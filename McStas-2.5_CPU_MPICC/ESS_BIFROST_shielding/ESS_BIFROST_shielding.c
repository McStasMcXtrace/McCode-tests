/* Automatically generated file. Do not edit. 
 * Format:     ANSI C source code
 * Creator:    McStas <http://www.mcstas.org>
 * Instrument: /zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr (ESS_BIFROST_shielding)
 * Date:       Wed Feb 26 18:36:55 2020
 * File:       ./ESS_BIFROST_shielding.c
 * Compile:    cc -o ESS_BIFROST_shielding.out ./ESS_BIFROST_shielding.c 
 * CFLAGS=
 */


#define MCCODE_STRING "McStas 2.5 - Feb. 26, 2020"
#define FLAVOR "mcstas"
#define FLAVOR_UPPER "MCSTAS"
#define MC_USE_DEFAULT_MAIN
#define MC_TRACE_ENABLED
#define MC_EMBEDDED_RUNTIME

#line 1 "mccode-r.h"
/*******************************************************************************
*
* McCode, neutron/xray ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mccode-r.h
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McStas 2.5
* Version: $Revision$
*
* Runtime system header for McStas/McXtrace.
*
* In order to use this library as an external library, the following variables
* and macros must be declared (see details in the code)
*
*   struct mcinputtable_struct mcinputtable[];
*   int mcnumipar;
*   char mcinstrument_name[], mcinstrument_source[];
*   int mctraceenabled, mcdefaultmain;
*   extern MCNUM  mccomp_storein[];
*   extern MCNUM  mcAbsorbProp[];
*   extern MCNUM  mcScattered;
*   #define MCCODE_STRING "the McStas/McXtrace version"
*
* Usage: Automatically embbeded in the c code.
*
* $Id$
*
*******************************************************************************/

#ifndef MCCODE_R_H
#define MCCODE_R_H "$Revision$"

#include <math.h>
#include <string.h>
#include <strings.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <limits.h>
#include <errno.h>
#include <time.h>
#include <float.h>
#include <inttypes.h>

/* If the runtime is embedded in the simulation program, some definitions can
   be made static. */

#ifdef MC_EMBEDDED_RUNTIME
#define mcstatic static
#else
#define mcstatic
#endif

#ifdef __dest_os
#if (__dest_os == __mac_os)
#define MAC
#endif
#endif

#ifdef __FreeBSD__
#define NEED_STAT_H
#endif

#if defined(__APPLE__) && defined(__GNUC__)
#define NEED_STAT_H
#endif

#ifdef NEED_STAT_H
#include <sys/stat.h>
#endif

#ifndef MC_PATHSEP_C
#ifdef WIN32
#define MC_PATHSEP_C '\\'
#define MC_PATHSEP_S "\\"
#else  /* !WIN32 */
#define MC_PATHSEP_C '/'
#define MC_PATHSEP_S "/"
#endif /* !WIN32 */
#endif /* MC_PATHSEP_C */

#ifndef WIN32
#ifndef _POSIX_SOURCE
#define _POSIX_SOURCE 1
#endif
#endif

/* the version string is replaced when building distribution with mkdist */
#ifndef MCCODE_STRING
#define MCCODE_STRING "McStas 2.5 - Feb. 26, 2020"
#endif

#ifndef MCCODE_DATE
#define MCCODE_DATE "Feb. 26, 2020"
#endif

#ifndef MCCODE_VERSION
#define MCCODE_VERSION "2.5"
#endif

#ifndef MCCODE_NAME
#define MCCODE_NAME "McStas"
#endif

#ifndef MCCODE_PARTICLE
#define MCCODE_PARTICLE "neutron"
#endif

#ifndef MCCODE_LIBENV
#define MCCODE_LIBENV "MCSTAS"
#endif

#ifndef FLAVOR_UPPER
#define FLAVOR_UPPER MCCODE_NAME
#endif

#ifdef MC_PORTABLE
#ifndef NOSIGNALS
#define NOSIGNALS 1
#endif
#endif

#ifdef MAC
#ifndef NOSIGNALS
#define NOSIGNALS 1
#endif
#endif

#if (USE_MPI == 0)
#undef USE_MPI
#endif

#ifdef USE_MPI  /* default is to disable signals with MPI, as MPICH uses them to communicate */
#ifndef NOSIGNALS
#define NOSIGNALS 1
#endif
#endif

#if (NOSIGNALS == 0)
#undef NOSIGNALS
#endif

/* Note: the enum instr_formal_types definition MUST be kept
   synchronized with the one in mccode.h and with the
   instr_formal_type_names array in cogen.c. */
enum instr_formal_types
  {
    instr_type_double, instr_type_int, instr_type_string
  };
struct mcinputtable_struct { /* defines instrument parameters */
  char *name; /* name of parameter */
  void *par;  /* pointer to instrument parameter (variable) */
  enum instr_formal_types type;
  char *val;  /* default value */
};

typedef double MCNUM;
typedef struct {MCNUM x, y, z;} Coords;
typedef MCNUM Rotation[3][3];

/* the following variables are defined in the McStas generated C code
   but should be defined externally in case of independent library usage */
#ifndef DANSE
extern struct mcinputtable_struct mcinputtable[]; /* list of instrument parameters */
extern int    mcnumipar;                          /* number of instrument parameters */
extern char   mcinstrument_name[], mcinstrument_source[]; /* instrument name and filename */
extern char  *mcinstrument_exe;                           /* executable path = argv[0] or NULL */
extern MCNUM  mccomp_storein[]; /* 11 coords * number of components in instrument */
extern MCNUM  mcAbsorbProp[];
extern MCNUM  mcScattered;      /* number of SCATTER calls in current component */
extern MCNUM  mcRestore;        /* Flag to indicate if neutron needs to be restored */
#ifndef MC_ANCIENT_COMPATIBILITY
extern int mctraceenabled, mcdefaultmain;
#endif
#endif


/* Useful macros ============================================================ */

/* MPI stuff */

#ifdef USE_MPI
#include "mpi.h"

#ifdef OMPI_MPI_H  /* openmpi does not use signals: we may install our sighandler */
#undef NOSIGNALS
#endif

/*
 * MPI_MASTER(i):
 * execution of i only on master node
 */
#define MPI_MASTER(statement) { \
  if(mpi_node_rank == mpi_node_root)\
  { statement; } \
}

#ifndef MPI_REDUCE_BLOCKSIZE
#define MPI_REDUCE_BLOCKSIZE 1000
#endif

int mc_MPI_Sum(double* buf, long count);
int mc_MPI_Send(void *sbuf, long count, MPI_Datatype dtype, int dest);
int mc_MPI_Recv(void *rbuf, long count, MPI_Datatype dtype, int source);

/* MPI_Finalize exits gracefully and should be preferred to MPI_Abort */
#define exit(code) do {                                   \
    MPI_Finalize();                                       \
    exit(code);                                           \
  } while(0)

#else /* !USE_MPI */
#define MPI_MASTER(instr) instr
#endif /* USE_MPI */

#ifdef USE_MPI
static int mpi_node_count;
#endif

#ifdef USE_THREADS  /* user want threads */
#error Threading (USE_THREADS) support has been removed for very poor efficiency. Use MPI/SSH grid instead.
#endif


void   mcset_ncount(unsigned long long count);    /* wrapper to get mcncount */
unsigned long long int mcget_ncount(void);            /* wrapper to set mcncount */
unsigned long long mcget_run_num(void);           /* wrapper to get mcrun_num=0:mcncount */


/* Following part is only embedded when not redundant with mccode.h ========= */

#ifndef MCCODE_H

#ifndef NOSIGNALS
#include <signal.h>
#define SIG_MESSAGE(msg) strcpy(mcsig_message, msg);
#else
#define SIG_MESSAGE(msg)
#endif /* !NOSIGNALS */

/* Useful macros and constants ============================================== */

#ifndef FLT_MAX
#define FLT_MAX         3.40282347E+38F /* max decimal value of a "float" */
#endif

#ifndef MIN
#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
#endif
#ifndef SQR
#define SQR(x) ( (x) * (x) )
#endif
#ifndef SIGN
#define SIGN(x) (((x)>0.0)?(1):(-1))
#endif

#ifndef PI
# ifdef M_PI
#  define PI M_PI
# else
/* When using c99 in the CFLAGS, some of these consts
   are lost... Perhaps we should in fact include everything from
   https://www.gnu.org/software/libc/manual/html_node/Mathematical-Constants.html
*/
#  define PI 3.14159265358979323846
#  define M_PI PI
#  define M_PI_2 M_PI/2.0
#  define M_PI_4 M_PI/4.0
#  define M_1_PI 1.0/M_PI
#  define M_2_PI 2*M_1_PI
#  define M_2_SQRTPI 2/sqrt(M_PI)
#  define M_SQRT2 sqrt(2)
#  define M_SQRT1_2 sqrt(1/2)
# endif
#endif

#define RAD2MIN  ((180*60)/PI)
#define MIN2RAD  (PI/(180*60))
#define DEG2RAD  (PI/180)
#define RAD2DEG  (180/PI)
#define FWHM2RMS 0.424660900144    /* Convert between full-width-half-max and */
#define RMS2FWHM 2.35482004503     /* root-mean-square (standard deviation) */
#define HBAR     1.05457168e-34    /* [Js] h bar Planck constant CODATA 2002 */
#define MNEUTRON 1.67492728e-27    /* [kg] mass of neutron CODATA 2002 */
#define GRAVITY  9.81              /* [m/s^2] gravitational acceleration */
#define NA       6.02214179e23     /* [#atoms/g .mole] Avogadro's number*/


/* wrapper to get absolute and relative position of comp */
/* mccomp_posa and mccomp_posr are defined in McStas generated C code */
#define POS_A_COMP_INDEX(index) \
    (mccomp_posa[index])
#define POS_R_COMP_INDEX(index) \
    (mccomp_posr[index])
/* number of SCATTER calls in current comp: mcScattered defined in generated C code */
#define SCATTERED mcScattered
/* Flag to indicate if neutron needs to be restored: mcRestore defined in generated C code */
#define RESTORE mcRestore


/* Retrieve component information from the kernel */
/* Name, position and orientation (both absolute and relative)  */
/* Any component: For "redundancy", see comment by KN */
#define tmp_name_comp(comp) #comp
#define NAME_COMP(comp) tmp_name_comp(comp)
#define tmp_pos_a_comp(comp) (mcposa ## comp)
#define POS_A_COMP(comp) tmp_pos_a_comp(comp)
#define tmp_pos_r_comp(comp) (mcposr ## comp)
#define POS_R_COMP(comp) tmp_pos_r_comp(comp)
#define tmp_rot_a_comp(comp) (mcrota ## comp)
#define ROT_A_COMP(comp) tmp_rot_a_comp(comp)
#define tmp_rot_r_comp(comp) (mcrotr ## comp)
#define ROT_R_COMP(comp) tmp_rot_r_comp(comp)

/* Current component name, index, position and orientation */
#define NAME_CURRENT_COMP  NAME_COMP(mccompcurname)
#define INDEX_CURRENT_COMP mccompcurindex
#define POS_A_CURRENT_COMP POS_A_COMP(mccompcurname)
#define POS_R_CURRENT_COMP POS_R_COMP(mccompcurname)
#define ROT_A_CURRENT_COMP ROT_A_COMP(mccompcurname)
#define ROT_R_CURRENT_COMP ROT_R_COMP(mccompcurname)

/* Note: The two-stage approach to MC_GETPAR is NOT redundant; without it,
* after #define C sample, MC_GETPAR(C,x) would refer to component C, not to
* component sample. Such are the joys of ANSI C.

* Anyway the usage of MCGETPAR requires that we use sometimes bare names...
*/
#define MC_GETPAR2(comp, par) (mcc ## comp ## _ ## par)
#define MC_GETPAR(comp, par) MC_GETPAR2(comp,par)

/* MCDISPLAY/trace and debugging message sent to stdout */
#ifdef MC_TRACE_ENABLED
#define DEBUG
#endif

#ifdef DEBUG
#define mcDEBUG_INSTR() if(!mcdotrace); else { printf("\nINSTRUMENT:\n"); printf("Instrument '%s' (%s)\n", mcinstrument_name, mcinstrument_source); }
#define mcDEBUG_COMPONENT(name,c,t) if(!mcdotrace); else {\
  printf("COMPONENT: \"%s\"\n" \
         "POS: %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", \
         name, c.x, c.y, c.z, t[0][0], t[0][1], t[0][2], \
         t[1][0], t[1][1], t[1][2], t[2][0], t[2][1], t[2][2]); \
  mcAccumulatedILength += coords_len(coords_sub(mcLastComp,c)); \
  printf("Component %30s AT (%g,%g,%g)    %g m from origin\n", name, c.x, c.y, c.z, mcAccumulatedILength); \
  mcLastComp=c;\
  }
#define mcDEBUG_INSTR_END() if(!mcdotrace); else printf("INSTRUMENT END:\n");
#define mcDEBUG_ENTER() if(!mcdotrace); else printf("ENTER:\n");
#define mcDEBUG_COMP(c) if(!mcdotrace); else printf("COMP: \"%s\"\n", c);
#define mcDEBUG_LEAVE() if(!mcdotrace); else printf("LEAVE:\n");
#define mcDEBUG_ABSORB() if(!mcdotrace); else printf("ABSORB:\n");
#else
#define mcDEBUG_INSTR()
#define mcDEBUG_COMPONENT(name,c,t)
#define mcDEBUG_INSTR_END()
#define mcDEBUG_ENTER()
#define mcDEBUG_COMP(c)
#define mcDEBUG_LEAVE()
#define mcDEBUG_ABSORB()
#endif

// mcDEBUG_STATE and mcDEBUG_SCATTER are defined by mcstas-r.h and mcxtrace-r.h



#ifdef TEST
#define test_printf printf
#else
#define test_printf while(0) printf
#endif

/* send MCDISPLAY message to stdout to show gemoetry */
void mcdis_magnify(char *what);
void mcdis_line(double x1, double y1, double z1,
                double x2, double y2, double z2);
void mcdis_dashed_linemcdis_dashed_line(double x1, double y1, double z1,
		       double x2, double y2, double z2, int n);
void mcdis_multiline(int count, ...);
void mcdis_rectangle(char* plane, double x, double y, double z,
		     double width, double height);
void mcdis_box(double x, double y, double z,
	       double width, double height, double length);
void mcdis_circle(char *plane, double x, double y, double z, double r);
void mcdis_Circle(double x, double y, double z, double r, double nx, double ny, double nz);
void mcdis_cylinder( double x, double y, double z,
        double r, double height, int N, double nx, double ny, double nz);
void mcdis_sphere(double x, double y, double z, double r, int N);

/* selection of random number generator. default is MT */
#ifndef MC_RAND_ALG
#define MC_RAND_ALG 1
#endif

#if MC_RAND_ALG == 0
   /* Use system random() (not recommended). */
#  define MC_RAND_MAX RAND_MAX
#elif MC_RAND_ALG == 1
   /* "Mersenne Twister", by Makoto Matsumoto and Takuji Nishimura. */
#  define MC_RAND_MAX ((unsigned long)0xffffffff)
#  define random mt_random
#  define srandom mt_srandom
#elif MC_RAND_ALG == 2
   /* Algorithm used in McStas CVS-080208 and earlier (not recommended). */
#  define MC_RAND_MAX 0x7fffffff
#  define random mc_random
#  define srandom mc_srandom
#else
#  error "Bad value for random number generator choice."
#endif

typedef int mc_int32_t;
mc_int32_t mc_random(void);
void mc_srandom (unsigned int x);
unsigned long mt_random(void);
void mt_srandom (unsigned long x);

double rand01();
double randpm1();
double rand0max(double max);
double randminmax(double min, double max);

double randnorm(void);
double randtriangle(void);

#ifndef DANSE
void mcinit(void);
void mcraytrace(void);
void mcsave(FILE *);
void mcfinally(void);
void mcdisplay(void);
#endif

/* simple vector algebra ==================================================== */
#define vec_prod(x, y, z, x1, y1, z1, x2, y2, z2) \
	vec_prod_func(&x, &y, &z, x1, y1, z1, x2, y2, z2)
mcstatic void vec_prod_func(double *x, double *y, double *z,
		double x1, double y1, double z1, double x2, double y2, double z2);

mcstatic double scalar_prod(
		double x1, double y1, double z1, double x2, double y2, double z2);

#define NORM(x,y,z) \
	norm_func(&x, &y, &z)
mcstatic void norm_func(double *x, double *y, double *z) {
	double temp = (*x * *x) + (*y * *y) + (*z * *z);
	if (temp != 0) {
		temp = sqrt(temp);
		*x /= temp;
		*y /= temp;
		*z /= temp;
	}
}
#define normal_vec(nx, ny, nz, x, y, z) \
    normal_vec_func(&(nx), &(ny), &(nz), x, y, z)
mcstatic void normal_vec_func(double *nx, double *ny, double *nz,
    double x, double y, double z);

/**
 * Rotate the vector vx,vy,vz psi radians around the vector ax,ay,az
 * and put the result in x,y,z.
 */
#define rotate(x, y, z, vx, vy, vz, phi, ax, ay, az) \
  do { \
    double mcrt_tmpx = (ax), mcrt_tmpy = (ay), mcrt_tmpz = (az); \
    double mcrt_vp, mcrt_vpx, mcrt_vpy, mcrt_vpz; \
    double mcrt_vnx, mcrt_vny, mcrt_vnz, mcrt_vn1x, mcrt_vn1y, mcrt_vn1z; \
    double mcrt_bx, mcrt_by, mcrt_bz; \
    double mcrt_cos, mcrt_sin; \
    NORM(mcrt_tmpx, mcrt_tmpy, mcrt_tmpz); \
    mcrt_vp = scalar_prod((vx), (vy), (vz), mcrt_tmpx, mcrt_tmpy, mcrt_tmpz); \
    mcrt_vpx = mcrt_vp*mcrt_tmpx; \
    mcrt_vpy = mcrt_vp*mcrt_tmpy; \
    mcrt_vpz = mcrt_vp*mcrt_tmpz; \
    mcrt_vnx = (vx) - mcrt_vpx; \
    mcrt_vny = (vy) - mcrt_vpy; \
    mcrt_vnz = (vz) - mcrt_vpz; \
    vec_prod(mcrt_bx, mcrt_by, mcrt_bz, \
             mcrt_tmpx, mcrt_tmpy, mcrt_tmpz, mcrt_vnx, mcrt_vny, mcrt_vnz); \
    mcrt_cos = cos((phi)); mcrt_sin = sin((phi)); \
    mcrt_vn1x = mcrt_vnx*mcrt_cos + mcrt_bx*mcrt_sin; \
    mcrt_vn1y = mcrt_vny*mcrt_cos + mcrt_by*mcrt_sin; \
    mcrt_vn1z = mcrt_vnz*mcrt_cos + mcrt_bz*mcrt_sin; \
    (x) = mcrt_vpx + mcrt_vn1x; \
    (y) = mcrt_vpy + mcrt_vn1y; \
    (z) = mcrt_vpz + mcrt_vn1z; \
  } while(0)

/**
 * Mirror (xyz) in the plane given by the point (rx,ry,rz) and normal (nx,ny,nz)
 *
 * TODO: This define is seemingly never used...
 */
#define mirror(x,y,z,rx,ry,rz,nx,ny,nz) \
  do { \
    double mcrt_tmpx= (nx), mcrt_tmpy = (ny), mcrt_tmpz = (nz); \
    double mcrt_tmpt; \
    NORM(mcrt_tmpx, mcrt_tmpy, mcrt_tmpz); \
    mcrt_tmpt=scalar_prod((rx),(ry),(rz),mcrt_tmpx,mcrt_tmpy,mcrt_tmpz); \
    (x) = rx -2 * mcrt_tmpt*mcrt_rmpx; \
    (y) = ry -2 * mcrt_tmpt*mcrt_rmpy; \
    (z) = rz -2 * mcrt_tmpt*mcrt_rmpz; \
  } while (0)

Coords coords_set(MCNUM x, MCNUM y, MCNUM z);
Coords coords_get(Coords a, MCNUM *x, MCNUM *y, MCNUM *z);
Coords coords_add(Coords a, Coords b);
Coords coords_sub(Coords a, Coords b);
Coords coords_neg(Coords a);
Coords coords_scale(Coords b, double scale);
double coords_sp(Coords a, Coords b);
Coords coords_xp(Coords b, Coords c);
double coords_len(Coords a);
void   coords_print(Coords a);
mcstatic void coords_norm(Coords* c);

void rot_set_rotation(Rotation t, double phx, double phy, double phz);
int  rot_test_identity(Rotation t);
void rot_mul(Rotation t1, Rotation t2, Rotation t3);
void rot_copy(Rotation dest, Rotation src);
void rot_transpose(Rotation src, Rotation dst);
Coords rot_apply(Rotation t, Coords a);

void mccoordschange(Coords a, Rotation t, double *x, double *y, double *z,
    double *vx, double *vy, double *vz, double *sx, double *sy, double *sz);
void
mccoordschange_polarisation(Rotation t, double *sx, double *sy, double *sz);

double mcestimate_error(double N, double p1, double p2);
void mcreadparams(void);

/* this is now in mcstas-r.h and mcxtrace-r.h as the number of state parameters is no longer equal*/
/* void mcsetstate(double x, double y, double z, double vx, double vy, double vz,
                double t, double sx, double sy, double sz, double p);
*/
void mcgenstate(void);

/* trajectory/shape intersection routines */
int inside_rectangle(double, double, double, double);
int box_intersect(double *dt_in, double *dt_out, double x, double y, double z,
    double vx, double vy, double vz, double dx, double dy, double dz);
int cylinder_intersect(double *t0, double *t1, double x, double y, double z,
    double vx, double vy, double vz, double r, double h);
int sphere_intersect(double *t0, double *t1, double x, double y, double z,
                 double vx, double vy, double vz, double r);
/* second order equation roots */
int solve_2nd_order(double *t1, double *t2,
    double A,  double B,  double C);

/* random vector generation to shape */
void randvec_target_circle(double *xo, double *yo, double *zo,
    double *solid_angle, double xi, double yi, double zi, double radius);
#define randvec_target_sphere randvec_target_circle
void randvec_target_rect_angular(double *xo, double *yo, double *zo,
    double *solid_angle,
               double xi, double yi, double zi, double height, double width, Rotation A);
#define randvec_target_rect(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9)  randvec_target_rect_real(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,0,0,0,1)
void randvec_target_rect_real(double *xo, double *yo, double *zo,
    double *solid_angle,
	       double xi, double yi, double zi, double height, double width, Rotation A,
			 double lx, double ly, double lz, int order);

/* this is the main() */
int mccode_main(int argc, char *argv[]);


#endif /* !MCCODE_H */

#ifndef MCCODE_R_IO_H
#define MCCODE_R_IO_H "$Revision$"

#if (USE_NEXUS == 0)
#undef USE_NEXUS
#endif

#ifndef CHAR_BUF_LENGTH
#define CHAR_BUF_LENGTH 1024
#endif

/* I/O section part ========================================================= */

/* ========================================================================== */

/*                               MCCODE_R_IO_C                                */

/* ========================================================================== */


/* main DETECTOR structure which stores most information to write to data files */
struct mcdetector_struct {
  char   filename[CHAR_BUF_LENGTH];   /* file name of monitor */
  char   position[CHAR_BUF_LENGTH];   /* position of detector component */
  char   component[CHAR_BUF_LENGTH];  /* component instance name */
  char   instrument[CHAR_BUF_LENGTH]; /* instrument name */
  char   type[CHAR_BUF_LENGTH];       /* data type, e.g. 0d, 1d, 2d, 3d */
  char   user[CHAR_BUF_LENGTH];       /* user name, e.g. HOME */
  char   date[CHAR_BUF_LENGTH];       /* date of simulation end/write time */
  char   title[CHAR_BUF_LENGTH];      /* title of detector */
  char   xlabel[CHAR_BUF_LENGTH];     /* X axis label */
  char   ylabel[CHAR_BUF_LENGTH];     /* Y axis label */
  char   zlabel[CHAR_BUF_LENGTH];     /* Z axis label */
  char   xvar[CHAR_BUF_LENGTH];       /* X variable name */
  char   yvar[CHAR_BUF_LENGTH];       /* Y variable name */
  char   zvar[CHAR_BUF_LENGTH];       /* Z variable name */
  char   ncount[CHAR_BUF_LENGTH];     /* number of events initially generated */
  char   limits[CHAR_BUF_LENGTH];     /* X Y Z limits, e.g. [xmin xmax ymin ymax zmin zmax] */
  char   variables[CHAR_BUF_LENGTH];  /* variables written into data block */
  char   statistics[CHAR_BUF_LENGTH]; /* center, mean and half width along axis */
  char   signal[CHAR_BUF_LENGTH];     /* min max and mean of signal (data block) */
  char   values[CHAR_BUF_LENGTH];     /* integrated values e.g. [I I_err N] */
  double xmin,xmax;                   /* min max of axes */
  double ymin,ymax;
  double zmin,zmax;
  double intensity;                   /* integrated values for data block */
  double error;
  double events;
  double min;                         /* statistics for data block */
  double max;
  double mean;
  double centerX;                     /* statistics for axes */
  double halfwidthX;
  double centerY;
  double halfwidthY;
  int    rank;                        /* dimensionaly of monitor, e.g. 0 1 2 3 */
  char   istransposed;                /* flag to transpose matrix for some formats */

  long   m,n,p;                       /* dimensions of data block and along axes */
  long   date_l;                      /* same as date, but in sec since 1970 */

  double *p0, *p1, *p2;               /* pointers to saved data, NULL when freed */
  char   format[CHAR_BUF_LENGTH];    /* format for file generation */
};

typedef struct mcdetector_struct MCDETECTOR;

static   char *mcdirname             = NULL;      /* name of output directory */
static   char *mcsiminfo_name        = "mccode";  /* default output sim file name */
char    *mcformat                    = NULL;      /* NULL (default) or a specific format */

/* file I/O definitions and function prototypes */

#ifndef MC_EMBEDDED_RUNTIME /* the mcstatic variables (from mccode-r.c) */
extern FILE * mcsiminfo_file;     /* handle to the output siminfo file */
extern int    mcgravitation;      /* flag to enable gravitation */
extern int    mcdotrace;          /* flag to print MCDISPLAY messages */
#else
mcstatic FILE *mcsiminfo_file        = NULL;
#endif

/* I/O function prototypes ================================================== */

/* output functions */
MCDETECTOR mcdetector_out_0D(char *t, double p0, double p1, double p2, char *c, Coords pos);
MCDETECTOR mcdetector_out_1D(char *t, char *xl, char *yl,
                  char *xvar, double x1, double x2, long n,
                  double *p0, double *p1, double *p2, char *f, char *c, Coords pos);
MCDETECTOR mcdetector_out_2D(char *t, char *xl, char *yl,
                  double x1, double x2, double y1, double y2, long m,
                  long n, double *p0, double *p1, double *p2, char *f,
                  char *c, Coords pos);
MCDETECTOR mcdetector_out_list(char *t, char *xl, char *yl,
                  long m, long n,
                  double *p1, char *f,
                  char *c, Coords posa);

/* wrappers to output functions, that automatically set NAME and POSITION */
#define DETECTOR_OUT(p0,p1,p2) mcdetector_out_0D(NAME_CURRENT_COMP,p0,p1,p2,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)
#define DETECTOR_OUT_0D(t,p0,p1,p2) mcdetector_out_0D(t,p0,p1,p2,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)
#define DETECTOR_OUT_1D(t,xl,yl,xvar,x1,x2,n,p0,p1,p2,f) \
     mcdetector_out_1D(t,xl,yl,xvar,x1,x2,n,p0,p1,p2,f,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)
#define DETECTOR_OUT_2D(t,xl,yl,x1,x2,y1,y2,m,n,p0,p1,p2,f) \
     mcdetector_out_2D(t,xl,yl,x1,x2,y1,y2,m,n,p0,p1,p2,f,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)

#ifdef USE_NEXUS
#include "napi.h"
NXhandle nxhandle;
#endif

#endif /* ndef MCCODE_R_IO_H */

#endif /* MCCODE_R_H */
/* End of file "mccode-r.h". */

#line 712 "./ESS_BIFROST_shielding.c"

#line 1 "mcstas-r.h"
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mcstas-r.h
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McStas X.Y
* Version: $Revision$
*
* Runtime system header for McStas.
*
* In order to use this library as an external library, the following variables
* and macros must be declared (see details in the code)
*
*   struct mcinputtable_struct mcinputtable[];
*   int mcnumipar;
*   char mcinstrument_name[], mcinstrument_source[];
*   int mctraceenabled, mcdefaultmain;
*   extern MCNUM  mccomp_storein[];
*   extern MCNUM  mcAbsorbProp[];
*   extern MCNUM  mcScattered;
*   #define MCCODE_STRING "the McStas version"
*
* Usage: Automatically embbeded in the c code.
*
* $Id$
*
*******************************************************************************/

#ifndef MCSTAS_R_H
#define MCSTAS_R_H "$Revision$"

/* Following part is only embedded when not redundent with mcstas.h ========= */

#ifndef MCCODE_H

#define AA2MS    629.622368        /* Convert k[1/AA] to v[m/s] */
#define MS2AA    1.58825361e-3     /* Convert v[m/s] to k[1/AA] */
#define K2V      AA2MS
#define V2K      MS2AA
#define Q2V      AA2MS
#define V2Q      MS2AA
#define SE2V     437.393377        /* Convert sqrt(E)[meV] to v[m/s] */
#define VS2E     5.22703725e-6     /* Convert (v[m/s])**2 to E[meV] */

#define SCATTER do {mcDEBUG_SCATTER(mcnlx, mcnly, mcnlz, mcnlvx, mcnlvy, mcnlvz, \
        mcnlt,mcnlsx,mcnlsy,mcnlsz, mcnlp); mcScattered++;} while(0)
#define ABSORB do {mcDEBUG_STATE(mcnlx, mcnly, mcnlz, mcnlvx, mcnlvy, mcnlvz, \
        mcnlt,mcnlsx,mcnlsy,mcnlsz, mcnlp); mcDEBUG_ABSORB(); MAGNET_OFF; goto mcabsorb;} while(0)

#define STORE_NEUTRON(index, x, y, z, vx, vy, vz, t, sx, sy, sz, p) \
  mcstore_neutron(mccomp_storein,index, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
#define RESTORE_NEUTRON(index, x, y, z, vx, vy, vz, t, sx, sy, sz, p) \
  mcrestore_neutron(mccomp_storein,index, &x, &y, &z, &vx, &vy, &vz, &t, &sx, &sy, &sz, &p);

#define MAGNET_ON \
  do { \
    mcMagnet = 1; \
  } while(0)

#define MAGNET_OFF \
  do { \
    mcMagnet = 0; \
  } while(0)

#define ALLOW_BACKPROP \
  do { \
    mcallowbackprop = 1; \
  } while(0)

#define DISALLOW_BACKPROP \
  do { \
    mcallowbackprop = 0; \
  } while(0)

#define PROP_MAGNET(dt) \
  do { \
  }while (0)
    /* change coordinates from local system to magnet system */
/*    Rotation rotLM, rotTemp; \
      Coords   posLM = coords_sub(POS_A_CURRENT_COMP, mcMagnetPos); \
      rot_transpose(ROT_A_CURRENT_COMP, rotTemp); \
      rot_mul(rotTemp, mcMagnetRot, rotLM); \
      mcMagnetPrecession(mcnlx, mcnly, mcnlz, mcnlt, mcnlvx, mcnlvy, mcnlvz, \
               &mcnlsx, &mcnlsy, &mcnlsz, dt, posLM, rotLM); \
      } while(0)
*/

#define mcPROP_DT(dt) \
  do { \
    if (mcMagnet && dt > 0) PROP_MAGNET(dt);\
    mcnlx += mcnlvx*(dt); \
    mcnly += mcnlvy*(dt); \
    mcnlz += mcnlvz*(dt); \
    mcnlt += (dt); \
    if (isnan(p) || isinf(p)) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }\
  } while(0)

/* ADD: E. Farhi, Aug 6th, 2001 PROP_GRAV_DT propagation with acceleration */
#define PROP_GRAV_DT(dt, Ax, Ay, Az) \
  do { \
    if(dt < 0 && mcallowbackprop == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }\
    if (mcMagnet) printf("Spin precession gravity\n"); \
    mcnlx  += mcnlvx*(dt) + (Ax)*(dt)*(dt)/2; \
    mcnly  += mcnlvy*(dt) + (Ay)*(dt)*(dt)/2; \
    mcnlz  += mcnlvz*(dt) + (Az)*(dt)*(dt)/2; \
    mcnlvx += (Ax)*(dt); \
    mcnlvy += (Ay)*(dt); \
    mcnlvz += (Az)*(dt); \
    mcnlt  += (dt); \
    DISALLOW_BACKPROP;\
  } while(0)


#define PROP_DT(dt) \
  do { \
    if(dt < 0) { RESTORE=1; goto mcabsorbComp; }; \
    if (mcgravitation) { Coords mcLocG; double mc_gx, mc_gy, mc_gz; \
    mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,-GRAVITY,0)); \
    coords_get(mcLocG, &mc_gx, &mc_gy, &mc_gz); \
    PROP_GRAV_DT(dt, mc_gx, mc_gy, mc_gz); } \
    else mcPROP_DT(dt); \
    DISALLOW_BACKPROP;\
  } while(0)


#define PROP_Z0 \
  do { \
    if (mcgravitation) { Coords mcLocG; int mc_ret; \
    double mc_dt, mc_gx, mc_gy, mc_gz; \
    mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,-GRAVITY,0)); \
    coords_get(mcLocG, &mc_gx, &mc_gy, &mc_gz); \
    mc_ret = solve_2nd_order(&mc_dt, NULL, -mc_gz/2, -mcnlvz, -mcnlz); \
    if (mc_ret && mc_dt>=0) {PROP_GRAV_DT(mc_dt, mc_gx, mc_gy, mc_gz); mcnlz=0;}\
    else { if (mcallowbackprop ==0) {mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }}; }\
    else mcPROP_Z0; \
    DISALLOW_BACKPROP;\
  } while(0)

#define mcPROP_Z0 \
  do { \
    double mc_dt; \
    if(mcnlvz == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mc_dt = -mcnlz/mcnlvz; \
    if(mc_dt < 0 && mcallowbackprop == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mcPROP_DT(mc_dt); \
    mcnlz = 0; \
    DISALLOW_BACKPROP;\
  } while(0)

#define PROP_X0 \
  do { \
    if (mcgravitation) { Coords mcLocG; int mc_ret; \
    double mc_dt, mc_gx, mc_gy, mc_gz; \
    mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,-GRAVITY,0)); \
    coords_get(mcLocG, &mc_gx, &mc_gy, &mc_gz); \
    mc_ret = solve_2nd_order(&mc_dt, NULL, -mc_gx/2, -mcnlvx, -mcnlx); \
    if (mc_ret && mc_dt>=0) PROP_GRAV_DT(mc_dt, mc_gx, mc_gy, mc_gz); \
    else { if (mcallowbackprop ==0) {mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }}; }\
    else mcPROP_X0; \
    DISALLOW_BACKPROP;\
  } while(0)

#define mcPROP_X0 \
  do { \
    double mc_dt; \
    if(mcnlvx == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mc_dt = -mcnlx/mcnlvx; \
    if(mc_dt < 0 && mcallowbackprop == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mcPROP_DT(mc_dt); \
    mcnlx = 0; \
    DISALLOW_BACKPROP;\
  } while(0)

#define PROP_Y0 \
  do { \
    if (mcgravitation) { Coords mcLocG; int mc_ret; \
    double mc_dt, mc_gx, mc_gy, mc_gz; \
    mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,-GRAVITY,0)); \
    coords_get(mcLocG, &mc_gx, &mc_gy, &mc_gz); \
    mc_ret = solve_2nd_order(&mc_dt, NULL, -mc_gy/2, -mcnlvy, -mcnly); \
    if (mc_ret && mc_dt>=0) PROP_GRAV_DT(mc_dt, mc_gx, mc_gy, mc_gz); \
    else { if (mcallowbackprop ==0) {mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }}; }\
    else mcPROP_Y0; \
    DISALLOW_BACKPROP;\
  } while(0)


#define mcPROP_Y0 \
  do { \
    double mc_dt; \
    if(mcnlvy == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mc_dt = -mcnly/mcnlvy; \
    if(mc_dt < 0 && mcallowbackprop == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mcPROP_DT(mc_dt); \
    mcnly = 0; \
    DISALLOW_BACKPROP; \
  } while(0)

/*moved from mccode-r.h*/
void mcsetstate(double x, double y, double z, double vx, double vy, double vz,
                double t, double sx, double sy, double sz, double p);

#ifdef DEBUG

#define mcDEBUG_STATE(x,y,z,vx,vy,vz,t,sx,sy,sz,p) if(!mcdotrace); else \
  printf("STATE: %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", \
         x,y,z,vx,vy,vz,t,sx,sy,sz,p);
#define mcDEBUG_SCATTER(x,y,z,vx,vy,vz,t,sx,sy,sz,p) if(!mcdotrace); else \
  printf("SCATTER: %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", \
         x,y,z,vx,vy,vz,t,sx,sy,sz,p);

#else

#define mcDEBUG_STATE(x,y,z,vx,vy,vz,t,sx,sy,sz,p)
#define mcDEBUG_SCATTER(x,y,z,vx,vy,vz,t,sx,sy,sz,p)

#endif

#endif /* !MCCODE_H */

#endif /* MCSTAS_R_H */
/* End of file "mcstas-r.h". */

#line 945 "./ESS_BIFROST_shielding.c"

#line 1 "mccode-r.c"
/*******************************************************************************
*
* McCode, neutron/xray ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mccode-r.c
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McStas X.Y/McXtrace X.Y
* Version: $Revision$
*
* Runtime system for McStas and McXtrace.
* Embedded within instrument in runtime mode.
* Contains SECTIONS:
*   MPI handling (sum, send, recv)
*   format definitions
*   I/O
*   mcdisplay support
*   random numbers
*   coordinates handling
*   vectors math (solve 2nd order, normals, randvec...)
*   parameter handling
*   signal and main handlers
*
* Usage: Automatically embbeded in the c code whenever required.
*
* $Id$
*
*******************************************************************************/

/*******************************************************************************
* The I/O format definitions and functions
*******************************************************************************/


/** Include header files to avoid implicit declarations (not allowed on LLVM) */
#include <ctype.h>
#include <sys/types.h>

// UNIX specific headers (non-Windows)
#if defined(__unix__) || defined(__APPLE__)
#include <unistd.h>
#endif

#include <sys/stat.h>

#ifdef _WIN32 
#include <direct.h>
# define  mkdir( D, M )   _mkdir( D ) 
#endif 

#ifndef DANSE
#ifdef MC_ANCIENT_COMPATIBILITY
int mctraceenabled = 0;
int mcdefaultmain  = 0;
#endif
/* else defined directly in the McCode generated C code */

static   long mcseed                 = 0; /* seed for random generator */
static   long mcstartdate            = 0; /* start simulation time */
static   int  mcdisable_output_files = 0; /* --no-output-files */
mcstatic int  mcgravitation          = 0; /* use gravitation flag, for PROP macros */
int      mcMagnet                    = 0; /* magnet stack flag */
mcstatic int  mcdotrace              = 0; /* flag for --trace and messages for DISPLAY */
int      mcallowbackprop             = 0;         /* flag to enable negative/backprop */

/* Number of particle histories to simulate. */
#ifdef NEUTRONICS
mcstatic unsigned long long int mcncount             = 1;
mcstatic unsigned long long int mcrun_num            = 0;
#else
mcstatic unsigned long long int mcncount             = 1000000;
mcstatic unsigned long long int mcrun_num            = 0;
#endif /* NEUTRONICS */

#else
#include "mcstas-globals.h"
#endif /* !DANSE */

/* SECTION: MPI handling ==================================================== */

#ifdef USE_MPI
/* MPI rank */
static int mpi_node_rank;
static int mpi_node_root = 0;


/*******************************************************************************
* mc_MPI_Reduce: Gathers arrays from MPI nodes using Reduce function.
*******************************************************************************/
int mc_MPI_Sum(double *sbuf, long count)
{
  if (!sbuf || count <= 0) return(MPI_SUCCESS); /* nothing to reduce */
  else {
    /* we must cut the buffer into blocks not exceeding the MPI max buffer size of 32000 */
    long   offset=0;
    double *rbuf=NULL;
    int    length=MPI_REDUCE_BLOCKSIZE; /* defined in mccode-r.h */
    int    i=0;
    rbuf = calloc(count, sizeof(double));
    if (!rbuf)
      exit(-fprintf(stderr, "Error: Out of memory %li (mc_MPI_Sum)\n", count*sizeof(double)));
    while (offset < count) {
      if (!length || offset+length > count-1) length=count-offset;
      else length=MPI_REDUCE_BLOCKSIZE;
      if (MPI_Reduce((double*)(sbuf+offset), (double*)(rbuf+offset),
              length, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD) != MPI_SUCCESS)
        return MPI_ERR_COUNT;
      offset += length;
    }

    for (i=0; i<count; i++) sbuf[i] = rbuf[i];
    free(rbuf);
  }
  return MPI_SUCCESS;
} /* mc_MPI_Sum */

/*******************************************************************************
* mc_MPI_Send: Send array to MPI node by blocks to avoid buffer limit
*******************************************************************************/
int mc_MPI_Send(void *sbuf,
                  long count, MPI_Datatype dtype,
                  int dest)
{
  int dsize;
  long offset=0;
  int  tag=1;
  int  length=MPI_REDUCE_BLOCKSIZE; /* defined in mccode-r.h */

  if (!sbuf || count <= 0) return(MPI_SUCCESS); /* nothing to send */
  MPI_Type_size(dtype, &dsize);

  while (offset < count) {
    if (offset+length > count-1) length=count-offset;
    else length=MPI_REDUCE_BLOCKSIZE;
    if (MPI_Send((void*)(sbuf+offset*dsize), length, dtype, dest, tag++, MPI_COMM_WORLD) != MPI_SUCCESS)
      return MPI_ERR_COUNT;
    offset += length;
  }

  return MPI_SUCCESS;
} /* mc_MPI_Send */

/*******************************************************************************
* mc_MPI_Recv: Receives arrays from MPI nodes by blocks to avoid buffer limit
*             the buffer must have been allocated previously.
*******************************************************************************/
int mc_MPI_Recv(void *sbuf,
                  long count, MPI_Datatype dtype,
                  int source)
{
  int dsize;
  long offset=0;
  int  tag=1;
  int  length=MPI_REDUCE_BLOCKSIZE; /* defined in mccode-r.h */

  if (!sbuf || count <= 0) return(MPI_SUCCESS); /* nothing to recv */
  MPI_Type_size(dtype, &dsize);

  while (offset < count) {
    if (offset+length > count-1) length=count-offset;
    else length=MPI_REDUCE_BLOCKSIZE;
    if (MPI_Recv((void*)(sbuf+offset*dsize), length, dtype, source, tag++,
            MPI_COMM_WORLD, MPI_STATUS_IGNORE) != MPI_SUCCESS)
      return MPI_ERR_COUNT;
    offset += length;
  }

  return MPI_SUCCESS;
} /* mc_MPI_Recv */

#endif /* USE_MPI */

/* SECTION: parameters handling ============================================= */

/* Instrument input parameter type handling. */
/*******************************************************************************
* mcparm_double: extract double value from 's' into 'vptr'
*******************************************************************************/
static int
mcparm_double(char *s, void *vptr)
{
  char *p;
  double *v = (double *)vptr;

  if (!s) { *v = 0; return(1); }
  *v = strtod(s, &p);
  if(*s == '\0' || (p != NULL && *p != '\0') || errno == ERANGE)
    return 0;                        /* Failed */
  else
    return 1;                        /* Success */
}

/*******************************************************************************
* mcparminfo_double: display parameter type double
*******************************************************************************/
static char *
mcparminfo_double(char *parmname)
{
  return "double";
}

/*******************************************************************************
* mcparmerror_double: display error message when failed extract double
*******************************************************************************/
static void
mcparmerror_double(char *parm, char *val)
{
  fprintf(stderr, "Error: Invalid value '%s' for floating point parameter %s (mcparmerror_double)\n",
          val, parm);
}

/*******************************************************************************
* mcparmprinter_double: convert double to string
*******************************************************************************/
static void
mcparmprinter_double(char *f, void *vptr)
{
  double *v = (double *)vptr;
  sprintf(f, "%g", *v);
}

/*******************************************************************************
* mcparm_int: extract int value from 's' into 'vptr'
*******************************************************************************/
static int
mcparm_int(char *s, void *vptr)
{
  char *p;
  int *v = (int *)vptr;
  long x;

  if (!s) { *v = 0; return(1); }
  *v = 0;
  x = strtol(s, &p, 10);
  if(x < INT_MIN || x > INT_MAX)
    return 0;                        /* Under/overflow */
  *v = x;
  if(*s == '\0' || (p != NULL && *p != '\0') || errno == ERANGE)
    return 0;                        /* Failed */
  else
    return 1;                        /* Success */
}

/*******************************************************************************
* mcparminfo_int: display parameter type int
*******************************************************************************/
static char *
mcparminfo_int(char *parmname)
{
  return "int";
}

/*******************************************************************************
* mcparmerror_int: display error message when failed extract int
*******************************************************************************/
static void
mcparmerror_int(char *parm, char *val)
{
  fprintf(stderr, "Error: Invalid value '%s' for integer parameter %s (mcparmerror_int)\n",
          val, parm);
}

/*******************************************************************************
* mcparmprinter_int: convert int to string
*******************************************************************************/
static void
mcparmprinter_int(char *f, void *vptr)
{
  int *v = (int *)vptr;
  sprintf(f, "%d", *v);
}

/*******************************************************************************
* mcparm_string: extract char* value from 's' into 'vptr' (copy)
*******************************************************************************/
static int
mcparm_string(char *s, void *vptr)
{
  char **v = (char **)vptr;
  if (!s) { *v = NULL; return(1); }
  *v = (char *)malloc(strlen(s) + 1);
  if(*v == NULL)
  {
    exit(-fprintf(stderr, "Error: Out of memory %li (mcparm_string).\n", (long)strlen(s) + 1));
  }
  strcpy(*v, s);
  return 1;                        /* Success */
}

/*******************************************************************************
* mcparminfo_string: display parameter type string
*******************************************************************************/
static char *
mcparminfo_string(char *parmname)
{
  return "string";
}

/*******************************************************************************
* mcparmerror_string: display error message when failed extract string
*******************************************************************************/
static void
mcparmerror_string(char *parm, char *val)
{
  fprintf(stderr, "Error: Invalid value '%s' for string parameter %s (mcparmerror_string)\n",
          val, parm);
}

/*******************************************************************************
* mcparmprinter_string: convert string to string (including esc chars)
*******************************************************************************/
static void
mcparmprinter_string(char *f, void *vptr)
{
  char **v = (char **)vptr;
  char *p;

  if (!*v) { *f='\0'; return; }
  strcpy(f, "");
  for(p = *v; *p != '\0'; p++)
  {
    switch(*p)
    {
      case '\n':
        strcat(f, "\\n");
        break;
      case '\r':
        strcat(f, "\\r");
        break;
      case '"':
        strcat(f, "\\\"");
        break;
      case '\\':
        strcat(f, "\\\\");
        break;
      default:
        strncat(f, p, 1);
    }
  }
  /* strcat(f, "\""); */
} /* mcparmprinter_string */

/* now we may define the parameter structure, using previous functions */
static struct
  {
    int (*getparm)(char *, void *);
    char * (*parminfo)(char *);
    void (*error)(char *, char *);
    void (*printer)(char *, void *);
} mcinputtypes[] = {
  {
    mcparm_double, mcparminfo_double, mcparmerror_double,
    mcparmprinter_double
  }, {
    mcparm_int, mcparminfo_int, mcparmerror_int,
    mcparmprinter_int
  }, {
    mcparm_string, mcparminfo_string, mcparmerror_string,
    mcparmprinter_string
  }
};

/*******************************************************************************
* mcestimate_error: compute sigma from N,p,p2 in Gaussian large numbers approx
*******************************************************************************/
double mcestimate_error(double N, double p1, double p2)
{
  double pmean, n1;
  if(N <= 1)
    return p1;
  pmean = p1 / N;
  n1 = N - 1;
  /* Note: underflow may cause p2 to become zero; the fabs() below guards
     against this. */
  return sqrt((N/n1)*fabs(p2 - pmean*pmean));
}

double (*mcestimate_error_p)
  (double V2, double psum, double p2sum)=mcestimate_error;

/* ========================================================================== */

/*                               MCCODE_R_IO_C                                */

/* ========================================================================== */

#ifndef MCCODE_R_IO_C
#define MCCODE_R_IO_C "$Revision$"

/* SECTION: file i/o handling ================================================ */

#ifndef HAVE_STRCASESTR
// from msysgit: https://code.google.com/p/msysgit/source/browse/compat/strcasestr.c
char *strcasestr(const char *haystack, const char *needle)
{
  int nlen = strlen(needle);
  int hlen = strlen(haystack) - nlen + 1;
  int i;

  for (i = 0; i < hlen; i++) {
    int j;
    for (j = 0; j < nlen; j++) {
            unsigned char c1 = haystack[i+j];
            unsigned char c2 = needle[j];
            if (toupper(c1) != toupper(c2))
                    goto next;
    }
    return (char *) haystack + i;
  next:
    ;
  }
  return NULL;
}


#endif
#ifndef HAVE_STRCASECMP
int strcasecmp( const char *s1, const char *s2 )
{
  int c1, c2;
  do {
    c1 = tolower( (unsigned char) *s1++ );
    c2 = tolower( (unsigned char) *s2++ );
  } while (c1 == c2 && c1 != 0);
  return c2 > c1 ? -1 : c1 > c2;
}
#endif

/*******************************************************************************
* mcfull_file: allocates a full file name=mcdirname+file. Catenate extension if missing.
*******************************************************************************/
char *mcfull_file(char *name, char *ext)
{
  int   dirlen=0;
  char *mem   =NULL;

  dirlen = mcdirname ? strlen(mcdirname) : 0;
  mem = (char*)malloc(dirlen + strlen(name) + CHAR_BUF_LENGTH);
  if(!mem) {
    exit(-fprintf(stderr, "Error: Out of memory %li (mcfull_file)\n", (long)(dirlen + strlen(name) + 256)));
  }
  strcpy(mem, "");

  /* prepend directory name to path if name does not contain a path */
  if (dirlen > 0 && !strchr(name, MC_PATHSEP_C)) {
    strcat(mem, mcdirname);
    strcat(mem, MC_PATHSEP_S);
  } /* dirlen */

  strcat(mem, name);
  if (!strchr(name, '.') && ext && strlen(ext))
  { /* add extension if not in file name already */
    strcat(mem, ".");
    strcat(mem, ext);
  }
  return(mem);
} /* mcfull_file */

/*******************************************************************************
* mcnew_file: opens a new file within mcdirname if non NULL
*             the file is opened in "a" (append, create if does not exist)
*             the extension 'ext' is added if the file name does not include one.
*             the last argument is set to 0 if file did not exist, else to 1.
*******************************************************************************/
FILE *mcnew_file(char *name, char *ext, int *exists)
{
  char *mem;
  FILE *file=NULL;

  if (!name || strlen(name) == 0 || mcdisable_output_files) return(NULL);
  
  mem  = mcfull_file(name, ext); /* create mcdirname/name.ext */
  
  /* check for existence */
  file = fopen(mem, "r"); /* for reading -> fails if does not exist */
  if (file) {
    fclose(file);
    *exists=1;
  } else
    *exists=0;
  
  /* open the file for writing/appending */
#ifdef USE_NEXUS
  if (mcformat && strcasestr(mcformat, "NeXus")) {
    /* NXhandle nxhandle is defined in the .h with USE_NEXUS */
    NXaccess mode = (*exists ? NXACC_CREATE5 | NXACC_RDWR : NXACC_CREATE5);
      
    if (NXopen(mem, mode, &nxhandle) != NX_OK)
      file = NULL;
    else
      file = (FILE*)&nxhandle; /* to make it non NULL */
  } else
#endif
    file = fopen(mem, "a+"); 
    
  if(!file)
    fprintf(stderr, "Warning: could not open output file '%s' for %s (mcnew_file)\n", 
      mem, *exists ? "append" : "create");
  free(mem);

  return file;
} /* mcnew_file */

/*******************************************************************************
* mcdetector_statistics: compute detector statistics, error bars, [x I I_err N] 1D
* RETURN:            updated detector structure
* Used by: mcdetector_import
*******************************************************************************/
MCDETECTOR mcdetector_statistics(
  MCDETECTOR detector)
{

  if (!detector.p1 || !detector.m || !detector.filename)
    return(detector);
  
  /* compute statistics and update MCDETECTOR structure ===================== */
  double sum_z  = 0, min_z  = 0, max_z  = 0;
  double fmon_x =0,  smon_x = 0, fmon_y =0, smon_y=0, mean_z=0;
  double Nsum=0, P2sum=0;

  double sum_xz = 0, sum_yz = 0, sum_x = 0, sum_y = 0, sum_x2z = 0, sum_y2z = 0;
  int    i,j;
  char   hasnan=0, hasinf=0;
  char   israw = ((char*)strcasestr(detector.format,"raw") != NULL);
  double *this_p1=NULL; /* new 1D McCode array [x I E N]. Freed after writing data */

  /* if McCode/PGPLOT and rank==1 we create a new m*4 data block=[x I E N] */
  if (detector.rank == 1 && strcasestr(detector.format,"McCode")) {
    this_p1 = (double *)calloc(detector.m*detector.n*detector.p*4, sizeof(double));
    if (!this_p1)
      exit(-fprintf(stderr, "Error: Out of memory creating %li 1D " MCCODE_STRING " data set for file '%s' (mcdetector_import)\n",
        detector.m*detector.n*detector.p*4*sizeof(double*), detector.filename));
  }

  max_z = min_z = detector.p1[0];
  
  /* compute sum and moments (not for lists) */
  if (!strcasestr(detector.format,"list") && detector.m)
  for(j = 0; j < detector.n*detector.p; j++)
  {
    for(i = 0; i < detector.m; i++)
    {
      double x,y,z;
      double N, E;
      long   index= !detector.istransposed ? i*detector.n*detector.p + j : i+j*detector.m;
      char   hasnaninf=0;

      if (detector.m) 
        x = detector.xmin + (i + 0.5)/detector.m*(detector.xmax - detector.xmin); 
      else x = 0;
      if (detector.n && detector.p) 
        y = detector.ymin + (j + 0.5)/detector.n/detector.p*(detector.ymax - detector.ymin); 
      else y = 0;
      z = detector.p1[index];
      N = detector.p0 ? detector.p0[index] : 1;
      E = detector.p2 ? detector.p2[index] : 0;
      if (detector.p2 && !israw) 
        detector.p2[index] = (*mcestimate_error_p)(detector.p0[index],detector.p1[index],detector.p2[index]); /* set sigma */
      
      if (detector.rank == 1 && this_p1 && strcasestr(detector.format,"McCode")) {
        /* fill-in 1D McCode array [x I E N] */
        this_p1[index*4]   = x;
        this_p1[index*4+1] = z;
        this_p1[index*4+2] = detector.p2 ? detector.p2[index] : 0;
        this_p1[index*4+3] = N;
      }
      
      if (isnan(z) || isnan(E) || isnan(N)) hasnaninf=hasnan=1;
      if (isinf(z) || isinf(E) || isinf(N)) hasnaninf=hasinf=1;

      /* compute stats integrals */
      if (!hasnaninf) {
        sum_xz += x*z;
        sum_yz += y*z;
        sum_x  += x;
        sum_y  += y;
        sum_z  += z;
        sum_x2z += x*x*z;
        sum_y2z += y*y*z;
        if (z > max_z) max_z = z;
        if (z < min_z) min_z = z;

        Nsum += N;
        P2sum += E;
      }

    }
  } /* for j */

  /* compute 1st and 2nd moments. For lists, sum_z=0 so this is skipped. */
  if (sum_z && detector.n*detector.m*detector.p)
  {
    fmon_x = sum_xz/sum_z;
    fmon_y = sum_yz/sum_z;
    smon_x = sum_x2z/sum_z-fmon_x*fmon_x; smon_x = smon_x > 0 ? sqrt(smon_x) : 0;
    smon_y = sum_y2z/sum_z-fmon_y*fmon_y; smon_y = smon_y > 0 ? sqrt(smon_y) : 0;
    mean_z = sum_z/detector.n/detector.m/detector.p;
  }
  /* store statistics into detector */
  detector.intensity = sum_z;
  detector.error     = Nsum ? (*mcestimate_error_p)(Nsum, sum_z, P2sum) : 0;
  detector.events    = Nsum;
  detector.min       = min_z;
  detector.max       = max_z;
  detector.mean      = mean_z;
  detector.centerX   = fmon_x;
  detector.halfwidthX= smon_x;
  detector.centerY   = fmon_y;
  detector.halfwidthY= smon_y;

  /* if McCode/PGPLOT and rank==1 replace p1 with new m*4 1D McCode and clear others */
  if (detector.rank == 1 && this_p1 && strcasestr(detector.format,"McCode")) {
    
    detector.p1 = this_p1;
    detector.n  = detector.m; detector.m  = 4;
    detector.p0 = detector.p2 = NULL;
    detector.istransposed = 1;
  }

  if (detector.n*detector.m*detector.p > 1)
    snprintf(detector.signal, CHAR_BUF_LENGTH, 
      "Min=%g; Max=%g; Mean=%g;", detector.min, detector.max, detector.mean);
  else
    strcpy(detector.signal, "None");
  snprintf(detector.values, CHAR_BUF_LENGTH,
    "%g %g %g", detector.intensity, detector.error, detector.events);

  switch (detector.rank) {
    case 1:  snprintf(detector.statistics, CHAR_BUF_LENGTH, "X0=%g; dX=%g;",
      detector.centerX, detector.halfwidthX); break;
    case 2:
    case 3:  snprintf(detector.statistics, CHAR_BUF_LENGTH, "X0=%g; dX=%g; Y0=%g; dY=%g;",
      detector.centerX, detector.halfwidthX, detector.centerY, detector.halfwidthY);
      break;
    default: strcpy(detector.statistics, "None");
  }
  
  if (hasnan)
    printf("WARNING: Nan detected in component/file %s %s\n", 
      detector.component, strlen(detector.filename) ? detector.filename : "");
  if (hasinf)
    printf("WARNING: Inf detected in component/file %s %s\n", 
      detector.component, strlen(detector.filename) ? detector.filename : "");
  
  return(detector);
  
} /* mcdetector_statistics */

/*******************************************************************************
* mcdetector_import: build detector structure, merge non-lists from MPI
*                    compute basic stat, write "Detector:" line
* RETURN:            detector structure. Invalid data if detector.p1 == NULL
*                    Invalid detector sets m=0 and filename=""
*                    Simulation data  sets m=0 and filename=mcsiminfo_name
* This function is equivalent to the old 'mcdetector_out', returning a structure
*******************************************************************************/
MCDETECTOR mcdetector_import(
  char *format,
  char *component, char *title,
  long m, long n,  long p,
  char *xlabel, char *ylabel, char *zlabel,
  char *xvar, char *yvar, char *zvar,
  double x1, double x2, double y1, double y2, double z1, double z2,
  char *filename,
  double *p0, double *p1, double *p2,
  Coords position)
{
  time_t t;       /* for detector.date */
  long   date_l;  /* date as a long number */
  char   istransposed=0;
  char   c[CHAR_BUF_LENGTH]; /* temp var for signal label */

  MCDETECTOR detector;

  /* build MCDETECTOR structure ============================================= */
  /* make sure we do not have NULL for char fields */

  /* these also apply to simfile */
  strncpy (detector.filename,  filename ? filename : "",        CHAR_BUF_LENGTH);
  strncpy (detector.format,    format   ? format   : "McCode" , CHAR_BUF_LENGTH);
  /* add extension if missing */
  if (strlen(detector.filename) && !strchr(detector.filename, '.'))
  { /* add extension if not in file name already */
    strcat(detector.filename, ".dat");
  }
  strncpy (detector.component, component ? component : MCCODE_STRING " component", CHAR_BUF_LENGTH);

  snprintf(detector.instrument, CHAR_BUF_LENGTH, "%s (%s)", mcinstrument_name, mcinstrument_source);
  snprintf(detector.user, CHAR_BUF_LENGTH,      "%s on %s",
        getenv("USER") ? getenv("USER") : MCCODE_NAME,
        getenv("HOST") ? getenv("HOST") : "localhost");
  time(&t);         /* get current write time */
  date_l = (long)t; /* same but as a long */
  snprintf(detector.date, CHAR_BUF_LENGTH, "%s", ctime(&t));
  if (strlen(detector.date))   detector.date[strlen(detector.date)-1] = '\0'; /* remove last \n in date */
  detector.date_l = date_l;

  if (!mcget_run_num() || mcget_run_num() >= mcget_ncount())
    snprintf(detector.ncount, CHAR_BUF_LENGTH, "%llu", mcget_ncount()
#ifdef USE_MPI
*mpi_node_count
#endif
  );
  else
    snprintf(detector.ncount, CHAR_BUF_LENGTH, "%g/%g", (double)mcget_run_num(), (double)mcget_ncount());

  detector.p0         = p0;
  detector.p1         = p1;
  detector.p2         = p2;

  /* handle transposition (not for NeXus) */
  if (!strcasestr(detector.format, "NeXus")) {
    if (m<0 || n<0 || p<0)             istransposed = !istransposed;
    if (strcasestr(detector.format, "transpose")) istransposed = !istransposed;
    if (istransposed) { /* do the swap once for all */
      long i=m; m=n; n=i;
    }
  }

  m=labs(m); n=labs(n); p=labs(p); /* make sure dimensions are positive */
  detector.istransposed = istransposed;

  /* determine detector rank (dimensionality) */
  if (!m || !n || !p || !p1) detector.rank = 4; /* invalid: exit with m=0 filename="" */
  else if (m*n*p == 1)       detector.rank = 0; /* 0D */
  else if (n == 1 || m == 1) detector.rank = 1; /* 1D */
  else if (p == 1)           detector.rank = 2; /* 2D */
  else                       detector.rank = 3; /* 3D */

  /* from rank, set type */
  switch (detector.rank) {
    case 0:  strcpy(detector.type,  "array_0d"); m=n=p=1; break;
    case 1:  snprintf(detector.type, CHAR_BUF_LENGTH, "array_1d(%ld)", m*n*p); m *= n*p; n=p=1; break;
    case 2:  snprintf(detector.type, CHAR_BUF_LENGTH, "array_2d(%ld, %ld)", m, n*p); n *= p; p=1; break;
    case 3:  snprintf(detector.type, CHAR_BUF_LENGTH, "array_3d(%ld, %ld, %ld)", m, n, p); break;
    default: m=0; strcpy(detector.type, ""); strcpy(detector.filename, "");/* invalid */
  }

  detector.m    = m;
  detector.n    = n;
  detector.p    = p;

  /* these only apply to detector files ===================================== */

  snprintf(detector.position, CHAR_BUF_LENGTH, "%g %g %g", position.x, position.y, position.z);
  /* may also store actual detector orientation in the future */

  strncpy(detector.title,      title && strlen(title) ? title : component,       CHAR_BUF_LENGTH);
  strncpy(detector.xlabel,     xlabel && strlen(xlabel) ? xlabel : "X", CHAR_BUF_LENGTH); /* axis labels */
  strncpy(detector.ylabel,     ylabel && strlen(ylabel) ? ylabel : "Y", CHAR_BUF_LENGTH);
  strncpy(detector.zlabel,     zlabel && strlen(zlabel) ? zlabel : "Z", CHAR_BUF_LENGTH);
  strncpy(detector.xvar,       xvar && strlen(xvar) ? xvar :       "x", CHAR_BUF_LENGTH); /* axis variables */
  strncpy(detector.yvar,       yvar && strlen(yvar) ? yvar :       detector.xvar, CHAR_BUF_LENGTH);
  strncpy(detector.zvar,       zvar && strlen(zvar) ? zvar :       detector.yvar, CHAR_BUF_LENGTH);

  /* set "variables" as e.g. "I I_err N" */
  strcpy(c, "I ");
  if (strlen(detector.zvar))      strncpy(c, detector.zvar,32);
  else if (strlen(detector.yvar)) strncpy(c, detector.yvar,32);
  else if (strlen(detector.xvar)) strncpy(c, detector.xvar,32);

  if (detector.rank == 1)
    snprintf(detector.variables, CHAR_BUF_LENGTH, "%s %s %s_err N", detector.xvar, c, c);
  else
    snprintf(detector.variables, CHAR_BUF_LENGTH, "%s %s_err N", c, c);

  /* limits */
  detector.xmin = x1;
  detector.xmax = x2;
  detector.ymin = y1;
  detector.ymax = y2;
  detector.zmin = z1;
  detector.zmax = z2;
  if (abs(detector.rank) == 1)
    snprintf(detector.limits, CHAR_BUF_LENGTH, "%g %g", x1, x2);
  else if (detector.rank == 2)
    snprintf(detector.limits, CHAR_BUF_LENGTH, "%g %g %g %g", x1, x2, y1, y2);
  else
    snprintf(detector.limits, CHAR_BUF_LENGTH, "%g %g %g %g %g %g", x1, x2, y1, y2, z1, z2);

  /* if MPI and nodes_nb > 1: reduce data sets when using MPI =============== */
#ifdef USE_MPI
  if (!strcasestr(detector.format,"list") && mpi_node_count > 1 && m) {
    /* we save additive data: reduce everything into mpi_node_root */
    if (p0) mc_MPI_Sum(p0, m*n*p);
    if (p1) mc_MPI_Sum(p1, m*n*p);
    if (p2) mc_MPI_Sum(p2, m*n*p);
    if (!p0) {  /* additive signal must be then divided by the number of nodes */
      int i;
      for (i=0; i<m*n*p; i++) {
        p1[i] /= mpi_node_count;
        if (p2) p2[i] /= mpi_node_count;
      }
    }
  }
#endif /* USE_MPI */

  /* compute statistics, Nsum, intensity, Error bars */
  detector = mcdetector_statistics(detector);

#ifdef USE_MPI
  /* slaves are done */
  if(mpi_node_rank != mpi_node_root) {
    return detector;
  }
#endif

  /* output "Detector:" line ================================================ */
  /* when this is a detector written by a component (not the SAVE from instrument),
     not an event lists */
  if (!m) return(detector);
  if (!strcasestr(detector.format,"list")) {
    if (!strcmp(detector.component, mcinstrument_name)) {
      if (strlen(detector.filename))  /* we name it from its filename, or from its title */
        strncpy(c, detector.filename, CHAR_BUF_LENGTH);
      else
        snprintf(c, CHAR_BUF_LENGTH, "%s", mcinstrument_name);
    } else
      strncpy(c, detector.component, CHAR_BUF_LENGTH);  /* usual detectors written by components */

    printf("Detector: %s_I=%g %s_ERR=%g %s_N=%g",
           c, detector.intensity,
           c, detector.error,
           c, detector.events);
    printf(" \"%s\"\n", strlen(detector.filename) ? detector.filename : detector.component);
  }
  

  return(detector);
} /* mcdetector_import */

/* end MCDETECTOR import section ============================================ */

















/* ========================================================================== */

/*                               ASCII output                                 */
/*     The SIM file is YAML based, the data files have '#' headers            */

/* ========================================================================== */


/*******************************************************************************
* mcinfo_out: output instrument tags/info (only in SIM)
* Used in: mcsiminfo_init (ascii), mcinfo(stdout)
*******************************************************************************/
static void mcinfo_out(char *pre, FILE *f)
{
  char Parameters[CHAR_BUF_LENGTH] = "";
  int  i;

  if (!f || mcdisable_output_files) return;

  /* create parameter string ================================================ */
  for(i = 0; i < mcnumipar; i++)
  {
    char ThisParam[CHAR_BUF_LENGTH];
    if (strlen(mcinputtable[i].name) > CHAR_BUF_LENGTH) break;
    snprintf(ThisParam, CHAR_BUF_LENGTH, " %s(%s)", mcinputtable[i].name,
            (*mcinputtypes[mcinputtable[i].type].parminfo)
                (mcinputtable[i].name));
    strcat(Parameters, ThisParam);
    if (strlen(Parameters) >= CHAR_BUF_LENGTH-64) break;
  }

  /* output data ============================================================ */
  if (f != stdout)
    fprintf(f, "%sFile: %s%c%s\n",    pre, mcdirname, MC_PATHSEP_C, mcsiminfo_name);
  else
    fprintf(f, "%sCreator: %s\n",     pre, MCCODE_STRING);

  fprintf(f, "%sSource: %s\n",   pre, mcinstrument_source);
  fprintf(f, "%sParameters: %s\n",    pre, Parameters);
  
  fprintf(f, "%sTrace_enabled: %s\n", pre, mctraceenabled ? "yes" : "no");
  fprintf(f, "%sDefault_main: %s\n",  pre, mcdefaultmain ?  "yes" : "no");
  fprintf(f, "%sEmbedded_runtime: %s\n", pre, 
#ifdef MC_EMBEDDED_RUNTIME
         "yes"
#else
         "no"
#endif
         );

  fflush(f);
} /* mcinfo_out */

/*******************************************************************************
* mcruninfo_out_backend: output simulation tags/info (both in SIM and data files)
* Used in: mcsiminfo_init (ascii case), mcdetector_out_xD_ascii, mcinfo(stdout)
*******************************************************************************/
static void mcruninfo_out_backend(char *pre, FILE *f, int info)
{
  int i;
  char Parameters[CHAR_BUF_LENGTH];

  if (!f || mcdisable_output_files) return;

  fprintf(f, "%sFormat: %s%s\n",      pre, 
    mcformat && strlen(mcformat) ? mcformat : MCCODE_NAME,
    mcformat && strcasestr(mcformat,"McCode") ? " with text headers" : "");
  fprintf(f, "%sURL: %s\n",         pre, "http://www.mccode.org");
  fprintf(f, "%sCreator: %s\n",     pre, MCCODE_STRING);
  fprintf(f, "%sInstrument: %s\n", pre, mcinstrument_source);
  fprintf(f, "%sNcount: %llu\n",        pre, mcget_ncount());
  fprintf(f, "%sTrace: %s\n",       pre, mcdotrace ? "yes" : "no");
  fprintf(f, "%sGravitation: %s\n", pre, mcgravitation ? "yes" : "no");
  snprintf(Parameters, CHAR_BUF_LENGTH, "%ld", mcseed);
  fprintf(f, "%sSeed: %s\n",        pre, Parameters);
  fprintf(f, "%sDirectory: %s\n",        pre, mcdirname ? mcdirname : ".");
#ifdef USE_MPI
  if (mpi_node_count > 1)
    fprintf(f, "%sNodes: %i\n",        pre, mpi_node_count);
#endif

  /* output parameter string ================================================ */
  for(i = 0; i < mcnumipar; i++) {
      if (!info){
          (*mcinputtypes[mcinputtable[i].type].printer)(Parameters, mcinputtable[i].par);
          fprintf(f, "%sParam: %s=%s\n", pre, mcinputtable[i].name, Parameters);
      }else{
        /*if an info run, some variables might not have values. Flag these by "NULL"*/
	if(mcinputtable[i].val && strlen(mcinputtable[i].val)){
            /* ... those with defautl values*/
            (*mcinputtypes[mcinputtable[i].type].printer)(Parameters, mcinputtable[i].par);
            fprintf(f, "%sParam: %s=%s\n", pre, mcinputtable[i].name, Parameters);
        }else{
            /* ... and those without */
            fprintf(f, "%sParam: %s=NULL\n", pre, mcinputtable[i].name);
	}
      }
  }
} /* mcruninfo_out_backend */

/************************
* wrapper function to mcruninfo_out_backend
*  Regular runs use this whereas the single call from mcinfo is directly to the backend
*************************/
static void mcruninfo_out(char *pre, FILE *f){
    mcruninfo_out_backend(pre,f,0);
}

/*******************************************************************************
* mcsiminfo_out:    wrapper to fprintf(mcsiminfo_file)
*******************************************************************************/
void mcsiminfo_out(char *format, ...)
{
  va_list ap;

  if(mcsiminfo_file && !mcdisable_output_files)
  {
    va_start(ap, format);
    vfprintf(mcsiminfo_file, format, ap);
    va_end(ap);
  }
} /* mcsiminfo_out */


/*******************************************************************************
* mcdatainfo_out: output detector header
*   mcdatainfo_out(prefix, file_handle, detector) writes info to data file
*******************************************************************************/
static void
mcdatainfo_out(char *pre, FILE *f, MCDETECTOR detector)
{
  if (!f || !detector.m || mcdisable_output_files) return;
  
  /* output data ============================================================ */
  fprintf(f, "%sDate: %s (%li)\n",       pre, detector.date, detector.date_l);
  fprintf(f, "%stype: %s\n",       pre, detector.type);
  fprintf(f, "%sSource: %s\n",     pre, detector.instrument);
  fprintf(f, "%scomponent: %s\n",  pre, detector.component);
  fprintf(f, "%sposition: %s\n",   pre, detector.position);

  fprintf(f, "%stitle: %s\n",      pre, detector.title);
  fprintf(f, !mcget_run_num() || mcget_run_num() >= mcget_ncount() ?
             "%sNcount: %s\n" : 
             "%sratio: %s\n",  pre, detector.ncount);

  if (strlen(detector.filename)) {
    fprintf(f, "%sfilename: %s\n", pre, detector.filename);
  }

  fprintf(f, "%sstatistics: %s\n", pre, detector.statistics);
  fprintf(f, "%ssignal: %s\n",     pre, detector.signal);
  fprintf(f, "%svalues: %s\n",     pre, detector.values);

  if (detector.rank >= 1)
  {
    fprintf(f, "%sxvar: %s\n",     pre, detector.xvar);
    fprintf(f, "%syvar: %s\n",     pre, detector.yvar);
    fprintf(f, "%sxlabel: %s\n",   pre, detector.xlabel);
    fprintf(f, "%sylabel: %s\n",   pre, detector.ylabel);
    if (detector.rank > 1) {
      fprintf(f, "%szvar: %s\n",   pre, detector.zvar);
      fprintf(f, "%szlabel: %s\n", pre, detector.zlabel);
    }
  }

  fprintf(f, 
    abs(detector.rank)==1 ?
             "%sxlimits: %s\n" : 
             "%sxylimits: %s\n", pre, detector.limits);
  fprintf(f, "%svariables: %s\n", pre, 
    strcasestr(detector.format, "list") ? detector.ylabel : detector.variables);
    
  fflush(f);

} /* mcdatainfo_out */

/* mcdetector_out_array_ascii: output a single array to a file
 *   m: columns
 *   n: rows
 *   p: array
 *   f: file handle (already opened)
 */
static void mcdetector_out_array_ascii(long m, long n, double *p, FILE *f, char istransposed)
{
  if(f)
  {
    int i,j;
    for(j = 0; j < n; j++)
    {
      for(i = 0; i < m; i++)
      {
          fprintf(f, "%.10g ", p[!istransposed ? i*n + j : j*m+i]);
      }
      fprintf(f,"\n");
    }
  }
} /* mcdetector_out_array_ascii */

/*******************************************************************************
* mcdetector_out_0D_ascii: called by mcdetector_out_0D for ascii output
*******************************************************************************/
MCDETECTOR mcdetector_out_0D_ascii(MCDETECTOR detector)
{
  int exists=0;
  FILE *outfile = NULL;
  
  /* Write data set information to simulation description file. */
  MPI_MASTER(
    mcsiminfo_out("\nbegin data\n"); // detector.component
    mcdatainfo_out("  ", mcsiminfo_file, detector);
    mcsiminfo_out("end data\n");
    /* Don't write if filename is NULL: mcnew_file handles this (return NULL) */
    outfile = mcnew_file(detector.component, "dat", &exists);
    if(outfile)
    {
      /* write data file header and entry in simulation description file */
      mcruninfo_out( "# ", outfile);
      mcdatainfo_out("# ", outfile, detector);
      /* write I I_err N */
      fprintf(outfile, "%g %g %g\n", 
        detector.intensity, detector.error, detector.events);
      fclose(outfile);
    }
  ); /* MPI_MASTER */
  return(detector);
} /* mcdetector_out_0D_ascii */

/*******************************************************************************
* mcdetector_out_1D_ascii: called by mcdetector_out_1D for ascii output
*******************************************************************************/
MCDETECTOR mcdetector_out_1D_ascii(MCDETECTOR detector)
{
  int exists=0;
  FILE *outfile = NULL;

  MPI_MASTER(
    /* Write data set information to simulation description file. */
    mcsiminfo_out("\nbegin data\n"); // detector.filename
    mcdatainfo_out("  ", mcsiminfo_file, detector);
    mcsiminfo_out("end data\n");
    /* Loop over array elements, writing to file. */
    /* Don't write if filename is NULL: mcnew_file handles this (return NULL) */
    outfile = mcnew_file(detector.filename, "dat", &exists);
    if(outfile)
    {
      /* write data file header and entry in simulation description file */
      mcruninfo_out( "# ", outfile);
      mcdatainfo_out("# ", outfile, detector);
      /* output the 1D array columns */
      mcdetector_out_array_ascii(detector.m, detector.n, detector.p1, outfile, detector.istransposed);
      
      fclose(outfile);
    }
  ); /* MPI_MASTER */
  return(detector);
  
}  /* mcdetector_out_1D_ascii */

/*******************************************************************************
* mcdetector_out_2D_ascii: called by mcdetector_out_2D for ascii output
*******************************************************************************/
MCDETECTOR mcdetector_out_2D_ascii(MCDETECTOR detector)
{
  int exists=0;
  FILE *outfile = NULL;
  
  MPI_MASTER(
    /* Loop over array elements, writing to file. */
    /* Don't write if filename is NULL: mcnew_file handles this (return NULL) */
    outfile = mcnew_file(detector.filename, "dat", &exists);
    if(outfile)
    {
      /* write header only if file has just been created (not appending) */
      if (!exists) {
        /* Write data set information to simulation description file. */
        mcsiminfo_out("\nbegin data\n"); // detector.filename
        mcdatainfo_out("  ", mcsiminfo_file, detector);
        mcsiminfo_out("end data\n");
      
        mcruninfo_out( "# ", outfile);
        mcdatainfo_out("# ", outfile,   detector);
      }
      fprintf(outfile, "# Data [%s/%s] %s:\n", detector.component, detector.filename, detector.zvar);
      mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p1, 
        outfile, detector.istransposed);
      if (detector.p2) {
        fprintf(outfile, "# Errors [%s/%s] %s_err:\n", detector.component, detector.filename, detector.zvar);
        mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p2, 
          outfile, detector.istransposed);
      }
      if (detector.p0) {
        fprintf(outfile, "# Events [%s/%s] N:\n", detector.component, detector.filename);
        mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p0, 
          outfile, detector.istransposed);
      }
      fclose(outfile);
      
      if (!exists) {
        if (strcasestr(detector.format, "list"))
          printf("Events:   \"%s\"\n",  
            strlen(detector.filename) ? detector.filename : detector.component);
      }
    } /* if outfile */
  ); /* MPI_MASTER */
#ifdef USE_MPI
  if (strcasestr(detector.format, "list") && mpi_node_count > 1) {
    int node_i=0;
    /* loop along MPI nodes to write sequentially */
    for(node_i=0; node_i<mpi_node_count; node_i++) {
      /* MPI: slaves wait for the master to write its block, then append theirs */
      MPI_Barrier(MPI_COMM_WORLD);
      if (node_i != mpi_node_root && node_i == mpi_node_rank) {
        if(strlen(detector.filename) && !mcdisable_output_files)	/* Don't write if filename is NULL */
          outfile = mcnew_file(detector.filename, "dat", &exists);
        if (!exists)
          fprintf(stderr, "Warning: [MPI node %i] file '%s' does not exist yet, "
                          "MASTER should have opened it before.\n",
            mpi_node_rank, detector.filename);
        if(outfile) {
          mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p1, 
            outfile, detector.istransposed);
          fclose(outfile);
        }
      }
    }
  } /* if strcasestr list */
#endif
  return(detector);
} /* mcdetector_out_2D_ascii */

/*******************************************************************************
* strcpy_valid: makes a valid string for variable names.
*   copy 'original' into 'valid', replacing invalid characters by '_'
*   char arrays must be pre-allocated
*******************************************************************************/
static char *strcpy_valid(char *valid, char *original)
{
  long i;
  int  n=32; /* max length of valid names */

  if (original == NULL || !strlen(original)) return(NULL);

  if (n > strlen(original)) n = strlen(original);
  else original += strlen(original)-n;
  strncpy(valid, original, n);

  for (i=0; i < n; i++)
  {
    if ( (valid[i] > 122)
      || (valid[i] < 32)
      || (strchr("!\"#$%&'()*+,-.:;<=>?@[\\]^`/ \n\r\t", valid[i]) != NULL) )
    {
      if (i) valid[i] = '_'; else valid[i] = 'm';
    }
  }
  valid[i] = '\0';

  return(valid);
} /* strcpy_valid */

/* end ascii output section ================================================= */







#ifdef USE_NEXUS

/* ========================================================================== */

/*                               NeXus output                                 */

/* ========================================================================== */

#define nxprintf(...)    nxstr('d', __VA_ARGS__)
#define nxprintattr(...) nxstr('a', __VA_ARGS__)

/*******************************************************************************
* nxstr: output a tag=value data set (char) in NeXus/current group
*   when 'format' is larger that 1024 chars it is used as value for the 'tag'
*   else the value is assembled with format and following arguments.
*   type='d' -> data set
*        'a' -> attribute for current data set
*******************************************************************************/
static int nxstr(char type, NXhandle *f, char *tag, char *format, ...)
{
  va_list ap;
  char value[CHAR_BUF_LENGTH];
  int  i;
  int  ret=NX_OK;
  
  if (!tag || !format || !strlen(tag) || !strlen(format)) return(NX_OK);
  
  /* assemble the value string */
  if (strlen(format) < CHAR_BUF_LENGTH) {
    va_start(ap, format);
    ret = vsnprintf(value, CHAR_BUF_LENGTH, format, ap);
    va_end(ap);
  
    i = strlen(value);
  } else {
    i = strlen(format);
  }

  if (type == 'd') {
    /* open/put/close data set */
    if (NXmakedata (f, tag, NX_CHAR, 1, &i) != NX_OK) return(NX_ERROR);
    NXopendata (f, tag);
    if (strlen(format) < CHAR_BUF_LENGTH)
      ret = NXputdata  (f, value);
    else
      ret = NXputdata  (f, format);
    NXclosedata(f);
  } else {
    if (strlen(format) < CHAR_BUF_LENGTH)
      ret = NXputattr  (f, tag, value, strlen(value), NX_CHAR);
    else
      ret = NXputattr  (f, tag, format, strlen(format), NX_CHAR);
  }
  
  return(ret);
  
} /* nxstr */

/*******************************************************************************
* mcinfo_readfile: read a full file into a string buffer which is allocated
*   Think to free the buffer after use.
* Used in: mcinfo_out_nexus (nexus)
*******************************************************************************/
char *mcinfo_readfile(char *filename)
{
  FILE *f = fopen(filename, "rb");
  if (!f) return(NULL);
  fseek(f, 0, SEEK_END);
  long fsize = ftell(f);
  rewind(f);
  char *string = malloc(fsize + 1);
  if (string) {
    int n = fread(string, fsize, 1, f);
    fclose(f);

    string[fsize] = 0;
  }
  return(string);
}

/*******************************************************************************
* mcinfo_out: output instrument/simulation groups in NeXus file
* Used in: mcsiminfo_init (nexus)
*******************************************************************************/
static void mcinfo_out_nexus(NXhandle f)
{
  FILE  *fid;     /* for intrument source code/C/IDF */
  char  *buffer=NULL;
  time_t t     =time(NULL); /* for date */
  char   entry0[CHAR_BUF_LENGTH];
  int    count=0;
  char   name[CHAR_BUF_LENGTH];
  char   class[CHAR_BUF_LENGTH];
  
  if (!f || mcdisable_output_files) return;
  
  /* write NeXus NXroot attributes */
  /* automatically added: file_name, HDF5_Version, file_time, NeXus_version */ 
  nxprintattr(f, "creator",   "%s generated with " MCCODE_STRING, mcinstrument_name);
  
  /* count the number of existing NXentry and create the next one */
  NXgetgroupinfo(f, &count, name, class);
  sprintf(entry0, "entry%i", count+1);

  /* create the main NXentry (mandatory in NeXus) */
  if (NXmakegroup(f, entry0, "NXentry") == NX_OK) 
  if (NXopengroup(f, entry0, "NXentry") == NX_OK) {
    
    nxprintf(nxhandle, "program_name", MCCODE_STRING);
    nxprintf(f, "start_time", ctime(&t));
    nxprintf(f, "title", "%s%s%s simulation generated by instrument %s", 
      mcdirname && strlen(mcdirname) ? mcdirname : ".", MC_PATHSEP_S, mcsiminfo_name,
      mcinstrument_name);
    nxprintattr(f, "program_name", MCCODE_STRING);
    nxprintattr(f, "instrument",   mcinstrument_name);
    nxprintattr(f, "simulation",   "%s%s%s",
        mcdirname && strlen(mcdirname) ? mcdirname : ".", MC_PATHSEP_S, mcsiminfo_name);

    /* write NeXus instrument group */
    if (NXmakegroup(f, "instrument", "NXinstrument") == NX_OK)
    if (NXopengroup(f, "instrument", "NXinstrument") == NX_OK) {
      int   i;
      char *string=NULL;

      /* write NeXus parameters(types) data =================================== */
      string = (char*)malloc(CHAR_BUF_LENGTH);
      if (string) {
        strcpy(string, "");
        for(i = 0; i < mcnumipar; i++)
        {
          char ThisParam[CHAR_BUF_LENGTH];
          snprintf(ThisParam, CHAR_BUF_LENGTH, " %s(%s)", mcinputtable[i].name,
                  (*mcinputtypes[mcinputtable[i].type].parminfo)
                      (mcinputtable[i].name));
          if (strlen(string) + strlen(ThisParam) < CHAR_BUF_LENGTH)
            strcat(string, ThisParam);
        }
        nxprintattr(f, "Parameters",    string);
        free(string);
      }
        
      nxprintattr(f, "name",          mcinstrument_name);
      nxprintf   (f, "name",          mcinstrument_name);
      nxprintattr(f, "Source",        mcinstrument_source);
      
      nxprintattr(f, "Trace_enabled", mctraceenabled ? "yes" : "no");
      nxprintattr(f, "Default_main",  mcdefaultmain ?  "yes" : "no");
      nxprintattr(f, "Embedded_runtime",  
  #ifdef MC_EMBEDDED_RUNTIME
           "yes"
  #else
           "no"
  #endif
           );
           
      /* add instrument source code when available */
      buffer = mcinfo_readfile(mcinstrument_source);
      if (buffer && strlen(buffer)) {
        long length=strlen(buffer);
        nxprintf (f, "description", buffer);
        NXopendata(f,"description");
        nxprintattr(f, "file_name", mcinstrument_source);
        nxprintattr(f, "file_size", "%li", length);
        nxprintattr(f, "MCCODE_STRING", MCCODE_STRING);
        NXclosedata(f);
        nxprintf (f,"instrument_source", "%s " MCCODE_NAME " " MCCODE_PARTICLE " Monte Carlo simulation", mcinstrument_name);
        free(buffer);
      } else
        nxprintf (f, "description", "File %s not found (instrument description %s is missing)", 
          mcinstrument_source, mcinstrument_name);
      
      /* add Mantid/IDF.xml when available */
      char *IDFfile=NULL;
      IDFfile = (char*)malloc(CHAR_BUF_LENGTH);
      sprintf(IDFfile,"%s%s",mcinstrument_source,".xml");
      buffer = mcinfo_readfile(IDFfile);
      if (buffer && strlen(buffer)) {
        NXmakegroup (nxhandle, "instrument_xml", "NXnote");
        NXopengroup (nxhandle, "instrument_xml", "NXnote");
        nxprintf(f, "data", buffer);
        nxprintf(f, "description", "IDF.xml file found with instrument %s", mcinstrument_source);
        nxprintf(f, "type", "text/xml");
        NXclosegroup(f); /* instrument_xml */
        free(buffer);
      }
      free(IDFfile);
      NXclosegroup(f); /* instrument */
    } /* NXinstrument */

    /* write NeXus simulation group */
    if (NXmakegroup(f, "simulation", "NXnote") == NX_OK)
    if (NXopengroup(f, "simulation", "NXnote") == NX_OK) {

      nxprintattr(f, "name",   "%s%s%s",
        mcdirname && strlen(mcdirname) ? mcdirname : ".", MC_PATHSEP_S, mcsiminfo_name);
      
      nxprintf   (f, "name",      "%s",     mcsiminfo_name);
      nxprintattr(f, "Format",    mcformat && strlen(mcformat) ? mcformat : MCCODE_NAME);
      nxprintattr(f, "URL",       "http://www.mccode.org");
      nxprintattr(f, "program",   MCCODE_STRING);
      nxprintattr(f, "Instrument",mcinstrument_source);
      nxprintattr(f, "Trace",     mcdotrace ?     "yes" : "no");
      nxprintattr(f, "Gravitation",mcgravitation ? "yes" : "no");
      nxprintattr(f, "Seed",      "%li", mcseed);
      nxprintattr(f, "Directory", mcdirname);
    #ifdef USE_MPI
      if (mpi_node_count > 1)
        nxprintf(f, "Nodes", "%i",        mpi_node_count);
    #endif
    
      /* output parameter string ================================================ */
      if (NXmakegroup(f, "Param", "NXparameters") == NX_OK)
      if (NXopengroup(f, "Param", "NXparameters") == NX_OK) {
        int i;
        char string[CHAR_BUF_LENGTH];
        for(i = 0; i < mcnumipar; i++) {
          if (mcget_run_num() || (mcinputtable[i].val && strlen(mcinputtable[i].val))) {
            if (mcinputtable[i].par == NULL)
              strncpy(string, (mcinputtable[i].val ? mcinputtable[i].val : ""), CHAR_BUF_LENGTH);
            else
              (*mcinputtypes[mcinputtable[i].type].printer)(string, mcinputtable[i].par);

            nxprintf(f,  mcinputtable[i].name, "%s", string);
            nxprintattr(f, mcinputtable[i].name, string);
          }
        }
        NXclosegroup(f); /* Param */
      } /* NXparameters */
      
      NXclosegroup(f); /* simulation */
    } /* NXsimulation */
    
    /* create a group to hold all monitors */
    NXmakegroup(f, "data", "NXdetector");

    /* leave the NXentry opened (closed at exit) */
  } /* NXentry */
} /* mcinfo_out_nexus */

/*******************************************************************************
* mcdatainfo_out_nexus: output detector header
*   mcdatainfo_out_nexus(detector) create group and write info to NeXus data file
*   open data:NXdetector then filename:NXdata and write headers/attributes
*   requires: NXentry to be opened
*******************************************************************************/
static void
mcdatainfo_out_nexus(NXhandle f, MCDETECTOR detector)
{
  char data_name[32];
  if (!f || !detector.m || mcdisable_output_files) return;
  
  strcpy_valid(data_name, 
    detector.filename && strlen(detector.filename) ? 
      detector.filename : detector.component);

  /* the NXdetector group has been created in mcinfo_out_nexus (mcsiminfo_init) */
  if (NXopengroup(f, "data", "NXdetector") == NX_OK) {

    /* create and open the data group */
    /* this may fail when appending to list -> ignore/skip */
    NXMDisableErrorReporting(); /* unactivate NeXus error messages, as creation may fail */
    
    if (NXmakegroup(f, data_name, "NXdata") == NX_OK)
    if (NXopengroup(f, data_name, "NXdata") == NX_OK) {
    
      /* output metadata (as attributes) ======================================== */
      nxprintattr(f, "Date",       detector.date);
      nxprintattr(f, "type",       detector.type);
      nxprintattr(f, "Source",     detector.instrument);
      nxprintattr(f, "component",  detector.component);
      nxprintattr(f, "position",   detector.position);

      nxprintattr(f, "title",      detector.title);
      nxprintattr(f, !mcget_run_num() || mcget_run_num() >= mcget_ncount() ?
                 "Ncount" : 
                 "ratio",  detector.ncount);

      if (strlen(detector.filename)) {
        nxprintattr(f, "filename", detector.filename);
      }

      nxprintattr(f, "statistics", detector.statistics);
      nxprintattr(f, "signal",     detector.signal);
      nxprintattr(f, "values",     detector.values);

      if (detector.rank >= 1)
      {
        nxprintattr(f, "xvar",     detector.xvar);
        nxprintattr(f, "yvar",     detector.yvar);
        nxprintattr(f, "xlabel",   detector.xlabel);
        nxprintattr(f, "ylabel",   detector.ylabel);
        if (detector.rank > 1) {
          nxprintattr(f, "zvar",   detector.zvar);
          nxprintattr(f, "zlabel", detector.zlabel);
        }
      }

      nxprintattr(f, abs(detector.rank)==1 ?
                 "xlimits" : 
                 "xylimits", detector.limits);
      nxprintattr(f, "variables", 
        strcasestr(detector.format, "list") ? detector.ylabel : detector.variables);
      nxprintf(f, "distance", detector.position);
      nxprintf(f, "acquisition_mode",
        strcasestr(detector.format, "list") ? "event" : "summed");
        
      NXclosegroup(f);
    } /* NXdata (filename) */
    NXMEnableErrorReporting();  /* re-enable NeXus error messages */
    NXclosegroup(f);
  } /* NXdetector (data) */
  
} /* mcdatainfo_out_nexus */

/*******************************************************************************
* mcdetector_out_axis_nexus: write detector axis into current NXdata
*   requires: NXdata to be opened
*******************************************************************************/
int mcdetector_out_axis_nexus(NXhandle f, char *label, char *var, int rank, long length, double min, double max)
{
  if (!f || length <= 1 || mcdisable_output_files || max == min) return(NX_OK);
  else {
    double axis[length];
    char valid[32];
    int dim=(int)length;
    int i;
    int nprimary=1;
    /* create an axis from [min:max] */
    for(i = 0; i < length; i++)
      axis[i] = min+(max-min)*(i+0.5)/length;
    /* create the data set */
    strcpy_valid(valid, label);
    NXcompmakedata(f, valid, NX_FLOAT64, 1, &dim, NX_COMP_LZW, &dim);
    /* open it */
    if (NXopendata(f, valid) != NX_OK) {
      fprintf(stderr, "Warning: could not open axis rank %i '%s' (NeXus)\n",
        rank, valid);
      return(NX_ERROR);
    }
    /* put the axis and its attributes */
    NXputdata  (f, axis);
    nxprintattr(f, "long_name",  label);
    nxprintattr(f, "short_name", var);
    NXputattr  (f, "axis",       &rank,     1, NX_INT32);
    nxprintattr(f, "units",      var);
    NXputattr  (f, "primary",    &nprimary, 1, NX_INT32);
    NXclosedata(f);
    
    return(NX_OK);
  }
} /* mcdetector_out_axis_nexus */

/*******************************************************************************
* mcdetector_out_array_nexus: write detector array into current NXdata (1D,2D)
*   requires: NXdata to be opened
*******************************************************************************/
int mcdetector_out_array_nexus(NXhandle f, char *part, double *data, MCDETECTOR detector)
{
  
  int dims[3]={detector.m,detector.n,detector.p};  /* number of elements to write */
  int signal=1;
  int exists=0;
  int current_dims[3]={0,0,0};
  int ret=NX_OK;
  
  if (!f || !data || !detector.m || mcdisable_output_files) return(NX_OK);
  
  /* when this is a list, we set 1st dimension to NX_UNLIMITED for creation */
  if (strcasestr(detector.format, "list")) dims[0] = NX_UNLIMITED;
  
  /* create the data set in NXdata group */
  NXMDisableErrorReporting(); /* unactivate NeXus error messages, as creation may fail */
  /* NXcompmakedata fails with NX_UNLIMITED */
  if (strcasestr(detector.format, "list"))
    ret = NXmakedata(    f, part, NX_FLOAT64, detector.rank, dims);
  else
    ret = NXcompmakedata(f, part, NX_FLOAT64, detector.rank, dims, NX_COMP_LZW, dims);
  if (ret != NX_OK) {
    /* failed: data set already exists */
    int datatype=0;
    int rank=0;
    exists=1;
    /* inquire current size of data set (nb of events stored) */
    NXopendata(f, part);
    NXgetinfo(f, &rank, current_dims, &datatype);
    NXclosedata(f);
  }
  NXMEnableErrorReporting();  /* re-enable NeXus error messages */
  dims[0] = detector.m; /* restore actual dimension from data writing */
  
  /* open the data set */
  if (NXopendata(f, part) == NX_ERROR) {
    fprintf(stderr, "Warning: could not open DataSet %s '%s' (NeXus)\n",
      part, detector.title);
    return(NX_ERROR);
  }
  if (strcasestr(detector.format, "list")) {
    current_dims[1] = current_dims[2] = 0; /* set starting location for writing slab */
    NXputslab(f, data, current_dims, dims);
    if (!exists)
      printf("Events:   \"%s\"\n",  
        strlen(detector.filename) ? detector.filename : detector.component);
  } else {
    NXputdata (f, data);
  }
  
  if (strstr(part,"data") || strstr(part, "events")) {
    NXputattr(f, "signal", &signal, 1, NX_INT32);
    nxprintattr(f, "short_name", detector.filename && strlen(detector.filename) ? 
      detector.filename : detector.component);
  }
  nxprintattr(f, "long_name", "%s '%s'", part, detector.title);
  NXclosedata(f);
  
  return(NX_OK);
} /* mcdetector_out_array_nexus */

/*******************************************************************************
* mcdetector_out_data_nexus: write detector axes+data into current NXdata
*   The data:NXdetector is opened, then filename:NXdata
*   requires: NXentry to be opened
*******************************************************************************/
int mcdetector_out_data_nexus(NXhandle f, MCDETECTOR detector)
{
  char data_name[32];
  
  if (!f || !detector.m || mcdisable_output_files) return(NX_OK);
  
  strcpy_valid(data_name, 
    detector.filename && strlen(detector.filename) ? 
      detector.filename : detector.component);

  /* the NXdetector group has been created in mcinfo_out_nexus (mcsiminfo_init) */
  if (NXopengroup(f, "data", "NXdetector") == NX_OK) {

    /* the NXdata group has been created in mcdatainfo_out_nexus */
    if (NXopengroup(f, data_name, "NXdata") == NX_OK) {
  
      /* write axes, for histogram data sets, not for lists */
      if (!strcasestr(detector.format, "list")) {
        mcdetector_out_axis_nexus(f, detector.xlabel, detector.xvar, 
          1, detector.m, detector.xmin, detector.xmax);
          
        mcdetector_out_axis_nexus(f, detector.ylabel, detector.yvar, 
          2, detector.n, detector.ymin, detector.ymax);
          
        mcdetector_out_axis_nexus(f, detector.zlabel, detector.zvar, 
          3, detector.p, detector.zmin, detector.zmax);

      } /* !list */
      
      /* write the actual data (appended if already exists) */
      if (!strcasestr(detector.format, "list")) {
        mcdetector_out_array_nexus(f, "data", detector.p1, detector);
        mcdetector_out_array_nexus(f, "errors", detector.p2, detector);
        mcdetector_out_array_nexus(f, "ncount", detector.p0, detector);
      } else
        mcdetector_out_array_nexus(  f, "events", detector.p1, detector);
      
      NXclosegroup(f);
    } /* NXdata */
    NXclosegroup(f);
  } /* NXdetector */
  
  return(NX_OK);
} /* mcdetector_out_array_nexus */

#ifdef USE_MPI
/*******************************************************************************
* mcdetector_out_list_slaves: slaves send their list data to master which writes
*   requires: NXentry to be opened
* WARNING: this method has a flaw: it requires all nodes to flush the lists
*   the same number of times. In case one node is just below the buffer size
*   when finishing (e.g. monitor_nd), it may not trigger save but others may. 
*   Then the number of recv/send is not constant along nodes, and simulation stalls.  
*******************************************************************************/
MCDETECTOR mcdetector_out_list_slaves(MCDETECTOR detector)
{
  int     node_i=0;
  MPI_MASTER(
	     printf("\n** MPI master gathering slave node list data ** \n");
  );
  
  if (mpi_node_rank != mpi_node_root) {
    /* MPI slave: slaves send their data to master: 2 MPI_Send calls */
    /* m, n, p must be sent first, since all slaves do not have the same number of events */
    int mnp[3]={detector.m,detector.n,detector.p};

    if (mc_MPI_Send(mnp, 3, MPI_INT, mpi_node_root)!= MPI_SUCCESS)
      fprintf(stderr, "Warning: proc %i to master: MPI_Send mnp list error (mcdetector_out_list_slaves)\n", mpi_node_rank);
    if (!detector.p1
     || mc_MPI_Send(detector.p1, mnp[0]*mnp[1]*mnp[2], MPI_DOUBLE, mpi_node_root) != MPI_SUCCESS)
      fprintf(stderr, "Warning: proc %i to master: MPI_Send p1 list error: mnp=%i (mcdetector_out_list_slaves)\n", mpi_node_rank, abs(mnp[0]*mnp[1]*mnp[2]));
    /* slaves are done: sent mnp and p1 */
    return (detector);
  } /* end slaves */

  /* MPI master: receive data from slaves sequentially: 2 MPI_Recv calls */

  if (mpi_node_rank == mpi_node_root) {
    for(node_i=0; node_i<mpi_node_count; node_i++) {
      double *this_p1=NULL;                               /* buffer to hold the list from slaves */
      int     mnp[3]={0,0,0};  /* size of this buffer */
      if (node_i != mpi_node_root) { /* get data from slaves */
	if (mc_MPI_Recv(mnp, 3, MPI_INT, node_i) != MPI_SUCCESS)
	  fprintf(stderr, "Warning: master from proc %i: "
		  "MPI_Recv mnp list error (mcdetector_write_data)\n", node_i);
	if (mnp[0]*mnp[1]*mnp[2]) {
	  this_p1 = (double *)calloc(mnp[0]*mnp[1]*mnp[2], sizeof(double));
	  if (!this_p1 || mc_MPI_Recv(this_p1, abs(mnp[0]*mnp[1]*mnp[2]), MPI_DOUBLE, node_i)!= MPI_SUCCESS)
	    fprintf(stderr, "Warning: master from proc %i: "
		    "MPI_Recv p1 list error: mnp=%i (mcdetector_write_data)\n", node_i, mnp[0]*mnp[1]*mnp[2]);
	  else {
	    printf(". MPI master writing data for slave node %i\n",node_i);
	    detector.p1 = this_p1;
	    detector.m  = mnp[0]; detector.n  = mnp[1]; detector.p  = mnp[2];
	    
	    mcdetector_out_data_nexus(nxhandle, detector);
	  }
	}
      } /* if not master */
    } /* for */
  MPI_MASTER(
	     printf("\n** Done ** \n");
  );   
  }
}
#endif

MCDETECTOR mcdetector_out_0D_nexus(MCDETECTOR detector)
{
  /* Write data set information to NeXus file. */
  MPI_MASTER(
    mcdatainfo_out_nexus(nxhandle, detector);
  );
  
  return(detector);
} /* mcdetector_out_0D_ascii */

MCDETECTOR mcdetector_out_1D_nexus(MCDETECTOR detector_inc)
{
  MCDETECTOR detector = detector_inc;
  MPI_MASTER(
  mcdatainfo_out_nexus(nxhandle, detector);
  mcdetector_out_data_nexus(nxhandle, detector);
  );
  return(detector);
} /* mcdetector_out_1D_ascii */

MCDETECTOR mcdetector_out_2D_nexus(MCDETECTOR detector_inc)
{
  MCDETECTOR detector = detector_inc;
  MPI_MASTER(
  mcdatainfo_out_nexus(nxhandle, detector);
  mcdetector_out_data_nexus(nxhandle, detector);
  );
  
#ifdef USE_MPI // and USE_NEXUS
  /* NeXus: slave nodes have master write their lists */
  if (strcasestr(detector.format, "list") && mpi_node_count > 1) {
    mcdetector_out_list_slaves(detector);
  }
#endif /* USE_MPI */

  return(detector);
} /* mcdetector_out_2D_nexus */

#endif /* USE_NEXUS*/








/* ========================================================================== */

/*                            Main input functions                            */
/*            DETECTOR_OUT_xD function calls -> ascii or NeXus                */

/* ========================================================================== */

/*******************************************************************************
* mcsiminfo_init:   open SIM and write header
*******************************************************************************/
FILE *mcsiminfo_init(FILE *f)
{
  int exists=0;
  int index;
  
  /* check format */      
  if (!mcformat || !strlen(mcformat) 
   || !strcasecmp(mcformat, "MCSTAS") || !strcasecmp(mcformat, "MCXTRACE") 
   || !strcasecmp(mcformat, "PGPLOT") || !strcasecmp(mcformat, "GNUPLOT") || !strcasecmp(mcformat, "MCCODE")
   || !strcasecmp(mcformat, "MATLAB")) {
    mcformat="McCode";
#ifdef USE_NEXUS
  } else if (strcasestr(mcformat, "NeXus")) {
    /* Do nothing */
#endif
  } else {
    fprintf(stderr,
	    "Warning: You have requested the output format %s which is unsupported by this binary. Resetting to standard %s format.\n",mcformat ,"McCode");
    mcformat="McCode";
  }
  
  /* open the SIM file if not defined yet */
  if (mcsiminfo_file || mcdisable_output_files) 
    return (mcsiminfo_file);
    
#ifdef USE_NEXUS
  /* only master writes NeXus header: calls NXopen(nxhandle) */
  if (mcformat && strcasestr(mcformat, "NeXus")) {
	  MPI_MASTER(
	  mcsiminfo_file = mcnew_file(mcsiminfo_name, "h5", &exists);
    if(!mcsiminfo_file)
      fprintf(stderr,
	      "Warning: could not open simulation description file '%s'\n",
	      mcsiminfo_name);
	  else
	    mcinfo_out_nexus(nxhandle);
	  );
    return(mcsiminfo_file); /* points to nxhandle */
  }
#endif
  
  /* write main description file (only MASTER) */
  MPI_MASTER(

  mcsiminfo_file = mcnew_file(mcsiminfo_name, "sim", &exists);
  if(!mcsiminfo_file)
    fprintf(stderr,
	    "Warning: could not open simulation description file '%s'\n",
	    mcsiminfo_name);
  else
  {
    /* write SIM header */
    time_t t=time(NULL);
    mcsiminfo_out("%s simulation description file for %s.\n", 
      MCCODE_NAME, mcinstrument_name);
    mcsiminfo_out("Date:    %s", ctime(&t)); /* includes \n */
    mcsiminfo_out("Program: %s\n\n", MCCODE_STRING);
    
    mcsiminfo_out("begin instrument: %s\n", mcinstrument_name);
    mcinfo_out(   "  ", mcsiminfo_file);
    mcsiminfo_out("end instrument\n");

    mcsiminfo_out("\nbegin simulation: %s\n", mcdirname);
    mcruninfo_out("  ", mcsiminfo_file);
    mcsiminfo_out("end simulation\n");

  }
  return (mcsiminfo_file);
  
  ); /* MPI_MASTER */
  
} /* mcsiminfo_init */

/*******************************************************************************
*   mcsiminfo_close:  close SIM
*******************************************************************************/
void mcsiminfo_close()
{
  MPI_MASTER(
  if(mcsiminfo_file && !mcdisable_output_files) {
#ifdef USE_NEXUS
    if (mcformat && strcasestr(mcformat, "NeXus")) {
      time_t t=time(NULL);
      nxprintf(nxhandle, "end_time", ctime(&t));
      nxprintf(nxhandle, "duration", "%li", (long)t-mcstartdate);
      NXclosegroup(nxhandle); /* NXentry */
      NXclose(&nxhandle);
    } else
#endif
      fclose(mcsiminfo_file);
    );
    mcsiminfo_file = NULL;
  }
} /* mcsiminfo_close */

/*******************************************************************************
* mcdetector_out_0D: wrapper for 0D (single value).
*   Output single detector/monitor data (p0, p1, p2).
*   Title is t, component name is c.
*******************************************************************************/
MCDETECTOR mcdetector_out_0D(char *t, double p0, double p1, double p2,
                         char *c, Coords posa)
{
  /* import and perform basic detector analysis (and handle MPI reduce) */
  MCDETECTOR detector = mcdetector_import(mcformat,
    c, (t ? t : MCCODE_STRING " data"),
    1, 1, 1,
    "I", "", "",
    "I", "", "",
    0, 0, 0, 0, 0, 0, "",
    &p0, &p1, &p2, posa); /* write Detector: line */

#ifdef USE_NEXUS
  if (strcasestr(detector.format, "NeXus"))
    return(mcdetector_out_0D_nexus(detector));
  else
#endif
    return(mcdetector_out_0D_ascii(detector));
    
} /* mcdetector_out_0D */



/*******************************************************************************
* mcdetector_out_1D: wrapper for 1D.
*   Output 1d detector data (p0, p1, p2) for n bins linearly
*   distributed across the range x1..x2 (x1 is lower limit of first
*   bin, x2 is upper limit of last bin). Title is t, axis labels are xl
*   and yl. File name is f, component name is c.
*******************************************************************************/
MCDETECTOR mcdetector_out_1D(char *t, char *xl, char *yl,
        char *xvar, double x1, double x2,
        long n,
        double *p0, double *p1, double *p2, char *f,
        char *c, Coords posa)
{
  /* import and perform basic detector analysis (and handle MPI_Reduce) */
  MCDETECTOR detector = mcdetector_import(mcformat,
    c, (t ? t : MCCODE_STRING " 1D data"),
    n, 1, 1,
    xl, yl, (n > 1 ? "Signal per bin" : " Signal"),
    xvar, "(I,I_err)", "I",
    x1, x2, 0, 0, 0, 0, f,
    p0, p1, p2, posa); /* write Detector: line */
  if (!detector.p1 || !detector.m) return(detector);

#ifdef USE_NEXUS
  if (strcasestr(detector.format, "NeXus"))
    return(mcdetector_out_1D_nexus(detector));
  else
#endif
    return(mcdetector_out_1D_ascii(detector));
  
} /* mcdetector_out_1D */

/*******************************************************************************
* mcdetector_out_2D: wrapper for 2D.
*   special case for list: master creates file first, then slaves append their blocks without header
*******************************************************************************/
MCDETECTOR mcdetector_out_2D(char *t, char *xl, char *yl,
                  double x1, double x2, double y1, double y2,
                  long m, long n,
                  double *p0, double *p1, double *p2, char *f,
                  char *c, Coords posa)
{
  char xvar[CHAR_BUF_LENGTH];
  char yvar[CHAR_BUF_LENGTH];
  
  /* create short axes labels */
  if (xl && strlen(xl)) { strncpy(xvar, xl, CHAR_BUF_LENGTH); xvar[strcspn(xvar,"\n\r ")]='\0'; }
  else strcpy(xvar, "x");
  if (yl && strlen(yl)) { strncpy(yvar, yl, CHAR_BUF_LENGTH); yvar[strcspn(yvar,"\n\r ")]='\0'; }
  else strcpy(yvar, "y");

  MCDETECTOR detector;

  /* import and perform basic detector analysis (and handle MPI_Reduce) */
  if (labs(m) == 1) {/* n>1 on Y, m==1 on X: 1D, no X axis*/
    detector = mcdetector_import(mcformat,
      c, (t ? t : MCCODE_STRING " 1D data"),
      n, 1, 1,
      yl, "", "Signal per bin",
      yvar, "(I,Ierr)", "I",
      y1, y2, x1, x2, 0, 0, f,
      p0, p1, p2, posa); /* write Detector: line */
  } else if (labs(n)==1) {/* m>1 on X, n==1 on Y: 1D, no Y axis*/
    detector = mcdetector_import(mcformat,
      c, (t ? t : MCCODE_STRING " 1D data"),
      m, 1, 1,
      xl, "", "Signal per bin",
      xvar, "(I,Ierr)", "I",
      x1, x2, y1, y2, 0, 0, f,
      p0, p1, p2, posa); /* write Detector: line */
  }else {
    detector = mcdetector_import(mcformat,
      c, (t ? t : MCCODE_STRING " 2D data"),
      m, n, 1,
      xl, yl, "Signal per bin",
      xvar, yvar, "I",
      x1, x2, y1, y2, 0, 0, f,
      p0, p1, p2, posa); /* write Detector: line */
  }

  if (!detector.p1 || !detector.m) return(detector);

#ifdef USE_NEXUS
  if (strcasestr(detector.format, "NeXus"))
    return(mcdetector_out_2D_nexus(detector));
  else
#endif
    return(mcdetector_out_2D_ascii(detector));
  
} /* mcdetector_out_2D */

/*******************************************************************************
* mcdetector_out_list: wrapper for list output (calls out_2D with mcformat+"list").
*   m=number of events, n=size of each event
*******************************************************************************/
MCDETECTOR mcdetector_out_list(char *t, char *xl, char *yl,
                  long m, long n,
                  double *p1, char *f,
                  char *c, Coords posa)
{
  char       format_new[CHAR_BUF_LENGTH];
  char      *format_org;
  MCDETECTOR detector;
  
  format_org = mcformat;
  strcpy(format_new, mcformat);
  strcat(format_new, " list");
  mcformat = format_new;

  detector = mcdetector_out_2D(t, xl, yl,
                  1,labs(m),1,labs(n),
                  m,n,
                  NULL, p1, NULL, f,
                  c, posa);
  
  mcformat = format_org;
  return(detector);
}

/*******************************************************************************
 * mcuse_dir: set data/sim storage directory and create it,
 * or exit with error if exists
 ******************************************************************************/
static void
mcuse_dir(char *dir)
{
  if (!dir || !strlen(dir)) return;
#ifdef MC_PORTABLE
  fprintf(stderr, "Error: "
          "Directory output cannot be used with portable simulation (mcuse_dir)\n");
  exit(1);
#else  /* !MC_PORTABLE */
  /* handle file://directory URL type */
  if (strncmp(dir, "file://", strlen("file://")))
    mcdirname = dir;
  else
    mcdirname = dir+strlen("file://");
  
  
  
  MPI_MASTER(
    if(mkdir(mcdirname, 0777)) {
#ifndef DANSE
      fprintf(stderr, "Error: unable to create directory '%s' (mcuse_dir)\n", dir);
      fprintf(stderr, "(Maybe the directory already exists?)\n");
#endif
#ifdef USE_MPI
    MPI_Abort(MPI_COMM_WORLD, -1);
#endif
    exit(-1);
    }
  ); /* MPI_MASTER */
  
  /* remove trailing PATHSEP (if any) */
  while (strlen(mcdirname) && mcdirname[strlen(mcdirname) - 1] == MC_PATHSEP_C)
    mcdirname[strlen(mcdirname) - 1]='\0';
#endif /* !MC_PORTABLE */
} /* mcuse_dir */

/*******************************************************************************
* mcinfo: display instrument simulation info to stdout and exit
*******************************************************************************/
static void
mcinfo(void)
{
  fprintf(stdout, "begin instrument: %s\n", mcinstrument_name);
  mcinfo_out("  ", stdout);
  fprintf(stdout, "end instrument\n");
  fprintf(stdout, "begin simulation: %s\n", mcdirname ? mcdirname : ".");
  mcruninfo_out_backend("  ", stdout,1);
  fprintf(stdout, "end simulation\n");
  exit(0); /* includes MPI_Finalize in MPI mode */
} /* mcinfo */

#endif /* ndef MCCODE_R_IO_C */

/* end of the I/O section =================================================== */







/*******************************************************************************
* mcset_ncount: set total number of rays to generate
*******************************************************************************/
void mcset_ncount(unsigned long long int count)
{
  mcncount = count;
}

/* mcget_ncount: get total number of rays to generate */
unsigned long long int mcget_ncount(void)
{
  return mcncount;
}

/* mcget_run_num: get curent number of rays in TRACE */
unsigned long long int mcget_run_num(void)
{
  return mcrun_num;
}

/* mcsetn_arg: get ncount from a string argument */
static void
mcsetn_arg(char *arg)
{
  mcset_ncount((long long int) strtod(arg, NULL));
}

/* mcsetseed: set the random generator seed from a string argument */
static void
mcsetseed(char *arg)
{
  mcseed = atol(arg);
  if(mcseed) {
    srandom(mcseed);
  } else {
    fprintf(stderr, "Error: seed must not be zero (mcsetseed)\n");
    exit(1);
  }
}

/* Following part is only embedded when not redundent with mccode-r.h ========= */

#ifndef MCCODE_H

/* SECTION: MCDISPLAY support. =============================================== */

/*******************************************************************************
* Just output MCDISPLAY keywords to be caught by an external plotter client.
*******************************************************************************/

void mcdis_magnify(char *what){
  // Do nothing here, better use interactive zoom from the tools
}

void mcdis_line(double x1, double y1, double z1,
                double x2, double y2, double z2){
  printf("MCDISPLAY: multiline(2,%g,%g,%g,%g,%g,%g)\n",
         x1,y1,z1,x2,y2,z2);
}

void mcdis_dashed_line(double x1, double y1, double z1,
		       double x2, double y2, double z2, int n){
  int i;
  const double dx = (x2-x1)/(2*n+1);
  const double dy = (y2-y1)/(2*n+1);
  const double dz = (z2-z1)/(2*n+1);

  for(i = 0; i < n+1; i++)
    mcdis_line(x1 + 2*i*dx,     y1 + 2*i*dy,     z1 + 2*i*dz,
	       x1 + (2*i+1)*dx, y1 + (2*i+1)*dy, z1 + (2*i+1)*dz);
}

void mcdis_multiline(int count, ...){
  va_list ap;
  double x,y,z;

  printf("MCDISPLAY: multiline(%d", count);
  va_start(ap, count);
  while(count--)
    {
    x = va_arg(ap, double);
    y = va_arg(ap, double);
    z = va_arg(ap, double);
    printf(",%g,%g,%g", x, y, z);
    }
  va_end(ap);
  printf(")\n");
}

void mcdis_rectangle(char* plane, double x, double y, double z,
		     double width, double height){
  /* draws a rectangle in the plane           */
  /* x is ALWAYS width and y is ALWAYS height */
  if (strcmp("xy", plane)==0) {
    mcdis_multiline(5,
		    x - width/2, y - height/2, z,
		    x + width/2, y - height/2, z,
		    x + width/2, y + height/2, z,
		    x - width/2, y + height/2, z,
		    x - width/2, y - height/2, z);
  } else if (strcmp("xz", plane)==0) {
    mcdis_multiline(5,
		    x - width/2, y, z - height/2,
		    x + width/2, y, z - height/2,
		    x + width/2, y, z + height/2,
		    x - width/2, y, z + height/2,
		    x - width/2, y, z - height/2);
  } else if (strcmp("yz", plane)==0) {
    mcdis_multiline(5,
		    x, y - height/2, z - width/2,
		    x, y - height/2, z + width/2,
		    x, y + height/2, z + width/2,
		    x, y + height/2, z - width/2,
		    x, y - height/2, z - width/2);
  } else {

    fprintf(stderr, "Error: Definition of plane %s unknown\n", plane);
    exit(1);
  }
}

/*  draws a box with center at (x, y, z) and
    width (deltax), height (deltay), length (deltaz) */
void mcdis_box(double x, double y, double z,
	       double width, double height, double length){

  mcdis_rectangle("xy", x, y, z-length/2, width, height);
  mcdis_rectangle("xy", x, y, z+length/2, width, height);
  mcdis_line(x-width/2, y-height/2, z-length/2,
	     x-width/2, y-height/2, z+length/2);
  mcdis_line(x-width/2, y+height/2, z-length/2,
	     x-width/2, y+height/2, z+length/2);
  mcdis_line(x+width/2, y-height/2, z-length/2,
	     x+width/2, y-height/2, z+length/2);
  mcdis_line(x+width/2, y+height/2, z-length/2,
	     x+width/2, y+height/2, z+length/2);
}

void mcdis_circle(char *plane, double x, double y, double z, double r){
  printf("MCDISPLAY: circle('%s',%g,%g,%g,%g)\n", plane, x, y, z, r);
}

/* Draws a circle with center (x,y,z), radius (r), and in the plane
 * with normal (nx,ny,nz)*/
void mcdis_Circle(double x, double y, double z, double r, double nx, double ny, double nz){
    int i;
    if(nx==0 && ny && nz==0){
        for (i=0;i<24; i++){
            mcdis_line(x+r*sin(i*2*M_PI/24),y,z+r*cos(i*2*M_PI/24),
                    x+r*sin((i+1)*2*M_PI/24),y,z+r*cos((i+1)*2*M_PI/24));
        }
    }else{
        double mx,my,mz;
        /*generate perpendicular vector using (nx,ny,nz) and (0,1,0)*/
        vec_prod(mx,my,mz, 0,1,0, nx,ny,nz);
        NORM(mx,my,mz);
        /*draw circle*/
        for (i=0;i<24; i++){
            double ux,uy,uz;
            double wx,wy,wz;
            rotate(ux,uy,uz, mx,my,mz, i*2*M_PI/24, nx,ny,nz);
            rotate(wx,wy,wz, mx,my,mz, (i+1)*2*M_PI/24, nx,ny,nz);
            mcdis_line(x+ux*r,y+uy*r,z+uz*r,
                    x+wx*r,y+wy*r,z+wz*r);
        }
    }
}

/* Draws a cylinder with center at (x,y,z) with extent (r,height).
 * The cylinder axis is along the vector nx,ny,nz.
 * N determines how many vertical lines are drawn.*/
void mcdis_cylinder( double x, double y, double z,
        double r, double height, int N, double nx, double ny, double nz){
    int i;
    /*no lines make little sense - so trigger the default*/
    if(N<=0) N=5;

    NORM(nx,ny,nz);
    double h_2=height/2.0;
    mcdis_Circle(x+nx*h_2,y+ny*h_2,z+nz*h_2,r,nx,ny,nz);
    mcdis_Circle(x-nx*h_2,y-ny*h_2,z-nz*h_2,r,nx,ny,nz);

    double mx,my,mz;
    /*generate perpendicular vector using (nx,ny,nz) and (0,1,0)*/
    if(nx==0 && ny && nz==0){
        mx=my=0;mz=1;
    }else{
        vec_prod(mx,my,mz, 0,1,0, nx,ny,nz);
        NORM(mx,my,mz);
    }
    /*draw circle*/
    for (i=0; i<24; i++){
        double ux,uy,uz;
        rotate(ux,uy,uz, mx,my,mz, i*2*M_PI/24, nx,ny,nz);
        mcdis_line(x+nx*h_2+ux*r, y+ny*h_2+uy*r, z+nz*h_2+uz*r,
                 x-nx*h_2+ux*r, y-ny*h_2+uy*r, z-nz*h_2+uz*r);
    }
}

/* draws a sphere with center at (x,y,z) with extent (r)
 * The sphere is drawn using N longitudes and N latitudes.*/
void mcdis_sphere(double x, double y, double z, double r, int N){
    double nx,ny,nz;
    int i;
    /*no lines make little sense - so trigger the default*/
    if(N<=0) N=5;

    nx=0;ny=0;nz=1;
    mcdis_Circle(x,y,z,r,nx,ny,nz);
    for (i=1;i<N;i++){
        rotate(nx,ny,nz, nx,ny,nz, M_PI/N, 0,1,0);
        mcdis_Circle(x,y,z,r,nx,ny,nz);
    }
    /*lastly draw a great circle perpendicular to all N circles*/
    //mcdis_Circle(x,y,z,radius,1,0,0);

    for (i=1;i<=N;i++){
        double yy=-r+ 2*r*((double)i/(N+1));
        mcdis_Circle(x,y+yy ,z,  sqrt(r*r-yy*yy) ,0,1,0);
    }
}

/* SECTION: coordinates handling ============================================ */

/*******************************************************************************
* Since we use a lot of geometric calculations using Cartesian coordinates,
* we collect some useful routines here. However, it is also permissible to
* work directly on the underlying struct coords whenever that is most
* convenient (that is, the type Coords is not abstract).
*
* Coordinates are also used to store rotation angles around x/y/z axis.
*
* Since coordinates are used much like a basic type (such as double), the
* structure itself is passed and returned, rather than a pointer.
*
* At compile-time, the values of the coordinates may be unknown (for example
* a motor position). Hence coordinates are general expressions and not simple
* numbers. For this we used the type Coords_exp which has three CExp
* fields. For runtime (or calculations possible at compile time), we use
* Coords which contains three double fields.
*******************************************************************************/

/* coords_set: Assign coordinates. */
Coords
coords_set(MCNUM x, MCNUM y, MCNUM z)
{
  Coords a;

  a.x = x;
  a.y = y;
  a.z = z;
  return a;
}

/* coords_get: get coordinates. Required when 'x','y','z' are #defined as ray pars */
Coords
coords_get(Coords a, MCNUM *x, MCNUM *y, MCNUM *z)
{
  *x = a.x;
  *y = a.y;
  *z = a.z;
  return a;
}

/* coords_add: Add two coordinates. */
Coords
coords_add(Coords a, Coords b)
{
  Coords c;

  c.x = a.x + b.x;
  c.y = a.y + b.y;
  c.z = a.z + b.z;
  if (fabs(c.z) < 1e-14) c.z=0.0;
  return c;
}

/* coords_sub: Subtract two coordinates. */
Coords
coords_sub(Coords a, Coords b)
{
  Coords c;

  c.x = a.x - b.x;
  c.y = a.y - b.y;
  c.z = a.z - b.z;
  if (fabs(c.z) < 1e-14) c.z=0.0;
  return c;
}

/* coords_neg: Negate coordinates. */
Coords
coords_neg(Coords a)
{
  Coords b;

  b.x = -a.x;
  b.y = -a.y;
  b.z = -a.z;
  return b;
}

/* coords_scale: Scale a vector. */
Coords coords_scale(Coords b, double scale) {
  Coords a;

  a.x = b.x*scale;
  a.y = b.y*scale;
  a.z = b.z*scale;
  return a;
}

/* coords_sp: Scalar product: a . b */
double coords_sp(Coords a, Coords b) {
  double value;

  value = a.x*b.x + a.y*b.y + a.z*b.z;
  return value;
}

/* coords_xp: Cross product: a = b x c. */
Coords coords_xp(Coords b, Coords c) {
  Coords a;

  a.x = b.y*c.z - c.y*b.z;
  a.y = b.z*c.x - c.z*b.x;
  a.z = b.x*c.y - c.x*b.y;
  return a;
}

/* coords_len: Gives length of coords set. */
double coords_len(Coords a) {
  return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);
}

/* coords_mirror: Mirror a in plane (through the origin) defined by normal n*/
Coords coords_mirror(Coords a, Coords n) {
  double t = scalar_prod(n.x, n.y, n.z, n.x, n.y, n.z);
  Coords b;
  if (t!=1) {
    t = sqrt(t);
    n.x /= t;
    n.y /= t;
    n.z /= t;
  }
  t=scalar_prod(a.x, a.y, a.z, n.x, n.y, n.z);
  b.x = a.x-2*t*n.x;
  b.y = a.y-2*t*n.y;
  b.z = a.z-2*t*n.z;
  return b;
}

/* coords_print: Print out vector values. */
void coords_print(Coords a) {

  fprintf(stdout, "(%f, %f, %f)\n", a.x, a.y, a.z);
  return;
}

mcstatic void coords_norm(Coords* c) {
	double temp = coords_sp(*c,*c);

	// Skip if we will end dividing by zero
	if (temp == 0) return;

	temp = sqrt(temp);

	c->x /= temp;
	c->y /= temp;
	c->z /= temp;
}

/*******************************************************************************
* The Rotation type implements a rotation transformation of a coordinate
* system in the form of a double[3][3] matrix.
*
* Contrary to the Coords type in coords.c, rotations are passed by
* reference. Functions that yield new rotations do so by writing to an
* explicit result parameter; rotations are not returned from functions. The
* reason for this is that arrays cannot by returned from functions (though
* structures can; thus an alternative would have been to wrap the
* double[3][3] array up in a struct). Such are the ways of C programming.
*
* A rotation represents the tranformation of the coordinates of a vector when
* changing between coordinate systems that are rotated with respect to each
* other. For example, suppose that coordinate system Q is rotated 45 degrees
* around the Z axis with respect to coordinate system P. Let T be the
* rotation transformation representing a 45 degree rotation around Z. Then to
* get the coordinates of a vector r in system Q, apply T to the coordinates
* of r in P. If r=(1,0,0) in P, it will be (sqrt(1/2),-sqrt(1/2),0) in
* Q. Thus we should be careful when interpreting the sign of rotation angles:
* they represent the rotation of the coordinate systems, not of the
* coordinates (which has opposite sign).
*******************************************************************************/

/*******************************************************************************
* rot_set_rotation: Get transformation for rotation first phx around x axis,
* then phy around y, then phz around z.
*******************************************************************************/
void
rot_set_rotation(Rotation t, double phx, double phy, double phz)
{
  if ((phx == 0) && (phy == 0) && (phz == 0)) {
    t[0][0] = 1.0;
    t[0][1] = 0.0;
    t[0][2] = 0.0;
    t[1][0] = 0.0;
    t[1][1] = 1.0;
    t[1][2] = 0.0;
    t[2][0] = 0.0;
    t[2][1] = 0.0;
    t[2][2] = 1.0;
  } else {
    double cx = cos(phx);
    double sx = sin(phx);
    double cy = cos(phy);
    double sy = sin(phy);
    double cz = cos(phz);
    double sz = sin(phz);

    t[0][0] = cy*cz;
    t[0][1] = sx*sy*cz + cx*sz;
    t[0][2] = sx*sz - cx*sy*cz;
    t[1][0] = -cy*sz;
    t[1][1] = cx*cz - sx*sy*sz;
    t[1][2] = sx*cz + cx*sy*sz;
    t[2][0] = sy;
    t[2][1] = -sx*cy;
    t[2][2] = cx*cy;
  }
}

/*******************************************************************************
* rot_test_identity: Test if rotation is identity
*******************************************************************************/
int
rot_test_identity(Rotation t)
{
  return (t[0][0] + t[1][1] + t[2][2] == 3);
}

/*******************************************************************************
* rot_mul: Matrix multiplication of transformations (this corresponds to
* combining transformations). After rot_mul(T1, T2, T3), doing T3 is
* equal to doing first T2, then T1.
* Note that T3 must not alias (use the same array as) T1 or T2.
*******************************************************************************/
void
rot_mul(Rotation t1, Rotation t2, Rotation t3)
{
  if (rot_test_identity(t1)) {
    rot_copy(t3, t2);
  } else if (rot_test_identity(t2)) {
    rot_copy(t3, t1);
  } else {
    int i,j;
    for(i = 0; i < 3; i++)
      for(j = 0; j < 3; j++)
	t3[i][j] = t1[i][0]*t2[0][j] + t1[i][1]*t2[1][j] + t1[i][2]*t2[2][j];
  }
}

/*******************************************************************************
* rot_copy: Copy a rotation transformation (arrays cannot be assigned in C).
*******************************************************************************/
void
rot_copy(Rotation dest, Rotation src)
{
  int i,j;
  for(i = 0; i < 3; i++)
    for(j = 0; j < 3; j++)
      dest[i][j] = src[i][j];
}

/*******************************************************************************
* rot_transpose: Matrix transposition, which is inversion for Rotation matrices
*******************************************************************************/
void
rot_transpose(Rotation src, Rotation dst)
{
  dst[0][0] = src[0][0];
  dst[0][1] = src[1][0];
  dst[0][2] = src[2][0];
  dst[1][0] = src[0][1];
  dst[1][1] = src[1][1];
  dst[1][2] = src[2][1];
  dst[2][0] = src[0][2];
  dst[2][1] = src[1][2];
  dst[2][2] = src[2][2];
}

/*******************************************************************************
* rot_apply: returns t*a
*******************************************************************************/
Coords
rot_apply(Rotation t, Coords a)
{
  Coords b;
  if (rot_test_identity(t)) {
    return a;
  } else {
    b.x = t[0][0]*a.x + t[0][1]*a.y + t[0][2]*a.z;
    b.y = t[1][0]*a.x + t[1][1]*a.y + t[1][2]*a.z;
    b.z = t[2][0]*a.x + t[2][1]*a.y + t[2][2]*a.z;
    return b;
  }
}

/**
 * Pretty-printing of rotation matrices.
 */
void rot_print(Rotation rot) {
	printf("[ %4.2f %4.2f %4.2f ]\n",
			rot[0][0], rot[0][1], rot[0][2]);
	printf("[ %4.2f %4.2f %4.2f ]\n",
			rot[1][0], rot[1][1], rot[1][2]);
	printf("[ %4.2f %4.2f %4.2f ]\n\n",
			rot[2][0], rot[2][1], rot[2][2]);
}

/**
 * Vector product: used by vec_prod (mccode-r.h). Use coords_xp for Coords.
 */
mcstatic void vec_prod_func(double *x, double *y, double *z,
		double x1, double y1, double z1,
		double x2, double y2, double z2) {
    *x = (y1)*(z2) - (y2)*(z1);
    *y = (z1)*(x2) - (z2)*(x1);
    *z = (x1)*(y2) - (x2)*(y1);
}

/**
 * Scalar product: use coords_sp for Coords.
 */
mcstatic double scalar_prod(
		double x1, double y1, double z1,
		double x2, double y2, double z2) {
	return ((x1 * x2) + (y1 * y2) + (z1 * z2));
}

/*******************************************************************************
* mccoordschange: applies rotation to (x y z) and (vx vy vz) and Spin (sx,sy,sz)
*******************************************************************************/
void
mccoordschange(Coords a, Rotation t, double *x, double *y, double *z,
               double *vx, double *vy, double *vz, double *sx, double *sy, double *sz)
{
  Coords b, c;

  b.x = *x;
  b.y = *y;
  b.z = *z;
  c = rot_apply(t, b);
  b = coords_add(c, a);
  *x = b.x;
  *y = b.y;
  *z = b.z;

  if ( (vz && vy  && vx) && (*vz != 0.0 || *vx != 0.0 || *vy != 0.0) ) mccoordschange_polarisation(t, vx, vy, vz);

  if ( (sz && sy  && sx) && (*sz != 0.0 || *sx != 0.0 || *sy != 0.0) ) mccoordschange_polarisation(t, sx, sy, sz);

}

/*******************************************************************************
* mccoordschange_polarisation: applies rotation to vector (sx sy sz)
*******************************************************************************/
void
mccoordschange_polarisation(Rotation t, double *sx, double *sy, double *sz)
{
  Coords b, c;

  b.x = *sx;
  b.y = *sy;
  b.z = *sz;
  c = rot_apply(t, b);
  *sx = c.x;
  *sy = c.y;
  *sz = c.z;
}

/* SECTION: vector math  ==================================================== */

/* normal_vec_func: Compute normal vector to (x,y,z). */
mcstatic void normal_vec_func(double *nx, double *ny, double *nz,
                double x, double y, double z)
{
  double ax = fabs(x);
  double ay = fabs(y);
  double az = fabs(z);
  double l;
  if(x == 0 && y == 0 && z == 0)
  {
    *nx = 0;
    *ny = 0;
    *nz = 0;
    return;
  }
  if(ax < ay)
  {
    if(ax < az)
    {                           /* Use X axis */
      l = sqrt(z*z + y*y);
      *nx = 0;
      *ny = z/l;
      *nz = -y/l;
      return;
    }
  }
  else
  {
    if(ay < az)
    {                           /* Use Y axis */
      l = sqrt(z*z + x*x);
      *nx = z/l;
      *ny = 0;
      *nz = -x/l;
      return;
    }
  }
  /* Use Z axis */
  l = sqrt(y*y + x*x);
  *nx = y/l;
  *ny = -x/l;
  *nz = 0;
} /* normal_vec */

/*******************************************************************************
 * solve_2nd_order: second order equation solve: A*t^2 + B*t + C = 0
 * solve_2nd_order(&t1, NULL, A,B,C)
 *   returns 0 if no solution was found, or set 't1' to the smallest positive
 *   solution.
 * solve_2nd_order(&t1, &t2, A,B,C)
 *   same as with &t2=NULL, but also returns the second solution.
 * EXAMPLE usage for intersection of a trajectory with a plane in gravitation
 * field (gx,gy,gz):
 * The neutron starts at point r=(x,y,z) with velocityv=(vx vy vz). The plane
 * has a normal vector n=(nx,ny,nz) and contains the point W=(wx,wy,wz).
 * The problem consists in solving the 2nd order equation:
 *      1/2.n.g.t^2 + n.v.t + n.(r-W) = 0
 * so that A = 0.5 n.g; B = n.v; C = n.(r-W);
 * Without acceleration, t=-n.(r-W)/n.v
 ******************************************************************************/
int solve_2nd_order(double *t1, double *t2,
                  double A,  double B,  double C)
{
  int ret=0;

  if (!t1) return 0;
  *t1 = 0;
  if (t2) *t2=0;

  if (fabs(A) < 1E-10) /* approximate to linear equation: A ~ 0 */
  {
    if (B) {  *t1 = -C/B; ret=1; if (t2) *t2=*t1; }
    /* else no intersection: A=B=0 ret=0 */
  }
  else
  {
    double D;
    D = B*B - 4*A*C;
    if (D >= 0) /* Delta > 0: two solutions */
    {
      double sD, dt1, dt2;
      sD = sqrt(D);
      dt1 = (-B + sD)/2/A;
      dt2 = (-B - sD)/2/A;
      /* we identify very small values with zero */
      if (fabs(dt1) < 1e-10) dt1=0.0;
      if (fabs(dt2) < 1e-10) dt2=0.0;

      /* now we choose the smallest positive solution */
      if      (dt1<=0.0 && dt2>0.0) ret=2; /* dt2 positive */
      else if (dt2<=0.0 && dt1>0.0) ret=1; /* dt1 positive */
      else if (dt1> 0.0 && dt2>0.0)
      {  if (dt1 < dt2) ret=1; else ret=2; } /* all positive: min(dt1,dt2) */
      /* else two solutions are negative. ret=-1 */
      if (ret==1) { *t1 = dt1;  if (t2) *t2=dt2; }
      else        { *t1 = dt2;  if (t2) *t2=dt1; }
      ret=2;  /* found 2 solutions and t1 is the positive one */
    } /* else Delta <0: no intersection. ret=0 */
  }
  return(ret);
} /* solve_2nd_order */

/*******************************************************************************
 * randvec_target_circle: Choose random direction towards target at (x,y,z)
 * with given radius.
 * If radius is zero, choose random direction in full 4PI, no target.
 ******************************************************************************/
void
randvec_target_circle(double *xo, double *yo, double *zo, double *solid_angle,
               double xi, double yi, double zi, double radius)
{
  double l2, phi, theta, nx, ny, nz, xt, yt, zt, xu, yu, zu;

  if(radius == 0.0)
  {
    /* No target, choose uniformly a direction in full 4PI solid angle. */
    theta = acos (1 - rand0max(2));
    phi = rand0max(2 * PI);
    if(solid_angle)
      *solid_angle = 4*PI;
    nx = 1;
    ny = 0;
    nz = 0;
    yi = sqrt(xi*xi+yi*yi+zi*zi);
    zi = 0;
    xi = 0;
  }
  else
  {
    double costheta0;
    l2 = xi*xi + yi*yi + zi*zi; /* sqr Distance to target. */
    costheta0 = sqrt(l2/(radius*radius+l2));
    if (radius < 0) costheta0 *= -1;
    if(solid_angle)
    {
      /* Compute solid angle of target as seen from origin. */
        *solid_angle = 2*PI*(1 - costheta0);
    }

    /* Now choose point uniformly on circle surface within angle theta0 */
    theta = acos (1 - rand0max(1 - costheta0)); /* radius on circle */
    phi = rand0max(2 * PI); /* rotation on circle at given radius */
    /* Now, to obtain the desired vector rotate (xi,yi,zi) angle theta around a
       perpendicular axis u=i x n and then angle phi around i. */
    if(xi == 0 && zi == 0)
    {
      nx = 1;
      ny = 0;
      nz = 0;
    }
    else
    {
      nx = -zi;
      nz = xi;
      ny = 0;
    }
  }

  /* [xyz]u = [xyz]i x n[xyz] (usually vertical) */
  vec_prod(xu,  yu,  zu, xi, yi, zi,        nx, ny, nz);
  /* [xyz]t = [xyz]i rotated theta around [xyz]u */
  rotate  (xt,  yt,  zt, xi, yi, zi, theta, xu, yu, zu);
  /* [xyz]o = [xyz]t rotated phi around n[xyz] */
  rotate (*xo, *yo, *zo, xt, yt, zt, phi, xi, yi, zi);
} /* randvec_target_circle */

/*******************************************************************************
 * randvec_target_rect_angular: Choose random direction towards target at
 * (xi,yi,zi) with given ANGULAR dimension height x width. height=phi_x=[0,PI],
 * width=phi_y=[0,2*PI] (radians)
 * If height or width is zero, choose random direction in full 4PI, no target.
 *******************************************************************************/
void
randvec_target_rect_angular(double *xo, double *yo, double *zo, double *solid_angle,
               double xi, double yi, double zi, double width, double height, Rotation A)
{
  double theta, phi, nx, ny, nz, xt, yt, zt, xu, yu, zu;
  Coords tmp;
  Rotation Ainverse;

  rot_transpose(A, Ainverse);

  if(height == 0.0 || width == 0.0)
  {
    randvec_target_circle(xo, yo, zo, solid_angle,
               xi, yi, zi, 0);
    return;
  }
  else
  {
    if(solid_angle)
    {
      /* Compute solid angle of target as seen from origin. */
      *solid_angle = 2*fabs(width*sin(height/2));
    }

    /* Go to global coordinate system */

    tmp = coords_set(xi, yi, zi);
    tmp = rot_apply(Ainverse, tmp);
    coords_get(tmp, &xi, &yi, &zi);

    /* Now choose point uniformly on the unit sphere segment with angle theta/phi */
    phi   = width*randpm1()/2.0;
    theta = asin(randpm1()*sin(height/2.0));
    /* Now, to obtain the desired vector rotate (xi,yi,zi) angle theta around
       n, and then phi around u. */
    if(xi == 0 && zi == 0)
    {
      nx = 1;
      ny = 0;
      nz = 0;
    }
    else
    {
      nx = -zi;
      nz = xi;
      ny = 0;
    }
  }

  /* [xyz]u = [xyz]i x n[xyz] (usually vertical) */
  vec_prod(xu,  yu,  zu, xi, yi, zi,        nx, ny, nz);
  /* [xyz]t = [xyz]i rotated theta around [xyz]u */
  rotate  (xt,  yt,  zt, xi, yi, zi, theta, nx, ny, nz);
  /* [xyz]o = [xyz]t rotated phi around n[xyz] */
  rotate (*xo, *yo, *zo, xt, yt, zt, phi, xu,  yu,  zu);

  /* Go back to local coordinate system */
  tmp = coords_set(*xo, *yo, *zo);
  tmp = rot_apply(A, tmp);
  coords_get(tmp, &*xo, &*yo, &*zo);

} /* randvec_target_rect_angular */

/*******************************************************************************
 * randvec_target_rect_real: Choose random direction towards target at (xi,yi,zi)
 * with given dimension height x width (in meters !).
 *
 * Local emission coordinate is taken into account and corrected for 'order' times.
 * (See remarks posted to mcstas-users by George Apostolopoulus <gapost@ipta.demokritos.gr>)
 *
 * If height or width is zero, choose random direction in full 4PI, no target.
 *
 * Traditionally, this routine had the name randvec_target_rect - this is now a
 * a define (see mcstas-r.h) pointing here. If you use the old rouine, you are NOT
 * taking the local emmission coordinate into account.
*******************************************************************************/

void
randvec_target_rect_real(double *xo, double *yo, double *zo, double *solid_angle,
               double xi, double yi, double zi,
               double width, double height, Rotation A,
               double lx, double ly, double lz, int order)
{
  double dx, dy, dist, dist_p, nx, ny, nz, mx, my, mz, n_norm, m_norm;
  double cos_theta;
  Coords tmp;
  Rotation Ainverse;

  rot_transpose(A, Ainverse);

  if(height == 0.0 || width == 0.0)
  {
    randvec_target_circle(xo, yo, zo, solid_angle,
               xi, yi, zi, 0);
    return;
  }
  else
  {

    /* Now choose point uniformly on rectangle within width x height */
    dx = width*randpm1()/2.0;
    dy = height*randpm1()/2.0;

    /* Determine distance to target plane*/
    dist = sqrt(xi*xi + yi*yi + zi*zi);
    /* Go to global coordinate system */

    tmp = coords_set(xi, yi, zi);
    tmp = rot_apply(Ainverse, tmp);
    coords_get(tmp, &xi, &yi, &zi);

    /* Determine vector normal to trajectory axis (z) and gravity [0 1 0] */
    vec_prod(nx, ny, nz, xi, yi, zi, 0, 1, 0);

    /* This now defines the x-axis, normalize: */
    n_norm=sqrt(nx*nx + ny*ny + nz*nz);
    nx = nx/n_norm;
    ny = ny/n_norm;
    nz = nz/n_norm;

    /* Now, determine our y-axis (vertical in many cases...) */
    vec_prod(mx, my, mz, xi, yi, zi, nx, ny, nz);
    m_norm=sqrt(mx*mx + my*my + mz*mz);
    mx = mx/m_norm;
    my = my/m_norm;
    mz = mz/m_norm;

    /* Our output, random vector can now be defined by linear combination: */

    *xo = xi + dx * nx + dy * mx;
    *yo = yi + dx * ny + dy * my;
    *zo = zi + dx * nz + dy * mz;

    /* Go back to local coordinate system */
    tmp = coords_set(*xo, *yo, *zo);
    tmp = rot_apply(A, tmp);
    coords_get(tmp, &*xo, &*yo, &*zo);

    /* Go back to local coordinate system */
    tmp = coords_set(xi, yi, zi);
    tmp = rot_apply(A, tmp);
    coords_get(tmp, &xi, &yi, &zi);

    if (solid_angle) {
      /* Calculate vector from local point to remote random point */
      lx = *xo - lx;
      ly = *yo - ly;
      lz = *zo - lz;
      dist_p = sqrt(lx*lx + ly*ly + lz*lz);

      /* Adjust the 'solid angle' */
      /* 1/r^2 to the chosen point times cos(\theta) between the normal */
      /* vector of the target rectangle and direction vector of the chosen point. */
      cos_theta = (xi * lx + yi * ly + zi * lz) / (dist * dist_p);
      *solid_angle = width * height / (dist_p * dist_p);
      int counter;
      for (counter = 0; counter < order; counter++) {
	*solid_angle = *solid_angle * cos_theta;
      }
    }
  }
} /* randvec_target_rect_real */

/* SECTION: random numbers ================================================== */

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

/*
 * This is derived from the Berkeley source:
 *        @(#)random.c        5.5 (Berkeley) 7/6/88
 * It was reworked for the GNU C Library by Roland McGrath.
 * Rewritten to use reentrant functions by Ulrich Drepper, 1995.
 */

/*******************************************************************************
* Modified for McStas from glibc 2.0.7pre1 stdlib/random.c and
* stdlib/random_r.c.
*
* This way random() is more than four times faster compared to calling
* standard glibc random() on ix86 Linux, probably due to multithread support,
* ELF shared library overhead, etc. It also makes McStas generated
* simulations more portable (more likely to behave identically across
* platforms, important for parrallel computations).
*******************************************************************************/


#define        TYPE_3                3
#define        BREAK_3                128
#define        DEG_3                31
#define        SEP_3                3

static mc_int32_t randtbl[DEG_3 + 1] =
  {
    TYPE_3,

    -1726662223, 379960547, 1735697613, 1040273694, 1313901226,
    1627687941, -179304937, -2073333483, 1780058412, -1989503057,
    -615974602, 344556628, 939512070, -1249116260, 1507946756,
    -812545463, 154635395, 1388815473, -1926676823, 525320961,
    -1009028674, 968117788, -123449607, 1284210865, 435012392,
    -2017506339, -911064859, -370259173, 1132637927, 1398500161,
    -205601318,
  };

static mc_int32_t *fptr = &randtbl[SEP_3 + 1];
static mc_int32_t *rptr = &randtbl[1];
static mc_int32_t *state = &randtbl[1];
#define rand_deg DEG_3
#define rand_sep SEP_3
static mc_int32_t *end_ptr = &randtbl[sizeof (randtbl) / sizeof (randtbl[0])];

mc_int32_t
mc_random (void)
{
  mc_int32_t result;

  *fptr += *rptr;
  /* Chucking least random bit.  */
  result = (*fptr >> 1) & 0x7fffffff;
  ++fptr;
  if (fptr >= end_ptr)
  {
    fptr = state;
    ++rptr;
  }
  else
  {
    ++rptr;
    if (rptr >= end_ptr)
      rptr = state;
  }
  return result;
}

void
mc_srandom (unsigned int x)
{
  /* We must make sure the seed is not 0.  Take arbitrarily 1 in this case.  */
  state[0] = x ? x : 1;
  {
    long int i;
    for (i = 1; i < rand_deg; ++i)
    {
      /* This does:
         state[i] = (16807 * state[i - 1]) % 2147483647;
         but avoids overflowing 31 bits.  */
      long int hi = state[i - 1] / 127773;
      long int lo = state[i - 1] % 127773;
      long int test = 16807 * lo - 2836 * hi;
      state[i] = test + (test < 0 ? 2147483647 : 0);
    }
    fptr = &state[rand_sep];
    rptr = &state[0];
    for (i = 0; i < 10 * rand_deg; ++i)
      random ();
  }
}

/* "Mersenne Twister", by Makoto Matsumoto and Takuji Nishimura. */
/* See http://www.math.keio.ac.jp/~matumoto/emt.html for original source. */


/*
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using mt_srandom(seed)
   or init_by_array(init_key, key_length).

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote
        products derived from this software without specific prior written
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   Any feedback is very welcome.
   http://www.math.keio.ac.jp/matumoto/emt.html
   email: matumoto@math.keio.ac.jp
*/

#include <stdio.h>

/* Period parameters */
#define N 624
#define M 397
#define MATRIX_A 0x9908b0dfUL   /* constant vector a */
#define UPPER_MASK 0x80000000UL /* most significant w-r bits */
#define LOWER_MASK 0x7fffffffUL /* least significant r bits */

static unsigned long mt[N]; /* the array for the state vector  */
static int mti=N+1; /* mti==N+1 means mt[N] is not initialized */

/* initializes mt[N] with a seed */
void mt_srandom(unsigned long s)
{
    mt[0]= s & 0xffffffffUL;
    for (mti=1; mti<N; mti++) {
        mt[mti] =
            (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);
        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
        /* In the previous versions, MSBs of the seed affect   */
        /* only MSBs of the array mt[].                        */
        /* 2002/01/09 modified by Makoto Matsumoto             */
        mt[mti] &= 0xffffffffUL;
        /* for >32 bit machines */
    }
}

/* initialize by an array with array-length */
/* init_key is the array for initializing keys */
/* key_length is its length */
void init_by_array(unsigned long init_key[], unsigned long key_length)
{
    int i, j, k;
    mt_srandom(19650218UL);
    i=1; j=0;
    k = (N>key_length ? N : key_length);
    for (; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))
          + init_key[j] + j; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++; j++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
        if (j>=key_length) j=0;
    }
    for (k=N-1; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL))
          - i; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
    }

    mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */
}

/* generates a random number on [0,0xffffffff]-interval */
unsigned long mt_random(void)
{
    unsigned long y;
    static unsigned long mag01[2]={0x0UL, MATRIX_A};
    /* mag01[x] = x * MATRIX_A  for x=0,1 */

    if (mti >= N) { /* generate N words at one time */
        int kk;

        if (mti == N+1)   /* if mt_srandom() has not been called, */
            mt_srandom(5489UL); /* a default initial seed is used */

        for (kk=0;kk<N-M;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        for (;kk<N-1;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];

        mti = 0;
    }

    y = mt[mti++];

    /* Tempering */
    y ^= (y >> 11);
    y ^= (y << 7) & 0x9d2c5680UL;
    y ^= (y << 15) & 0xefc60000UL;
    y ^= (y >> 18);

    return y;
}

#undef N
#undef M
#undef MATRIX_A
#undef UPPER_MASK
#undef LOWER_MASK

/* End of "Mersenne Twister". */

/* End of McCode random number routine. */

/* randnorm: generate a random number from normal law */
double
randnorm(void)
{
  static double v1, v2, s;
  static int phase = 0;
  double X, u1, u2;

  if(phase == 0)
  {
    do
    {
      u1 = rand01();
      u2 = rand01();
      v1 = 2*u1 - 1;
      v2 = 2*u2 - 1;
      s = v1*v1 + v2*v2;
    } while(s >= 1 || s == 0);

    X = v1*sqrt(-2*log(s)/s);
  }
  else
  {
    X = v2*sqrt(-2*log(s)/s);
  }

  phase = 1 - phase;
  return X;
}

/**
 * Generate a random number from -1 to 1 with triangle distribution
 */
double randtriangle(void) {
	double randnum = rand01();
	if (randnum>0.5) return(1-sqrt(2*(randnum-0.5)));
	else return(sqrt(2*randnum)-1);
}

/**
 * Random number between 0.0 and 1.0 (including?)
 */
double rand01() {
	double randnum;
	randnum = (double) random();
	randnum /= (double) MC_RAND_MAX + 1;
	return randnum;
}

/**
 * Return a random number between 1 and -1
 */
double randpm1() {
	double randnum;
	randnum = (double) random();
	randnum /= ((double) MC_RAND_MAX + 1) / 2;
	randnum -= 1;
	return randnum;
}

/**
 * Return a random number between 0 and max.
 */
double rand0max(double max) {
	double randnum;
	randnum = (double) random();
	randnum /= ((double) MC_RAND_MAX + 1) / max;
	return randnum;
}

/**
 * Return a random number between min and max.
 */
double randminmax(double min, double max) {
	return rand0max(max - min) + max;
}

/* SECTION: main and signal handlers ======================================== */

/*******************************************************************************
* mchelp: displays instrument executable help with possible options
*******************************************************************************/
static void
mchelp(char *pgmname)
{
  int i;

  fprintf(stderr, "%s (%s) instrument simulation, generated with " MCCODE_STRING " (" MCCODE_DATE ")\n", mcinstrument_name, mcinstrument_source);
  fprintf(stderr, "Usage: %s [options] [parm=value ...]\n", pgmname);
  fprintf(stderr,
"Options are:\n"
"  -s SEED   --seed=SEED      Set random seed (must be != 0)\n"
"  -n COUNT  --ncount=COUNT   Set number of " MCCODE_PARTICLE "s to simulate.\n"
"  -d DIR    --dir=DIR        Put all data files in directory DIR.\n"
"  -t        --trace          Enable trace of " MCCODE_PARTICLE "s through instrument.\n"
"  -g        --gravitation    Enable gravitation for all trajectories.\n"
"  --no-output-files          Do not write any data files.\n"
"  -h        --help           Show this help message.\n"
"  -i        --info           Detailed instrument information.\n"
"  --format=FORMAT            Output data files using FORMAT="
   FLAVOR_UPPER
#ifdef USE_NEXUS
   " NEXUS"
#endif
"\n\n"
);
#ifdef USE_MPI
  fprintf(stderr,
  "This instrument has been compiled with MPI support.\n  Use 'mpirun %s [options] [parm=value ...]'.\n", pgmname);
#endif
  if(mcnumipar > 0)
  {
    fprintf(stderr, "Instrument parameters are:\n");
    for(i = 0; i < mcnumipar; i++)
      if (mcinputtable[i].val && strlen(mcinputtable[i].val))
        fprintf(stderr, "  %-16s(%s) [default='%s']\n", mcinputtable[i].name,
        (*mcinputtypes[mcinputtable[i].type].parminfo)(mcinputtable[i].name),
        mcinputtable[i].val);
      else
        fprintf(stderr, "  %-16s(%s)\n", mcinputtable[i].name,
        (*mcinputtypes[mcinputtable[i].type].parminfo)(mcinputtable[i].name));
  }

#ifndef NOSIGNALS
  fprintf(stderr, "Known signals are: "
#ifdef SIGUSR1
  "USR1 (status) "
#endif
#ifdef SIGUSR2
  "USR2 (save) "
#endif
#ifdef SIGBREAK
  "BREAK (save) "
#endif
#ifdef SIGTERM
  "TERM (save and exit)"
#endif
  "\n");
#endif /* !NOSIGNALS */
} /* mchelp */


/* mcshowhelp: show help and exit with 0 */
static void
mcshowhelp(char *pgmname)
{
  mchelp(pgmname);
  exit(0);
}

/* mcusage: display usage when error in input arguments and exit with 1 */
static void
mcusage(char *pgmname)
{
  fprintf(stderr, "Error: incorrect command line arguments\n");
  mchelp(pgmname);
  exit(1);
}

/* mcenabletrace: enable trace/mcdisplay or error if requires recompile */
static void
mcenabletrace(void)
{
 if(mctraceenabled)
  mcdotrace = 1;
 else
 {
   fprintf(stderr,
           "Error: trace not enabled (mcenabletrace)\n"
           "Please re-run the " MCCODE_NAME " compiler "
                   "with the --trace option, or rerun the\n"
           "C compiler with the MC_TRACE_ENABLED macro defined.\n");
   exit(1);
 }
}

/*******************************************************************************
* mcreadparams: request parameters from the prompt (or use default)
*******************************************************************************/
void
mcreadparams(void)
{
  int i,j,status;
  static char buf[CHAR_BUF_LENGTH];
  char *p;
  int len;

  MPI_MASTER(printf("Instrument parameters for %s (%s)\n",
                    mcinstrument_name, mcinstrument_source));

  for(i = 0; mcinputtable[i].name != 0; i++)
  {
    do
    {
      MPI_MASTER(
                 if (mcinputtable[i].val && strlen(mcinputtable[i].val))
                   printf("Set value of instrument parameter %s (%s) [default='%s']:\n",
                          mcinputtable[i].name,
                          (*mcinputtypes[mcinputtable[i].type].parminfo)
                          (mcinputtable[i].name), mcinputtable[i].val);
                 else
                   printf("Set value of instrument parameter %s (%s):\n",
                          mcinputtable[i].name,
                          (*mcinputtypes[mcinputtable[i].type].parminfo)
                          (mcinputtable[i].name));
                 fflush(stdout);
                 );
#ifdef USE_MPI
      if(mpi_node_rank == mpi_node_root)
        {
          p = fgets(buf, CHAR_BUF_LENGTH, stdin);
          if(p == NULL)
            {
              fprintf(stderr, "Error: empty input for paramater %s (mcreadparams)\n", mcinputtable[i].name);
              exit(1);
            }
        }
      else
        p = buf;
      MPI_Bcast(buf, CHAR_BUF_LENGTH, MPI_CHAR, mpi_node_root, MPI_COMM_WORLD);
#else /* !USE_MPI */
      p = fgets(buf, CHAR_BUF_LENGTH, stdin);
      if(p == NULL)
        {
          fprintf(stderr, "Error: empty input for paramater %s (mcreadparams)\n", mcinputtable[i].name);
          exit(1);
        }
#endif /* USE_MPI */
      len = strlen(buf);
      if (!len || (len == 1 && (buf[0] == '\n' || buf[0] == '\r')))
      {
        if (mcinputtable[i].val && strlen(mcinputtable[i].val)) {
          strncpy(buf, mcinputtable[i].val, CHAR_BUF_LENGTH);  /* use default value */
          len = strlen(buf);
        }
      }
      for(j = 0; j < 2; j++)
      {
        if(len > 0 && (buf[len - 1] == '\n' || buf[len - 1] == '\r'))
        {
          len--;
          buf[len] = '\0';
        }
      }

      status = (*mcinputtypes[mcinputtable[i].type].getparm)
                   (buf, mcinputtable[i].par);
      if(!status)
      {
        (*mcinputtypes[mcinputtable[i].type].error)(mcinputtable[i].name, buf);
        if (!mcinputtable[i].val || strlen(mcinputtable[i].val)) {
          fprintf(stderr, "       Change %s default value in instrument definition.\n", mcinputtable[i].name);
          exit(1);
        }
      }
    } while(!status);
  }
} /* mcreadparams */

/*******************************************************************************
* mcparseoptions: parse command line arguments (options, parameters)
*******************************************************************************/
void
mcparseoptions(int argc, char *argv[])
{
  int i, j;
  char *p;
  int paramset = 0, *paramsetarray;
  char *usedir=NULL;

  /* Add one to mcnumipar to avoid allocating zero size memory block. */
  paramsetarray = (int*)malloc((mcnumipar + 1)*sizeof(*paramsetarray));
  if(paramsetarray == NULL)
  {
    fprintf(stderr, "Error: insufficient memory (mcparseoptions)\n");
    exit(1);
  }
  for(j = 0; j < mcnumipar; j++)
    {
      paramsetarray[j] = 0;
      if (mcinputtable[j].val != NULL && strlen(mcinputtable[j].val))
      {
        int  status;
        char buf[CHAR_BUF_LENGTH];
        strncpy(buf, mcinputtable[j].val, CHAR_BUF_LENGTH);
        status = (*mcinputtypes[mcinputtable[j].type].getparm)
                   (buf, mcinputtable[j].par);
        if(!status) fprintf(stderr, "Invalid '%s' default value %s in instrument definition (mcparseoptions)\n", mcinputtable[j].name, buf);
        else paramsetarray[j] = 1;
      } else {
        (*mcinputtypes[mcinputtable[j].type].getparm)
          (NULL, mcinputtable[j].par);
        paramsetarray[j] = 0;
      }
    }
  for(i = 1; i < argc; i++)
  {
    if(!strcmp("-s", argv[i]) && (i + 1) < argc)
      mcsetseed(argv[++i]);
    else if(!strncmp("-s", argv[i], 2))
      mcsetseed(&argv[i][2]);
    else if(!strcmp("--seed", argv[i]) && (i + 1) < argc)
      mcsetseed(argv[++i]);
    else if(!strncmp("--seed=", argv[i], 7))
      mcsetseed(&argv[i][7]);
    else if(!strcmp("-n", argv[i]) && (i + 1) < argc)
      mcsetn_arg(argv[++i]);
    else if(!strncmp("-n", argv[i], 2))
      mcsetn_arg(&argv[i][2]);
    else if(!strcmp("--ncount", argv[i]) && (i + 1) < argc)
      mcsetn_arg(argv[++i]);
    else if(!strncmp("--ncount=", argv[i], 9))
      mcsetn_arg(&argv[i][9]);
    else if(!strcmp("-d", argv[i]) && (i + 1) < argc)
      usedir=argv[++i];  /* will create directory after parsing all arguments (end of this function) */
    else if(!strncmp("-d", argv[i], 2))
      usedir=&argv[i][2];
    else if(!strcmp("--dir", argv[i]) && (i + 1) < argc)
      usedir=argv[++i];
    else if(!strncmp("--dir=", argv[i], 6))
      usedir=&argv[i][6];
    else if(!strcmp("-h", argv[i]))
      mcshowhelp(argv[0]);
    else if(!strcmp("--help", argv[i]))
      mcshowhelp(argv[0]);
    else if(!strcmp("-i", argv[i])) {
      mcformat=FLAVOR_UPPER;
      mcinfo();
    }
    else if(!strcmp("--info", argv[i]))
      mcinfo();
    else if(!strcmp("-t", argv[i]))
      mcenabletrace();
    else if(!strcmp("--trace", argv[i]))
      mcenabletrace();
    else if(!strcmp("--gravitation", argv[i]))
      mcgravitation = 1;
    else if(!strcmp("-g", argv[i]))
      mcgravitation = 1;
    else if(!strncmp("--format=", argv[i], 9)) {
      mcformat=&argv[i][9];
    }
    else if(!strcmp("--format", argv[i]) && (i + 1) < argc) {
      mcformat=argv[++i];
    }
    else if(!strcmp("--no-output-files", argv[i]))
      mcdisable_output_files = 1;
    else if(argv[i][0] != '-' && (p = strchr(argv[i], '=')) != NULL)
    {
      *p++ = '\0';

      for(j = 0; j < mcnumipar; j++)
        if(!strcmp(mcinputtable[j].name, argv[i]))
        {
          int status;
          status = (*mcinputtypes[mcinputtable[j].type].getparm)(p,
                        mcinputtable[j].par);
          if(!status || !strlen(p))
          {
            (*mcinputtypes[mcinputtable[j].type].error)
              (mcinputtable[j].name, p);
            exit(1);
          }
          paramsetarray[j] = 1;
          paramset = 1;
          break;
        }
      if(j == mcnumipar)
      {                                /* Unrecognized parameter name */
        fprintf(stderr, "Error: unrecognized parameter %s (mcparseoptions)\n", argv[i]);
        exit(1);
      }
    }
    else if(argv[i][0] == '-') {
      fprintf(stderr, "Error: unrecognized option argument %s (mcparseoptions). Ignored.\n", argv[i++]);
    }
    else {
      fprintf(stderr, "Error: unrecognized argument %s (mcparseoptions). Aborting.\n", argv[i]);
      mcusage(argv[0]);
    }
  }
  if(!paramset)
    mcreadparams();                /* Prompt for parameters if not specified. */
  else
  {
    for(j = 0; j < mcnumipar; j++)
      if(!paramsetarray[j])
      {
        fprintf(stderr, "Error: Instrument parameter %s left unset (mcparseoptions)\n",
                mcinputtable[j].name);
        exit(1);
      }
  }
  free(paramsetarray);
#ifdef USE_MPI
  if (mcdotrace) mpi_node_count=1; /* disable threading when in trace mode */
#endif
  if (usedir && strlen(usedir) && !mcdisable_output_files) mcuse_dir(usedir);
} /* mcparseoptions */

#ifndef NOSIGNALS
mcstatic char  mcsig_message[256];


/*******************************************************************************
* sighandler: signal handler that makes simulation stop, and save results
*******************************************************************************/
void sighandler(int sig)
{
  /* MOD: E. Farhi, Sep 20th 2001: give more info */
  time_t t1, t0;
#define SIG_SAVE 0
#define SIG_TERM 1
#define SIG_STAT 2
#define SIG_ABRT 3

  printf("\n# " MCCODE_STRING ": [pid %i] Signal %i detected", getpid(), sig);
#ifdef USE_MPI
  printf(" [proc %i]", mpi_node_rank);
#endif
#if defined(SIGUSR1) && defined(SIGUSR2) && defined(SIGKILL)
  if (!strcmp(mcsig_message, "sighandler") && (sig != SIGUSR1) && (sig != SIGUSR2))
  {
    printf("\n# Fatal : unrecoverable loop ! Suicide (naughty boy).\n");
    kill(0, SIGKILL); /* kill myself if error occurs within sighandler: loops */
  }
#endif
  switch (sig) {
#ifdef SIGINT
    case SIGINT : printf(" SIGINT (interrupt from terminal, Ctrl-C)"); sig = SIG_TERM; break;
#endif
#ifdef SIGILL
    case SIGILL  : printf(" SIGILL (Illegal instruction)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGFPE
    case SIGFPE  : printf(" SIGFPE (Math Error)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGSEGV
    case SIGSEGV : printf(" SIGSEGV (Mem Error)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGTERM
    case SIGTERM : printf(" SIGTERM (Termination)"); sig = SIG_TERM; break;
#endif
#ifdef SIGABRT
    case SIGABRT : printf(" SIGABRT (Abort)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGQUIT
    case SIGQUIT : printf(" SIGQUIT (Quit from terminal)"); sig = SIG_TERM; break;
#endif
#ifdef SIGTRAP
    case SIGTRAP : printf(" SIGTRAP (Trace trap)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGPIPE
    case SIGPIPE : printf(" SIGPIPE (Broken pipe)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGUSR1
    case SIGUSR1 : printf(" SIGUSR1 (Display info)"); sig = SIG_STAT; break;
#endif
#ifdef SIGUSR2
    case SIGUSR2 : printf(" SIGUSR2 (Save simulation)"); sig = SIG_SAVE; break;
#endif
#ifdef SIGHUP
    case SIGHUP  : printf(" SIGHUP (Hangup/update)"); sig = SIG_SAVE; break;
#endif
#ifdef SIGBUS
    case SIGBUS  : printf(" SIGBUS (Bus error)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGURG
    case SIGURG  : printf(" SIGURG (Urgent socket condition)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGBREAK
    case SIGBREAK: printf(" SIGBREAK (Break signal, Ctrl-Break)"); sig = SIG_SAVE; break;
#endif
    default : printf(" (look at signal list for signification)"); sig = SIG_ABRT; break;
  }
  printf("\n");
  printf("# Simulation: %s (%s) \n", mcinstrument_name, mcinstrument_source);
  printf("# Breakpoint: %s ", mcsig_message);
  if (strstr(mcsig_message, "Save") && (sig == SIG_SAVE))
    sig = SIG_STAT;
  SIG_MESSAGE("sighandler");
  if (mcget_ncount() == 0)
    printf("(0 %%)\n" );
  else
  {
    printf("%.2f %% (%10.1f/%10.1f)\n", 100.0*mcget_run_num()/mcget_ncount(), 1.0*mcget_run_num(), 1.0*mcget_ncount());
  }
  t0 = (time_t)mcstartdate;
  t1 = time(NULL);
  printf("# Date:      %s", ctime(&t1));
  printf("# Started:   %s", ctime(&t0));

  if (sig == SIG_STAT)
  {
    printf("# " MCCODE_STRING ": Resuming simulation (continue)\n");
    fflush(stdout);
    return;
  }
  else
  if (sig == SIG_SAVE)
  {
    printf("# " MCCODE_STRING ": Saving data and resume simulation (continue)\n");
    mcsave(NULL);
    fflush(stdout);
    return;
  }
  else
  if (sig == SIG_TERM)
  {
    printf("# " MCCODE_STRING ": Finishing simulation (save results and exit)\n");
    mcfinally();
    exit(0);
  }
  else
  {
    fflush(stdout);
    perror("# Last I/O Error");
    printf("# " MCCODE_STRING ": Simulation stop (abort).\n");
// This portion of the signal handling only works on UNIX
#if defined(__unix__) || defined(__APPLE__)
    signal(sig, SIG_DFL); /* force to use default sighandler now */
    kill(getpid(), sig);  /* and trigger it with the current signal */
#endif
    exit(-1);
  }
#undef SIG_SAVE
#undef SIG_TERM
#undef SIG_STAT
#undef SIG_ABRT

} /* sighandler */
#endif /* !NOSIGNALS */

/*******************************************************************************
* mccode_main: McCode main() function.
*******************************************************************************/
int mccode_main(int argc, char *argv[])
{
/*  double run_num = 0; */
  time_t  t;
#ifdef USE_MPI
  char mpi_node_name[MPI_MAX_PROCESSOR_NAME];
  int  mpi_node_name_len;
#endif /* USE_MPI */

#ifdef MAC
  argc = ccommand(&argv);
#endif

#ifdef USE_MPI
  MPI_Init(&argc,&argv);
  MPI_Comm_size(MPI_COMM_WORLD, &mpi_node_count); /* get number of nodes */
  MPI_Comm_rank(MPI_COMM_WORLD, &mpi_node_rank);
  MPI_Comm_set_name(MPI_COMM_WORLD, mcinstrument_name);
  MPI_Get_processor_name(mpi_node_name, &mpi_node_name_len);
#endif /* USE_MPI */

t = time(NULL);
mcseed = (long)t+(long)getpid();

#ifdef USE_MPI
/* *** print number of nodes *********************************************** */
  if (mpi_node_count > 1) {
    MPI_MASTER(
    printf("Simulation '%s' (%s): running on %i nodes (master is '%s', MPI version %i.%i).\n",
      mcinstrument_name, mcinstrument_source, mpi_node_count, mpi_node_name, MPI_VERSION, MPI_SUBVERSION);
    );
  }
#endif /* USE_MPI */
  
  mcstartdate = (long)t;  /* set start date before parsing options and creating sim file */

/* *** parse options ******************************************************* */
  SIG_MESSAGE("main (Start)");
  mcformat=getenv(FLAVOR_UPPER "_FORMAT") ?
           getenv(FLAVOR_UPPER "_FORMAT") : FLAVOR_UPPER;
  mcinstrument_exe = argv[0]; /* store the executable path */
  /* read simulation parameters and options */
  mcparseoptions(argc, argv); /* sets output dir and format */
  
#ifdef USE_MPI
  if (mpi_node_count > 1) {
    /* share the same seed, then adapt random seed for each node */
    MPI_Bcast(&mcseed, 1, MPI_LONG, 0, MPI_COMM_WORLD); /* root sends its seed to slaves */
    mcseed += mpi_node_rank; /* make sure we use different seeds per node */
  }
#endif
  srandom(mcseed);

/* *** install sig handler, but only once !! after parameters parsing ******* */
#ifndef NOSIGNALS
#ifdef SIGQUIT
  if (signal( SIGQUIT ,sighandler) == SIG_IGN)
    signal( SIGQUIT,SIG_IGN);   /* quit (ASCII FS) */
#endif
#ifdef SIGABRT
  if (signal( SIGABRT ,sighandler) == SIG_IGN)
    signal( SIGABRT,SIG_IGN);   /* used by abort, replace SIGIOT in the future */
#endif
#ifdef SIGTERM
  if (signal( SIGTERM ,sighandler) == SIG_IGN)
    signal( SIGTERM,SIG_IGN);   /* software termination signal from kill */
#endif
#ifdef SIGUSR1
  if (signal( SIGUSR1 ,sighandler) == SIG_IGN)
    signal( SIGUSR1,SIG_IGN);   /* display simulation status */
#endif
#ifdef SIGUSR2
  if (signal( SIGUSR2 ,sighandler) == SIG_IGN)
    signal( SIGUSR2,SIG_IGN);
#endif
#ifdef SIGHUP
  if (signal( SIGHUP ,sighandler) == SIG_IGN)
    signal( SIGHUP,SIG_IGN);
#endif
#ifdef SIGILL
  if (signal( SIGILL ,sighandler) == SIG_IGN)
    signal( SIGILL,SIG_IGN);    /* illegal instruction (not reset when caught) */
#endif
#ifdef SIGFPE
  if (signal( SIGFPE ,sighandler) == SIG_IGN)
    signal( SIGSEGV,SIG_IGN);    /* floating point exception */
#endif
#ifdef SIGBUS
  if (signal( SIGBUS ,sighandler) == SIG_IGN)
    signal( SIGSEGV,SIG_IGN);    /* bus error */
#endif
#ifdef SIGSEGV
  if (signal( SIGSEGV ,sighandler) == SIG_IGN)
    signal( SIGSEGV,SIG_IGN);   /* segmentation violation */
#endif
#endif /* !NOSIGNALS */
  mcsiminfo_init(NULL); /* open SIM */
  SIG_MESSAGE("main (Init)");
  mcinit();
#ifndef NOSIGNALS
#ifdef SIGINT
  if (signal( SIGINT ,sighandler) == SIG_IGN)
    signal( SIGINT,SIG_IGN);    /* interrupt (rubout) only after INIT */
#endif
#endif /* !NOSIGNALS */

/* ================ main particle generation/propagation loop ================ */
#if defined (USE_MPI)
  /* sliced Ncount on each MPI node */
  mcncount = mpi_node_count > 1 ?
    floor(mcncount / mpi_node_count) :
    mcncount; /* number of rays per node */
#endif

/* main particle event loop */
while(mcrun_num < mcncount || mcrun_num < mcget_ncount())
  {
#ifndef NEUTRONICS
    mcgenstate();
#endif
    /* old init: mcsetstate(0, 0, 0, 0, 0, 1, 0, sx=0, sy=1, sz=0, 1); */
    mcraytrace();
    mcrun_num++;
  }

#ifdef USE_MPI
 /* merge run_num from MPI nodes */
  if (mpi_node_count > 1) {
  double mcrun_num_double = (double)mcrun_num;
  mc_MPI_Sum(&mcrun_num_double, 1);
  mcrun_num = (unsigned long long)mcrun_num_double;
  }
#endif

/* save/finally executed by master node/thread */
  mcfinally();

#ifdef USE_MPI
  MPI_Finalize();
#endif /* USE_MPI */

  return 0;
} /* mccode_main */

#ifdef NEUTRONICS
/*Main neutronics function steers the McStas calls, initializes parameters etc */
/* Only called in case NEUTRONICS = TRUE */
void neutronics_main_(float *inx, float *iny, float *inz, float *invx, float *invy, float *invz, float *intime, float *insx, float *insy, float *insz, float *inw, float *outx, float *outy, float *outz, float *outvx, float *outvy, float *outvz, float *outtime, float *outsx, float *outsy, float *outsz, float *outwgt)
{

  extern double mcnx, mcny, mcnz, mcnvx, mcnvy, mcnvz;
  extern double mcnt, mcnsx, mcnsy, mcnsz, mcnp;

  /* External code governs iteration - McStas is iterated once per call to neutronics_main. I.e. below counter must be initiancated for each call to neutronics_main*/
  mcrun_num=0;

  time_t t;
  t = (time_t)mcstartdate;
  mcstartdate = t;  /* set start date before parsing options and creating sim file */
  mcinit();

  /* *** parse options *** */
  SIG_MESSAGE("main (Start)");
  mcformat=getenv(FLAVOR_UPPER "_FORMAT") ?
           getenv(FLAVOR_UPPER "_FORMAT") : FLAVOR_UPPER;

  /* Set neutron state based on input from neutronics code */
  mcsetstate(*inx,*iny,*inz,*invx,*invy,*invz,*intime,*insx,*insy,*insz,*inw);

  /* main neutron event loop - runs only one iteration */

  //mcstas_raytrace(&mcncount); /* prior to McStas 1.12 */

  mcallowbackprop = 1; //avoid absorbtion from negative dt
  int argc=1;
  char *argv[0];
  int dummy = mccode_main(argc, argv);

  *outx =  mcnx;
  *outy =  mcny;
  *outz =  mcnz;
  *outvx =  mcnvx;
  *outvy =  mcnvy;
  *outvz =  mcnvz;
  *outtime =  mcnt;
  *outsx =  mcnsx;
  *outsy =  mcnsy;
  *outsz =  mcnsz;
  *outwgt =  mcnp;

  return;
} /* neutronics_main */

#endif /*NEUTRONICS*/

#endif /* !MCCODE_H */
/* End of file "mccode-r.c". */
/* End of file "mccode-r.c". */

#line 4977 "./ESS_BIFROST_shielding.c"

#line 1 "mcstas-r.c"
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mcstas-r.c
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McStas X.Y
* Version: $Revision$
*
* Runtime system for McStas.
* Embedded within instrument in runtime mode.
*
* Usage: Automatically embbeded in the c code whenever required.
*
* $Id$
*
*******************************************************************************/

#ifndef MCSTAS_R_H
#include "mcstas-r.h"
#endif
#ifdef DANSE
#include "mcstas-globals.h"
#endif

/*******************************************************************************
* The I/O format definitions and functions
*******************************************************************************/

/*the magnet stack*/
#ifdef MC_POL_COMPAT
void (*mcMagnetPrecession) (double, double, double, double, double, double,
    double, double*, double*, double*, double, Coords, Rotation)=NULL;
Coords   mcMagnetPos;
Rotation mcMagnetRot;
double*  mcMagnetData                = NULL;
/* mcMagneticField(x, y, z, t, Bx, By, Bz) */
int (*mcMagneticField) (double, double, double, double,
    double*, double*, double*, void *) = NULL;
#endif

#ifndef MCSTAS_H

/*******************************************************************************
* mcstore_neutron: stores neutron coodinates into global array (per component)
*******************************************************************************/
void
mcstore_neutron(MCNUM *s, int index, double x, double y, double z,
               double vx, double vy, double vz, double t,
               double sx, double sy, double sz, double p)
{
    double *dptr = &s[11*index];
    *dptr++  = x;
    *dptr++  = y ;
    *dptr++  = z ;
    *dptr++  = vx;
    *dptr++  = vy;
    *dptr++  = vz;
    *dptr++  = t ;
    *dptr++  = sx;
    *dptr++  = sy;
    *dptr++  = sz;
    *dptr    = p ;
} /* mcstore_neutron */

/*******************************************************************************
* mcrestore_neutron: restores neutron coodinates from global array
*******************************************************************************/
void
mcrestore_neutron(MCNUM *s, int index, double *x, double *y, double *z,
               double *vx, double *vy, double *vz, double *t,
               double *sx, double *sy, double *sz, double *p)
{
    double *dptr = &s[11*index];
    *x  =  *dptr++;
    *y  =  *dptr++;
    *z  =  *dptr++;
    *vx =  *dptr++;
    *vy =  *dptr++;
    *vz =  *dptr++;
    *t  =  *dptr++;
    *sx =  *dptr++;
    *sy =  *dptr++;
    *sz =  *dptr++;
    *p  =  *dptr;
} /* mcrestore_neutron */

/*******************************************************************************
* mcsetstate: transfer parameters into global McStas variables 
*******************************************************************************/
void
mcsetstate(double x, double y, double z, double vx, double vy, double vz,
           double t, double sx, double sy, double sz, double p)
{
  extern double mcnx, mcny, mcnz, mcnvx, mcnvy, mcnvz;
  extern double mcnt, mcnsx, mcnsy, mcnsz, mcnp;

  mcnx = x;
  mcny = y;
  mcnz = z;
  mcnvx = vx;
  mcnvy = vy;
  mcnvz = vz;
  mcnt = t;
  mcnsx = sx;
  mcnsy = sy;
  mcnsz = sz;
  mcnp = p;
} /* mcsetstate */

/*******************************************************************************
* mcgenstate: set default neutron parameters 
*******************************************************************************/
void
mcgenstate(void)
{
  mcsetstate(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
  /* old initialisation: mcsetstate(0, 0, 0, 0, 0, 1, 0, sx=0, sy=1, sz=0, 1); */
}

/* intersection routines ==================================================== */

/*******************************************************************************
* inside_rectangle: Check if (x,y) is inside rectangle (xwidth, yheight) 
* return 0 if outside and 1 if inside 
*******************************************************************************/
int inside_rectangle(double x, double y, double xwidth, double yheight)
{
  if (x>-xwidth/2 && x<xwidth/2 && y>-yheight/2 && y<yheight/2)
    return 1;
  else
    return 0;
}

/*******************************************************************************
 * box_intersect: compute time intersection with a box
 * returns 0 when no intersection is found
 *      or 1 in case of intersection with resulting times dt_in and dt_out
 * This function written by Stine Nyborg, 1999. 
 *******************************************************************************/
int box_intersect(double *dt_in, double *dt_out,
                  double x, double y, double z,
                  double vx, double vy, double vz,
                  double dx, double dy, double dz)
{
  double x_in, y_in, z_in, tt, t[6], a, b;
  int i, count, s;

      /* Calculate intersection time for each of the six box surface planes
       *  If the box surface plane is not hit, the result is zero.*/

  if(vx != 0)
   {
    tt = -(dx/2 + x)/vx;
    y_in = y + tt*vy;
    z_in = z + tt*vz;
    if( y_in > -dy/2 && y_in < dy/2 && z_in > -dz/2 && z_in < dz/2)
      t[0] = tt;
    else
      t[0] = 0;

    tt = (dx/2 - x)/vx;
    y_in = y + tt*vy;
    z_in = z + tt*vz;
    if( y_in > -dy/2 && y_in < dy/2 && z_in > -dz/2 && z_in < dz/2)
      t[1] = tt;
    else
      t[1] = 0;
   }
  else
    t[0] = t[1] = 0;

  if(vy != 0)
   {
    tt = -(dy/2 + y)/vy;
    x_in = x + tt*vx;
    z_in = z + tt*vz;
    if( x_in > -dx/2 && x_in < dx/2 && z_in > -dz/2 && z_in < dz/2)
      t[2] = tt;
    else
      t[2] = 0;

    tt = (dy/2 - y)/vy;
    x_in = x + tt*vx;
    z_in = z + tt*vz;
    if( x_in > -dx/2 && x_in < dx/2 && z_in > -dz/2 && z_in < dz/2)
      t[3] = tt;
    else
      t[3] = 0;
   }
  else
    t[2] = t[3] = 0;

  if(vz != 0)
   {
    tt = -(dz/2 + z)/vz;
    x_in = x + tt*vx;
    y_in = y + tt*vy;
    if( x_in > -dx/2 && x_in < dx/2 && y_in > -dy/2 && y_in < dy/2)
      t[4] = tt;
    else
      t[4] = 0;

    tt = (dz/2 - z)/vz;
    x_in = x + tt*vx;
    y_in = y + tt*vy;
    if( x_in > -dx/2 && x_in < dx/2 && y_in > -dy/2 && y_in < dy/2)
      t[5] = tt;
    else
      t[5] = 0;
   }
  else
    t[4] = t[5] = 0;

  /* The intersection is evaluated and *dt_in and *dt_out are assigned */

  a = b = s = 0;
  count = 0;

  for( i = 0; i < 6; i = i + 1 )
    if( t[i] == 0 )
      s = s+1;
    else if( count == 0 )
    {
      a = t[i];
      count = 1;
    }
    else
    {
      b = t[i];
      count = 2;
    }

  if ( a == 0 && b == 0 )
    return 0;
  else if( a < b )
  {
    *dt_in = a;
    *dt_out = b;
    return 1;
  }
  else
  {
    *dt_in = b;
    *dt_out = a;
    return 1;
  }

} /* box_intersect */

/*******************************************************************************
 * cylinder_intersect: compute intersection with a cylinder
 * returns 0 when no intersection is found
 *      or 2/4/8/16 bits depending on intersection,
 *     and resulting times t0 and t1
 * Written by: EM,NB,ABA 4.2.98 
  *******************************************************************************/
int
cylinder_intersect(double *t0, double *t1, double x, double y, double z,
                   double vx, double vy, double vz, double r, double h)
{
  double D, t_in, t_out, y_in, y_out;
  int ret=1;

  D = (2*vx*x + 2*vz*z)*(2*vx*x + 2*vz*z)
    - 4*(vx*vx + vz*vz)*(x*x + z*z - r*r);

  if (D>=0)
  {
    if (vz*vz + vx*vx) {
      t_in  = (-(2*vz*z + 2*vx*x) - sqrt(D))/(2*(vz*vz + vx*vx));
      t_out = (-(2*vz*z + 2*vx*x) + sqrt(D))/(2*(vz*vz + vx*vx));
    } else if (vy) { /* trajectory parallel to cylinder axis */
      t_in = (-h/2-y)/vy;
      t_out = (h/2-y)/vy;
      if (t_in>t_out){
        double tmp=t_in;
        t_in=t_out;t_out=tmp;
      }
    } else return 0;
    y_in = vy*t_in + y;
    y_out =vy*t_out + y;

    if ( (y_in > h/2 && y_out > h/2) || (y_in < -h/2 && y_out < -h/2) )
      return 0;
    else
    {
      if (y_in > h/2)
        { t_in = ((h/2)-y)/vy; ret += 2; }
      else if (y_in < -h/2)
        { t_in = ((-h/2)-y)/vy; ret += 4; }
      if (y_out > h/2)
        { t_out = ((h/2)-y)/vy; ret += 8; }
      else if (y_out < -h/2)
        { t_out = ((-h/2)-y)/vy; ret += 16; }
    }
    *t0 = t_in;
    *t1 = t_out;
    return ret;
  }
  else
  {
    *t0 = *t1 = 0;
    return 0;
  }
} /* cylinder_intersect */


/*******************************************************************************
 * sphere_intersect: Calculate intersection between a line and a sphere.
 * returns 0 when no intersection is found
 *      or 1 in case of intersection with resulting times t0 and t1 
 *******************************************************************************/
int
sphere_intersect(double *t0, double *t1, double x, double y, double z,
                 double vx, double vy, double vz, double r)
{
  double A, B, C, D, v;

  v = sqrt(vx*vx + vy*vy + vz*vz);
  A = v*v;
  B = 2*(x*vx + y*vy + z*vz);
  C = x*x + y*y + z*z - r*r;
  D = B*B - 4*A*C;
  if(D < 0)
    return 0;
  D = sqrt(D);
  *t0 = (-B - D) / (2*A);
  *t1 = (-B + D) / (2*A);
  return 1;
} /* sphere_intersect */

/*******************************************************************************
 * plane_intersect: Calculate intersection between a plane and a line.
 * returns 0 when no intersection is found (i.e. line is parallel to the plane)
 * returns 1 or -1 when intersection time is positive and negative respectively
 *******************************************************************************/
int
plane_intersect(double *t, double x, double y, double z,
                 double vx, double vy, double vz, double nx, double ny, double nz, double wx, double wy, double wz)
{
  double s;
  if (fabs(s=scalar_prod(nx,ny,nz,vx,vy,vz))<FLT_EPSILON) return 0;
  *t = - scalar_prod(nx,ny,nz,x-wx,y-wy,z-wz)/s;
  if (*t<0) return -1;
  else return 1;
} /* plane_intersect */

#endif /* !MCSTAS_H */
/* End of file "mcstas-r.c". */

#line 5337 "./ESS_BIFROST_shielding.c"
#ifdef MC_TRACE_ENABLED
int mctraceenabled = 1;
#else
int mctraceenabled = 0;
#endif
#define MCSTAS "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../"
int mcdefaultmain = 1;
char mcinstrument_name[] = "ESS_BIFROST_shielding";
char mcinstrument_source[] = "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr";
char *mcinstrument_exe=NULL; /* will be set to argv[0] in main */
int main(int argc, char *argv[]){return mccode_main(argc, argv);}
void mcinit(void);
void mcraytrace(void);
void mcsave(FILE *);
void mcfinally(void);
void mcdisplay(void);

/* Shared user declarations for all components 'Elliptic_guide_gravity_shieldinglogger'. */
#line 193 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
// m_local_refl is to be used in shielding applications and accessed by shielding logger
#ifndef MVALUE_LOCAL_IS_DEF
#define MVALUE_LOCAL_IS_DEF 1
double m_local_refl=-1;
#endif

/*****************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2006, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/ref-lib.h
*
* %Identification
* Written by: Peter Christiansen
* Date: August, 2006
* Origin: RISOE
* Release: McStas 1.10
* Version: $Revision$
*
* Commonly used reflection functions are declared in this file which
* are used by some guide and mirror components.
*
* Depends on read_table-lib
*
* Usage: within SHARE
* %include "ref-lib"
*
****************************************************************************/
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/read_table-lib.h
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas 1.6
* Version: $Revision$
*
* This file is to be imported by components that may read data from table files
* It handles some shared functions.
*
* This library may be used directly as an external library. It has no dependency
*
* Usage: within SHARE
* %include "read_table-lib"
*
*******************************************************************************/

#ifndef READ_TABLE_LIB_H
#define READ_TABLE_LIB_H "$Revision$"

#define READ_TABLE_STEPTOL  0.04 /* tolerancy for constant step approx */

#ifndef MC_PATHSEP_C
#ifdef WIN32
#define MC_PATHSEP_C '\\'
#define MC_PATHSEP_S "\\"
#else  /* !WIN32 */
#ifdef MAC
#define MC_PATHSEP_C ':'
#define MC_PATHSEP_S ":"
#else  /* !MAC */
#define MC_PATHSEP_C '/'
#define MC_PATHSEP_S "/"
#endif /* !MAC */
#endif /* !WIN32 */
#endif /* !MC_PATHSEP_C */

#ifndef MCSTAS
#ifdef WIN32
#define MCSTAS "C:\\mcstas\\lib"
#else  /* !WIN32 */
#ifdef MAC
#define MCSTAS ":mcstas:lib" /* ToDo: What to put here? */
#else  /* !MAC */
#define MCSTAS "/usr/local/lib/mcstas"
#endif /* !MAC */
#endif /* !WIN32 */
#endif /* !MCSTAS */

#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>

  typedef struct struct_table
  {
    char    filename[1024];
    long    filesize;
    char   *header;  /* text header, e.g. comments */
    double *data;    /* vector { x[0], y[0], ... x[n-1], y[n-1]... } */
    double  min_x;   /* min value of first column */
    double  max_x;   /* max value of first column */
    double  step_x;  /* minimal step value of first column */
    long    rows;    /* number of rows in matrix block */
    long    columns; /* number of columns in matrix block */

    long    begin;   /* start fseek index of block */
    long    end;     /* stop  fseek index of block */
    long    block_number;  /* block index. 0 is catenation of all */
    long    array_length;  /* number of elements in the t_Table array */
    char    monotonic;     /* true when 1st column/vector data is monotonic */
    char    constantstep;  /* true when 1st column/vector data has constant step */
    char    method[32];    /* interpolation method: nearest, linear */
  } t_Table;

/*maximum number of rows to rebin a table = 1M*/
enum { mcread_table_rebin_maxsize = 1000000 };

typedef struct t_Read_table_file_item {
    int ref_count;
    t_Table *table_ref;
} t_Read_table_file_item;

typedef enum enum_Read_table_file_actions {STORE,FIND,GC}  t_Read_table_file_actions;

/* read_table-lib function prototypes */
/* ========================================================================= */

/* 'public' functions */
long     Table_Read              (t_Table *Table, char *File, long block_number);
long     Table_Read_Offset       (t_Table *Table, char *File, long block_number,
                                  long *offset, long max_lines);
long     Table_Read_Offset_Binary(t_Table *Table, char *File, char *Type,
                                  long *Offset, long Rows, long Columns);
long     Table_Rebin(t_Table *Table); /* rebin table with regular 1st column and interpolate all columns 2:end */
long     Table_Info (t_Table Table);
double   Table_Index(t_Table Table,   long i, long j); /* get indexed value */
double   Table_Value(t_Table Table, double X, long j); /* search X in 1st column and return interpolated value in j-column */
t_Table *Table_Read_Array(char *File, long *blocks);
void     Table_Free_Array(t_Table *Table);
long     Table_Info_Array(t_Table *Table);
int      Table_SetElement(t_Table *Table, long i, long j, double value);
long     Table_Init(t_Table *Table, long rows, long columns); /* create a Table */
double   Table_Value2d(t_Table Table, double X, double Y);    /* same as Table_Index with non-integer indices and 2d interpolation */
MCDETECTOR Table_Write(t_Table Table, char*file, char*xl, char*yl, 
           double x1, double x2, double y1, double y2); /* write Table to disk */
void * Table_File_List_Handler(t_Read_table_file_actions action, void *item, void *item_modifier);
t_Table *Table_File_List_find(char *name, int block, int offset);
int Table_File_List_gc(t_Table *tab);
void *Table_File_List_store(t_Table *tab);

#define Table_ParseHeader(header, ...) \
  Table_ParseHeader_backend(header,__VA_ARGS__,NULL);

char **Table_ParseHeader_backend(char *header, ...);

/* private functions */
void Table_Free(t_Table *Table);
long Table_Read_Handle(t_Table *Table, FILE *fid, long block_number, long max_lines, char *name);
static void Table_Stat(t_Table *Table);
double Table_Interp1d(double x, double x1, double y1, double x2, double y2);
double Table_Interp1d_nearest(double x, double x1, double y1, double x2, double y2);
double Table_Interp2d(double x, double y, double x1, double y1, double x2, double y2,
double z11, double z12, double z21, double z22);

#endif

/* end of read_table-lib.h */
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/read_table-lib.c
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas CVS_090504
* Version: $Revision: 5052 $
*
* This file is to be imported by components that may read data from table files
* It handles some shared functions. Embedded within instrument in runtime mode.
*
* Usage: within SHARE
* %include "read_table-lib"
*
*******************************************************************************/

#ifndef READ_TABLE_LIB_H
#include "read_table-lib.h"
#endif


/*******************************************************************************
 * void *Table_File_List_Handler(action, item, item_modifier)
 *   ACTION: handle file entries in the read_table-lib file list. If a file is read - it is supposed to be
 *   stored in a list such that we can avoid reading the same file many times.
 *   input  action: FIND, STORE, GC. check if file exists in the list, store an item in the list, or check if it can be garbage collected.
 *   input item: depends on the action.
 *    FIND)  item is a filename, and item_modifier is the block number
 *    STORE) item is the Table to store - item_modifier is ignored
 *    GC)    item is the Table to check. If it has a ref_count >1 then this is simply decremented.
 *   return  depends on the action
 *    FIND)  return a reference to a table+ref_count item if found - NULL otherwise. I.e. NULL means the file has not been read before and must be read again.
 *    STORE) return NULL always
 *    GC)    return NULL if no garbage collection is needed, return an adress to the t_Table which should be garbage collected. 0x1 is returned if
 *           the item is not found in the list
*******************************************************************************/
void * Table_File_List_Handler(t_Read_table_file_actions action, void *item, void *item_modifier){

    /* logic here is Read_Table should include a call to FIND. If found the return value should just be used as
     * if the table had been read from disk. If not found then read the table and STORE.
     * Table_Free should include a call to GC. If this returns non-NULL then we should proceed with freeing the memory
     * associated with the table item - otherwise only decrement the reference counter since there are more references
     * that may need it.*/

    static t_Read_table_file_item read_table_file_list[1024];  
    static int read_table_file_count=0;

    t_Read_table_file_item *tr;
    switch(action){
        case FIND:
            /*interpret data item as a filename, if it is found return a pointer to the table and increment refcount.
             * if not found return the item itself*/
            tr=read_table_file_list;
            while ( tr->table_ref!=NULL ){
                int i=*((int*) item_modifier);
                int j=*( ((int*) item_modifier)+1);
                if ( !strcmp(tr->table_ref->filename,(char *) item) &&
                        tr->table_ref->block_number==i && tr->table_ref->begin==j ){
                    tr->ref_count++;
                    return (void *) tr;
                }
                tr++;
            }
            return NULL;
        case STORE:
            /*find an available slot and store references to table there*/
            tr=&(read_table_file_list[read_table_file_count++]);
            tr->table_ref = ((t_Table *) item);
            tr->ref_count++;
            return NULL;
        case GC:
            /* Should this item be garbage collected (freed) - if so scratch the entry and return the address of the item - 
             * else decrement ref_count and return NULL.
             * A non-NULL return expects the item to actually be freed afterwards.*/
            tr=read_table_file_list;
            while ( tr->table_ref!=NULL ){
                if ( tr->table_ref->data ==((t_Table *)item)->data && 
                        tr->table_ref->block_number == ((t_Table *)item)->block_number){
                    /*matching item found*/
                    if (tr->ref_count>1){
                        /*the item is found and no garbage collection needed*/
                        tr->ref_count--;
                        return NULL;
                    }else{
                        /* The item is found and the reference counter is 1.
                         * This means we should garbage collect. Move remaining list items up one slot,
                         * and return the table for garbage collection by caller*/
                        while (tr->table_ref!=NULL){
                            *tr=*(tr+1);
                            tr++;
                        }
                        read_table_file_count--;
                        return (t_Table *) item;
                    }
                }
                tr++;
            }
            /* item not found, and so should be garbage collected. This could be the case if freeing a
             * Table that has been constructed from code - not read from file. Return 0x1 to flag it for
             * collection.*/
            return (void *) 0x1 ;
    }
}

/* Access functions to the handler*/

/********************************************
 * t_Table *Table_File_List_find(char *name, int block, int offset)
 * input name: filename to search for in the file list
 * input block: data block in the file as each file may contain more than 1 data block.
 * return a ref. to a table if it is found (you may use this pointer and skip reading the file), NULL otherwise (i.e. go ahead and read the file)
*********************************************/
t_Table *Table_File_List_find(char *name, int block, int offset){
    int vars[2]={block,offset};
    t_Read_table_file_item *item = Table_File_List_Handler(FIND,name, vars);
    if (item == NULL){
        return NULL;
    }else{
        return item->table_ref;
    }
}
/********************************************
 * int Table_File_List_gc(t_Table *tab)
 * input tab: the table to check for references.
 * return 0: no garbage collection needed
 *        1: Table's data and header (at least) should be freed.
*********************************************/
int Table_File_List_gc(t_Table *tab){
    void *rval=Table_File_List_Handler(GC,tab,0);
    if (rval==NULL) return 0;
    else return 1;
}


/*****************************************************************************
 * void *Table_File_List_store(t_Table *tab)
 * input tab: pointer to table to store.
 * return None. 
*******************************************************************************/
void *Table_File_List_store(t_Table *tab){
    return Table_File_List_Handler(STORE,tab,0);
}


/*******************************************************************************
* FILE *Open_File(char *name, char *Mode, char *path)
*   ACTION: search for a file and open it. Optionally return the opened path.
*   input   name:  file name from which table should be extracted
*           mode: "r", "w", "a" or any valid fopen mode
*           path:  NULL or a pointer to at least 1024 allocated chars
*   return  initialized file handle or NULL in case of error
*******************************************************************************/

  FILE *Open_File(char *File, const char *Mode, char *Path)
  {
    char path[1024];
    FILE *hfile = NULL;
    
    if (!File || File[0]=='\0')                     return(NULL);
    if (!strcmp(File,"NULL") || !strcmp(File,"0"))  return(NULL);
    
    /* search in current or full path */
    strncpy(path, File, 1024);
    hfile = fopen(path, Mode);
    if(!hfile)
    {
      char dir[1024];

      if (!hfile && mcinstrument_source[0] != '\0' && strlen(mcinstrument_source)) /* search in instrument source location */
      {
        char *path_pos   = NULL;
        /* extract path: searches for last file separator */
        path_pos    = strrchr(mcinstrument_source, MC_PATHSEP_C);  /* last PATHSEP */
        if (path_pos) {
          long path_length = path_pos +1 - mcinstrument_source;  /* from start to path+sep */
          if (path_length) {
            strncpy(dir, mcinstrument_source, path_length);
            dir[path_length] = '\0';
            snprintf(path, 1024, "%s%c%s", dir, MC_PATHSEP_C, File);
            hfile = fopen(path, Mode);
          }
        }
      }
      if (!hfile && mcinstrument_exe[0] != '\0' && strlen(mcinstrument_exe)) /* search in PWD instrument executable location */
      {
        char *path_pos   = NULL;
        /* extract path: searches for last file separator */
        path_pos    = strrchr(mcinstrument_exe, MC_PATHSEP_C);  /* last PATHSEP */
        if (path_pos) {
          long path_length = path_pos +1 - mcinstrument_exe;  /* from start to path+sep */
          if (path_length) {
            strncpy(dir, mcinstrument_exe, path_length);
            dir[path_length] = '\0';
            snprintf(path, 1024, "%s%c%s", dir, MC_PATHSEP_C, File);
            hfile = fopen(path, Mode);
          }
        }
      }
      if (!hfile) /* search in HOME or . */
      {
        strcpy(dir, getenv("HOME") ? getenv("HOME") : ".");
        snprintf(path, 1024, "%s%c%s", dir, MC_PATHSEP_C, File);
        hfile = fopen(path, Mode);
      }
      if (!hfile) /* search in MCSTAS/data */
      {
        strcpy(dir, getenv(FLAVOR_UPPER) ? getenv(FLAVOR_UPPER) : MCSTAS);
        snprintf(path, 1024, "%s%c%s%c%s", dir, MC_PATHSEP_C, "data", MC_PATHSEP_C, File);
        hfile = fopen(path, Mode);
      }
      if (!hfile) /* search in MVCSTAS/contrib */
      {
        strcpy(dir, getenv(FLAVOR_UPPER) ? getenv(FLAVOR_UPPER) : MCSTAS);
        snprintf(path, 1024, "%s%c%s%c%s", dir, MC_PATHSEP_C, "contrib", MC_PATHSEP_C, File);
        hfile = fopen(path, Mode);
      }
      if(!hfile)
      {
        fprintf(stderr, "Error: Could not open input file '%s' (Open_File)\n", File);
        return (NULL);
      }
    }
    if (Path) strncpy(Path, path, 1024);
    return(hfile);
  } /* end Open_File */

/*******************************************************************************
* long Read_Table(t_Table *Table, char *name, int block_number)
*   ACTION: read a single Table from a text file
*   input   Table: pointer to a t_Table structure
*           name:  file name from which table should be extracted
*           block_number: if the file does contain more than one
*                 data block, then indicates which one to get (from index 1)
*                 a 0 value means append/catenate all
*   return  initialized single Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
* The routine stores any line starting with '#', '%' and ';' into the header
* File is opened, read and closed
* Other lines are interpreted as numerical data, and stored.
* Data block should be a rectangular matrix or vector.
* Data block may be rebinned with Table_Rebin (also sort in ascending order)
*******************************************************************************/
  long Table_Read(t_Table *Table, char *File, long block_number)
  { /* reads all or a single data block from 'file' and returns a Table structure  */
    return(Table_Read_Offset(Table, File, block_number, NULL, 0));
  } /* end Table_Read */

/*******************************************************************************
* long Table_Read_Offset(t_Table *Table, char *name, int block_number, long *offset
*                        long max_rows)
*   ACTION: read a single Table from a text file, starting at offset
*     Same as Table_Read(..) except:
*   input   offset:    pointer to an offset (*offset should be 0 at start)
*           max_rows: max number of data rows to read from file (0 means all)
*   return  initialized single Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
*           updated *offset position (where end of reading occured)
*******************************************************************************/
  long Table_Read_Offset(t_Table *Table, char *File,
                         long block_number, long *offset,
                         long max_rows)
  { /* reads all/a data block in 'file' and returns a Table structure  */
    FILE *hfile;
    long  nelements=0;
    long  begin=0;
    long  filesize=0;
    char  name[1024];
    char  path[1024];
    struct stat stfile;

    /*Need to be able to store the pointer*/
    if (!Table) return(-1);
    
    //if (offset && *offset) snprintf(name, 1024, "%s@%li", File, *offset);
    //else                   
    strncpy(name, File, 1024);
    if(offset && *offset){
        begin=*offset;
    }
    /* Check if the table has already been read from file.
     * If so just reuse the table, if not (this is flagged by returning NULL
     * set up a new table and read the data into it */
    t_Table *tab_p= Table_File_List_find(name,block_number,begin);
    if ( tab_p!=NULL ){
        /*table was found in the Table_File_List*/
        // printf("Reusing input file '%s' (Table_Read_Offset)\n", name);
        *Table=*tab_p;
        return Table->rows*Table->columns;
    }

    /* open the file */
    hfile = Open_File(File, "r", path);
    if (!hfile) return(-1);
    else {
      MPI_MASTER(
      printf("Opening input file '%s' (Table_Read_Offset)\n", path);
      );
    }
    
    /* read file state */
    stat(path,&stfile); filesize = stfile.st_size;
    if (offset && *offset) fseek(hfile, *offset, SEEK_SET);
    begin     = ftell(hfile);
    
    Table_Init(Table, 0, 0);

    /* read file content and set the Table */
    nelements = Table_Read_Handle(Table, hfile, block_number, max_rows, name);
    Table->begin = begin;
    Table->end   = ftell(hfile);
    Table->filesize = (filesize>0 ? filesize : 0);
    Table_Stat(Table);
    
    Table_File_List_store(Table);

    if (offset) *offset=Table->end;
    fclose(hfile);
    return(nelements);

  } /* end Table_Read_Offset */

/*******************************************************************************
* long Table_Read_Offset_Binary(t_Table *Table, char *File, char *type,
*                               long *offset, long rows, long columns)
*   ACTION: read a single Table from a binary file, starting at offset
*     Same as Table_Read_Offset(..) except that it handles binary files.
*   input   type: may be "float"/NULL or "double"
*           offset: pointer to an offset (*offset should be 0 at start)
*           rows   : number of rows (0 means read all)
*           columns: number of columns
*   return  initialized single Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
*           updated *offset position (where end of reading occured)
*******************************************************************************/
  long Table_Read_Offset_Binary(t_Table *Table, char *File, char *type,
                                long *offset, long rows, long columns)
  { /* reads all/a data block in binary 'file' and returns a Table structure  */
    long    nelements, sizeofelement;
    long    filesize;
    FILE   *hfile;
    char    path[1024];
    struct stat stfile;
    double *data;
    long    i;
    long    begin;

    if (!Table) return(-1);

    Table_Init(Table, 0, 0);
    
    /* open the file */
    hfile = Open_File(File, "r", path);
    if (!hfile) return(-1);
    else {
      MPI_MASTER(
      printf("Opening input file '%s' (Table_Read, Binary)\n", path);
      );
    }
    
    /* read file state */
    stat(File,&stfile);
    filesize = stfile.st_size;
    Table->filesize=filesize;
    
    /* read file content */
    if (type && !strcmp(type,"double")) sizeofelement = sizeof(double);
    else  sizeofelement = sizeof(float);
    if (offset && *offset) fseek(hfile, *offset, SEEK_SET);
    begin     = ftell(hfile);
    if (rows && filesize > sizeofelement*columns*rows)
      nelements = columns*rows;
    else nelements = (long)(filesize/sizeofelement);
    if (!nelements || filesize <= *offset) return(0);
    data    = (double*)malloc(nelements*sizeofelement);
    if (!data) {
      fprintf(stderr,"Error: allocating %ld elements for %s file '%s'. Too big (Table_Read_Offset_Binary).\n", nelements, type, File);
      exit(-1);
    }
    nelements = fread(data, sizeofelement, nelements, hfile);

    if (!data || !nelements)
    {
      fprintf(stderr,"Error: reading %ld elements from %s file '%s' (Table_Read_Offset_Binary)\n", nelements, type, File);
      exit(-1);
    }
    Table->begin   = begin;
    Table->end     = ftell(hfile);
    if (offset) *offset=Table->end;
    fclose(hfile);
    data = (double*)realloc(data, (double)nelements*sizeofelement);
    /* copy file data into Table */
    if (type && !strcmp(type,"double")) Table->data = data;
    else {
      float  *s;
      double *dataf;
      s     = (float*)data;
      dataf = (double*)malloc(sizeof(double)*nelements);
      for (i=0; i<nelements; i++)
        dataf[i]=s[i];
      free(data);
      Table->data = dataf;
    }
    strncpy(Table->filename, File, 1024);
    Table->rows    = nelements/columns;
    Table->columns = columns;
    Table->array_length = 1;
    Table->block_number = 1;

    Table_Stat(Table);

    return(nelements);
  } /* end Table_Read_Offset_Binary */

/*******************************************************************************
* long Table_Read_Handle(t_Table *Table, FILE *fid, int block_number, long max_rows, char *name)
*   ACTION: read a single Table from a text file handle (private)
*   input   Table:pointer to a t_Table structure
*           fid:  pointer to FILE handle
*           block_number: if the file does contain more than one
*                 data block, then indicates which one to get (from index 1)
*                 a 0 value means append/catenate all
*           max_rows: if non 0, only reads that number of lines
*   return  initialized single Table t_Table structure containing data, header, ...
*           modified Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
* The routine stores any line starting with '#', '%' and ';' into the header
* Other lines are interpreted as numerical data, and stored.
* Data block should be a rectangular matrix or vector.
* Data block may be rebined with Table_Rebin (also sort in ascending order)
*******************************************************************************/
  long Table_Read_Handle(t_Table *Table, FILE *hfile,
                         long block_number, long max_rows, char *name)
  { /* reads all/a data block from 'file' handle and returns a Table structure  */
    double *Data;
    char *Header              = NULL;
    long  malloc_size         = CHAR_BUF_LENGTH;
    long  malloc_size_h       = 4096;
    long  Rows = 0,   Columns = 0;
    long  count_in_array      = 0;
    long  count_in_header     = 0;
    long  block_Current_index = 0;
    char  flag_End_row_loop   = 0;

    if (!Table) return(-1);
    Table_Init(Table, 0, 0);
    if (name && name[0]!='\0') strncpy(Table->filename, name, 1024);

    if(!hfile) {
       fprintf(stderr, "Error: File handle is NULL (Table_Read_Handle).\n");
       return (-1);
    }
    Header = (char*)  calloc(malloc_size_h, sizeof(char));
    Data   = (double*)calloc(malloc_size,   sizeof(double));
    if ((Header == NULL) || (Data == NULL)) {
       fprintf(stderr, "Error: Could not allocate Table and Header (Table_Read_Handle).\n");
       return (-1);
    }

    int flag_In_array = 0;
    do { /* while (!flag_End_row_loop) */
      char  line[1024*CHAR_BUF_LENGTH];
      long  back_pos=0;   /* ftell start of line */

      back_pos = ftell(hfile);
      if (fgets(line, 1024*CHAR_BUF_LENGTH, hfile) != NULL) { /* analyse line */
        /* first skip blank and tabulation characters */
        int i = strspn(line, " \t");

        /* handle comments: stored in header */
        if (NULL != strchr("#%;/", line[i]))
        { /* line is a comment */
          count_in_header += strlen(line);
          if (count_in_header >= malloc_size_h) {
            /* if succeed and in array : add (and realloc if necessary) */
            malloc_size_h = count_in_header+4096;
            Header        = (char*)realloc(Header, malloc_size_h*sizeof(char));
          }
          strncat(Header, line, 4096);
          flag_In_array=0;
          /* exit line and file if passed desired block */
          if (block_number > 0 && block_number == block_Current_index) {
            flag_End_row_loop = 1;
          }

          /* Continue with next line */
          continue;
        }

        /* get the number of columns splitting line with strtok */
        char  *lexeme;
        char  flag_End_Line = 0;
        long  block_Num_Columns = 0;
        const char seps[] = " ,;\t\n\r";

        lexeme = strtok(line, seps);
        while (!flag_End_Line) {
          if ((lexeme != NULL) && (lexeme[0] != '\0')) {
            /* reading line: the token is not empty */
            double X;
            int    count=1;
            /* test if we have 'NaN','Inf' */
            if (!strncasecmp(lexeme,"NaN",3))
              X = 0;
            else if (!strncasecmp(lexeme,"Inf",3) || !strncasecmp(lexeme,"+Inf",4))
              X = FLT_MAX;
            else if (!strncasecmp(lexeme,"-Inf",4))
              X = -FLT_MAX;
            else
              count = sscanf(lexeme,"%lg",&X);
            if (count == 1) {
              /* reading line: the token is a number in the line */
              if (!flag_In_array) {
                /* reading num: not already in a block: starts a new data block */
                block_Current_index++;
                flag_In_array    = 1;
                block_Num_Columns= 0;
                if (block_number > 0) {
                  /* initialise a new data block */
                  Rows = 0;
                  count_in_array = 0;
                } /* else append */
              }
              /* reading num: all blocks or selected block */
              if (flag_In_array && (block_number == 0 ||
                  block_number == block_Current_index)) {
                /* starting block: already the desired number of rows ? */
                if (block_Num_Columns == 0 &&
                    max_rows > 0 && Rows >= max_rows) {
                  flag_End_Line      = 1;
                  flag_End_row_loop  = 1;
                  flag_In_array      = 0;
                  /* reposition to begining of line (ignore line) */
                  fseek(hfile, back_pos, SEEK_SET);
                } else { /* store into data array */
                  if (count_in_array >= malloc_size) {
                    /* realloc data buffer if necessary */
                    malloc_size = count_in_array*1.5;
                    Data = (double*) realloc(Data, malloc_size*sizeof(double));
                    if (Data == NULL) {
                      fprintf(stderr, "Error: Can not re-allocate memory %li (Table_Read_Handle).\n",
                              malloc_size*sizeof(double));
                      return (-1);
                    }
                  }
                  if (0 == block_Num_Columns) Rows++;
                  Data[count_in_array] = X;
                  count_in_array++;
                  block_Num_Columns++;
                }
              } /* reading num: end if flag_In_array */
            } /* end reading num: end if sscanf lexeme -> numerical */
            else {
              /* reading line: the token is not numerical in that line. end block */
              if (block_Current_index == block_number) {
                flag_End_Line = 1;
                flag_End_row_loop = 1;
              } else {
                flag_In_array = 0;
                flag_End_Line = 1;
              }
            }
          }
          else {
            /* no more tokens in line */
            flag_End_Line = 1;
            if (block_Num_Columns > 0) Columns = block_Num_Columns;
          }

          // parse next token
          lexeme = strtok(NULL, seps);

        } /* while (!flag_End_Line) */
      } /* end: if fgets */
      else flag_End_row_loop = 1; /* else fgets : end of file */

    } while (!flag_End_row_loop); /* end while flag_End_row_loop */

    Table->block_number = block_number;
    Table->array_length = 1;

    // shrink header to actual size (plus terminating 0-byte)
    if (count_in_header) {
      Header = (char*)realloc(Header, count_in_header*sizeof(char) + 1);
    }
    Table->header = Header;

    if (count_in_array*Rows*Columns == 0)
    {
      Table->rows         = 0;
      Table->columns      = 0;
      free(Data);
      return (0);
    }
    if (Rows * Columns != count_in_array)
    {
      fprintf(stderr, "Warning: Read_Table :%s %s Data has %li values that should be %li x %li\n",
        (Table->filename[0] != '\0' ? Table->filename : ""),
        (!block_number ? " catenated" : ""),
        count_in_array, Rows, Columns);
      Columns = count_in_array; Rows = 1;
    }
    Data     = (double*)realloc(Data, count_in_array*sizeof(double));
    Table->data         = Data;
    Table->rows         = Rows;
    Table->columns      = Columns;

    return (count_in_array);

  } /* end Table_Read_Handle */

/*******************************************************************************
* long Table_Rebin(t_Table *Table)
*   ACTION: rebin a single Table, sorting 1st column in ascending order
*   input   Table: single table containing data.
*                  The data block is reallocated in this process
*   return  updated Table with increasing, evenly spaced first column (index 0)
*           number of data elements (-1: error, 0:empty data)
*******************************************************************************/
  long Table_Rebin(t_Table *Table)
  {
    double new_step=0;
    long   i;
    /* performs linear interpolation on X axis (0-th column) */

    if (!Table) return(-1);
    if (!Table->data 
    || Table->rows*Table->columns == 0 || !Table->step_x)
      return(0);
    Table_Stat(Table); /* recompute statitstics and minimal step */
    new_step = Table->step_x; /* minimal step in 1st column */

    if (!(Table->constantstep)) /* not already evenly spaced */
    {
      long Length_Table;
      double *New_Table;

      Length_Table = ceil(fabs(Table->max_x - Table->min_x)/new_step)+1;
      /*return early if the rebinned table will become too large*/
      if (Length_Table > mcread_table_rebin_maxsize){
        fprintf(stderr,"WARNING: (Table_Rebin): Rebinning table from %s would exceed 1M rows. Skipping.\n", Table->filename); 
        return(Table->rows*Table->columns);
      }
      New_Table    = (double*)malloc(Length_Table*Table->columns*sizeof(double));

      for (i=0; i < Length_Table; i++)
      {
        long   j;
        double X;
        X = Table->min_x + i*new_step;
        New_Table[i*Table->columns] = X;
        for (j=1; j < Table->columns; j++)
          New_Table[i*Table->columns+j]
                = Table_Value(*Table, X, j);
      } /* end for i */

      Table->rows = Length_Table;
      Table->step_x = new_step;
      Table->max_x = Table->min_x + (Length_Table-1)*new_step; 
      /*max might not be the same anymore
       * Use Length_Table -1 since the first and laset rows are the limits of the defined interval.*/
      free(Table->data);
      Table->data = New_Table;
      Table->constantstep=1;
    } /* end else (!constantstep) */
    return (Table->rows*Table->columns);
  } /* end Table_Rebin */

/*******************************************************************************
* double Table_Index(t_Table Table, long i, long j)
*   ACTION: read an element [i,j] of a single Table
*   input   Table: table containing data
*           i : index of row      (0:Rows-1)
*           j : index of column   (0:Columns-1)
*   return  Value = data[i][j]
* Returns Value from the i-th row, j-th column of Table
* Tests are performed on indexes i,j to avoid errors
*******************************************************************************/

#ifndef MIN
#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
#endif

double Table_Index(t_Table Table, long i, long j)
{
  long AbsIndex;

  if (Table.rows == 1 || Table.columns == 1) {
    /* vector */
    j = MIN(MAX(0, i+j), Table.columns*Table.rows - 1);
    i = 0;
  } else {
    /* matrix */
    i = MIN(MAX(0, i), Table.rows - 1);
    j = MIN(MAX(0, j), Table.columns - 1);
  }

  /* handle vectors specifically */
  AbsIndex = i*(Table.columns)+j;

  if (Table.data != NULL)
    return (Table.data[AbsIndex]);
  else
    return 0;
} /* end Table_Index */

/*******************************************************************************
* void Table_SetElement(t_Table *Table, long i, long j, double value)
*   ACTION: set an element [i,j] of a single Table
*   input   Table: table containing data
*           i : index of row      (0:Rows-1)
*           j : index of column   (0:Columns-1)
*           value = data[i][j]
* Returns 0 in case of error
* Tests are performed on indexes i,j to avoid errors
*******************************************************************************/
int Table_SetElement(t_Table *Table, long i, long j,
                     double value)
{
  long AbsIndex;

  if (Table->rows == 1 || Table->columns == 1) {
    /* vector */
    j = MIN(MAX(0, i+j), Table->columns*Table->rows - 1); i=0;
  } else {
    /* matrix */
    i = MIN(MAX(0, i), Table->rows - 1);
    j = MIN(MAX(0, j), Table->columns - 1);
  }

  AbsIndex = i*(Table->columns)+j;
  if (Table->data != NULL) {
    Table->data[AbsIndex] = value;
    return 1;
  }

  return 0;
} /* end Table_SetElement */

/*******************************************************************************
* double Table_Value(t_Table Table, double X, long j)
*   ACTION: read column [j] of a single Table at row which 1st column is X
*   input   Table: table containing data.
*           X : data value in the first column (index 0)
*           j : index of column from which is extracted the Value (0:Columns-1)
*   return  Value = data[index for X][j] with linear interpolation
* Returns Value from the j-th column of Table corresponding to the
* X value for the 1st column (index 0)
* Tests are performed (within Table_Index) on indexes i,j to avoid errors
* NOTE: data should rather be monotonic, and evenly sampled.
*******************************************************************************/
double Table_Value(t_Table Table, double X, long j)
{
  long   Index = -1;
  double X1=0, Y1=0, X2=0, Y2=0;
  double ret=0;

  if (X > Table.max_x) return Table_Index(Table,Table.rows-1  ,j);
  if (X < Table.min_x) return Table_Index(Table,0  ,j);

  // Use constant-time lookup when possible
  if(Table.constantstep) {
    Index = (long)floor(
              (X - Table.min_x) / (Table.max_x - Table.min_x) * (Table.rows-1));
    X1 = Table_Index(Table,Index  ,0);
    X2 = Table_Index(Table,Index+1,0);
  }
  // Use binary search on large, monotonic tables
  else if(Table.monotonic && Table.rows > 100) {
    long left = Table.min_x;
    long right = Table.max_x;

    while (!((X1 <= X) && (X < X2)) && (right - left > 1)) {
      Index = (left + right) / 2;

      X1 = Table_Index(Table, Index-1, 0);
      X2 = Table_Index(Table, Index,   0);

      if (X < X1) {
        right = Index;
      } else {
        left  = Index;
      }
    }
  }

  // Fall back to linear search, if no-one else has set X1, X2 correctly
  if (!((X1 <= X) && (X < X2))) {
    /* look for index surrounding X in the table -> Index */
    for (Index=1; Index <= Table.rows-1; Index++) {
        X1 = Table_Index(Table, Index-1,0);
        X2 = Table_Index(Table, Index  ,0);
        if ((X1 <= X) && (X < X2)) break;
      } /* end for Index */
  }

  Y1 = Table_Index(Table,Index-1,j);
  Y2 = Table_Index(Table,Index  ,j);

  if (!strcmp(Table.method,"linear")) {
    ret = Table_Interp1d(X, X1,Y1, X2,Y2);
  }
  else if (!strcmp(Table.method,"nearest")) {
    ret = Table_Interp1d_nearest(X, X1,Y1, X2,Y2);
  }

  return ret;
} /* end Table_Value */

/*******************************************************************************
* double Table_Value2d(t_Table Table, double X, double Y)
*   ACTION: read element [X,Y] of a matrix Table
*   input   Table: table containing data.
*           X : row index, may be non integer
*           Y : column index, may be non integer
*   return  Value = data[index X][index Y] with bi-linear interpolation
* Returns Value for the indices [X,Y]
* Tests are performed (within Table_Index) on indexes i,j to avoid errors
* NOTE: data should rather be monotonic, and evenly sampled.
*******************************************************************************/
  double Table_Value2d(t_Table Table, double X, double Y)
  {
    long   x1,x2,y1,y2;
    double z11,z12,z21,z22;
    double ret=0;

    x1 = (long)floor(X);
    y1 = (long)floor(Y);

    if (x1 > Table.rows-1 || x1 < 0) {
      x2 = x1;
    } else {
      x2 = x1 + 1;
    }

    if (y1 > Table.columns-1 || y1 < 0) {
      y2 = y1;
    } else {
      y2 = y1 + 1;
    }

    z11 = Table_Index(Table, x1, y1);

    if (y2 != y1) z12=Table_Index(Table, x1, y2); else z12 = z11;
    if (x2 != x1) z21=Table_Index(Table, x2, y1); else z21 = z11;
    if (y2 != y1) z22=Table_Index(Table, x2, y2); else z22 = z21;

    if (!strcmp(Table.method,"linear"))
      ret = Table_Interp2d(X,Y, x1,y1,x2,y2, z11,z12,z21,z22);
    else {
      if (fabs(X-x1) < fabs(X-x2)) {
        if (fabs(Y-y1) < fabs(Y-y2)) ret = z11; else ret = z12;
      } else {
        if (fabs(Y-y1) < fabs(Y-y2)) ret = z21; else ret = z22;
      }
    }
    return ret;
  } /* end Table_Value2d */


/*******************************************************************************
* void Table_Free(t_Table *Table)
*   ACTION: free a single Table. First Call Table_File_list_gc. If this returns
*   non-zero it means there are more refernces to the table, and so the table
*   should not bee freed.
*   return: empty Table
*******************************************************************************/
  void Table_Free(t_Table *Table)
  {
    if( !Table_File_List_gc(Table) ){
       return;
    } 
    if (!Table) return;
    if (Table->data   != NULL) free(Table->data);
    if (Table->header != NULL) free(Table->header);
    Table->data   = NULL;
    Table->header = NULL;
  } /* end Table_Free */

/******************************************************************************
* void Table_Info(t_Table Table)
*    ACTION: print informations about a single Table
*******************************************************************************/
  long Table_Info(t_Table Table)
  {
    char buffer[256];
    long ret=0;

    if (!Table.block_number) strcpy(buffer, "catenated");
    else sprintf(buffer, "block %li", Table.block_number);
    printf("Table from file '%s' (%s)",
      Table.filename[0] != '\0' ? Table.filename : "", buffer);
    if ((Table.data != NULL) && (Table.rows*Table.columns))
    {
      printf(" is %li x %li ", Table.rows, Table.columns);
      if (Table.rows*Table.columns > 1)
        printf("(x=%g:%g)", Table.min_x, Table.max_x);
      else printf("(x=%g) ", Table.min_x);
      ret = Table.rows*Table.columns;
      if (Table.monotonic)    printf(", monotonic");
      if (Table.constantstep) printf(", constant step");
      printf(". interpolation: %s\n", Table.method);
    }
    else printf(" is empty.\n");

    if (Table.header && strlen(Table.header)) {
      char *header;
      int  i;
      header = malloc(80);
      if (!header) return(ret);
      for (i=0; i<80; header[i++]=0);
      strncpy(header, Table.header, 75);
      if (strlen(Table.header) > 75) {
        strcat( header, " ...");
      }
      for (i=0; i<strlen(header); i++)
        if (header[i] == '\n' || header[i] == '\r') header[i] = ';';
      printf("  '%s'\n", header);
      free(header);
    }

    return(ret);
  } /* end Table_Info */

/******************************************************************************
* long Table_Init(t_Table *Table, m, n)
*   ACTION: initialise a Table to empty m by n table
*   return: empty Table
******************************************************************************/
long Table_Init(t_Table *Table, long rows, long columns)
{
  double *data=NULL;
  long   i;

  if (!Table) return(0);

  Table->header  = NULL;
  Table->filename[0]= '\0';
  Table->filesize= 0;
  Table->min_x   = 0;
  Table->max_x   = 0;
  Table->step_x  = 0;
  Table->block_number = 0;
  Table->array_length = 0;
  Table->monotonic    = 0;
  Table->constantstep = 0;
  Table->begin   = 0;
  Table->end     = 0;
  strcpy(Table->method,"linear");

  if (rows*columns >= 1) {
    data    = (double*)malloc(rows*columns*sizeof(double));
    if (data) for (i=0; i < rows*columns; data[i++]=0);
    else {
      fprintf(stderr,"Error: allocating %ld double elements."
                     "Too big (Table_Init).\n", rows*columns);
      rows = columns = 0;
    }
  }
  Table->rows    = (rows >= 1 ? rows : 0);
  Table->columns = (columns >= 1 ? columns : 0);
  Table->data    = data;
  return(Table->rows*Table->columns);
} /* end Table_Init */

/******************************************************************************
* long Table_Write(t_Table Table, char *file, x1,x2, y1,y2)
*   ACTION: write a Table to disk (ascii).
*     when x1=x2=0 or y1=y2=0, the table default limits are used.
*   return: 0=all is fine, non-0: error
*******************************************************************************/
MCDETECTOR Table_Write(t_Table Table, char *file, char *xl, char *yl, 
  double x1, double x2, double y1, double y2)
{
  long    i =0;
  MCDETECTOR detector;

  if ((Table.data == NULL) && (Table.rows*Table.columns)) {
    detector.m = 0;
    return(detector); /* Table is empty - nothing to do */
  }
  if (!x1 && !x2) {
    x1 = Table.min_x;
    x2 = Table.max_x;
  }
  if (!y1 && !y2) {
    y1 = 1;
    y2 = Table.columns;
  }

  /* transfer content of the Table into a 2D detector */
  Coords coords = { 0, 0, 0};

  if (Table.rows == 1 || Table.columns == 1) {
    detector = mcdetector_out_1D(Table.filename,
                      xl ? xl : "", yl ? yl : "",
                      "x", x1, x2,
                      Table.rows * Table.columns,
                      NULL, Table.data, NULL,
                      file, file, coords);
  } else {
    detector = mcdetector_out_2D(Table.filename,
                      xl ? xl : "", yl ? yl : "",
                      x1, x2, y1, y2,
                      Table.rows, Table.columns,
                      NULL, Table.data, NULL,
                      file, file, coords);
  }
  return(detector);
}

/******************************************************************************
* void Table_Stat(t_Table *Table)
*   ACTION: computes min/max/mean step of 1st column for a single table (private)
*   return: updated Table
*******************************************************************************/
  static void Table_Stat(t_Table *Table)
  {
    long   i;
    double max_x, min_x;
    double row=1;
    char   monotonic=1;
    char   constantstep=1;
    double step=0;
    long n;

    if (!Table) return;
    if (!Table->rows || !Table->columns) return;
    if (Table->rows == 1) row=0; // single row
    max_x = -FLT_MAX;
    min_x =  FLT_MAX;
    n     = (row ? Table->rows : Table->columns);
    /* get min and max of first column/vector */
    for (i=0; i < n; i++)
    {
      double X;
      X = (row ? Table_Index(*Table,i  ,0)
                               : Table_Index(*Table,0, i));
      if (X < min_x) min_x = X;
      if (X > max_x) max_x = X;
    } /* for */
    
    /* test for monotonicity and constant step if the table is an XY or single vector */
    if (n > 1) {
      /* mean step */
      step = (max_x - min_x)/(n-1);
      /* now test if table is monotonic on first column, and get minimal step size */
      for (i=0; i < n-1; i++) {
        double X, diff;;
        X    = (row ? Table_Index(*Table,i  ,0)
                    : Table_Index(*Table,0,  i));
        diff = (row ? Table_Index(*Table,i+1,0)
                    : Table_Index(*Table,0,  i+1)) - X;
        if (diff && fabs(diff) < fabs(step)) step = diff;
        /* change sign ? */
        if ((max_x - min_x)*diff < 0 && monotonic)
          monotonic = 0;
      } /* end for */
      
      /* now test if steps are constant within READ_TABLE_STEPTOL */
      if(!step){
        /*means there's a disconitnuity -> not constantstep*/
        constantstep=0;
      }else if (monotonic) {
        for (i=0; i < n-1; i++) {
          double X, diff;
          X    = (row ? Table_Index(*Table,i  ,0)
              : Table_Index(*Table,0,  i));
          diff = (row ? Table_Index(*Table,i+1,0)
              : Table_Index(*Table,0,  i+1)) - X;
          if ( fabs(step)*(1+READ_TABLE_STEPTOL) < fabs(diff) ||
                fabs(diff) < fabs(step)*(1-READ_TABLE_STEPTOL) )
          { constantstep = 0; break; }
        }
      }

    }
    Table->step_x= step;
    Table->max_x = max_x;
    Table->min_x = min_x;
    Table->monotonic = monotonic;
    Table->constantstep = constantstep;
  } /* end Table_Stat */

/******************************************************************************
* t_Table *Table_Read_Array(char *File, long *blocks)
*   ACTION: read as many data blocks as available, iteratively from file
*   return: initialized t_Table array, last element is an empty Table.
*           the number of extracted blocks in non NULL pointer *blocks
*******************************************************************************/
  t_Table *Table_Read_Array(char *File, long *blocks)
  {
    t_Table *Table_Array=NULL;
    long offset=0;
    long block_number=0;
    long allocated=256;
    long nelements=1;

    /* first allocate an initial empty t_Table array */
    Table_Array = (t_Table *)malloc(allocated*sizeof(t_Table));
    if (!Table_Array) {
      fprintf(stderr, "Error: Can not allocate memory %li (Table_Read_Array).\n",
         allocated*sizeof(t_Table));
      *blocks = 0;
      return (NULL);
    }

    while (nelements > 0)
    {
      t_Table Table;

      /* if ok, set t_Table block number else exit loop */
      block_number++;
      Table.block_number = block_number;
      
      /* access file at offset and get following block. Block number is from the set offset
       * hence the hardcoded 1 - i.e. the next block counted from offset.*/
      nelements = Table_Read_Offset(&Table, File, 1, &offset,0);
      /*if the block is empty - don't store it*/
      if (nelements>0){
          /* if t_Table array is not long enough, expand and realocate */
          if (block_number >= allocated-1) {
              allocated += 256;
              Table_Array = (t_Table *)realloc(Table_Array,
                      allocated*sizeof(t_Table));
              if (!Table_Array) {
                  fprintf(stderr, "Error: Can not re-allocate memory %li (Table_Read_Array).\n",
                          allocated*sizeof(t_Table));
                  *blocks = 0;
                  return (NULL);
              }
          }
          /* store it into t_Table array */
          //snprintf(Table.filename, 1024, "%s#%li", File, block_number-1);
          Table_Array[block_number-1] = Table;
      }
      /* continues until we find an empty block */
    }
    /* send back number of extracted blocks */
    if (blocks) *blocks = block_number-1;

    /* now store total number of elements in Table array */
    for (offset=0; offset < block_number;
      Table_Array[offset++].array_length = block_number-1);

    return(Table_Array);
  } /* end Table_Read_Array */
/*******************************************************************************
* void Table_Free_Array(t_Table *Table)
*   ACTION: free a Table array
*******************************************************************************/
  void Table_Free_Array(t_Table *Table)
  {
    long index;
    if (!Table) return;
    for (index=0;index < Table[0].array_length; index++){
            Table_Free(&Table[index]);
    }
    free(Table);
  } /* end Table_Free_Array */

/******************************************************************************
* long Table_Info_Array(t_Table *Table)
*    ACTION: print informations about a Table array
*    return: number of elements in the Table array
*******************************************************************************/
  long Table_Info_Array(t_Table *Table)
  {
    long index=0;

    if (!Table) return(-1);
    while (index < Table[index].array_length
       && (Table[index].data || Table[index].header)
       && (Table[index].rows*Table[index].columns) ) {
      Table_Info(Table[index]);
      index++;
    }
    printf("This Table array contains %li elements\n", index);
    return(index);
  } /* end Table_Info_Array */

/******************************************************************************
* char **Table_ParseHeader(char *header, symbol1, symbol2, ..., NULL)
*    ACTION: search for char* symbols in header and return their value or NULL
*            the search is not case sensitive.
*            Last argument MUST be NULL
*    return: array of char* with line following each symbol, or NULL if not found
*******************************************************************************/
#ifndef MyNL_ARGMAX
#define MyNL_ARGMAX 50
#endif

char **Table_ParseHeader_backend(char *header, ...){
  va_list ap;
  char exit_flag=0;
  int counter   =0;
  char **ret    =NULL;
  if (!header || header[0]=='\0') return(NULL);

  ret = (char**)calloc(MyNL_ARGMAX, sizeof(char*));
  if (!ret) {
    printf("Table_ParseHeader: Cannot allocate %i values array for Parser (Table_ParseHeader).\n",
      MyNL_ARGMAX);
    return(NULL);
  }
  for (counter=0; counter < MyNL_ARGMAX; ret[counter++] = NULL);
  counter=0;

  va_start(ap, header);
  while(!exit_flag && counter < MyNL_ARGMAX-1)
  {
    char *arg_char=NULL;
    char *pos     =NULL;
    /* get variable argument value as a char */
    arg_char = va_arg(ap, char *);
    if (!arg_char || arg_char[0]=='\0'){
      exit_flag = 1; break;
    }
    /* search for the symbol in the header */
    pos = (char*)strcasestr(header, arg_char);
    if (pos) {
      char *eol_pos;
      eol_pos = strchr(pos+strlen(arg_char), '\n');
      if (!eol_pos)
        eol_pos = strchr(pos+strlen(arg_char), '\r');
      if (!eol_pos)
        eol_pos = pos+strlen(pos)-1;
      ret[counter] = (char*)malloc(eol_pos - pos);
      if (!ret[counter]) {
        printf("Table_ParseHeader: Cannot allocate value[%i] array for Parser searching for %s (Table_ParseHeader).\n",
          counter, arg_char);
        exit_flag = 1; break;
      }
      strncpy(ret[counter], pos+strlen(arg_char), eol_pos - pos - strlen(arg_char));
      ret[counter][eol_pos - pos - strlen(arg_char)]='\0';
    }
    counter++;
  }
  va_end(ap);
  return(ret);
} /* Table_ParseHeader */

/******************************************************************************
* double Table_Interp1d(x, x1, y1, x2, y2)
*    ACTION: interpolates linearly at x between y1=f(x1) and y2=f(x2)
*    return: y=f(x) value
*******************************************************************************/
double Table_Interp1d(double x,
  double x1, double y1,
  double x2, double y2)
{
  double slope;
  if (x2 == x1) return (y1+y2)/2;
  if (y1 == y2) return  y1;
  slope = (y2 - y1)/(x2 - x1);
  return y1+slope*(x - x1);
} /* Table_Interp1d */

/******************************************************************************
* double Table_Interp1d_nearest(x, x1, y1, x2, y2)
*    ACTION: table lookup with nearest method at x between y1=f(x1) and y2=f(x2)
*    return: y=f(x) value
*******************************************************************************/
double Table_Interp1d_nearest(double x,
  double x1, double y1,
  double x2, double y2)
{
  if (fabs(x-x1) < fabs(x-x2)) return (y1);
  else return(y2);
} /* Table_Interp1d_nearest */

/******************************************************************************
* double Table_Interp2d(x,y, x1,y1, x2,y2, z11,z12,z21,z22)
*    ACTION: interpolates bi-linearly at (x,y) between z1=f(x1,y1) and z2=f(x2,y2)
*    return: z=f(x,y) value
*    x,y |   x1   x2
*    ----------------
*     y1 |   z11  z21
*     y2 |   z12  z22
*******************************************************************************/
double Table_Interp2d(double x, double y,
  double x1, double y1,
  double x2, double y2,
  double z11, double z12, double z21, double z22)
{
  double ratio_x, ratio_y;
  if (x2 == x1) return Table_Interp1d(y, y1,z11, y2,z12);
  if (y1 == y2) return Table_Interp1d(x, x1,z11, x2,z21);

  ratio_y = (y - y1)/(y2 - y1);
  ratio_x = (x - x1)/(x2 - x1);
  return (1-ratio_x)*(1-ratio_y)*z11 + ratio_x*(1-ratio_y)*z21
    + ratio_x*ratio_y*z22         + (1-ratio_x)*ratio_y*z12;
} /* Table_Interp2d */

/* end of read_table-lib.c */


#ifndef REF_LIB_H
#define REF_LIB_H "$Revision$"

void StdReflecFunc(double, double*, double*);
void TableReflecFunc(double, t_Table*, double*);

#endif

/* end of ref-lib.h */
/****************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2006, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/ref-lib.c
*
* %Identification
* Written by: Peter Christiansen
* Date: August, 2006
* Origin: RISOE
* Release: McStas 1.10
* Version: $Revision$
*
* Commonly used reflection functions are declared in this file which
* are used by some guide and mirror components.
*
* Variable names have prefix 'mc_ref_' for 'McStas Reflection' 
* to avoid conflicts
*
* Usage: within SHARE
* %include "ref-lib"
*
****************************************************************************/

#ifndef REF_LIB_H
#include "ref-lib.h"
#endif

#ifndef READ_TABLE_LIB_H
#include "read_table-lib.h"
#include "read_table-lib.c"
#endif

/****************************************************************************
* void StdReflecFunc(double q, double *par, double *r)
* 
* The McStas standard analytic parametrization of the reflectivity.
* The parameters are:
* R0:      [1]    Low-angle reflectivity
* Qc:      [AA-1] Critical scattering vector
* alpha:   [AA]   Slope of reflectivity
* m:       [1]    m-value of material. Zero means completely absorbing.
* W:       [AA-1] Width of supermirror cut-off
*****************************************************************************/
void StdReflecFunc(double mc_pol_q, double *mc_pol_par, double *mc_pol_r) {
    double R0    = mc_pol_par[0];
    double Qc    = mc_pol_par[1];
    double alpha = mc_pol_par[2];
    double m     = mc_pol_par[3];
    double W     = mc_pol_par[4];
    double beta  = 0;
    mc_pol_q     = fabs(mc_pol_q);
    double arg;
        
    /* Simpler parametrization from Henrik Jacobsen uses these values that depend on m only.
       double m_value=m*0.9853+0.1978;
       double W=-0.0002*m_value+0.0022;
       double alpha=0.2304*m_value+5.0944;
       double beta=-7.6251*m_value+68.1137; 
       If W and alpha are set to 0, use Henrik's approach for estimating these parameters
       and apply the formulation:
       arg = R0*0.5*(1-tanh(arg))*(1-alpha*(q-Qc)+beta*(q-Qc)*(q-Qc));
    */  
    if (W==0 && alpha==0) {
      m=m*0.9853+0.1978;
      W=-0.0002*m+0.0022;
      alpha=0.2304*m+5.0944;
      beta=-7.6251*m+68.1137;
      if (m<=3) {
	alpha=m;
	beta=0;
      }
    }
    
    arg = W > 0 ? (mc_pol_q - m*Qc)/W : 11;

    if (arg > 10 || m <= 0 || Qc <=0 || R0 <= 0) {
      *mc_pol_r = 0;
      return;
    }
    
    if (m < 1) { Qc *= m; m=1; }
    
    if(mc_pol_q <= Qc) {      
      *mc_pol_r = R0;
      return;
    }
    
    
    *mc_pol_r = R0*0.5*(1 - tanh(arg))*(1 - alpha*(mc_pol_q - Qc) + beta*(mc_pol_q - Qc)*(mc_pol_q - Qc));
    
    return;
  }

/****************************************************************************
* void TableReflecFunc(double q, t_Table *par, double *r) {
* 
* Looks up the reflectivity in a table using the routines in read_table-lib.
*****************************************************************************/
void TableReflecFunc(double mc_pol_q, t_Table *mc_pol_par, double *mc_pol_r) {
    
  *mc_pol_r = Table_Value(*mc_pol_par, mc_pol_q, 1);
  if(*mc_pol_r>1)
    *mc_pol_r = 1;
  return;
}

/* end of ref-lib.c */


///////////////////////////////////////////////////////////////////////////
/////////////// local structs and enums
///////////////////////////////////////////////////////////////////////////

/**
	Sides of the guide
*/
enum Side {RightSide,TopSide,LeftSide,BottomSide,None};

/**
	The type of the collision is set in the collision function
	and decide the functions called in trace()
	Reflex (TODO change this name) calls the reflection function
	Absorb calls the built in ABSORB funtion.
	LeaveGuide calls break and end the calculations in this component
	EnterGuide does nothing
*/
enum CollisionType {Reflex,Absorb,LeaveGuide,EnterGuide};

/**
	The Mirror type sets the CollisionType of particles colliding on the mirror
*/
enum MirrorType {MirrorTypeReflection,MirrorTypeTransparent,MirrorTypeabsorption};

// enum IntersectionType {Reflex,Absorb,Transparent,Leave,Enter};

/**
	Collision between guide and the particle
	contain infomation on the time to the next collision,
	which side of the guide it is on and whether this part of the guide
	is a perfect or approximated ellipse.
*/
struct Intersection
{
	double delta_time_to_next_collision; 
	enum Side side;	// A number from 0 to 4 (4 being an error warning)
	int ApproxOn;
	enum CollisionType collisionType;
};

/**
	Static Guide information (SGI)
	contain information on the guide, the ellipses and the mirrors on all sides
*/
struct SGI
{
	// guide infomation
	double Length;
	double entranceHorizontalWidth, entranceVerticalWidth;	
	double exitHorizontalWidth, exitVerticalWidth;	

	// ellipses infomation
	double ellipseMajorAxis[4],		ellipseMinorAxis[4];
	double ellipseMajorOffset[4],	ellipseMinorOffset[4];

	// mirror infomation
	double R0Arr[4]; 
	double QcArr[4]; 
	double alphaArr[4]; 
	double mArr[4]; 
	double WArr[4];

	// mirror type
	enum MirrorType InnerSide[4];
	enum MirrorType OuterSide[4];

	// selene
	int EnclosingBoxOn;
    double xArray[8];
    double yArray[8];
    double zArray[8];

    // segmentation
    int numberOfSegments;
    int enableSegments;
    double *mValuesright;
	double *mValuesleft;
	double *mValuestop;
	double *mValuesbottom;
    double *segLength;

    int verboseSetting;
};


///////////////////////////////////////////////////////////////////////////
/////////////// Error Handling Functions
///////////////////////////////////////////////////////////////////////////

/**
	If a user input is less than zero and hence doesn't allow for a well
	define geomtric of the guide or physical values for mirrors
	@param var is the input varible there the error occurred [text]
*/
int guide_elliptical_illegalInputLessThanZero(char var[],int verbose){
	if (verbose)
		printf("The user defined variable %s in %s has an illegal value"
				" less than zero\n",var,"Elliptic_guide_gravity");
	return 1;
}

/**
	The first focal point is in and the second is out.
	If -in-out > L then they would change position as the 
	first and second focal points. This is 
	@param in,out is the input varible there the error occurred [text]
*/
int guide_elliptical_illegalInputFocalPointsHyperbola(
			char in[],char out[],
			double inValue,double outValue, int verbose){
	if (verbose){
		printf("The user defined length of the guide, length \
				and the focal points %s and %s does not result \
				in an well defined ellipse. swap the focal points \
				or increase L, %s or %s to fix this problem\n",
				in,out,in,out);
		printf("The mininum length of the should be around %e\n",
				inValue+outValue+0.000001);
	}
	return 1;
}

/**
	Gives a warning if a part of the code is called that 
	should not be accessible if the algoritmes are working correctly
	Most likely errors are floating points and ill-defined cases
*/
void guide_elliptical_callCriticalWarning(char func[],int verbose){
	if (verbose)
		printf("A CRITICAL WARNING has been called inside %s by function %s." 
			"This is most likely due to a programming error \
			inside the component. \n",
			"Elliptic_guide_gravity",func);
	}

///////////////////////////////////////////////////////////////////////////
/////////////// Collision handling functions
///////////////////////////////////////////////////////////////////////////

int guide_elliptical_getMirrorTypeFromInput(char * input,int verbose){
	int type = -1;
	char* r1 = "reflection"; char* r2 = "reflect"; char* r3 = "r";
	char* a1 = "absorption"; char* a2 = "absorb"; char* a3 = "a";
	char* t1 = "transparant";char* t2 = "trans"; char* t3 = "t";
	if (strcmp (input, r1) == 0
	||  strcmp (input, r2) == 0 
	||  strcmp (input, r3) == 0)
		type = MirrorTypeReflection;
	if (strcmp (input, a1) == 0
	||  strcmp (input, a2) == 0 
	||  strcmp (input, a3) == 0)
		type = MirrorTypeabsorption;
	if (strcmp (input, t1) == 0
	||  strcmp (input, t2) == 0 
	||  strcmp (input, t3) == 0)
		type = MirrorTypeTransparent;
	if ( type == -1 && verbose)
		printf( "Following string is not a valid type of a mirror: %s,"
				"use reflection,absorption or transparant. \n" ,input);

	return type;
	}

///////////////////////////////////////////////////////////////////////////
/////////////// Collision functions
///////////////////////////////////////////////////////////////////////////	

/**
	Find the intersection between the neutron and the ellipse using newton method.
	As there is up to 4 solution to this problem, and only the 
	smallest positive root is the physical solution. Using the tuning points 
	it is possible to look the only the potential roots to speed up calculations.

	@param coef; A pointer to the array holding the coeffecients 
			for the 4th order polynomial.
	@param startPosition, The default starting point for newton method. [s]
	@param limit; A point after all the roots of the polynial. [s]
	@param solution A pointer which will hold the physical solution 
			if this function return true.
	@return; return 1 if the physical solution is found. [boolean] 
*/

double guide_elliptical_foverdf(double *coefficients,double currentPoint){
	double numerator= coefficients[0]*currentPoint*currentPoint*currentPoint*currentPoint
					+ coefficients[1]*currentPoint*currentPoint*currentPoint
					+ coefficients[2]*currentPoint*currentPoint
					+ coefficients[3]*currentPoint
					+ coefficients[4];
	double denominator=4*coefficients[0]*currentPoint*currentPoint*currentPoint
					+ 3*coefficients[1]*currentPoint*currentPoint
					+ 2*coefficients[2]*currentPoint
					+ coefficients[3];
	return numerator/denominator;
}

int guide_elliptical_newtonRapsonsMethod4thOrder(
		double *coefficients,double *solution,double startingPoint,
		double tolerance,double max_iterations){

	double numerator;
	double denominator;
	double t_previous;
	double t = startingPoint;
	int iteration = 0;

	do {
		t_previous = t;
		t = t_previous - guide_elliptical_foverdf(coefficients,t);
		iteration++;
	} while( fabs(t-t_previous) > tolerance && iteration < max_iterations );
	if( iteration == max_iterations ) { return 0; }
	else 			{ *solution = t;	return 1; }
}



int guide_elliptical_findNeutronEllipseIntersection(
				double *coef,double startPosition,
				double limit,double *solution){

	// in the case of no gravity
	if(coef[0] == 0 & coef[1] == 0){
		double t1=0;
		double t2=0;
		int boolean = solve_2nd_order(&t1,&t2,coef[2],coef[3],coef[4]);

		if ( t1 > startPosition ){ *solution = t1; }
		if ( t2 > startPosition ){ *solution = t2; }
		return boolean;
	}

	double tol = 1e-15;
	double max_iter = 1e3;
	double turningP1,turningP2;
	
	double sp = startPosition;
	int inside;
	if ( coef[0]*sp*sp*sp*sp
		+coef[1]*sp*sp*sp
		+coef[2]*sp*sp
		+coef[3]*sp
		+coef[4] < 0)
		 inside = 1;
	else inside = 0;

	int boolean = solve_2nd_order(
						&turningP1,&turningP2,
						12*coef[0],6*coef[1],2*coef[2]);

	double t1=0,t2=0;
	double ss=100;

	if( inside ){
		if(boolean) guide_elliptical_newtonRapsonsMethod4thOrder(coef,&t1,turningP1,tol,max_iter);
		guide_elliptical_newtonRapsonsMethod4thOrder(coef,&t2,limit,tol,max_iter);
	}
	else{
		if(boolean) guide_elliptical_newtonRapsonsMethod4thOrder(coef,&t1,turningP2,tol,max_iter);
		guide_elliptical_newtonRapsonsMethod4thOrder(coef,&t2,startPosition,tol,max_iter);
	}

	if (ss > t1 && t1 > 1e-15)	ss = t1;
	if (ss > t2 && t2 > 1e-15)	ss = t2;
	*solution = ss;
	
	return 1;
}


int guide_elliptical_handleGuideIntersection(
		double x, double y, double z,
		double vx,double vy,double vz,
		double Gx,double Gy,double Gz,
		struct SGI *guideInfo,
		struct Intersection *currentCollision){
	//
	double horExS = 1/( guideInfo->ellipseMinorAxis[RightSide]
					   *guideInfo->ellipseMinorAxis[RightSide]);
	double horEzS = 1/( guideInfo->ellipseMajorAxis[RightSide]
				 	   *guideInfo->ellipseMajorAxis[RightSide]);
	double hordiffx = x-guideInfo->ellipseMinorOffset[RightSide]; 
	double hordiffz = z-guideInfo->ellipseMajorOffset[RightSide]; 

	double horAlpha = ( Gx*Gx*horExS + Gz*Gz*horEzS )/4;
	double horBeta  = ( Gx*vx*horExS + Gz*vz*horEzS );
	double horGamma = horExS*vx*vx + horEzS*vz*vz 
					 + horExS*Gx*hordiffx + horEzS*Gz*hordiffz; 
	double horDelta = 2*horExS*vx*hordiffx + 2*horEzS*vz*hordiffz;
	double horEpsilon = horExS*hordiffx*hordiffx + horEzS*hordiffz*hordiffz - 1; 

	double horCoefficients[5] = {horAlpha,horBeta,horGamma,horDelta,horEpsilon};

	double verEyS = 1/( guideInfo->ellipseMinorAxis[TopSide]
					   *guideInfo->ellipseMinorAxis[TopSide]);
	double verEzS = 1/( guideInfo->ellipseMajorAxis[TopSide]
				 	   *guideInfo->ellipseMajorAxis[TopSide]);
	double verdiffy = y-guideInfo->ellipseMinorOffset[TopSide];
	double verdiffz = z-guideInfo->ellipseMajorOffset[TopSide];

	double verAlpha = ( Gy*Gy*verEyS + Gz*Gz*verEzS )/4;
	double verBeta  = ( Gy*vy*verEyS + Gz*vz*verEzS );
	double verGamma = verEyS*vy*vy + verEzS*vz*vz 
					+ verEyS*Gy*verdiffy + verEzS*Gz*verdiffz;
	double verDelta = 2*verEyS*vy*verdiffy + 2*verEzS*vz*verdiffz;
	double verEpsilon = verEyS*verdiffy*verdiffy + verEzS*verdiffz*verdiffz - 1;

	double verCoefficients[5] = {verAlpha,verBeta,verGamma,verDelta,verEpsilon};


	double upperlimit;
	double startingPoint = 1e-15;

	int boolean;
	// Horizontal
	double solutionH = 0;
	solve_2nd_order(
			&upperlimit,NULL,
			-0.5*Gz,-vz,2*guideInfo->ellipseMajorAxis[RightSide]-z);
	int booleanH = guide_elliptical_findNeutronEllipseIntersection(
						horCoefficients,startingPoint,upperlimit,&solutionH);
	// Vertical
	double solutionV = 0;
	solve_2nd_order(
			&upperlimit,NULL,
			-0.5*Gz,-vz,2*guideInfo->ellipseMajorAxis[TopSide]-z);
	int booleanV = guide_elliptical_findNeutronEllipseIntersection(
						verCoefficients,startingPoint,upperlimit,&solutionV);

	if (solutionH <= 0)
			currentCollision->delta_time_to_next_collision = solutionV;
	else if (solutionV <= 0)
			currentCollision->delta_time_to_next_collision = solutionH;
	else if (fabs(solutionH - solutionV) < 1e-12) return 0;
	else if (solutionH < solutionV){
		currentCollision->delta_time_to_next_collision = solutionH; 
		boolean = booleanH; 
		}
	else{
		currentCollision->delta_time_to_next_collision = solutionV; 
		boolean = booleanV; 
		}

	double tside = currentCollision->delta_time_to_next_collision;
	double xside = x + vx*tside + 0.5*Gx*tside*tside;
	double yside = y + vy*tside + 0.5*Gy*tside*tside;
	double zside = z + vz*tside + 0.5*Gz*tside*tside;

	double xfactor =
		2*sqrt(1 - ( (zside-guideInfo->ellipseMajorOffset[RightSide])
					*(zside-guideInfo->ellipseMajorOffset[RightSide]) 
					)/(guideInfo->ellipseMajorAxis[RightSide] 
					*guideInfo->ellipseMajorAxis[RightSide] ) 
		)*guideInfo->ellipseMinorAxis[RightSide];

	double yfactor =
		2*sqrt(1 - ( (zside-guideInfo->ellipseMajorOffset[BottomSide])
					*(zside-guideInfo->ellipseMajorOffset[BottomSide]) 
					)/(guideInfo->ellipseMajorAxis[BottomSide] 
					*guideInfo->ellipseMajorAxis[BottomSide] )
		)*guideInfo->ellipseMinorAxis[BottomSide];

	xside = xside/xfactor;
	yside = yside/yfactor;
	if( fabs(yside) >= fabs(xside) ){
		if(y > 0)	currentCollision->side = TopSide;
		else 		currentCollision->side = BottomSide;
	}
	else{
		if(x < 0)	currentCollision->side = RightSide;
		else 		currentCollision->side = LeftSide;
	}
	if (tside < 1e-15) printf("low time is: %e\n",tside);

	return boolean;
}

/**
	Check if the neutron is within the guide using the sign 
	of the crossproduct between the two points,
	on each of the enclosing box surface and neutrons position.    
	
	@param x,y,z; position of the neutron. [m]
	@param guideInfo; pointer to the guide infomation holding structure.
	@return; return 1 if the neutron is inside the guide [boolean] 
*/

/*
int guide_elliptical_InsideEnclosingBox(double x,double y,double z,struct SGI *guideInfo){
	int guide_elliptical_IsPointInVolume(
			double *x,double *y,double *z,
			double px,double py,double pz){
		int guide_elliptical_WhichSide( 	double p1x,double p1y,double p1z,
						double p2x,double p2y,double p2z,
						double p3x,double p3y,double p3z,
						double px ,double py ,double pz ){
			
			double v1x = p1x - p2x, v1y = p1y-p2y, v1z = p1z-p2z;
			double v2x = p3x - p2x, v2y = p3y-p2y, v2z = p3z-p2z;
			double v3x = v2y*v1z-v2z*v1y; 
			double v3y = v2z*v1x-v2x*v1z;
			double v3z = v2x*v1y-v2y*v1x;

			return 0 >= v3x*(px-p1x)+v3y*(py-p1y)+v3z*(pz-p1z); 
		}

		if(	//front
			guide_elliptical_WhichSide(x[3],y[3],z[3],x[2],y[2],z[2],x[1],y[1],z[1],px,py,pz) &&
			guide_elliptical_WhichSide(x[1],y[1],z[1],x[0],y[0],z[0],x[3],y[3],z[3],px,py,pz) &&
			//back
			guide_elliptical_WhichSide(x[5],y[5],z[5],x[6],y[6],z[6],x[7],y[7],z[7],px,py,pz) &&
			guide_elliptical_WhichSide(x[7],y[7],z[7],x[4],y[4],z[4],x[5],y[5],z[5],px,py,pz) &&
			//right
			guide_elliptical_WhichSide(x[7],y[7],z[7],x[3],y[3],z[3],x[0],y[0],z[0],px,py,pz) &&
			guide_elliptical_WhichSide(x[0],y[0],z[0],x[4],y[4],z[4],x[7],y[7],z[7],px,py,pz) &&
			//left
			guide_elliptical_WhichSide(x[1],y[1],z[1],x[2],y[2],z[2],x[6],y[6],z[6],px,py,pz) &&
			guide_elliptical_WhichSide(x[6],y[6],z[6],x[5],y[5],z[5],x[1],y[1],z[1],px,py,pz) &&
			//top
			guide_elliptical_WhichSide(x[0],y[0],z[0],x[1],y[1],z[1],x[5],y[5],z[5],px,py,pz) &&
			guide_elliptical_WhichSide(x[5],y[5],z[5],x[4],y[4],z[4],x[0],y[0],z[0],px,py,pz) &&
			//bottom
			guide_elliptical_WhichSide(x[6],y[6],z[6],x[2],y[2],z[2],x[3],y[3],z[3],px,py,pz) &&
			guide_elliptical_WhichSide(x[3],y[3],z[3],x[7],y[7],z[7],x[6],y[6],z[6],px,py,pz) )
			 	return 1;
		else 	return 0;
	}
	return guide_elliptical_IsPointInVolume(
				guideInfo->xArray,guideInfo->yArray,guideInfo->zArray,x,y,z);
}
*/


///////////////////////////////////////////////////////////////////////////
/////////////// reflection functions
///////////////////////////////////////////////////////////////////////////
		

/**
	Calculate the new velocity vector for the particle colliding on 
	the inner side of the elliptic mirror and returns the loss-factor (TODO)
	
	@param pos_V0,pos_W0 Is the 2d position vector of the particle, 
			assumed to be a point on the ellipse. [m]
	@param pvel_V0,pvel_W0 Is the 2d velocity vector of the particle. [m/s]
	@param ellipse_V_axis_squared,ellipse_W_axis_squared
			are the axes of the ellipse. [m]
	@param ellipse_V_offset,ellipse_W_offset Is the 2d vector difference 
			between the ellipse coordinate system (center of the ellipse) 
			and the guide coordinate system [m]
	@param R0, Mvalue, Qc, W, Alpha #TODO 
		slaa beskrivelse af disse variabler i andre dokumenter 
		og hold dig til standarden.
	@return the new wieght of the package
*/
double guide_elliptical_ReflectionOnEllipticSurface(
			double pos_V,double pos_W,
			double *pvel_V,double *pvel_W,
			double ellipse_V_axis,double ellipse_W_axis,
			double ellipse_V_offset,double ellipse_W_offset,
			double R0, double Qc, double alpha, double Mvalue, double W)
{

	// Turns the velocity vector (vel_V0,vel_W0) into a local value
	double vel_V = *pvel_V;
	double vel_W = *pvel_W;

	// Galilean transformation of the particles start position 
	// to the ellipse coordinate system
	pos_V=pos_V-ellipse_V_offset;
	pos_W=pos_W-ellipse_W_offset;

	/*  
	*   If we reflect the velocity vector in the normal 
	*	to the ellipse in the point of intersection
	*   The resulting vector will be -f2, do to conservation of momentum.
	*   this result in the following equation
	*   f2 = -f1 + 2(f1 dot nhat)nhat
	*   which is equal to f2 = f1 - 2(f1 dot n)n/nlength^2
	*/
	
	// The normal vector to the point of intersection
	double normVec_V = - pos_W*ellipse_V_axis/ellipse_W_axis;
	double normVec_W =   pos_V*ellipse_W_axis/ellipse_V_axis;

	double normVec_length_squared = normVec_V*normVec_V + normVec_W*normVec_W;

	// Dot product of (vel_V0,vel_W0) and the normal vector
	double Vel_dot_NV = vel_V*normVec_V+vel_W*normVec_W;

	// Calculate f2
	double vel_V_2 = -vel_V + 2*Vel_dot_NV*normVec_V/normVec_length_squared;
	double vel_W_2 = -vel_W + 2*Vel_dot_NV*normVec_W/normVec_length_squared;

	// Apply the new velocity vector to the particle globally
	*pvel_V=vel_V_2;
	*pvel_W=vel_W_2;

	// Calculate q and the weighting of the neutron package
	// q=f1-f2
	double delta_vel_V = vel_V-vel_V_2;
	double delta_vel_W = vel_W-vel_W_2;
	double q = V2Q*sqrt( delta_vel_V*delta_vel_V+delta_vel_W*delta_vel_W );

	// Calculate the loss of neutrons due to the reflection
	double mirrorPar[] = {R0, Qc, alpha, Mvalue, W};
	double weight = 1.0;
	StdReflecFunc(q, mirrorPar, &weight);

	return weight;
}

/**
	Use the found side of Intersection to call guide_elliptical_ReflectionOnEllipticSurface with
	the parameters of that side.
*/
double guide_elliptical_handleReflection(double x0, double y0, double z0,
				double *vx_p,double *vy_p,double *vz_p,
				struct SGI *sgi,
				struct Intersection *cc)
{

    if(!sgi->enableSegments){
		if(cc->side == RightSide || cc->side == LeftSide)
			return guide_elliptical_ReflectionOnEllipticSurface(x0,z0,vx_p,vz_p,
					sgi->ellipseMinorAxis[cc->side],
					sgi->ellipseMajorAxis[cc->side],
					sgi->ellipseMinorOffset[cc->side],
					sgi->ellipseMajorOffset[cc->side],
					sgi->R0Arr[cc->side],
					sgi->QcArr[cc->side],
					sgi->alphaArr[cc->side],
					sgi->mArr[cc->side],
					sgi->WArr[cc->side]
					);
		if(cc->side == TopSide || cc->side == BottomSide)
			return guide_elliptical_ReflectionOnEllipticSurface(y0,z0,vy_p,vz_p,
					sgi->ellipseMinorAxis[cc->side],
					sgi->ellipseMajorAxis[cc->side],
					sgi->ellipseMinorOffset[cc->side],
					sgi->ellipseMajorOffset[cc->side],
					sgi->R0Arr[cc->side],
					sgi->QcArr[cc->side],
					sgi->alphaArr[cc->side],
					sgi->mArr[cc->side],
					sgi->WArr[cc->side]
					);
    }
	else{
    	int currentSegment;
    	double combinedLength = 0;
    	int i;
    	for(i=0; i < sgi->numberOfSegments; i++){
    		combinedLength = combinedLength + sgi->segLength[i];
    		if(z0 < combinedLength)	{
    			currentSegment = i; break;
    		}
    	}

		if(cc->side == RightSide)
			return guide_elliptical_ReflectionOnEllipticSurface(x0,z0,vx_p,vz_p,
					sgi->ellipseMinorAxis[cc->side],
					sgi->ellipseMajorAxis[cc->side],
					sgi->ellipseMinorOffset[cc->side],
					sgi->ellipseMajorOffset[cc->side],
					sgi->R0Arr[cc->side],
					sgi->QcArr[cc->side],
					sgi->alphaArr[cc->side],
					sgi->mValuesright[currentSegment],
					sgi->WArr[cc->side] );
		if(cc->side == LeftSide)
			return guide_elliptical_ReflectionOnEllipticSurface(x0,z0,vx_p,vz_p,
					sgi->ellipseMinorAxis[cc->side],
					sgi->ellipseMajorAxis[cc->side],
					sgi->ellipseMinorOffset[cc->side],
					sgi->ellipseMajorOffset[cc->side],
					sgi->R0Arr[cc->side],
					sgi->QcArr[cc->side],
					sgi->alphaArr[cc->side],
					sgi->mValuesleft[currentSegment],
					sgi->WArr[cc->side] );
		if(cc->side == TopSide)
			return guide_elliptical_ReflectionOnEllipticSurface(y0,z0,vy_p,vz_p,
					sgi->ellipseMinorAxis[cc->side],
					sgi->ellipseMajorAxis[cc->side],
					sgi->ellipseMinorOffset[cc->side],
					sgi->ellipseMajorOffset[cc->side],
					sgi->R0Arr[cc->side],
					sgi->QcArr[cc->side],
					sgi->alphaArr[cc->side],
					sgi->mValuestop[currentSegment],
					sgi->WArr[cc->side] );
		if(cc->side == BottomSide)
			return guide_elliptical_ReflectionOnEllipticSurface(y0,z0,vy_p,vz_p,
					sgi->ellipseMinorAxis[cc->side],
					sgi->ellipseMajorAxis[cc->side],
					sgi->ellipseMinorOffset[cc->side],
					sgi->ellipseMajorOffset[cc->side],
					sgi->R0Arr[cc->side],
					sgi->QcArr[cc->side],
					sgi->alphaArr[cc->side],
					sgi->mValuesbottom[currentSegment],
					sgi->WArr[cc->side] );
    }
	return 0;
}

///////////////////////////////////////////////////////////////////////////
/////////////// End of functions
/////////////////////////////////////////////////////////////////////////// 
#line 7563 "./ESS_BIFROST_shielding.c"

/* Shared user declarations for all components 'Guide_gravity_shieldinglogger'. */
#line 137 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
// m_local_refl is to be used in shielding applications and accessed by shielding logger
#ifndef MVALUE_LOCAL_IS_DEF
#define MVALUE_LOCAL_IS_DEF 1
double m_local_refl=-1;
#endif


#ifndef Gravity_guide_Version
#define Gravity_guide_Version "$Revision$"

#ifndef PROP_GRAV_DT
#error McStas : You need PROP_GRAV_DT (McStas >= 1.4.3) to run this component
#endif

/*
* G:       (m/s^2) Gravitation acceleration along y axis [-9.81]
* Gx:      (m/s^2) Gravitation acceleration along x axis [0]
* Gy:      (m/s^2) Gravitation acceleration along y axis [-9.81]
* Gz:      (m/s^2) Gravitation acceleration along z axis [0]
* mh:      (1)    m-value of material for left/right vert. mirrors
* mv:      (1)    m-value of material for top/bottom horz. mirrors
* mx:      (1)    m-value of material for left/right vert. mirrors
* my:      (1)    m-value of material for top/bottom horz. mirrors
*/

  typedef struct Gravity_guide_Vars
  {
    double gx;
    double gy;
    double gz;
    double nx[6], ny[6], nz[6];
    double wx[6], wy[6], wz[6];
    double A[6], norm_n2[6], norm_n[6];
    long   N_reflection[7];
    double w1c, h1c;
    double w2c, h2c;
    double M[5];
    double Alpha[5];
    double nzC[5], norm_n2xy[5], Axy[5];
    double wav_lr, wav_tb, wav_z;
    double chamfer_z, chamfer_lr, chamfer_tb;
    char   compcurname[256];
    double fc_freq, fc_phase;
    double warnings;
  } Gravity_guide_Vars_type;

  void Gravity_guide_Init(Gravity_guide_Vars_type *aVars,
    MCNUM a_w1, MCNUM a_h1, MCNUM a_w2, MCNUM a_h2, MCNUM a_l, MCNUM a_R0,
    MCNUM a_Qc, MCNUM a_alpha, MCNUM a_m, MCNUM a_W, MCNUM a_nslit, MCNUM a_d,
    MCNUM a_Gx, MCNUM a_Gy, MCNUM a_Gz,
    MCNUM a_mleft, MCNUM a_mright, MCNUM a_mtop, MCNUM a_mbottom, MCNUM a_nhslit,
    MCNUM a_wavy_lr, MCNUM a_wavy_tb, MCNUM a_wavy_z, MCNUM a_wavy,
    MCNUM a_chamfers_z, MCNUM a_chamfers_lr, MCNUM a_chamfers_tb, MCNUM a_chamfers,
    MCNUM a_nu, MCNUM a_phase, MCNUM a_aleft, MCNUM a_aright, MCNUM a_atop, MCNUM a_abottom)
  {
    int i;

    for (i=0; i<7; aVars->N_reflection[i++] = 0);
    for (i=0; i<5; aVars->M[i++] = 0);
    for (i=0; i<5; aVars->Alpha[i++] = 0);
    
    aVars->gx = a_Gx; /* The gravitation vector in the current component axis system */
    aVars->gy = a_Gy;
    aVars->gz = a_Gz;
    aVars->warnings=0;

    if (a_nslit <= 0 || a_nhslit <= 0) { fprintf(stderr,"%s: Fatal: no channel in this guide (nhslit or nslit=0).\n", aVars->compcurname); exit(-1); }
    if (a_d < 0) { fprintf(stderr,"%s: Fatal: subdividing walls have negative thickness in this guide (d<0).\n", aVars->compcurname); exit(-1); }
    aVars->w1c = (a_w1 - (a_nslit-1) *a_d)/(double)a_nslit;
    aVars->w2c = (a_w2 - (a_nslit-1) *a_d)/(double)a_nslit;
    aVars->h1c = (a_h1 - (a_nhslit-1)*a_d)/(double)a_nhslit;
    aVars->h2c = (a_h2 - (a_nhslit-1)*a_d)/(double)a_nhslit;

    for (i=0; i <= 4;   aVars->M[i++]=a_m);
    for (i=0; i <= 4;   aVars->Alpha[i++]=a_alpha);
    if (a_mleft   >= 0) aVars->M[1] =a_mleft  ;
    if (a_mright  >= 0) aVars->M[2] =a_mright ;
    if (a_mtop    >= 0) aVars->M[3] =a_mtop   ;
    if (a_mbottom >= 0) aVars->M[4] =a_mbottom;
    if (a_aleft   >= 0) aVars->Alpha[1] =a_aleft  ;
    if (a_aright  >= 0) aVars->Alpha[2] =a_aright ;
    if (a_atop    >= 0) aVars->Alpha[3] =a_atop   ;
    if (a_abottom >= 0) aVars->Alpha[4] =a_abottom;
    
    /* n: normal vectors to surfaces */
    aVars->nx[1] =  a_l; aVars->ny[1] =  0;   aVars->nz[1] =  0.5*(aVars->w2c-aVars->w1c);  /* 1:+X left       */
    aVars->nx[2] = -a_l; aVars->ny[2] =  0;   aVars->nz[2] = -aVars->nz[1];             /* 2:-X right      */
    aVars->nx[3] =  0;   aVars->ny[3] =  a_l; aVars->nz[3] =  0.5*(aVars->h2c-aVars->h1c);  /* 3:+Y top        */
    aVars->nx[4] =  0;   aVars->ny[4] = -a_l; aVars->nz[4] = -aVars->nz[3];             /* 4:-Y bottom     */
    aVars->nx[5] =  0;   aVars->ny[5] =  0;   aVars->nz[5] =  a_l;                      /* 5:+Z exit       */
    aVars->nx[0] =  0;   aVars->ny[0] =  0;   aVars->nz[0] = -a_l;                      /* 0:Z0 input      */
    /* w: a point on these surfaces */
    aVars->wx[1] = +(aVars->w1c)/2; aVars->wy[1] =  0;              aVars->wz[1] = 0;   /* 1:+X left       */
    aVars->wx[2] = -(aVars->w1c)/2; aVars->wy[2] =  0;              aVars->wz[2] = 0;   /* 2:-X right      */
    aVars->wx[3] =  0;              aVars->wy[3] = +(aVars->h1c)/2; aVars->wz[3] = 0;   /* 3:+Y top        */
    aVars->wx[4] =  0;              aVars->wy[4] = -(aVars->h1c)/2; aVars->wz[4] = 0;   /* 4:-Y bottom     */
    aVars->wx[5] =  0;              aVars->wy[5] =  0;              aVars->wz[5] = a_l; /* 5:+Z exit       */
    aVars->wx[0] =  0;              aVars->wy[0] =  0;              aVars->wz[0] = 0;   /* 0:Z0 input      */

    for (i=0; i <= 5; i++)
    {
      aVars->A[i] = scalar_prod(aVars->nx[i], aVars->ny[i], aVars->nz[i], aVars->gx, aVars->gy, aVars->gz)/2;
      aVars->norm_n2[i] = aVars->nx[i]*aVars->nx[i] + aVars->ny[i]*aVars->ny[i] + aVars->nz[i]*aVars->nz[i];
      if (aVars->norm_n2[i] <= 0)
        { fprintf(stderr,"%s: Fatal: normal vector norm %i is null/negative ! check guide dimensions.\n", aVars->compcurname, i); exit(-1); } /* should never occur */
      else
        aVars->norm_n[i] = sqrt(aVars->norm_n2[i]);
    }
    /* partial computations for l/r/t/b sides, to save computing time */
    for (i=1; i <= 4; i++)
    { /* stores nz that changes in case non box element (focus/defocus) */
      aVars->nzC[i]      =  aVars->nz[i]; /* partial xy terms */
      aVars->norm_n2xy[i]=  aVars->nx[i]*aVars->nx[i] + aVars->ny[i]*aVars->ny[i];
      aVars->Axy[i]      = (aVars->nx[i]*aVars->gx    + aVars->ny[i]*aVars->gy)/2;
    }
    /* handle waviness init */
    if (a_wavy && (!a_wavy_tb && !a_wavy_lr && !a_wavy_z))
    { aVars->wav_tb=aVars->wav_lr=aVars->wav_z=a_wavy; }
    else
    { aVars->wav_tb=a_wavy_tb; aVars->wav_lr=a_wavy_lr; aVars->wav_z=a_wavy_z; }
    aVars->wav_tb *= DEG2RAD/(sqrt(8*log(2)));   /* Convert from deg FWHM to rad Gaussian sigma */
    aVars->wav_lr *= DEG2RAD/(sqrt(8*log(2)));
    aVars->wav_z  *= DEG2RAD/(sqrt(8*log(2)));
    /* handle chamfers init */
    if (a_chamfers && (!a_chamfers_z && !a_chamfers_lr && !a_chamfers_tb))
    { aVars->chamfer_z=aVars->chamfer_lr=aVars->chamfer_tb=a_chamfers; }
    else
    {
      aVars->chamfer_z=a_chamfers_z;
      aVars->chamfer_lr=a_chamfers_lr;
      aVars->chamfer_tb=a_chamfers_tb;
    }

    aVars->fc_freq  = a_nu;
    aVars->fc_phase = a_phase;
  }

  int Gravity_guide_Trace(double *dt,
        Gravity_guide_Vars_type *aVars,
        double cx, double cy, double cz,
        double cvx, double cvy, double cvz,
        double cxnum, double cxk, double cynum, double cyk,
        double *cnx, double *cny,double *cnz)
  {
    double B, C;
    int    ret=0;
    int    side=0;
    double n1;
    double dt0, dt_min=0;
    int    i;
    double loc_num, loc_nslit;
    int    i_slope=3;

    /* look if there is a previous intersection with guide sides */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 5=+Z side: n=(0, 0, -l) ; W = (0, 0, l) (at z=l, guide exit)*/
    B = aVars->nz[5]*cvz; C = aVars->nz[5]*(cz - aVars->wz[5]);
    ret = solve_2nd_order(&dt0, NULL, aVars->A[5], B, C);
    if (ret && dt0>1e-10) { dt_min = dt0; side=5; }

    loc_num = cynum; loc_nslit = cyk;
    for (i=4; i>0; i--)
    {
      if (i == 2) { i_slope=1; loc_num = cxnum; loc_nslit = cxk; }

      if (aVars->nzC[i_slope] != 0) {
        n1 = loc_nslit - 2*(loc_num);  /* slope of l/r/u/d sides depends on the channel ! */
        loc_num++; /* use partial computations to alter nz and A */
        aVars->nz[i]= aVars->nzC[i]*n1;
        aVars->A[i] = aVars->Axy[i] + aVars->nz[i]*aVars->gz/2;
      }
      if (i < 3)
      {      B = aVars->nx[i]*cvx + aVars->nz[i]*cvz; C = aVars->nx[i]*(cx-aVars->wx[i]) + aVars->nz[i]*cz; }
      else { B = aVars->ny[i]*cvy + aVars->nz[i]*cvz; C = aVars->ny[i]*(cy-aVars->wy[i]) + aVars->nz[i]*cz; }
      ret = solve_2nd_order(&dt0, NULL, aVars->A[i], B, C);
      if (ret && dt0>1e-10 && (dt0<dt_min || !dt_min))
      { dt_min = dt0; side=i;
        if (aVars->nzC[i] != 0)
        { aVars->norm_n2[i] = aVars->norm_n2xy[i] + aVars->nz[i]*aVars->nz[i];
          aVars->norm_n[i]  = sqrt(aVars->norm_n2[i]); }
      }
     }

    *dt = dt_min;
    /* handles waviness: rotate n vector */
    if (side > 0 && side < 5 && (aVars->wav_z || aVars->wav_lr || aVars->wav_tb))
    {
      double nt_x, nt_y, nt_z;  /* transverse vector */
      double nn_x, nn_y, nn_z;  /* normal vector (tmp) */
      double phi;
      /* normal vector n_z = [ 0,0,1], n_t = n x n_z; */
      vec_prod(nt_x,nt_y,nt_z, aVars->nx[side],aVars->ny[side],aVars->nz[side], 0,0,1);
      /* rotate n with angle wavy_z around n_t -> nn */
      if (aVars->wav_z) {
        phi = aVars->wav_z;
        rotate(nn_x,nn_y,nn_z, aVars->nx[side],aVars->ny[side],aVars->nz[side], aVars->wav_z*randnorm(), nt_x,nt_y,nt_z);
      } else { nn_x=aVars->nx[side]; nn_y=aVars->ny[side]; nn_z=aVars->nz[side]; }
      /* rotate n with angle wavy_{x|y} around n_z -> nt */
      phi = (side <=2) ? aVars->wav_lr : aVars->wav_tb;
      if (phi) {
        rotate(nt_x,nt_y,nt_z, nn_x,nn_y,nn_z, phi*randnorm(), 0,0,1);
      } else { nt_x=nn_x; nt_y=nn_y; nt_z=nn_z; }
      *cnx=nt_x; *cny=nt_y; *cnz=nt_z;
    } else
    { *cnx=aVars->nx[side]; *cny=aVars->ny[side]; *cnz=aVars->nz[side]; }
    return (side);
  }



#endif
#line 7778 "./ESS_BIFROST_shielding.c"

/* Shared user declarations for all components 'Shielding_logger'. */
#line 41 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_logger.comp"

// m_local_refl is to be used in shielding applications and accessed by shielding logger
#ifndef MVALUE_LOCAL_IS_DEF
#define MVALUE_LOCAL_IS_DEF 1
double m_local_refl=-1;
#endif

  struct Generalized_State_t {
    double _x,_y,_z,_vx,_vy,_vz;
    double _p,_t,_sx,_sy,_sz;
    double _mvalue; // coating m-value in the place of the hit
    long long int _nid;
    int _comp, _idx;
  };
  
#define SCATTER_LOG do { \
    if (bounce_store_index<BOUNCE_LOG_SIZE-1){\
      struct Generalized_State_t *bp=&(Bounce_store[bounce_store_index]);\
      if( (bp-1)->_p!=p || (bp-1)->_vx!=vx || (bp-1)->_vy!=vy || (bp-1)->_vz!=vz ){\
        Coords ctmp=POS_A_CURRENT_COMP;\
        Coords _r = coords_set(x,y,z);\
        Coords _v = coords_set(vx,vy,vz);\
        Coords _s = coords_set(sx,sy,sz);\
        Coords _rg,_vg,_sg;\
        Rotation _Rt;\
        rot_transpose(ROT_A_CURRENT_COMP,_Rt);\
        _rg=coords_add(rot_apply(_Rt,_r),ctmp);\
        _vg=rot_apply(_Rt,_v);\
        _sg=rot_apply(_Rt,_s);\
        coords_get(_rg,&(bp->_x),&(bp->_y),&(bp->_z));\
        coords_get(_vg,&(bp->_vx),&(bp->_vy),&(bp->_vz));\
        coords_get(_sg,&(bp->_sx),&(bp->_sy),&(bp->_sz));\
        bp->_t=t;\
        bp->_p=p;\
        bp->_nid=mcget_run_num();\
        bp->_comp=INDEX_CURRENT_COMP;\
        bp->_idx=bounce_store_index;\
/* New: registering m-value at reflection. it is set to -1 by component the if we missed coating */\
        bp->_mvalue=m_local_refl;\
      /* printf("Recording scattering, writing state (%d) to the buffer, r: %g %g %g v: %g %g %g p:%g\n",\
                bounce_store_index, bp->_x, bp->_y, bp->_z, bp->_vx, bp->_vy, bp->_vz, bp->_p);*/\
        bounce_store_index++;\
     }\
    }else if(bounce_store_index==(BOUNCE_LOG_SIZE-1) && !bounce_store_overrun){\
      printf("Warning (%s): Scatter_log overrun at %llu - not logging any more events\n",NAME_CURRENT_COMP,mcget_run_num());\
      bounce_store_overrun=1;\
    }\
    do {mcDEBUG_SCATTER(mcnlx, mcnly, mcnlz, mcnlvx, mcnlvy, mcnlvz, \
			mcnlt,mcnlsx,mcnlsy,mcnlsz, mcnlp); mcScattered++;} while(0);\
} while(0)

#define ABSORB_LOG do { /*printf("DOING ABSORB_LOG\n");*/ \
    if (bounce_store_index<BOUNCE_LOG_SIZE-1){\
      struct Generalized_State_t *bp=&(Bounce_store[bounce_store_index]);\
     /* if( (bp-1)->_p!=p || (bp-1)->_vx!=vx || (bp-1)->_vy!=vy || (bp-1)->_vz!=vz )*//*<-- Check removed, works wrong if neutron is absorbed at the entrance*/{\
        Coords ctmp=POS_A_CURRENT_COMP;\
        Coords _r = coords_set(x,y,z);\
        Coords _v = coords_set(vx,vy,vz);\
        Coords _s = coords_set(sx,sy,sz);\
        Coords _rg,_vg,_sg;\
        Rotation _Rt;\
        rot_transpose(ROT_A_CURRENT_COMP,_Rt);\
        _rg=coords_add(rot_apply(_Rt,_r),ctmp);\
        _vg=rot_apply(_Rt,_v);\
        _sg=rot_apply(_Rt,_s);\
        coords_get(_rg,&(bp->_x),&(bp->_y),&(bp->_z));\
        coords_get(_vg,&(bp->_vx),&(bp->_vy),&(bp->_vz));\
	/*bp->_vx=0.; bp->_vy=0.; bp->_vz=0.;*/\
        /*vx=0; vy=0;vz=0;*/\
        coords_get(_sg,&(bp->_sx),&(bp->_sy),&(bp->_sz));\
        bp->_t=t;\
        bp->_p=0.;\
        bp->_nid=mcget_run_num();\
        bp->_comp=INDEX_CURRENT_COMP;\
        bp->_idx=bounce_store_index;\
        bp->_mvalue=m_local_refl;\
      /* printf("Recording absorption event, writing state (%d) to the buffer, r: %g %g %g v: %g %g %g p:%g\n",\
                bounce_store_index, bp->_x, bp->_y, bp->_z, bp->_vx, bp->_vy, bp->_vz, bp->_p);*/\
        bounce_store_index++;\
      }\
    }else if(bounce_store_index==(BOUNCE_LOG_SIZE-1) && !bounce_store_overrun){\
      printf("Warning (%s): Scatter_log overrun at %llu - not logging any more events\n",NAME_CURRENT_COMP,mcget_run_num());\
      bounce_store_overrun=1;\
    }\
absorbed_in_optics=1;\
    do {mcDEBUG_STATE(mcnlx, mcnly, mcnlz, mcnlvx, mcnlvy, mcnlvz, \
        mcnlt,mcnlsx,mcnlsy,mcnlsz, mcnlp); mcDEBUG_ABSORB(); MAGNET_OFF; goto mcabsorb;} while(0);\
} while(0)


#define SCATTER0\
    do {mcDEBUG_SCATTER(mcnlx, mcnly, mcnlz, mcnlvx, mcnlvy, mcnlvz, \
			mcnlt,mcnlsx,mcnlsy,mcnlsz, mcnlp); mcScattered++;} while(0)

#define ABSORB0\
    do {mcDEBUG_STATE(mcnlx, mcnly, mcnlz, mcnlvx, mcnlvy, mcnlvz, \
        mcnlt,mcnlsx,mcnlsy,mcnlsz, mcnlp); mcDEBUG_ABSORB(); MAGNET_OFF; goto mcabsorb;} while(0)



  const int BOUNCE_LOG_SIZE=10000000;
  struct Generalized_State_t *Bounce_store;

#line 7885 "./ESS_BIFROST_shielding.c"

/* Shared user declarations for all components 'Virtual_output'. */
#line 67 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../sources/Virtual_output.comp"
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/monitor_nd-lib.h
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas 1.6
* Version: $Revision$
*
* This file is to be imported by the monitor_nd related components
* It handles some shared functions.
*
* Usage: within SHARE
* %include "monitor_nd-lib"
*
*******************************************************************************/

#ifndef MONITOR_ND_LIB_H

#define MONITOR_ND_LIB_H "$Revision$"
#define MONnD_COORD_NMAX  30  /* max number of variables to record */

  typedef struct MonitornD_Defines
  {
    int COORD_NONE  ;
    int COORD_X     ;
    int COORD_Y     ;
    int COORD_Z     ;
    int COORD_RADIUS; 
    int COORD_VX    ;
    int COORD_VY    ;
    int COORD_VZ    ;
    int COORD_V     ;
    int COORD_T     ;
    int COORD_P     ;
    int COORD_SX    ;
    int COORD_SY    ;
    int COORD_SZ    ;
    int COORD_KX    ;
    int COORD_KY    ;
    int COORD_KZ    ;
    int COORD_K     ;
    int COORD_ENERGY;
    int COORD_LAMBDA;
    int COORD_KXY   ;
    int COORD_KYZ   ;
    int COORD_KXZ   ;
    int COORD_VXY   ;
    int COORD_VYZ   ;
    int COORD_VXZ   ;
    int COORD_HDIV  ;
    int COORD_VDIV  ;
    int COORD_ANGLE ;
    int COORD_NCOUNT;
    int COORD_THETA ;
    int COORD_PHI   ;
    int COORD_USER1 ;
    int COORD_USER2 ;
    int COORD_USER3 ;
    int COORD_XY    ;
    int COORD_XZ    ;
    int COORD_YZ    ;
    int COORD_PIXELID;

    /* token modifiers */
    int COORD_VAR   ; /* next token should be a variable or normal option */
    int COORD_MIN   ; /* next token is a min value */
    int COORD_MAX   ; /* next token is a max value */
    int COORD_DIM   ; /* next token is a bin value */
    int COORD_FIL   ; /* next token is a filename */
    int COORD_EVNT  ; /* next token is a buffer size value */
    int COORD_3HE   ; /* next token is a 3He pressure value */
    int COORD_LOG   ; /* next variable will be in log scale */
    int COORD_ABS   ; /* next variable will be in abs scale */
    int COORD_SIGNAL; /* next variable will be the signal var */
    int COORD_AUTO  ; /* set auto limits */

    char TOKEN_DEL[32]; /* token separators */

    char SHAPE_SQUARE; /* shape of the monitor */
    char SHAPE_DISK  ;
    char SHAPE_SPHERE;
    char SHAPE_CYLIND;
    char SHAPE_BANANA; /* cylinder without top/bottom, on restricted angular area */
    char SHAPE_BOX   ;
    char SHAPE_PREVIOUS;
    char SHAPE_OFF;

  } MonitornD_Defines_type;

  typedef struct MonitornD_Variables
  {
    double area;
    double Sphere_Radius     ;
    double Cylinder_Height   ;
    char   Flag_With_Borders ;   /* 2 means xy borders too */
    char   Flag_List         ;   /* 1 store 1 buffer, 2 is list all, 3 list all+append */
    char   Flag_Multiple     ;   /* 1 when n1D, 0 for 2D */
    char   Flag_Verbose      ;
    int    Flag_Shape        ;
    char   Flag_Auto_Limits  ;   /* get limits from first Buffer */
    char   Flag_Absorb       ;   /* monitor is also a slit */
    char   Flag_per_cm2      ;   /* flux is per cm2 */
    char   Flag_log          ;   /* log10 of the flux */
    char   Flag_parallel     ;   /* set neutron state back after detection (parallel components) */
    char   Flag_Binary_List  ;
    char   Flag_capture      ;   /* lambda monitor with lambda/lambda(2200m/s = 1.7985 Angs) weightening */
    int    Flag_signal       ;   /* 0:monitor p, else monitor a mean value */
    int    Flag_mantid       ;   /* 0:normal monitor, else do mantid-event specifics */
    int    Flag_OFF          ;   /* Flag to indicate external geometry from OFF file */
    unsigned long OFF_polyidx;   /* When intersection is done externally by off_intersect, this gives the 
				    polygon number, i.e. pixel index */

    unsigned long Coord_Number      ;   /* total number of variables to monitor, plus intensity (0) */
    unsigned long Coord_NumberNoPixel;  /* same but without counting PixelID */
    unsigned long Buffer_Block      ;   /* Buffer size for list or auto limits */
    unsigned long Neutron_Counter   ;   /* event counter, simulation total counts is mcget_ncount() */
    unsigned long Buffer_Counter    ;   /* index in Buffer size (for realloc) */
    unsigned long Buffer_Size       ;
    int    Coord_Type[MONnD_COORD_NMAX];      /* type of variable */
    char   Coord_Label[MONnD_COORD_NMAX][30]; /* label of variable */
    char   Coord_Var[MONnD_COORD_NMAX][30];   /* short id of variable */
    long   Coord_Bin[MONnD_COORD_NMAX];       /* bins of variable array */
    long   Coord_BinProd[MONnD_COORD_NMAX];   /* product of bins of variable array */
    double Coord_Min[MONnD_COORD_NMAX];
    double Coord_Max[MONnD_COORD_NMAX];
    char   Monitor_Label[MONnD_COORD_NMAX*30];/* Label for monitor */
    char   Mon_File[128];                     /* output file name */

    double cx,cy,cz;
    double cvx, cvy, cvz;
    double ckx, cky, ckz;
    double csx, csy, csz;
    double cEx, cEy, cEz;
    double cs1, cs2, ct, cphi, cp;
    double He3_pressure;
    char   Flag_UsePreMonitor    ;   /* use a previously stored neutron parameter set */
    char   UserName1[128];
    char   UserName2[128];
    char   UserName3[128];
    double UserVariable1;
    double UserVariable2;
    double UserVariable3;
    char   option[CHAR_BUF_LENGTH];

    long long int Nsum;
    double psum, p2sum;
    double **Mon2D_N;
    double **Mon2D_p;
    double **Mon2D_p2;
    double *Mon2D_Buffer;
    unsigned long PixelID;

    double mxmin,mxmax,mymin,mymax,mzmin,mzmax;
    double mean_dx, mean_dy, min_x, min_y, max_x, max_y, mean_p;

    char   compcurname[128];
    Coords compcurpos;

  } MonitornD_Variables_type;

/* monitor_nd-lib function prototypes */
/* ========================================================================= */

void Monitor_nD_Init(MonitornD_Defines_type *, MonitornD_Variables_type *, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, int);
int Monitor_nD_Trace(MonitornD_Defines_type *, MonitornD_Variables_type *);
MCDETECTOR Monitor_nD_Save(MonitornD_Defines_type *, MonitornD_Variables_type *);
void Monitor_nD_Finally(MonitornD_Defines_type *, MonitornD_Variables_type *);
void Monitor_nD_McDisplay(MonitornD_Defines_type *,
 MonitornD_Variables_type *);

#define MONND_DECLARE(monname) \
  struct MonitornD_Variables *mcmonnd ## monname;
#define MONND_USER_TITLE(monname, num, title) \
  { mcmonnd ## monname = &(MC_GETPAR(monname, Vars)); \
    strcpy(mcmonnd ## monname->UserName ## num, title); }
#define MONND_USER_VALUE(monname, num, value) \
  { mcmonnd ## monname = &(MC_GETPAR(monname, Vars)); \
    mcmonnd ## monname->UserVariable ## num = (value); }

#endif

/* end of monitor_nd-lib.h */
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/monitor_nd-lib.c
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas 1.6
* Version: $Revision$
*
* This file is to be imported by the monitor_nd related components
* It handles some shared functions. Embedded within instrument in runtime mode.
*
* Usage: within SHARE
* %include "monitor_nd-lib"
*
*******************************************************************************/

#ifndef MONITOR_ND_LIB_H
#error McStas : please import this library with %include "monitor_nd-lib"
#endif

/* ========================================================================= */
/* Monitor_nD_Init: this routine is used to parse options                    */
/* ========================================================================= */

void Monitor_nD_Init(MonitornD_Defines_type *DEFS,
  MonitornD_Variables_type *Vars,
  MCNUM xwidth,
  MCNUM yheight,
  MCNUM zdepth,
  MCNUM xmin,
  MCNUM xmax,
  MCNUM ymin,
  MCNUM ymax,
  MCNUM zmin,
  MCNUM zmax,
  int offflag)
  {
    long carg = 1;
    char *option_copy, *token;
    char Flag_New_token = 1;
    char Flag_End       = 1;
    char Flag_All       = 0;
    char Flag_No        = 0;
    char Flag_abs       = 0;
    int  Flag_auto      = 0;  /* -1: all, 1: the current variable */
    int  Set_Vars_Coord_Type;
    char Set_Vars_Coord_Label[64];
    char Set_Vars_Coord_Var[64];
    char Short_Label[MONnD_COORD_NMAX][64];
    int  Set_Coord_Mode;
    long i=0, j=0;
    double lmin, lmax, XY=0;
    long t;


    t = (long)time(NULL);

/* initialize DEFS */
/* Variables to monitor */
    DEFS->COORD_NONE   =0;
    DEFS->COORD_X      =1;
    DEFS->COORD_Y      =2;
    DEFS->COORD_Z      =3;
    DEFS->COORD_RADIUS =19;
    DEFS->COORD_VX     =4;
    DEFS->COORD_VY     =5;
    DEFS->COORD_VZ     =6;
    DEFS->COORD_V      =16;
    DEFS->COORD_T      =7;
    DEFS->COORD_P      =8;
    DEFS->COORD_SX     =9;
    DEFS->COORD_SY     =10;
    DEFS->COORD_SZ     =11;
    DEFS->COORD_KX     =12;
    DEFS->COORD_KY     =13;
    DEFS->COORD_KZ     =14;
    DEFS->COORD_K      =15;
    DEFS->COORD_ENERGY =17;
    DEFS->COORD_LAMBDA =18;
    DEFS->COORD_HDIV   =20;
    DEFS->COORD_VDIV   =21;
    DEFS->COORD_ANGLE  =22;
    DEFS->COORD_NCOUNT =23;
    DEFS->COORD_THETA  =24;
    DEFS->COORD_PHI    =25;
    DEFS->COORD_USER1  =26;
    DEFS->COORD_USER2  =27;
    DEFS->COORD_USER3  =28;
    DEFS->COORD_XY     =37;
    DEFS->COORD_YZ     =31;
    DEFS->COORD_XZ     =32;
    DEFS->COORD_VXY    =30;
    DEFS->COORD_VYZ    =34;
    DEFS->COORD_VXZ    =36;
    DEFS->COORD_KXY    =29;
    DEFS->COORD_KYZ    =33;
    DEFS->COORD_KXZ    =35;
    DEFS->COORD_PIXELID=38;

/* token modifiers */
    DEFS->COORD_VAR    =0;    /* next token should be a variable or normal option */
    DEFS->COORD_MIN    =1;    /* next token is a min value */
    DEFS->COORD_MAX    =2;    /* next token is a max value */
    DEFS->COORD_DIM    =3;    /* next token is a bin value */
    DEFS->COORD_FIL    =4;    /* next token is a filename */
    DEFS->COORD_EVNT   =5;    /* next token is a buffer size value */
    DEFS->COORD_3HE    =6;    /* next token is a 3He pressure value */
    DEFS->COORD_LOG    =64;   /* next variable will be in log scale */
    DEFS->COORD_ABS    =128;  /* next variable will be in abs scale */
    DEFS->COORD_SIGNAL =256;  /* next variable will be the signal var */
    DEFS->COORD_AUTO   =512;  /* set auto limits */

    strcpy(DEFS->TOKEN_DEL, " =,;[](){}:");  /* token separators */

    DEFS->SHAPE_SQUARE =0;    /* shape of the monitor */
    DEFS->SHAPE_DISK   =1;
    DEFS->SHAPE_SPHERE =2;
    DEFS->SHAPE_CYLIND =3;
    DEFS->SHAPE_BANANA =4;
    DEFS->SHAPE_BOX    =5;
    DEFS->SHAPE_PREVIOUS=6;
    DEFS->SHAPE_OFF=7;

    Vars->Sphere_Radius     = 0;
    Vars->Cylinder_Height   = 0;
    Vars->Flag_With_Borders = 0;   /* 2 means xy borders too */
    Vars->Flag_List         = 0;   /* 1=store 1 buffer, 2=list all, 3=re-use buffer */
    Vars->Flag_Multiple     = 0;   /* 1 when n1D, 0 for 2D */
    Vars->Flag_Verbose      = 0;
    Vars->Flag_Shape        = DEFS->SHAPE_SQUARE;
    Vars->Flag_Auto_Limits  = 0;   /* get limits from first Buffer */
    Vars->Flag_Absorb       = 0;   /* monitor is also a slit */
    Vars->Flag_per_cm2      = 0;   /* flux is per cm2 */
    Vars->Flag_log          = 0;   /* log10 of the flux */
    Vars->Flag_parallel     = 0;   /* set neutron state back after detection (parallel components) */
    Vars->Flag_Binary_List  = 0;   /* save list as a binary file (smaller) */
    Vars->Coord_Number      = 0;   /* total number of variables to monitor, plus intensity (0) */
    Vars->Coord_NumberNoPixel=0;   /* same but without counting PixelID */

/* Allow to specify size of Monitor_nD buffer via a define*/
#ifndef MONND_BUFSIZ
    Vars->Buffer_Block      = 100000;     /* Buffer size for list or auto limits */
#else
	Vars->Buffer_Block      = MONND_BUFSIZ;     /* Buffer size for list or auto limits */	
#endif
    Vars->Neutron_Counter   = 0;   /* event counter, simulation total counts is mcget_ncount() */
    Vars->Buffer_Counter    = 0;   /* index in Buffer size (for realloc) */
    Vars->Buffer_Size       = 0;
    Vars->UserVariable1     = 0;
    Vars->UserVariable2     = 0;
    Vars->He3_pressure      = 0;
    Vars->Flag_capture      = 0;
    Vars->Flag_signal       = DEFS->COORD_P;
    Vars->Flag_mantid       = 0;
    Vars->Flag_OFF          = offflag;
    Vars->OFF_polyidx       = -1;
    Vars->mean_dx=Vars->mean_dy=0;
    Vars->min_x = Vars->max_x  =0;
    Vars->min_y = Vars->max_y  =0;

    Set_Vars_Coord_Type = DEFS->COORD_NONE;
    Set_Coord_Mode = DEFS->COORD_VAR;

    /* handle size parameters */
    /* normal use is with xwidth, yheight, zdepth */
    /* if xmin,xmax,ymin,ymax,zmin,zmax are non 0, use them */
    if (fabs(xmin-xmax) == 0)
      { Vars->mxmin = -fabs(xwidth)/2; Vars->mxmax = fabs(xwidth)/2; }
    else
      { if (xmin < xmax) {Vars->mxmin = xmin; Vars->mxmax = xmax;}
        else {Vars->mxmin = xmax; Vars->mxmax = xmin;}
      }
    if (fabs(ymin-ymax) == 0)
      { Vars->mymin = -fabs(yheight)/2; Vars->mymax = fabs(yheight)/2; }
    else
      { if (ymin < ymax) {Vars->mymin = ymin; Vars->mymax = ymax;}
        else {Vars->mymin = ymax; Vars->mymax = ymin;}
      }
    if (fabs(zmin-zmax) == 0)
      { Vars->mzmin = -fabs(zdepth)/2; Vars->mzmax = fabs(zdepth)/2; }
    else
      { if (zmin < zmax) {Vars->mzmin = zmin; Vars->mzmax = zmax; }
        else {Vars->mzmin = zmax; Vars->mzmax = zmin; }
      }

    if (fabs(Vars->mzmax-Vars->mzmin) == 0)
      Vars->Flag_Shape        = DEFS->SHAPE_SQUARE;
    else
      Vars->Flag_Shape        = DEFS->SHAPE_BOX;

    if (Vars->Flag_OFF) {
      Vars->Flag_Shape        = DEFS->SHAPE_OFF;
    }
    
    /* parse option string */

    option_copy = (char*)malloc(strlen(Vars->option)+1);
    if (option_copy == NULL)
    {
      fprintf(stderr,"Monitor_nD: %s cannot allocate 'options' copy (%li). Fatal.\n", Vars->compcurname, (long)strlen(Vars->option));
      exit(-1);
    }

    if (strlen(Vars->option))
    {
      Flag_End = 0;
      strcpy(option_copy, Vars->option);
    }

    if (strstr(Vars->option, "cm2") || strstr(Vars->option, "cm^2")) Vars->Flag_per_cm2 = 1;

    if (strstr(Vars->option, "binary") || strstr(Vars->option, "float"))
      Vars->Flag_Binary_List  = 1;
    if (strstr(Vars->option, "double"))
      Vars->Flag_Binary_List  = 2;

    strcpy(Vars->Coord_Label[0],"Intensity");
    strncpy(Vars->Coord_Var[0],"p",30);
    Vars->Coord_Type[0] = DEFS->COORD_P;
    Vars->Coord_Bin[0] = 1;
    Vars->Coord_Min[0] = 0;
    Vars->Coord_Max[0] = FLT_MAX;

    /* default file name is comp_name+dateID */
    sprintf(Vars->Mon_File, "%s_%li", Vars->compcurname, t);

    carg = 1;
    while((Flag_End == 0) && (carg < 128))
    {

      if (Flag_New_token) /* retain previous token or get a new one */
      {
        if (carg == 1) token=(char *)strtok(option_copy,DEFS->TOKEN_DEL);
        else token=(char *)strtok(NULL,DEFS->TOKEN_DEL);
        if (token == NULL) Flag_End=1;
      }
      Flag_New_token = 1;
      if ((token != NULL) && (strlen(token) != 0))
      {
        char iskeyword=0; /* left at 0 when variables are processed, 1 for modifiers */
        int  old_Mode;
        /* change token to lower case */
        for (i=0; i<strlen(token); i++) token[i]=tolower(token[i]);
        /* first handle option values from preceeding keyword token detected */
        old_Mode = Set_Coord_Mode;
        if (Set_Coord_Mode == DEFS->COORD_MAX)  /* max=%i */
        {
          if (!Flag_All)
            Vars->Coord_Max[Vars->Coord_Number] = atof(token);
          else
            for (i = 0; i <= Vars->Coord_Number; Vars->Coord_Max[i++] = atof(token));
          Set_Coord_Mode = DEFS->COORD_VAR; Flag_All = 0;
        }
        if (Set_Coord_Mode == DEFS->COORD_MIN)  /* min=%i */
        {
          if (!Flag_All)
            Vars->Coord_Min[Vars->Coord_Number] = atof(token);
          else
            for (i = 0; i <= Vars->Coord_Number; Vars->Coord_Min[i++] = atof(token));
          Set_Coord_Mode = DEFS->COORD_MAX;
        }
        if (Set_Coord_Mode == DEFS->COORD_DIM)  /* bins=%i */
        {
          if (!Flag_All)
            Vars->Coord_Bin[Vars->Coord_Number] = atoi(token);
          else
            for (i = 0; i <= Vars->Coord_Number; Vars->Coord_Bin[i++] = atoi(token));
          Set_Coord_Mode = DEFS->COORD_VAR; Flag_All = 0;
        }
        if (Set_Coord_Mode == DEFS->COORD_FIL)  /* file=%s */
        {
          if (!Flag_No) strncpy(Vars->Mon_File,token,128);
          else { strcpy(Vars->Mon_File,""); Vars->Coord_Number = 0; Flag_End = 1;}
          Set_Coord_Mode = DEFS->COORD_VAR;
        }
        if (Set_Coord_Mode == DEFS->COORD_EVNT) /* list=%i */
        {
          if (!strcmp(token, "all") || Flag_All) Vars->Flag_List = 2;
          else { i = (long)ceil(atof(token)); if (i) Vars->Buffer_Block = i;
            Vars->Flag_List = 1; }
          Set_Coord_Mode = DEFS->COORD_VAR; Flag_All = 0;
        }
        if (Set_Coord_Mode == DEFS->COORD_3HE)  /* pressure=%g */
        {
            Vars->He3_pressure = atof(token);
            Set_Coord_Mode = DEFS->COORD_VAR; Flag_All = 0;
        }

        /* now look for general option keywords */
        if (!strcmp(token, "borders"))  {Vars->Flag_With_Borders = 1; iskeyword=1; }
        if (!strcmp(token, "verbose"))  {Vars->Flag_Verbose      = 1; iskeyword=1; }
        if (!strcmp(token, "log"))      {Vars->Flag_log          = 1; iskeyword=1; }
        if (!strcmp(token, "abs"))      {Flag_abs                = 1; iskeyword=1; }
        if (!strcmp(token, "multiple")) {Vars->Flag_Multiple     = 1; iskeyword=1; }
        if (!strcmp(token, "list") || !strcmp(token, "events")) {
          Vars->Flag_List = 1; Set_Coord_Mode = DEFS->COORD_EVNT;  }
        if (!strcmp(token, "limits") || !strcmp(token, "min"))
          Set_Coord_Mode = DEFS->COORD_MIN;
        if (!strcmp(token, "slit") || !strcmp(token, "absorb")) {
          Vars->Flag_Absorb = 1;  iskeyword=1; }
        if (!strcmp(token, "max"))  Set_Coord_Mode = DEFS->COORD_MAX;
        if (!strcmp(token, "bins") || !strcmp(token, "dim")) Set_Coord_Mode = DEFS->COORD_DIM;
        if (!strcmp(token, "file") || !strcmp(token, "filename")) {
          Set_Coord_Mode = DEFS->COORD_FIL;
          if (Flag_No) { strcpy(Vars->Mon_File,""); Vars->Coord_Number = 0; Flag_End = 1; }
        }
        if (!strcmp(token, "unactivate")) {
          Flag_End = 1; Vars->Coord_Number = 0; iskeyword=1; }
        if (!strcmp(token, "all"))    { Flag_All = 1;  iskeyword=1; }
        if (!strcmp(token, "sphere")) { Vars->Flag_Shape = DEFS->SHAPE_SPHERE; iskeyword=1; }
        if (!strcmp(token, "cylinder")) { Vars->Flag_Shape = DEFS->SHAPE_CYLIND; iskeyword=1; }
        if (!strcmp(token, "banana")) { Vars->Flag_Shape = DEFS->SHAPE_BANANA; iskeyword=1; }
        if (!strcmp(token, "square")) { Vars->Flag_Shape = DEFS->SHAPE_SQUARE; iskeyword=1; }
        if (!strcmp(token, "disk"))   { Vars->Flag_Shape = DEFS->SHAPE_DISK; iskeyword=1; }
        if (!strcmp(token, "box"))     { Vars->Flag_Shape = DEFS->SHAPE_BOX; iskeyword=1; }
        if (!strcmp(token, "previous")) { Vars->Flag_Shape = DEFS->SHAPE_PREVIOUS; iskeyword=1; }
        if (!strcmp(token, "parallel")){ Vars->Flag_parallel = 1; iskeyword=1; }
        if (!strcmp(token, "capture")) { Vars->Flag_capture = 1; iskeyword=1; }
        if (!strcmp(token, "auto") && (Flag_auto != -1)) {
          Vars->Flag_Auto_Limits = 1;
          if (Flag_All) Flag_auto = -1;
          else          Flag_auto = 1;
          iskeyword=1; Flag_All=0; }
        if (!strcmp(token, "premonitor")) {
          Vars->Flag_UsePreMonitor = 1; iskeyword=1; }
        if (!strcmp(token, "3He_pressure") || !strcmp(token, "pressure")) {
          Vars->He3_pressure = 3; iskeyword=1; }
        if (!strcmp(token, "no") || !strcmp(token, "not")) { Flag_No = 1;  iskeyword=1; }
        if (!strcmp(token, "signal")) Set_Coord_Mode = DEFS->COORD_SIGNAL;
        if (!strcmp(token, "mantid")) { Vars->Flag_mantid = 1; iskeyword=1; }

        /* Mode has changed: this was a keyword or value  ? */
        if (Set_Coord_Mode != old_Mode) iskeyword=1;

        /* now look for variable names to monitor */
        Set_Vars_Coord_Type = DEFS->COORD_NONE; lmin = 0; lmax = 0;

        if (!strcmp(token, "x"))
          { Set_Vars_Coord_Type = DEFS->COORD_X; strcpy(Set_Vars_Coord_Label,"x [m]"); strcpy(Set_Vars_Coord_Var,"x");
          lmin = Vars->mxmin; lmax = Vars->mxmax;
          Vars->Coord_Min[Vars->Coord_Number+1] = Vars->mxmin;
          Vars->Coord_Max[Vars->Coord_Number+1] = Vars->mxmax;}
        if (!strcmp(token, "y"))
          { Set_Vars_Coord_Type = DEFS->COORD_Y; strcpy(Set_Vars_Coord_Label,"y [m]"); strcpy(Set_Vars_Coord_Var,"y");
          lmin = Vars->mymin; lmax = Vars->mymax;
          Vars->Coord_Min[Vars->Coord_Number+1] = Vars->mymin;
          Vars->Coord_Max[Vars->Coord_Number+1] = Vars->mymax;}
        if (!strcmp(token, "z"))
          { Set_Vars_Coord_Type = DEFS->COORD_Z; strcpy(Set_Vars_Coord_Label,"z [m]"); strcpy(Set_Vars_Coord_Var,"z"); lmin = Vars->mzmin; lmax = Vars->mzmax; }
        if (!strcmp(token, "k") || !strcmp(token, "wavevector"))
          { Set_Vars_Coord_Type = DEFS->COORD_K; strcpy(Set_Vars_Coord_Label,"|k| [Angs-1]"); strcpy(Set_Vars_Coord_Var,"k"); lmin = 0; lmax = 10; }
        if (!strcmp(token, "v"))
          { Set_Vars_Coord_Type = DEFS->COORD_V; strcpy(Set_Vars_Coord_Label,"Velocity [m/s]"); strcpy(Set_Vars_Coord_Var,"v"); lmin = 0; lmax = 1000000; }
        if (!strcmp(token, "t") || !strcmp(token, "time") || !strcmp(token, "tof"))
          { Set_Vars_Coord_Type = DEFS->COORD_T; strcpy(Set_Vars_Coord_Label,"TOF [s]"); strcpy(Set_Vars_Coord_Var,"t"); lmin = 0; lmax = .1; }
        if ((!strcmp(token, "p") || !strcmp(token, "i") || !strcmp(token, "intensity") || !strcmp(token, "flux")))
          { Set_Vars_Coord_Type = DEFS->COORD_P;
            strcpy(Set_Vars_Coord_Label,"Intensity");
            strncat(Set_Vars_Coord_Label, " [n/s", 30);
            if (Vars->Flag_per_cm2) strncat(Set_Vars_Coord_Label, "/cm2", 30);
            if (XY > 1 && Vars->Coord_Number)
              strncat(Set_Vars_Coord_Label, "/bin", 30);
            strncat(Set_Vars_Coord_Label, "]", 30);
            strcpy(Set_Vars_Coord_Var,"I");
            lmin = 0; lmax = FLT_MAX;
            if (Flag_auto>0) Flag_auto=0;
          }

        if (!strcmp(token, "vx"))
          { Set_Vars_Coord_Type = DEFS->COORD_VX; strcpy(Set_Vars_Coord_Label,"vx [m/s]"); strcpy(Set_Vars_Coord_Var,"vx"); lmin = -1000; lmax = 1000; }
        if (!strcmp(token, "vy"))
          { Set_Vars_Coord_Type = DEFS->COORD_VY; strcpy(Set_Vars_Coord_Label,"vy [m/s]"); strcpy(Set_Vars_Coord_Var,"vy"); lmin = -1000; lmax = 1000; }
        if (!strcmp(token, "vz"))
          { Set_Vars_Coord_Type = DEFS->COORD_VZ; strcpy(Set_Vars_Coord_Label,"vz [m/s]"); strcpy(Set_Vars_Coord_Var,"vz"); lmin = -10000; lmax = 10000; }
        if (!strcmp(token, "kx"))
          { Set_Vars_Coord_Type = DEFS->COORD_KX; strcpy(Set_Vars_Coord_Label,"kx [Angs-1]"); strcpy(Set_Vars_Coord_Var,"kx"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "ky"))
          { Set_Vars_Coord_Type = DEFS->COORD_KY; strcpy(Set_Vars_Coord_Label,"ky [Angs-1]"); strcpy(Set_Vars_Coord_Var,"ky"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "kz"))
          { Set_Vars_Coord_Type = DEFS->COORD_KZ; strcpy(Set_Vars_Coord_Label,"kz [Angs-1]"); strcpy(Set_Vars_Coord_Var,"kz"); lmin = -10; lmax = 10; }
        if (!strcmp(token, "sx"))
          { Set_Vars_Coord_Type = DEFS->COORD_SX; strcpy(Set_Vars_Coord_Label,"sx [1]"); strcpy(Set_Vars_Coord_Var,"sx"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "sy"))
          { Set_Vars_Coord_Type = DEFS->COORD_SY; strcpy(Set_Vars_Coord_Label,"sy [1]"); strcpy(Set_Vars_Coord_Var,"sy"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "sz"))
          { Set_Vars_Coord_Type = DEFS->COORD_SZ; strcpy(Set_Vars_Coord_Label,"sz [1]"); strcpy(Set_Vars_Coord_Var,"sz"); lmin = -1; lmax = 1; }

        if (!strcmp(token, "energy") || !strcmp(token, "omega") || !strcmp(token, "e"))
          { Set_Vars_Coord_Type = DEFS->COORD_ENERGY; strcpy(Set_Vars_Coord_Label,"Energy [meV]"); strcpy(Set_Vars_Coord_Var,"E"); lmin = 0; lmax = 100; }
        if (!strcmp(token, "lambda") || !strcmp(token, "wavelength") || !strcmp(token, "l"))
          { Set_Vars_Coord_Type = DEFS->COORD_LAMBDA; strcpy(Set_Vars_Coord_Label,"Wavelength [Angs]"); strcpy(Set_Vars_Coord_Var,"L"); lmin = 0; lmax = 100; }
        if (!strcmp(token, "radius") || !strcmp(token, "r"))
          { Set_Vars_Coord_Type = DEFS->COORD_RADIUS; strcpy(Set_Vars_Coord_Label,"Radius [m]"); strcpy(Set_Vars_Coord_Var,"xy"); lmin = 0; lmax = xmax; }
        if (!strcmp(token, "xy"))
          { Set_Vars_Coord_Type = DEFS->COORD_XY; strcpy(Set_Vars_Coord_Label,"Radius (xy) [m]"); strcpy(Set_Vars_Coord_Var,"xy"); lmin = 0; lmax = xmax; }
        if (!strcmp(token, "yz"))
          { Set_Vars_Coord_Type = DEFS->COORD_YZ; strcpy(Set_Vars_Coord_Label,"Radius (yz) [m]"); strcpy(Set_Vars_Coord_Var,"yz"); lmin = 0; lmax = xmax; }
        if (!strcmp(token, "xz"))
          { Set_Vars_Coord_Type = DEFS->COORD_XZ; strcpy(Set_Vars_Coord_Label,"Radius (xz) [m]"); strcpy(Set_Vars_Coord_Var,"xz"); lmin = 0; lmax = xmax; }
        if (!strcmp(token, "vxy"))
          { Set_Vars_Coord_Type = DEFS->COORD_VXY; strcpy(Set_Vars_Coord_Label,"Radial Velocity (xy) [m]"); strcpy(Set_Vars_Coord_Var,"Vxy"); lmin = 0; lmax = 2000; }
        if (!strcmp(token, "kxy"))
          { Set_Vars_Coord_Type = DEFS->COORD_KXY; strcpy(Set_Vars_Coord_Label,"Radial Wavevector (xy) [Angs-1]"); strcpy(Set_Vars_Coord_Var,"Kxy"); lmin = 0; lmax = 2; }
        if (!strcmp(token, "vyz"))
          { Set_Vars_Coord_Type = DEFS->COORD_VYZ; strcpy(Set_Vars_Coord_Label,"Radial Velocity (yz) [m]"); strcpy(Set_Vars_Coord_Var,"Vyz"); lmin = 0; lmax = 2000; }
        if (!strcmp(token, "kyz"))
          { Set_Vars_Coord_Type = DEFS->COORD_KYZ; strcpy(Set_Vars_Coord_Label,"Radial Wavevector (yz) [Angs-1]"); strcpy(Set_Vars_Coord_Var,"Kyz"); lmin = 0; lmax = 2; }
        if (!strcmp(token, "vxz"))
          { Set_Vars_Coord_Type = DEFS->COORD_VXZ; strcpy(Set_Vars_Coord_Label,"Radial Velocity (xz) [m]"); strcpy(Set_Vars_Coord_Var,"Vxz"); lmin = 0; lmax = 2000; }
        if (!strcmp(token, "kxz"))
          { Set_Vars_Coord_Type = DEFS->COORD_KXZ; strcpy(Set_Vars_Coord_Label,"Radial Wavevector (xz) [Angs-1]"); strcpy(Set_Vars_Coord_Var,"Kxz"); lmin = 0; lmax = 2; }
        if (!strcmp(token, "angle") || !strcmp(token, "a"))
          { Set_Vars_Coord_Type = DEFS->COORD_ANGLE; strcpy(Set_Vars_Coord_Label,"Angle [deg]"); strcpy(Set_Vars_Coord_Var,"A"); lmin = -50; lmax = 50; }
        if (!strcmp(token, "hdiv")|| !strcmp(token, "divergence") || !strcmp(token, "xdiv") || !strcmp(token, "hd") || !strcmp(token, "dx"))
          { Set_Vars_Coord_Type = DEFS->COORD_HDIV; strcpy(Set_Vars_Coord_Label,"Hor. Divergence [deg]"); strcpy(Set_Vars_Coord_Var,"hd"); lmin = -5; lmax = 5; }
        if (!strcmp(token, "vdiv") || !strcmp(token, "ydiv") || !strcmp(token, "vd") || !strcmp(token, "dy"))
          { Set_Vars_Coord_Type = DEFS->COORD_VDIV; strcpy(Set_Vars_Coord_Label,"Vert. Divergence [deg]"); strcpy(Set_Vars_Coord_Var,"vd"); lmin = -5; lmax = 5; }
        if (!strcmp(token, "theta") || !strcmp(token, "longitude") || !strcmp(token, "th"))
          { Set_Vars_Coord_Type = DEFS->COORD_THETA; strcpy(Set_Vars_Coord_Label,"Longitude [deg]"); strcpy(Set_Vars_Coord_Var,"th"); lmin = -180; lmax = 180; }
        if (!strcmp(token, "phi") || !strcmp(token, "lattitude") || !strcmp(token, "ph"))
          { Set_Vars_Coord_Type = DEFS->COORD_PHI; strcpy(Set_Vars_Coord_Label,"Lattitude [deg]"); strcpy(Set_Vars_Coord_Var,"ph"); lmin = -180; lmax = 180; }
        if (!strcmp(token, "ncounts") || !strcmp(token, "n") || !strcmp(token, "neutron"))
          { Set_Vars_Coord_Type = DEFS->COORD_NCOUNT; strcpy(Set_Vars_Coord_Label,"Neutron ID [1]"); strcpy(Set_Vars_Coord_Var,"n"); lmin = 0; lmax = mcget_ncount(); if (Flag_auto>0) Flag_auto=0; }
        if (!strcmp(token, "id") || !strcmp(token, "pixel"))
          { Set_Vars_Coord_Type = DEFS->COORD_PIXELID; 
            strcpy(Set_Vars_Coord_Label,"Pixel ID [1]"); 
            strcpy(Set_Vars_Coord_Var,"id"); lmin = 0; lmax = FLT_MAX; 
            if (Flag_auto>0) Flag_auto=0;
            Vars->Flag_List = 1; }
        if (!strcmp(token, "user") || !strcmp(token, "user1") || !strcmp(token, "u1"))
          { Set_Vars_Coord_Type = DEFS->COORD_USER1; strncpy(Set_Vars_Coord_Label,Vars->UserName1,30); strcpy(Set_Vars_Coord_Var,"U1"); lmin = -1e10; lmax = 1e10; }
        if (!strcmp(token, "user2") || !strcmp(token, "u2"))
          { Set_Vars_Coord_Type = DEFS->COORD_USER2; strncpy(Set_Vars_Coord_Label,Vars->UserName2,30); strcpy(Set_Vars_Coord_Var,"U2"); lmin = -1e10; lmax = 1e10; }
        if (!strcmp(token, "user3") || !strcmp(token, "u3"))
          { Set_Vars_Coord_Type = DEFS->COORD_USER3; strncpy(Set_Vars_Coord_Label,Vars->UserName3,30); strcpy(Set_Vars_Coord_Var,"U3"); lmin = -1e10; lmax = 1e10; }

        /* now stores variable keywords detected, if any */
        if (Set_Vars_Coord_Type != DEFS->COORD_NONE)
        {
          int Coord_Number = Vars->Coord_Number;
          if (Vars->Flag_log) { Set_Vars_Coord_Type |= DEFS->COORD_LOG; Vars->Flag_log = 0; }
          if (Flag_abs) { Set_Vars_Coord_Type |= DEFS->COORD_ABS; Flag_abs = 0; }
          if (Flag_auto != 0) { Set_Vars_Coord_Type |= DEFS->COORD_AUTO; 
            if (Flag_auto > 0) Flag_auto = 0; }
          if (Set_Coord_Mode == DEFS->COORD_SIGNAL)
          {
            Coord_Number = 0;
            Vars->Flag_signal = Set_Vars_Coord_Type;
          }
          else
          {
            if (Coord_Number < MONnD_COORD_NMAX)
            { Coord_Number++;
              Vars->Coord_Number = Coord_Number; 
              if (Set_Vars_Coord_Type != DEFS->COORD_PIXELID)
                Vars->Coord_NumberNoPixel++;
            }
            else if (Vars->Flag_Verbose) printf("Monitor_nD: %s reached max number of variables (%i).\n", Vars->compcurname, MONnD_COORD_NMAX);
          }
          Vars->Coord_Type[Coord_Number] = Set_Vars_Coord_Type;
          strncpy(Vars->Coord_Label[Coord_Number], Set_Vars_Coord_Label,30);
          strncpy(Vars->Coord_Var[Coord_Number], Set_Vars_Coord_Var,30);
          if (lmin > lmax) { XY = lmin; lmin=lmax; lmax = XY; }
          Vars->Coord_Min[Coord_Number] = lmin;
          Vars->Coord_Max[Coord_Number] = lmax;
          if (Set_Vars_Coord_Type == DEFS->COORD_NCOUNT || Set_Vars_Coord_Type == DEFS->COORD_PIXELID || Set_Vars_Coord_Type == DEFS->COORD_SIGNAL)
            Vars->Coord_Bin[Coord_Number] = 1;
          else
            Vars->Coord_Bin[Coord_Number] = 20;
          Set_Coord_Mode = DEFS->COORD_VAR;
          Flag_All = 0;
          Flag_No  = 0;
        } else {
          /* no variable name could be read from options */
          if (!iskeyword) {
            if (strcmp(token, "cm2") && strcmp(token, "incoming")
             && strcmp(token, "outgoing") && strcmp(token, "cm2")
             && strcmp(token, "cm^2") && strcmp(token, "float")
             && strcmp(token, "double") && strcmp(token, "binary")
             && strcmp(token, "steradian") && Vars->Flag_Verbose)
              printf("Monitor_nD: %s: unknown '%s' keyword in 'options'. Ignoring.\n", Vars->compcurname, token);
          }
        }
      carg++;
      } /* end if token */
    } /* end while carg */
    free(option_copy);
    if (carg == 128) printf("Monitor_nD: %s reached max number of tokens (%i). Skipping.\n", Vars->compcurname, 128);

    if ((Vars->Flag_Shape == DEFS->SHAPE_BOX) && (fabs(Vars->mzmax - Vars->mzmin) == 0)) Vars->Flag_Shape = DEFS->SHAPE_SQUARE;

    if (Vars->Flag_log == 1) Vars->Coord_Type[0] |= DEFS->COORD_LOG;
    if (Vars->Coord_Number == 0)
    { Vars->Flag_Auto_Limits=0; Vars->Flag_Multiple=0; Vars->Flag_List=0; }

    /* now setting Monitor Name from variable labels */
    strcpy(Vars->Monitor_Label,"");
    XY = 1; /* will contain total bin number */
    for (i = 0; i <= Vars->Coord_Number; i++)
    {
      if (Flag_auto != 0) Vars->Coord_Type[i] |= DEFS->COORD_AUTO;
      Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
      if ((Set_Vars_Coord_Type == DEFS->COORD_X)
       || (Set_Vars_Coord_Type == DEFS->COORD_Y)
       || (Set_Vars_Coord_Type == DEFS->COORD_Z))
       strcpy(Short_Label[i],"Position");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_THETA)
       || (Set_Vars_Coord_Type == DEFS->COORD_PHI)
       || (Set_Vars_Coord_Type == DEFS->COORD_ANGLE))
       strcpy(Short_Label[i],"Angle");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_XY)
       || (Set_Vars_Coord_Type == DEFS->COORD_XZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_YZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_RADIUS))
       strcpy(Short_Label[i],"Radius");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_VX)
       || (Set_Vars_Coord_Type == DEFS->COORD_VY)
       || (Set_Vars_Coord_Type == DEFS->COORD_VZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_V)
       || (Set_Vars_Coord_Type == DEFS->COORD_VXY)
       || (Set_Vars_Coord_Type == DEFS->COORD_VYZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_VXZ))
       strcpy(Short_Label[i],"Velocity");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_KX)
       || (Set_Vars_Coord_Type == DEFS->COORD_KY)
       || (Set_Vars_Coord_Type == DEFS->COORD_KZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_KXY)
       || (Set_Vars_Coord_Type == DEFS->COORD_KYZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_KXZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_K))
       strcpy(Short_Label[i],"Wavevector");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_SX)
       || (Set_Vars_Coord_Type == DEFS->COORD_SY)
       || (Set_Vars_Coord_Type == DEFS->COORD_SZ))
       strcpy(Short_Label[i],"Spin");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_HDIV)
       || (Set_Vars_Coord_Type == DEFS->COORD_VDIV))
       strcpy(Short_Label[i],"Divergence");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_ENERGY)
       strcpy(Short_Label[i],"Energy");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_LAMBDA)
       strcpy(Short_Label[i],"Wavelength");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_NCOUNT)
       strcpy(Short_Label[i],"Neutron_ID");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_PIXELID)
       strcpy(Short_Label[i],"Pixel_ID");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_T)
          strcpy(Short_Label[i],"Time_Of_Flight");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_P)
          strcpy(Short_Label[i],"Intensity");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_USER1)
          strncpy(Short_Label[i],Vars->UserName1,30);
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_USER2)
          strncpy(Short_Label[i],Vars->UserName2,30);
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_USER3)
          strncpy(Short_Label[i],Vars->UserName3,30);
      else
          strcpy(Short_Label[i],"Unknown");

      if (Vars->Coord_Type[i] & DEFS->COORD_ABS)
      { strcat(Vars->Coord_Label[i]," (abs)"); }

      if (Vars->Coord_Type[i] & DEFS->COORD_LOG)
      { strcat(Vars->Coord_Label[i]," (log)"); }

      strcat(Vars->Monitor_Label, " ");
      strcat(Vars->Monitor_Label, Short_Label[i]);
      XY *= Vars->Coord_Bin[i];

    } /* end for Short_Label */

    if ((Vars->Coord_Type[0] & (DEFS->COORD_LOG-1)) == DEFS->COORD_P) {
      strncat(Vars->Coord_Label[0], " [n/s", 30);
      if (Vars->Flag_per_cm2) strncat(Vars->Coord_Label[0], "/cm2", 30);

      if (XY > 1 && Vars->Coord_Number)
        strncat(Vars->Coord_Label[0], "/bin", 30);
      strncat(Vars->Coord_Label[0], "]", 30);
    }

    /* update label 'signal per bin' if more than 1 bin */
    if (XY > 1 && Vars->Coord_Number) {
      if (Vars->Flag_capture)
        printf("Monitor_nD: %s: Using capture flux weightening on %ld bins.\n"
               "WARNING     Use binned data with caution, and prefer monitor integral value (I,Ierr).\n", Vars->compcurname, (long)XY);
    }

    strcat(Vars->Monitor_Label, " Monitor");
    if (Vars->Flag_Shape == DEFS->SHAPE_SQUARE) strcat(Vars->Monitor_Label, " (Square)");
    if (Vars->Flag_Shape == DEFS->SHAPE_DISK)   strcat(Vars->Monitor_Label, " (Disk)");
    if (Vars->Flag_Shape == DEFS->SHAPE_SPHERE) strcat(Vars->Monitor_Label, " (Sphere)");
    if (Vars->Flag_Shape == DEFS->SHAPE_CYLIND) strcat(Vars->Monitor_Label, " (Cylinder)");
    if (Vars->Flag_Shape == DEFS->SHAPE_BANANA) strcat(Vars->Monitor_Label, " (Banana)");
    if (Vars->Flag_Shape == DEFS->SHAPE_BOX)    strcat(Vars->Monitor_Label, " (Box)");
    if (Vars->Flag_Shape == DEFS->SHAPE_PREVIOUS) strcat(Vars->Monitor_Label, " (on PREVIOUS)");
    if (Vars->Flag_Shape == DEFS->SHAPE_OFF) strcat(Vars->Monitor_Label, " (OFF geometry)");
    if ((Vars->Flag_Shape == DEFS->SHAPE_CYLIND) || (Vars->Flag_Shape == DEFS->SHAPE_BANANA) || (Vars->Flag_Shape == DEFS->SHAPE_SPHERE) || (Vars->Flag_Shape == DEFS->SHAPE_BOX))
    {
      if (strstr(Vars->option, "incoming"))
      {
        Vars->Flag_Shape = abs(Vars->Flag_Shape);
        strcat(Vars->Monitor_Label, " [in]");
      }
      else /* if strstr(Vars->option, "outgoing")) */
      {
        Vars->Flag_Shape = -abs(Vars->Flag_Shape);
        strcat(Vars->Monitor_Label, " [out]");
      }
    }
    if (Vars->Flag_UsePreMonitor == 1)
    {
        strcat(Vars->Monitor_Label, " at ");
        strncat(Vars->Monitor_Label, Vars->UserName1,30);
    }
    if (Vars->Flag_log == 1) strcat(Vars->Monitor_Label, " [log] ");

    /* now allocate memory to store variables in TRACE */

    /* Vars->Coord_Number  0   : intensity or signal
     * Vars->Coord_Number  1:n : detector variables */

    if ((Vars->Coord_NumberNoPixel != 2) && !Vars->Flag_Multiple && !Vars->Flag_List)
    { Vars->Flag_Multiple = 1; /* default is n1D */
      if (Vars->Coord_Number != Vars->Coord_NumberNoPixel) Vars->Flag_List = 1; }

    /* list and auto limits case : Vars->Flag_List or Vars->Flag_Auto_Limits
     * -> Buffer to flush and suppress after Vars->Flag_Auto_Limits
     */
    if ((Vars->Flag_Auto_Limits || Vars->Flag_List) && Vars->Coord_Number)
    { /* Dim : (Vars->Coord_Number+1)*Vars->Buffer_Block matrix (for p, dp) */
      Vars->Mon2D_Buffer = (double *)malloc((Vars->Coord_Number+1)*Vars->Buffer_Block*sizeof(double));
      if (Vars->Mon2D_Buffer == NULL)
      { printf("Monitor_nD: %s cannot allocate Vars->Mon2D_Buffer (%li). No list and auto limits.\n", Vars->compcurname, Vars->Buffer_Block*(Vars->Coord_Number+1)*sizeof(double)); Vars->Flag_List = 0; Vars->Flag_Auto_Limits = 0; }
      else
      {
        for (i=0; i < (Vars->Coord_Number+1)*Vars->Buffer_Block; Vars->Mon2D_Buffer[i++] = (double)0);
      }
      Vars->Buffer_Size = Vars->Buffer_Block;
    }

    /* 1D and n1D case : Vars->Flag_Multiple */
    if (Vars->Flag_Multiple && Vars->Coord_NumberNoPixel)
    { /* Dim : Vars->Coord_Number*Vars->Coord_Bin[i] vectors */
      Vars->Mon2D_N  = (double **)malloc((Vars->Coord_Number)*sizeof(double *));
      Vars->Mon2D_p  = (double **)malloc((Vars->Coord_Number)*sizeof(double *));
      Vars->Mon2D_p2 = (double **)malloc((Vars->Coord_Number)*sizeof(double *));
      if ((Vars->Mon2D_N == NULL) || (Vars->Mon2D_p == NULL) || (Vars->Mon2D_p2 == NULL))
      { fprintf(stderr,"Monitor_nD: %s n1D cannot allocate Vars->Mon2D_N/p/p2 (%li). Fatal.\n", Vars->compcurname, (Vars->Coord_Number)*sizeof(double *)); exit(-1); }
      for (i= 1; i <= Vars->Coord_Number; i++)
      {
        Vars->Mon2D_N[i-1]  = (double *)malloc(Vars->Coord_Bin[i]*sizeof(double));
        Vars->Mon2D_p[i-1]  = (double *)malloc(Vars->Coord_Bin[i]*sizeof(double));
        Vars->Mon2D_p2[i-1] = (double *)malloc(Vars->Coord_Bin[i]*sizeof(double));
        if ((Vars->Mon2D_N == NULL) || (Vars->Mon2D_p == NULL) || (Vars->Mon2D_p2 == NULL))
        { fprintf(stderr,"Monitor_nD: %s n1D cannot allocate %s Vars->Mon2D_N/p/p2[%li] (%li). Fatal.\n", Vars->compcurname, Vars->Coord_Var[i], i, (Vars->Coord_Bin[i])*sizeof(double *)); exit(-1); }
        else
        {
          for (j=0; j < Vars->Coord_Bin[i]; j++ )
          { Vars->Mon2D_N[i-1][j] = (double)0; Vars->Mon2D_p[i-1][j] = (double)0; Vars->Mon2D_p2[i-1][j] = (double)0; }
        }
      }
    }
    else /* 2D case : Vars->Coord_Number==2 and !Vars->Flag_Multiple and !Vars->Flag_List */
    if ((Vars->Coord_NumberNoPixel == 2) && !Vars->Flag_Multiple)
    { /* Dim : Vars->Coord_Bin[1]*Vars->Coord_Bin[2] matrix */
      Vars->Mon2D_N  = (double **)malloc((Vars->Coord_Bin[1])*sizeof(double *));
      Vars->Mon2D_p  = (double **)malloc((Vars->Coord_Bin[1])*sizeof(double *));
      Vars->Mon2D_p2 = (double **)malloc((Vars->Coord_Bin[1])*sizeof(double *));
      if ((Vars->Mon2D_N == NULL) || (Vars->Mon2D_p == NULL) || (Vars->Mon2D_p2 == NULL))
      { fprintf(stderr,"Monitor_nD: %s 2D cannot allocate %s Vars->Mon2D_N/p/p2 (%li). Fatal.\n", Vars->compcurname, Vars->Coord_Var[1], (Vars->Coord_Bin[1])*sizeof(double *)); exit(-1); }
      for (i= 0; i < Vars->Coord_Bin[1]; i++)
      {
        Vars->Mon2D_N[i]  = (double *)malloc(Vars->Coord_Bin[2]*sizeof(double));
        Vars->Mon2D_p[i]  = (double *)malloc(Vars->Coord_Bin[2]*sizeof(double));
        Vars->Mon2D_p2[i] = (double *)malloc(Vars->Coord_Bin[2]*sizeof(double));
        if ((Vars->Mon2D_N == NULL) || (Vars->Mon2D_p == NULL) || (Vars->Mon2D_p2 == NULL))
        { fprintf(stderr,"Monitor_nD: %s 2D cannot allocate %s Vars->Mon2D_N/p/p2[%li] (%li). Fatal.\n", Vars->compcurname, Vars->Coord_Var[1], i, (Vars->Coord_Bin[2])*sizeof(double *)); exit(-1); }
        else
        {
          for (j=0; j < Vars->Coord_Bin[2]; j++ )
          { Vars->Mon2D_N[i][j] = (double)0; Vars->Mon2D_p[i][j] = (double)0; Vars->Mon2D_p2[i][j] = (double)0; }
        }
      }
    }
    else {
      Vars->Mon2D_N = Vars->Mon2D_p = Vars->Mon2D_p2 = NULL;
    }
      /* no Mon2D allocated for
       * (Vars->Coord_Number != 2) && !Vars->Flag_Multiple && Vars->Flag_List */

    Vars->psum  = 0;
    Vars->p2sum = 0;
    Vars->Nsum  = 0;

    Vars->area  = fabs(Vars->mxmax - Vars->mxmin)*fabs(Vars->mymax - Vars->mymin)*1E4; /* in cm**2 for square and box shapes */
    Vars->Sphere_Radius = fabs(Vars->mxmax - Vars->mxmin)/2;
    if ((abs(Vars->Flag_Shape) == DEFS->SHAPE_DISK) || (abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE))
    {
      Vars->area = PI*Vars->Sphere_Radius*Vars->Sphere_Radius*1E4; /* disk shapes */
    }


    if (Vars->area == 0 && abs(Vars->Flag_Shape) != DEFS->SHAPE_PREVIOUS ) {
      if (abs(Vars->Flag_Shape) != DEFS->SHAPE_OFF) {  
	Vars->Coord_Number = 0;
      }
    }
    if (Vars->Coord_Number == 0 && Vars->Flag_Verbose)
      printf("Monitor_nD: %s is unactivated (0D)\n", Vars->compcurname);
    Vars->Cylinder_Height = fabs(Vars->mymax - Vars->mymin);

    if (Vars->Flag_Verbose)
    {
      printf("Monitor_nD: %s is a %s.\n", Vars->compcurname, Vars->Monitor_Label);
      printf("Monitor_nD: version %s with options=%s\n", MONITOR_ND_LIB_H, Vars->option);
    }
    
    /* compute the product of bin dimensions for PixelID */
    Vars->Coord_BinProd[0]=1;
    for (i = 1; i <= Vars->Coord_Number; i++)
      Vars->Coord_BinProd[i]=Vars->Coord_Bin[i]*Vars->Coord_BinProd[i-1];
  } /* end Monitor_nD_Init */

/* ========================================================================= */
/* Monitor_nD_Trace: this routine is used to monitor one propagating neutron */
/* return values: 0=neutron was absorbed, -1=neutron was outside bounds, 1=neutron was measured*/
/* ========================================================================= */

int Monitor_nD_Trace(MonitornD_Defines_type *DEFS, MonitornD_Variables_type *Vars)
{

  double  XY=0, pp=0;
  int     retval;
  long    i =0, j =0;
  double  Coord[MONnD_COORD_NMAX];
  long    Coord_Index[MONnD_COORD_NMAX];
  char    While_End   =0;
  long    While_Buffer=0;
  char    Set_Vars_Coord_Type = DEFS->COORD_NONE;
  
  /* the logic below depends mainly on:
       Flag_List:        1=store 1 buffer, 2=list all, 3=re-use buffer 
       Flag_Auto_Limits: 0 (no auto limits/list), 1 (store events into Buffer), 2 (re-emit store events)
   */

  /* Vars->Flag_Auto_Limits=1: buffer full, we read the Buffer, and determine min and max bounds */
  if ((Vars->Buffer_Counter >= Vars->Buffer_Block) && (Vars->Flag_Auto_Limits == 1) && (Vars->Coord_Number > 0))
  {
    /* auto limits case : get limits in Buffer for each variable */
          /* Dim : (Vars->Coord_Number+1)*Vars->Buffer_Block matrix (for p, dp) */
    if (Vars->Flag_Verbose) printf("Monitor_nD: %s getting %li Auto Limits from List (%li events) in TRACE.\n", Vars->compcurname, Vars->Coord_Number, Vars->Buffer_Counter);
    for (i = 1; i <= Vars->Coord_Number; i++)
    {
      if (Vars->Coord_Type[i] & DEFS->COORD_AUTO)
      {
        Vars->Coord_Min[i] =  FLT_MAX;
        Vars->Coord_Max[i] = -FLT_MAX;
        for (j = 0; j < Vars->Buffer_Counter; j++)
        {
          XY = Vars->Mon2D_Buffer[i+j*(Vars->Coord_Number+1)];  /* scanning variables in Buffer */
          if (XY < Vars->Coord_Min[i]) Vars->Coord_Min[i] = XY;
          if (XY > Vars->Coord_Max[i]) Vars->Coord_Max[i] = XY;
        }
        if  (Vars->Flag_Verbose)  
          printf("  %s: min=%g max=%g\n", Vars->Coord_Var[i], Vars->Coord_Min[i], Vars->Coord_Max[i]);
      }
    }
    Vars->Flag_Auto_Limits = 2;  /* pass to 2nd auto limits step (read Buffer and generate new events to store in histograms) */
  } /* end if Flag_Auto_Limits == 1 */

  /* manage realloc for 'list all' if Buffer size exceeded: flush Buffer to file */
  if ((Vars->Buffer_Counter >= Vars->Buffer_Block) && (Vars->Flag_List >= 2))
  {
    if (Vars->Buffer_Size >= 1000000 || Vars->Flag_List == 3)
    { /* save current (possibly append) and re-use Buffer */
      Monitor_nD_Save(DEFS, Vars);
      Vars->Flag_List = 3;
      Vars->Buffer_Block = Vars->Buffer_Size;
      Vars->Buffer_Counter  = 0;
      Vars->Neutron_Counter = 0;
    }
    else
    {
      Vars->Mon2D_Buffer  = (double *)realloc(Vars->Mon2D_Buffer, (Vars->Coord_Number+1)*(Vars->Neutron_Counter+Vars->Buffer_Block)*sizeof(double));
      if (Vars->Mon2D_Buffer == NULL)
            { printf("Monitor_nD: %s cannot reallocate Vars->Mon2D_Buffer[%li] (%li). Skipping.\n", Vars->compcurname, i, (Vars->Neutron_Counter+Vars->Buffer_Block)*sizeof(double)); Vars->Flag_List = 1; }
      else { Vars->Buffer_Counter = 0; Vars->Buffer_Size = Vars->Neutron_Counter+Vars->Buffer_Block; }
    }
  } /* end if Buffer realloc */

  char    outsidebounds=0;
  while (!While_End)
  { /* we generate Coord[] and Coord_index[] from Buffer (auto limits) or passing neutron */
    if ((Vars->Flag_Auto_Limits == 2) && (Vars->Coord_Number > 0))
    { /* Vars->Flag_Auto_Limits == 2: read back from Buffer (Buffer is filled or auto limits have been computed) */
      if (While_Buffer < Vars->Buffer_Block)
      {
        /* first while loop (While_Buffer) */
        /* auto limits case : scan Buffer within limits and store in Mon2D */
        Coord[0] = pp = Vars->Mon2D_Buffer[While_Buffer*(Vars->Coord_Number+1)];

        for (i = 1; i <= Vars->Coord_Number; i++)
        {
          /* scanning variables in Buffer */
          if (Vars->Coord_Bin[i] <= 1) continue;
          XY = (Vars->Coord_Max[i]-Vars->Coord_Min[i]);

          Coord[i] = Vars->Mon2D_Buffer[i+While_Buffer*(Vars->Coord_Number+1)];
          if (XY > 0) Coord_Index[i] = floor((Coord[i]-Vars->Coord_Min[i])*Vars->Coord_Bin[i]/XY);
          else        Coord_Index[i] = 0;
          if (Vars->Flag_With_Borders)
          {
            if (Coord_Index[i] < 0)                   Coord_Index[i] = 0;
            if (Coord_Index[i] >= Vars->Coord_Bin[i]) Coord_Index[i] = Vars->Coord_Bin[i] - 1;
          }
        } /* end for */
        
        /* update the PixelID, we compute it from the previous variables index */
        if (Vars->Coord_NumberNoPixel < Vars->Coord_Number) /* there is a Pixel variable */
        for (i = 1; i <= Vars->Coord_Number; i++) {
          char Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
          if (Set_Vars_Coord_Type == DEFS->COORD_PIXELID) {
            char flag_outside=0;
            Coord_Index[i] = Coord[i] = 0;
            for (j= 1; j < i; j++) {
              /* not for 1D variables with Bin=1 such as PixelID, NCOUNT, Intensity */
              if (Vars->Coord_Bin[j] == 1) continue; 
              if (0 > Coord_Index[j] || Coord_Index[j] >= Vars->Coord_Bin[j]) {
                flag_outside=1;
                Coord[i] = 0;
                break;
              }
              Coord[i] += Coord_Index[j]*Vars->Coord_BinProd[j-1];
            }
            if (!flag_outside) {
              Vars->Mon2D_Buffer[i+While_Buffer*(Vars->Coord_Number+1)] = Coord[i];
            }
          } /* end if PixelID */
        }
        While_Buffer++;
      } /* end if in Buffer */
      else /* (While_Buffer >= Vars->Buffer_Block) && (Vars->Flag_Auto_Limits == 2) */
      {
        Vars->Flag_Auto_Limits = 0;
        if (!Vars->Flag_List) /* free Buffer not needed anymore (no list to output) */
        { /* Dim : (Vars->Coord_Number+1)*Vars->Buffer_Block matrix (for p, p2) */
          free(Vars->Mon2D_Buffer); Vars->Mon2D_Buffer = NULL;
        }
        if (Vars->Flag_Verbose) printf("Monitor_nD: %s flushed %li Auto Limits from List (%li) in TRACE.\n", Vars->compcurname, Vars->Coord_Number, Vars->Buffer_Counter);
      }
    } /* if Vars->Flag_Auto_Limits == 2 */
    
    if (Vars->Flag_Auto_Limits != 2 || !Vars->Coord_Number) /* Vars->Flag_Auto_Limits == 0 (no auto limits/list) or 1 (store events into Buffer) */
    {
      /* automatically compute area and steradian solid angle when in AUTO mode */
      /* compute the steradian solid angle incoming on the monitor */
      double v;
      v=sqrt(Vars->cvx*Vars->cvx
            +Vars->cvy*Vars->cvy
            +Vars->cvz*Vars->cvz);
      if (Vars->min_x > Vars->cx) Vars->min_x = Vars->cx;
      if (Vars->max_x < Vars->cx) Vars->max_x = Vars->cx;
      if (Vars->min_y > Vars->cy) Vars->min_y = Vars->cy;
      if (Vars->max_y < Vars->cy) Vars->max_y = Vars->cy;
      Vars->mean_p  += Vars->cp;
      if (v) {
        Vars->mean_dx += Vars->cp*fabs(Vars->cvx/v);
        Vars->mean_dy += Vars->cp*fabs(Vars->cvy/v);
      }

      for (i = 0; i <= Vars->Coord_Number; i++)
      { /* handle current neutron : last while */
        XY = 0;
        Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
        /* get values for variables to monitor */
        if (Set_Vars_Coord_Type == DEFS->COORD_X) XY = Vars->cx;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_Y) XY = Vars->cy;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_Z) XY = Vars->cz;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VX) XY = Vars->cvx;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VY) XY = Vars->cvy;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VZ) XY = Vars->cvz;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KX) XY = V2K*Vars->cvx;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KY) XY = V2K*Vars->cvy;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KZ) XY = V2K*Vars->cvz;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_SX) XY = Vars->csx;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_SY) XY = Vars->csy;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_SZ) XY = Vars->csz;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_T) XY = Vars->ct;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_P) XY = Vars->cp;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_HDIV) XY = RAD2DEG*atan2(Vars->cvx,Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VDIV) XY = RAD2DEG*atan2(Vars->cvy,Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_V) XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_RADIUS)
          XY = sqrt(Vars->cx*Vars->cx+Vars->cy*Vars->cy+Vars->cz*Vars->cz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_XY)
          XY = sqrt(Vars->cx*Vars->cx+Vars->cy*Vars->cy)*(Vars->cx > 0 ? 1 : -1);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_YZ) XY = sqrt(Vars->cy*Vars->cy+Vars->cz*Vars->cz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_XZ)
          XY = sqrt(Vars->cx*Vars->cx+Vars->cz*Vars->cz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VXY) XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VXZ) XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvz*Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VYZ) XY = sqrt(Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_K) { XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);  XY *= V2K; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KXY) { XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy);  XY *= V2K; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KXZ) { XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvz*Vars->cvz);  XY *= V2K; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KYZ) { XY = sqrt(Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);  XY *= V2K; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_ENERGY) { XY = Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz;  XY *= VS2E; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_LAMBDA) { XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);  XY *= V2K; if (XY != 0) XY = 2*PI/XY; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_NCOUNT) XY = Vars->Neutron_Counter;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_ANGLE)
        {  XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy);
           if (Vars->cvz != 0)
                XY = RAD2DEG*atan2(XY,Vars->cvz)*(Vars->cx > 0 ? 1 : -1);
           else XY = 0;
        }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_THETA)  { if (Vars->cz != 0) XY = RAD2DEG*atan2(Vars->cx,Vars->cz); }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_PHI) { if (Vars->cz != 0) XY = RAD2DEG*asin(Vars->cy/Vars->cz); }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_USER1) XY = Vars->UserVariable1;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_USER2) XY = Vars->UserVariable2;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_USER3) XY = Vars->UserVariable3;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_PIXELID && !Vars->Flag_Auto_Limits) {
          /* compute the PixelID from previous coordinates 
             the PixelID is the product of Coord_Index[i] in the detector geometry 
             pixelID = sum( Coord_Index[j]*prod(Vars->Coord_Bin[1:(j-1)]) )
             
             this does not apply when we store events in the buffer as Coord_Index
             is not set. Then the pixelID will be re-computed during SAVE.
          */
          char flag_outside=0;
          for (j= 1; j < i; j++) {
            /* not for 1D variables with Bin=1 such as PixelID, NCOUNT, Intensity */
            if (Vars->Coord_Bin[j] <= 1) continue; 
            if (0 > Coord_Index[j] || Coord_Index[j] >= Vars->Coord_Bin[j]) { 
              flag_outside=1; XY=0; break;
            }
            XY += Coord_Index[j]*Vars->Coord_BinProd[j-1];
          }
	  if (Vars->Flag_mantid && Vars->Flag_OFF && Vars->OFF_polyidx >=0) XY=Vars->OFF_polyidx;
          if (!flag_outside) XY += Vars->Coord_Min[i];
        }
        
        /* handle 'abs' and 'log' keywords */
        if (Vars->Coord_Type[i] & DEFS->COORD_ABS) XY=fabs(XY);

        if (Vars->Coord_Type[i] & DEFS->COORD_LOG) /* compute log of variable if requested */
        {  if (XY > 0) XY = log(XY)/log(10);
           else        XY = -100; }

        Coord[i] = XY; Coord_Index[i] = 0;
        if (i == 0) { pp = XY; Coord_Index[i] = 0; }
        else {
        /* check bounds for variables which have no automatic limits */
          if ((!Vars->Flag_Auto_Limits || !(Vars->Coord_Type[i] & DEFS->COORD_AUTO)) && Vars->Coord_Bin[i]>1)
          { /* compute index in histograms for each variable to monitor */
            XY = (Vars->Coord_Max[i]-Vars->Coord_Min[i]);
            if (XY > 0) Coord_Index[i] = floor((Coord[i]-Vars->Coord_Min[i])*Vars->Coord_Bin[i]/XY);
            if (Vars->Flag_With_Borders)
            {
              if (Coord_Index[i] >= Vars->Coord_Bin[i]) Coord_Index[i] = Vars->Coord_Bin[i] - 1;
              if (Coord_Index[i] < 0) Coord_Index[i] = 0;
            }
            //if (0 > Coord_Index[i] || Coord_Index[i] >= Vars->Coord_Bin[i])
            //  outsidebounds=1;
          } /* else will get Index later from Buffer when Flag_Auto_Limits == 2 */
        }
        
      } /* end for i */
      While_End = 1;
    }/* end else if Vars->Flag_Auto_Limits == 2 */
    
    /* ====================================================================== */
    /* store n1d/2d neutron from Buffer (Auto_Limits == 2) or current neutron in while */
    if (Vars->Flag_Auto_Limits != 1) /* not when storing auto limits Buffer */
    {
      /* apply per cm2 */
      if (Vars->Flag_per_cm2 && Vars->area != 0)
        pp /= Vars->area;

      /* 2D case : Vars->Coord_Number==2 and !Vars->Flag_Multiple and !Vars->Flag_List */
      if ( Vars->Coord_NumberNoPixel == 2 && !Vars->Flag_Multiple)
      { /* Dim : Vars->Coord_Bin[1]*Vars->Coord_Bin[2] matrix */
        
        i = Coord_Index[1];
        j = Coord_Index[2];
        if (i >= 0 && i < Vars->Coord_Bin[1] && j >= 0 && j < Vars->Coord_Bin[2])
        {
          if (Vars->Mon2D_N) { 
            Vars->Mon2D_N[i][j]++;
            Vars->Mon2D_p[i][j] += pp;
            Vars->Mon2D_p2[i][j] += pp*pp;
          }
        } else {
          outsidebounds=1; 
        }
      } else {
        /* 1D and n1D case : Vars->Flag_Multiple */
        /* Dim : Vars->Coord_Number*Vars->Coord_Bin[i] vectors (intensity is not included) */
          
        for (i= 1; i <= Vars->Coord_Number; i++) {
          j = Coord_Index[i];
          if (j >= 0 && j < Vars->Coord_Bin[i]) {
            if  (Vars->Flag_Multiple && Vars->Mon2D_N) {
              Vars->Mon2D_N[i-1][j]++;
              Vars->Mon2D_p[i-1][j]  += pp;
              Vars->Mon2D_p2[i-1][j] += pp*pp;
            }
          } else { 
            outsidebounds=1;
            break;
          }
        }
      }
    } /* end (Vars->Flag_Auto_Limits != 1) */
    
    if (Vars->Flag_Auto_Limits != 2 && !outsidebounds) /* not when reading auto limits Buffer */
    { /* now store Coord into Buffer (no index needed) if necessary (list or auto limits) */
      if ((Vars->Buffer_Counter < Vars->Buffer_Block) && ((Vars->Flag_List) || (Vars->Flag_Auto_Limits == 1)))
      {
          
        for (i = 0; i <= Vars->Coord_Number; i++)
        {
          Vars->Mon2D_Buffer[i + Vars->Neutron_Counter*(Vars->Coord_Number+1)] = Coord[i];
        }
        Vars->Buffer_Counter++;
        if (Vars->Flag_Verbose && (Vars->Buffer_Counter >= Vars->Buffer_Block) && (Vars->Flag_List == 1)) 
          printf("Monitor_nD: %s %li neutrons stored in List.\n", Vars->compcurname, Vars->Buffer_Counter);
      }
      Vars->Neutron_Counter++;
    } /* end (Vars->Flag_Auto_Limits != 2) */
    
  } /* end while */
  Vars->Nsum++;
  Vars->psum  += pp;
  Vars->p2sum += pp*pp;

  /*determine return value: 1:neutron was in bounds and measured, -1: outside bounds, 0: outside bounds, should be absorbed.*/
  if(outsidebounds){
      if(Vars->Flag_Absorb){
          return 0;
      }else{
          return -1;
      }
  }
  return 1;
} /* end Monitor_nD_Trace */

/* ========================================================================= */
/* Monitor_nD_Save: this routine is used to save data files                  */
/* ========================================================================= */

MCDETECTOR Monitor_nD_Save(MonitornD_Defines_type *DEFS, MonitornD_Variables_type *Vars)
  {
    char   *fname;
    long    i,j;
    double *p0m = NULL;
    double *p1m = NULL;
    double *p2m = NULL;
    char    Coord_X_Label[CHAR_BUF_LENGTH];
    double  min1d, max1d;
    double  min2d, max2d;
    long    bin1d, bin2d;
    char    While_End = 0;
    long    While_Buffer = 0;
    double  XY=0, pp=0;
    double  Coord[MONnD_COORD_NMAX];
    long    Coord_Index[MONnD_COORD_NMAX];
    char    label[CHAR_BUF_LENGTH];
    double  ratio;

    MCDETECTOR detector;

    ratio = 100.0*mcget_run_num()/mcget_ncount();
    if (Vars->Flag_Verbose && Vars->Flag_per_cm2) {
      printf("Monitor_nD: %s: active flat detector area is %g [cm^2], total area is %g [cm^2]\n",
        Vars->compcurname, (Vars->max_x-Vars->min_x)
                          *(Vars->max_y-Vars->min_y)*1E4, Vars->area);
      printf("Monitor_nD: %s: beam solid angle is %g [st] (%g x %g [deg^2])\n",
        Vars->compcurname,
        2*fabs(2*atan(Vars->mean_dx/Vars->mean_p)
         *sin(2*atan(Vars->mean_dy/Vars->mean_p)/2)),
        atan(Vars->mean_dx/Vars->mean_p)*RAD2DEG,
        atan(Vars->mean_dy/Vars->mean_p)*RAD2DEG);
    }

    /* check Buffer flush when end of simulation reached */
    if ((Vars->Buffer_Counter <= Vars->Buffer_Block) && Vars->Flag_Auto_Limits && Vars->Mon2D_Buffer && Vars->Buffer_Counter)
    {
      /* Get Auto Limits */
      if (Vars->Flag_Verbose) printf("Monitor_nD: %s getting %li Auto Limits from List (%li events).\n", Vars->compcurname, Vars->Coord_Number, Vars->Buffer_Counter);

      for (i = 1; i <= Vars->Coord_Number; i++)
      {
        if ((Vars->Coord_Type[i] & DEFS->COORD_AUTO) && Vars->Coord_Bin[i] > 1)
        {
          Vars->Coord_Min[i] = FLT_MAX;
          Vars->Coord_Max[i] = -FLT_MAX;
          for (j = 0; j < Vars->Buffer_Counter; j++)
          {
            XY = Vars->Mon2D_Buffer[i+j*(Vars->Coord_Number+1)];  /* scanning variables in Buffer */
            if (XY < Vars->Coord_Min[i]) Vars->Coord_Min[i] = XY;
            if (XY > Vars->Coord_Max[i]) Vars->Coord_Max[i] = XY;
          }
          if  (Vars->Flag_Verbose)  
            printf("  %s: min=%g max=%g in %li bins\n", Vars->Coord_Var[i], Vars->Coord_Min[i], Vars->Coord_Max[i], Vars->Coord_Bin[i]);
        }
      }
      Vars->Flag_Auto_Limits = 2;  /* pass to 2nd auto limits step */
      Vars->Buffer_Block = Vars->Buffer_Counter;

      while (!While_End)
      { /* we generate Coord[] and Coord_index[] from Buffer (auto limits) */
        /* simulation ended before Buffer was filled. Limits have to be computed, and stored events must be sent into histograms */
        
        if (While_Buffer < Vars->Buffer_Block)
        {
          /* first while loops (While_Buffer) */
          Coord[0] = Vars->Mon2D_Buffer[While_Buffer*(Vars->Coord_Number+1)];

          /* auto limits case : scan Buffer within limits and store in Mon2D */
          for (i = 1; i <= Vars->Coord_Number; i++)
          {
            /* scanning variables in Buffer */
            if (Vars->Coord_Bin[i] <= 1) Coord_Index[i] = 0;
            else {
              XY = (Vars->Coord_Max[i]-Vars->Coord_Min[i]);
              Coord[i] = Vars->Mon2D_Buffer[i+While_Buffer*(Vars->Coord_Number+1)];
              if (XY > 0) Coord_Index[i] = floor((Coord[i]-Vars->Coord_Min[i])*Vars->Coord_Bin[i]/XY);
              else Coord_Index[i] = 0;
              if (Vars->Flag_With_Borders)
              {
                if (Coord_Index[i] < 0) Coord_Index[i] = 0;
                if (Coord_Index[i] >= Vars->Coord_Bin[i]) Coord_Index[i] = Vars->Coord_Bin[i] - 1;
              }
            }
          } /* end for */

          /* update the PixelID, we compute it from the previous variables index */
          for (i = 1; i <= Vars->Coord_Number; i++) {
            char Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
            if (Set_Vars_Coord_Type == DEFS->COORD_PIXELID) {
              char outsidebounds=0;
              Coord_Index[i] = Coord[i] = 0;
              for (j= 1; j < i; j++) {
                /* not for 1D variables with Bin=1 such as PixelID, NCOUNT, Intensity */
                if (Vars->Coord_Bin[j] == 1) continue; 
                if (0 > Coord_Index[j] || Coord_Index[j] >= Vars->Coord_Bin[j]) {
                  outsidebounds=1;
                  Coord[i] = 0;
                  break;
                }
                Coord[i] += Coord_Index[j]*Vars->Coord_BinProd[j-1];
              }
              if (!outsidebounds) {
                Vars->Mon2D_Buffer[i+While_Buffer*(Vars->Coord_Number+1)] = Coord[i];
              }
            } /* end if PixelID */
          }
          While_Buffer++;
        } /* end if in Buffer */
        else /* (While_Buffer >= Vars->Buffer_Block) && (Vars->Flag_Auto_Limits == 2) */
        {
          Vars->Flag_Auto_Limits = 0;
          While_End = 1;
          if (Vars->Flag_Verbose) printf("Monitor_nD: %s flushed %li Auto Limits from List (%li).\n", Vars->compcurname, Vars->Coord_Number, Vars->Buffer_Counter);
        }

        /* store n1d/2d section from Buffer */

        pp = Coord[0];
        /* apply per cm2 or per st */
        if (Vars->Flag_per_cm2 && Vars->area      != 0)
          pp /= Vars->area;
        
        /* 2D case : Vars->Coord_Number==2 and !Vars->Flag_Multiple and !Vars->Flag_List */
        if (!Vars->Flag_Multiple && Vars->Coord_NumberNoPixel == 2)
        { /* Dim : Vars->Coord_Bin[1]*Vars->Coord_Bin[2] matrix */
          i = Coord_Index[1];
          j = Coord_Index[2];
          if (i >= 0 && i < Vars->Coord_Bin[1] && j >= 0 && j < Vars->Coord_Bin[2])
          {
            if (Vars->Mon2D_N) {
              Vars->Mon2D_N[i][j]++;
              Vars->Mon2D_p[i][j] += pp;
              Vars->Mon2D_p2[i][j] += pp*pp;
            }
          } else if (Vars->Flag_Absorb) pp=0;
        }
        else
        /* 1D and n1D case : Vars->Flag_Multiple */
        { /* Dim : Vars->Coord_Number*Vars->Coord_Bin[i] vectors (intensity is not included) */
          for (i= 1; i <= Vars->Coord_Number; i++)
          {
            j = Coord_Index[i];
            if (j >= 0 && j < Vars->Coord_Bin[i])
            {
              if (Vars->Flag_Multiple && Vars->Mon2D_N) {
                Vars->Mon2D_N[i-1][j]++;
                Vars->Mon2D_p[i-1][j] += pp;
                Vars->Mon2D_p2[i-1][j] += pp*pp;
              }
            } else if (Vars->Flag_Absorb) {
              pp=0; break;
            }
          }
        } /* end store 2D/1D */
        
      } /* end while */
    } /* end Force Get Limits */

    /* write output files (sent to file as p[i*n + j] vectors) */
    if (Vars->Coord_Number == 0)
    {
      double Nsum;
      double psum, p2sum;
      Nsum = Vars->Nsum;
      psum = Vars->psum;
      p2sum= Vars->p2sum;
      if (Vars->Flag_signal != DEFS->COORD_P && Nsum > 0)
      { psum /=Nsum; p2sum /= Nsum*Nsum; }
      /* DETECTOR_OUT_0D(Vars->Monitor_Label, Vars->Nsum, Vars->psum, Vars->p2sum); */
      detector = mcdetector_out_0D(Vars->Monitor_Label, Nsum, psum, p2sum, Vars->compcurname, Vars->compcurpos);
    }
    else
    if (strlen(Vars->Mon_File) > 0)
    {
      fname = (char*)malloc(strlen(Vars->Mon_File)+10*Vars->Coord_Number);
      if (Vars->Flag_List && Vars->Mon2D_Buffer) /* List: DETECTOR_OUT_2D */
      {
       
        if (Vars->Flag_List >= 2) Vars->Buffer_Size = Vars->Neutron_Counter;
        if (Vars->Buffer_Size >= Vars->Neutron_Counter)
          Vars->Buffer_Size = Vars->Neutron_Counter;
        strcpy(fname,Vars->Mon_File);
        if (strchr(Vars->Mon_File,'.') == NULL) strcat(fname, "_list");

        strcpy(Coord_X_Label,"");
        for (i= 0; i <= Vars->Coord_Number; i++)
        {
          strcat(Coord_X_Label, Vars->Coord_Var[i]);
          strcat(Coord_X_Label, " ");
          if (strchr(Vars->Mon_File,'.') == NULL)
          { strcat(fname, "."); strcat(fname, Vars->Coord_Var[i]); }
        }
        if (Vars->Flag_Verbose) printf("Monitor_nD: %s write monitor file %s List (%lix%li).\n", Vars->compcurname, fname,bin2d,bin1d);

        /* handle the type of list output */
        strcpy(label, Vars->Monitor_Label);
        
        detector = mcdetector_out_list(
              label, "List of neutron events", Coord_X_Label,
              -Vars->Buffer_Size, Vars->Coord_Number+1,
              Vars->Mon2D_Buffer,
              fname, Vars->compcurname, Vars->compcurpos);
      }
      if (Vars->Flag_Multiple) /* n1D: DETECTOR_OUT_1D */
      {
        for (i= 0; i < Vars->Coord_Number; i++)
        {

          strcpy(fname,Vars->Mon_File);
          if (strchr(Vars->Mon_File,'.') == NULL)
          { strcat(fname, "."); strcat(fname, Vars->Coord_Var[i+1]); }
          sprintf(Coord_X_Label, "%s monitor", Vars->Coord_Label[i+1]);
          strcpy(label, Coord_X_Label);
          if (Vars->Coord_Bin[i+1] > 0) { /* 1D monitor */
            if (Vars->Flag_Verbose) printf("Monitor_nD: %s write monitor file %s 1D (%li).\n", Vars->compcurname, fname, Vars->Coord_Bin[i+1]);
            min1d = Vars->Coord_Min[i+1];
            max1d = Vars->Coord_Max[i+1];
            if (min1d == max1d) max1d = min1d+1e-6;
            p1m = (double *)malloc(Vars->Coord_Bin[i+1]*sizeof(double));
            p2m = (double *)malloc(Vars->Coord_Bin[i+1]*sizeof(double));
            if (p2m == NULL) /* use Raw Buffer line output */
            {
              if (Vars->Flag_Verbose) printf("Monitor_nD: %s cannot allocate memory for output. Using raw data.\n", Vars->compcurname);
              if (p1m != NULL) free(p1m);
              detector = mcdetector_out_1D(
              label,
              Vars->Coord_Label[i+1],
              Vars->Coord_Label[0],
              Vars->Coord_Var[i+1],
              min1d, max1d,
              Vars->Coord_Bin[i+1],
              Vars->Mon2D_N[i],Vars->Mon2D_p[i],Vars->Mon2D_p2[i],
              fname, Vars->compcurname, Vars->compcurpos);
            } /* if (p2m == NULL) */
            else
            {
              if (Vars->Flag_log != 0)
              {
                XY = FLT_MAX;
                for (j=0; j < Vars->Coord_Bin[i+1]; j++) /* search min of signal */
                  if ((XY > Vars->Mon2D_p[i][j]) && (Vars->Mon2D_p[i][j] > 0)) XY = Vars->Mon2D_p[i][j];
                if (XY <= 0) XY = -log(FLT_MAX)/log(10); else XY = log(XY)/log(10)-1;
              } /* if */

              for (j=0; j < Vars->Coord_Bin[i+1]; j++)
              {
                p1m[j] = Vars->Mon2D_p[i][j];
                p2m[j] = Vars->Mon2D_p2[i][j];
                if (Vars->Flag_signal != DEFS->COORD_P && Vars->Mon2D_N[i][j] > 0)
                { /* normalize mean signal to the number of events */
                  p1m[j] /= Vars->Mon2D_N[i][j];
                  p2m[j] /= Vars->Mon2D_N[i][j]*Vars->Mon2D_N[i][j];
                }
                if (Vars->Flag_log != 0)
                {
                  if ((p1m[j] > 0) && (p2m[j] > 0))
                  {
                    p2m[j] /= p1m[j]*p1m[j];
                    p1m[j] = log(p1m[j])/log(10);
                  }
                  else
                  {
                    p1m[j] = XY;
                    p2m[j] = 0;
                  }
                }
              } /* for */
              detector = mcdetector_out_1D(
                label,
                Vars->Coord_Label[i+1],
                Vars->Coord_Label[0],
                Vars->Coord_Var[i+1],
                min1d, max1d,
                Vars->Coord_Bin[i+1],
                Vars->Mon2D_N[i],p1m,p2m,
                fname, Vars->compcurname, Vars->compcurpos);

            } /* else */
            /* comment out 'free memory' lines to avoid loosing arrays if
               'detector' structure is used by other instrument parts
            if (p1m != NULL) free(p1m); p1m=NULL;
            if (p2m != NULL) free(p2m); p2m=NULL;
            */
          } else { /* 0d monitor */
            detector = mcdetector_out_0D(label, Vars->Mon2D_p[i][0], Vars->Mon2D_p2[i][0], Vars->Mon2D_N[i][0], Vars->compcurname, Vars->compcurpos);
          }


        } /* for */
      } /* if 1D */
      else
      if (Vars->Coord_NumberNoPixel == 2)  /* 2D: DETECTOR_OUT_2D */
      {
        strcpy(fname,Vars->Mon_File);

        p0m = (double *)malloc(Vars->Coord_Bin[1]*Vars->Coord_Bin[2]*sizeof(double));
        p1m = (double *)malloc(Vars->Coord_Bin[1]*Vars->Coord_Bin[2]*sizeof(double));
        p2m = (double *)malloc(Vars->Coord_Bin[1]*Vars->Coord_Bin[2]*sizeof(double));
        if (p2m == NULL)
        {
          if (Vars->Flag_Verbose) printf("Monitor_nD: %s cannot allocate memory for 2D array (%li). Skipping.\n", Vars->compcurname, 3*Vars->Coord_Bin[1]*Vars->Coord_Bin[2]*sizeof(double));
          /* comment out 'free memory' lines to avoid loosing arrays if
               'detector' structure is used by other instrument parts
          if (p0m != NULL) free(p0m);
          if (p1m != NULL) free(p1m);
          */
        }
        else
        {
          if (Vars->Flag_log != 0)
          {
            XY = FLT_MAX;
            for (i= 0; i < Vars->Coord_Bin[1]; i++)
              for (j= 0; j < Vars->Coord_Bin[2]; j++) /* search min of signal */
                if ((XY > Vars->Mon2D_p[i][j]) && (Vars->Mon2D_p[i][j]>0)) XY = Vars->Mon2D_p[i][j];
            if (XY <= 0) XY = -log(FLT_MAX)/log(10); else XY = log(XY)/log(10)-1;
          }
          for (i= 0; i < Vars->Coord_Bin[1]; i++)
          {
            for (j= 0; j < Vars->Coord_Bin[2]; j++)
            {
              long index;
              index = j + i*Vars->Coord_Bin[2];
              p0m[index] = Vars->Mon2D_N[i][j];
              p1m[index] = Vars->Mon2D_p[i][j];
              p2m[index] = Vars->Mon2D_p2[i][j];
              if (Vars->Flag_signal != DEFS->COORD_P && p0m[index] > 0)
              {
                  p1m[index] /= p0m[index];
                  p2m[index] /= p0m[index]*p0m[index];
              }

              if (Vars->Flag_log != 0)
              {
                if ((p1m[index] > 0) && (p2m[index] > 0))
                {
                  p2m[index] /= (p1m[index]*p1m[index]);
                  p1m[index] = log(p1m[index])/log(10);

                }
                else
                {
                  p1m[index] = XY;
                  p2m[index] = 0;
                }
              }
            }
          }
          if (strchr(Vars->Mon_File,'.') == NULL)
          { strcat(fname, "."); strcat(fname, Vars->Coord_Var[1]);
              strcat(fname, "_"); strcat(fname, Vars->Coord_Var[2]); }
          if (Vars->Flag_Verbose) printf("Monitor_nD: %s write monitor file %s 2D (%lix%li).\n", Vars->compcurname, fname, Vars->Coord_Bin[1], Vars->Coord_Bin[2]);

          min1d = Vars->Coord_Min[1];
          max1d = Vars->Coord_Max[1];
          if (min1d == max1d) max1d = min1d+1e-6;
          min2d = Vars->Coord_Min[2];
          max2d = Vars->Coord_Max[2];
          if (min2d == max2d) max2d = min2d+1e-6;
          strcpy(label, Vars->Monitor_Label);
          if (Vars->Coord_Bin[1]*Vars->Coord_Bin[2] > 1
           && Vars->Flag_signal == DEFS->COORD_P)
            strcat(label, " per bin");

          detector = mcdetector_out_2D(
            label,
            Vars->Coord_Label[1],
            Vars->Coord_Label[2],
            min1d, max1d,
            min2d, max2d,
            Vars->Coord_Bin[1],
            Vars->Coord_Bin[2],
            p0m,p1m,p2m,
            fname, Vars->compcurname, Vars->compcurpos);

          /* comment out 'free memory' lines to avoid loosing arrays if
               'detector' structure is used by other instrument parts
          if (p0m != NULL) free(p0m);
          if (p1m != NULL) free(p1m);
          if (p2m != NULL) free(p2m);
          */
        }
      }
      free(fname);
    }
    return(detector);
  } /* end Monitor_nD_Save */

/* ========================================================================= */
/* Monitor_nD_Finally: this routine is used to free memory                   */
/* ========================================================================= */

void Monitor_nD_Finally(MonitornD_Defines_type *DEFS,
  MonitornD_Variables_type *Vars)
  {
    int i;

    /* Now Free memory Mon2D.. */
    if ((Vars->Flag_Auto_Limits || Vars->Flag_List) && Vars->Coord_Number)
    { /* Dim : (Vars->Coord_Number+1)*Vars->Buffer_Block matrix (for p, dp) */
      if (Vars->Mon2D_Buffer != NULL) free(Vars->Mon2D_Buffer);
    }

    /* 1D and n1D case : Vars->Flag_Multiple */
    if (Vars->Flag_Multiple && Vars->Coord_Number)
    { /* Dim : Vars->Coord_Number*Vars->Coord_Bin[i] vectors */
      for (i= 0; i < Vars->Coord_Number; i++)
      {
        free(Vars->Mon2D_N[i]);
        free(Vars->Mon2D_p[i]);
        free(Vars->Mon2D_p2[i]);
      }
      free(Vars->Mon2D_N);
      free(Vars->Mon2D_p);
      free(Vars->Mon2D_p2);
    }


    /* 2D case : Vars->Coord_Number==2 and !Vars->Flag_Multiple and !Vars->Flag_List */
    if ((Vars->Coord_NumberNoPixel == 2) && !Vars->Flag_Multiple)
    { /* Dim : Vars->Coord_Bin[1]*Vars->Coord_Bin[2] matrix */
      for (i= 0; i < Vars->Coord_Bin[1]; i++)
      {
        free(Vars->Mon2D_N[i]);
        free(Vars->Mon2D_p[i]);
        free(Vars->Mon2D_p2[i]);
      }
      free(Vars->Mon2D_N);
      free(Vars->Mon2D_p);
      free(Vars->Mon2D_p2);
    }
  } /* end Monitor_nD_Finally */

/* ========================================================================= */
/* Monitor_nD_McDisplay: this routine is used to display component           */
/* ========================================================================= */

void Monitor_nD_McDisplay(MonitornD_Defines_type *DEFS,
  MonitornD_Variables_type *Vars)
  {
    double radius, h;
    double xmin;
    double xmax;
    double ymin;
    double ymax;
    double zmin;
    double zmax;
    int    i;
    double hdiv_min=-180, hdiv_max=180, vdiv_min=-90, vdiv_max=90;
    char   restricted = 0;

    radius = Vars->Sphere_Radius;
    h = Vars->Cylinder_Height;
    xmin = Vars->mxmin;
    xmax = Vars->mxmax;
    ymin = Vars->mymin;
    ymax = Vars->mymax;
    zmin = Vars->mzmin;
    zmax = Vars->mzmax;

    /* determine if there are angular limits set at start (no auto) in coord_types
     * cylinder/banana: look for hdiv
     * sphere: look for angle, radius (->atan2(val,radius)), hdiv, vdiv
     * this activates a 'restricted' flag, to draw a region as blades on cylinder/sphere
     */
    for (i= 0; i <= Vars->Coord_Number; i++)
    {
      int Set_Vars_Coord_Type;
      Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
      if (Set_Vars_Coord_Type == DEFS->COORD_HDIV || Set_Vars_Coord_Type == DEFS->COORD_THETA)
      { hdiv_min = Vars->Coord_Min[i]; hdiv_max = Vars->Coord_Max[i]; restricted = 1; }
      else if (Set_Vars_Coord_Type == DEFS->COORD_VDIV || Set_Vars_Coord_Type == DEFS->COORD_PHI)
      { vdiv_min = Vars->Coord_Min[i]; vdiv_max = Vars->Coord_Max[i];restricted = 1;  }
      else if (Set_Vars_Coord_Type == DEFS->COORD_ANGLE)
      { hdiv_min = vdiv_min = Vars->Coord_Min[i];
        hdiv_max = vdiv_max = Vars->Coord_Max[i];
        restricted = 1; }
      else if (Set_Vars_Coord_Type == DEFS->COORD_RADIUS)
      { double angle;
        angle = RAD2DEG*atan2(Vars->Coord_Max[i], radius);
        hdiv_min = vdiv_min = angle;
        hdiv_max = vdiv_max = angle;
        restricted = 1; }
      else if (Set_Vars_Coord_Type == DEFS->COORD_Y && abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE)
      {
        vdiv_min = atan2(ymin,radius)*RAD2DEG;
        vdiv_max = atan2(ymax,radius)*RAD2DEG;
        restricted = 1;
      }
    }
    /* full sphere */
    if ((!restricted && (abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE))
    || abs(Vars->Flag_Shape) == DEFS->SHAPE_PREVIOUS)
    {
      mcdis_magnify("");
      mcdis_circle("xy",0,0,0,radius);
      mcdis_circle("xz",0,0,0,radius);
      mcdis_circle("yz",0,0,0,radius);
    }
    /* banana/cylinder/sphere portion */
    else
    if (restricted && ((abs(Vars->Flag_Shape) == DEFS->SHAPE_CYLIND)
                    || (abs(Vars->Flag_Shape) == DEFS->SHAPE_BANANA)
                    || (abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE)))
    {
      int NH=24, NV=24;
      int ih, iv;
      double width, height;
      int issphere;
      issphere = (abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE);
      width = (hdiv_max-hdiv_min)/NH;
      if (!issphere) NV=1; /* cylinder has vertical axis */
      else height= (vdiv_max-vdiv_min)/NV;
      
      /* check width and height of elements (sphere) to make sure the nb
         of plates remains limited */
      if (width < 10  && NH > 1) { width = 10;  NH=(hdiv_max-hdiv_min)/width; width=(hdiv_max-hdiv_min)/NH; }
      if (height < 10 && NV > 1) { height = 10; NV=(vdiv_max-vdiv_min)/height; height= (vdiv_max-vdiv_min)/NV; }
      
      mcdis_magnify("xyz");
      for(ih = 0; ih < NH; ih++)
        for(iv = 0; iv < NV; iv++)
        {
          double theta0, phi0, theta1, phi1;          /* angles in spherical coordinates */
          double x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3; /* vertices at plate edges */
          phi0 = (hdiv_min+ width*ih-90)*DEG2RAD;        /* in xz plane */
          phi1 = (hdiv_min+ width*(ih+1)-90)*DEG2RAD;
          if (issphere)
          {
            theta0= (vdiv_min+height* iv + 90)   *DEG2RAD; /* in vertical plane */
            theta1= (vdiv_min+height*(iv+1) + 90)*DEG2RAD;
            if (y0 < ymin) y0=ymin; 
            if (y0 > ymax) y0=ymax;
            if (y1 < ymin) y1=ymin; 
            if (y1 > ymax) y1=ymax;
            
            y0 = -radius*cos(theta0);            /* z with Z vertical */
            y1 = -radius*cos(theta1);
            if (y0 < ymin) y0=ymin;
            if (y0 > ymax) y0=ymax;
            if (y1 < ymin) y1=ymin;
            if (y1 > ymax) y1=ymax;
          } else {
            y0 = ymin;
            y1 = ymax;
            theta0=theta1=90*DEG2RAD;
          }

          x0 = radius*sin(theta0)*cos(phi0); /* x with Z vertical */
          z0 =-radius*sin(theta0)*sin(phi0); /* y with Z vertical */
          x1 = radius*sin(theta1)*cos(phi0); 
          z1 =-radius*sin(theta1)*sin(phi0);
          x2 = radius*sin(theta1)*cos(phi1); 
          z2 =-radius*sin(theta1)*sin(phi1);
          x3 = radius*sin(theta0)*cos(phi1); 
          z3 =-radius*sin(theta0)*sin(phi1);
          y2 = y1; y3 = y0;

          mcdis_multiline(5,
            x0,y0,z0,
            x1,y1,z1,
            x2,y2,z2,
            x3,y3,z3,
            x0,y0,z0);
        }
      if (Vars->Flag_mantid) {
	/* First define the base pixel type */
	double dt, dy;
	dt = (Vars->Coord_Max[1]-Vars->Coord_Min[1])/Vars->Coord_Bin[1];
	dy = (Vars->Coord_Max[2]-Vars->Coord_Min[2])/Vars->Coord_Bin[2];
	printf("MANTID_BANANA_DET:  %g, %g, %g, %g, %g, %li, %li, %g\n", radius, 
	       Vars->Coord_Min[1],Vars->Coord_Max[1], Vars->Coord_Min[2],Vars->Coord_Max[2], Vars->Coord_Bin[1], Vars->Coord_Bin[2], Vars->Coord_Min[4]); 
      }
    }
    /* disk (circle) */
    else
    if (abs(Vars->Flag_Shape) == DEFS->SHAPE_DISK)
    {
      mcdis_magnify("");
      mcdis_circle("xy",0,0,0,radius);
    }
    /* rectangle (square) */
    else
    if (abs(Vars->Flag_Shape) == DEFS->SHAPE_SQUARE)
    {
      mcdis_magnify("xy");
      mcdis_multiline(5, (double)xmin, (double)ymin, 0.0,
             (double)xmax, (double)ymin, 0.0,
             (double)xmax, (double)ymax, 0.0,
             (double)xmin, (double)ymax, 0.0,
             (double)xmin, (double)ymin, 0.0);
      
      if (Vars->Flag_mantid) {
	/* First define the base pixel type */
	double dx, dy;
	dx = (Vars->Coord_Max[1]-Vars->Coord_Min[1])/Vars->Coord_Bin[1];
	dy = (Vars->Coord_Max[2]-Vars->Coord_Min[2])/Vars->Coord_Bin[2];
	printf("MANTID_RECTANGULAR_DET:  %g, %g, %g, %g, %li, %li, %g\n", 
	       Vars->Coord_Min[1],Vars->Coord_Max[1], Vars->Coord_Min[2],Vars->Coord_Max[2], Vars->Coord_Bin[1], Vars->Coord_Bin[2], Vars->Coord_Min[4]);
      }
    }
    /* full cylinder/banana */
    else
    if (!restricted && ((abs(Vars->Flag_Shape) == DEFS->SHAPE_CYLIND) || (abs(Vars->Flag_Shape) == DEFS->SHAPE_BANANA)))
    {
      mcdis_magnify("xyz");
      mcdis_circle("xz", 0,  h/2.0, 0, radius);
      mcdis_circle("xz", 0, -h/2.0, 0, radius);
      mcdis_line(-radius, -h/2.0, 0, -radius, +h/2.0, 0);
      mcdis_line(+radius, -h/2.0, 0, +radius, +h/2.0, 0);
      mcdis_line(0, -h/2.0, -radius, 0, +h/2.0, -radius);
      mcdis_line(0, -h/2.0, +radius, 0, +h/2.0, +radius);
    }
    else
    /* box */
    if (abs(Vars->Flag_Shape) == DEFS->SHAPE_BOX)
    {
      mcdis_magnify("xyz");
      mcdis_multiline(5, xmin, ymin, zmin,
                   xmax, ymin, zmin,
                   xmax, ymax, zmin,
                   xmin, ymax, zmin,
                   xmin, ymin, zmin);
      mcdis_multiline(5, xmin, ymin, zmax,
                   xmax, ymin, zmax,
                   xmax, ymax, zmax,
                   xmin, ymax, zmax,
                   xmin, ymin, zmax);
      mcdis_line(xmin, ymin, zmin, xmin, ymin, zmax);
      mcdis_line(xmax, ymin, zmin, xmax, ymin, zmax);
      mcdis_line(xmin, ymax, zmin, xmin, ymax, zmax);
      mcdis_line(xmax, ymax, zmin, xmax, ymax, zmax);
    }
  } /* end Monitor_nD_McDisplay */

/* end of monitor_nd-lib.c */

#line 9827 "./ESS_BIFROST_shielding.c"

/* Shared user declarations for all components 'Shielding_logger_stop'. */
#line 38 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_logger_stop.comp"
#define SCATTER0\
    do {mcDEBUG_SCATTER(mcnlx, mcnly, mcnlz, mcnlvx, mcnlvy, mcnlvz, \
			mcnlt,mcnlsx,mcnlsy,mcnlsz, mcnlp); mcScattered++;} while(0)
#define ABSORB0\
    do {mcDEBUG_STATE(mcnlx, mcnly, mcnlz, mcnlvx, mcnlvy, mcnlvz, \
        mcnlt,mcnlsx,mcnlsy,mcnlsz, mcnlp); mcDEBUG_ABSORB(); MAGNET_OFF; goto mcabsorb;} while(0)
#line 9837 "./ESS_BIFROST_shielding.c"

/* Shared user declarations for all components 'Shielding_log_iterator_Ni_new'. */
#line 47 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_Ni_new.comp"
#ifndef M1THICKNESS
#define M1THICKNESS 1500.0 //thickness of the m=1 coating
#endif
  /*This is the specialized pseudo-neutron function that computes
    an escaping neutron from logged before and after SCATTER neutron states
  with weight corresponding to capture in the Nickel layers*/
  int exit_neutron_Ni(double *ns_tilde, struct Generalized_State_t *S0, struct Generalized_State_t *S1){
    /*!!Note that the transformation into global coordinate system must be done while logging
      as we do not have access to neither the component name nor can get the component rotation by index.*/
    Coords c1,c2;
    Rotation R1,R2;

    /*so now compute the pseudo neutron state and possibly user variables*/ 
    /*momentum transfer at reflection. ASSUMES NO GRAVITY???*/
    double velocity=sqrt((S1->_vx)*(S1->_vx)+(S1->_vy)*(S1->_vy)+(S1->_vz)*(S1->_vz));
    double qtransf = V2Q*sqrt((S1->_vx-S0->_vx)*(S1->_vx-S0->_vx)+(S1->_vy-S0->_vy)*(S1->_vy-S0->_vy)+(S1->_vz-S0->_vz)*(S1->_vz-S0->_vz));
    double qinm = qtransf/0.0218; 
    /*position comes from "new" state*/
    ns_tilde[0]=S1->_x;ns_tilde[1]=S1->_y;ns_tilde[2]=S1->_z;
    /*velocity is the "old" state*/
    ns_tilde[3]=S0->_vx;ns_tilde[4]=S0->_vy;ns_tilde[5]=S0->_vz;
    /*time from new*/
    ns_tilde[6]=S1->_t;
      /*spin comes from "new" state*/
    ns_tilde[7]=S1->_sx;ns_tilde[8]=S1->_sy;ns_tilde[9]=S1->_sz;
    /*weight of capture in Ni is determined analytically*/
   double captureprob; 
   	if ((S1->_mvalue<0)||(qinm<0.0001)) {ns_tilde[10]=0.0; captureprob=0.0;}
   else  if (qinm<=1.01){
   /*q<qc(Ni), loss due to diffusion beyond the coating cutoff*/
   /* captureprob = 4.0582E-09*2200.0/velocity/((0.085787L*18.5 + 0.008321L*5.7)*1.0E-08+4.0582E-09*2200.0/velocity)*(S0->_p-S1->_p)/S0->_p;	*/
	double sigmadif ;//diffuse scattering cross section
	if (velocity > 1950.0){ sigmadif = 18.5; //lambda < 2A, totally incoherent scattering
	 } else if (velocity < 1300.0){sigmadif = 5.2; // lambda >3A, totally coherent regime, only incoherent part contributes
	 } else sigmadif=5.2+13.3*(1950-velocity)/(1950.0-1300.0); 
     /*Now checking if the coating is m=1 or has higher m*/
     
     if(S1->_mvalue<1.05) /*m=1 coating=> "triple thickness approximation" with Im k determined for reflectivity dip*/
	{
	double imk; /*imaginary part of momentum in the layer*/
     imk=1.e-8*(sigmadif*0.09121+0.41*2200.0/velocity)*velocity/3956.0*M1THICKNESS; /*v(m/s)x\lambda(AA)=3956*/
	    captureprob = 4.49*2200.0/velocity/(sigmadif+4.49*2200.0/velocity)*(S0->_p-S1->_p)*(1-exp(-2.0*imk*M1THICKNESS*3.0))/S0->_p;
	} else { // reflection loss below qcNi in case of multilayer. 
	/*Taking the minimum of what is for m=1 coating and what is when assume that neutron is physically lost beyond the cutoff.*/
	double imk; /*imaginary part of momentum in the layer*/
         imk=1.e-8*(sigmadif*0.09121+0.41*2200.0/velocity)*velocity/3956.0*M1THICKNESS; /*v(m/s)x\lambda(AA)=3956*/
	double c1, c2;    
      c1 = 4.49*2200.0/velocity/(sigmadif+4.49*2200.0/velocity)*(S0->_p-S1->_p)*(1-exp(-2.0*imk*M1THICKNESS*3.0))/S0->_p;	
    	c2 = 0.005*(S1->_mvalue+0.1)*(S0->_p-S1->_p)/S0->_p; // for the matters of conservative estimate might be divided by 1-R at mvalue+0.1.
      captureprob = (c1>c2) ? c1 : c2 ;	      
        } 
 } //end of "if (qinm<=1.02)" 
   else if (qinm<=S1->_mvalue+0.1) { /*q>q_c(Ni) and reflection, absorption per hit */
   captureprob=0.005*qinm; 
    }  else { /* transmission beyond smirrorcutoff, some reserve for m=1 coating*/
     if(S1->_mvalue<1.05) captureprob=0.0025*1.3*1.3/qinm;
                  else captureprob=0.0025*(S1->_mvalue+0.1)*(S1->_mvalue+0.1)/qinm;}
     /*check change in weight*/
	if((S0->_p-S1->_p)>1.e-5*S0->_p)  ns_tilde[10]=S0->_p*captureprob; else ns_tilde[10]=0.0; 
	/* if "mvalue" is -1,  then absorption happened not on the coating but somewhere else. The weight of capture in nickel should be set to zero.*/

 if(ns_tilde[10]>(S0->_p-S1->_p)) { printf("%f\t%f\t%f\t%E\t%E\t%f\t%E\n",velocity, qinm, S1->_mvalue, S0->_p, S1->_p, captureprob, ns_tilde[10]); exit(0);}
    return 0;
  }

#define NOABS						     \
  do {/* Nothing*/} while(0)
  
#line 9909 "./ESS_BIFROST_shielding.c"

/* Shared user declarations for all components 'Monitor_nD'. */
#line 216 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"


/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2008, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/interoff.h
*
* %Identification
* Written by: Reynald Arnerin
* Date:    Jun 12, 2008
* Release: 
* Version: 
*
* Object File Format intersection header for McStas. Requires the qsort function.
*
* Such files may be obtained with e.g.
*   qhull < points.xyz Qx Qv Tv o > points.off
* where points.xyz has format:
*   3
*   <nb_points>
*   <x> <y> <z>
*   ...
* The resulting file should have its first line being changed from '3' into 'OFF'.
* It can then be displayed with geomview.
* A similar, but somewhat older solution is to use 'powercrust' with e.g.
*   powercrust -i points.xyz
* which will generate a 'pc.off' file to be renamed as suited.
*
*******************************************************************************/

#ifndef INTEROFF_LIB_H
#define INTEROFF_LIB_H "$Revision$"

#ifndef EPSILON
#define EPSILON 1e-13
#endif

#define OFF_INTERSECT_MAX 100

//#include <float.h>

#define N_VERTEX_DISPLAYED    200000

typedef struct intersection {
	MCNUM time;  	  //time of the intersection
	Coords v;	      //intersection point
	Coords normal;  //normal vector of the surface intersected
	short in_out;	  //1 if the ray enters the volume, -1 otherwise
	short edge;	    //1 if the intersection is on the boundary of the polygon, and error is possible
	unsigned long index; // index of the face
} intersection;

typedef struct polygon {
  MCNUM* p;       //vertices of the polygon in adjacent order, this way : x1 | y1 | z1 | x2 | y2 | z2 ...
  int npol;       //number of vertices
  Coords normal;
} polygon;

typedef struct off_struct {
    long vtxSize;
    long polySize;
    long faceSize;
    Coords* vtxArray;
    Coords* normalArray;
    unsigned long* faceArray;
    char *filename;
    int mantidflag;
    long mantidoffset;
    intersection intersects[OFF_INTERSECT_MAX]; // After a call to off_intersect_all contains the list of intersections.
    int nextintersect;                 // 'Next' intersection (first t>0) solution after call to off_intersect_all
    int numintersect;               // Number of intersections after call to off_intersect_all
} off_struct;

/*******************************************************************************
* long off_init(  char *offfile, double xwidth, double yheight, double zdepth, off_struct* data)
* ACTION: read an OFF file, optionally center object and rescale, initialize OFF data structure
* INPUT: 'offfile' OFF file to read
*        'xwidth,yheight,zdepth' if given as non-zero, apply bounding box. 
*           Specifying only one of these will also use the same ratio on all axes
*        'notcenter' center the object to the (0,0,0) position in local frame when set to zero
* RETURN: number of polyhedra and 'data' OFF structure 
*******************************************************************************/
long off_init(  char *offfile, double xwidth, double yheight, double zdepth, 
                int notcenter, off_struct* data);

/*******************************************************************************
* int off_intersect_all(double* t0, double* t3, 
     Coords *n0, Coords *n3,
     double x, double y, double z, 
     double vx, double vy, double vz, 
     off_struct *data )
* ACTION: computes intersection of neutron trajectory with an object. 
* INPUT:  x,y,z and vx,vy,vz are the position and velocity of the neutron
*         data points to the OFF data structure
* RETURN: the number of polyhedra which trajectory intersects
*         t0 and t3 are the smallest incoming and outgoing intersection times
*         n0 and n3 are the corresponding normal vectors to the surface
*         data is the full OFF structure, including a list intersection type
*******************************************************************************/
int off_intersect_all(double* t0, double* t3, 
     Coords *n0, Coords *n3,
     double x, double y, double z, 
     double vx, double vy, double vz, 
     off_struct *data );

/*******************************************************************************
* int off_intersect(double* t0, double* t3, 
     Coords *n0, Coords *n3,
     double x, double y, double z, 
     double vx, double vy, double vz, 
     off_struct data )
* ACTION: computes intersection of neutron trajectory with an object. 
* INPUT:  x,y,z and vx,vy,vz are the position and velocity of the neutron
*         data points to the OFF data structure
* RETURN: the number of polyhedra which trajectory intersects
*         t0 and t3 are the smallest incoming and outgoing intersection times
*         n0 and n3 are the corresponding normal vectors to the surface
*******************************************************************************/
int off_intersect(double* t0, double* t3, 
     Coords *n0, Coords *n3,
     double x, double y, double z, 
     double vx, double vy, double vz, 
     off_struct data );

/*****************************************************************************
* int off_intersectx(double* l0, double* l3, 
     Coords *n0, Coords *n3,
     double x, double y, double z, 
     double kx, double ky, double kz, 
     off_struct data )
* ACTION: computes intersection of an xray trajectory with an object.
* INPUT:  x,y,z and kx,ky,kz, are spatial coordinates and wavevector of the x-ray
*         respectively. data points to the OFF data structure.
* RETURN: the number of polyhedra the trajectory intersects
*         l0 and l3 are the smallest incoming and outgoing intersection lengths
*         n0 and n3 are the corresponding normal vectors to the surface
*******************************************************************************/
int off_x_intersect(double *l0,double *l3,
     Coords *n0, Coords *n3,
     double x,  double y,  double z, 
     double kx, double ky, double kz, 
     off_struct data );

/*******************************************************************************
* void off_display(off_struct data)
* ACTION: display up to N_VERTEX_DISPLAYED points from the object
*******************************************************************************/
void off_display(off_struct);

#endif

/* end of interoff-lib.h */
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2008, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/interoff-lib.c
*
* %Identification
* Written by: Reynald Arnerin
* Date:    Jun 12, 2008
* Origin: ILL
* Release: $Revision$
* Version: McStas X.Y
*
* Object File Format intersection library for McStas. Requires the qsort function.
*
* Such files may be obtained with e.g.
*   qhull < points.xyz Qx Qv Tv o > points.off
* where points.xyz has format (it supports comments):
*   3
*   <nb_points>
*   <x> <y> <z>
*   ...
* The resulting file should have its first line being changed from '3' into 'OFF'.
* It can then be displayed with geomview.
* A similar, but somewhat older solution is to use 'powercrust' with e.g.
*   powercrust -i points.xyz
* which will generate a 'pc.off' file to be renamed as suited.
*
*******************************************************************************/

#ifndef INTEROFF_LIB_H
#include "interoff-lib.h"
#endif

double off_F(double x, double y,double z,double A,double B,double C,double D) {
  return ( A*x + B*y + C*z + D );
}

char off_sign(double a) {
  if (a<0)       return(-1);
  else if (a==0) return(0);
  else           return(1);
}

// off_normal ******************************************************************
//gives the normal vector of p
void off_normal(Coords* n, polygon p)
{
  //using Newell method
  int i=0,j=0;
  n->x=0;n->y=0;n->z=0;
  for (i = 0, j = p.npol-1; i < p.npol; j = i++)
  {
    MCNUM x1=p.p[3*i],
          y1=p.p[3*i+1],
          z1=p.p[3*i+2];
    MCNUM x2=p.p[3*j],
          y2=p.p[3*j+1],
          z2=p.p[3*j+2];
    // n is the cross product of v1*v2
    n->x += (y1 - y2) * (z1 + z2);
    n->y += (z1 - z2) * (x1 + x2);
    n->z += (x1 - x2) * (y1 + y2);
  }
} /* off_normal */

// off_pnpoly ******************************************************************
//based on http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
//return 0 if the vertex is out
//    1 if it is in
//   -1 if on the boundary
int off_pnpoly(polygon p, Coords v)
{
  int i=0, c = 0;
  MCNUM minx=FLT_MAX,maxx=-FLT_MAX,miny=FLT_MAX,maxy=-FLT_MAX,minz=FLT_MAX,maxz=-FLT_MAX;
  MCNUM rangex=0,rangey=0,rangez=0;

  int pol2dx=0,pol2dy=1;          //2d restriction of the poly
  MCNUM x=v.x,y=v.y;


  //take the most relevant 2D projection (prevent from instability)
  for (i=0; i<p.npol; ++i)
  {
    if (p.p[3*i]<minx)   minx=p.p[3*i];
    if (p.p[3*i]>maxx)   maxx=p.p[3*i];
    if (p.p[3*i+1]<miny) miny=p.p[3*i+1];
    if (p.p[3*i+1]>maxy) maxy=p.p[3*i+1];
    if (p.p[3*i+2]<minz) minz=p.p[3*i+2];
    if (p.p[3*i+2]>maxz) maxz=p.p[3*i+2];
  }
  rangex=maxx-minx;
  rangey=maxy-miny;
  rangez=maxz-minz;

  if (rangex<rangez)
  {
    if (rangex<rangey) {
      pol2dx=2;
      x=v.z;
    } else {
      pol2dy=2;
      y=v.z;
    }
  }
  else if (rangey<rangez) {
    pol2dy=2;
    y=v.z;
  }

  //trace rays and test number of intersection
  int j;
  for (i = 0, j = p.npol-1; i < p.npol; j = i++) {
    if (((((p.p[3*i+pol2dy])<=y) && (y<(p.p[3*j+pol2dy]))) ||
         (((p.p[3*j+pol2dy])<=y) && (y<(p.p[3*i+pol2dy])))) &&
        (x < ( (p.p[3*j+pol2dx] - p.p[3*i+pol2dx]) * (y - p.p[3*i+pol2dy])
             / (p.p[3*j+pol2dy] - p.p[3*i+pol2dy]) + p.p[3*i+pol2dx]) ))
      c = !c;

    if (((fabs(p.p[3*i+pol2dy]-y)<=EPSILON) || ((fabs(p.p[3*j+pol2dy]-y)<=EPSILON))) &&
        fabs(x -((p.p[3*j+pol2dx] - p.p[3*i+pol2dx]) * (y - p.p[3*i+pol2dy])
          / (p.p[3*j+pol2dy] - p.p[3*i+pol2dy]) + p.p[3*i+pol2dx])) < EPSILON)
    {
      //the point lies on the edge
      c=-1;
      break;
    }
  }

  return c;
} /* off_pnpoly */

// off_intersectPoly ***********************************************************
//gives the intersection vertex between ray [a,b) and polygon p and its parametric value on (a b)
//based on http://geometryalgorithms.com/Archive/algorithm_0105/algorithm_0105.htm
int off_intersectPoly(intersection *inter, Coords a, Coords b, polygon p)
{
  //direction vector of [a,b]
  Coords dir = {b.x-a.x, b.y-a.y, b.z-a.z};

  //the normal vector to the polygon
  Coords normale=p.normal;
  //off_normal(&normale, p); done at the init stage

  //direction vector from a to a vertex of the polygon
  Coords w0 = {a.x-p.p[0], a.y-p.p[1], a.z-p.p[2]};

  //scalar product
  MCNUM nw0  =-scalar_prod(normale.x,normale.y,normale.z,w0.x,w0.y,w0.z);
  MCNUM ndir = scalar_prod(normale.x,normale.y,normale.z,dir.x,dir.y,dir.z);
  inter->time = inter->edge = inter->in_out=0;
  inter->v = inter->normal = coords_set(0,0,1);

  if (fabs(ndir) < EPSILON)    // ray is parallel to polygon plane
  {
    if (nw0 == 0)              // ray lies in polygon plane (infinite number of solution)
      return 0;
    else return 0;             // ray disjoint from plane (no solution)
  }

  // get intersect point of ray with polygon plane
  inter->time = nw0 / ndir;            //parametric value the point on line (a,b)

  inter->v = coords_set(a.x + inter->time * dir.x,// intersect point of ray and plane
    a.y + inter->time * dir.y,
    a.z + inter->time * dir.z);

  int res=off_pnpoly(p,inter->v);

  inter->edge=(res==-1);
  if (ndir<0)
    inter->in_out=1;  //the negative dot product means we enter the surface
  else
    inter->in_out=-1;

  inter->normal=p.normal;

  return res;         //true if the intersection point lies inside the poly
} /* off_intersectPoly */


// off_getBlocksIndex **********************************************************
/*reads the indexes at the beginning of the off file as this :
line 1  OFF
line 2  nbVertex nbFaces nbEdges
*/
FILE *off_getBlocksIndex(char* filename, long* vtxSize, long* polySize )
{
  FILE* f = Open_File(filename,"r", NULL); /* from read_table-lib: FILE *Open_File(char *name, char *Mode, char *path) */
  if (!f) return (f);
  
  char line[CHAR_BUF_LENGTH];
  char *ret=0;
  *vtxSize = *polySize = 0;

  /* **************** start to read the file header */
  /* OFF file:
     'OFF' or '3'
   */

  ret=fgets(line,CHAR_BUF_LENGTH , f);// line 1 = "OFF"
  if (ret == NULL)
  {
    fprintf(stderr, "Error: Can not read 1st line in file %s (interoff/off_getBlocksIndex)\n", filename);
    exit(1);
  }
  if (strlen(line)>5)
  {
      fprintf(stderr,"Error: First line in %s is too long (=%lu). Possibly the line is not terminated by '\\n'.\n" 
              "       The first line is required to be exactly 'OFF', '3' or 'ply'.\n",filename,strlen(line));
      fclose(f);
      return(NULL);
  }

  if (strncmp(line,"OFF",3) && strncmp(line,"3",1) && strncmp(line,"ply",1))
  {
    fprintf(stderr, "Error: %s is probably not an OFF, NOFF or PLY file (interoff/off_getBlocksIndex).\n"
                    "       Requires first line to be 'OFF', '3' or 'ply'.\n",filename);
    fclose(f);
    return(NULL);
  }

  if (!strncmp(line,"OFF",3) || !strncmp(line,"3",1)) {
    do  /* OFF file: skip # comments which may be there */
    {
      ret=fgets(line,CHAR_BUF_LENGTH , f);
      if (ret == NULL)
      {
        fprintf(stderr, "Error: Can not read line in file %s (interoff/off_getBlocksIndex)\n", filename);
        exit(1);
      }
    } while (line[0]=='#');
    //line = nblines of vertex,faces and edges arrays
    sscanf(line,"%lu %lu",vtxSize,polySize);
  } else {
    do  /* PLY file: read all lines until find 'end_header'
           and locate 'element faces' and 'element vertex' */
    {
      ret=fgets(line,CHAR_BUF_LENGTH , f);
      if (ret == NULL)
      {
        fprintf(stderr, "Error: Can not read line in file %s (interoff/off_getBlocksIndex)\n", filename);
        exit(1);
      }
      if (!strncmp(line,"element face",12))
        sscanf(line,"element face %lu",polySize);
      else if (!strncmp(line,"element vertex",14))
        sscanf(line,"element vertex %lu",vtxSize);
      else if (!strncmp(line,"format binary",13))
        exit(fprintf(stderr,
          "Error: Can not read binary PLY file %s, only 'format ascii' (interoff/off_getBlocksIndex)\n%s\n",
          filename, line));
    } while (strncmp(line,"end_header",10));
  }
  
  /* The FILE is left opened ready to read 'vtxSize' vertices (vtxSize *3 numbers)
     and then polySize polygons (rows) */

  return(f);
} /* off_getBlocksIndex */

// off_init_planes *************************************************************
//gives the equations of 2 perpandicular planes of [ab]
void off_init_planes(Coords a, Coords b,
  MCNUM* A1, MCNUM* C1, MCNUM* D1, MCNUM *A2, MCNUM* B2, MCNUM* C2, MCNUM* D2)
{
  //direction vector of [a b]
  Coords dir={b.x-a.x, b.y-a.y, b.z-a.z};

  //the plane parallel to the 'y' is computed with the normal vector of the projection of [ab] on plane 'xz'
  *A1= dir.z;
  *C1=-dir.x;
  if(*A1!=0 || *C1!=0)
    *D1=-(a.x)*(*A1)-(a.z)*(*C1);
  else
  {
    //the plane does not support the vector, take the one parallel to 'z''
    *A1=1;
    //B1=dir.x=0
    *D1=-(a.x);
  }
  //the plane parallel to the 'x' is computed with the normal vector of the projection of [ab] on plane 'yz'
  *B2= dir.z;
  *C2=-dir.y;
  *A2= 0;
  if (*B2==0 && *C2==0)
  {
    //the plane does not support the vector, take the one parallel to 'z'
    *B2=1;
    //B1=dir.x=0
    *D2=-(a.y);
  }
  else {
    if (dir.z==0)
    {
      //the planes are the same, take the one parallel to 'z'
      *A2= dir.y;
      *B2=-dir.x;
      *D2=-(a.x)*(*A2)-(a.y)*(*B2);
    }
    else
      *D2=-(a.y)**B2-(a.z)**C2;
  }
} /* off_init_planes */

// off_clip_3D_mod *************************************************************
int off_clip_3D_mod(intersection* t, Coords a, Coords b,
  Coords* vtxArray, unsigned long vtxSize, unsigned long* faceArray,
  unsigned long faceSize, Coords* normalArray)
{
  MCNUM A1=0, C1=0, D1=0, A2=0, B2=0, C2=0, D2=0;      //perpendicular plane equations to [a,b]
  off_init_planes(a, b, &A1, &C1, &D1, &A2, &B2, &C2, &D2);

  int t_size=0;
  //unsigned long vtxSize=vtxTable.rows, faceSize=faceTable.columns;  //Size of the corresponding tables
  char sg[vtxSize];  //array telling if vertex is left or right of the plane
  MCNUM popol[3*CHAR_BUF_LENGTH];
  unsigned long i=0,indPoly=0;
  for (i=0; i < vtxSize; ++i)
  {
    sg[i]=off_sign(off_F(vtxArray[i].x,vtxArray[i].y,vtxArray[i].z,A1,0,C1,D1));
  }

  //exploring the polygons :
  i=indPoly=0;
  while (i<faceSize)
  {
    polygon pol;
    pol.npol  = faceArray[i];                //nb vertex of polygon
    pol.p     = popol;
    pol.normal= coords_set(0,0,1);
    unsigned long indVertP1=faceArray[++i];  //polygon's first vertex index in vtxTable
    int j=1;
    while (j<pol.npol)
    {
      //polygon's j-th vertex index in vtxTable
      if (sg[indVertP1]!=sg[faceArray[i+j]]) //if the plane intersect the polygon
        break;

      ++j;
    }

    if (j<pol.npol)          //ok, let's test with the second plane
    {
      char sg1=off_sign(off_F(vtxArray[indVertP1].x,vtxArray[indVertP1].y,vtxArray[indVertP1].z,A2,B2,C2,D2));//tells if vertex is left or right of the plane

      j=1;
      while (j<pol.npol)
      {
        //unsigned long indVertPi=faceArray[i+j];  //polyg's j-th vertex index in vtxTable
        Coords vertPi=vtxArray[faceArray[i+j]];
        if (sg1!=off_sign(off_F(vertPi.x,vertPi.y,vertPi.z,A2,B2,C2,D2)))//if the plane intersect the polygon
          break;
        ++j;
      }
      if (j<pol.npol)
      {
        if (t_size>CHAR_BUF_LENGTH)
        {
          fprintf(stderr, "Warning: number of intersection exceeded (%d) (interoff-lib/off_clip_3D_mod)\n", CHAR_BUF_LENGTH);
            return (t_size);
        }
        //both planes intersect the polygon, let's find the intersection point
        //our polygon :
        int k;
        for (k=0; k<pol.npol; ++k)
        {
          Coords vertPk=vtxArray[faceArray[i+k]];
          pol.p[3*k]  =vertPk.x;
          pol.p[3*k+1]=vertPk.y;
          pol.p[3*k+2]=vertPk.z;
        }
        pol.normal=normalArray[indPoly];
        intersection x;
        if (off_intersectPoly(&x, a, b, pol))
        {
          x.index = indPoly;
          t[t_size++]=x;
        }
      } /* if (j<pol.npol) */
    } /* if (j<pol.npol) */
    i += pol.npol;
    indPoly++;
  } /* while i<faceSize */
  return t_size;
} /* off_clip_3D_mod */


// off_compare *****************************************************************
int off_compare (void const *a, void const *b)
{
   intersection const *pa = a;
   intersection const *pb = b;

   return off_sign(pa->time - pb->time);
} /* off_compare */

// off_cleanDouble *************************************************************
//given an array of intersections throw those which appear several times
//returns 1 if there is a possibility of error
int off_cleanDouble(intersection* t, int* t_size)
{
  int i=1;
  intersection prev=t[0];
  while (i<*t_size)
  {
    int j=i;
    //for each intersection with the same time
    while (j<*t_size && fabs(prev.time-t[j].time)<EPSILON)
    {
      //if the intersection is the exact same erase it
      if (prev.in_out==t[j].in_out)
      {
        int k;
        for (k=j+1; k<*t_size; ++k)
        {
          t[k-1]=t[k];
        }
        *t_size-=1;
      }
      else
        ++j;
    }
    prev=t[i];
    ++i;

  }
  return 1;
} /* off_cleanDouble */

// off_cleanInOut **************************************************************
//given an array of intesections throw those which enter and exit in the same time
//Meaning the ray passes very close to the volume
//returns 1 if there is a possibility of error
int off_cleanInOut(intersection* t, int* t_size)
{
  int i=1;
  intersection prev=t[0];
  while (i<*t_size)
  {
    //if two intersection have the same time but one enters and the other exits erase both
    //(such intersections must be adjacent in the array : run off_cleanDouble before)
    if (fabs(prev.time-t[i].time)<EPSILON && prev.in_out!=t[i].in_out)
    {
      int j=0;
      for (j=i+1; j<*t_size; ++j)
      {
        t[j-2]=t[j];
      }
      *t_size-=2;
      prev=t[i-1];
    }
    else
    {
      prev=t[i];
      ++i;
    }
  }
  return (*t_size);
} /* off_cleanInOut */

/* PUBLIC functions ******************************************************** */

/*******************************************************************************
* long off_init(  char *offfile, double xwidth, double yheight, double zdepth, off_struct* data)
* ACTION: read an OFF file, optionally center object and rescale, initialize OFF data structure
* INPUT: 'offfile' OFF file to read
*        'xwidth,yheight,zdepth' if given as non-zero, apply bounding box.
*           Specifying only one of these will also use the same ratio on all axes
*        'notcenter' center the object to the (0,0,0) position in local frame when set to zero
* RETURN: number of polyhedra and 'data' OFF structure
*******************************************************************************/
long off_init(  char *offfile, double xwidth, double yheight, double zdepth,
                int notcenter, off_struct* data)
{
  // data to be initialized
  long    vtxSize =0, polySize=0, i=0, ret=0, faceSize=0;
  Coords* vtxArray        =NULL;
  Coords* normalArray     =NULL;
  unsigned long* faceArray=NULL;
  FILE*   f               =NULL; /* the FILE with vertices and polygons */
  double minx=FLT_MAX,maxx=-FLT_MAX,miny=FLT_MAX,maxy=-FLT_MAX,minz=FLT_MAX,maxz=-FLT_MAX;

  // get the indexes
  if (!data) return(0);
  
  MPI_MASTER(
  printf("Loading geometry file (OFF/PLY): %s\n", offfile);
  );
  
  f=off_getBlocksIndex(offfile,&vtxSize,&polySize);
  if (!f) return(0);
  
  // read vertex table = [x y z | x y z | ...] =================================
  // now we read the vertices as 'vtxSize*3' numbers and store it in vtxArray 
  MPI_MASTER(
  printf("  Number of vertices: %ld\n", vtxSize);
  );
  vtxArray   = malloc(vtxSize*sizeof(Coords));
  if (!vtxArray) return(0);
  i=0;
  while (i<vtxSize && ~feof(f))
  {
    double x,y,z;
    ret=fscanf(f, "%lg%lg%lg", &x,&y,&z);
    if (!ret) { 
      // invalid line: we skip it (probably a comment)
      char line[CHAR_BUF_LENGTH];
      fgets(line, CHAR_BUF_LENGTH, f);
      continue; 
    }
    if (ret != 3) {
      fprintf(stderr, "Error: can not read [xyz] coordinates for vertex %ld in file %s (interoff/off_init). Read %ld values.\n", 
        i, offfile, ret);
      exit(2);
    }
    vtxArray[i].x=x;
    vtxArray[i].y=y;
    vtxArray[i].z=z;

    //bounding box
    if (vtxArray[i].x<minx) minx=vtxArray[i].x;
    if (vtxArray[i].x>maxx) maxx=vtxArray[i].x;
    if (vtxArray[i].y<miny) miny=vtxArray[i].y;
    if (vtxArray[i].y>maxy) maxy=vtxArray[i].y;
    if (vtxArray[i].z<minz) minz=vtxArray[i].z;
    if (vtxArray[i].z>maxz) maxz=vtxArray[i].z;
    i++; // inquire next vertex
  }

  // resizing and repositioning params
  double centerx=0, centery=0, centerz=0;
  if (!notcenter) {
    centerx=(minx+maxx)*0.5;
    centery=(miny+maxy)*0.5;
    centerz=(minz+maxz)*0.5;
  }

  double rangex=-minx+maxx,
         rangey=-miny+maxy,
         rangez=-minz+maxz;

  double ratiox=1,ratioy=1,ratioz=1;

  if (xwidth && rangex)
  {
    ratiox=xwidth/rangex;
    ratioy=ratiox;
    ratioz=ratiox;
  }

  if (yheight && rangey)
  {
    ratioy=yheight/rangey;
    if(!xwidth)  ratiox=ratioy;
    ratioz=ratioy;
  }

  if (zdepth && rangez)
  {
    ratioz=zdepth/rangez;
    if(!xwidth)  ratiox=ratioz;
    if(!yheight) ratioy=ratioz;
  }

  rangex *= ratiox;
  rangey *= ratioy;
  rangez *= ratioz;

  //center and resize the object
  for (i=0; i<vtxSize; ++i)
  {
    vtxArray[i].x=(vtxArray[i].x-centerx)*ratiox+(!notcenter ? 0 : centerx);
    vtxArray[i].y=(vtxArray[i].y-centery)*ratioy+(!notcenter ? 0 : centery);
    vtxArray[i].z=(vtxArray[i].z-centerz)*ratioz+(!notcenter ? 0 : centerz);
  }
  
  // read face table = [nbvertex v1 v2 vn | nbvertex v1 v2 vn ...] =============
  MPI_MASTER(
  printf("  Number of polygons: %ld\n", polySize);
  );
  normalArray= malloc(polySize*sizeof(Coords));
  faceArray  = malloc(polySize*10*sizeof(unsigned long)); // we assume polygons have less than 9 vertices
  if (!normalArray || !faceArray) return(0);
  
  // fill faces
  faceSize=0;
  i=0;
  while (i<polySize && ~feof(f)) {
    int  nbVertex=0, j=0;
    // read the length of this polygon
    ret=fscanf(f, "%d", &nbVertex);
    if (!ret) { 
      // invalid line: we skip it (probably a comment)
      char line[CHAR_BUF_LENGTH];
      fgets(line, CHAR_BUF_LENGTH, f);
      continue; 
    }
    if (ret != 1) {
      fprintf(stderr, "Error: can not read polygon %ld length in file %s (interoff/off_init)\n", 
        i, offfile);
      exit(3);
    }
    if (faceSize > polySize*10) {
      fprintf(stderr, "Error: %li exceeded allocated polygon array[%li] in file %s (interoff/off_init)\n", 
        faceSize, polySize*10, offfile);
    }
    faceArray[faceSize++] = nbVertex; // length of the polygon/face
    // then read the vertex ID's
    for (j=0; j<nbVertex; j++) {
      double vtx=0;
      fscanf(f, "%lg", &vtx);
      faceArray[faceSize++] = vtx;   // add vertices index after length of polygon
    }
    i++;
  }

  // precomputes normals
  long indNormal=0;//index in polyArray
  i=0;    //index in faceArray
  while (i<faceSize)
  {
    int    nbVertex=faceArray[i];//nb of vertices of this polygon
    double vertices[3*nbVertex];
    int j;

    for (j=0; j<nbVertex; ++j)
    {
      unsigned long indVertPj=faceArray[i+j+1];
      vertices[3*j]  =vtxArray[indVertPj].x;
      vertices[3*j+1]=vtxArray[indVertPj].y;
      vertices[3*j+2]=vtxArray[indVertPj].z;
    }

    polygon p;
    p.p   =vertices;
    p.npol=nbVertex;
    off_normal(&(p.normal),p);

    normalArray[indNormal]=p.normal;

    i += nbVertex+1;
    indNormal++;

  }
  
  MPI_MASTER(
  if (ratiox!=ratioy || ratiox!=ratioz || ratioy!=ratioz)
    printf("Warning: Aspect ratio of the geometry %s was modified.\n"
           "         If you want to keep the original proportions, specifiy only one of the dimensions.\n",
           offfile);
  if ( xwidth==0 && yheight==0 && zdepth==0 ) {
    printf("Warning: Neither xwidth, yheight or zdepth are defined.\n"
	   "           The file-defined (non-scaled) geometry the OFF geometry %s will be applied!\n", 
           offfile);
  }
  printf("  Bounding box dimensions for geometry %s:\n", offfile);
  printf("    Length=%f (%.3f%%)\n", rangex, ratiox*100);
  printf("    Width= %f (%.3f%%)\n", rangey, ratioy*100);
  printf("    Depth= %f (%.3f%%)\n", rangez, ratioz*100);
  );

  data->vtxArray   = vtxArray;
  data->normalArray= normalArray;
  data->faceArray  = faceArray;
  data->vtxSize    = vtxSize;
  data->polySize   = polySize;
  data->faceSize   = faceSize;
  data->filename   = offfile;
  return(polySize);
} /* off_init */

/*******************************************************************************
* int off_intersect_all(double* t0, double* t3,
     Coords *n0, Coords *n3,
     double x, double y, double z,
     double vx, double vy, double vz,
     off_struct *data )
* ACTION: computes intersection of neutron trajectory with an object.
* INPUT:  x,y,z and vx,vy,vz are the position and velocity of the neutron
*         data points to the OFF data structure
* RETURN: the number of polyhedra which trajectory intersects
*         t0 and t3 are the smallest incoming and outgoing intersection times
*         n0 and n3 are the corresponding normal vectors to the surface
*         data is the full OFF structure, including a list intersection type
*******************************************************************************/
int off_intersect_all(double* t0, double* t3,
     Coords *n0, Coords *n3,
     double x,  double y,  double z,
     double vx, double vy, double vz,
     off_struct *data )
{
    Coords A={x, y, z};
    Coords B={x+vx, y+vy, z+vz};
    int t_size=off_clip_3D_mod(data->intersects, A, B,
      data->vtxArray, data->vtxSize, data->faceArray, data->faceSize, data->normalArray );
    qsort(data->intersects, t_size, sizeof(intersection),  off_compare);
    off_cleanDouble(data->intersects, &t_size);
    off_cleanInOut(data->intersects,  &t_size);

    /*find intersections "closest" to 0 (favouring positive ones)*/
    if(t_size>0){
      int i=0;
      if(t_size>1) {
        for (i=1; i < t_size-1; i++){
          if (data->intersects[i-1].time > 0 && data->intersects[i].time > 0)
            break;
        }
	
	data->nextintersect=i-1;
	data->numintersect=t_size;

        if (t0) *t0 = data->intersects[i-1].time;
        if (n0) *n0 = data->intersects[i-1].normal;
        if (t3) *t3 = data->intersects[i].time;
        if (n3) *n3 = data->intersects[i].normal;
      } else {
        if (t0) *t0 = data->intersects[0].time; 	 
	      if (n0) *n0 = data->intersects[0].normal;
      }
      /* should also return t[0].index and t[i].index as polygon ID */
      return t_size;
    }
    return 0;
} /* off_intersect */

/*******************************************************************************
* int off_intersect(double* t0, double* t3,
     Coords *n0, Coords *n3,
     double x, double y, double z,
     double vx, double vy, double vz,
     off_struct data )
* ACTION: computes intersection of neutron trajectory with an object.
* INPUT:  x,y,z and vx,vy,vz are the position and velocity of the neutron
*         data points to the OFF data structure
* RETURN: the number of polyhedra which trajectory intersects
*         t0 and t3 are the smallest incoming and outgoing intersection times
*         n0 and n3 are the corresponding normal vectors to the surface
*******************************************************************************/
int off_intersect(double* t0, double* t3,
     Coords *n0, Coords *n3,
     double x,  double y,  double z,
     double vx, double vy, double vz,
     off_struct data )
{
  return off_intersect_all(t0, t3, n0, n3, x, y, z, vx, vy, vz, &data );
} /* off_intersect */

/*****************************************************************************
* int off_x_intersect(double* l0, double* l3,
     Coords *n0, Coords *n3,
     double x, double y, double z,
     double kx, double ky, double kz,
     off_struct data )
* ACTION: computes intersection of an xray trajectory with an object.
* INPUT:  x,y,z and kx,ky,kz, are spatial coordinates and wavevector of the x-ray
*         respectively. data points to the OFF data structure.
* RETURN: the number of polyhedra the trajectory intersects
*         l0 and l3 are the smallest incoming and outgoing intersection lengths
*         n0 and n3 are the corresponding normal vectors to the surface
*******************************************************************************/
int off_x_intersect(double *l0,double *l3,
     Coords *n0, Coords *n3,
     double x,  double y,  double z,
     double kx, double ky, double kz,
     off_struct data )
{
  /*This function simply reformats and calls off_intersect (as for neutrons)
   *by normalizing the wavevector - this will yield the intersection lengths
   *in m*/
  double jx,jy,jz,invk;
  int n;
  invk=1/sqrt(scalar_prod(kx,ky,kz,kx,ky,kz));
  jx=kx*invk;jy=ky*invk;jz=kz*invk;
  n=off_intersect(l0,l3,n0,n3,x,y,z,jx,jy,jz,data);
  return n;
}


/*******************************************************************************
* void off_display(off_struct data)
* ACTION: display up to N_VERTEX_DISPLAYED polygons from the object
*******************************************************************************/
void off_display(off_struct data)
{
  unsigned int i;
  double ratio=(double)(N_VERTEX_DISPLAYED)/(double)data.faceSize;
  unsigned int pixel=0;
  for (i=0; i<data.faceSize-1; i++) {
    int j;
    int nbVertex = data.faceArray[i];
    double x0,y0,z0;
    x0 = data.vtxArray[data.faceArray[i+1]].x;
    y0 = data.vtxArray[data.faceArray[i+1]].y;
    z0 = data.vtxArray[data.faceArray[i+1]].z;
    double x1=x0,y1=y0,z1=z0;
    double cmx=0,cmy=0,cmz=0;
    
    int drawthis = rand01() < ratio;
    // First pass, calculate center of mass location...
    for (j=1; j<=nbVertex; j++) {
      cmx = cmx+data.vtxArray[data.faceArray[i+j]].x;
      cmy = cmy+data.vtxArray[data.faceArray[i+j]].y;
      cmz = cmz+data.vtxArray[data.faceArray[i+j]].z;
    }
    cmx /= nbVertex;
    cmy /= nbVertex;
    cmz /= nbVertex;
    
    char pixelinfo[1024];    
    sprintf(pixelinfo, "%lu,%lu,%lu,%i,%g,%g,%g,%g,%g,%g", data.mantidoffset+pixel, data.mantidoffset, data.mantidoffset+data.polySize-1, nbVertex, cmx, cmy, cmz, x1-cmx, y1-cmy, z1-cmz);
    for (j=2; j<=nbVertex; j++) {
      double x2,y2,z2;
      x2 = data.vtxArray[data.faceArray[i+j]].x;
      y2 = data.vtxArray[data.faceArray[i+j]].y;
      z2 = data.vtxArray[data.faceArray[i+j]].z;
      sprintf(pixelinfo, "%s,%g,%g,%g", pixelinfo, x2-cmx, y2-cmy, z2-cmz); 
      if (ratio > 1 || drawthis) {
	mcdis_line(x1,y1,z1,x2,y2,z2);
      }
      x1 = x2; y1 = y2; z1 = z2;
    }
    if (ratio > 1 || drawthis) {
	mcdis_line(x1,y1,z1,x0,y0,z0);
      }
    if (data.mantidflag) {
      printf("MANTID_PIXEL: %s\n", pixelinfo);
      pixel++;
    }
    i += nbVertex;
  }
} /* off_display */

/* end of interoff-lib.c */

#line 10907 "./ESS_BIFROST_shielding.c"

/* Shared user declarations for all components 'Shielding_log_iterator_Ti_new'. */
#line 46 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_Ti_new.comp"
  /*This is the specialized pseudo-neutron function that computes
    an escaping neutron from logged before and after SCATTER neutron states
   with weights corresponding to capture in Ti layers*/
  int exit_neutron_Ti(double *ns_tilde, struct Generalized_State_t *S0, struct Generalized_State_t *S1){
    /*!!Note that the transformation into global coordinate system must be done while logging
      as we do not have access to neither the component name nor can get the component rotation by index.*/
    Coords c1,c2;
    Rotation R1,R2;

    /*so now compute the pseudo neutron state and possibly user variables*/ 
    /*momentum transfer at reflection*/
    double velocity=sqrt((S1->_vx)*(S1->_vx)+(S1->_vy)*(S1->_vy)+(S1->_vz)*(S1->_vz));
    double qtransf = V2Q*sqrt((S1->_vx-S0->_vx)*(S1->_vx-S0->_vx)+(S1->_vy-S0->_vy)*(S1->_vy-S0->_vy)+(S1->_vz-S0->_vz)*(S1->_vz-S0->_vz));
    double qinm = qtransf/0.0218; 
    /*position comes from "new" state*/
    ns_tilde[0]=S1->_x;ns_tilde[1]=S1->_y;ns_tilde[2]=S1->_z;
    /*velocity is the "old" state*/
    ns_tilde[3]=S0->_vx;ns_tilde[4]=S0->_vy;ns_tilde[5]=S0->_vz;
    /*time from new*/
    ns_tilde[6]=S1->_t;
      /*spin comes from "new" state*/
    ns_tilde[7]=S1->_sx;ns_tilde[8]=S1->_sy;ns_tilde[9]=S1->_sz;
    /*weight of capture in Ni is determined analytically*/
   double captureprob; 
	/* if "mvalue" is -1,  than absorption happened not on the coating but somewhere else. The weight of capture in nickel should be set to zero.*/
	if ((S1->_mvalue<0)||(qinm<0.0001)) {ns_tilde[10]=0.0; captureprob=0.0;}
   else if (S1->_mvalue<1.02){captureprob=0.0; //negligible probability for capture in Ti for m=1 coatings
     }
     else // now for coatings with m>1 
	{if (qinm<=1.02){
    /*q<qc(Ni) means diffusion to higher divergences and interaction with coating there*/
    captureprob=0.0045*(S1->_mvalue-0.9)*(S0->_p-S1->_p)/S0->_p;	
	}  else if (qinm<=S1->_mvalue+0.1) { /*q>q_c(Ni) and reflection, absorption per hit */
   captureprob=0.0045*(qinm-1.0);
    }  else { /* transmission beyond smirrorcutoff*/
   captureprob=0.00225*(S1->_mvalue-0.9)*(S1->_mvalue+0.1)/qinm;}}
     /*check change in weight*/
	if((S0->_p-S1->_p)>1.e-5*S0->_p)  ns_tilde[10]=S0->_p*captureprob; else ns_tilde[10]=0.0; 
//printf("%f\t%f\t%f\t%E\t%E\t%f\t%E\n",velocity, qinm, S1->_mvalue, S0->_p, S1->_p, captureprob, ns_tilde[10]);
    return 0;
  }

#define NOABS						     \
  do {/* Nothing*/} while(0)
  
#line 10956 "./ESS_BIFROST_shielding.c"

/* Shared user declarations for all components 'Shielding_log_iterator_total'. */
#line 46 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_total.comp"
  /*This is the specialized pseudo-neutron function that computes
    an escaping neutron from logged before and after SCATTER neutron states*/
  int exit_neutron(double *ns_tilde, struct Generalized_State_t *S0, struct Generalized_State_t *S1){
    /*!!Note that the transformation into global coordinate system must be done while logging
      as we do not have access to neither the component name nor can get the component rotation by index.*/
    Coords c1,c2;
    Rotation R1,R2;

    /*so now compute the pseudo neutron state and possibly user variables*/
    /*position comes from "new" state*/
    ns_tilde[0]=S1->_x;ns_tilde[1]=S1->_y;ns_tilde[2]=S1->_z;
    /*velocity is the "old" state*/
    ns_tilde[3]=S0->_vx;ns_tilde[4]=S0->_vy;ns_tilde[5]=S0->_vz;
    /*time from new*/
    ns_tilde[6]=S1->_t;
      /*spin comes from "new" state*/
    ns_tilde[7]=S1->_sx;ns_tilde[8]=S1->_sy;ns_tilde[9]=S1->_sz;
    /*weight is difference old-new to mean the neutrons "deposited" in the guide wall*/
    ns_tilde[10]=S0->_p-S1->_p;
    return 0;
  }

#define NOABS						     \
  do {/* Nothing*/} while(0)
  
#line 10985 "./ESS_BIFROST_shielding.c"

/* Shared user declarations for all components 'Shielding_calculator'. */
#line 43 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_calculator.comp"
#ifndef LIN_INT_ROUTINE
#define LIN_INT_ROUTINE 1
//Multi-d linear interpolation routine. Array of args, number of args, sizes of args in interpolation grid, argument grid in single line, data in single line
double lint (double * args, int Narg, int * sizearg, double * argtable, double * datatable)
{
  if (Narg==1) {
    //  printf ("Narg=1, arg = %g\n", *args);
    int point=0;
    if ((*args)<(*argtable) ) return *datatable;
    else if ((*args)>*(argtable+ *sizearg-1) ) return * (datatable+ *sizearg-1); // if the value is too large return what corresponds to largest point on the grid available
    else { // now argument is withing the range of values
      //interval lookup
      while (*args>*(argtable+point)) point++;
      //weights
      double interval = *(argtable + point) - *(argtable+point-1);
      double weightup = (*args -  *(argtable+point-1))/interval;
      double weightlow =(*(argtable + point) - *args)/interval;
      return weightup*(*(datatable+point))+weightlow*(*(datatable+point-1));
        }//arg within range of values
     }// if Narg==1
   else if (Narg >1){//if more than one argument 
    //lookup how large is the data (Narg-1)D slice for fixed value of the first argument 
    int slicesize=1;
    int i,point=0;
    for ( i=1;i<Narg;i++) slicesize*=sizearg[i];
    // printf("Narg > 1, slicesize = %d, arggridstart = %g, argument = %g, arggridend = %g\n",slicesize,*argtable,*args, *(argtable+ *sizearg-1) );
    //search weights for the first argument and get results with one argument less 
    if ((*args)<(*argtable) ) return lint(args+1,Narg-1, sizearg+1, argtable+(*sizearg), datatable);
    // if the value is too low -- return what is on the lower bound 
    else if ((*args)>*(argtable+ *sizearg-1) ) return lint(args+1,Narg-1, sizearg+1, argtable+(*sizearg), (datatable+ slicesize*(*sizearg))); 
   // if the value is too large return what corresponds to largest point on the grid available          
    else { // now argument is withing the range of values                                                                                                                         
      //interval lookup                                                                                                                                                           
      while (*args>*(argtable+point)) {
	//	printf ("*(argtable+point) = %g\n", *(argtable+point)); 
	point++;}
      //weights                                                                                                                                                                   
      double interval = *(argtable + point) - *(argtable+point-1);
      double weightup =(*args -  *(argtable+point-1))/interval;
      double weightlow =(*(argtable + point) - *args)/interval;
      return weightup*lint(args+1,Narg-1, sizearg+1, argtable+(*sizearg), datatable+point*slicesize )
	+weightlow*lint(args+1,Narg-1, sizearg+1, argtable+(*sizearg),  datatable+(point-1)*slicesize);
    } // argument within the ragne
   } //Narg>1
};
#endif
#line 11035 "./ESS_BIFROST_shielding.c"

/* Shared user declarations for all components 'Dose_calculator'. */
#line 43 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Dose_calculator.comp"
#ifndef LIN_INT_ROUTINE
#define LIN_INT_ROUTINE 1
//Multi-d linear interpolation routine. Array of args, number of args, sizes of args in interpolation grid, argument grid in single line, data in single line
double lint (double * args, int Narg, int * sizearg, double * argtable, double * datatable)
{
  if (Narg==1) {
    //  printf ("Narg=1, arg = %g\n", *args);
    int point=0;
    if ((*args)<(*argtable) ) return *datatable;
    else if ((*args)>*(argtable+ *sizearg-1) ) return * (datatable+ *sizearg-1); // if the value is too large return what corresponds to largest point on the grid available
    else { // now argument is withing the range of values
      //interval lookup
      while (*args>*(argtable+point)) point++;
      //weights
      double interval = *(argtable + point) - *(argtable+point-1);
      double weightup = (*args -  *(argtable+point-1))/interval;
      double weightlow =(*(argtable + point) - *args)/interval;
      return weightup*(*(datatable+point))+weightlow*(*(datatable+point-1));
        }//arg within range of values
     }// if Narg==1
   else if (Narg >1){//if more than one argument 
    //lookup how large is the data (Narg-1)D slice for fixed value of the first argument 
    int slicesize=1;
    int i,point=0;
    for ( i=1;i<Narg;i++) slicesize*=sizearg[i];
    // printf("Narg > 1, slicesize = %d, arggridstart = %g, argument = %g, arggridend = %g\n",slicesize,*argtable,*args, *(argtable+ *sizearg-1) );
    //search weights for the first argument and get results with one argument less 
    if ((*args)<(*argtable) ) return lint(args+1,Narg-1, sizearg+1, argtable+(*sizearg), datatable);
    // if the value is too low -- return what is on the lower bound 
    else if ((*args)>*(argtable+ *sizearg-1) ) return lint(args+1,Narg-1, sizearg+1, argtable+(*sizearg), (datatable+ slicesize*(*sizearg))); 
   // if the value is too large return what corresponds to largest point on the grid available          
    else { // now argument is withing the range of values                                                                                                                         
      //interval lookup                                                                                                                                                           
      while (*args>*(argtable+point)) {
	//	printf ("*(argtable+point) = %g\n", *(argtable+point)); 
	point++;}
      //weights                                                                                                                                                                   
      double interval = *(argtable + point) - *(argtable+point-1);
      double weightup =(*args -  *(argtable+point-1))/interval;
      double weightlow =(*(argtable + point) - *args)/interval;
      return weightup*lint(args+1,Narg-1, sizearg+1, argtable+(*sizearg), datatable+point*slicesize )
	+weightlow*lint(args+1,Narg-1, sizearg+1, argtable+(*sizearg),  datatable+(point-1)*slicesize);
    } // argument within the ragne
   } //Narg>1
};
#endif
#line 11085 "./ESS_BIFROST_shielding.c"

/* Instrument parameters. */
MCNUM mcipWaveMin;
MCNUM mcipWaveMax;
MCNUM mcipE_0;
MCNUM mcipL_0;
MCNUM mcipchopPulseOpening;
MCNUM mcipDivSlit0_width;
MCNUM mcipDivSlit1_width;
MCNUM mcipDivSlit2_width;
MCNUM mcipDivSlit3_width;
MCNUM mcipNpulse;
int mcipprint;
int mcipmakeVirtualSource;
int mcipprintMValues;
MCNUM mcippower;
MCNUM mcipBWopen;

#define mcNUMIPAR 15
int mcnumipar = 15;
struct mcinputtable_struct mcinputtable[mcNUMIPAR+1] = {
  "WaveMin", &mcipWaveMin, instr_type_double, "1", 
  "WaveMax", &mcipWaveMax, instr_type_double, "10", 
  "E_0", &mcipE_0, instr_type_double, "4.0", 
  "L_0", &mcipL_0, instr_type_double, "0", 
  "chopPulseOpening", &mcipchopPulseOpening, instr_type_double, "0.004", 
  "DivSlit0_width", &mcipDivSlit0_width, instr_type_double, "0.1", 
  "DivSlit1_width", &mcipDivSlit1_width, instr_type_double, "0.1", 
  "DivSlit2_width", &mcipDivSlit2_width, instr_type_double, "0.1", 
  "DivSlit3_width", &mcipDivSlit3_width, instr_type_double, "0.1", 
  "Npulse", &mcipNpulse, instr_type_double, "1", 
  "print", &mcipprint, instr_type_int, "0", 
  "makeVirtualSource", &mcipmakeVirtualSource, instr_type_int, "0", 
  "printMValues", &mcipprintMValues, instr_type_int, "0", 
  "power", &mcippower, instr_type_double, "5.0", 
  "BWopen", &mcipBWopen, instr_type_double, "161", 
  NULL, NULL, instr_type_double, ""
};

/* User declarations from instrument definition. */
#define mccompcurname  ESS_BIFROST_shielding
#define mccompcurtype  INSTRUMENT
#define mccompcurindex 0
#define mcposaESS_BIFROST_shielding coords_set(0,0,0)
#define WaveMin mcipWaveMin
#define WaveMax mcipWaveMax
#define E_0 mcipE_0
#define L_0 mcipL_0
#define chopPulseOpening mcipchopPulseOpening
#define DivSlit0_width mcipDivSlit0_width
#define DivSlit1_width mcipDivSlit1_width
#define DivSlit2_width mcipDivSlit2_width
#define DivSlit3_width mcipDivSlit3_width
#define Npulse mcipNpulse
#define print mcipprint
#define makeVirtualSource mcipmakeVirtualSource
#define printMValues mcipprintMValues
#define power mcippower
#define BWopen mcipBWopen
#line 69 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
// M-value and element length arrays
double elementLength6S[150];
double mValues6verticalS[150];
double mValues6horizontalS[150];
double elementLength3S[150];
double mValues3verticalS[150];
double mValues3horizontalS[150];
double elementLength1S[150];
double mValues1verticalS[150];
double mValues1horizontalS[150];


// Transferred parameters
double chopPulseFrequencyOrder=14; // Number of chopper pulses pr moderator pulse. It will automatically be reduced when nesesary and a warning will be written in the promt. 
double sampleSizeX=0.010; // Width of monitors at sample position. Guide optimized for up to 0.015, intruments optimized for 0.001 to 0.01.
double sampleSizeY=0.010; // Height of monitors at sample position. Guide optimized for up to 0.015, intruments optimized for 0.001 to 0.01.
double chopBWPos=78;  // Distance from pulse shapping choppers to BW Chopper
double PscOff=0.0306;
double discD=0.04;
double monigap_length = 0.02; // Length of the moni-gap
double FOCopen1=38.26;
double FOCopen2=52.01;

//Chopper translation parameters adjusting for engineering margins

//The precise values relate to the FOC chopper document, the value 'u' is calculated from the guide width, and
//the engineering margin is 3 mm

// u for the bunker = 0.00031 
// u for the traight section = 0.00123 

//Add engineering margin to this and get. 

double ChopTransBunker=0.00331; //To accomodate floor deformations in the bunker
double ChopTransE2=0.00423; //To accomodate floor deformations in the E02 hall (piles)







double x_div;
double y_div;
int flag;
double u = 1e-5;

/*************************************** Chopper Variables  *******************************************/

double lambda_0; double lambda_1;
double v_0; double v_1;
double InstLength;
double chopPulseOffset;  double chopPulsePhaseOffset;  double chopPulseDist; double chopPulseOpen; 
double chopPulse2PhaseOffset;
double chopFrameOverlap1Offset;   double chopFrameOverlap1PhaseOffset; //double chopFrameOverlap1Pos; 
double chopFrameOverlap1Open;
double chopFrameOverlap2Offset;   double chopFrameOverlap2PhaseOffset; //double chopFrameOverlap2Pos; 
double chopFrameOverlap2Open;
double chopBWOffset;   double chopBWPhaseOffset; //double chopBWPos; 
double chopBWOpen;
double t_samp_center; double t_samp_0; double t_samp_1;
double chopBW_t0; double  chopBW_t1;

double PulseHighFluxOffset;
double WavelengthBand;
double ModPulseLengthHighF;
double chopPulsePossibleOpening;


/////  Martin's cutting parameters:
double sample_dist = 0.5;
double startXposition_straight = 49.303484;


double length5 = 17.995800;
//double benderStartXposition =6.380700;
double benderStartXposition =24.376254 ;

// straiht:
double length2 = 90.0;

// Focus ellipse:
double length1 = 22.114200;
double Linx1 = 24.364542;
double Loutx1 = 2.250342;
double Liny1 = 23.034433;
double Louty1 = 0.920233;
double alpha1 = 3.1;
double Qc1 = 0.021700;
double R01 = 0.990000;
double smallaxis_y1 = 0.090000/2;
double smallaxis_x1 = 0.060000/2;



double elementLength1_part_1[50]; 
double mValues1vertical_part_1[50]; 
double mValues1horizontal_part_1[50];
double elementLength1_part_2[5]; 
double mValues1vertical_part_2[5]; 
double mValues1horizontal_part_2[5];
double elementLength1_part_3[5]; 
double mValues1vertical_part_3[5]; 
double mValues1horizontal_part_3[5];
double elementLength1_part_4[5]; 
double mValues1vertical_part_4[5]; 
double mValues1horizontal_part_4[5];

int counter = 0;

double chopper_coordinate_offset = 4.439;


double curve_rot = 0; // has to be either 180 or -180. Determines curve to left or right

double chopFrameOverlap1Pos;
double chopFrameOverlap2Pos;

// These parameters are no longer safe to change
double DivSlit0Gap=0.02; // Hole in guide required for Divergence slit nr 0 (at the end of guide)
double DivSlit1Gap=0.02; // Hole in guide required for Divergence slit nr 1
double DivSlit2Gap=0.02; // Hole in guide required for Divergence slit nr 2
double DivSlit3Gap=0.02; // Hole in guide required for Divergence slit nr 3

double DivSlit1Pos=1.0814;  // Position of Divergence Slit nr 1
double DivSlit2Pos=1.661; // Position of Divergence Slit nr 2
double DivSlit3Pos=2.961; // Position of Divergence Slit nr 3
// Old divJaw pos:
//double DivSlit1Pos=1.191;  // Position of Divergence Slit nr 1
//double DivSlit2Pos=1.661; // Position of Divergence Slit nr 2
//double DivSlit3Pos=2.961; // Position of Divergence Slit nr 3
double chopGap=0.04;
double BW_chopGap=0.04;
double chopFrameOverlap1Pos= 8.530;    // Distance from moderator to first frame owerlap chopper
double chopFrameOverlap2Pos= 14.973;    // Distance from moderator to second frame owerlap chopper

double benderAngle = 0.01886551; // Mads numbers = 0.0183513513514;

int i;   
#line 11285 "./ESS_BIFROST_shielding.c"
#undef BWopen
#undef power
#undef printMValues
#undef makeVirtualSource
#undef print
#undef Npulse
#undef DivSlit3_width
#undef DivSlit2_width
#undef DivSlit1_width
#undef DivSlit0_width
#undef chopPulseOpening
#undef L_0
#undef E_0
#undef WaveMax
#undef WaveMin
#undef mcposaESS_BIFROST_shielding
#undef mccompcurindex
#undef mccompcurtype
#undef mccompcurname

/* neutron state table at each component input (local coords) */
/* [x, y, z, vx, vy, vz, t, sx, sy, sz, p] */
MCNUM mccomp_storein[11*92];
/* Components position table (absolute and relative coords) */
Coords mccomp_posa[92];
Coords mccomp_posr[92];
/* Counter for each comp to check for inactive ones */
MCNUM  mcNCounter[92];
MCNUM  mcPCounter[92];
MCNUM  mcP2Counter[92];
#define mcNUMCOMP 91 /* number of components */
/* Counter for PROP ABSORB */
MCNUM  mcAbsorbProp[92];
/* Flag true when previous component acted on the neutron (SCATTER) */
MCNUM mcScattered=0;
/* Flag true when neutron should be restored (RESTORE) */
MCNUM mcRestore=0;
/* Declarations of component definition and setting parameters. */

/* Setting parameters for component 'Origin' [1]. */
char mccOrigin_profile[16384];
MCNUM mccOrigin_percent;
MCNUM mccOrigin_flag_save;
MCNUM mccOrigin_minutes;

/* Setting parameters for component 'ESS_source' [2]. */
char mccESS_source_sector[16384];
int mccESS_source_beamline;
MCNUM mccESS_source_yheight;
MCNUM mccESS_source_cold_frac;
int mccESS_source_target_index;
MCNUM mccESS_source_dist;
MCNUM mccESS_source_focus_xw;
MCNUM mccESS_source_focus_yh;
MCNUM mccESS_source_c_performance;
MCNUM mccESS_source_t_performance;
MCNUM mccESS_source_Lmin;
MCNUM mccESS_source_Lmax;
MCNUM mccESS_source_tmax_multiplier;
int mccESS_source_n_pulses;
MCNUM mccESS_source_acc_power;
MCNUM mccESS_source_tfocus_dist;
MCNUM mccESS_source_tfocus_time;
MCNUM mccESS_source_tfocus_width;

/* Definition parameters for component 'NBOA' [4]. */
#define mccNBOA_mvaluesright mValues6horizontalS
#define mccNBOA_mvaluesleft mValues6horizontalS
#define mccNBOA_mvaluestop mValues6verticalS
#define mccNBOA_mvaluesbottom mValues6verticalS
#define mccNBOA_seglength elementLength6S
/* Setting parameters for component 'NBOA' [4]. */
MCNUM mccNBOA_l;
MCNUM mccNBOA_xwidth;
MCNUM mccNBOA_yheight;
MCNUM mccNBOA_linxw;
MCNUM mccNBOA_loutxw;
MCNUM mccNBOA_linyh;
MCNUM mccNBOA_loutyh;
MCNUM mccNBOA_majorAxisxw;
MCNUM mccNBOA_minorAxisxw;
MCNUM mccNBOA_majorAxisyh;
MCNUM mccNBOA_minorAxisyh;
MCNUM mccNBOA_majorAxisoffsetxw;
MCNUM mccNBOA_majorAxisoffsetyh;
char mccNBOA_dimensionsAt[16384];
char mccNBOA_option[16384];
MCNUM mccNBOA_R0;
MCNUM mccNBOA_Qc;
MCNUM mccNBOA_alpha;
MCNUM mccNBOA_m;
MCNUM mccNBOA_W;
MCNUM mccNBOA_alpharight;
MCNUM mccNBOA_mright;
MCNUM mccNBOA_alphaleft;
MCNUM mccNBOA_mleft;
MCNUM mccNBOA_alphatop;
MCNUM mccNBOA_mtop;
MCNUM mccNBOA_alphabottom;
MCNUM mccNBOA_mbottom;
char mccNBOA_verbose[16384];
MCNUM mccNBOA_enableGravity;
MCNUM mccNBOA_curvature;

/* Setting parameters for component 'curved_guide_1_0' [7]. */
MCNUM mcccurved_guide_1_0_w1;
MCNUM mcccurved_guide_1_0_h1;
MCNUM mcccurved_guide_1_0_w2;
MCNUM mcccurved_guide_1_0_h2;
MCNUM mcccurved_guide_1_0_l;
MCNUM mcccurved_guide_1_0_R0;
MCNUM mcccurved_guide_1_0_Qc;
MCNUM mcccurved_guide_1_0_alpha;
MCNUM mcccurved_guide_1_0_m;
MCNUM mcccurved_guide_1_0_W;
MCNUM mcccurved_guide_1_0_nslit;
MCNUM mcccurved_guide_1_0_d;
MCNUM mcccurved_guide_1_0_mleft;
MCNUM mcccurved_guide_1_0_mright;
MCNUM mcccurved_guide_1_0_mtop;
MCNUM mcccurved_guide_1_0_mbottom;
MCNUM mcccurved_guide_1_0_nhslit;
MCNUM mcccurved_guide_1_0_G;
MCNUM mcccurved_guide_1_0_aleft;
MCNUM mcccurved_guide_1_0_aright;
MCNUM mcccurved_guide_1_0_atop;
MCNUM mcccurved_guide_1_0_abottom;
MCNUM mcccurved_guide_1_0_wavy;
MCNUM mcccurved_guide_1_0_wavy_z;
MCNUM mcccurved_guide_1_0_wavy_tb;
MCNUM mcccurved_guide_1_0_wavy_lr;
MCNUM mcccurved_guide_1_0_chamfers;
MCNUM mcccurved_guide_1_0_chamfers_z;
MCNUM mcccurved_guide_1_0_chamfers_lr;
MCNUM mcccurved_guide_1_0_chamfers_tb;
MCNUM mcccurved_guide_1_0_nelements;
MCNUM mcccurved_guide_1_0_nu;
MCNUM mcccurved_guide_1_0_phase;
char mcccurved_guide_1_0_reflect[16384];

/* Setting parameters for component 'curved_guide_2_0' [8]. */
MCNUM mcccurved_guide_2_0_w1;
MCNUM mcccurved_guide_2_0_h1;
MCNUM mcccurved_guide_2_0_w2;
MCNUM mcccurved_guide_2_0_h2;
MCNUM mcccurved_guide_2_0_l;
MCNUM mcccurved_guide_2_0_R0;
MCNUM mcccurved_guide_2_0_Qc;
MCNUM mcccurved_guide_2_0_alpha;
MCNUM mcccurved_guide_2_0_m;
MCNUM mcccurved_guide_2_0_W;
MCNUM mcccurved_guide_2_0_nslit;
MCNUM mcccurved_guide_2_0_d;
MCNUM mcccurved_guide_2_0_mleft;
MCNUM mcccurved_guide_2_0_mright;
MCNUM mcccurved_guide_2_0_mtop;
MCNUM mcccurved_guide_2_0_mbottom;
MCNUM mcccurved_guide_2_0_nhslit;
MCNUM mcccurved_guide_2_0_G;
MCNUM mcccurved_guide_2_0_aleft;
MCNUM mcccurved_guide_2_0_aright;
MCNUM mcccurved_guide_2_0_atop;
MCNUM mcccurved_guide_2_0_abottom;
MCNUM mcccurved_guide_2_0_wavy;
MCNUM mcccurved_guide_2_0_wavy_z;
MCNUM mcccurved_guide_2_0_wavy_tb;
MCNUM mcccurved_guide_2_0_wavy_lr;
MCNUM mcccurved_guide_2_0_chamfers;
MCNUM mcccurved_guide_2_0_chamfers_z;
MCNUM mcccurved_guide_2_0_chamfers_lr;
MCNUM mcccurved_guide_2_0_chamfers_tb;
MCNUM mcccurved_guide_2_0_nelements;
MCNUM mcccurved_guide_2_0_nu;
MCNUM mcccurved_guide_2_0_phase;
char mcccurved_guide_2_0_reflect[16384];

/* Setting parameters for component 'curved_guide_3_0' [9]. */
MCNUM mcccurved_guide_3_0_w1;
MCNUM mcccurved_guide_3_0_h1;
MCNUM mcccurved_guide_3_0_w2;
MCNUM mcccurved_guide_3_0_h2;
MCNUM mcccurved_guide_3_0_l;
MCNUM mcccurved_guide_3_0_R0;
MCNUM mcccurved_guide_3_0_Qc;
MCNUM mcccurved_guide_3_0_alpha;
MCNUM mcccurved_guide_3_0_m;
MCNUM mcccurved_guide_3_0_W;
MCNUM mcccurved_guide_3_0_nslit;
MCNUM mcccurved_guide_3_0_d;
MCNUM mcccurved_guide_3_0_mleft;
MCNUM mcccurved_guide_3_0_mright;
MCNUM mcccurved_guide_3_0_mtop;
MCNUM mcccurved_guide_3_0_mbottom;
MCNUM mcccurved_guide_3_0_nhslit;
MCNUM mcccurved_guide_3_0_G;
MCNUM mcccurved_guide_3_0_aleft;
MCNUM mcccurved_guide_3_0_aright;
MCNUM mcccurved_guide_3_0_atop;
MCNUM mcccurved_guide_3_0_abottom;
MCNUM mcccurved_guide_3_0_wavy;
MCNUM mcccurved_guide_3_0_wavy_z;
MCNUM mcccurved_guide_3_0_wavy_tb;
MCNUM mcccurved_guide_3_0_wavy_lr;
MCNUM mcccurved_guide_3_0_chamfers;
MCNUM mcccurved_guide_3_0_chamfers_z;
MCNUM mcccurved_guide_3_0_chamfers_lr;
MCNUM mcccurved_guide_3_0_chamfers_tb;
MCNUM mcccurved_guide_3_0_nelements;
MCNUM mcccurved_guide_3_0_nu;
MCNUM mcccurved_guide_3_0_phase;
char mcccurved_guide_3_0_reflect[16384];

/* Setting parameters for component 'curved_guide_4_0' [10]. */
MCNUM mcccurved_guide_4_0_w1;
MCNUM mcccurved_guide_4_0_h1;
MCNUM mcccurved_guide_4_0_w2;
MCNUM mcccurved_guide_4_0_h2;
MCNUM mcccurved_guide_4_0_l;
MCNUM mcccurved_guide_4_0_R0;
MCNUM mcccurved_guide_4_0_Qc;
MCNUM mcccurved_guide_4_0_alpha;
MCNUM mcccurved_guide_4_0_m;
MCNUM mcccurved_guide_4_0_W;
MCNUM mcccurved_guide_4_0_nslit;
MCNUM mcccurved_guide_4_0_d;
MCNUM mcccurved_guide_4_0_mleft;
MCNUM mcccurved_guide_4_0_mright;
MCNUM mcccurved_guide_4_0_mtop;
MCNUM mcccurved_guide_4_0_mbottom;
MCNUM mcccurved_guide_4_0_nhslit;
MCNUM mcccurved_guide_4_0_G;
MCNUM mcccurved_guide_4_0_aleft;
MCNUM mcccurved_guide_4_0_aright;
MCNUM mcccurved_guide_4_0_atop;
MCNUM mcccurved_guide_4_0_abottom;
MCNUM mcccurved_guide_4_0_wavy;
MCNUM mcccurved_guide_4_0_wavy_z;
MCNUM mcccurved_guide_4_0_wavy_tb;
MCNUM mcccurved_guide_4_0_wavy_lr;
MCNUM mcccurved_guide_4_0_chamfers;
MCNUM mcccurved_guide_4_0_chamfers_z;
MCNUM mcccurved_guide_4_0_chamfers_lr;
MCNUM mcccurved_guide_4_0_chamfers_tb;
MCNUM mcccurved_guide_4_0_nelements;
MCNUM mcccurved_guide_4_0_nu;
MCNUM mcccurved_guide_4_0_phase;
char mcccurved_guide_4_0_reflect[16384];

/* Setting parameters for component 'curved_guide_5_beforeChopper' [11]. */
MCNUM mcccurved_guide_5_beforeChopper_w1;
MCNUM mcccurved_guide_5_beforeChopper_h1;
MCNUM mcccurved_guide_5_beforeChopper_w2;
MCNUM mcccurved_guide_5_beforeChopper_h2;
MCNUM mcccurved_guide_5_beforeChopper_l;
MCNUM mcccurved_guide_5_beforeChopper_R0;
MCNUM mcccurved_guide_5_beforeChopper_Qc;
MCNUM mcccurved_guide_5_beforeChopper_alpha;
MCNUM mcccurved_guide_5_beforeChopper_m;
MCNUM mcccurved_guide_5_beforeChopper_W;
MCNUM mcccurved_guide_5_beforeChopper_nslit;
MCNUM mcccurved_guide_5_beforeChopper_d;
MCNUM mcccurved_guide_5_beforeChopper_mleft;
MCNUM mcccurved_guide_5_beforeChopper_mright;
MCNUM mcccurved_guide_5_beforeChopper_mtop;
MCNUM mcccurved_guide_5_beforeChopper_mbottom;
MCNUM mcccurved_guide_5_beforeChopper_nhslit;
MCNUM mcccurved_guide_5_beforeChopper_G;
MCNUM mcccurved_guide_5_beforeChopper_aleft;
MCNUM mcccurved_guide_5_beforeChopper_aright;
MCNUM mcccurved_guide_5_beforeChopper_atop;
MCNUM mcccurved_guide_5_beforeChopper_abottom;
MCNUM mcccurved_guide_5_beforeChopper_wavy;
MCNUM mcccurved_guide_5_beforeChopper_wavy_z;
MCNUM mcccurved_guide_5_beforeChopper_wavy_tb;
MCNUM mcccurved_guide_5_beforeChopper_wavy_lr;
MCNUM mcccurved_guide_5_beforeChopper_chamfers;
MCNUM mcccurved_guide_5_beforeChopper_chamfers_z;
MCNUM mcccurved_guide_5_beforeChopper_chamfers_lr;
MCNUM mcccurved_guide_5_beforeChopper_chamfers_tb;
MCNUM mcccurved_guide_5_beforeChopper_nelements;
MCNUM mcccurved_guide_5_beforeChopper_nu;
MCNUM mcccurved_guide_5_beforeChopper_phase;
char mcccurved_guide_5_beforeChopper_reflect[16384];

/* Setting parameters for component 'curved_guide_5_afterChopper' [12]. */
MCNUM mcccurved_guide_5_afterChopper_w1;
MCNUM mcccurved_guide_5_afterChopper_h1;
MCNUM mcccurved_guide_5_afterChopper_w2;
MCNUM mcccurved_guide_5_afterChopper_h2;
MCNUM mcccurved_guide_5_afterChopper_l;
MCNUM mcccurved_guide_5_afterChopper_R0;
MCNUM mcccurved_guide_5_afterChopper_Qc;
MCNUM mcccurved_guide_5_afterChopper_alpha;
MCNUM mcccurved_guide_5_afterChopper_m;
MCNUM mcccurved_guide_5_afterChopper_W;
MCNUM mcccurved_guide_5_afterChopper_nslit;
MCNUM mcccurved_guide_5_afterChopper_d;
MCNUM mcccurved_guide_5_afterChopper_mleft;
MCNUM mcccurved_guide_5_afterChopper_mright;
MCNUM mcccurved_guide_5_afterChopper_mtop;
MCNUM mcccurved_guide_5_afterChopper_mbottom;
MCNUM mcccurved_guide_5_afterChopper_nhslit;
MCNUM mcccurved_guide_5_afterChopper_G;
MCNUM mcccurved_guide_5_afterChopper_aleft;
MCNUM mcccurved_guide_5_afterChopper_aright;
MCNUM mcccurved_guide_5_afterChopper_atop;
MCNUM mcccurved_guide_5_afterChopper_abottom;
MCNUM mcccurved_guide_5_afterChopper_wavy;
MCNUM mcccurved_guide_5_afterChopper_wavy_z;
MCNUM mcccurved_guide_5_afterChopper_wavy_tb;
MCNUM mcccurved_guide_5_afterChopper_wavy_lr;
MCNUM mcccurved_guide_5_afterChopper_chamfers;
MCNUM mcccurved_guide_5_afterChopper_chamfers_z;
MCNUM mcccurved_guide_5_afterChopper_chamfers_lr;
MCNUM mcccurved_guide_5_afterChopper_chamfers_tb;
MCNUM mcccurved_guide_5_afterChopper_nelements;
MCNUM mcccurved_guide_5_afterChopper_nu;
MCNUM mcccurved_guide_5_afterChopper_phase;
char mcccurved_guide_5_afterChopper_reflect[16384];

/* Setting parameters for component 'curved_guide_6_0' [13]. */
MCNUM mcccurved_guide_6_0_w1;
MCNUM mcccurved_guide_6_0_h1;
MCNUM mcccurved_guide_6_0_w2;
MCNUM mcccurved_guide_6_0_h2;
MCNUM mcccurved_guide_6_0_l;
MCNUM mcccurved_guide_6_0_R0;
MCNUM mcccurved_guide_6_0_Qc;
MCNUM mcccurved_guide_6_0_alpha;
MCNUM mcccurved_guide_6_0_m;
MCNUM mcccurved_guide_6_0_W;
MCNUM mcccurved_guide_6_0_nslit;
MCNUM mcccurved_guide_6_0_d;
MCNUM mcccurved_guide_6_0_mleft;
MCNUM mcccurved_guide_6_0_mright;
MCNUM mcccurved_guide_6_0_mtop;
MCNUM mcccurved_guide_6_0_mbottom;
MCNUM mcccurved_guide_6_0_nhslit;
MCNUM mcccurved_guide_6_0_G;
MCNUM mcccurved_guide_6_0_aleft;
MCNUM mcccurved_guide_6_0_aright;
MCNUM mcccurved_guide_6_0_atop;
MCNUM mcccurved_guide_6_0_abottom;
MCNUM mcccurved_guide_6_0_wavy;
MCNUM mcccurved_guide_6_0_wavy_z;
MCNUM mcccurved_guide_6_0_wavy_tb;
MCNUM mcccurved_guide_6_0_wavy_lr;
MCNUM mcccurved_guide_6_0_chamfers;
MCNUM mcccurved_guide_6_0_chamfers_z;
MCNUM mcccurved_guide_6_0_chamfers_lr;
MCNUM mcccurved_guide_6_0_chamfers_tb;
MCNUM mcccurved_guide_6_0_nelements;
MCNUM mcccurved_guide_6_0_nu;
MCNUM mcccurved_guide_6_0_phase;
char mcccurved_guide_6_0_reflect[16384];

/* Setting parameters for component 'curved_guide_7_0' [14]. */
MCNUM mcccurved_guide_7_0_w1;
MCNUM mcccurved_guide_7_0_h1;
MCNUM mcccurved_guide_7_0_w2;
MCNUM mcccurved_guide_7_0_h2;
MCNUM mcccurved_guide_7_0_l;
MCNUM mcccurved_guide_7_0_R0;
MCNUM mcccurved_guide_7_0_Qc;
MCNUM mcccurved_guide_7_0_alpha;
MCNUM mcccurved_guide_7_0_m;
MCNUM mcccurved_guide_7_0_W;
MCNUM mcccurved_guide_7_0_nslit;
MCNUM mcccurved_guide_7_0_d;
MCNUM mcccurved_guide_7_0_mleft;
MCNUM mcccurved_guide_7_0_mright;
MCNUM mcccurved_guide_7_0_mtop;
MCNUM mcccurved_guide_7_0_mbottom;
MCNUM mcccurved_guide_7_0_nhslit;
MCNUM mcccurved_guide_7_0_G;
MCNUM mcccurved_guide_7_0_aleft;
MCNUM mcccurved_guide_7_0_aright;
MCNUM mcccurved_guide_7_0_atop;
MCNUM mcccurved_guide_7_0_abottom;
MCNUM mcccurved_guide_7_0_wavy;
MCNUM mcccurved_guide_7_0_wavy_z;
MCNUM mcccurved_guide_7_0_wavy_tb;
MCNUM mcccurved_guide_7_0_wavy_lr;
MCNUM mcccurved_guide_7_0_chamfers;
MCNUM mcccurved_guide_7_0_chamfers_z;
MCNUM mcccurved_guide_7_0_chamfers_lr;
MCNUM mcccurved_guide_7_0_chamfers_tb;
MCNUM mcccurved_guide_7_0_nelements;
MCNUM mcccurved_guide_7_0_nu;
MCNUM mcccurved_guide_7_0_phase;
char mcccurved_guide_7_0_reflect[16384];

/* Setting parameters for component 'curved_guide_8_0' [15]. */
MCNUM mcccurved_guide_8_0_w1;
MCNUM mcccurved_guide_8_0_h1;
MCNUM mcccurved_guide_8_0_w2;
MCNUM mcccurved_guide_8_0_h2;
MCNUM mcccurved_guide_8_0_l;
MCNUM mcccurved_guide_8_0_R0;
MCNUM mcccurved_guide_8_0_Qc;
MCNUM mcccurved_guide_8_0_alpha;
MCNUM mcccurved_guide_8_0_m;
MCNUM mcccurved_guide_8_0_W;
MCNUM mcccurved_guide_8_0_nslit;
MCNUM mcccurved_guide_8_0_d;
MCNUM mcccurved_guide_8_0_mleft;
MCNUM mcccurved_guide_8_0_mright;
MCNUM mcccurved_guide_8_0_mtop;
MCNUM mcccurved_guide_8_0_mbottom;
MCNUM mcccurved_guide_8_0_nhslit;
MCNUM mcccurved_guide_8_0_G;
MCNUM mcccurved_guide_8_0_aleft;
MCNUM mcccurved_guide_8_0_aright;
MCNUM mcccurved_guide_8_0_atop;
MCNUM mcccurved_guide_8_0_abottom;
MCNUM mcccurved_guide_8_0_wavy;
MCNUM mcccurved_guide_8_0_wavy_z;
MCNUM mcccurved_guide_8_0_wavy_tb;
MCNUM mcccurved_guide_8_0_wavy_lr;
MCNUM mcccurved_guide_8_0_chamfers;
MCNUM mcccurved_guide_8_0_chamfers_z;
MCNUM mcccurved_guide_8_0_chamfers_lr;
MCNUM mcccurved_guide_8_0_chamfers_tb;
MCNUM mcccurved_guide_8_0_nelements;
MCNUM mcccurved_guide_8_0_nu;
MCNUM mcccurved_guide_8_0_phase;
char mcccurved_guide_8_0_reflect[16384];

/* Setting parameters for component 'curved_guide_9_0' [16]. */
MCNUM mcccurved_guide_9_0_w1;
MCNUM mcccurved_guide_9_0_h1;
MCNUM mcccurved_guide_9_0_w2;
MCNUM mcccurved_guide_9_0_h2;
MCNUM mcccurved_guide_9_0_l;
MCNUM mcccurved_guide_9_0_R0;
MCNUM mcccurved_guide_9_0_Qc;
MCNUM mcccurved_guide_9_0_alpha;
MCNUM mcccurved_guide_9_0_m;
MCNUM mcccurved_guide_9_0_W;
MCNUM mcccurved_guide_9_0_nslit;
MCNUM mcccurved_guide_9_0_d;
MCNUM mcccurved_guide_9_0_mleft;
MCNUM mcccurved_guide_9_0_mright;
MCNUM mcccurved_guide_9_0_mtop;
MCNUM mcccurved_guide_9_0_mbottom;
MCNUM mcccurved_guide_9_0_nhslit;
MCNUM mcccurved_guide_9_0_G;
MCNUM mcccurved_guide_9_0_aleft;
MCNUM mcccurved_guide_9_0_aright;
MCNUM mcccurved_guide_9_0_atop;
MCNUM mcccurved_guide_9_0_abottom;
MCNUM mcccurved_guide_9_0_wavy;
MCNUM mcccurved_guide_9_0_wavy_z;
MCNUM mcccurved_guide_9_0_wavy_tb;
MCNUM mcccurved_guide_9_0_wavy_lr;
MCNUM mcccurved_guide_9_0_chamfers;
MCNUM mcccurved_guide_9_0_chamfers_z;
MCNUM mcccurved_guide_9_0_chamfers_lr;
MCNUM mcccurved_guide_9_0_chamfers_tb;
MCNUM mcccurved_guide_9_0_nelements;
MCNUM mcccurved_guide_9_0_nu;
MCNUM mcccurved_guide_9_0_phase;
char mcccurved_guide_9_0_reflect[16384];

/* Setting parameters for component 'curved_guide_10_0' [17]. */
MCNUM mcccurved_guide_10_0_w1;
MCNUM mcccurved_guide_10_0_h1;
MCNUM mcccurved_guide_10_0_w2;
MCNUM mcccurved_guide_10_0_h2;
MCNUM mcccurved_guide_10_0_l;
MCNUM mcccurved_guide_10_0_R0;
MCNUM mcccurved_guide_10_0_Qc;
MCNUM mcccurved_guide_10_0_alpha;
MCNUM mcccurved_guide_10_0_m;
MCNUM mcccurved_guide_10_0_W;
MCNUM mcccurved_guide_10_0_nslit;
MCNUM mcccurved_guide_10_0_d;
MCNUM mcccurved_guide_10_0_mleft;
MCNUM mcccurved_guide_10_0_mright;
MCNUM mcccurved_guide_10_0_mtop;
MCNUM mcccurved_guide_10_0_mbottom;
MCNUM mcccurved_guide_10_0_nhslit;
MCNUM mcccurved_guide_10_0_G;
MCNUM mcccurved_guide_10_0_aleft;
MCNUM mcccurved_guide_10_0_aright;
MCNUM mcccurved_guide_10_0_atop;
MCNUM mcccurved_guide_10_0_abottom;
MCNUM mcccurved_guide_10_0_wavy;
MCNUM mcccurved_guide_10_0_wavy_z;
MCNUM mcccurved_guide_10_0_wavy_tb;
MCNUM mcccurved_guide_10_0_wavy_lr;
MCNUM mcccurved_guide_10_0_chamfers;
MCNUM mcccurved_guide_10_0_chamfers_z;
MCNUM mcccurved_guide_10_0_chamfers_lr;
MCNUM mcccurved_guide_10_0_chamfers_tb;
MCNUM mcccurved_guide_10_0_nelements;
MCNUM mcccurved_guide_10_0_nu;
MCNUM mcccurved_guide_10_0_phase;
char mcccurved_guide_10_0_reflect[16384];

/* Setting parameters for component 'curved_guide_11_0' [18]. */
MCNUM mcccurved_guide_11_0_w1;
MCNUM mcccurved_guide_11_0_h1;
MCNUM mcccurved_guide_11_0_w2;
MCNUM mcccurved_guide_11_0_h2;
MCNUM mcccurved_guide_11_0_l;
MCNUM mcccurved_guide_11_0_R0;
MCNUM mcccurved_guide_11_0_Qc;
MCNUM mcccurved_guide_11_0_alpha;
MCNUM mcccurved_guide_11_0_m;
MCNUM mcccurved_guide_11_0_W;
MCNUM mcccurved_guide_11_0_nslit;
MCNUM mcccurved_guide_11_0_d;
MCNUM mcccurved_guide_11_0_mleft;
MCNUM mcccurved_guide_11_0_mright;
MCNUM mcccurved_guide_11_0_mtop;
MCNUM mcccurved_guide_11_0_mbottom;
MCNUM mcccurved_guide_11_0_nhslit;
MCNUM mcccurved_guide_11_0_G;
MCNUM mcccurved_guide_11_0_aleft;
MCNUM mcccurved_guide_11_0_aright;
MCNUM mcccurved_guide_11_0_atop;
MCNUM mcccurved_guide_11_0_abottom;
MCNUM mcccurved_guide_11_0_wavy;
MCNUM mcccurved_guide_11_0_wavy_z;
MCNUM mcccurved_guide_11_0_wavy_tb;
MCNUM mcccurved_guide_11_0_wavy_lr;
MCNUM mcccurved_guide_11_0_chamfers;
MCNUM mcccurved_guide_11_0_chamfers_z;
MCNUM mcccurved_guide_11_0_chamfers_lr;
MCNUM mcccurved_guide_11_0_chamfers_tb;
MCNUM mcccurved_guide_11_0_nelements;
MCNUM mcccurved_guide_11_0_nu;
MCNUM mcccurved_guide_11_0_phase;
char mcccurved_guide_11_0_reflect[16384];

/* Setting parameters for component 'curved_guide_12_0' [19]. */
MCNUM mcccurved_guide_12_0_w1;
MCNUM mcccurved_guide_12_0_h1;
MCNUM mcccurved_guide_12_0_w2;
MCNUM mcccurved_guide_12_0_h2;
MCNUM mcccurved_guide_12_0_l;
MCNUM mcccurved_guide_12_0_R0;
MCNUM mcccurved_guide_12_0_Qc;
MCNUM mcccurved_guide_12_0_alpha;
MCNUM mcccurved_guide_12_0_m;
MCNUM mcccurved_guide_12_0_W;
MCNUM mcccurved_guide_12_0_nslit;
MCNUM mcccurved_guide_12_0_d;
MCNUM mcccurved_guide_12_0_mleft;
MCNUM mcccurved_guide_12_0_mright;
MCNUM mcccurved_guide_12_0_mtop;
MCNUM mcccurved_guide_12_0_mbottom;
MCNUM mcccurved_guide_12_0_nhslit;
MCNUM mcccurved_guide_12_0_G;
MCNUM mcccurved_guide_12_0_aleft;
MCNUM mcccurved_guide_12_0_aright;
MCNUM mcccurved_guide_12_0_atop;
MCNUM mcccurved_guide_12_0_abottom;
MCNUM mcccurved_guide_12_0_wavy;
MCNUM mcccurved_guide_12_0_wavy_z;
MCNUM mcccurved_guide_12_0_wavy_tb;
MCNUM mcccurved_guide_12_0_wavy_lr;
MCNUM mcccurved_guide_12_0_chamfers;
MCNUM mcccurved_guide_12_0_chamfers_z;
MCNUM mcccurved_guide_12_0_chamfers_lr;
MCNUM mcccurved_guide_12_0_chamfers_tb;
MCNUM mcccurved_guide_12_0_nelements;
MCNUM mcccurved_guide_12_0_nu;
MCNUM mcccurved_guide_12_0_phase;
char mcccurved_guide_12_0_reflect[16384];

/* Setting parameters for component 'curved_guide_13_0' [20]. */
MCNUM mcccurved_guide_13_0_w1;
MCNUM mcccurved_guide_13_0_h1;
MCNUM mcccurved_guide_13_0_w2;
MCNUM mcccurved_guide_13_0_h2;
MCNUM mcccurved_guide_13_0_l;
MCNUM mcccurved_guide_13_0_R0;
MCNUM mcccurved_guide_13_0_Qc;
MCNUM mcccurved_guide_13_0_alpha;
MCNUM mcccurved_guide_13_0_m;
MCNUM mcccurved_guide_13_0_W;
MCNUM mcccurved_guide_13_0_nslit;
MCNUM mcccurved_guide_13_0_d;
MCNUM mcccurved_guide_13_0_mleft;
MCNUM mcccurved_guide_13_0_mright;
MCNUM mcccurved_guide_13_0_mtop;
MCNUM mcccurved_guide_13_0_mbottom;
MCNUM mcccurved_guide_13_0_nhslit;
MCNUM mcccurved_guide_13_0_G;
MCNUM mcccurved_guide_13_0_aleft;
MCNUM mcccurved_guide_13_0_aright;
MCNUM mcccurved_guide_13_0_atop;
MCNUM mcccurved_guide_13_0_abottom;
MCNUM mcccurved_guide_13_0_wavy;
MCNUM mcccurved_guide_13_0_wavy_z;
MCNUM mcccurved_guide_13_0_wavy_tb;
MCNUM mcccurved_guide_13_0_wavy_lr;
MCNUM mcccurved_guide_13_0_chamfers;
MCNUM mcccurved_guide_13_0_chamfers_z;
MCNUM mcccurved_guide_13_0_chamfers_lr;
MCNUM mcccurved_guide_13_0_chamfers_tb;
MCNUM mcccurved_guide_13_0_nelements;
MCNUM mcccurved_guide_13_0_nu;
MCNUM mcccurved_guide_13_0_phase;
char mcccurved_guide_13_0_reflect[16384];

/* Setting parameters for component 'curved_guide_14_0' [21]. */
MCNUM mcccurved_guide_14_0_w1;
MCNUM mcccurved_guide_14_0_h1;
MCNUM mcccurved_guide_14_0_w2;
MCNUM mcccurved_guide_14_0_h2;
MCNUM mcccurved_guide_14_0_l;
MCNUM mcccurved_guide_14_0_R0;
MCNUM mcccurved_guide_14_0_Qc;
MCNUM mcccurved_guide_14_0_alpha;
MCNUM mcccurved_guide_14_0_m;
MCNUM mcccurved_guide_14_0_W;
MCNUM mcccurved_guide_14_0_nslit;
MCNUM mcccurved_guide_14_0_d;
MCNUM mcccurved_guide_14_0_mleft;
MCNUM mcccurved_guide_14_0_mright;
MCNUM mcccurved_guide_14_0_mtop;
MCNUM mcccurved_guide_14_0_mbottom;
MCNUM mcccurved_guide_14_0_nhslit;
MCNUM mcccurved_guide_14_0_G;
MCNUM mcccurved_guide_14_0_aleft;
MCNUM mcccurved_guide_14_0_aright;
MCNUM mcccurved_guide_14_0_atop;
MCNUM mcccurved_guide_14_0_abottom;
MCNUM mcccurved_guide_14_0_wavy;
MCNUM mcccurved_guide_14_0_wavy_z;
MCNUM mcccurved_guide_14_0_wavy_tb;
MCNUM mcccurved_guide_14_0_wavy_lr;
MCNUM mcccurved_guide_14_0_chamfers;
MCNUM mcccurved_guide_14_0_chamfers_z;
MCNUM mcccurved_guide_14_0_chamfers_lr;
MCNUM mcccurved_guide_14_0_chamfers_tb;
MCNUM mcccurved_guide_14_0_nelements;
MCNUM mcccurved_guide_14_0_nu;
MCNUM mcccurved_guide_14_0_phase;
char mcccurved_guide_14_0_reflect[16384];

/* Setting parameters for component 'curved_guide_15_0' [22]. */
MCNUM mcccurved_guide_15_0_w1;
MCNUM mcccurved_guide_15_0_h1;
MCNUM mcccurved_guide_15_0_w2;
MCNUM mcccurved_guide_15_0_h2;
MCNUM mcccurved_guide_15_0_l;
MCNUM mcccurved_guide_15_0_R0;
MCNUM mcccurved_guide_15_0_Qc;
MCNUM mcccurved_guide_15_0_alpha;
MCNUM mcccurved_guide_15_0_m;
MCNUM mcccurved_guide_15_0_W;
MCNUM mcccurved_guide_15_0_nslit;
MCNUM mcccurved_guide_15_0_d;
MCNUM mcccurved_guide_15_0_mleft;
MCNUM mcccurved_guide_15_0_mright;
MCNUM mcccurved_guide_15_0_mtop;
MCNUM mcccurved_guide_15_0_mbottom;
MCNUM mcccurved_guide_15_0_nhslit;
MCNUM mcccurved_guide_15_0_G;
MCNUM mcccurved_guide_15_0_aleft;
MCNUM mcccurved_guide_15_0_aright;
MCNUM mcccurved_guide_15_0_atop;
MCNUM mcccurved_guide_15_0_abottom;
MCNUM mcccurved_guide_15_0_wavy;
MCNUM mcccurved_guide_15_0_wavy_z;
MCNUM mcccurved_guide_15_0_wavy_tb;
MCNUM mcccurved_guide_15_0_wavy_lr;
MCNUM mcccurved_guide_15_0_chamfers;
MCNUM mcccurved_guide_15_0_chamfers_z;
MCNUM mcccurved_guide_15_0_chamfers_lr;
MCNUM mcccurved_guide_15_0_chamfers_tb;
MCNUM mcccurved_guide_15_0_nelements;
MCNUM mcccurved_guide_15_0_nu;
MCNUM mcccurved_guide_15_0_phase;
char mcccurved_guide_15_0_reflect[16384];

/* Setting parameters for component 'curved_guide_16_0' [23]. */
MCNUM mcccurved_guide_16_0_w1;
MCNUM mcccurved_guide_16_0_h1;
MCNUM mcccurved_guide_16_0_w2;
MCNUM mcccurved_guide_16_0_h2;
MCNUM mcccurved_guide_16_0_l;
MCNUM mcccurved_guide_16_0_R0;
MCNUM mcccurved_guide_16_0_Qc;
MCNUM mcccurved_guide_16_0_alpha;
MCNUM mcccurved_guide_16_0_m;
MCNUM mcccurved_guide_16_0_W;
MCNUM mcccurved_guide_16_0_nslit;
MCNUM mcccurved_guide_16_0_d;
MCNUM mcccurved_guide_16_0_mleft;
MCNUM mcccurved_guide_16_0_mright;
MCNUM mcccurved_guide_16_0_mtop;
MCNUM mcccurved_guide_16_0_mbottom;
MCNUM mcccurved_guide_16_0_nhslit;
MCNUM mcccurved_guide_16_0_G;
MCNUM mcccurved_guide_16_0_aleft;
MCNUM mcccurved_guide_16_0_aright;
MCNUM mcccurved_guide_16_0_atop;
MCNUM mcccurved_guide_16_0_abottom;
MCNUM mcccurved_guide_16_0_wavy;
MCNUM mcccurved_guide_16_0_wavy_z;
MCNUM mcccurved_guide_16_0_wavy_tb;
MCNUM mcccurved_guide_16_0_wavy_lr;
MCNUM mcccurved_guide_16_0_chamfers;
MCNUM mcccurved_guide_16_0_chamfers_z;
MCNUM mcccurved_guide_16_0_chamfers_lr;
MCNUM mcccurved_guide_16_0_chamfers_tb;
MCNUM mcccurved_guide_16_0_nelements;
MCNUM mcccurved_guide_16_0_nu;
MCNUM mcccurved_guide_16_0_phase;
char mcccurved_guide_16_0_reflect[16384];

/* Setting parameters for component 'curved_guide_17_0' [24]. */
MCNUM mcccurved_guide_17_0_w1;
MCNUM mcccurved_guide_17_0_h1;
MCNUM mcccurved_guide_17_0_w2;
MCNUM mcccurved_guide_17_0_h2;
MCNUM mcccurved_guide_17_0_l;
MCNUM mcccurved_guide_17_0_R0;
MCNUM mcccurved_guide_17_0_Qc;
MCNUM mcccurved_guide_17_0_alpha;
MCNUM mcccurved_guide_17_0_m;
MCNUM mcccurved_guide_17_0_W;
MCNUM mcccurved_guide_17_0_nslit;
MCNUM mcccurved_guide_17_0_d;
MCNUM mcccurved_guide_17_0_mleft;
MCNUM mcccurved_guide_17_0_mright;
MCNUM mcccurved_guide_17_0_mtop;
MCNUM mcccurved_guide_17_0_mbottom;
MCNUM mcccurved_guide_17_0_nhslit;
MCNUM mcccurved_guide_17_0_G;
MCNUM mcccurved_guide_17_0_aleft;
MCNUM mcccurved_guide_17_0_aright;
MCNUM mcccurved_guide_17_0_atop;
MCNUM mcccurved_guide_17_0_abottom;
MCNUM mcccurved_guide_17_0_wavy;
MCNUM mcccurved_guide_17_0_wavy_z;
MCNUM mcccurved_guide_17_0_wavy_tb;
MCNUM mcccurved_guide_17_0_wavy_lr;
MCNUM mcccurved_guide_17_0_chamfers;
MCNUM mcccurved_guide_17_0_chamfers_z;
MCNUM mcccurved_guide_17_0_chamfers_lr;
MCNUM mcccurved_guide_17_0_chamfers_tb;
MCNUM mcccurved_guide_17_0_nelements;
MCNUM mcccurved_guide_17_0_nu;
MCNUM mcccurved_guide_17_0_phase;
char mcccurved_guide_17_0_reflect[16384];

/* Setting parameters for component 'curved_guide_18_beforeChopper' [25]. */
MCNUM mcccurved_guide_18_beforeChopper_w1;
MCNUM mcccurved_guide_18_beforeChopper_h1;
MCNUM mcccurved_guide_18_beforeChopper_w2;
MCNUM mcccurved_guide_18_beforeChopper_h2;
MCNUM mcccurved_guide_18_beforeChopper_l;
MCNUM mcccurved_guide_18_beforeChopper_R0;
MCNUM mcccurved_guide_18_beforeChopper_Qc;
MCNUM mcccurved_guide_18_beforeChopper_alpha;
MCNUM mcccurved_guide_18_beforeChopper_m;
MCNUM mcccurved_guide_18_beforeChopper_W;
MCNUM mcccurved_guide_18_beforeChopper_nslit;
MCNUM mcccurved_guide_18_beforeChopper_d;
MCNUM mcccurved_guide_18_beforeChopper_mleft;
MCNUM mcccurved_guide_18_beforeChopper_mright;
MCNUM mcccurved_guide_18_beforeChopper_mtop;
MCNUM mcccurved_guide_18_beforeChopper_mbottom;
MCNUM mcccurved_guide_18_beforeChopper_nhslit;
MCNUM mcccurved_guide_18_beforeChopper_G;
MCNUM mcccurved_guide_18_beforeChopper_aleft;
MCNUM mcccurved_guide_18_beforeChopper_aright;
MCNUM mcccurved_guide_18_beforeChopper_atop;
MCNUM mcccurved_guide_18_beforeChopper_abottom;
MCNUM mcccurved_guide_18_beforeChopper_wavy;
MCNUM mcccurved_guide_18_beforeChopper_wavy_z;
MCNUM mcccurved_guide_18_beforeChopper_wavy_tb;
MCNUM mcccurved_guide_18_beforeChopper_wavy_lr;
MCNUM mcccurved_guide_18_beforeChopper_chamfers;
MCNUM mcccurved_guide_18_beforeChopper_chamfers_z;
MCNUM mcccurved_guide_18_beforeChopper_chamfers_lr;
MCNUM mcccurved_guide_18_beforeChopper_chamfers_tb;
MCNUM mcccurved_guide_18_beforeChopper_nelements;
MCNUM mcccurved_guide_18_beforeChopper_nu;
MCNUM mcccurved_guide_18_beforeChopper_phase;
char mcccurved_guide_18_beforeChopper_reflect[16384];

/* Setting parameters for component 'curved_guide_18_afterChopper' [26]. */
MCNUM mcccurved_guide_18_afterChopper_w1;
MCNUM mcccurved_guide_18_afterChopper_h1;
MCNUM mcccurved_guide_18_afterChopper_w2;
MCNUM mcccurved_guide_18_afterChopper_h2;
MCNUM mcccurved_guide_18_afterChopper_l;
MCNUM mcccurved_guide_18_afterChopper_R0;
MCNUM mcccurved_guide_18_afterChopper_Qc;
MCNUM mcccurved_guide_18_afterChopper_alpha;
MCNUM mcccurved_guide_18_afterChopper_m;
MCNUM mcccurved_guide_18_afterChopper_W;
MCNUM mcccurved_guide_18_afterChopper_nslit;
MCNUM mcccurved_guide_18_afterChopper_d;
MCNUM mcccurved_guide_18_afterChopper_mleft;
MCNUM mcccurved_guide_18_afterChopper_mright;
MCNUM mcccurved_guide_18_afterChopper_mtop;
MCNUM mcccurved_guide_18_afterChopper_mbottom;
MCNUM mcccurved_guide_18_afterChopper_nhslit;
MCNUM mcccurved_guide_18_afterChopper_G;
MCNUM mcccurved_guide_18_afterChopper_aleft;
MCNUM mcccurved_guide_18_afterChopper_aright;
MCNUM mcccurved_guide_18_afterChopper_atop;
MCNUM mcccurved_guide_18_afterChopper_abottom;
MCNUM mcccurved_guide_18_afterChopper_wavy;
MCNUM mcccurved_guide_18_afterChopper_wavy_z;
MCNUM mcccurved_guide_18_afterChopper_wavy_tb;
MCNUM mcccurved_guide_18_afterChopper_wavy_lr;
MCNUM mcccurved_guide_18_afterChopper_chamfers;
MCNUM mcccurved_guide_18_afterChopper_chamfers_z;
MCNUM mcccurved_guide_18_afterChopper_chamfers_lr;
MCNUM mcccurved_guide_18_afterChopper_chamfers_tb;
MCNUM mcccurved_guide_18_afterChopper_nelements;
MCNUM mcccurved_guide_18_afterChopper_nu;
MCNUM mcccurved_guide_18_afterChopper_phase;
char mcccurved_guide_18_afterChopper_reflect[16384];

/* Setting parameters for component 'curved_guide_19_0' [27]. */
MCNUM mcccurved_guide_19_0_w1;
MCNUM mcccurved_guide_19_0_h1;
MCNUM mcccurved_guide_19_0_w2;
MCNUM mcccurved_guide_19_0_h2;
MCNUM mcccurved_guide_19_0_l;
MCNUM mcccurved_guide_19_0_R0;
MCNUM mcccurved_guide_19_0_Qc;
MCNUM mcccurved_guide_19_0_alpha;
MCNUM mcccurved_guide_19_0_m;
MCNUM mcccurved_guide_19_0_W;
MCNUM mcccurved_guide_19_0_nslit;
MCNUM mcccurved_guide_19_0_d;
MCNUM mcccurved_guide_19_0_mleft;
MCNUM mcccurved_guide_19_0_mright;
MCNUM mcccurved_guide_19_0_mtop;
MCNUM mcccurved_guide_19_0_mbottom;
MCNUM mcccurved_guide_19_0_nhslit;
MCNUM mcccurved_guide_19_0_G;
MCNUM mcccurved_guide_19_0_aleft;
MCNUM mcccurved_guide_19_0_aright;
MCNUM mcccurved_guide_19_0_atop;
MCNUM mcccurved_guide_19_0_abottom;
MCNUM mcccurved_guide_19_0_wavy;
MCNUM mcccurved_guide_19_0_wavy_z;
MCNUM mcccurved_guide_19_0_wavy_tb;
MCNUM mcccurved_guide_19_0_wavy_lr;
MCNUM mcccurved_guide_19_0_chamfers;
MCNUM mcccurved_guide_19_0_chamfers_z;
MCNUM mcccurved_guide_19_0_chamfers_lr;
MCNUM mcccurved_guide_19_0_chamfers_tb;
MCNUM mcccurved_guide_19_0_nelements;
MCNUM mcccurved_guide_19_0_nu;
MCNUM mcccurved_guide_19_0_phase;
char mcccurved_guide_19_0_reflect[16384];

/* Setting parameters for component 'curved_guide_20_0' [28]. */
MCNUM mcccurved_guide_20_0_w1;
MCNUM mcccurved_guide_20_0_h1;
MCNUM mcccurved_guide_20_0_w2;
MCNUM mcccurved_guide_20_0_h2;
MCNUM mcccurved_guide_20_0_l;
MCNUM mcccurved_guide_20_0_R0;
MCNUM mcccurved_guide_20_0_Qc;
MCNUM mcccurved_guide_20_0_alpha;
MCNUM mcccurved_guide_20_0_m;
MCNUM mcccurved_guide_20_0_W;
MCNUM mcccurved_guide_20_0_nslit;
MCNUM mcccurved_guide_20_0_d;
MCNUM mcccurved_guide_20_0_mleft;
MCNUM mcccurved_guide_20_0_mright;
MCNUM mcccurved_guide_20_0_mtop;
MCNUM mcccurved_guide_20_0_mbottom;
MCNUM mcccurved_guide_20_0_nhslit;
MCNUM mcccurved_guide_20_0_G;
MCNUM mcccurved_guide_20_0_aleft;
MCNUM mcccurved_guide_20_0_aright;
MCNUM mcccurved_guide_20_0_atop;
MCNUM mcccurved_guide_20_0_abottom;
MCNUM mcccurved_guide_20_0_wavy;
MCNUM mcccurved_guide_20_0_wavy_z;
MCNUM mcccurved_guide_20_0_wavy_tb;
MCNUM mcccurved_guide_20_0_wavy_lr;
MCNUM mcccurved_guide_20_0_chamfers;
MCNUM mcccurved_guide_20_0_chamfers_z;
MCNUM mcccurved_guide_20_0_chamfers_lr;
MCNUM mcccurved_guide_20_0_chamfers_tb;
MCNUM mcccurved_guide_20_0_nelements;
MCNUM mcccurved_guide_20_0_nu;
MCNUM mcccurved_guide_20_0_phase;
char mcccurved_guide_20_0_reflect[16384];

/* Setting parameters for component 'curved_guide_21_0' [29]. */
MCNUM mcccurved_guide_21_0_w1;
MCNUM mcccurved_guide_21_0_h1;
MCNUM mcccurved_guide_21_0_w2;
MCNUM mcccurved_guide_21_0_h2;
MCNUM mcccurved_guide_21_0_l;
MCNUM mcccurved_guide_21_0_R0;
MCNUM mcccurved_guide_21_0_Qc;
MCNUM mcccurved_guide_21_0_alpha;
MCNUM mcccurved_guide_21_0_m;
MCNUM mcccurved_guide_21_0_W;
MCNUM mcccurved_guide_21_0_nslit;
MCNUM mcccurved_guide_21_0_d;
MCNUM mcccurved_guide_21_0_mleft;
MCNUM mcccurved_guide_21_0_mright;
MCNUM mcccurved_guide_21_0_mtop;
MCNUM mcccurved_guide_21_0_mbottom;
MCNUM mcccurved_guide_21_0_nhslit;
MCNUM mcccurved_guide_21_0_G;
MCNUM mcccurved_guide_21_0_aleft;
MCNUM mcccurved_guide_21_0_aright;
MCNUM mcccurved_guide_21_0_atop;
MCNUM mcccurved_guide_21_0_abottom;
MCNUM mcccurved_guide_21_0_wavy;
MCNUM mcccurved_guide_21_0_wavy_z;
MCNUM mcccurved_guide_21_0_wavy_tb;
MCNUM mcccurved_guide_21_0_wavy_lr;
MCNUM mcccurved_guide_21_0_chamfers;
MCNUM mcccurved_guide_21_0_chamfers_z;
MCNUM mcccurved_guide_21_0_chamfers_lr;
MCNUM mcccurved_guide_21_0_chamfers_tb;
MCNUM mcccurved_guide_21_0_nelements;
MCNUM mcccurved_guide_21_0_nu;
MCNUM mcccurved_guide_21_0_phase;
char mcccurved_guide_21_0_reflect[16384];

/* Setting parameters for component 'curved_guide_22_0' [30]. */
MCNUM mcccurved_guide_22_0_w1;
MCNUM mcccurved_guide_22_0_h1;
MCNUM mcccurved_guide_22_0_w2;
MCNUM mcccurved_guide_22_0_h2;
MCNUM mcccurved_guide_22_0_l;
MCNUM mcccurved_guide_22_0_R0;
MCNUM mcccurved_guide_22_0_Qc;
MCNUM mcccurved_guide_22_0_alpha;
MCNUM mcccurved_guide_22_0_m;
MCNUM mcccurved_guide_22_0_W;
MCNUM mcccurved_guide_22_0_nslit;
MCNUM mcccurved_guide_22_0_d;
MCNUM mcccurved_guide_22_0_mleft;
MCNUM mcccurved_guide_22_0_mright;
MCNUM mcccurved_guide_22_0_mtop;
MCNUM mcccurved_guide_22_0_mbottom;
MCNUM mcccurved_guide_22_0_nhslit;
MCNUM mcccurved_guide_22_0_G;
MCNUM mcccurved_guide_22_0_aleft;
MCNUM mcccurved_guide_22_0_aright;
MCNUM mcccurved_guide_22_0_atop;
MCNUM mcccurved_guide_22_0_abottom;
MCNUM mcccurved_guide_22_0_wavy;
MCNUM mcccurved_guide_22_0_wavy_z;
MCNUM mcccurved_guide_22_0_wavy_tb;
MCNUM mcccurved_guide_22_0_wavy_lr;
MCNUM mcccurved_guide_22_0_chamfers;
MCNUM mcccurved_guide_22_0_chamfers_z;
MCNUM mcccurved_guide_22_0_chamfers_lr;
MCNUM mcccurved_guide_22_0_chamfers_tb;
MCNUM mcccurved_guide_22_0_nelements;
MCNUM mcccurved_guide_22_0_nu;
MCNUM mcccurved_guide_22_0_phase;
char mcccurved_guide_22_0_reflect[16384];

/* Setting parameters for component 'curved_guide_23_0' [31]. */
MCNUM mcccurved_guide_23_0_w1;
MCNUM mcccurved_guide_23_0_h1;
MCNUM mcccurved_guide_23_0_w2;
MCNUM mcccurved_guide_23_0_h2;
MCNUM mcccurved_guide_23_0_l;
MCNUM mcccurved_guide_23_0_R0;
MCNUM mcccurved_guide_23_0_Qc;
MCNUM mcccurved_guide_23_0_alpha;
MCNUM mcccurved_guide_23_0_m;
MCNUM mcccurved_guide_23_0_W;
MCNUM mcccurved_guide_23_0_nslit;
MCNUM mcccurved_guide_23_0_d;
MCNUM mcccurved_guide_23_0_mleft;
MCNUM mcccurved_guide_23_0_mright;
MCNUM mcccurved_guide_23_0_mtop;
MCNUM mcccurved_guide_23_0_mbottom;
MCNUM mcccurved_guide_23_0_nhslit;
MCNUM mcccurved_guide_23_0_G;
MCNUM mcccurved_guide_23_0_aleft;
MCNUM mcccurved_guide_23_0_aright;
MCNUM mcccurved_guide_23_0_atop;
MCNUM mcccurved_guide_23_0_abottom;
MCNUM mcccurved_guide_23_0_wavy;
MCNUM mcccurved_guide_23_0_wavy_z;
MCNUM mcccurved_guide_23_0_wavy_tb;
MCNUM mcccurved_guide_23_0_wavy_lr;
MCNUM mcccurved_guide_23_0_chamfers;
MCNUM mcccurved_guide_23_0_chamfers_z;
MCNUM mcccurved_guide_23_0_chamfers_lr;
MCNUM mcccurved_guide_23_0_chamfers_tb;
MCNUM mcccurved_guide_23_0_nelements;
MCNUM mcccurved_guide_23_0_nu;
MCNUM mcccurved_guide_23_0_phase;
char mcccurved_guide_23_0_reflect[16384];

/* Setting parameters for component 'curved_guide_24_0' [32]. */
MCNUM mcccurved_guide_24_0_w1;
MCNUM mcccurved_guide_24_0_h1;
MCNUM mcccurved_guide_24_0_w2;
MCNUM mcccurved_guide_24_0_h2;
MCNUM mcccurved_guide_24_0_l;
MCNUM mcccurved_guide_24_0_R0;
MCNUM mcccurved_guide_24_0_Qc;
MCNUM mcccurved_guide_24_0_alpha;
MCNUM mcccurved_guide_24_0_m;
MCNUM mcccurved_guide_24_0_W;
MCNUM mcccurved_guide_24_0_nslit;
MCNUM mcccurved_guide_24_0_d;
MCNUM mcccurved_guide_24_0_mleft;
MCNUM mcccurved_guide_24_0_mright;
MCNUM mcccurved_guide_24_0_mtop;
MCNUM mcccurved_guide_24_0_mbottom;
MCNUM mcccurved_guide_24_0_nhslit;
MCNUM mcccurved_guide_24_0_G;
MCNUM mcccurved_guide_24_0_aleft;
MCNUM mcccurved_guide_24_0_aright;
MCNUM mcccurved_guide_24_0_atop;
MCNUM mcccurved_guide_24_0_abottom;
MCNUM mcccurved_guide_24_0_wavy;
MCNUM mcccurved_guide_24_0_wavy_z;
MCNUM mcccurved_guide_24_0_wavy_tb;
MCNUM mcccurved_guide_24_0_wavy_lr;
MCNUM mcccurved_guide_24_0_chamfers;
MCNUM mcccurved_guide_24_0_chamfers_z;
MCNUM mcccurved_guide_24_0_chamfers_lr;
MCNUM mcccurved_guide_24_0_chamfers_tb;
MCNUM mcccurved_guide_24_0_nelements;
MCNUM mcccurved_guide_24_0_nu;
MCNUM mcccurved_guide_24_0_phase;
char mcccurved_guide_24_0_reflect[16384];

/* Setting parameters for component 'curved_guide_25_0' [33]. */
MCNUM mcccurved_guide_25_0_w1;
MCNUM mcccurved_guide_25_0_h1;
MCNUM mcccurved_guide_25_0_w2;
MCNUM mcccurved_guide_25_0_h2;
MCNUM mcccurved_guide_25_0_l;
MCNUM mcccurved_guide_25_0_R0;
MCNUM mcccurved_guide_25_0_Qc;
MCNUM mcccurved_guide_25_0_alpha;
MCNUM mcccurved_guide_25_0_m;
MCNUM mcccurved_guide_25_0_W;
MCNUM mcccurved_guide_25_0_nslit;
MCNUM mcccurved_guide_25_0_d;
MCNUM mcccurved_guide_25_0_mleft;
MCNUM mcccurved_guide_25_0_mright;
MCNUM mcccurved_guide_25_0_mtop;
MCNUM mcccurved_guide_25_0_mbottom;
MCNUM mcccurved_guide_25_0_nhslit;
MCNUM mcccurved_guide_25_0_G;
MCNUM mcccurved_guide_25_0_aleft;
MCNUM mcccurved_guide_25_0_aright;
MCNUM mcccurved_guide_25_0_atop;
MCNUM mcccurved_guide_25_0_abottom;
MCNUM mcccurved_guide_25_0_wavy;
MCNUM mcccurved_guide_25_0_wavy_z;
MCNUM mcccurved_guide_25_0_wavy_tb;
MCNUM mcccurved_guide_25_0_wavy_lr;
MCNUM mcccurved_guide_25_0_chamfers;
MCNUM mcccurved_guide_25_0_chamfers_z;
MCNUM mcccurved_guide_25_0_chamfers_lr;
MCNUM mcccurved_guide_25_0_chamfers_tb;
MCNUM mcccurved_guide_25_0_nelements;
MCNUM mcccurved_guide_25_0_nu;
MCNUM mcccurved_guide_25_0_phase;
char mcccurved_guide_25_0_reflect[16384];

/* Setting parameters for component 'curved_guide_26_0' [34]. */
MCNUM mcccurved_guide_26_0_w1;
MCNUM mcccurved_guide_26_0_h1;
MCNUM mcccurved_guide_26_0_w2;
MCNUM mcccurved_guide_26_0_h2;
MCNUM mcccurved_guide_26_0_l;
MCNUM mcccurved_guide_26_0_R0;
MCNUM mcccurved_guide_26_0_Qc;
MCNUM mcccurved_guide_26_0_alpha;
MCNUM mcccurved_guide_26_0_m;
MCNUM mcccurved_guide_26_0_W;
MCNUM mcccurved_guide_26_0_nslit;
MCNUM mcccurved_guide_26_0_d;
MCNUM mcccurved_guide_26_0_mleft;
MCNUM mcccurved_guide_26_0_mright;
MCNUM mcccurved_guide_26_0_mtop;
MCNUM mcccurved_guide_26_0_mbottom;
MCNUM mcccurved_guide_26_0_nhslit;
MCNUM mcccurved_guide_26_0_G;
MCNUM mcccurved_guide_26_0_aleft;
MCNUM mcccurved_guide_26_0_aright;
MCNUM mcccurved_guide_26_0_atop;
MCNUM mcccurved_guide_26_0_abottom;
MCNUM mcccurved_guide_26_0_wavy;
MCNUM mcccurved_guide_26_0_wavy_z;
MCNUM mcccurved_guide_26_0_wavy_tb;
MCNUM mcccurved_guide_26_0_wavy_lr;
MCNUM mcccurved_guide_26_0_chamfers;
MCNUM mcccurved_guide_26_0_chamfers_z;
MCNUM mcccurved_guide_26_0_chamfers_lr;
MCNUM mcccurved_guide_26_0_chamfers_tb;
MCNUM mcccurved_guide_26_0_nelements;
MCNUM mcccurved_guide_26_0_nu;
MCNUM mcccurved_guide_26_0_phase;
char mcccurved_guide_26_0_reflect[16384];

/* Setting parameters for component 'curved_guide_27_0' [35]. */
MCNUM mcccurved_guide_27_0_w1;
MCNUM mcccurved_guide_27_0_h1;
MCNUM mcccurved_guide_27_0_w2;
MCNUM mcccurved_guide_27_0_h2;
MCNUM mcccurved_guide_27_0_l;
MCNUM mcccurved_guide_27_0_R0;
MCNUM mcccurved_guide_27_0_Qc;
MCNUM mcccurved_guide_27_0_alpha;
MCNUM mcccurved_guide_27_0_m;
MCNUM mcccurved_guide_27_0_W;
MCNUM mcccurved_guide_27_0_nslit;
MCNUM mcccurved_guide_27_0_d;
MCNUM mcccurved_guide_27_0_mleft;
MCNUM mcccurved_guide_27_0_mright;
MCNUM mcccurved_guide_27_0_mtop;
MCNUM mcccurved_guide_27_0_mbottom;
MCNUM mcccurved_guide_27_0_nhslit;
MCNUM mcccurved_guide_27_0_G;
MCNUM mcccurved_guide_27_0_aleft;
MCNUM mcccurved_guide_27_0_aright;
MCNUM mcccurved_guide_27_0_atop;
MCNUM mcccurved_guide_27_0_abottom;
MCNUM mcccurved_guide_27_0_wavy;
MCNUM mcccurved_guide_27_0_wavy_z;
MCNUM mcccurved_guide_27_0_wavy_tb;
MCNUM mcccurved_guide_27_0_wavy_lr;
MCNUM mcccurved_guide_27_0_chamfers;
MCNUM mcccurved_guide_27_0_chamfers_z;
MCNUM mcccurved_guide_27_0_chamfers_lr;
MCNUM mcccurved_guide_27_0_chamfers_tb;
MCNUM mcccurved_guide_27_0_nelements;
MCNUM mcccurved_guide_27_0_nu;
MCNUM mcccurved_guide_27_0_phase;
char mcccurved_guide_27_0_reflect[16384];

/* Setting parameters for component 'curved_guide_28_0' [36]. */
MCNUM mcccurved_guide_28_0_w1;
MCNUM mcccurved_guide_28_0_h1;
MCNUM mcccurved_guide_28_0_w2;
MCNUM mcccurved_guide_28_0_h2;
MCNUM mcccurved_guide_28_0_l;
MCNUM mcccurved_guide_28_0_R0;
MCNUM mcccurved_guide_28_0_Qc;
MCNUM mcccurved_guide_28_0_alpha;
MCNUM mcccurved_guide_28_0_m;
MCNUM mcccurved_guide_28_0_W;
MCNUM mcccurved_guide_28_0_nslit;
MCNUM mcccurved_guide_28_0_d;
MCNUM mcccurved_guide_28_0_mleft;
MCNUM mcccurved_guide_28_0_mright;
MCNUM mcccurved_guide_28_0_mtop;
MCNUM mcccurved_guide_28_0_mbottom;
MCNUM mcccurved_guide_28_0_nhslit;
MCNUM mcccurved_guide_28_0_G;
MCNUM mcccurved_guide_28_0_aleft;
MCNUM mcccurved_guide_28_0_aright;
MCNUM mcccurved_guide_28_0_atop;
MCNUM mcccurved_guide_28_0_abottom;
MCNUM mcccurved_guide_28_0_wavy;
MCNUM mcccurved_guide_28_0_wavy_z;
MCNUM mcccurved_guide_28_0_wavy_tb;
MCNUM mcccurved_guide_28_0_wavy_lr;
MCNUM mcccurved_guide_28_0_chamfers;
MCNUM mcccurved_guide_28_0_chamfers_z;
MCNUM mcccurved_guide_28_0_chamfers_lr;
MCNUM mcccurved_guide_28_0_chamfers_tb;
MCNUM mcccurved_guide_28_0_nelements;
MCNUM mcccurved_guide_28_0_nu;
MCNUM mcccurved_guide_28_0_phase;
char mcccurved_guide_28_0_reflect[16384];

/* Setting parameters for component 'curved_guide_29_0' [37]. */
MCNUM mcccurved_guide_29_0_w1;
MCNUM mcccurved_guide_29_0_h1;
MCNUM mcccurved_guide_29_0_w2;
MCNUM mcccurved_guide_29_0_h2;
MCNUM mcccurved_guide_29_0_l;
MCNUM mcccurved_guide_29_0_R0;
MCNUM mcccurved_guide_29_0_Qc;
MCNUM mcccurved_guide_29_0_alpha;
MCNUM mcccurved_guide_29_0_m;
MCNUM mcccurved_guide_29_0_W;
MCNUM mcccurved_guide_29_0_nslit;
MCNUM mcccurved_guide_29_0_d;
MCNUM mcccurved_guide_29_0_mleft;
MCNUM mcccurved_guide_29_0_mright;
MCNUM mcccurved_guide_29_0_mtop;
MCNUM mcccurved_guide_29_0_mbottom;
MCNUM mcccurved_guide_29_0_nhslit;
MCNUM mcccurved_guide_29_0_G;
MCNUM mcccurved_guide_29_0_aleft;
MCNUM mcccurved_guide_29_0_aright;
MCNUM mcccurved_guide_29_0_atop;
MCNUM mcccurved_guide_29_0_abottom;
MCNUM mcccurved_guide_29_0_wavy;
MCNUM mcccurved_guide_29_0_wavy_z;
MCNUM mcccurved_guide_29_0_wavy_tb;
MCNUM mcccurved_guide_29_0_wavy_lr;
MCNUM mcccurved_guide_29_0_chamfers;
MCNUM mcccurved_guide_29_0_chamfers_z;
MCNUM mcccurved_guide_29_0_chamfers_lr;
MCNUM mcccurved_guide_29_0_chamfers_tb;
MCNUM mcccurved_guide_29_0_nelements;
MCNUM mcccurved_guide_29_0_nu;
MCNUM mcccurved_guide_29_0_phase;
char mcccurved_guide_29_0_reflect[16384];

/* Setting parameters for component 'curved_guide_30_0' [38]. */
MCNUM mcccurved_guide_30_0_w1;
MCNUM mcccurved_guide_30_0_h1;
MCNUM mcccurved_guide_30_0_w2;
MCNUM mcccurved_guide_30_0_h2;
MCNUM mcccurved_guide_30_0_l;
MCNUM mcccurved_guide_30_0_R0;
MCNUM mcccurved_guide_30_0_Qc;
MCNUM mcccurved_guide_30_0_alpha;
MCNUM mcccurved_guide_30_0_m;
MCNUM mcccurved_guide_30_0_W;
MCNUM mcccurved_guide_30_0_nslit;
MCNUM mcccurved_guide_30_0_d;
MCNUM mcccurved_guide_30_0_mleft;
MCNUM mcccurved_guide_30_0_mright;
MCNUM mcccurved_guide_30_0_mtop;
MCNUM mcccurved_guide_30_0_mbottom;
MCNUM mcccurved_guide_30_0_nhslit;
MCNUM mcccurved_guide_30_0_G;
MCNUM mcccurved_guide_30_0_aleft;
MCNUM mcccurved_guide_30_0_aright;
MCNUM mcccurved_guide_30_0_atop;
MCNUM mcccurved_guide_30_0_abottom;
MCNUM mcccurved_guide_30_0_wavy;
MCNUM mcccurved_guide_30_0_wavy_z;
MCNUM mcccurved_guide_30_0_wavy_tb;
MCNUM mcccurved_guide_30_0_wavy_lr;
MCNUM mcccurved_guide_30_0_chamfers;
MCNUM mcccurved_guide_30_0_chamfers_z;
MCNUM mcccurved_guide_30_0_chamfers_lr;
MCNUM mcccurved_guide_30_0_chamfers_tb;
MCNUM mcccurved_guide_30_0_nelements;
MCNUM mcccurved_guide_30_0_nu;
MCNUM mcccurved_guide_30_0_phase;
char mcccurved_guide_30_0_reflect[16384];

/* Setting parameters for component 'curved_guide_31_0' [39]. */
MCNUM mcccurved_guide_31_0_w1;
MCNUM mcccurved_guide_31_0_h1;
MCNUM mcccurved_guide_31_0_w2;
MCNUM mcccurved_guide_31_0_h2;
MCNUM mcccurved_guide_31_0_l;
MCNUM mcccurved_guide_31_0_R0;
MCNUM mcccurved_guide_31_0_Qc;
MCNUM mcccurved_guide_31_0_alpha;
MCNUM mcccurved_guide_31_0_m;
MCNUM mcccurved_guide_31_0_W;
MCNUM mcccurved_guide_31_0_nslit;
MCNUM mcccurved_guide_31_0_d;
MCNUM mcccurved_guide_31_0_mleft;
MCNUM mcccurved_guide_31_0_mright;
MCNUM mcccurved_guide_31_0_mtop;
MCNUM mcccurved_guide_31_0_mbottom;
MCNUM mcccurved_guide_31_0_nhslit;
MCNUM mcccurved_guide_31_0_G;
MCNUM mcccurved_guide_31_0_aleft;
MCNUM mcccurved_guide_31_0_aright;
MCNUM mcccurved_guide_31_0_atop;
MCNUM mcccurved_guide_31_0_abottom;
MCNUM mcccurved_guide_31_0_wavy;
MCNUM mcccurved_guide_31_0_wavy_z;
MCNUM mcccurved_guide_31_0_wavy_tb;
MCNUM mcccurved_guide_31_0_wavy_lr;
MCNUM mcccurved_guide_31_0_chamfers;
MCNUM mcccurved_guide_31_0_chamfers_z;
MCNUM mcccurved_guide_31_0_chamfers_lr;
MCNUM mcccurved_guide_31_0_chamfers_tb;
MCNUM mcccurved_guide_31_0_nelements;
MCNUM mcccurved_guide_31_0_nu;
MCNUM mcccurved_guide_31_0_phase;
char mcccurved_guide_31_0_reflect[16384];

/* Setting parameters for component 'curved_guide_32_0' [40]. */
MCNUM mcccurved_guide_32_0_w1;
MCNUM mcccurved_guide_32_0_h1;
MCNUM mcccurved_guide_32_0_w2;
MCNUM mcccurved_guide_32_0_h2;
MCNUM mcccurved_guide_32_0_l;
MCNUM mcccurved_guide_32_0_R0;
MCNUM mcccurved_guide_32_0_Qc;
MCNUM mcccurved_guide_32_0_alpha;
MCNUM mcccurved_guide_32_0_m;
MCNUM mcccurved_guide_32_0_W;
MCNUM mcccurved_guide_32_0_nslit;
MCNUM mcccurved_guide_32_0_d;
MCNUM mcccurved_guide_32_0_mleft;
MCNUM mcccurved_guide_32_0_mright;
MCNUM mcccurved_guide_32_0_mtop;
MCNUM mcccurved_guide_32_0_mbottom;
MCNUM mcccurved_guide_32_0_nhslit;
MCNUM mcccurved_guide_32_0_G;
MCNUM mcccurved_guide_32_0_aleft;
MCNUM mcccurved_guide_32_0_aright;
MCNUM mcccurved_guide_32_0_atop;
MCNUM mcccurved_guide_32_0_abottom;
MCNUM mcccurved_guide_32_0_wavy;
MCNUM mcccurved_guide_32_0_wavy_z;
MCNUM mcccurved_guide_32_0_wavy_tb;
MCNUM mcccurved_guide_32_0_wavy_lr;
MCNUM mcccurved_guide_32_0_chamfers;
MCNUM mcccurved_guide_32_0_chamfers_z;
MCNUM mcccurved_guide_32_0_chamfers_lr;
MCNUM mcccurved_guide_32_0_chamfers_tb;
MCNUM mcccurved_guide_32_0_nelements;
MCNUM mcccurved_guide_32_0_nu;
MCNUM mcccurved_guide_32_0_phase;
char mcccurved_guide_32_0_reflect[16384];

/* Setting parameters for component 'curved_guide_33_0' [41]. */
MCNUM mcccurved_guide_33_0_w1;
MCNUM mcccurved_guide_33_0_h1;
MCNUM mcccurved_guide_33_0_w2;
MCNUM mcccurved_guide_33_0_h2;
MCNUM mcccurved_guide_33_0_l;
MCNUM mcccurved_guide_33_0_R0;
MCNUM mcccurved_guide_33_0_Qc;
MCNUM mcccurved_guide_33_0_alpha;
MCNUM mcccurved_guide_33_0_m;
MCNUM mcccurved_guide_33_0_W;
MCNUM mcccurved_guide_33_0_nslit;
MCNUM mcccurved_guide_33_0_d;
MCNUM mcccurved_guide_33_0_mleft;
MCNUM mcccurved_guide_33_0_mright;
MCNUM mcccurved_guide_33_0_mtop;
MCNUM mcccurved_guide_33_0_mbottom;
MCNUM mcccurved_guide_33_0_nhslit;
MCNUM mcccurved_guide_33_0_G;
MCNUM mcccurved_guide_33_0_aleft;
MCNUM mcccurved_guide_33_0_aright;
MCNUM mcccurved_guide_33_0_atop;
MCNUM mcccurved_guide_33_0_abottom;
MCNUM mcccurved_guide_33_0_wavy;
MCNUM mcccurved_guide_33_0_wavy_z;
MCNUM mcccurved_guide_33_0_wavy_tb;
MCNUM mcccurved_guide_33_0_wavy_lr;
MCNUM mcccurved_guide_33_0_chamfers;
MCNUM mcccurved_guide_33_0_chamfers_z;
MCNUM mcccurved_guide_33_0_chamfers_lr;
MCNUM mcccurved_guide_33_0_chamfers_tb;
MCNUM mcccurved_guide_33_0_nelements;
MCNUM mcccurved_guide_33_0_nu;
MCNUM mcccurved_guide_33_0_phase;
char mcccurved_guide_33_0_reflect[16384];

/* Setting parameters for component 'curved_guide_34_0' [42]. */
MCNUM mcccurved_guide_34_0_w1;
MCNUM mcccurved_guide_34_0_h1;
MCNUM mcccurved_guide_34_0_w2;
MCNUM mcccurved_guide_34_0_h2;
MCNUM mcccurved_guide_34_0_l;
MCNUM mcccurved_guide_34_0_R0;
MCNUM mcccurved_guide_34_0_Qc;
MCNUM mcccurved_guide_34_0_alpha;
MCNUM mcccurved_guide_34_0_m;
MCNUM mcccurved_guide_34_0_W;
MCNUM mcccurved_guide_34_0_nslit;
MCNUM mcccurved_guide_34_0_d;
MCNUM mcccurved_guide_34_0_mleft;
MCNUM mcccurved_guide_34_0_mright;
MCNUM mcccurved_guide_34_0_mtop;
MCNUM mcccurved_guide_34_0_mbottom;
MCNUM mcccurved_guide_34_0_nhslit;
MCNUM mcccurved_guide_34_0_G;
MCNUM mcccurved_guide_34_0_aleft;
MCNUM mcccurved_guide_34_0_aright;
MCNUM mcccurved_guide_34_0_atop;
MCNUM mcccurved_guide_34_0_abottom;
MCNUM mcccurved_guide_34_0_wavy;
MCNUM mcccurved_guide_34_0_wavy_z;
MCNUM mcccurved_guide_34_0_wavy_tb;
MCNUM mcccurved_guide_34_0_wavy_lr;
MCNUM mcccurved_guide_34_0_chamfers;
MCNUM mcccurved_guide_34_0_chamfers_z;
MCNUM mcccurved_guide_34_0_chamfers_lr;
MCNUM mcccurved_guide_34_0_chamfers_tb;
MCNUM mcccurved_guide_34_0_nelements;
MCNUM mcccurved_guide_34_0_nu;
MCNUM mcccurved_guide_34_0_phase;
char mcccurved_guide_34_0_reflect[16384];

/* Setting parameters for component 'curved_guide_35_0' [43]. */
MCNUM mcccurved_guide_35_0_w1;
MCNUM mcccurved_guide_35_0_h1;
MCNUM mcccurved_guide_35_0_w2;
MCNUM mcccurved_guide_35_0_h2;
MCNUM mcccurved_guide_35_0_l;
MCNUM mcccurved_guide_35_0_R0;
MCNUM mcccurved_guide_35_0_Qc;
MCNUM mcccurved_guide_35_0_alpha;
MCNUM mcccurved_guide_35_0_m;
MCNUM mcccurved_guide_35_0_W;
MCNUM mcccurved_guide_35_0_nslit;
MCNUM mcccurved_guide_35_0_d;
MCNUM mcccurved_guide_35_0_mleft;
MCNUM mcccurved_guide_35_0_mright;
MCNUM mcccurved_guide_35_0_mtop;
MCNUM mcccurved_guide_35_0_mbottom;
MCNUM mcccurved_guide_35_0_nhslit;
MCNUM mcccurved_guide_35_0_G;
MCNUM mcccurved_guide_35_0_aleft;
MCNUM mcccurved_guide_35_0_aright;
MCNUM mcccurved_guide_35_0_atop;
MCNUM mcccurved_guide_35_0_abottom;
MCNUM mcccurved_guide_35_0_wavy;
MCNUM mcccurved_guide_35_0_wavy_z;
MCNUM mcccurved_guide_35_0_wavy_tb;
MCNUM mcccurved_guide_35_0_wavy_lr;
MCNUM mcccurved_guide_35_0_chamfers;
MCNUM mcccurved_guide_35_0_chamfers_z;
MCNUM mcccurved_guide_35_0_chamfers_lr;
MCNUM mcccurved_guide_35_0_chamfers_tb;
MCNUM mcccurved_guide_35_0_nelements;
MCNUM mcccurved_guide_35_0_nu;
MCNUM mcccurved_guide_35_0_phase;
char mcccurved_guide_35_0_reflect[16384];

/* Setting parameters for component 'curved_guide_36_0' [44]. */
MCNUM mcccurved_guide_36_0_w1;
MCNUM mcccurved_guide_36_0_h1;
MCNUM mcccurved_guide_36_0_w2;
MCNUM mcccurved_guide_36_0_h2;
MCNUM mcccurved_guide_36_0_l;
MCNUM mcccurved_guide_36_0_R0;
MCNUM mcccurved_guide_36_0_Qc;
MCNUM mcccurved_guide_36_0_alpha;
MCNUM mcccurved_guide_36_0_m;
MCNUM mcccurved_guide_36_0_W;
MCNUM mcccurved_guide_36_0_nslit;
MCNUM mcccurved_guide_36_0_d;
MCNUM mcccurved_guide_36_0_mleft;
MCNUM mcccurved_guide_36_0_mright;
MCNUM mcccurved_guide_36_0_mtop;
MCNUM mcccurved_guide_36_0_mbottom;
MCNUM mcccurved_guide_36_0_nhslit;
MCNUM mcccurved_guide_36_0_G;
MCNUM mcccurved_guide_36_0_aleft;
MCNUM mcccurved_guide_36_0_aright;
MCNUM mcccurved_guide_36_0_atop;
MCNUM mcccurved_guide_36_0_abottom;
MCNUM mcccurved_guide_36_0_wavy;
MCNUM mcccurved_guide_36_0_wavy_z;
MCNUM mcccurved_guide_36_0_wavy_tb;
MCNUM mcccurved_guide_36_0_wavy_lr;
MCNUM mcccurved_guide_36_0_chamfers;
MCNUM mcccurved_guide_36_0_chamfers_z;
MCNUM mcccurved_guide_36_0_chamfers_lr;
MCNUM mcccurved_guide_36_0_chamfers_tb;
MCNUM mcccurved_guide_36_0_nelements;
MCNUM mcccurved_guide_36_0_nu;
MCNUM mcccurved_guide_36_0_phase;
char mcccurved_guide_36_0_reflect[16384];

/* Definition parameters for component 'elliptical_guide_gravity3' [47]. */
#define mccelliptical_guide_gravity3_mvaluesright mValues3horizontalS
#define mccelliptical_guide_gravity3_mvaluesleft mValues3horizontalS
#define mccelliptical_guide_gravity3_mvaluestop mValues3verticalS
#define mccelliptical_guide_gravity3_mvaluesbottom mValues3verticalS
#define mccelliptical_guide_gravity3_seglength elementLength3S
/* Setting parameters for component 'elliptical_guide_gravity3' [47]. */
MCNUM mccelliptical_guide_gravity3_l;
MCNUM mccelliptical_guide_gravity3_xwidth;
MCNUM mccelliptical_guide_gravity3_yheight;
MCNUM mccelliptical_guide_gravity3_linxw;
MCNUM mccelliptical_guide_gravity3_loutxw;
MCNUM mccelliptical_guide_gravity3_linyh;
MCNUM mccelliptical_guide_gravity3_loutyh;
MCNUM mccelliptical_guide_gravity3_majorAxisxw;
MCNUM mccelliptical_guide_gravity3_minorAxisxw;
MCNUM mccelliptical_guide_gravity3_majorAxisyh;
MCNUM mccelliptical_guide_gravity3_minorAxisyh;
MCNUM mccelliptical_guide_gravity3_majorAxisoffsetxw;
MCNUM mccelliptical_guide_gravity3_majorAxisoffsetyh;
char mccelliptical_guide_gravity3_dimensionsAt[16384];
char mccelliptical_guide_gravity3_option[16384];
MCNUM mccelliptical_guide_gravity3_R0;
MCNUM mccelliptical_guide_gravity3_Qc;
MCNUM mccelliptical_guide_gravity3_alpha;
MCNUM mccelliptical_guide_gravity3_m;
MCNUM mccelliptical_guide_gravity3_W;
MCNUM mccelliptical_guide_gravity3_alpharight;
MCNUM mccelliptical_guide_gravity3_mright;
MCNUM mccelliptical_guide_gravity3_alphaleft;
MCNUM mccelliptical_guide_gravity3_mleft;
MCNUM mccelliptical_guide_gravity3_alphatop;
MCNUM mccelliptical_guide_gravity3_mtop;
MCNUM mccelliptical_guide_gravity3_alphabottom;
MCNUM mccelliptical_guide_gravity3_mbottom;
char mccelliptical_guide_gravity3_verbose[16384];
MCNUM mccelliptical_guide_gravity3_enableGravity;
MCNUM mccelliptical_guide_gravity3_curvature;

/* Setting parameters for component 'straight_guide_2_1' [49]. */
MCNUM mccstraight_guide_2_1_w1;
MCNUM mccstraight_guide_2_1_h1;
MCNUM mccstraight_guide_2_1_w2;
MCNUM mccstraight_guide_2_1_h2;
MCNUM mccstraight_guide_2_1_l;
MCNUM mccstraight_guide_2_1_R0;
MCNUM mccstraight_guide_2_1_Qc;
MCNUM mccstraight_guide_2_1_alpha;
MCNUM mccstraight_guide_2_1_m;
MCNUM mccstraight_guide_2_1_W;
MCNUM mccstraight_guide_2_1_nslit;
MCNUM mccstraight_guide_2_1_d;
MCNUM mccstraight_guide_2_1_mleft;
MCNUM mccstraight_guide_2_1_mright;
MCNUM mccstraight_guide_2_1_mtop;
MCNUM mccstraight_guide_2_1_mbottom;
MCNUM mccstraight_guide_2_1_nhslit;
MCNUM mccstraight_guide_2_1_G;
MCNUM mccstraight_guide_2_1_aleft;
MCNUM mccstraight_guide_2_1_aright;
MCNUM mccstraight_guide_2_1_atop;
MCNUM mccstraight_guide_2_1_abottom;
MCNUM mccstraight_guide_2_1_wavy;
MCNUM mccstraight_guide_2_1_wavy_z;
MCNUM mccstraight_guide_2_1_wavy_tb;
MCNUM mccstraight_guide_2_1_wavy_lr;
MCNUM mccstraight_guide_2_1_chamfers;
MCNUM mccstraight_guide_2_1_chamfers_z;
MCNUM mccstraight_guide_2_1_chamfers_lr;
MCNUM mccstraight_guide_2_1_chamfers_tb;
MCNUM mccstraight_guide_2_1_nelements;
MCNUM mccstraight_guide_2_1_nu;
MCNUM mccstraight_guide_2_1_phase;
char mccstraight_guide_2_1_reflect[16384];

/* Setting parameters for component 'straight_guide_2_2' [50]. */
MCNUM mccstraight_guide_2_2_w1;
MCNUM mccstraight_guide_2_2_h1;
MCNUM mccstraight_guide_2_2_w2;
MCNUM mccstraight_guide_2_2_h2;
MCNUM mccstraight_guide_2_2_l;
MCNUM mccstraight_guide_2_2_R0;
MCNUM mccstraight_guide_2_2_Qc;
MCNUM mccstraight_guide_2_2_alpha;
MCNUM mccstraight_guide_2_2_m;
MCNUM mccstraight_guide_2_2_W;
MCNUM mccstraight_guide_2_2_nslit;
MCNUM mccstraight_guide_2_2_d;
MCNUM mccstraight_guide_2_2_mleft;
MCNUM mccstraight_guide_2_2_mright;
MCNUM mccstraight_guide_2_2_mtop;
MCNUM mccstraight_guide_2_2_mbottom;
MCNUM mccstraight_guide_2_2_nhslit;
MCNUM mccstraight_guide_2_2_G;
MCNUM mccstraight_guide_2_2_aleft;
MCNUM mccstraight_guide_2_2_aright;
MCNUM mccstraight_guide_2_2_atop;
MCNUM mccstraight_guide_2_2_abottom;
MCNUM mccstraight_guide_2_2_wavy;
MCNUM mccstraight_guide_2_2_wavy_z;
MCNUM mccstraight_guide_2_2_wavy_tb;
MCNUM mccstraight_guide_2_2_wavy_lr;
MCNUM mccstraight_guide_2_2_chamfers;
MCNUM mccstraight_guide_2_2_chamfers_z;
MCNUM mccstraight_guide_2_2_chamfers_lr;
MCNUM mccstraight_guide_2_2_chamfers_tb;
MCNUM mccstraight_guide_2_2_nelements;
MCNUM mccstraight_guide_2_2_nu;
MCNUM mccstraight_guide_2_2_phase;
char mccstraight_guide_2_2_reflect[16384];

/* Definition parameters for component 'elliptical_guide_gravity1_1' [52]. */
#define mccelliptical_guide_gravity1_1_mvaluesright mValues1horizontal_part_1
#define mccelliptical_guide_gravity1_1_mvaluesleft mValues1horizontal_part_1
#define mccelliptical_guide_gravity1_1_mvaluestop mValues1vertical_part_1
#define mccelliptical_guide_gravity1_1_mvaluesbottom mValues1vertical_part_1
#define mccelliptical_guide_gravity1_1_seglength elementLength1_part_1
/* Setting parameters for component 'elliptical_guide_gravity1_1' [52]. */
MCNUM mccelliptical_guide_gravity1_1_l;
MCNUM mccelliptical_guide_gravity1_1_xwidth;
MCNUM mccelliptical_guide_gravity1_1_yheight;
MCNUM mccelliptical_guide_gravity1_1_linxw;
MCNUM mccelliptical_guide_gravity1_1_loutxw;
MCNUM mccelliptical_guide_gravity1_1_linyh;
MCNUM mccelliptical_guide_gravity1_1_loutyh;
MCNUM mccelliptical_guide_gravity1_1_majorAxisxw;
MCNUM mccelliptical_guide_gravity1_1_minorAxisxw;
MCNUM mccelliptical_guide_gravity1_1_majorAxisyh;
MCNUM mccelliptical_guide_gravity1_1_minorAxisyh;
MCNUM mccelliptical_guide_gravity1_1_majorAxisoffsetxw;
MCNUM mccelliptical_guide_gravity1_1_majorAxisoffsetyh;
char mccelliptical_guide_gravity1_1_dimensionsAt[16384];
char mccelliptical_guide_gravity1_1_option[16384];
MCNUM mccelliptical_guide_gravity1_1_R0;
MCNUM mccelliptical_guide_gravity1_1_Qc;
MCNUM mccelliptical_guide_gravity1_1_alpha;
MCNUM mccelliptical_guide_gravity1_1_m;
MCNUM mccelliptical_guide_gravity1_1_W;
MCNUM mccelliptical_guide_gravity1_1_alpharight;
MCNUM mccelliptical_guide_gravity1_1_mright;
MCNUM mccelliptical_guide_gravity1_1_alphaleft;
MCNUM mccelliptical_guide_gravity1_1_mleft;
MCNUM mccelliptical_guide_gravity1_1_alphatop;
MCNUM mccelliptical_guide_gravity1_1_mtop;
MCNUM mccelliptical_guide_gravity1_1_alphabottom;
MCNUM mccelliptical_guide_gravity1_1_mbottom;
char mccelliptical_guide_gravity1_1_verbose[16384];
MCNUM mccelliptical_guide_gravity1_1_enableGravity;
MCNUM mccelliptical_guide_gravity1_1_curvature;

/* Setting parameters for component 'DiwJaw3' [53]. */
MCNUM mccDiwJaw3_xmin;
MCNUM mccDiwJaw3_xmax;
MCNUM mccDiwJaw3_ymin;
MCNUM mccDiwJaw3_ymax;
MCNUM mccDiwJaw3_radius;
MCNUM mccDiwJaw3_xwidth;
MCNUM mccDiwJaw3_yheight;

/* Definition parameters for component 'elliptical_guide_gravity1_2' [54]. */
#define mccelliptical_guide_gravity1_2_mvaluesright mValues1horizontal_part_2
#define mccelliptical_guide_gravity1_2_mvaluesleft mValues1horizontal_part_2
#define mccelliptical_guide_gravity1_2_mvaluestop mValues1vertical_part_2
#define mccelliptical_guide_gravity1_2_mvaluesbottom mValues1vertical_part_2
#define mccelliptical_guide_gravity1_2_seglength elementLength1_part_2
/* Setting parameters for component 'elliptical_guide_gravity1_2' [54]. */
MCNUM mccelliptical_guide_gravity1_2_l;
MCNUM mccelliptical_guide_gravity1_2_xwidth;
MCNUM mccelliptical_guide_gravity1_2_yheight;
MCNUM mccelliptical_guide_gravity1_2_linxw;
MCNUM mccelliptical_guide_gravity1_2_loutxw;
MCNUM mccelliptical_guide_gravity1_2_linyh;
MCNUM mccelliptical_guide_gravity1_2_loutyh;
MCNUM mccelliptical_guide_gravity1_2_majorAxisxw;
MCNUM mccelliptical_guide_gravity1_2_minorAxisxw;
MCNUM mccelliptical_guide_gravity1_2_majorAxisyh;
MCNUM mccelliptical_guide_gravity1_2_minorAxisyh;
MCNUM mccelliptical_guide_gravity1_2_majorAxisoffsetxw;
MCNUM mccelliptical_guide_gravity1_2_majorAxisoffsetyh;
char mccelliptical_guide_gravity1_2_dimensionsAt[16384];
char mccelliptical_guide_gravity1_2_option[16384];
MCNUM mccelliptical_guide_gravity1_2_R0;
MCNUM mccelliptical_guide_gravity1_2_Qc;
MCNUM mccelliptical_guide_gravity1_2_alpha;
MCNUM mccelliptical_guide_gravity1_2_m;
MCNUM mccelliptical_guide_gravity1_2_W;
MCNUM mccelliptical_guide_gravity1_2_alpharight;
MCNUM mccelliptical_guide_gravity1_2_mright;
MCNUM mccelliptical_guide_gravity1_2_alphaleft;
MCNUM mccelliptical_guide_gravity1_2_mleft;
MCNUM mccelliptical_guide_gravity1_2_alphatop;
MCNUM mccelliptical_guide_gravity1_2_mtop;
MCNUM mccelliptical_guide_gravity1_2_alphabottom;
MCNUM mccelliptical_guide_gravity1_2_mbottom;
char mccelliptical_guide_gravity1_2_verbose[16384];
MCNUM mccelliptical_guide_gravity1_2_enableGravity;
MCNUM mccelliptical_guide_gravity1_2_curvature;

/* Setting parameters for component 'DiwJaw2' [55]. */
MCNUM mccDiwJaw2_xmin;
MCNUM mccDiwJaw2_xmax;
MCNUM mccDiwJaw2_ymin;
MCNUM mccDiwJaw2_ymax;
MCNUM mccDiwJaw2_radius;
MCNUM mccDiwJaw2_xwidth;
MCNUM mccDiwJaw2_yheight;

/* Definition parameters for component 'elliptical_guide_gravity1_3' [56]. */
#define mccelliptical_guide_gravity1_3_mvaluesright mValues1horizontal_part_3
#define mccelliptical_guide_gravity1_3_mvaluesleft mValues1horizontal_part_3
#define mccelliptical_guide_gravity1_3_mvaluestop mValues1vertical_part_3
#define mccelliptical_guide_gravity1_3_mvaluesbottom mValues1vertical_part_3
#define mccelliptical_guide_gravity1_3_seglength elementLength1_part_3
/* Setting parameters for component 'elliptical_guide_gravity1_3' [56]. */
MCNUM mccelliptical_guide_gravity1_3_l;
MCNUM mccelliptical_guide_gravity1_3_xwidth;
MCNUM mccelliptical_guide_gravity1_3_yheight;
MCNUM mccelliptical_guide_gravity1_3_linxw;
MCNUM mccelliptical_guide_gravity1_3_loutxw;
MCNUM mccelliptical_guide_gravity1_3_linyh;
MCNUM mccelliptical_guide_gravity1_3_loutyh;
MCNUM mccelliptical_guide_gravity1_3_majorAxisxw;
MCNUM mccelliptical_guide_gravity1_3_minorAxisxw;
MCNUM mccelliptical_guide_gravity1_3_majorAxisyh;
MCNUM mccelliptical_guide_gravity1_3_minorAxisyh;
MCNUM mccelliptical_guide_gravity1_3_majorAxisoffsetxw;
MCNUM mccelliptical_guide_gravity1_3_majorAxisoffsetyh;
char mccelliptical_guide_gravity1_3_dimensionsAt[16384];
char mccelliptical_guide_gravity1_3_option[16384];
MCNUM mccelliptical_guide_gravity1_3_R0;
MCNUM mccelliptical_guide_gravity1_3_Qc;
MCNUM mccelliptical_guide_gravity1_3_alpha;
MCNUM mccelliptical_guide_gravity1_3_m;
MCNUM mccelliptical_guide_gravity1_3_W;
MCNUM mccelliptical_guide_gravity1_3_alpharight;
MCNUM mccelliptical_guide_gravity1_3_mright;
MCNUM mccelliptical_guide_gravity1_3_alphaleft;
MCNUM mccelliptical_guide_gravity1_3_mleft;
MCNUM mccelliptical_guide_gravity1_3_alphatop;
MCNUM mccelliptical_guide_gravity1_3_mtop;
MCNUM mccelliptical_guide_gravity1_3_alphabottom;
MCNUM mccelliptical_guide_gravity1_3_mbottom;
char mccelliptical_guide_gravity1_3_verbose[16384];
MCNUM mccelliptical_guide_gravity1_3_enableGravity;
MCNUM mccelliptical_guide_gravity1_3_curvature;

/* Setting parameters for component 'DiwJaw1' [57]. */
MCNUM mccDiwJaw1_xmin;
MCNUM mccDiwJaw1_xmax;
MCNUM mccDiwJaw1_ymin;
MCNUM mccDiwJaw1_ymax;
MCNUM mccDiwJaw1_radius;
MCNUM mccDiwJaw1_xwidth;
MCNUM mccDiwJaw1_yheight;

/* Definition parameters for component 'elliptical_guide_gravity1_4' [58]. */
#define mccelliptical_guide_gravity1_4_mvaluesright mValues1horizontal_part_4
#define mccelliptical_guide_gravity1_4_mvaluesleft mValues1horizontal_part_4
#define mccelliptical_guide_gravity1_4_mvaluestop mValues1vertical_part_4
#define mccelliptical_guide_gravity1_4_mvaluesbottom mValues1vertical_part_4
#define mccelliptical_guide_gravity1_4_seglength elementLength1_part_4
/* Setting parameters for component 'elliptical_guide_gravity1_4' [58]. */
MCNUM mccelliptical_guide_gravity1_4_l;
MCNUM mccelliptical_guide_gravity1_4_xwidth;
MCNUM mccelliptical_guide_gravity1_4_yheight;
MCNUM mccelliptical_guide_gravity1_4_linxw;
MCNUM mccelliptical_guide_gravity1_4_loutxw;
MCNUM mccelliptical_guide_gravity1_4_linyh;
MCNUM mccelliptical_guide_gravity1_4_loutyh;
MCNUM mccelliptical_guide_gravity1_4_majorAxisxw;
MCNUM mccelliptical_guide_gravity1_4_minorAxisxw;
MCNUM mccelliptical_guide_gravity1_4_majorAxisyh;
MCNUM mccelliptical_guide_gravity1_4_minorAxisyh;
MCNUM mccelliptical_guide_gravity1_4_majorAxisoffsetxw;
MCNUM mccelliptical_guide_gravity1_4_majorAxisoffsetyh;
char mccelliptical_guide_gravity1_4_dimensionsAt[16384];
char mccelliptical_guide_gravity1_4_option[16384];
MCNUM mccelliptical_guide_gravity1_4_R0;
MCNUM mccelliptical_guide_gravity1_4_Qc;
MCNUM mccelliptical_guide_gravity1_4_alpha;
MCNUM mccelliptical_guide_gravity1_4_m;
MCNUM mccelliptical_guide_gravity1_4_W;
MCNUM mccelliptical_guide_gravity1_4_alpharight;
MCNUM mccelliptical_guide_gravity1_4_mright;
MCNUM mccelliptical_guide_gravity1_4_alphaleft;
MCNUM mccelliptical_guide_gravity1_4_mleft;
MCNUM mccelliptical_guide_gravity1_4_alphatop;
MCNUM mccelliptical_guide_gravity1_4_mtop;
MCNUM mccelliptical_guide_gravity1_4_alphabottom;
MCNUM mccelliptical_guide_gravity1_4_mbottom;
char mccelliptical_guide_gravity1_4_verbose[16384];
MCNUM mccelliptical_guide_gravity1_4_enableGravity;
MCNUM mccelliptical_guide_gravity1_4_curvature;

/* Setting parameters for component 'VirtualOutput' [60]. */
char mccVirtualOutput_filename[16384];
MCNUM mccVirtualOutput_bufsize;

/* Setting parameters for component 'DiwJaw0' [61]. */
MCNUM mccDiwJaw0_xmin;
MCNUM mccDiwJaw0_xmax;
MCNUM mccDiwJaw0_ymin;
MCNUM mccDiwJaw0_ymax;
MCNUM mccDiwJaw0_radius;
MCNUM mccDiwJaw0_xwidth;
MCNUM mccDiwJaw0_yheight;

/* Definition parameters for component 'log_P_stop' [62]. */
#define mcclog_P_stop_logger log_P_start

/* Definition parameters for component 'iter_P1_start' [64]. */
#define mcciter_P1_start_compute_func NULL

/* Definition parameters for component 'mndP01' [66]. */
#define mccmndP01_user1 FLT_MAX
#define mccmndP01_user2 FLT_MAX
#define mccmndP01_user3 FLT_MAX
/* Setting parameters for component 'mndP01' [66]. */
MCNUM mccmndP01_xwidth;
MCNUM mccmndP01_yheight;
MCNUM mccmndP01_zdepth;
MCNUM mccmndP01_xmin;
MCNUM mccmndP01_xmax;
MCNUM mccmndP01_ymin;
MCNUM mccmndP01_ymax;
MCNUM mccmndP01_zmin;
MCNUM mccmndP01_zmax;
MCNUM mccmndP01_bins;
MCNUM mccmndP01_min;
MCNUM mccmndP01_max;
MCNUM mccmndP01_restore_neutron;
MCNUM mccmndP01_radius;
char mccmndP01_options[16384];
char mccmndP01_filename[16384];
char mccmndP01_geometry[16384];
char mccmndP01_username1[16384];
char mccmndP01_username2[16384];
char mccmndP01_username3[16384];
int mccmndP01_nowritefile;

/* Definition parameters for component 'iter_P1_stop' [68]. */
#define mcciter_P1_stop_iterator iter_P1_start
/* Setting parameters for component 'iter_P1_stop' [68]. */
int mcciter_P1_stop_last;

/* Definition parameters for component 'iter_P2_start' [71]. */
#define mcciter_P2_start_compute_func NULL

/* Definition parameters for component 'mndP02' [73]. */
#define mccmndP02_user1 FLT_MAX
#define mccmndP02_user2 FLT_MAX
#define mccmndP02_user3 FLT_MAX
/* Setting parameters for component 'mndP02' [73]. */
MCNUM mccmndP02_xwidth;
MCNUM mccmndP02_yheight;
MCNUM mccmndP02_zdepth;
MCNUM mccmndP02_xmin;
MCNUM mccmndP02_xmax;
MCNUM mccmndP02_ymin;
MCNUM mccmndP02_ymax;
MCNUM mccmndP02_zmin;
MCNUM mccmndP02_zmax;
MCNUM mccmndP02_bins;
MCNUM mccmndP02_min;
MCNUM mccmndP02_max;
MCNUM mccmndP02_restore_neutron;
MCNUM mccmndP02_radius;
char mccmndP02_options[16384];
char mccmndP02_filename[16384];
char mccmndP02_geometry[16384];
char mccmndP02_username1[16384];
char mccmndP02_username2[16384];
char mccmndP02_username3[16384];
int mccmndP02_nowritefile;

/* Definition parameters for component 'iter_P2_stop' [75]. */
#define mcciter_P2_stop_iterator iter_P2_start
/* Setting parameters for component 'iter_P2_stop' [75]. */
int mcciter_P2_stop_last;

/* Definition parameters for component 'iter_P3_start' [78]. */
#define mcciter_P3_start_compute_func NULL

/* Definition parameters for component 'mndP03' [80]. */
#define mccmndP03_user1 FLT_MAX
#define mccmndP03_user2 FLT_MAX
#define mccmndP03_user3 FLT_MAX
/* Setting parameters for component 'mndP03' [80]. */
MCNUM mccmndP03_xwidth;
MCNUM mccmndP03_yheight;
MCNUM mccmndP03_zdepth;
MCNUM mccmndP03_xmin;
MCNUM mccmndP03_xmax;
MCNUM mccmndP03_ymin;
MCNUM mccmndP03_ymax;
MCNUM mccmndP03_zmin;
MCNUM mccmndP03_zmax;
MCNUM mccmndP03_bins;
MCNUM mccmndP03_min;
MCNUM mccmndP03_max;
MCNUM mccmndP03_restore_neutron;
MCNUM mccmndP03_radius;
char mccmndP03_options[16384];
char mccmndP03_filename[16384];
char mccmndP03_geometry[16384];
char mccmndP03_username1[16384];
char mccmndP03_username2[16384];
char mccmndP03_username3[16384];
int mccmndP03_nowritefile;

/* Definition parameters for component 'iter_P3_stop' [82]. */
#define mcciter_P3_stop_iterator iter_P3_start
/* Setting parameters for component 'iter_P3_stop' [82]. */
int mcciter_P3_stop_last;

/* Setting parameters for component 'Beamstop' [84]. */
MCNUM mccBeamstop_xmin;
MCNUM mccBeamstop_xmax;
MCNUM mccBeamstop_ymin;
MCNUM mccBeamstop_ymax;
MCNUM mccBeamstop_xwidth;
MCNUM mccBeamstop_yheight;
MCNUM mccBeamstop_radius;

/* Definition parameters for component 'Lmon_guide_end' [85]. */
#define mccLmon_guide_end_nL 300
/* Setting parameters for component 'Lmon_guide_end' [85]. */
char mccLmon_guide_end_filename[16384];
MCNUM mccLmon_guide_end_xmin;
MCNUM mccLmon_guide_end_xmax;
MCNUM mccLmon_guide_end_ymin;
MCNUM mccLmon_guide_end_ymax;
MCNUM mccLmon_guide_end_xwidth;
MCNUM mccLmon_guide_end_yheight;
MCNUM mccLmon_guide_end_Lmin;
MCNUM mccLmon_guide_end_Lmax;
MCNUM mccLmon_guide_end_restore_neutron;
int mccLmon_guide_end_nowritefile;

/* Setting parameters for component 'SCalc' [86]. */
MCNUM mccSCalc_MaxRate;
MCNUM mccSCalc_Innerspace;
char mccSCalc_NiCaptureFile[16384];
char mccSCalc_TiCaptureFile[16384];
char mccSCalc_TotalCaptureFile[16384];
char mccSCalc_OutputFile[16384];

/* Setting parameters for component 'DoseFe' [87]. */
char mccDoseFe_Material[16384];
MCNUM mccDoseFe_Innerspace;
MCNUM mccDoseFe_Thickness;
char mccDoseFe_SteelTubing[16384];
MCNUM mccDoseFe_TubingThickness;
char mccDoseFe_NiCaptureFile[16384];
char mccDoseFe_TiCaptureFile[16384];
char mccDoseFe_TotalCaptureFile[16384];
char mccDoseFe_OutputFile[16384];

/* Setting parameters for component 'DoseConc' [88]. */
char mccDoseConc_Material[16384];
MCNUM mccDoseConc_Innerspace;
MCNUM mccDoseConc_Thickness;
char mccDoseConc_SteelTubing[16384];
MCNUM mccDoseConc_TubingThickness;
char mccDoseConc_NiCaptureFile[16384];
char mccDoseConc_TiCaptureFile[16384];
char mccDoseConc_TotalCaptureFile[16384];
char mccDoseConc_OutputFile[16384];

/* Setting parameters for component 'DoseStandard' [89]. */
char mccDoseStandard_Material[16384];
MCNUM mccDoseStandard_Innerspace;
MCNUM mccDoseStandard_Thickness;
char mccDoseStandard_SteelTubing[16384];
MCNUM mccDoseStandard_TubingThickness;
char mccDoseStandard_NiCaptureFile[16384];
char mccDoseStandard_TiCaptureFile[16384];
char mccDoseStandard_TotalCaptureFile[16384];
char mccDoseStandard_OutputFile[16384];

/* Setting parameters for component 'Dose5' [90]. */
char mccDose5_Material[16384];
MCNUM mccDose5_Innerspace;
MCNUM mccDose5_Thickness;
char mccDose5_SteelTubing[16384];
MCNUM mccDose5_TubingThickness;
char mccDose5_NiCaptureFile[16384];
char mccDose5_TiCaptureFile[16384];
char mccDose5_TotalCaptureFile[16384];
char mccDose5_OutputFile[16384];

/* User component declarations. */

/* User declarations for component 'Origin' [1]. */
#define mccompcurname  Origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccOrigin_IntermediateCnts
#define StartTime mccOrigin_StartTime
#define EndTime mccOrigin_EndTime
#define CurrentTime mccOrigin_CurrentTime
#define profile mccOrigin_profile
#define percent mccOrigin_percent
#define flag_save mccOrigin_flag_save
#define minutes mccOrigin_minutes
#line 44 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../misc/Progress_bar.comp"
#ifndef PROGRESS_BAR
#define PROGRESS_BAR
#else
#error Only one Progress_bar component may be used in an instrument definition.
#endif

double IntermediateCnts;
time_t StartTime;
time_t EndTime;
time_t CurrentTime;
#line 13274 "./ESS_BIFROST_shielding.c"
#undef minutes
#undef flag_save
#undef percent
#undef profile
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ESS_source' [2]. */
#define mccompcurname  ESS_source
#define mccompcurtype  ESS_butterfly
#define mccompcurindex 2
#define cx mccESS_source_cx
#define cz mccESS_source_cz
#define sign_bl_angle mccESS_source_sign_bl_angle
#define orientation_angle mccESS_source_orientation_angle
#define jmax mccESS_source_jmax
#define C1_x mccESS_source_C1_x
#define C1_z mccESS_source_C1_z
#define C2_x mccESS_source_C2_x
#define C2_z mccESS_source_C2_z
#define C3_x mccESS_source_C3_x
#define C3_z mccESS_source_C3_z
#define T1_x mccESS_source_T1_x
#define T1_z mccESS_source_T1_z
#define T2_x mccESS_source_T2_x
#define T2_z mccESS_source_T2_z
#define T3_x mccESS_source_T3_x
#define T3_z mccESS_source_T3_z
#define rC1_x mccESS_source_rC1_x
#define rC1_z mccESS_source_rC1_z
#define rC2_x mccESS_source_rC2_x
#define rC2_z mccESS_source_rC2_z
#define rC3_x mccESS_source_rC3_x
#define rC3_z mccESS_source_rC3_z
#define rT1_x mccESS_source_rT1_x
#define rT1_z mccESS_source_rT1_z
#define rT2_x mccESS_source_rT2_x
#define rT2_z mccESS_source_rT2_z
#define rT3_x mccESS_source_rT3_x
#define rT3_z mccESS_source_rT3_z
#define tx mccESS_source_tx
#define ty mccESS_source_ty
#define tz mccESS_source_tz
#define r11 mccESS_source_r11
#define r12 mccESS_source_r12
#define r21 mccESS_source_r21
#define r22 mccESS_source_r22
#define xf mccESS_source_xf
#define yf mccESS_source_yf
#define zf mccESS_source_zf
#define w_mult mccESS_source_w_mult
#define w_stat mccESS_source_w_stat
#define w_geom mccESS_source_w_geom
#define w_focus mccESS_source_w_focus
#define w_tfocus mccESS_source_w_tfocus
#define w_geom_c mccESS_source_w_geom_c
#define w_geom_t mccESS_source_w_geom_t
#define tx mccESS_source_tx
#define ty mccESS_source_ty
#define tz mccESS_source_tz
#define dt mccESS_source_dt
#define lambda mccESS_source_lambda
#define l_range mccESS_source_l_range
#define k mccESS_source_k
#define v mccESS_source_v
#define r mccESS_source_r
#define dx mccESS_source_dx
#define dy mccESS_source_dy
#define dz mccESS_source_dz
#define internal_angle mccESS_source_internal_angle
#define x0 mccESS_source_x0
#define z0 mccESS_source_z0
#define cos_beamport_angle mccESS_source_cos_beamport_angle
#define sin_beamport_angle mccESS_source_sin_beamport_angle
#define cos_thermal mccESS_source_cos_thermal
#define cos_cold mccESS_source_cos_cold
#define Lmin_sampled mccESS_source_Lmin_sampled
#define Lmax_sampled mccESS_source_Lmax_sampled
#define sector mccESS_source_sector
#define beamline mccESS_source_beamline
#define yheight mccESS_source_yheight
#define cold_frac mccESS_source_cold_frac
#define target_index mccESS_source_target_index
#define dist mccESS_source_dist
#define focus_xw mccESS_source_focus_xw
#define focus_yh mccESS_source_focus_yh
#define c_performance mccESS_source_c_performance
#define t_performance mccESS_source_t_performance
#define Lmin mccESS_source_Lmin
#define Lmax mccESS_source_Lmax
#define tmax_multiplier mccESS_source_tmax_multiplier
#define n_pulses mccESS_source_n_pulses
#define acc_power mccESS_source_acc_power
#define tfocus_dist mccESS_source_tfocus_dist
#define tfocus_time mccESS_source_tfocus_time
#define tfocus_width mccESS_source_tfocus_width
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../sources/ESS_butterfly.comp"
/* Centering-parameters, which sector are we in? */
double cx, cz;
int sign_bl_angle,surf_sign;
double orientation_angle;
/* 10 beamlines in sector N and E  - plus one location added for drawing */
double BeamlinesN[] = { 30.0,  36.0,  42.0,  48.0,  54.0,  60.0,  66.0,  72.0,  78.0,  84.0,  90.0};
double BeamlinesE[] = {-30.0, -36.0, -42.0, -48.0, -54.0, -60.0, -66.0, -72.0, -78.0, -84.0, -90.0};
/* 11 beamlines in sector S and W - plus one location added for drawing */
double BeamlinesW[] = { 150.0,  144.7,  138.0,  132.7,  126.0,  120.7,  114.0,  108.7,  102.0,  96.7,  90.0,  84.0};
double BeamlinesS[] = {-150.0, -144.7, -138.0, -132.7, -126.0, -120.7, -114.0, -108.7, -102.0, -96.7, -90.0, -84.0};
double* Beamlines;
/* Moderator widths N+E */
double ColdWidthNE[] = {7e-2, 7.45e-2, 8.3e-2, 8.6e-2, 8.7e-2, 8.8e-2, 8.8e-2, 8.7e-2, 8.6e-2, 8.3e-2};
double ThermalWidthNE[] = {5.4e-2, 6.2e-2, 7.2e-2, 8.2e-2, 8.5e-2, 9.1e-2, 9.6e-2, 10e-2, 10.3e-2, 10.5e-2};
/* Moderator widths S+W */
double ColdWidthSW[] = {7e-2, 7.45e-2, 8.3e-2, 8.6e-2, 8.7e-2, 8.8e-2, 8.8e-2, 8.8e-2, 8.6e-2, 8.4e-2, 6.9e-2};
double ThermalWidthSW[] = {5.4e-2, 6.2e-2, 7.2e-2, 8.2e-2, 8.5e-2, 9.1e-2, 9.6e-2, 9.95e-2, 10.25e-2, 10.45e-2, 10.5e-2};
double* ColdWidths;
double* ThermalWidths;
/* Per-beamport brilliance scaling parameters */
double ColdScalarsN[]={9.8788e-01, 1.0009e+00, 9.9335e-01, 9.5997e-01, 9.0717e-01, 9.1646e-01, 9.1028e-01, 9.1773e-01, 9.2537e-01, 9.1727e-01};
double ColdScalarsE[]={9.9032e-01, 1.0020e+00, 9.9647e-01, 9.6885e-01, 9.0713e-01, 9.1787e-01, 9.1190e-01, 9.2113e-01, 9.2786e-01, 9.2146e-01};
double ColdScalarsW[]={9.9017e-01, 1.0069e+00, 9.9366e-01, 9.7144e-01, 9.0624e-01, 8.9379e-01, 9.1022e-01, 9.2847e-01, 9.2812e-01, 9.2703e-01, 8.3098e-01};
double ColdScalarsS[]={8.6550e-01, 1.0071e+00, 9.9401e-01, 9.6243e-01, 9.0398e-01, 8.9299e-01, 9.0830e-01, 9.2450e-01, 9.2270e-01, 9.2373e-01, 8.2508e-01};
double* ColdScalars;
double ThermalScalarsN[]={8.6782e-01, 7.8627e-01, 7.6528e-01, 7.9469e-01, 7.3645e-01, 7.3012e-01, 7.2755e-01, 7.1750e-01, 7.1973e-01, 7.0459e-01};
double ThermalScalarsE[]={8.6838e-01, 7.8295e-01, 7.6719e-01, 7.9431e-01, 7.3989e-01, 7.3107e-01, 7.2811e-01, 7.2201e-01, 7.2097e-01, 7.0307e-01};
double ThermalScalarsW[]={8.7232e-01, 8.0007e-01, 7.6853e-01, 8.0251e-01, 7.3728e-01, 7.3761e-01, 7.2808e-01, 7.2151e-01, 7.1797e-01, 6.9857e-01, 6.9610e-01};
double ThermalScalarsS[]={8.6910e-01, 7.9964e-01, 7.6365e-01, 7.9922e-01, 7.3479e-01, 7.3836e-01, 7.2773e-01, 7.2202e-01, 7.1667e-01, 7.0149e-01, 7.0084e-01};
double* ThermalScalars;
/* Beamport-dependent translation of moderator sampling axes. 11 positions long - constant after beamport 3 */
double dxCold[]={-0.01, -0.01, -0.002, 0.004,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0};
double dxThermal[]={0.002, 0.003, 0.002, 0.007, 0.007, 0.007, 0.007, 0.007, 0.007, 0.007, 0.007};
/* Oversampling for widths plus fraction of moderator surface "not around the corner" */
double oversampT=1.1;
double oversampC=1.0;
double wfrac_cold;
double wfrac_thermal;
double dx_focalpoint;
int jmax;
/* 'Corner' parametrization, i.e. where are the limits of the moderators */
double C1_x,C1_z,C2_x,C2_z,C3_x,C3_z;
double T1_x,T1_z,T2_x,T2_z,T3_x,T3_z;
/* - plus rotated versions of the same... */
double rC1_x,rC1_z,rC2_x,rC2_z,rC3_x,rC3_z;
double rT1_x,rT1_z,rT2_x,rT2_z,rT3_x,rT3_z;
double tx,ty,tz;
double r11, r12, r21, r22;
int iscold;
double xtmp;
double delta_y;
double xf, yf, zf;
double w_mult,w_stat;
double w_geom, w_focus, w_tfocus;
double w_geom_c, w_geom_t;
double tx,ty,tz;
int isleft;
double  Lmin_sampled,  Lmax_sampled,  dt, lambda, l_range;
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2013, All rights reserved
*         DTU Physics, Lyngby, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/ESS_butterfly-lib.h
*
* %Identification
* Written by: PW
* Date: Nov 7, 2013
* Origin: DTU Physics
* Release: McStas 2.1
* Version: 0.1
*
* This file is to be imported by the ESS_moderator_long component
* It defines a set of brilliance definitions (used via function pointer) for
* easier use of the component.
*
* Usage: within SHARE
* %include "ESS_butterfly-lib"
*
*******************************************************************************/

#ifndef ESS_BUTTERFLY_LIB_H
#define ESS_BUTTERFLY_LIB_H 0.1
#define ESS_SOURCE_DURATION 2.857e-3
#define ESS_SOURCE_FREQUENCY 14
#define ESS_SOURCE_POWER 5


/* Struct for extra source parameters - for future geometrical adjustments */
struct ess_struct {
  double X;
  double Y;
  double Z;
  double height_t;
  double height_c;
  double Width_c;
  double Width_t;
  double Mwidth_c;
  double Mwidth_t;
  double tmultiplier;
  double Radius_c;
  double beamportangle;
  int Uniform;
  double extractionangle;
  int Wasleft;
};

typedef struct ess_struct ess_moderator_struct;

typedef void (*functype)(double* t , double* p, double lambda,  double tfocus_w, double tfocus_t, double tfocus_dt, ess_moderator_struct extras);

double ESS_2015_Schoenfeldt_cold_spectrum(double lambda,double theta);
double ESS_2015_Schoenfeldt_thermal_spectrum(double lambda, double theta);

/* List of brilliance definitions */
void ESS_2015_Schoenfeldt_cold(double *t, double *p, double lambda, double tfocus_w, double tfocus_t, double tfocus_dt, ess_moderator_struct extras); 
void ESS_2015_Schoenfeldt_thermal(double *t, double *p, double lambda, double tfocus_w, double tfocus_t, double tfocus_dt, ess_moderator_struct extras);

/* List of pulse-shape definitions */
double ESS_2015_Schoenfeldt_cold_timedist(double t, double lambda, double height, double pulselength);
double ESS_2015_Schoenfeldt_thermal_timedist(double t, double lambda, double height, double pulselength);

/* List of moderator-geometry-weighting definitions */
double ESS_2014_Schoenfeldt_cold_y0(double y0,double height);
double ESS_2014_Schoenfeldt_cold_x0(double x0,double height, double width);
double ESS_2014_Schoenfeldt_thermal_y0(double y0,double height);
double ESS_2014_Schoenfeldt_thermal_x0(double x0,double height, double width);

double ESS_2015_Schoenfeldt_cold_y0(double y0);
double ESS_2015_Schoenfeldt_cold_x0(double x0, double theta, double width);
double ESS_2015_Schoenfeldt_thermal_y0(double y0);
double ESS_2015_Schoenfeldt_thermal_x0(double x0,double theta, double width);
double ESS_2015_Schoenfeldt_cold_Y(double x0,double height);
double ESS_2015_Schoenfeldt_thermal_Y(double y0,double height);
double ESS_2015_Schoenfeldt_cold_Theta120(double x0,double height);
double ESS_2015_Schoenfeldt_thermal_Theta120(double beamportangle,int isleft);

/* end of ESS_butterfly-lib.h */
#endif

/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2013, All rights reserved
*         DTU Physics, Lyngby, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/ESS_butterfly-lib.c
*
* %Identification
* Written by: PW
* Date: Nov 7, 2013
* Origin: DTU Physics
* Release: McStas 2.1
* Version: 0.1
*
* This file is to be imported by the ESS_moderator_long component
* It defines a set of brilliance definitions (used via function pointer) for
* easier use of the component.
*
* Usage: within SHARE
* %include "ESS_butterfly-lib"
*
*******************************************************************************/

#ifndef ESS_BUTTERFLY_LIB_H
#error McStas : please import this library with %include "ESS_butterfly-lib"
#endif

double ESS_2015_Schoenfeldt_cold_spectrum(double lambda,double theta){
  if(lambda<=0)return 0;
  double par0=8.44e13/25.;
  double par1=2.5;
  double par2=2.2;
  
  double par3=-13.-.5*(theta-5);
  double par4=2.53;
  double par5=-0.0478073-0.160*exp(-0.45186*(theta-5.)/10.);
  
  double par6;
  if(theta==5)par6=5.73745e+015/25.;
  else if(theta==15)par6=5.88284e+015/25.;
  else if(theta==25)par6=6.09573e+015/25.;
  else if(theta==35)par6=6.29116e+015/25.;
  else if(theta==45)par6=6.03436e+015/25.;
  else if(theta==55)par6=6.02045e+015/25.;
  double par7=0.788956+0.00854184*(theta-5.)/10.;
  double par8=0.0461868-0.0016464*(theta-5.)/10.;
  double par9=0.325;
  
  double SD_part=par0/((1+exp(par1*(lambda-par2)))*lambda);
  double para_part=pow((1+exp(par3*(lambda-par4))),par5)*(par6*(exp(-par7*(lambda))+par8*exp(-par9*(lambda))));
  return para_part+SD_part;
  
}

double ESS_2015_Schoenfeldt_thermal_spectrum(double lambda, double theta){
    if(lambda<=0)return 0;
    double i=(theta-5.)/10.;
    double par0=4.2906e+013-9.2758e+011*i+8.02603e+011*i*i-1.29523e+011*i*i*i;
    double par2=6.24806e+012-8.84602e+010*i;
    double par3=-0.31107+0.0221138*i;
    double aOlsqr=949./(325*lambda*lambda);
    return par0*2.*aOlsqr*aOlsqr/lambda*pow(lambda,-par3)*exp(-aOlsqr)+par2/((1+exp(2.5*(lambda-0.88)))*lambda);
	  
}


/* This is ESS_2014_Schoenfeldt_cold_y0 - vertical intensity distribution for the 2014 Schoenfeldt cold moderator */
double ESS_2014_Schoenfeldt_cold_y0(double y0,double height){
  
  double one_over_integral_y0_of_height= height/((0.36434*height*height+2.53796*height-0.107774));
  if(y0 < -height/2. || y0 > height/2. )return 0;
  double cosh_ish=(exp(-7e-1/sqrt(height)*(y0-height/2.))+exp(-7e-1/20.*height+7e-1/sqrt(height)*(y0+height/2.)));
  double sinh_ish=(exp(50/sqrt(height)*(y0-height/2.))-1)*(exp(-50/sqrt(height)*(y0+height/2.))-1);
  double tmp=one_over_integral_y0_of_height*cosh_ish*sinh_ish;
  return tmp;
} /* end of ESS_2014_Schoenfeldt_cold_y0 */

/* This is ESS_2014_Schoenfeldt_thermal_y0 - vertical intensity distribution for the 2014 Schoenfeldt cold moderator */
double ESS_2014_Schoenfeldt_thermal_y0(double y0,double height){
  /* Placeholder - we assume that this distribution is flat for now */
  return 1;
} /* end of ESS_2014_Schoenfeldt_thermal_y0 */

/* This is ESS_2014_Schoenfeldt_cold_x0 - horizontal intensity distribution for the 2014 Schoenfeldt cold moderator */
double ESS_2014_Schoenfeldt_cold_x0(double x0,double height, double width){
  double normalization=1;
  if(x0<-width||x0>width)return 0;
  return normalization*(0.008*x0+1)*(exp(height/2.*(x0-width/2))-1)*(exp(-height/2.*(x0+width/2))-1);
} /* end of ESS_2014_Schoenfeldt_cold_x0 */

/* This is ESS_2014_Schoenfeldt_thermal_x0 - horizontal intensity distribution for the 2014 Schoenfeldt cold moderator */
double ESS_2014_Schoenfeldt_thermal_x0(double x0,double height, double width){
  // Kept for reference only...
  /* if(x0>-width&&x0<width)return 0; */
  /* if(x0<0)return fmax(0,2.5*(0.0524986*fabs(x0)-1.84817-0.0189762*height+(-1.49712e+002*exp(-4.06814e-001*height))*exp(-4.48657e-001*fabs(x0)))*(exp(7*(x0+width))-1)); */
  /* return fmax(0,2.5*(0.84199+0.00307022*height)*(0.0524986*fabs(x0)-1.84817-0.0189762*height+(-1.49712e+002*exp(-4.06814e-001*height))*exp(-4.48657e-001*fabs(x0)))*(exp(-7*(x0-width))-1)); */  
  if(x0>-23./2.&&x0<23./2.)return 0;
  long double cosh_ish=fmin(0.0524986*fabs(x0)-1.84817-0.0189762*height+(-1.49712e+002*exp(-4.06814e-001*height))*exp(-4.48657e-001*fabs(x0)),0);
  if(x0<0)return (-1.73518e-003*height*height+2.10277e-002*height+7.65692e-001) // intensity
	    *cosh_ish*(exp(7.*(x0+23./2.))-1); // slope 
  return (-1.73518e-003*height*height+2.10277e-002*height+7.65692e-001) // intensity
    *(0.84199+0.00307022*height) // asumetry
    *cosh_ish*(exp(-7.*(x0-23./2.))-1); // slope
} /* end of ESS_2014_Schoenfeldt_thermal_x0 */

/* This is the thermal moderator with 2015 updates, fits from Troels Schoenfeldt */
void ESS_2015_Schoenfeldt_thermal(double *t, double *p, double lambda, double tfocus_w, double tfocus_t, double tfocus_dt, ess_moderator_struct extras)
{
  if ((extras.height_t == 0.03) || (extras.height_t == 0.06)) {
    *p = ESS_2015_Schoenfeldt_thermal_spectrum(lambda, extras.beamportangle);
  } else {
    printf("Sorry! Moderator height must be either %g or %g m\n",0.03,0.06);
    exit(-1);
  }

  /* Troels Schoenfeldt function for timestructure */
  *p *= extras.tmultiplier*ESS_2015_Schoenfeldt_thermal_timedist(*t, lambda, 3 /* cm height */, ESS_SOURCE_DURATION);  
  if (extras.height_c == 0.03) {
    // 3cm case
    *p *= ESS_2015_Schoenfeldt_thermal_y0(100*extras.Y) * ESS_2015_Schoenfeldt_thermal_x0(100*extras.X, extras.beamportangle, extras.Mwidth_t);
  } else {
    // 6cm case
    // Downscale brightness by factor from 
    // "New ESS Moderator Baseline", Ken Andersen, 9/4/2015
    *p *= (6.2e14/9.0e14);
    *p *= ESS_2014_Schoenfeldt_thermal_y0(100*extras.Y, 100*extras.height_c) * ESS_2015_Schoenfeldt_thermal_x0(100*extras.X, extras.beamportangle, extras.Mwidth_t);
  }
} /* end of ESS_2015_Schoenfeldt_thermal */


/* This is the cold moderator with 2015 updates, fits from Troels Schoenfeldt */
/* Parametrization including moderator height for the "pancake" moderator */
void ESS_2015_Schoenfeldt_cold(double *t, double *p, double lambda, double tfocus_w, double tfocus_t, double tfocus_dt, ess_moderator_struct extras)
{
   if ((extras.height_c == 0.03) || (extras.height_c == 0.06)) {
    *p = ESS_2015_Schoenfeldt_cold_spectrum(lambda,extras.beamportangle);
  } else {
    printf("Sorry! Moderator height must be either %g or %g m\n",0.03,0.06);
    exit(-1);
  }

  /* Troels Schoenfeldt function for timestructure */
  *p *= extras.tmultiplier*ESS_2015_Schoenfeldt_cold_timedist(*t, lambda, 3 /* cm height */, ESS_SOURCE_DURATION);
  
  if (extras.Uniform==0) {
    if (extras.height_c == 0.03) {
      // 3cm case
      *p *= ESS_2015_Schoenfeldt_cold_y0(100*extras.Y) * ESS_2015_Schoenfeldt_cold_x0(100*extras.X, extras.beamportangle, extras.Mwidth_c);
    } else {
      // 6cm case
      // Downscale brightness by factor from 
      // "New ESS Moderator Baseline", Ken Andersen, 9/4/2015
      *p *= (10.1e14/16.0e14);
      *p *= ESS_2014_Schoenfeldt_cold_y0(100*extras.Y, 100*extras.height_c) * ESS_2015_Schoenfeldt_cold_x0(100*extras.X, extras.beamportangle, extras.Mwidth_c);
    }
  }
} /* end of ESS_2015_Schoenfeldt_cold */

/* This is ESS_2015_Schoenfeldt_cold_y0 - vertical intensity distribution for the 2015 Schoenfeldt cold moderator */
double ESS_2015_Schoenfeldt_cold_y0(double y0){
    double par3=30;
    double par4=.35;
    long double cosh_ish=exp(-par4*y0)+exp(par4*y0);
    long double sinh_ish=pow(1+exp(par3*(y0-3./2.)),-1)*pow(1+exp(-par3*(y0+3./2.)),-1);
    return 1./2.*(double)((long double)cosh_ish*(long double)sinh_ish);

} /* end of ESS_2015_Schoenfeldt_cold_y0 */

/* This is ESS_2015_Schoenfeldt_thermal_y0 - vertical intensity distribution for the 2015 Schoenfeldt cold moderator */
double ESS_2015_Schoenfeldt_thermal_y0(double y0){
    if(y0<-3./2.+0.105){
        return 1.005*exp(-pow((y0+3./2.-0.105)/0.372,2));
    } else if(y0>3./2.-0.105){
        return 1.005*exp(-pow((y0-3./2.+0.105)/0.372,2));
    }
    return 1.005;
} /* end of ESS_2015_Schoenfeldt_thermal_y0 */

/* This is ESS_2015_Schoenfeldt_cold_x0 - horizontal intensity distribution for the 2015 Schoenfeldt cold moderator */
double ESS_2015_Schoenfeldt_cold_x0(double x0,double theta, double width){
  // GEOMETRY / SAMPLING SPACE
    double i=(theta-5.)/10.;
    double par0=0.0146115+0.00797729*i-0.00279541*i*i;
    double par1=0.980886;
    if(i==1)par1=0.974217;
    if(i==2)par1=0.981462;
    if(i==3)par1=1.01466;
    if(i==4)par1=1.11707;
    if(i==5)par1=1.16057;
        
    double par2=-4-.75*i;
    if(i==0)par2=-20;
    double par3=-14.9402-0.178369*i+0.0367007*i*i;
    if(i==0)par3*=0.95;
    double par4=-15;
    if(i==3)par4=-3.5;
    if(i==5)par4=-1.9;
    double par5=-7.07979+0.0835695*i-0.0546662*i*i;
    if(i==5)par5*=0.85;
    
    //printf("Angle %g, width is %g\n",theta,width,cos(theta*DEG2RAD)*width);
    //if(i==4) width=width+0.3;
    //if(i==5) width=width-0.7;

    /* Rescaling to achieve a BF1 model */
    double tmp=(par5-par3)/width;
    //printf("Cold x0 in BF1 units: %g,",x0);
    x0=x0*tmp-7.16;
    //printf("x0 in BF2 units: %g, moderator width is %g from %g\n",x0,width,par5-par3);

    /* if (x0<=par5 && x0>=par3) */
    /*   return 1; */
    /* else */
    /*   return 0; */
    

    double line=par0*(x0+12)+par1;
    double CutLeftCutRight=1./((1+exp(par2*(x0-par3)))*(1+exp(-par4*(x0-par5))));

    return line*CutLeftCutRight;
} /* end of ESS_2015_Schoenfeldt_cold_x0 */

/* This is ESS_2015_Schoenfeldt_thermal_x0 - horizontal intensity distribution for the 2015 Schoenfeldt cold moderator */
double ESS_2015_Schoenfeldt_thermal_x0(double x0,double theta, double width){
    double i=(theta-5.)/10.;
    double par0=-5.54775+0.492804*i;
    double par1=-0.265929-0.711477*i;
    if(theta==55)par1=-2.55;

    double par2=0.821885+0.00914832*i;
    double par3=1.31108-0.00698647*i;
    if(theta==55)par3=1.23;
    double par4=-.035;
    double par5=-0.0817358+0.00807125*i;
        
    double par6=-8;
    double par7=-7.15;
    if(theta==45)par7=-8.2;
    if(theta==55)par7=-7.7;

    double par8=-8;
    double par9=7.15;
    if(theta==45)par9=7.5;
    if(theta==55)par9=8.2;

    /* Rescaling to achieve a BF1 model */
    double tmp=(par9-par7)/width;
    //printf("Thermal x0 in BF1 units: %g,",x0);
    x0=x0*tmp-7.16;
    //printf(" x0 in BF2 units: %g, moderator width is %g from %g\n",x0,width,par9-par7);
    
    /* if (x0<=par9 && x0>=par7) */
    /*   return 1; */
    /* else */
    /*   return 0; */
    
    double soften1=1./(1+exp(8.*(x0-par0)));
    double soften2=1./(1+exp(8.*(x0-par1)));
    double CutLeftCutRight=1./((1+exp(par6*(x0-par7)))*(1+exp(-par8*(x0-par9))));
    double line1=par4*(x0-par0)+par2;
    double line2=(par2-par3)/(par0-par1)*(x0-par0)+par2;
    double line3=par5*(x0-par1)+par3;
    double add45degbumb=1.2*exp(-(x0+7.55)*(x0+7.55)/.35/.35);


    return CutLeftCutRight*(
        (line1)*soften1
        +line2*soften2*(1-soften1)
        +line3*(1-soften2)
        );
} /* end of ESS_2015_Schoenfeldt_thermal_x0 */

/* This is ESS_2015_Schoenfeldt_cold_Y - vertical intensity distribution for the 2015 Schoenfeldt cold moderator */
double ESS_2015_Schoenfeldt_cold_Y(double Y,double height){
  /* Placeholder - we assume that this distribution is flat for now */
  return 1;
} /* end of ESS_2015_Schoenfeldt_cold_Y */

/* This is ESS_2015_Schoenfeldt_thermal_Y - vertical intensity distribution for the 2015 Schoenfeldt cold moderator */
double ESS_2015_Schoenfeldt_thermal_Y(double Y,double height){
  /* Placeholder - we assume that this distribution is flat for now */
  return 1;
} /* end of ESS_2015_Schoenfeldt_thermal_Y */

/* This is ESS_2015_Schoenfeldt_cold_Theta120 - vertical intensity distribution for the 2015 Schoenfeldt cold moderator */
double ESS_2015_Schoenfeldt_cold_Theta120(double Theta120,double height){
  /* Placeholder - we assume that this distribution is flat for now */
  return 1;
} /* end of ESS_2015_Schoenfeldt_cold_Theta120 */

/* This is ESS_2015_Schoenfeldt_thermal_Theta120 - vertical intensity distribution for the 2015 Schoenfeldt cold moderator */
double ESS_2015_Schoenfeldt_thermal_Theta120(double beamportangle,int isleft){
  if(!isleft)return cos((beamportangle-30)*DEG2RAD)/cos(30*DEG2RAD);
  return cos((90-beamportangle)*DEG2RAD)/cos(30*DEG2RAD);
/* Placeholder - we assume that this distribution is flat for now */
  return 1;
} /* end of ESS_2015_Schoenfeldt_thermal_Theta120 */


/* This is ESS_2015_Schoenfeldt_cold_timedist time-distribution of the 2014 Schoenfeldt cold moderator */ 
double ESS_2015_Schoenfeldt_cold_timedist(double time,double lambda,double height, double pulselength){
        if(time<0)return 0;
        double tau=3.00094e-004*(4.15681e-003*lambda*lambda+2.96212e-001*exp(-1.78408e-001*height)+7.77496e-001)*exp(-6.63537e+001*pow(fmax(1e-13,lambda+.9),-8.64455e+000));
        if(time<pulselength)return ((1-exp(-time/tau)));
        return ((1-exp(-pulselength/tau))*exp(-(time-pulselength)/tau));

} /* end of ESS_2015_Schoenfeldt_cold_timedist */

/* This is ESS_2015_Schoenfeldt_thermal_timedist time-distribution of the 2015 Schoenfeldt cold moderator */    
double ESS_2015_Schoenfeldt_thermal_timedist(double time,double lambda,double height, double pulselength){
        if(time<0)return 0;
        double tau=3.00000e-004*(1.23048e-002*lambda*lambda+1.75628e-001*exp(-1.82452e-001*height)+9.27770e-001)*exp(-3.91090e+001*pow(fmax(1e-13,lambda+9.87990e-001),-7.65675e+000));
        if(time<pulselength)return ((1-exp(-time/tau)));
        return ((1-exp(-pulselength/tau))*exp(-(time-pulselength)/tau));
} /* end of ESS_2015_Schoenfeldt_thermal_timedist */

/* end of ESS_butterfly-lib.c */

ess_moderator_struct modextras;
/* Cold and thermal function pointers */
functype cold_bril;
functype thermal_bril;
double k,v,r;
double dx,dy,dz;
/* variables needed to correct for the emission surface angle */
double internal_angle;

int nearest_angle(double angle) {
    int AngleList[] = {5, 15, 25, 35, 45, 55};
    double diff = 180;
    int jmin=-1;
    int j;
    for (j=0; j<6; j++) {
      if (fabs(AngleList[j]-angle) < diff) {
	diff = fabs(AngleList[j]-angle);
	jmin = j;
      }
    }
    return AngleList[jmin];
  }
  
  double x0,z0;
  double cos_beamport_angle, sin_beamport_angle, cos_thermal, cos_cold, cos_factor;
#line 13864 "./ESS_BIFROST_shielding.c"
#undef tfocus_width
#undef tfocus_time
#undef tfocus_dist
#undef acc_power
#undef n_pulses
#undef tmax_multiplier
#undef Lmax
#undef Lmin
#undef t_performance
#undef c_performance
#undef focus_yh
#undef focus_xw
#undef dist
#undef target_index
#undef cold_frac
#undef yheight
#undef beamline
#undef sector
#undef Lmax_sampled
#undef Lmin_sampled
#undef cos_cold
#undef cos_thermal
#undef sin_beamport_angle
#undef cos_beamport_angle
#undef z0
#undef x0
#undef internal_angle
#undef dz
#undef dy
#undef dx
#undef r
#undef v
#undef k
#undef l_range
#undef lambda
#undef dt
#undef tz
#undef ty
#undef tx
#undef w_geom_t
#undef w_geom_c
#undef w_tfocus
#undef w_focus
#undef w_geom
#undef w_stat
#undef w_mult
#undef zf
#undef yf
#undef xf
#undef r22
#undef r21
#undef r12
#undef r11
#undef tz
#undef ty
#undef tx
#undef rT3_z
#undef rT3_x
#undef rT2_z
#undef rT2_x
#undef rT1_z
#undef rT1_x
#undef rC3_z
#undef rC3_x
#undef rC2_z
#undef rC2_x
#undef rC1_z
#undef rC1_x
#undef T3_z
#undef T3_x
#undef T2_z
#undef T2_x
#undef T1_z
#undef T1_x
#undef C3_z
#undef C3_x
#undef C2_z
#undef C2_x
#undef C1_z
#undef C1_x
#undef jmax
#undef orientation_angle
#undef sign_bl_angle
#undef cz
#undef cx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'StartOfGuide' [3]. */
#define mccompcurname  StartOfGuide
#define mccompcurtype  Arm
#define mccompcurindex 3
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'NBOA' [4]. */
#define mccompcurname  NBOA
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 4
#define mvaluesright mccNBOA_mvaluesright
#define mvaluesleft mccNBOA_mvaluesleft
#define mvaluestop mccNBOA_mvaluestop
#define mvaluesbottom mccNBOA_mvaluesbottom
#define seglength mccNBOA_seglength
#define guideInfo mccNBOA_guideInfo
#define latestParticleCollision mccNBOA_latestParticleCollision
#define Gx mccNBOA_Gx
#define Gy mccNBOA_Gy
#define Gz mccNBOA_Gz
#define Gx0 mccNBOA_Gx0
#define Gy0 mccNBOA_Gy0
#define Gz0 mccNBOA_Gz0
#define Circ mccNBOA_Circ
#define dynamicalSegLength mccNBOA_dynamicalSegLength
#define l mccNBOA_l
#define xwidth mccNBOA_xwidth
#define yheight mccNBOA_yheight
#define linxw mccNBOA_linxw
#define loutxw mccNBOA_loutxw
#define linyh mccNBOA_linyh
#define loutyh mccNBOA_loutyh
#define majorAxisxw mccNBOA_majorAxisxw
#define minorAxisxw mccNBOA_minorAxisxw
#define majorAxisyh mccNBOA_majorAxisyh
#define minorAxisyh mccNBOA_minorAxisyh
#define majorAxisoffsetxw mccNBOA_majorAxisoffsetxw
#define majorAxisoffsetyh mccNBOA_majorAxisoffsetyh
#define dimensionsAt mccNBOA_dimensionsAt
#define option mccNBOA_option
#define R0 mccNBOA_R0
#define Qc mccNBOA_Qc
#define alpha mccNBOA_alpha
#define m mccNBOA_m
#define W mccNBOA_W
#define alpharight mccNBOA_alpharight
#define mright mccNBOA_mright
#define alphaleft mccNBOA_alphaleft
#define mleft mccNBOA_mleft
#define alphatop mccNBOA_alphatop
#define mtop mccNBOA_mtop
#define alphabottom mccNBOA_alphabottom
#define mbottom mccNBOA_mbottom
#define verbose mccNBOA_verbose
#define enableGravity mccNBOA_enableGravity
#define curvature mccNBOA_curvature
#line 815 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
	/** 
		All variables below is locally declared 
		and hence accessible through OUTPUT PARAMETERS.
	*/ 
	struct SGI guideInfo; // Static Guide information, is set in INITIALIZE
	struct Intersection latestParticleCollision; // Is changed duing trace
	double Gx,Gy,Gz;  // Local gravity vector, is set once in INITIALIZE
	double Gx0, Gy0, Gz0;
	double Circ;
	double *dynamicalSegLength;

#line 14024 "./ESS_BIFROST_shielding.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'EndOfelement_6' [5]. */
#define mccompcurname  EndOfelement_6
#define mccompcurtype  Arm
#define mccompcurindex 5
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'EndOfelement_5' [6]. */
#define mccompcurname  EndOfelement_5
#define mccompcurtype  Arm
#define mccompcurindex 6
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_1_0' [7]. */
#define mccompcurname  curved_guide_1_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 7
#define GVars mcccurved_guide_1_0_GVars
#define pTable mcccurved_guide_1_0_pTable
#define w1 mcccurved_guide_1_0_w1
#define h1 mcccurved_guide_1_0_h1
#define w2 mcccurved_guide_1_0_w2
#define h2 mcccurved_guide_1_0_h2
#define l mcccurved_guide_1_0_l
#define R0 mcccurved_guide_1_0_R0
#define Qc mcccurved_guide_1_0_Qc
#define alpha mcccurved_guide_1_0_alpha
#define m mcccurved_guide_1_0_m
#define W mcccurved_guide_1_0_W
#define nslit mcccurved_guide_1_0_nslit
#define d mcccurved_guide_1_0_d
#define mleft mcccurved_guide_1_0_mleft
#define mright mcccurved_guide_1_0_mright
#define mtop mcccurved_guide_1_0_mtop
#define mbottom mcccurved_guide_1_0_mbottom
#define nhslit mcccurved_guide_1_0_nhslit
#define G mcccurved_guide_1_0_G
#define aleft mcccurved_guide_1_0_aleft
#define aright mcccurved_guide_1_0_aright
#define atop mcccurved_guide_1_0_atop
#define abottom mcccurved_guide_1_0_abottom
#define wavy mcccurved_guide_1_0_wavy
#define wavy_z mcccurved_guide_1_0_wavy_z
#define wavy_tb mcccurved_guide_1_0_wavy_tb
#define wavy_lr mcccurved_guide_1_0_wavy_lr
#define chamfers mcccurved_guide_1_0_chamfers
#define chamfers_z mcccurved_guide_1_0_chamfers_z
#define chamfers_lr mcccurved_guide_1_0_chamfers_lr
#define chamfers_tb mcccurved_guide_1_0_chamfers_tb
#define nelements mcccurved_guide_1_0_nelements
#define nu mcccurved_guide_1_0_nu
#define phase mcccurved_guide_1_0_phase
#define reflect mcccurved_guide_1_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14134 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_2_0' [8]. */
#define mccompcurname  curved_guide_2_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 8
#define GVars mcccurved_guide_2_0_GVars
#define pTable mcccurved_guide_2_0_pTable
#define w1 mcccurved_guide_2_0_w1
#define h1 mcccurved_guide_2_0_h1
#define w2 mcccurved_guide_2_0_w2
#define h2 mcccurved_guide_2_0_h2
#define l mcccurved_guide_2_0_l
#define R0 mcccurved_guide_2_0_R0
#define Qc mcccurved_guide_2_0_Qc
#define alpha mcccurved_guide_2_0_alpha
#define m mcccurved_guide_2_0_m
#define W mcccurved_guide_2_0_W
#define nslit mcccurved_guide_2_0_nslit
#define d mcccurved_guide_2_0_d
#define mleft mcccurved_guide_2_0_mleft
#define mright mcccurved_guide_2_0_mright
#define mtop mcccurved_guide_2_0_mtop
#define mbottom mcccurved_guide_2_0_mbottom
#define nhslit mcccurved_guide_2_0_nhslit
#define G mcccurved_guide_2_0_G
#define aleft mcccurved_guide_2_0_aleft
#define aright mcccurved_guide_2_0_aright
#define atop mcccurved_guide_2_0_atop
#define abottom mcccurved_guide_2_0_abottom
#define wavy mcccurved_guide_2_0_wavy
#define wavy_z mcccurved_guide_2_0_wavy_z
#define wavy_tb mcccurved_guide_2_0_wavy_tb
#define wavy_lr mcccurved_guide_2_0_wavy_lr
#define chamfers mcccurved_guide_2_0_chamfers
#define chamfers_z mcccurved_guide_2_0_chamfers_z
#define chamfers_lr mcccurved_guide_2_0_chamfers_lr
#define chamfers_tb mcccurved_guide_2_0_chamfers_tb
#define nelements mcccurved_guide_2_0_nelements
#define nu mcccurved_guide_2_0_nu
#define phase mcccurved_guide_2_0_phase
#define reflect mcccurved_guide_2_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14218 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_3_0' [9]. */
#define mccompcurname  curved_guide_3_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 9
#define GVars mcccurved_guide_3_0_GVars
#define pTable mcccurved_guide_3_0_pTable
#define w1 mcccurved_guide_3_0_w1
#define h1 mcccurved_guide_3_0_h1
#define w2 mcccurved_guide_3_0_w2
#define h2 mcccurved_guide_3_0_h2
#define l mcccurved_guide_3_0_l
#define R0 mcccurved_guide_3_0_R0
#define Qc mcccurved_guide_3_0_Qc
#define alpha mcccurved_guide_3_0_alpha
#define m mcccurved_guide_3_0_m
#define W mcccurved_guide_3_0_W
#define nslit mcccurved_guide_3_0_nslit
#define d mcccurved_guide_3_0_d
#define mleft mcccurved_guide_3_0_mleft
#define mright mcccurved_guide_3_0_mright
#define mtop mcccurved_guide_3_0_mtop
#define mbottom mcccurved_guide_3_0_mbottom
#define nhslit mcccurved_guide_3_0_nhslit
#define G mcccurved_guide_3_0_G
#define aleft mcccurved_guide_3_0_aleft
#define aright mcccurved_guide_3_0_aright
#define atop mcccurved_guide_3_0_atop
#define abottom mcccurved_guide_3_0_abottom
#define wavy mcccurved_guide_3_0_wavy
#define wavy_z mcccurved_guide_3_0_wavy_z
#define wavy_tb mcccurved_guide_3_0_wavy_tb
#define wavy_lr mcccurved_guide_3_0_wavy_lr
#define chamfers mcccurved_guide_3_0_chamfers
#define chamfers_z mcccurved_guide_3_0_chamfers_z
#define chamfers_lr mcccurved_guide_3_0_chamfers_lr
#define chamfers_tb mcccurved_guide_3_0_chamfers_tb
#define nelements mcccurved_guide_3_0_nelements
#define nu mcccurved_guide_3_0_nu
#define phase mcccurved_guide_3_0_phase
#define reflect mcccurved_guide_3_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14302 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_4_0' [10]. */
#define mccompcurname  curved_guide_4_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 10
#define GVars mcccurved_guide_4_0_GVars
#define pTable mcccurved_guide_4_0_pTable
#define w1 mcccurved_guide_4_0_w1
#define h1 mcccurved_guide_4_0_h1
#define w2 mcccurved_guide_4_0_w2
#define h2 mcccurved_guide_4_0_h2
#define l mcccurved_guide_4_0_l
#define R0 mcccurved_guide_4_0_R0
#define Qc mcccurved_guide_4_0_Qc
#define alpha mcccurved_guide_4_0_alpha
#define m mcccurved_guide_4_0_m
#define W mcccurved_guide_4_0_W
#define nslit mcccurved_guide_4_0_nslit
#define d mcccurved_guide_4_0_d
#define mleft mcccurved_guide_4_0_mleft
#define mright mcccurved_guide_4_0_mright
#define mtop mcccurved_guide_4_0_mtop
#define mbottom mcccurved_guide_4_0_mbottom
#define nhslit mcccurved_guide_4_0_nhslit
#define G mcccurved_guide_4_0_G
#define aleft mcccurved_guide_4_0_aleft
#define aright mcccurved_guide_4_0_aright
#define atop mcccurved_guide_4_0_atop
#define abottom mcccurved_guide_4_0_abottom
#define wavy mcccurved_guide_4_0_wavy
#define wavy_z mcccurved_guide_4_0_wavy_z
#define wavy_tb mcccurved_guide_4_0_wavy_tb
#define wavy_lr mcccurved_guide_4_0_wavy_lr
#define chamfers mcccurved_guide_4_0_chamfers
#define chamfers_z mcccurved_guide_4_0_chamfers_z
#define chamfers_lr mcccurved_guide_4_0_chamfers_lr
#define chamfers_tb mcccurved_guide_4_0_chamfers_tb
#define nelements mcccurved_guide_4_0_nelements
#define nu mcccurved_guide_4_0_nu
#define phase mcccurved_guide_4_0_phase
#define reflect mcccurved_guide_4_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14386 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_5_beforeChopper' [11]. */
#define mccompcurname  curved_guide_5_beforeChopper
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 11
#define GVars mcccurved_guide_5_beforeChopper_GVars
#define pTable mcccurved_guide_5_beforeChopper_pTable
#define w1 mcccurved_guide_5_beforeChopper_w1
#define h1 mcccurved_guide_5_beforeChopper_h1
#define w2 mcccurved_guide_5_beforeChopper_w2
#define h2 mcccurved_guide_5_beforeChopper_h2
#define l mcccurved_guide_5_beforeChopper_l
#define R0 mcccurved_guide_5_beforeChopper_R0
#define Qc mcccurved_guide_5_beforeChopper_Qc
#define alpha mcccurved_guide_5_beforeChopper_alpha
#define m mcccurved_guide_5_beforeChopper_m
#define W mcccurved_guide_5_beforeChopper_W
#define nslit mcccurved_guide_5_beforeChopper_nslit
#define d mcccurved_guide_5_beforeChopper_d
#define mleft mcccurved_guide_5_beforeChopper_mleft
#define mright mcccurved_guide_5_beforeChopper_mright
#define mtop mcccurved_guide_5_beforeChopper_mtop
#define mbottom mcccurved_guide_5_beforeChopper_mbottom
#define nhslit mcccurved_guide_5_beforeChopper_nhslit
#define G mcccurved_guide_5_beforeChopper_G
#define aleft mcccurved_guide_5_beforeChopper_aleft
#define aright mcccurved_guide_5_beforeChopper_aright
#define atop mcccurved_guide_5_beforeChopper_atop
#define abottom mcccurved_guide_5_beforeChopper_abottom
#define wavy mcccurved_guide_5_beforeChopper_wavy
#define wavy_z mcccurved_guide_5_beforeChopper_wavy_z
#define wavy_tb mcccurved_guide_5_beforeChopper_wavy_tb
#define wavy_lr mcccurved_guide_5_beforeChopper_wavy_lr
#define chamfers mcccurved_guide_5_beforeChopper_chamfers
#define chamfers_z mcccurved_guide_5_beforeChopper_chamfers_z
#define chamfers_lr mcccurved_guide_5_beforeChopper_chamfers_lr
#define chamfers_tb mcccurved_guide_5_beforeChopper_chamfers_tb
#define nelements mcccurved_guide_5_beforeChopper_nelements
#define nu mcccurved_guide_5_beforeChopper_nu
#define phase mcccurved_guide_5_beforeChopper_phase
#define reflect mcccurved_guide_5_beforeChopper_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14470 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_5_afterChopper' [12]. */
#define mccompcurname  curved_guide_5_afterChopper
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 12
#define GVars mcccurved_guide_5_afterChopper_GVars
#define pTable mcccurved_guide_5_afterChopper_pTable
#define w1 mcccurved_guide_5_afterChopper_w1
#define h1 mcccurved_guide_5_afterChopper_h1
#define w2 mcccurved_guide_5_afterChopper_w2
#define h2 mcccurved_guide_5_afterChopper_h2
#define l mcccurved_guide_5_afterChopper_l
#define R0 mcccurved_guide_5_afterChopper_R0
#define Qc mcccurved_guide_5_afterChopper_Qc
#define alpha mcccurved_guide_5_afterChopper_alpha
#define m mcccurved_guide_5_afterChopper_m
#define W mcccurved_guide_5_afterChopper_W
#define nslit mcccurved_guide_5_afterChopper_nslit
#define d mcccurved_guide_5_afterChopper_d
#define mleft mcccurved_guide_5_afterChopper_mleft
#define mright mcccurved_guide_5_afterChopper_mright
#define mtop mcccurved_guide_5_afterChopper_mtop
#define mbottom mcccurved_guide_5_afterChopper_mbottom
#define nhslit mcccurved_guide_5_afterChopper_nhslit
#define G mcccurved_guide_5_afterChopper_G
#define aleft mcccurved_guide_5_afterChopper_aleft
#define aright mcccurved_guide_5_afterChopper_aright
#define atop mcccurved_guide_5_afterChopper_atop
#define abottom mcccurved_guide_5_afterChopper_abottom
#define wavy mcccurved_guide_5_afterChopper_wavy
#define wavy_z mcccurved_guide_5_afterChopper_wavy_z
#define wavy_tb mcccurved_guide_5_afterChopper_wavy_tb
#define wavy_lr mcccurved_guide_5_afterChopper_wavy_lr
#define chamfers mcccurved_guide_5_afterChopper_chamfers
#define chamfers_z mcccurved_guide_5_afterChopper_chamfers_z
#define chamfers_lr mcccurved_guide_5_afterChopper_chamfers_lr
#define chamfers_tb mcccurved_guide_5_afterChopper_chamfers_tb
#define nelements mcccurved_guide_5_afterChopper_nelements
#define nu mcccurved_guide_5_afterChopper_nu
#define phase mcccurved_guide_5_afterChopper_phase
#define reflect mcccurved_guide_5_afterChopper_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14554 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_6_0' [13]. */
#define mccompcurname  curved_guide_6_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 13
#define GVars mcccurved_guide_6_0_GVars
#define pTable mcccurved_guide_6_0_pTable
#define w1 mcccurved_guide_6_0_w1
#define h1 mcccurved_guide_6_0_h1
#define w2 mcccurved_guide_6_0_w2
#define h2 mcccurved_guide_6_0_h2
#define l mcccurved_guide_6_0_l
#define R0 mcccurved_guide_6_0_R0
#define Qc mcccurved_guide_6_0_Qc
#define alpha mcccurved_guide_6_0_alpha
#define m mcccurved_guide_6_0_m
#define W mcccurved_guide_6_0_W
#define nslit mcccurved_guide_6_0_nslit
#define d mcccurved_guide_6_0_d
#define mleft mcccurved_guide_6_0_mleft
#define mright mcccurved_guide_6_0_mright
#define mtop mcccurved_guide_6_0_mtop
#define mbottom mcccurved_guide_6_0_mbottom
#define nhslit mcccurved_guide_6_0_nhslit
#define G mcccurved_guide_6_0_G
#define aleft mcccurved_guide_6_0_aleft
#define aright mcccurved_guide_6_0_aright
#define atop mcccurved_guide_6_0_atop
#define abottom mcccurved_guide_6_0_abottom
#define wavy mcccurved_guide_6_0_wavy
#define wavy_z mcccurved_guide_6_0_wavy_z
#define wavy_tb mcccurved_guide_6_0_wavy_tb
#define wavy_lr mcccurved_guide_6_0_wavy_lr
#define chamfers mcccurved_guide_6_0_chamfers
#define chamfers_z mcccurved_guide_6_0_chamfers_z
#define chamfers_lr mcccurved_guide_6_0_chamfers_lr
#define chamfers_tb mcccurved_guide_6_0_chamfers_tb
#define nelements mcccurved_guide_6_0_nelements
#define nu mcccurved_guide_6_0_nu
#define phase mcccurved_guide_6_0_phase
#define reflect mcccurved_guide_6_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14638 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_7_0' [14]. */
#define mccompcurname  curved_guide_7_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 14
#define GVars mcccurved_guide_7_0_GVars
#define pTable mcccurved_guide_7_0_pTable
#define w1 mcccurved_guide_7_0_w1
#define h1 mcccurved_guide_7_0_h1
#define w2 mcccurved_guide_7_0_w2
#define h2 mcccurved_guide_7_0_h2
#define l mcccurved_guide_7_0_l
#define R0 mcccurved_guide_7_0_R0
#define Qc mcccurved_guide_7_0_Qc
#define alpha mcccurved_guide_7_0_alpha
#define m mcccurved_guide_7_0_m
#define W mcccurved_guide_7_0_W
#define nslit mcccurved_guide_7_0_nslit
#define d mcccurved_guide_7_0_d
#define mleft mcccurved_guide_7_0_mleft
#define mright mcccurved_guide_7_0_mright
#define mtop mcccurved_guide_7_0_mtop
#define mbottom mcccurved_guide_7_0_mbottom
#define nhslit mcccurved_guide_7_0_nhslit
#define G mcccurved_guide_7_0_G
#define aleft mcccurved_guide_7_0_aleft
#define aright mcccurved_guide_7_0_aright
#define atop mcccurved_guide_7_0_atop
#define abottom mcccurved_guide_7_0_abottom
#define wavy mcccurved_guide_7_0_wavy
#define wavy_z mcccurved_guide_7_0_wavy_z
#define wavy_tb mcccurved_guide_7_0_wavy_tb
#define wavy_lr mcccurved_guide_7_0_wavy_lr
#define chamfers mcccurved_guide_7_0_chamfers
#define chamfers_z mcccurved_guide_7_0_chamfers_z
#define chamfers_lr mcccurved_guide_7_0_chamfers_lr
#define chamfers_tb mcccurved_guide_7_0_chamfers_tb
#define nelements mcccurved_guide_7_0_nelements
#define nu mcccurved_guide_7_0_nu
#define phase mcccurved_guide_7_0_phase
#define reflect mcccurved_guide_7_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14722 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_8_0' [15]. */
#define mccompcurname  curved_guide_8_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 15
#define GVars mcccurved_guide_8_0_GVars
#define pTable mcccurved_guide_8_0_pTable
#define w1 mcccurved_guide_8_0_w1
#define h1 mcccurved_guide_8_0_h1
#define w2 mcccurved_guide_8_0_w2
#define h2 mcccurved_guide_8_0_h2
#define l mcccurved_guide_8_0_l
#define R0 mcccurved_guide_8_0_R0
#define Qc mcccurved_guide_8_0_Qc
#define alpha mcccurved_guide_8_0_alpha
#define m mcccurved_guide_8_0_m
#define W mcccurved_guide_8_0_W
#define nslit mcccurved_guide_8_0_nslit
#define d mcccurved_guide_8_0_d
#define mleft mcccurved_guide_8_0_mleft
#define mright mcccurved_guide_8_0_mright
#define mtop mcccurved_guide_8_0_mtop
#define mbottom mcccurved_guide_8_0_mbottom
#define nhslit mcccurved_guide_8_0_nhslit
#define G mcccurved_guide_8_0_G
#define aleft mcccurved_guide_8_0_aleft
#define aright mcccurved_guide_8_0_aright
#define atop mcccurved_guide_8_0_atop
#define abottom mcccurved_guide_8_0_abottom
#define wavy mcccurved_guide_8_0_wavy
#define wavy_z mcccurved_guide_8_0_wavy_z
#define wavy_tb mcccurved_guide_8_0_wavy_tb
#define wavy_lr mcccurved_guide_8_0_wavy_lr
#define chamfers mcccurved_guide_8_0_chamfers
#define chamfers_z mcccurved_guide_8_0_chamfers_z
#define chamfers_lr mcccurved_guide_8_0_chamfers_lr
#define chamfers_tb mcccurved_guide_8_0_chamfers_tb
#define nelements mcccurved_guide_8_0_nelements
#define nu mcccurved_guide_8_0_nu
#define phase mcccurved_guide_8_0_phase
#define reflect mcccurved_guide_8_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14806 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_9_0' [16]. */
#define mccompcurname  curved_guide_9_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 16
#define GVars mcccurved_guide_9_0_GVars
#define pTable mcccurved_guide_9_0_pTable
#define w1 mcccurved_guide_9_0_w1
#define h1 mcccurved_guide_9_0_h1
#define w2 mcccurved_guide_9_0_w2
#define h2 mcccurved_guide_9_0_h2
#define l mcccurved_guide_9_0_l
#define R0 mcccurved_guide_9_0_R0
#define Qc mcccurved_guide_9_0_Qc
#define alpha mcccurved_guide_9_0_alpha
#define m mcccurved_guide_9_0_m
#define W mcccurved_guide_9_0_W
#define nslit mcccurved_guide_9_0_nslit
#define d mcccurved_guide_9_0_d
#define mleft mcccurved_guide_9_0_mleft
#define mright mcccurved_guide_9_0_mright
#define mtop mcccurved_guide_9_0_mtop
#define mbottom mcccurved_guide_9_0_mbottom
#define nhslit mcccurved_guide_9_0_nhslit
#define G mcccurved_guide_9_0_G
#define aleft mcccurved_guide_9_0_aleft
#define aright mcccurved_guide_9_0_aright
#define atop mcccurved_guide_9_0_atop
#define abottom mcccurved_guide_9_0_abottom
#define wavy mcccurved_guide_9_0_wavy
#define wavy_z mcccurved_guide_9_0_wavy_z
#define wavy_tb mcccurved_guide_9_0_wavy_tb
#define wavy_lr mcccurved_guide_9_0_wavy_lr
#define chamfers mcccurved_guide_9_0_chamfers
#define chamfers_z mcccurved_guide_9_0_chamfers_z
#define chamfers_lr mcccurved_guide_9_0_chamfers_lr
#define chamfers_tb mcccurved_guide_9_0_chamfers_tb
#define nelements mcccurved_guide_9_0_nelements
#define nu mcccurved_guide_9_0_nu
#define phase mcccurved_guide_9_0_phase
#define reflect mcccurved_guide_9_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14890 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_10_0' [17]. */
#define mccompcurname  curved_guide_10_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 17
#define GVars mcccurved_guide_10_0_GVars
#define pTable mcccurved_guide_10_0_pTable
#define w1 mcccurved_guide_10_0_w1
#define h1 mcccurved_guide_10_0_h1
#define w2 mcccurved_guide_10_0_w2
#define h2 mcccurved_guide_10_0_h2
#define l mcccurved_guide_10_0_l
#define R0 mcccurved_guide_10_0_R0
#define Qc mcccurved_guide_10_0_Qc
#define alpha mcccurved_guide_10_0_alpha
#define m mcccurved_guide_10_0_m
#define W mcccurved_guide_10_0_W
#define nslit mcccurved_guide_10_0_nslit
#define d mcccurved_guide_10_0_d
#define mleft mcccurved_guide_10_0_mleft
#define mright mcccurved_guide_10_0_mright
#define mtop mcccurved_guide_10_0_mtop
#define mbottom mcccurved_guide_10_0_mbottom
#define nhslit mcccurved_guide_10_0_nhslit
#define G mcccurved_guide_10_0_G
#define aleft mcccurved_guide_10_0_aleft
#define aright mcccurved_guide_10_0_aright
#define atop mcccurved_guide_10_0_atop
#define abottom mcccurved_guide_10_0_abottom
#define wavy mcccurved_guide_10_0_wavy
#define wavy_z mcccurved_guide_10_0_wavy_z
#define wavy_tb mcccurved_guide_10_0_wavy_tb
#define wavy_lr mcccurved_guide_10_0_wavy_lr
#define chamfers mcccurved_guide_10_0_chamfers
#define chamfers_z mcccurved_guide_10_0_chamfers_z
#define chamfers_lr mcccurved_guide_10_0_chamfers_lr
#define chamfers_tb mcccurved_guide_10_0_chamfers_tb
#define nelements mcccurved_guide_10_0_nelements
#define nu mcccurved_guide_10_0_nu
#define phase mcccurved_guide_10_0_phase
#define reflect mcccurved_guide_10_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14974 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_11_0' [18]. */
#define mccompcurname  curved_guide_11_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 18
#define GVars mcccurved_guide_11_0_GVars
#define pTable mcccurved_guide_11_0_pTable
#define w1 mcccurved_guide_11_0_w1
#define h1 mcccurved_guide_11_0_h1
#define w2 mcccurved_guide_11_0_w2
#define h2 mcccurved_guide_11_0_h2
#define l mcccurved_guide_11_0_l
#define R0 mcccurved_guide_11_0_R0
#define Qc mcccurved_guide_11_0_Qc
#define alpha mcccurved_guide_11_0_alpha
#define m mcccurved_guide_11_0_m
#define W mcccurved_guide_11_0_W
#define nslit mcccurved_guide_11_0_nslit
#define d mcccurved_guide_11_0_d
#define mleft mcccurved_guide_11_0_mleft
#define mright mcccurved_guide_11_0_mright
#define mtop mcccurved_guide_11_0_mtop
#define mbottom mcccurved_guide_11_0_mbottom
#define nhslit mcccurved_guide_11_0_nhslit
#define G mcccurved_guide_11_0_G
#define aleft mcccurved_guide_11_0_aleft
#define aright mcccurved_guide_11_0_aright
#define atop mcccurved_guide_11_0_atop
#define abottom mcccurved_guide_11_0_abottom
#define wavy mcccurved_guide_11_0_wavy
#define wavy_z mcccurved_guide_11_0_wavy_z
#define wavy_tb mcccurved_guide_11_0_wavy_tb
#define wavy_lr mcccurved_guide_11_0_wavy_lr
#define chamfers mcccurved_guide_11_0_chamfers
#define chamfers_z mcccurved_guide_11_0_chamfers_z
#define chamfers_lr mcccurved_guide_11_0_chamfers_lr
#define chamfers_tb mcccurved_guide_11_0_chamfers_tb
#define nelements mcccurved_guide_11_0_nelements
#define nu mcccurved_guide_11_0_nu
#define phase mcccurved_guide_11_0_phase
#define reflect mcccurved_guide_11_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15058 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_12_0' [19]. */
#define mccompcurname  curved_guide_12_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 19
#define GVars mcccurved_guide_12_0_GVars
#define pTable mcccurved_guide_12_0_pTable
#define w1 mcccurved_guide_12_0_w1
#define h1 mcccurved_guide_12_0_h1
#define w2 mcccurved_guide_12_0_w2
#define h2 mcccurved_guide_12_0_h2
#define l mcccurved_guide_12_0_l
#define R0 mcccurved_guide_12_0_R0
#define Qc mcccurved_guide_12_0_Qc
#define alpha mcccurved_guide_12_0_alpha
#define m mcccurved_guide_12_0_m
#define W mcccurved_guide_12_0_W
#define nslit mcccurved_guide_12_0_nslit
#define d mcccurved_guide_12_0_d
#define mleft mcccurved_guide_12_0_mleft
#define mright mcccurved_guide_12_0_mright
#define mtop mcccurved_guide_12_0_mtop
#define mbottom mcccurved_guide_12_0_mbottom
#define nhslit mcccurved_guide_12_0_nhslit
#define G mcccurved_guide_12_0_G
#define aleft mcccurved_guide_12_0_aleft
#define aright mcccurved_guide_12_0_aright
#define atop mcccurved_guide_12_0_atop
#define abottom mcccurved_guide_12_0_abottom
#define wavy mcccurved_guide_12_0_wavy
#define wavy_z mcccurved_guide_12_0_wavy_z
#define wavy_tb mcccurved_guide_12_0_wavy_tb
#define wavy_lr mcccurved_guide_12_0_wavy_lr
#define chamfers mcccurved_guide_12_0_chamfers
#define chamfers_z mcccurved_guide_12_0_chamfers_z
#define chamfers_lr mcccurved_guide_12_0_chamfers_lr
#define chamfers_tb mcccurved_guide_12_0_chamfers_tb
#define nelements mcccurved_guide_12_0_nelements
#define nu mcccurved_guide_12_0_nu
#define phase mcccurved_guide_12_0_phase
#define reflect mcccurved_guide_12_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15142 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_13_0' [20]. */
#define mccompcurname  curved_guide_13_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 20
#define GVars mcccurved_guide_13_0_GVars
#define pTable mcccurved_guide_13_0_pTable
#define w1 mcccurved_guide_13_0_w1
#define h1 mcccurved_guide_13_0_h1
#define w2 mcccurved_guide_13_0_w2
#define h2 mcccurved_guide_13_0_h2
#define l mcccurved_guide_13_0_l
#define R0 mcccurved_guide_13_0_R0
#define Qc mcccurved_guide_13_0_Qc
#define alpha mcccurved_guide_13_0_alpha
#define m mcccurved_guide_13_0_m
#define W mcccurved_guide_13_0_W
#define nslit mcccurved_guide_13_0_nslit
#define d mcccurved_guide_13_0_d
#define mleft mcccurved_guide_13_0_mleft
#define mright mcccurved_guide_13_0_mright
#define mtop mcccurved_guide_13_0_mtop
#define mbottom mcccurved_guide_13_0_mbottom
#define nhslit mcccurved_guide_13_0_nhslit
#define G mcccurved_guide_13_0_G
#define aleft mcccurved_guide_13_0_aleft
#define aright mcccurved_guide_13_0_aright
#define atop mcccurved_guide_13_0_atop
#define abottom mcccurved_guide_13_0_abottom
#define wavy mcccurved_guide_13_0_wavy
#define wavy_z mcccurved_guide_13_0_wavy_z
#define wavy_tb mcccurved_guide_13_0_wavy_tb
#define wavy_lr mcccurved_guide_13_0_wavy_lr
#define chamfers mcccurved_guide_13_0_chamfers
#define chamfers_z mcccurved_guide_13_0_chamfers_z
#define chamfers_lr mcccurved_guide_13_0_chamfers_lr
#define chamfers_tb mcccurved_guide_13_0_chamfers_tb
#define nelements mcccurved_guide_13_0_nelements
#define nu mcccurved_guide_13_0_nu
#define phase mcccurved_guide_13_0_phase
#define reflect mcccurved_guide_13_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15226 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_14_0' [21]. */
#define mccompcurname  curved_guide_14_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 21
#define GVars mcccurved_guide_14_0_GVars
#define pTable mcccurved_guide_14_0_pTable
#define w1 mcccurved_guide_14_0_w1
#define h1 mcccurved_guide_14_0_h1
#define w2 mcccurved_guide_14_0_w2
#define h2 mcccurved_guide_14_0_h2
#define l mcccurved_guide_14_0_l
#define R0 mcccurved_guide_14_0_R0
#define Qc mcccurved_guide_14_0_Qc
#define alpha mcccurved_guide_14_0_alpha
#define m mcccurved_guide_14_0_m
#define W mcccurved_guide_14_0_W
#define nslit mcccurved_guide_14_0_nslit
#define d mcccurved_guide_14_0_d
#define mleft mcccurved_guide_14_0_mleft
#define mright mcccurved_guide_14_0_mright
#define mtop mcccurved_guide_14_0_mtop
#define mbottom mcccurved_guide_14_0_mbottom
#define nhslit mcccurved_guide_14_0_nhslit
#define G mcccurved_guide_14_0_G
#define aleft mcccurved_guide_14_0_aleft
#define aright mcccurved_guide_14_0_aright
#define atop mcccurved_guide_14_0_atop
#define abottom mcccurved_guide_14_0_abottom
#define wavy mcccurved_guide_14_0_wavy
#define wavy_z mcccurved_guide_14_0_wavy_z
#define wavy_tb mcccurved_guide_14_0_wavy_tb
#define wavy_lr mcccurved_guide_14_0_wavy_lr
#define chamfers mcccurved_guide_14_0_chamfers
#define chamfers_z mcccurved_guide_14_0_chamfers_z
#define chamfers_lr mcccurved_guide_14_0_chamfers_lr
#define chamfers_tb mcccurved_guide_14_0_chamfers_tb
#define nelements mcccurved_guide_14_0_nelements
#define nu mcccurved_guide_14_0_nu
#define phase mcccurved_guide_14_0_phase
#define reflect mcccurved_guide_14_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15310 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_15_0' [22]. */
#define mccompcurname  curved_guide_15_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 22
#define GVars mcccurved_guide_15_0_GVars
#define pTable mcccurved_guide_15_0_pTable
#define w1 mcccurved_guide_15_0_w1
#define h1 mcccurved_guide_15_0_h1
#define w2 mcccurved_guide_15_0_w2
#define h2 mcccurved_guide_15_0_h2
#define l mcccurved_guide_15_0_l
#define R0 mcccurved_guide_15_0_R0
#define Qc mcccurved_guide_15_0_Qc
#define alpha mcccurved_guide_15_0_alpha
#define m mcccurved_guide_15_0_m
#define W mcccurved_guide_15_0_W
#define nslit mcccurved_guide_15_0_nslit
#define d mcccurved_guide_15_0_d
#define mleft mcccurved_guide_15_0_mleft
#define mright mcccurved_guide_15_0_mright
#define mtop mcccurved_guide_15_0_mtop
#define mbottom mcccurved_guide_15_0_mbottom
#define nhslit mcccurved_guide_15_0_nhslit
#define G mcccurved_guide_15_0_G
#define aleft mcccurved_guide_15_0_aleft
#define aright mcccurved_guide_15_0_aright
#define atop mcccurved_guide_15_0_atop
#define abottom mcccurved_guide_15_0_abottom
#define wavy mcccurved_guide_15_0_wavy
#define wavy_z mcccurved_guide_15_0_wavy_z
#define wavy_tb mcccurved_guide_15_0_wavy_tb
#define wavy_lr mcccurved_guide_15_0_wavy_lr
#define chamfers mcccurved_guide_15_0_chamfers
#define chamfers_z mcccurved_guide_15_0_chamfers_z
#define chamfers_lr mcccurved_guide_15_0_chamfers_lr
#define chamfers_tb mcccurved_guide_15_0_chamfers_tb
#define nelements mcccurved_guide_15_0_nelements
#define nu mcccurved_guide_15_0_nu
#define phase mcccurved_guide_15_0_phase
#define reflect mcccurved_guide_15_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15394 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_16_0' [23]. */
#define mccompcurname  curved_guide_16_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 23
#define GVars mcccurved_guide_16_0_GVars
#define pTable mcccurved_guide_16_0_pTable
#define w1 mcccurved_guide_16_0_w1
#define h1 mcccurved_guide_16_0_h1
#define w2 mcccurved_guide_16_0_w2
#define h2 mcccurved_guide_16_0_h2
#define l mcccurved_guide_16_0_l
#define R0 mcccurved_guide_16_0_R0
#define Qc mcccurved_guide_16_0_Qc
#define alpha mcccurved_guide_16_0_alpha
#define m mcccurved_guide_16_0_m
#define W mcccurved_guide_16_0_W
#define nslit mcccurved_guide_16_0_nslit
#define d mcccurved_guide_16_0_d
#define mleft mcccurved_guide_16_0_mleft
#define mright mcccurved_guide_16_0_mright
#define mtop mcccurved_guide_16_0_mtop
#define mbottom mcccurved_guide_16_0_mbottom
#define nhslit mcccurved_guide_16_0_nhslit
#define G mcccurved_guide_16_0_G
#define aleft mcccurved_guide_16_0_aleft
#define aright mcccurved_guide_16_0_aright
#define atop mcccurved_guide_16_0_atop
#define abottom mcccurved_guide_16_0_abottom
#define wavy mcccurved_guide_16_0_wavy
#define wavy_z mcccurved_guide_16_0_wavy_z
#define wavy_tb mcccurved_guide_16_0_wavy_tb
#define wavy_lr mcccurved_guide_16_0_wavy_lr
#define chamfers mcccurved_guide_16_0_chamfers
#define chamfers_z mcccurved_guide_16_0_chamfers_z
#define chamfers_lr mcccurved_guide_16_0_chamfers_lr
#define chamfers_tb mcccurved_guide_16_0_chamfers_tb
#define nelements mcccurved_guide_16_0_nelements
#define nu mcccurved_guide_16_0_nu
#define phase mcccurved_guide_16_0_phase
#define reflect mcccurved_guide_16_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15478 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_17_0' [24]. */
#define mccompcurname  curved_guide_17_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 24
#define GVars mcccurved_guide_17_0_GVars
#define pTable mcccurved_guide_17_0_pTable
#define w1 mcccurved_guide_17_0_w1
#define h1 mcccurved_guide_17_0_h1
#define w2 mcccurved_guide_17_0_w2
#define h2 mcccurved_guide_17_0_h2
#define l mcccurved_guide_17_0_l
#define R0 mcccurved_guide_17_0_R0
#define Qc mcccurved_guide_17_0_Qc
#define alpha mcccurved_guide_17_0_alpha
#define m mcccurved_guide_17_0_m
#define W mcccurved_guide_17_0_W
#define nslit mcccurved_guide_17_0_nslit
#define d mcccurved_guide_17_0_d
#define mleft mcccurved_guide_17_0_mleft
#define mright mcccurved_guide_17_0_mright
#define mtop mcccurved_guide_17_0_mtop
#define mbottom mcccurved_guide_17_0_mbottom
#define nhslit mcccurved_guide_17_0_nhslit
#define G mcccurved_guide_17_0_G
#define aleft mcccurved_guide_17_0_aleft
#define aright mcccurved_guide_17_0_aright
#define atop mcccurved_guide_17_0_atop
#define abottom mcccurved_guide_17_0_abottom
#define wavy mcccurved_guide_17_0_wavy
#define wavy_z mcccurved_guide_17_0_wavy_z
#define wavy_tb mcccurved_guide_17_0_wavy_tb
#define wavy_lr mcccurved_guide_17_0_wavy_lr
#define chamfers mcccurved_guide_17_0_chamfers
#define chamfers_z mcccurved_guide_17_0_chamfers_z
#define chamfers_lr mcccurved_guide_17_0_chamfers_lr
#define chamfers_tb mcccurved_guide_17_0_chamfers_tb
#define nelements mcccurved_guide_17_0_nelements
#define nu mcccurved_guide_17_0_nu
#define phase mcccurved_guide_17_0_phase
#define reflect mcccurved_guide_17_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15562 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_18_beforeChopper' [25]. */
#define mccompcurname  curved_guide_18_beforeChopper
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 25
#define GVars mcccurved_guide_18_beforeChopper_GVars
#define pTable mcccurved_guide_18_beforeChopper_pTable
#define w1 mcccurved_guide_18_beforeChopper_w1
#define h1 mcccurved_guide_18_beforeChopper_h1
#define w2 mcccurved_guide_18_beforeChopper_w2
#define h2 mcccurved_guide_18_beforeChopper_h2
#define l mcccurved_guide_18_beforeChopper_l
#define R0 mcccurved_guide_18_beforeChopper_R0
#define Qc mcccurved_guide_18_beforeChopper_Qc
#define alpha mcccurved_guide_18_beforeChopper_alpha
#define m mcccurved_guide_18_beforeChopper_m
#define W mcccurved_guide_18_beforeChopper_W
#define nslit mcccurved_guide_18_beforeChopper_nslit
#define d mcccurved_guide_18_beforeChopper_d
#define mleft mcccurved_guide_18_beforeChopper_mleft
#define mright mcccurved_guide_18_beforeChopper_mright
#define mtop mcccurved_guide_18_beforeChopper_mtop
#define mbottom mcccurved_guide_18_beforeChopper_mbottom
#define nhslit mcccurved_guide_18_beforeChopper_nhslit
#define G mcccurved_guide_18_beforeChopper_G
#define aleft mcccurved_guide_18_beforeChopper_aleft
#define aright mcccurved_guide_18_beforeChopper_aright
#define atop mcccurved_guide_18_beforeChopper_atop
#define abottom mcccurved_guide_18_beforeChopper_abottom
#define wavy mcccurved_guide_18_beforeChopper_wavy
#define wavy_z mcccurved_guide_18_beforeChopper_wavy_z
#define wavy_tb mcccurved_guide_18_beforeChopper_wavy_tb
#define wavy_lr mcccurved_guide_18_beforeChopper_wavy_lr
#define chamfers mcccurved_guide_18_beforeChopper_chamfers
#define chamfers_z mcccurved_guide_18_beforeChopper_chamfers_z
#define chamfers_lr mcccurved_guide_18_beforeChopper_chamfers_lr
#define chamfers_tb mcccurved_guide_18_beforeChopper_chamfers_tb
#define nelements mcccurved_guide_18_beforeChopper_nelements
#define nu mcccurved_guide_18_beforeChopper_nu
#define phase mcccurved_guide_18_beforeChopper_phase
#define reflect mcccurved_guide_18_beforeChopper_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15646 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_18_afterChopper' [26]. */
#define mccompcurname  curved_guide_18_afterChopper
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 26
#define GVars mcccurved_guide_18_afterChopper_GVars
#define pTable mcccurved_guide_18_afterChopper_pTable
#define w1 mcccurved_guide_18_afterChopper_w1
#define h1 mcccurved_guide_18_afterChopper_h1
#define w2 mcccurved_guide_18_afterChopper_w2
#define h2 mcccurved_guide_18_afterChopper_h2
#define l mcccurved_guide_18_afterChopper_l
#define R0 mcccurved_guide_18_afterChopper_R0
#define Qc mcccurved_guide_18_afterChopper_Qc
#define alpha mcccurved_guide_18_afterChopper_alpha
#define m mcccurved_guide_18_afterChopper_m
#define W mcccurved_guide_18_afterChopper_W
#define nslit mcccurved_guide_18_afterChopper_nslit
#define d mcccurved_guide_18_afterChopper_d
#define mleft mcccurved_guide_18_afterChopper_mleft
#define mright mcccurved_guide_18_afterChopper_mright
#define mtop mcccurved_guide_18_afterChopper_mtop
#define mbottom mcccurved_guide_18_afterChopper_mbottom
#define nhslit mcccurved_guide_18_afterChopper_nhslit
#define G mcccurved_guide_18_afterChopper_G
#define aleft mcccurved_guide_18_afterChopper_aleft
#define aright mcccurved_guide_18_afterChopper_aright
#define atop mcccurved_guide_18_afterChopper_atop
#define abottom mcccurved_guide_18_afterChopper_abottom
#define wavy mcccurved_guide_18_afterChopper_wavy
#define wavy_z mcccurved_guide_18_afterChopper_wavy_z
#define wavy_tb mcccurved_guide_18_afterChopper_wavy_tb
#define wavy_lr mcccurved_guide_18_afterChopper_wavy_lr
#define chamfers mcccurved_guide_18_afterChopper_chamfers
#define chamfers_z mcccurved_guide_18_afterChopper_chamfers_z
#define chamfers_lr mcccurved_guide_18_afterChopper_chamfers_lr
#define chamfers_tb mcccurved_guide_18_afterChopper_chamfers_tb
#define nelements mcccurved_guide_18_afterChopper_nelements
#define nu mcccurved_guide_18_afterChopper_nu
#define phase mcccurved_guide_18_afterChopper_phase
#define reflect mcccurved_guide_18_afterChopper_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15730 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_19_0' [27]. */
#define mccompcurname  curved_guide_19_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 27
#define GVars mcccurved_guide_19_0_GVars
#define pTable mcccurved_guide_19_0_pTable
#define w1 mcccurved_guide_19_0_w1
#define h1 mcccurved_guide_19_0_h1
#define w2 mcccurved_guide_19_0_w2
#define h2 mcccurved_guide_19_0_h2
#define l mcccurved_guide_19_0_l
#define R0 mcccurved_guide_19_0_R0
#define Qc mcccurved_guide_19_0_Qc
#define alpha mcccurved_guide_19_0_alpha
#define m mcccurved_guide_19_0_m
#define W mcccurved_guide_19_0_W
#define nslit mcccurved_guide_19_0_nslit
#define d mcccurved_guide_19_0_d
#define mleft mcccurved_guide_19_0_mleft
#define mright mcccurved_guide_19_0_mright
#define mtop mcccurved_guide_19_0_mtop
#define mbottom mcccurved_guide_19_0_mbottom
#define nhslit mcccurved_guide_19_0_nhslit
#define G mcccurved_guide_19_0_G
#define aleft mcccurved_guide_19_0_aleft
#define aright mcccurved_guide_19_0_aright
#define atop mcccurved_guide_19_0_atop
#define abottom mcccurved_guide_19_0_abottom
#define wavy mcccurved_guide_19_0_wavy
#define wavy_z mcccurved_guide_19_0_wavy_z
#define wavy_tb mcccurved_guide_19_0_wavy_tb
#define wavy_lr mcccurved_guide_19_0_wavy_lr
#define chamfers mcccurved_guide_19_0_chamfers
#define chamfers_z mcccurved_guide_19_0_chamfers_z
#define chamfers_lr mcccurved_guide_19_0_chamfers_lr
#define chamfers_tb mcccurved_guide_19_0_chamfers_tb
#define nelements mcccurved_guide_19_0_nelements
#define nu mcccurved_guide_19_0_nu
#define phase mcccurved_guide_19_0_phase
#define reflect mcccurved_guide_19_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15814 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_20_0' [28]. */
#define mccompcurname  curved_guide_20_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 28
#define GVars mcccurved_guide_20_0_GVars
#define pTable mcccurved_guide_20_0_pTable
#define w1 mcccurved_guide_20_0_w1
#define h1 mcccurved_guide_20_0_h1
#define w2 mcccurved_guide_20_0_w2
#define h2 mcccurved_guide_20_0_h2
#define l mcccurved_guide_20_0_l
#define R0 mcccurved_guide_20_0_R0
#define Qc mcccurved_guide_20_0_Qc
#define alpha mcccurved_guide_20_0_alpha
#define m mcccurved_guide_20_0_m
#define W mcccurved_guide_20_0_W
#define nslit mcccurved_guide_20_0_nslit
#define d mcccurved_guide_20_0_d
#define mleft mcccurved_guide_20_0_mleft
#define mright mcccurved_guide_20_0_mright
#define mtop mcccurved_guide_20_0_mtop
#define mbottom mcccurved_guide_20_0_mbottom
#define nhslit mcccurved_guide_20_0_nhslit
#define G mcccurved_guide_20_0_G
#define aleft mcccurved_guide_20_0_aleft
#define aright mcccurved_guide_20_0_aright
#define atop mcccurved_guide_20_0_atop
#define abottom mcccurved_guide_20_0_abottom
#define wavy mcccurved_guide_20_0_wavy
#define wavy_z mcccurved_guide_20_0_wavy_z
#define wavy_tb mcccurved_guide_20_0_wavy_tb
#define wavy_lr mcccurved_guide_20_0_wavy_lr
#define chamfers mcccurved_guide_20_0_chamfers
#define chamfers_z mcccurved_guide_20_0_chamfers_z
#define chamfers_lr mcccurved_guide_20_0_chamfers_lr
#define chamfers_tb mcccurved_guide_20_0_chamfers_tb
#define nelements mcccurved_guide_20_0_nelements
#define nu mcccurved_guide_20_0_nu
#define phase mcccurved_guide_20_0_phase
#define reflect mcccurved_guide_20_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15898 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_21_0' [29]. */
#define mccompcurname  curved_guide_21_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 29
#define GVars mcccurved_guide_21_0_GVars
#define pTable mcccurved_guide_21_0_pTable
#define w1 mcccurved_guide_21_0_w1
#define h1 mcccurved_guide_21_0_h1
#define w2 mcccurved_guide_21_0_w2
#define h2 mcccurved_guide_21_0_h2
#define l mcccurved_guide_21_0_l
#define R0 mcccurved_guide_21_0_R0
#define Qc mcccurved_guide_21_0_Qc
#define alpha mcccurved_guide_21_0_alpha
#define m mcccurved_guide_21_0_m
#define W mcccurved_guide_21_0_W
#define nslit mcccurved_guide_21_0_nslit
#define d mcccurved_guide_21_0_d
#define mleft mcccurved_guide_21_0_mleft
#define mright mcccurved_guide_21_0_mright
#define mtop mcccurved_guide_21_0_mtop
#define mbottom mcccurved_guide_21_0_mbottom
#define nhslit mcccurved_guide_21_0_nhslit
#define G mcccurved_guide_21_0_G
#define aleft mcccurved_guide_21_0_aleft
#define aright mcccurved_guide_21_0_aright
#define atop mcccurved_guide_21_0_atop
#define abottom mcccurved_guide_21_0_abottom
#define wavy mcccurved_guide_21_0_wavy
#define wavy_z mcccurved_guide_21_0_wavy_z
#define wavy_tb mcccurved_guide_21_0_wavy_tb
#define wavy_lr mcccurved_guide_21_0_wavy_lr
#define chamfers mcccurved_guide_21_0_chamfers
#define chamfers_z mcccurved_guide_21_0_chamfers_z
#define chamfers_lr mcccurved_guide_21_0_chamfers_lr
#define chamfers_tb mcccurved_guide_21_0_chamfers_tb
#define nelements mcccurved_guide_21_0_nelements
#define nu mcccurved_guide_21_0_nu
#define phase mcccurved_guide_21_0_phase
#define reflect mcccurved_guide_21_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15982 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_22_0' [30]. */
#define mccompcurname  curved_guide_22_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 30
#define GVars mcccurved_guide_22_0_GVars
#define pTable mcccurved_guide_22_0_pTable
#define w1 mcccurved_guide_22_0_w1
#define h1 mcccurved_guide_22_0_h1
#define w2 mcccurved_guide_22_0_w2
#define h2 mcccurved_guide_22_0_h2
#define l mcccurved_guide_22_0_l
#define R0 mcccurved_guide_22_0_R0
#define Qc mcccurved_guide_22_0_Qc
#define alpha mcccurved_guide_22_0_alpha
#define m mcccurved_guide_22_0_m
#define W mcccurved_guide_22_0_W
#define nslit mcccurved_guide_22_0_nslit
#define d mcccurved_guide_22_0_d
#define mleft mcccurved_guide_22_0_mleft
#define mright mcccurved_guide_22_0_mright
#define mtop mcccurved_guide_22_0_mtop
#define mbottom mcccurved_guide_22_0_mbottom
#define nhslit mcccurved_guide_22_0_nhslit
#define G mcccurved_guide_22_0_G
#define aleft mcccurved_guide_22_0_aleft
#define aright mcccurved_guide_22_0_aright
#define atop mcccurved_guide_22_0_atop
#define abottom mcccurved_guide_22_0_abottom
#define wavy mcccurved_guide_22_0_wavy
#define wavy_z mcccurved_guide_22_0_wavy_z
#define wavy_tb mcccurved_guide_22_0_wavy_tb
#define wavy_lr mcccurved_guide_22_0_wavy_lr
#define chamfers mcccurved_guide_22_0_chamfers
#define chamfers_z mcccurved_guide_22_0_chamfers_z
#define chamfers_lr mcccurved_guide_22_0_chamfers_lr
#define chamfers_tb mcccurved_guide_22_0_chamfers_tb
#define nelements mcccurved_guide_22_0_nelements
#define nu mcccurved_guide_22_0_nu
#define phase mcccurved_guide_22_0_phase
#define reflect mcccurved_guide_22_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16066 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_23_0' [31]. */
#define mccompcurname  curved_guide_23_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 31
#define GVars mcccurved_guide_23_0_GVars
#define pTable mcccurved_guide_23_0_pTable
#define w1 mcccurved_guide_23_0_w1
#define h1 mcccurved_guide_23_0_h1
#define w2 mcccurved_guide_23_0_w2
#define h2 mcccurved_guide_23_0_h2
#define l mcccurved_guide_23_0_l
#define R0 mcccurved_guide_23_0_R0
#define Qc mcccurved_guide_23_0_Qc
#define alpha mcccurved_guide_23_0_alpha
#define m mcccurved_guide_23_0_m
#define W mcccurved_guide_23_0_W
#define nslit mcccurved_guide_23_0_nslit
#define d mcccurved_guide_23_0_d
#define mleft mcccurved_guide_23_0_mleft
#define mright mcccurved_guide_23_0_mright
#define mtop mcccurved_guide_23_0_mtop
#define mbottom mcccurved_guide_23_0_mbottom
#define nhslit mcccurved_guide_23_0_nhslit
#define G mcccurved_guide_23_0_G
#define aleft mcccurved_guide_23_0_aleft
#define aright mcccurved_guide_23_0_aright
#define atop mcccurved_guide_23_0_atop
#define abottom mcccurved_guide_23_0_abottom
#define wavy mcccurved_guide_23_0_wavy
#define wavy_z mcccurved_guide_23_0_wavy_z
#define wavy_tb mcccurved_guide_23_0_wavy_tb
#define wavy_lr mcccurved_guide_23_0_wavy_lr
#define chamfers mcccurved_guide_23_0_chamfers
#define chamfers_z mcccurved_guide_23_0_chamfers_z
#define chamfers_lr mcccurved_guide_23_0_chamfers_lr
#define chamfers_tb mcccurved_guide_23_0_chamfers_tb
#define nelements mcccurved_guide_23_0_nelements
#define nu mcccurved_guide_23_0_nu
#define phase mcccurved_guide_23_0_phase
#define reflect mcccurved_guide_23_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16150 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_24_0' [32]. */
#define mccompcurname  curved_guide_24_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 32
#define GVars mcccurved_guide_24_0_GVars
#define pTable mcccurved_guide_24_0_pTable
#define w1 mcccurved_guide_24_0_w1
#define h1 mcccurved_guide_24_0_h1
#define w2 mcccurved_guide_24_0_w2
#define h2 mcccurved_guide_24_0_h2
#define l mcccurved_guide_24_0_l
#define R0 mcccurved_guide_24_0_R0
#define Qc mcccurved_guide_24_0_Qc
#define alpha mcccurved_guide_24_0_alpha
#define m mcccurved_guide_24_0_m
#define W mcccurved_guide_24_0_W
#define nslit mcccurved_guide_24_0_nslit
#define d mcccurved_guide_24_0_d
#define mleft mcccurved_guide_24_0_mleft
#define mright mcccurved_guide_24_0_mright
#define mtop mcccurved_guide_24_0_mtop
#define mbottom mcccurved_guide_24_0_mbottom
#define nhslit mcccurved_guide_24_0_nhslit
#define G mcccurved_guide_24_0_G
#define aleft mcccurved_guide_24_0_aleft
#define aright mcccurved_guide_24_0_aright
#define atop mcccurved_guide_24_0_atop
#define abottom mcccurved_guide_24_0_abottom
#define wavy mcccurved_guide_24_0_wavy
#define wavy_z mcccurved_guide_24_0_wavy_z
#define wavy_tb mcccurved_guide_24_0_wavy_tb
#define wavy_lr mcccurved_guide_24_0_wavy_lr
#define chamfers mcccurved_guide_24_0_chamfers
#define chamfers_z mcccurved_guide_24_0_chamfers_z
#define chamfers_lr mcccurved_guide_24_0_chamfers_lr
#define chamfers_tb mcccurved_guide_24_0_chamfers_tb
#define nelements mcccurved_guide_24_0_nelements
#define nu mcccurved_guide_24_0_nu
#define phase mcccurved_guide_24_0_phase
#define reflect mcccurved_guide_24_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16234 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_25_0' [33]. */
#define mccompcurname  curved_guide_25_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 33
#define GVars mcccurved_guide_25_0_GVars
#define pTable mcccurved_guide_25_0_pTable
#define w1 mcccurved_guide_25_0_w1
#define h1 mcccurved_guide_25_0_h1
#define w2 mcccurved_guide_25_0_w2
#define h2 mcccurved_guide_25_0_h2
#define l mcccurved_guide_25_0_l
#define R0 mcccurved_guide_25_0_R0
#define Qc mcccurved_guide_25_0_Qc
#define alpha mcccurved_guide_25_0_alpha
#define m mcccurved_guide_25_0_m
#define W mcccurved_guide_25_0_W
#define nslit mcccurved_guide_25_0_nslit
#define d mcccurved_guide_25_0_d
#define mleft mcccurved_guide_25_0_mleft
#define mright mcccurved_guide_25_0_mright
#define mtop mcccurved_guide_25_0_mtop
#define mbottom mcccurved_guide_25_0_mbottom
#define nhslit mcccurved_guide_25_0_nhslit
#define G mcccurved_guide_25_0_G
#define aleft mcccurved_guide_25_0_aleft
#define aright mcccurved_guide_25_0_aright
#define atop mcccurved_guide_25_0_atop
#define abottom mcccurved_guide_25_0_abottom
#define wavy mcccurved_guide_25_0_wavy
#define wavy_z mcccurved_guide_25_0_wavy_z
#define wavy_tb mcccurved_guide_25_0_wavy_tb
#define wavy_lr mcccurved_guide_25_0_wavy_lr
#define chamfers mcccurved_guide_25_0_chamfers
#define chamfers_z mcccurved_guide_25_0_chamfers_z
#define chamfers_lr mcccurved_guide_25_0_chamfers_lr
#define chamfers_tb mcccurved_guide_25_0_chamfers_tb
#define nelements mcccurved_guide_25_0_nelements
#define nu mcccurved_guide_25_0_nu
#define phase mcccurved_guide_25_0_phase
#define reflect mcccurved_guide_25_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16318 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_26_0' [34]. */
#define mccompcurname  curved_guide_26_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 34
#define GVars mcccurved_guide_26_0_GVars
#define pTable mcccurved_guide_26_0_pTable
#define w1 mcccurved_guide_26_0_w1
#define h1 mcccurved_guide_26_0_h1
#define w2 mcccurved_guide_26_0_w2
#define h2 mcccurved_guide_26_0_h2
#define l mcccurved_guide_26_0_l
#define R0 mcccurved_guide_26_0_R0
#define Qc mcccurved_guide_26_0_Qc
#define alpha mcccurved_guide_26_0_alpha
#define m mcccurved_guide_26_0_m
#define W mcccurved_guide_26_0_W
#define nslit mcccurved_guide_26_0_nslit
#define d mcccurved_guide_26_0_d
#define mleft mcccurved_guide_26_0_mleft
#define mright mcccurved_guide_26_0_mright
#define mtop mcccurved_guide_26_0_mtop
#define mbottom mcccurved_guide_26_0_mbottom
#define nhslit mcccurved_guide_26_0_nhslit
#define G mcccurved_guide_26_0_G
#define aleft mcccurved_guide_26_0_aleft
#define aright mcccurved_guide_26_0_aright
#define atop mcccurved_guide_26_0_atop
#define abottom mcccurved_guide_26_0_abottom
#define wavy mcccurved_guide_26_0_wavy
#define wavy_z mcccurved_guide_26_0_wavy_z
#define wavy_tb mcccurved_guide_26_0_wavy_tb
#define wavy_lr mcccurved_guide_26_0_wavy_lr
#define chamfers mcccurved_guide_26_0_chamfers
#define chamfers_z mcccurved_guide_26_0_chamfers_z
#define chamfers_lr mcccurved_guide_26_0_chamfers_lr
#define chamfers_tb mcccurved_guide_26_0_chamfers_tb
#define nelements mcccurved_guide_26_0_nelements
#define nu mcccurved_guide_26_0_nu
#define phase mcccurved_guide_26_0_phase
#define reflect mcccurved_guide_26_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16402 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_27_0' [35]. */
#define mccompcurname  curved_guide_27_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 35
#define GVars mcccurved_guide_27_0_GVars
#define pTable mcccurved_guide_27_0_pTable
#define w1 mcccurved_guide_27_0_w1
#define h1 mcccurved_guide_27_0_h1
#define w2 mcccurved_guide_27_0_w2
#define h2 mcccurved_guide_27_0_h2
#define l mcccurved_guide_27_0_l
#define R0 mcccurved_guide_27_0_R0
#define Qc mcccurved_guide_27_0_Qc
#define alpha mcccurved_guide_27_0_alpha
#define m mcccurved_guide_27_0_m
#define W mcccurved_guide_27_0_W
#define nslit mcccurved_guide_27_0_nslit
#define d mcccurved_guide_27_0_d
#define mleft mcccurved_guide_27_0_mleft
#define mright mcccurved_guide_27_0_mright
#define mtop mcccurved_guide_27_0_mtop
#define mbottom mcccurved_guide_27_0_mbottom
#define nhslit mcccurved_guide_27_0_nhslit
#define G mcccurved_guide_27_0_G
#define aleft mcccurved_guide_27_0_aleft
#define aright mcccurved_guide_27_0_aright
#define atop mcccurved_guide_27_0_atop
#define abottom mcccurved_guide_27_0_abottom
#define wavy mcccurved_guide_27_0_wavy
#define wavy_z mcccurved_guide_27_0_wavy_z
#define wavy_tb mcccurved_guide_27_0_wavy_tb
#define wavy_lr mcccurved_guide_27_0_wavy_lr
#define chamfers mcccurved_guide_27_0_chamfers
#define chamfers_z mcccurved_guide_27_0_chamfers_z
#define chamfers_lr mcccurved_guide_27_0_chamfers_lr
#define chamfers_tb mcccurved_guide_27_0_chamfers_tb
#define nelements mcccurved_guide_27_0_nelements
#define nu mcccurved_guide_27_0_nu
#define phase mcccurved_guide_27_0_phase
#define reflect mcccurved_guide_27_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16486 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_28_0' [36]. */
#define mccompcurname  curved_guide_28_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 36
#define GVars mcccurved_guide_28_0_GVars
#define pTable mcccurved_guide_28_0_pTable
#define w1 mcccurved_guide_28_0_w1
#define h1 mcccurved_guide_28_0_h1
#define w2 mcccurved_guide_28_0_w2
#define h2 mcccurved_guide_28_0_h2
#define l mcccurved_guide_28_0_l
#define R0 mcccurved_guide_28_0_R0
#define Qc mcccurved_guide_28_0_Qc
#define alpha mcccurved_guide_28_0_alpha
#define m mcccurved_guide_28_0_m
#define W mcccurved_guide_28_0_W
#define nslit mcccurved_guide_28_0_nslit
#define d mcccurved_guide_28_0_d
#define mleft mcccurved_guide_28_0_mleft
#define mright mcccurved_guide_28_0_mright
#define mtop mcccurved_guide_28_0_mtop
#define mbottom mcccurved_guide_28_0_mbottom
#define nhslit mcccurved_guide_28_0_nhslit
#define G mcccurved_guide_28_0_G
#define aleft mcccurved_guide_28_0_aleft
#define aright mcccurved_guide_28_0_aright
#define atop mcccurved_guide_28_0_atop
#define abottom mcccurved_guide_28_0_abottom
#define wavy mcccurved_guide_28_0_wavy
#define wavy_z mcccurved_guide_28_0_wavy_z
#define wavy_tb mcccurved_guide_28_0_wavy_tb
#define wavy_lr mcccurved_guide_28_0_wavy_lr
#define chamfers mcccurved_guide_28_0_chamfers
#define chamfers_z mcccurved_guide_28_0_chamfers_z
#define chamfers_lr mcccurved_guide_28_0_chamfers_lr
#define chamfers_tb mcccurved_guide_28_0_chamfers_tb
#define nelements mcccurved_guide_28_0_nelements
#define nu mcccurved_guide_28_0_nu
#define phase mcccurved_guide_28_0_phase
#define reflect mcccurved_guide_28_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16570 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_29_0' [37]. */
#define mccompcurname  curved_guide_29_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 37
#define GVars mcccurved_guide_29_0_GVars
#define pTable mcccurved_guide_29_0_pTable
#define w1 mcccurved_guide_29_0_w1
#define h1 mcccurved_guide_29_0_h1
#define w2 mcccurved_guide_29_0_w2
#define h2 mcccurved_guide_29_0_h2
#define l mcccurved_guide_29_0_l
#define R0 mcccurved_guide_29_0_R0
#define Qc mcccurved_guide_29_0_Qc
#define alpha mcccurved_guide_29_0_alpha
#define m mcccurved_guide_29_0_m
#define W mcccurved_guide_29_0_W
#define nslit mcccurved_guide_29_0_nslit
#define d mcccurved_guide_29_0_d
#define mleft mcccurved_guide_29_0_mleft
#define mright mcccurved_guide_29_0_mright
#define mtop mcccurved_guide_29_0_mtop
#define mbottom mcccurved_guide_29_0_mbottom
#define nhslit mcccurved_guide_29_0_nhslit
#define G mcccurved_guide_29_0_G
#define aleft mcccurved_guide_29_0_aleft
#define aright mcccurved_guide_29_0_aright
#define atop mcccurved_guide_29_0_atop
#define abottom mcccurved_guide_29_0_abottom
#define wavy mcccurved_guide_29_0_wavy
#define wavy_z mcccurved_guide_29_0_wavy_z
#define wavy_tb mcccurved_guide_29_0_wavy_tb
#define wavy_lr mcccurved_guide_29_0_wavy_lr
#define chamfers mcccurved_guide_29_0_chamfers
#define chamfers_z mcccurved_guide_29_0_chamfers_z
#define chamfers_lr mcccurved_guide_29_0_chamfers_lr
#define chamfers_tb mcccurved_guide_29_0_chamfers_tb
#define nelements mcccurved_guide_29_0_nelements
#define nu mcccurved_guide_29_0_nu
#define phase mcccurved_guide_29_0_phase
#define reflect mcccurved_guide_29_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16654 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_30_0' [38]. */
#define mccompcurname  curved_guide_30_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 38
#define GVars mcccurved_guide_30_0_GVars
#define pTable mcccurved_guide_30_0_pTable
#define w1 mcccurved_guide_30_0_w1
#define h1 mcccurved_guide_30_0_h1
#define w2 mcccurved_guide_30_0_w2
#define h2 mcccurved_guide_30_0_h2
#define l mcccurved_guide_30_0_l
#define R0 mcccurved_guide_30_0_R0
#define Qc mcccurved_guide_30_0_Qc
#define alpha mcccurved_guide_30_0_alpha
#define m mcccurved_guide_30_0_m
#define W mcccurved_guide_30_0_W
#define nslit mcccurved_guide_30_0_nslit
#define d mcccurved_guide_30_0_d
#define mleft mcccurved_guide_30_0_mleft
#define mright mcccurved_guide_30_0_mright
#define mtop mcccurved_guide_30_0_mtop
#define mbottom mcccurved_guide_30_0_mbottom
#define nhslit mcccurved_guide_30_0_nhslit
#define G mcccurved_guide_30_0_G
#define aleft mcccurved_guide_30_0_aleft
#define aright mcccurved_guide_30_0_aright
#define atop mcccurved_guide_30_0_atop
#define abottom mcccurved_guide_30_0_abottom
#define wavy mcccurved_guide_30_0_wavy
#define wavy_z mcccurved_guide_30_0_wavy_z
#define wavy_tb mcccurved_guide_30_0_wavy_tb
#define wavy_lr mcccurved_guide_30_0_wavy_lr
#define chamfers mcccurved_guide_30_0_chamfers
#define chamfers_z mcccurved_guide_30_0_chamfers_z
#define chamfers_lr mcccurved_guide_30_0_chamfers_lr
#define chamfers_tb mcccurved_guide_30_0_chamfers_tb
#define nelements mcccurved_guide_30_0_nelements
#define nu mcccurved_guide_30_0_nu
#define phase mcccurved_guide_30_0_phase
#define reflect mcccurved_guide_30_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16738 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_31_0' [39]. */
#define mccompcurname  curved_guide_31_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 39
#define GVars mcccurved_guide_31_0_GVars
#define pTable mcccurved_guide_31_0_pTable
#define w1 mcccurved_guide_31_0_w1
#define h1 mcccurved_guide_31_0_h1
#define w2 mcccurved_guide_31_0_w2
#define h2 mcccurved_guide_31_0_h2
#define l mcccurved_guide_31_0_l
#define R0 mcccurved_guide_31_0_R0
#define Qc mcccurved_guide_31_0_Qc
#define alpha mcccurved_guide_31_0_alpha
#define m mcccurved_guide_31_0_m
#define W mcccurved_guide_31_0_W
#define nslit mcccurved_guide_31_0_nslit
#define d mcccurved_guide_31_0_d
#define mleft mcccurved_guide_31_0_mleft
#define mright mcccurved_guide_31_0_mright
#define mtop mcccurved_guide_31_0_mtop
#define mbottom mcccurved_guide_31_0_mbottom
#define nhslit mcccurved_guide_31_0_nhslit
#define G mcccurved_guide_31_0_G
#define aleft mcccurved_guide_31_0_aleft
#define aright mcccurved_guide_31_0_aright
#define atop mcccurved_guide_31_0_atop
#define abottom mcccurved_guide_31_0_abottom
#define wavy mcccurved_guide_31_0_wavy
#define wavy_z mcccurved_guide_31_0_wavy_z
#define wavy_tb mcccurved_guide_31_0_wavy_tb
#define wavy_lr mcccurved_guide_31_0_wavy_lr
#define chamfers mcccurved_guide_31_0_chamfers
#define chamfers_z mcccurved_guide_31_0_chamfers_z
#define chamfers_lr mcccurved_guide_31_0_chamfers_lr
#define chamfers_tb mcccurved_guide_31_0_chamfers_tb
#define nelements mcccurved_guide_31_0_nelements
#define nu mcccurved_guide_31_0_nu
#define phase mcccurved_guide_31_0_phase
#define reflect mcccurved_guide_31_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16822 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_32_0' [40]. */
#define mccompcurname  curved_guide_32_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 40
#define GVars mcccurved_guide_32_0_GVars
#define pTable mcccurved_guide_32_0_pTable
#define w1 mcccurved_guide_32_0_w1
#define h1 mcccurved_guide_32_0_h1
#define w2 mcccurved_guide_32_0_w2
#define h2 mcccurved_guide_32_0_h2
#define l mcccurved_guide_32_0_l
#define R0 mcccurved_guide_32_0_R0
#define Qc mcccurved_guide_32_0_Qc
#define alpha mcccurved_guide_32_0_alpha
#define m mcccurved_guide_32_0_m
#define W mcccurved_guide_32_0_W
#define nslit mcccurved_guide_32_0_nslit
#define d mcccurved_guide_32_0_d
#define mleft mcccurved_guide_32_0_mleft
#define mright mcccurved_guide_32_0_mright
#define mtop mcccurved_guide_32_0_mtop
#define mbottom mcccurved_guide_32_0_mbottom
#define nhslit mcccurved_guide_32_0_nhslit
#define G mcccurved_guide_32_0_G
#define aleft mcccurved_guide_32_0_aleft
#define aright mcccurved_guide_32_0_aright
#define atop mcccurved_guide_32_0_atop
#define abottom mcccurved_guide_32_0_abottom
#define wavy mcccurved_guide_32_0_wavy
#define wavy_z mcccurved_guide_32_0_wavy_z
#define wavy_tb mcccurved_guide_32_0_wavy_tb
#define wavy_lr mcccurved_guide_32_0_wavy_lr
#define chamfers mcccurved_guide_32_0_chamfers
#define chamfers_z mcccurved_guide_32_0_chamfers_z
#define chamfers_lr mcccurved_guide_32_0_chamfers_lr
#define chamfers_tb mcccurved_guide_32_0_chamfers_tb
#define nelements mcccurved_guide_32_0_nelements
#define nu mcccurved_guide_32_0_nu
#define phase mcccurved_guide_32_0_phase
#define reflect mcccurved_guide_32_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16906 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_33_0' [41]. */
#define mccompcurname  curved_guide_33_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 41
#define GVars mcccurved_guide_33_0_GVars
#define pTable mcccurved_guide_33_0_pTable
#define w1 mcccurved_guide_33_0_w1
#define h1 mcccurved_guide_33_0_h1
#define w2 mcccurved_guide_33_0_w2
#define h2 mcccurved_guide_33_0_h2
#define l mcccurved_guide_33_0_l
#define R0 mcccurved_guide_33_0_R0
#define Qc mcccurved_guide_33_0_Qc
#define alpha mcccurved_guide_33_0_alpha
#define m mcccurved_guide_33_0_m
#define W mcccurved_guide_33_0_W
#define nslit mcccurved_guide_33_0_nslit
#define d mcccurved_guide_33_0_d
#define mleft mcccurved_guide_33_0_mleft
#define mright mcccurved_guide_33_0_mright
#define mtop mcccurved_guide_33_0_mtop
#define mbottom mcccurved_guide_33_0_mbottom
#define nhslit mcccurved_guide_33_0_nhslit
#define G mcccurved_guide_33_0_G
#define aleft mcccurved_guide_33_0_aleft
#define aright mcccurved_guide_33_0_aright
#define atop mcccurved_guide_33_0_atop
#define abottom mcccurved_guide_33_0_abottom
#define wavy mcccurved_guide_33_0_wavy
#define wavy_z mcccurved_guide_33_0_wavy_z
#define wavy_tb mcccurved_guide_33_0_wavy_tb
#define wavy_lr mcccurved_guide_33_0_wavy_lr
#define chamfers mcccurved_guide_33_0_chamfers
#define chamfers_z mcccurved_guide_33_0_chamfers_z
#define chamfers_lr mcccurved_guide_33_0_chamfers_lr
#define chamfers_tb mcccurved_guide_33_0_chamfers_tb
#define nelements mcccurved_guide_33_0_nelements
#define nu mcccurved_guide_33_0_nu
#define phase mcccurved_guide_33_0_phase
#define reflect mcccurved_guide_33_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16990 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_34_0' [42]. */
#define mccompcurname  curved_guide_34_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 42
#define GVars mcccurved_guide_34_0_GVars
#define pTable mcccurved_guide_34_0_pTable
#define w1 mcccurved_guide_34_0_w1
#define h1 mcccurved_guide_34_0_h1
#define w2 mcccurved_guide_34_0_w2
#define h2 mcccurved_guide_34_0_h2
#define l mcccurved_guide_34_0_l
#define R0 mcccurved_guide_34_0_R0
#define Qc mcccurved_guide_34_0_Qc
#define alpha mcccurved_guide_34_0_alpha
#define m mcccurved_guide_34_0_m
#define W mcccurved_guide_34_0_W
#define nslit mcccurved_guide_34_0_nslit
#define d mcccurved_guide_34_0_d
#define mleft mcccurved_guide_34_0_mleft
#define mright mcccurved_guide_34_0_mright
#define mtop mcccurved_guide_34_0_mtop
#define mbottom mcccurved_guide_34_0_mbottom
#define nhslit mcccurved_guide_34_0_nhslit
#define G mcccurved_guide_34_0_G
#define aleft mcccurved_guide_34_0_aleft
#define aright mcccurved_guide_34_0_aright
#define atop mcccurved_guide_34_0_atop
#define abottom mcccurved_guide_34_0_abottom
#define wavy mcccurved_guide_34_0_wavy
#define wavy_z mcccurved_guide_34_0_wavy_z
#define wavy_tb mcccurved_guide_34_0_wavy_tb
#define wavy_lr mcccurved_guide_34_0_wavy_lr
#define chamfers mcccurved_guide_34_0_chamfers
#define chamfers_z mcccurved_guide_34_0_chamfers_z
#define chamfers_lr mcccurved_guide_34_0_chamfers_lr
#define chamfers_tb mcccurved_guide_34_0_chamfers_tb
#define nelements mcccurved_guide_34_0_nelements
#define nu mcccurved_guide_34_0_nu
#define phase mcccurved_guide_34_0_phase
#define reflect mcccurved_guide_34_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17074 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_35_0' [43]. */
#define mccompcurname  curved_guide_35_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 43
#define GVars mcccurved_guide_35_0_GVars
#define pTable mcccurved_guide_35_0_pTable
#define w1 mcccurved_guide_35_0_w1
#define h1 mcccurved_guide_35_0_h1
#define w2 mcccurved_guide_35_0_w2
#define h2 mcccurved_guide_35_0_h2
#define l mcccurved_guide_35_0_l
#define R0 mcccurved_guide_35_0_R0
#define Qc mcccurved_guide_35_0_Qc
#define alpha mcccurved_guide_35_0_alpha
#define m mcccurved_guide_35_0_m
#define W mcccurved_guide_35_0_W
#define nslit mcccurved_guide_35_0_nslit
#define d mcccurved_guide_35_0_d
#define mleft mcccurved_guide_35_0_mleft
#define mright mcccurved_guide_35_0_mright
#define mtop mcccurved_guide_35_0_mtop
#define mbottom mcccurved_guide_35_0_mbottom
#define nhslit mcccurved_guide_35_0_nhslit
#define G mcccurved_guide_35_0_G
#define aleft mcccurved_guide_35_0_aleft
#define aright mcccurved_guide_35_0_aright
#define atop mcccurved_guide_35_0_atop
#define abottom mcccurved_guide_35_0_abottom
#define wavy mcccurved_guide_35_0_wavy
#define wavy_z mcccurved_guide_35_0_wavy_z
#define wavy_tb mcccurved_guide_35_0_wavy_tb
#define wavy_lr mcccurved_guide_35_0_wavy_lr
#define chamfers mcccurved_guide_35_0_chamfers
#define chamfers_z mcccurved_guide_35_0_chamfers_z
#define chamfers_lr mcccurved_guide_35_0_chamfers_lr
#define chamfers_tb mcccurved_guide_35_0_chamfers_tb
#define nelements mcccurved_guide_35_0_nelements
#define nu mcccurved_guide_35_0_nu
#define phase mcccurved_guide_35_0_phase
#define reflect mcccurved_guide_35_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17158 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'curved_guide_36_0' [44]. */
#define mccompcurname  curved_guide_36_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 44
#define GVars mcccurved_guide_36_0_GVars
#define pTable mcccurved_guide_36_0_pTable
#define w1 mcccurved_guide_36_0_w1
#define h1 mcccurved_guide_36_0_h1
#define w2 mcccurved_guide_36_0_w2
#define h2 mcccurved_guide_36_0_h2
#define l mcccurved_guide_36_0_l
#define R0 mcccurved_guide_36_0_R0
#define Qc mcccurved_guide_36_0_Qc
#define alpha mcccurved_guide_36_0_alpha
#define m mcccurved_guide_36_0_m
#define W mcccurved_guide_36_0_W
#define nslit mcccurved_guide_36_0_nslit
#define d mcccurved_guide_36_0_d
#define mleft mcccurved_guide_36_0_mleft
#define mright mcccurved_guide_36_0_mright
#define mtop mcccurved_guide_36_0_mtop
#define mbottom mcccurved_guide_36_0_mbottom
#define nhslit mcccurved_guide_36_0_nhslit
#define G mcccurved_guide_36_0_G
#define aleft mcccurved_guide_36_0_aleft
#define aright mcccurved_guide_36_0_aright
#define atop mcccurved_guide_36_0_atop
#define abottom mcccurved_guide_36_0_abottom
#define wavy mcccurved_guide_36_0_wavy
#define wavy_z mcccurved_guide_36_0_wavy_z
#define wavy_tb mcccurved_guide_36_0_wavy_tb
#define wavy_lr mcccurved_guide_36_0_wavy_lr
#define chamfers mcccurved_guide_36_0_chamfers
#define chamfers_z mcccurved_guide_36_0_chamfers_z
#define chamfers_lr mcccurved_guide_36_0_chamfers_lr
#define chamfers_tb mcccurved_guide_36_0_chamfers_tb
#define nelements mcccurved_guide_36_0_nelements
#define nu mcccurved_guide_36_0_nu
#define phase mcccurved_guide_36_0_phase
#define reflect mcccurved_guide_36_0_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17242 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'EndOfelement_4' [45]. */
#define mccompcurname  EndOfelement_4
#define mccompcurtype  Arm
#define mccompcurindex 45
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'log_P_start' [46]. */
#define mccompcurname  log_P_start
#define mccompcurtype  Shielding_logger
#define mccompcurindex 46
#line 148 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_logger.comp"
  int bounce_store_index;
  int bounce_store_overrun;
  int absorbed_in_optics;
#line 17299 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'elliptical_guide_gravity3' [47]. */
#define mccompcurname  elliptical_guide_gravity3
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 47
#define mvaluesright mccelliptical_guide_gravity3_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity3_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity3_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity3_mvaluesbottom
#define seglength mccelliptical_guide_gravity3_seglength
#define guideInfo mccelliptical_guide_gravity3_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity3_latestParticleCollision
#define Gx mccelliptical_guide_gravity3_Gx
#define Gy mccelliptical_guide_gravity3_Gy
#define Gz mccelliptical_guide_gravity3_Gz
#define Gx0 mccelliptical_guide_gravity3_Gx0
#define Gy0 mccelliptical_guide_gravity3_Gy0
#define Gz0 mccelliptical_guide_gravity3_Gz0
#define Circ mccelliptical_guide_gravity3_Circ
#define dynamicalSegLength mccelliptical_guide_gravity3_dynamicalSegLength
#define l mccelliptical_guide_gravity3_l
#define xwidth mccelliptical_guide_gravity3_xwidth
#define yheight mccelliptical_guide_gravity3_yheight
#define linxw mccelliptical_guide_gravity3_linxw
#define loutxw mccelliptical_guide_gravity3_loutxw
#define linyh mccelliptical_guide_gravity3_linyh
#define loutyh mccelliptical_guide_gravity3_loutyh
#define majorAxisxw mccelliptical_guide_gravity3_majorAxisxw
#define minorAxisxw mccelliptical_guide_gravity3_minorAxisxw
#define majorAxisyh mccelliptical_guide_gravity3_majorAxisyh
#define minorAxisyh mccelliptical_guide_gravity3_minorAxisyh
#define majorAxisoffsetxw mccelliptical_guide_gravity3_majorAxisoffsetxw
#define majorAxisoffsetyh mccelliptical_guide_gravity3_majorAxisoffsetyh
#define dimensionsAt mccelliptical_guide_gravity3_dimensionsAt
#define option mccelliptical_guide_gravity3_option
#define R0 mccelliptical_guide_gravity3_R0
#define Qc mccelliptical_guide_gravity3_Qc
#define alpha mccelliptical_guide_gravity3_alpha
#define m mccelliptical_guide_gravity3_m
#define W mccelliptical_guide_gravity3_W
#define alpharight mccelliptical_guide_gravity3_alpharight
#define mright mccelliptical_guide_gravity3_mright
#define alphaleft mccelliptical_guide_gravity3_alphaleft
#define mleft mccelliptical_guide_gravity3_mleft
#define alphatop mccelliptical_guide_gravity3_alphatop
#define mtop mccelliptical_guide_gravity3_mtop
#define alphabottom mccelliptical_guide_gravity3_alphabottom
#define mbottom mccelliptical_guide_gravity3_mbottom
#define verbose mccelliptical_guide_gravity3_verbose
#define enableGravity mccelliptical_guide_gravity3_enableGravity
#define curvature mccelliptical_guide_gravity3_curvature
#line 815 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
	/** 
		All variables below is locally declared 
		and hence accessible through OUTPUT PARAMETERS.
	*/ 
	struct SGI guideInfo; // Static Guide information, is set in INITIALIZE
	struct Intersection latestParticleCollision; // Is changed duing trace
	double Gx,Gy,Gz;  // Local gravity vector, is set once in INITIALIZE
	double Gx0, Gy0, Gz0;
	double Circ;
	double *dynamicalSegLength;

#line 17366 "./ESS_BIFROST_shielding.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'EndOfelement_3' [48]. */
#define mccompcurname  EndOfelement_3
#define mccompcurtype  Arm
#define mccompcurindex 48
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'straight_guide_2_1' [49]. */
#define mccompcurname  straight_guide_2_1
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 49
#define GVars mccstraight_guide_2_1_GVars
#define pTable mccstraight_guide_2_1_pTable
#define w1 mccstraight_guide_2_1_w1
#define h1 mccstraight_guide_2_1_h1
#define w2 mccstraight_guide_2_1_w2
#define h2 mccstraight_guide_2_1_h2
#define l mccstraight_guide_2_1_l
#define R0 mccstraight_guide_2_1_R0
#define Qc mccstraight_guide_2_1_Qc
#define alpha mccstraight_guide_2_1_alpha
#define m mccstraight_guide_2_1_m
#define W mccstraight_guide_2_1_W
#define nslit mccstraight_guide_2_1_nslit
#define d mccstraight_guide_2_1_d
#define mleft mccstraight_guide_2_1_mleft
#define mright mccstraight_guide_2_1_mright
#define mtop mccstraight_guide_2_1_mtop
#define mbottom mccstraight_guide_2_1_mbottom
#define nhslit mccstraight_guide_2_1_nhslit
#define G mccstraight_guide_2_1_G
#define aleft mccstraight_guide_2_1_aleft
#define aright mccstraight_guide_2_1_aright
#define atop mccstraight_guide_2_1_atop
#define abottom mccstraight_guide_2_1_abottom
#define wavy mccstraight_guide_2_1_wavy
#define wavy_z mccstraight_guide_2_1_wavy_z
#define wavy_tb mccstraight_guide_2_1_wavy_tb
#define wavy_lr mccstraight_guide_2_1_wavy_lr
#define chamfers mccstraight_guide_2_1_chamfers
#define chamfers_z mccstraight_guide_2_1_chamfers_z
#define chamfers_lr mccstraight_guide_2_1_chamfers_lr
#define chamfers_tb mccstraight_guide_2_1_chamfers_tb
#define nelements mccstraight_guide_2_1_nelements
#define nu mccstraight_guide_2_1_nu
#define phase mccstraight_guide_2_1_phase
#define reflect mccstraight_guide_2_1_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17468 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'straight_guide_2_2' [50]. */
#define mccompcurname  straight_guide_2_2
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 50
#define GVars mccstraight_guide_2_2_GVars
#define pTable mccstraight_guide_2_2_pTable
#define w1 mccstraight_guide_2_2_w1
#define h1 mccstraight_guide_2_2_h1
#define w2 mccstraight_guide_2_2_w2
#define h2 mccstraight_guide_2_2_h2
#define l mccstraight_guide_2_2_l
#define R0 mccstraight_guide_2_2_R0
#define Qc mccstraight_guide_2_2_Qc
#define alpha mccstraight_guide_2_2_alpha
#define m mccstraight_guide_2_2_m
#define W mccstraight_guide_2_2_W
#define nslit mccstraight_guide_2_2_nslit
#define d mccstraight_guide_2_2_d
#define mleft mccstraight_guide_2_2_mleft
#define mright mccstraight_guide_2_2_mright
#define mtop mccstraight_guide_2_2_mtop
#define mbottom mccstraight_guide_2_2_mbottom
#define nhslit mccstraight_guide_2_2_nhslit
#define G mccstraight_guide_2_2_G
#define aleft mccstraight_guide_2_2_aleft
#define aright mccstraight_guide_2_2_aright
#define atop mccstraight_guide_2_2_atop
#define abottom mccstraight_guide_2_2_abottom
#define wavy mccstraight_guide_2_2_wavy
#define wavy_z mccstraight_guide_2_2_wavy_z
#define wavy_tb mccstraight_guide_2_2_wavy_tb
#define wavy_lr mccstraight_guide_2_2_wavy_lr
#define chamfers mccstraight_guide_2_2_chamfers
#define chamfers_z mccstraight_guide_2_2_chamfers_z
#define chamfers_lr mccstraight_guide_2_2_chamfers_lr
#define chamfers_tb mccstraight_guide_2_2_chamfers_tb
#define nelements mccstraight_guide_2_2_nelements
#define nu mccstraight_guide_2_2_nu
#define phase mccstraight_guide_2_2_phase
#define reflect mccstraight_guide_2_2_reflect
#line 354 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17552 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'EndOfelement_2' [51]. */
#define mccompcurname  EndOfelement_2
#define mccompcurtype  Arm
#define mccompcurindex 51
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'elliptical_guide_gravity1_1' [52]. */
#define mccompcurname  elliptical_guide_gravity1_1
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 52
#define mvaluesright mccelliptical_guide_gravity1_1_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_1_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_1_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_1_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_1_seglength
#define guideInfo mccelliptical_guide_gravity1_1_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_1_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_1_Gx
#define Gy mccelliptical_guide_gravity1_1_Gy
#define Gz mccelliptical_guide_gravity1_1_Gz
#define Gx0 mccelliptical_guide_gravity1_1_Gx0
#define Gy0 mccelliptical_guide_gravity1_1_Gy0
#define Gz0 mccelliptical_guide_gravity1_1_Gz0
#define Circ mccelliptical_guide_gravity1_1_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_1_dynamicalSegLength
#define l mccelliptical_guide_gravity1_1_l
#define xwidth mccelliptical_guide_gravity1_1_xwidth
#define yheight mccelliptical_guide_gravity1_1_yheight
#define linxw mccelliptical_guide_gravity1_1_linxw
#define loutxw mccelliptical_guide_gravity1_1_loutxw
#define linyh mccelliptical_guide_gravity1_1_linyh
#define loutyh mccelliptical_guide_gravity1_1_loutyh
#define majorAxisxw mccelliptical_guide_gravity1_1_majorAxisxw
#define minorAxisxw mccelliptical_guide_gravity1_1_minorAxisxw
#define majorAxisyh mccelliptical_guide_gravity1_1_majorAxisyh
#define minorAxisyh mccelliptical_guide_gravity1_1_minorAxisyh
#define majorAxisoffsetxw mccelliptical_guide_gravity1_1_majorAxisoffsetxw
#define majorAxisoffsetyh mccelliptical_guide_gravity1_1_majorAxisoffsetyh
#define dimensionsAt mccelliptical_guide_gravity1_1_dimensionsAt
#define option mccelliptical_guide_gravity1_1_option
#define R0 mccelliptical_guide_gravity1_1_R0
#define Qc mccelliptical_guide_gravity1_1_Qc
#define alpha mccelliptical_guide_gravity1_1_alpha
#define m mccelliptical_guide_gravity1_1_m
#define W mccelliptical_guide_gravity1_1_W
#define alpharight mccelliptical_guide_gravity1_1_alpharight
#define mright mccelliptical_guide_gravity1_1_mright
#define alphaleft mccelliptical_guide_gravity1_1_alphaleft
#define mleft mccelliptical_guide_gravity1_1_mleft
#define alphatop mccelliptical_guide_gravity1_1_alphatop
#define mtop mccelliptical_guide_gravity1_1_mtop
#define alphabottom mccelliptical_guide_gravity1_1_alphabottom
#define mbottom mccelliptical_guide_gravity1_1_mbottom
#define verbose mccelliptical_guide_gravity1_1_verbose
#define enableGravity mccelliptical_guide_gravity1_1_enableGravity
#define curvature mccelliptical_guide_gravity1_1_curvature
#line 815 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
	/** 
		All variables below is locally declared 
		and hence accessible through OUTPUT PARAMETERS.
	*/ 
	struct SGI guideInfo; // Static Guide information, is set in INITIALIZE
	struct Intersection latestParticleCollision; // Is changed duing trace
	double Gx,Gy,Gz;  // Local gravity vector, is set once in INITIALIZE
	double Gx0, Gy0, Gz0;
	double Circ;
	double *dynamicalSegLength;

#line 17663 "./ESS_BIFROST_shielding.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'DiwJaw3' [53]. */
#define mccompcurname  DiwJaw3
#define mccompcurtype  Slit
#define mccompcurindex 53
#define xmin mccDiwJaw3_xmin
#define xmax mccDiwJaw3_xmax
#define ymin mccDiwJaw3_ymin
#define ymax mccDiwJaw3_ymax
#define radius mccDiwJaw3_radius
#define xwidth mccDiwJaw3_xwidth
#define yheight mccDiwJaw3_yheight
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'elliptical_guide_gravity1_2' [54]. */
#define mccompcurname  elliptical_guide_gravity1_2
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 54
#define mvaluesright mccelliptical_guide_gravity1_2_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_2_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_2_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_2_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_2_seglength
#define guideInfo mccelliptical_guide_gravity1_2_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_2_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_2_Gx
#define Gy mccelliptical_guide_gravity1_2_Gy
#define Gz mccelliptical_guide_gravity1_2_Gz
#define Gx0 mccelliptical_guide_gravity1_2_Gx0
#define Gy0 mccelliptical_guide_gravity1_2_Gy0
#define Gz0 mccelliptical_guide_gravity1_2_Gz0
#define Circ mccelliptical_guide_gravity1_2_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_2_dynamicalSegLength
#define l mccelliptical_guide_gravity1_2_l
#define xwidth mccelliptical_guide_gravity1_2_xwidth
#define yheight mccelliptical_guide_gravity1_2_yheight
#define linxw mccelliptical_guide_gravity1_2_linxw
#define loutxw mccelliptical_guide_gravity1_2_loutxw
#define linyh mccelliptical_guide_gravity1_2_linyh
#define loutyh mccelliptical_guide_gravity1_2_loutyh
#define majorAxisxw mccelliptical_guide_gravity1_2_majorAxisxw
#define minorAxisxw mccelliptical_guide_gravity1_2_minorAxisxw
#define majorAxisyh mccelliptical_guide_gravity1_2_majorAxisyh
#define minorAxisyh mccelliptical_guide_gravity1_2_minorAxisyh
#define majorAxisoffsetxw mccelliptical_guide_gravity1_2_majorAxisoffsetxw
#define majorAxisoffsetyh mccelliptical_guide_gravity1_2_majorAxisoffsetyh
#define dimensionsAt mccelliptical_guide_gravity1_2_dimensionsAt
#define option mccelliptical_guide_gravity1_2_option
#define R0 mccelliptical_guide_gravity1_2_R0
#define Qc mccelliptical_guide_gravity1_2_Qc
#define alpha mccelliptical_guide_gravity1_2_alpha
#define m mccelliptical_guide_gravity1_2_m
#define W mccelliptical_guide_gravity1_2_W
#define alpharight mccelliptical_guide_gravity1_2_alpharight
#define mright mccelliptical_guide_gravity1_2_mright
#define alphaleft mccelliptical_guide_gravity1_2_alphaleft
#define mleft mccelliptical_guide_gravity1_2_mleft
#define alphatop mccelliptical_guide_gravity1_2_alphatop
#define mtop mccelliptical_guide_gravity1_2_mtop
#define alphabottom mccelliptical_guide_gravity1_2_alphabottom
#define mbottom mccelliptical_guide_gravity1_2_mbottom
#define verbose mccelliptical_guide_gravity1_2_verbose
#define enableGravity mccelliptical_guide_gravity1_2_enableGravity
#define curvature mccelliptical_guide_gravity1_2_curvature
#line 815 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
	/** 
		All variables below is locally declared 
		and hence accessible through OUTPUT PARAMETERS.
	*/ 
	struct SGI guideInfo; // Static Guide information, is set in INITIALIZE
	struct Intersection latestParticleCollision; // Is changed duing trace
	double Gx,Gy,Gz;  // Local gravity vector, is set once in INITIALIZE
	double Gx0, Gy0, Gz0;
	double Circ;
	double *dynamicalSegLength;

#line 17798 "./ESS_BIFROST_shielding.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'DiwJaw2' [55]. */
#define mccompcurname  DiwJaw2
#define mccompcurtype  Slit
#define mccompcurindex 55
#define xmin mccDiwJaw2_xmin
#define xmax mccDiwJaw2_xmax
#define ymin mccDiwJaw2_ymin
#define ymax mccDiwJaw2_ymax
#define radius mccDiwJaw2_radius
#define xwidth mccDiwJaw2_xwidth
#define yheight mccDiwJaw2_yheight
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'elliptical_guide_gravity1_3' [56]. */
#define mccompcurname  elliptical_guide_gravity1_3
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 56
#define mvaluesright mccelliptical_guide_gravity1_3_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_3_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_3_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_3_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_3_seglength
#define guideInfo mccelliptical_guide_gravity1_3_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_3_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_3_Gx
#define Gy mccelliptical_guide_gravity1_3_Gy
#define Gz mccelliptical_guide_gravity1_3_Gz
#define Gx0 mccelliptical_guide_gravity1_3_Gx0
#define Gy0 mccelliptical_guide_gravity1_3_Gy0
#define Gz0 mccelliptical_guide_gravity1_3_Gz0
#define Circ mccelliptical_guide_gravity1_3_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_3_dynamicalSegLength
#define l mccelliptical_guide_gravity1_3_l
#define xwidth mccelliptical_guide_gravity1_3_xwidth
#define yheight mccelliptical_guide_gravity1_3_yheight
#define linxw mccelliptical_guide_gravity1_3_linxw
#define loutxw mccelliptical_guide_gravity1_3_loutxw
#define linyh mccelliptical_guide_gravity1_3_linyh
#define loutyh mccelliptical_guide_gravity1_3_loutyh
#define majorAxisxw mccelliptical_guide_gravity1_3_majorAxisxw
#define minorAxisxw mccelliptical_guide_gravity1_3_minorAxisxw
#define majorAxisyh mccelliptical_guide_gravity1_3_majorAxisyh
#define minorAxisyh mccelliptical_guide_gravity1_3_minorAxisyh
#define majorAxisoffsetxw mccelliptical_guide_gravity1_3_majorAxisoffsetxw
#define majorAxisoffsetyh mccelliptical_guide_gravity1_3_majorAxisoffsetyh
#define dimensionsAt mccelliptical_guide_gravity1_3_dimensionsAt
#define option mccelliptical_guide_gravity1_3_option
#define R0 mccelliptical_guide_gravity1_3_R0
#define Qc mccelliptical_guide_gravity1_3_Qc
#define alpha mccelliptical_guide_gravity1_3_alpha
#define m mccelliptical_guide_gravity1_3_m
#define W mccelliptical_guide_gravity1_3_W
#define alpharight mccelliptical_guide_gravity1_3_alpharight
#define mright mccelliptical_guide_gravity1_3_mright
#define alphaleft mccelliptical_guide_gravity1_3_alphaleft
#define mleft mccelliptical_guide_gravity1_3_mleft
#define alphatop mccelliptical_guide_gravity1_3_alphatop
#define mtop mccelliptical_guide_gravity1_3_mtop
#define alphabottom mccelliptical_guide_gravity1_3_alphabottom
#define mbottom mccelliptical_guide_gravity1_3_mbottom
#define verbose mccelliptical_guide_gravity1_3_verbose
#define enableGravity mccelliptical_guide_gravity1_3_enableGravity
#define curvature mccelliptical_guide_gravity1_3_curvature
#line 815 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
	/** 
		All variables below is locally declared 
		and hence accessible through OUTPUT PARAMETERS.
	*/ 
	struct SGI guideInfo; // Static Guide information, is set in INITIALIZE
	struct Intersection latestParticleCollision; // Is changed duing trace
	double Gx,Gy,Gz;  // Local gravity vector, is set once in INITIALIZE
	double Gx0, Gy0, Gz0;
	double Circ;
	double *dynamicalSegLength;

#line 17933 "./ESS_BIFROST_shielding.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'DiwJaw1' [57]. */
#define mccompcurname  DiwJaw1
#define mccompcurtype  Slit
#define mccompcurindex 57
#define xmin mccDiwJaw1_xmin
#define xmax mccDiwJaw1_xmax
#define ymin mccDiwJaw1_ymin
#define ymax mccDiwJaw1_ymax
#define radius mccDiwJaw1_radius
#define xwidth mccDiwJaw1_xwidth
#define yheight mccDiwJaw1_yheight
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'elliptical_guide_gravity1_4' [58]. */
#define mccompcurname  elliptical_guide_gravity1_4
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 58
#define mvaluesright mccelliptical_guide_gravity1_4_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_4_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_4_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_4_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_4_seglength
#define guideInfo mccelliptical_guide_gravity1_4_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_4_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_4_Gx
#define Gy mccelliptical_guide_gravity1_4_Gy
#define Gz mccelliptical_guide_gravity1_4_Gz
#define Gx0 mccelliptical_guide_gravity1_4_Gx0
#define Gy0 mccelliptical_guide_gravity1_4_Gy0
#define Gz0 mccelliptical_guide_gravity1_4_Gz0
#define Circ mccelliptical_guide_gravity1_4_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_4_dynamicalSegLength
#define l mccelliptical_guide_gravity1_4_l
#define xwidth mccelliptical_guide_gravity1_4_xwidth
#define yheight mccelliptical_guide_gravity1_4_yheight
#define linxw mccelliptical_guide_gravity1_4_linxw
#define loutxw mccelliptical_guide_gravity1_4_loutxw
#define linyh mccelliptical_guide_gravity1_4_linyh
#define loutyh mccelliptical_guide_gravity1_4_loutyh
#define majorAxisxw mccelliptical_guide_gravity1_4_majorAxisxw
#define minorAxisxw mccelliptical_guide_gravity1_4_minorAxisxw
#define majorAxisyh mccelliptical_guide_gravity1_4_majorAxisyh
#define minorAxisyh mccelliptical_guide_gravity1_4_minorAxisyh
#define majorAxisoffsetxw mccelliptical_guide_gravity1_4_majorAxisoffsetxw
#define majorAxisoffsetyh mccelliptical_guide_gravity1_4_majorAxisoffsetyh
#define dimensionsAt mccelliptical_guide_gravity1_4_dimensionsAt
#define option mccelliptical_guide_gravity1_4_option
#define R0 mccelliptical_guide_gravity1_4_R0
#define Qc mccelliptical_guide_gravity1_4_Qc
#define alpha mccelliptical_guide_gravity1_4_alpha
#define m mccelliptical_guide_gravity1_4_m
#define W mccelliptical_guide_gravity1_4_W
#define alpharight mccelliptical_guide_gravity1_4_alpharight
#define mright mccelliptical_guide_gravity1_4_mright
#define alphaleft mccelliptical_guide_gravity1_4_alphaleft
#define mleft mccelliptical_guide_gravity1_4_mleft
#define alphatop mccelliptical_guide_gravity1_4_alphatop
#define mtop mccelliptical_guide_gravity1_4_mtop
#define alphabottom mccelliptical_guide_gravity1_4_alphabottom
#define mbottom mccelliptical_guide_gravity1_4_mbottom
#define verbose mccelliptical_guide_gravity1_4_verbose
#define enableGravity mccelliptical_guide_gravity1_4_enableGravity
#define curvature mccelliptical_guide_gravity1_4_curvature
#line 815 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
	/** 
		All variables below is locally declared 
		and hence accessible through OUTPUT PARAMETERS.
	*/ 
	struct SGI guideInfo; // Static Guide information, is set in INITIALIZE
	struct Intersection latestParticleCollision; // Is changed duing trace
	double Gx,Gy,Gz;  // Local gravity vector, is set once in INITIALIZE
	double Gx0, Gy0, Gz0;
	double Circ;
	double *dynamicalSegLength;

#line 18068 "./ESS_BIFROST_shielding.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'EndOfelement_1' [59]. */
#define mccompcurname  EndOfelement_1
#define mccompcurtype  Arm
#define mccompcurindex 59
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'VirtualOutput' [60]. */
#define mccompcurname  VirtualOutput
#define mccompcurtype  Virtual_output
#define mccompcurindex 60
#define DEFS mccVirtualOutput_DEFS
#define Vars mccVirtualOutput_Vars
#define filename mccVirtualOutput_filename
#define bufsize mccVirtualOutput_bufsize
#line 72 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../sources/Virtual_output.comp"
  MonitornD_Defines_type DEFS;
  MonitornD_Variables_type Vars;
#line 18138 "./ESS_BIFROST_shielding.c"
#undef bufsize
#undef filename
#undef Vars
#undef DEFS
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'DiwJaw0' [61]. */
#define mccompcurname  DiwJaw0
#define mccompcurtype  Slit
#define mccompcurindex 61
#define xmin mccDiwJaw0_xmin
#define xmax mccDiwJaw0_xmax
#define ymin mccDiwJaw0_ymin
#define ymax mccDiwJaw0_ymax
#define radius mccDiwJaw0_radius
#define xwidth mccDiwJaw0_xwidth
#define yheight mccDiwJaw0_yheight
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'log_P_stop' [62]. */
#define mccompcurname  log_P_stop
#define mccompcurtype  Shielding_logger_stop
#define mccompcurindex 62
#define logger mcclog_P_stop_logger
#line 48 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_logger_stop.comp"
  int bounce_store_index;
  int bounce_store_overrun;
  int logger_buffer_cleared;
#line 18178 "./ESS_BIFROST_shielding.c"
#undef logger
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'arm_iter_P1_start' [63]. */
#define mccompcurname  arm_iter_P1_start
#define mccompcurtype  Arm
#define mccompcurindex 63
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'iter_P1_start' [64]. */
#define mccompcurname  iter_P1_start
#define mccompcurtype  Shielding_log_iterator_Ni_new
#define mccompcurindex 64
#define compute_func mcciter_P1_start_compute_func
#define nstate_initial mcciter_P1_start_nstate_initial
#define s0 mcciter_P1_start_s0
#define s1 mcciter_P1_start_s1
#line 119 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_Ni_new.comp"
  int (*pseudo_neutron_state_function_Ni) (double *, struct Generalized_State_t *, struct Generalized_State_t *); 

  struct Generalized_State_t *s1,*s0;

  double *nstate_initial;
  
  int optics_not_hit;

  /*need a pointer to the structure set up by the logger*/
#line 18210 "./ESS_BIFROST_shielding.c"
#undef s1
#undef s0
#undef nstate_initial
#undef compute_func
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'arm_iter_P1_dummy' [65]. */
#define mccompcurname  arm_iter_P1_dummy
#define mccompcurtype  Arm
#define mccompcurindex 65
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'mndP01' [66]. */
#define mccompcurname  mndP01
#define mccompcurtype  Monitor_nD
#define mccompcurindex 66
#define user1 mccmndP01_user1
#define user2 mccmndP01_user2
#define user3 mccmndP01_user3
#define DEFS mccmndP01_DEFS
#define Vars mccmndP01_Vars
#define detector mccmndP01_detector
#define offdata mccmndP01_offdata
#define xwidth mccmndP01_xwidth
#define yheight mccmndP01_yheight
#define zdepth mccmndP01_zdepth
#define xmin mccmndP01_xmin
#define xmax mccmndP01_xmax
#define ymin mccmndP01_ymin
#define ymax mccmndP01_ymax
#define zmin mccmndP01_zmin
#define zmax mccmndP01_zmax
#define bins mccmndP01_bins
#define min mccmndP01_min
#define max mccmndP01_max
#define restore_neutron mccmndP01_restore_neutron
#define radius mccmndP01_radius
#define options mccmndP01_options
#define filename mccmndP01_filename
#define geometry mccmndP01_geometry
#define username1 mccmndP01_username1
#define username2 mccmndP01_username2
#define username3 mccmndP01_username3
#define nowritefile mccmndP01_nowritefile
#line 225 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
  MonitornD_Defines_type DEFS;
  MonitornD_Variables_type Vars;
  MCDETECTOR detector;
  off_struct offdata;
#line 18264 "./ESS_BIFROST_shielding.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'arm_iter_P1_stop' [67]. */
#define mccompcurname  arm_iter_P1_stop
#define mccompcurtype  Arm
#define mccompcurindex 67
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'iter_P1_stop' [68]. */
#define mccompcurname  iter_P1_stop
#define mccompcurtype  Shielding_log_iterator_stop
#define mccompcurindex 68
#define iterator mcciter_P1_stop_iterator
#define loop mcciter_P1_stop_loop
#define last mcciter_P1_stop_last
#line 50 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_stop.comp"
  int loop;
#line 18314 "./ESS_BIFROST_shielding.c"
#undef last
#undef loop
#undef iterator
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'a11i' [69]. */
#define mccompcurname  a11i
#define mccompcurtype  Arm
#define mccompcurindex 69
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'arm_iter_P2_start' [70]. */
#define mccompcurname  arm_iter_P2_start
#define mccompcurtype  Arm
#define mccompcurindex 70
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'iter_P2_start' [71]. */
#define mccompcurname  iter_P2_start
#define mccompcurtype  Shielding_log_iterator_Ti_new
#define mccompcurindex 71
#define compute_func mcciter_P2_start_compute_func
#define nstate_initial mcciter_P2_start_nstate_initial
#define s0 mcciter_P2_start_s0
#define s1 mcciter_P2_start_s1
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_Ti_new.comp"
  int (*pseudo_neutron_state_function_Ti) (double *, struct Generalized_State_t *, struct Generalized_State_t *); 

  struct Generalized_State_t *s1,*s0;

  double *nstate_initial;
  
  int optics_not_hit;

  /*need a pointer to the structure set up by the logger*/
#line 18356 "./ESS_BIFROST_shielding.c"
#undef s1
#undef s0
#undef nstate_initial
#undef compute_func
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'arm_iter_P2_dummy' [72]. */
#define mccompcurname  arm_iter_P2_dummy
#define mccompcurtype  Arm
#define mccompcurindex 72
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'mndP02' [73]. */
#define mccompcurname  mndP02
#define mccompcurtype  Monitor_nD
#define mccompcurindex 73
#define user1 mccmndP02_user1
#define user2 mccmndP02_user2
#define user3 mccmndP02_user3
#define DEFS mccmndP02_DEFS
#define Vars mccmndP02_Vars
#define detector mccmndP02_detector
#define offdata mccmndP02_offdata
#define xwidth mccmndP02_xwidth
#define yheight mccmndP02_yheight
#define zdepth mccmndP02_zdepth
#define xmin mccmndP02_xmin
#define xmax mccmndP02_xmax
#define ymin mccmndP02_ymin
#define ymax mccmndP02_ymax
#define zmin mccmndP02_zmin
#define zmax mccmndP02_zmax
#define bins mccmndP02_bins
#define min mccmndP02_min
#define max mccmndP02_max
#define restore_neutron mccmndP02_restore_neutron
#define radius mccmndP02_radius
#define options mccmndP02_options
#define filename mccmndP02_filename
#define geometry mccmndP02_geometry
#define username1 mccmndP02_username1
#define username2 mccmndP02_username2
#define username3 mccmndP02_username3
#define nowritefile mccmndP02_nowritefile
#line 225 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
  MonitornD_Defines_type DEFS;
  MonitornD_Variables_type Vars;
  MCDETECTOR detector;
  off_struct offdata;
#line 18410 "./ESS_BIFROST_shielding.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'arm_iter_P2_stop' [74]. */
#define mccompcurname  arm_iter_P2_stop
#define mccompcurtype  Arm
#define mccompcurindex 74
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'iter_P2_stop' [75]. */
#define mccompcurname  iter_P2_stop
#define mccompcurtype  Shielding_log_iterator_stop
#define mccompcurindex 75
#define iterator mcciter_P2_stop_iterator
#define loop mcciter_P2_stop_loop
#define last mcciter_P2_stop_last
#line 50 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_stop.comp"
  int loop;
#line 18460 "./ESS_BIFROST_shielding.c"
#undef last
#undef loop
#undef iterator
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'a12i' [76]. */
#define mccompcurname  a12i
#define mccompcurtype  Arm
#define mccompcurindex 76
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'arm_iter_P3_start' [77]. */
#define mccompcurname  arm_iter_P3_start
#define mccompcurtype  Arm
#define mccompcurindex 77
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'iter_P3_start' [78]. */
#define mccompcurname  iter_P3_start
#define mccompcurtype  Shielding_log_iterator_total
#define mccompcurindex 78
#define compute_func mcciter_P3_start_compute_func
#define nstate_initial mcciter_P3_start_nstate_initial
#define s0 mcciter_P3_start_s0
#define s1 mcciter_P3_start_s1
#line 75 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_total.comp"
  int (*pseudo_neutron_state_function) (double *, struct Generalized_State_t *, struct Generalized_State_t *); 

  struct Generalized_State_t *s1,*s0;

  double *nstate_initial;
  
  int optics_not_hit;

  /*need a pointer to the structure set up by the logger*/
#line 18502 "./ESS_BIFROST_shielding.c"
#undef s1
#undef s0
#undef nstate_initial
#undef compute_func
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'arm_iter_P3_dummy' [79]. */
#define mccompcurname  arm_iter_P3_dummy
#define mccompcurtype  Arm
#define mccompcurindex 79
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'mndP03' [80]. */
#define mccompcurname  mndP03
#define mccompcurtype  Monitor_nD
#define mccompcurindex 80
#define user1 mccmndP03_user1
#define user2 mccmndP03_user2
#define user3 mccmndP03_user3
#define DEFS mccmndP03_DEFS
#define Vars mccmndP03_Vars
#define detector mccmndP03_detector
#define offdata mccmndP03_offdata
#define xwidth mccmndP03_xwidth
#define yheight mccmndP03_yheight
#define zdepth mccmndP03_zdepth
#define xmin mccmndP03_xmin
#define xmax mccmndP03_xmax
#define ymin mccmndP03_ymin
#define ymax mccmndP03_ymax
#define zmin mccmndP03_zmin
#define zmax mccmndP03_zmax
#define bins mccmndP03_bins
#define min mccmndP03_min
#define max mccmndP03_max
#define restore_neutron mccmndP03_restore_neutron
#define radius mccmndP03_radius
#define options mccmndP03_options
#define filename mccmndP03_filename
#define geometry mccmndP03_geometry
#define username1 mccmndP03_username1
#define username2 mccmndP03_username2
#define username3 mccmndP03_username3
#define nowritefile mccmndP03_nowritefile
#line 225 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
  MonitornD_Defines_type DEFS;
  MonitornD_Variables_type Vars;
  MCDETECTOR detector;
  off_struct offdata;
#line 18556 "./ESS_BIFROST_shielding.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'arm_iter_P3_stop' [81]. */
#define mccompcurname  arm_iter_P3_stop
#define mccompcurtype  Arm
#define mccompcurindex 81
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'iter_P3_stop' [82]. */
#define mccompcurname  iter_P3_stop
#define mccompcurtype  Shielding_log_iterator_stop
#define mccompcurindex 82
#define iterator mcciter_P3_stop_iterator
#define loop mcciter_P3_stop_loop
#define last mcciter_P3_stop_last
#line 50 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_stop.comp"
  int loop;
#line 18606 "./ESS_BIFROST_shielding.c"
#undef last
#undef loop
#undef iterator
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'a13i' [83]. */
#define mccompcurname  a13i
#define mccompcurtype  Arm
#define mccompcurindex 83
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Beamstop' [84]. */
#define mccompcurname  Beamstop
#define mccompcurtype  Beamstop
#define mccompcurindex 84
#define xmin mccBeamstop_xmin
#define xmax mccBeamstop_xmax
#define ymin mccBeamstop_ymin
#define ymax mccBeamstop_ymax
#define xwidth mccBeamstop_xwidth
#define yheight mccBeamstop_yheight
#define radius mccBeamstop_radius
#undef radius
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Lmon_guide_end' [85]. */
#define mccompcurname  Lmon_guide_end
#define mccompcurtype  L_monitor
#define mccompcurindex 85
#define nL mccLmon_guide_end_nL
#define L_N mccLmon_guide_end_L_N
#define L_p mccLmon_guide_end_L_p
#define L_p2 mccLmon_guide_end_L_p2
#define filename mccLmon_guide_end_filename
#define xmin mccLmon_guide_end_xmin
#define xmax mccLmon_guide_end_xmax
#define ymin mccLmon_guide_end_ymin
#define ymax mccLmon_guide_end_ymax
#define xwidth mccLmon_guide_end_xwidth
#define yheight mccLmon_guide_end_yheight
#define Lmin mccLmon_guide_end_Lmin
#define Lmax mccLmon_guide_end_Lmax
#define restore_neutron mccLmon_guide_end_restore_neutron
#define nowritefile mccLmon_guide_end_nowritefile
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 18666 "./ESS_BIFROST_shielding.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'SCalc' [86]. */
#define mccompcurname  SCalc
#define mccompcurtype  Shielding_calculator
#define mccompcurindex 86
#define MaxRate mccSCalc_MaxRate
#define Innerspace mccSCalc_Innerspace
#define NiCaptureFile mccSCalc_NiCaptureFile
#define TiCaptureFile mccSCalc_TiCaptureFile
#define TotalCaptureFile mccSCalc_TotalCaptureFile
#define OutputFile mccSCalc_OutputFile
#line 93 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_calculator.comp"
#include <dirent.h>
#include <unistd.h>
/******Parameters relevant for calculations of the  shielding*******/                                                                                                      
#define stepPb 0.001 // Step for calculations  with steel shielding (2mm)
#define stepFe 0.001 // Step for calculations  with steel shielding (5mm)
#define stepbt 0.005 // Step for calculations with concrete shielding. (1cm)
#define Rtubing 0.05 //in meters. Vacuum tubing inner radius, used  for calculation of combined shielding in Febt case.                                                                                                                                 
#define TFe 0.1 // in meters. Thickness of steel vacuum tubing. (Assuming guide model as guide in evacuated steel pipe with wall thickness TFe).
#define stepcomb 0.005 // Step for calculation of combined shielding, TFe layer of steel plus concrete. (2.5 cm)

//*** NEUTRON CONVERSION DATA *****//
#ifndef NEUTRON_GAMMA_DATA
#define NEUTRON_GAMMA_DATA 1
//Photons per capture in NiTi coating
double fraction[]={0.003565789,  0.009694611, 0.028838269, 0.149117282, 0.117348519, 0.042269932, 0.386434136, 0.092896131, 0.046767054, 0.032512648,  0.043547581, 0.040537585, 0.510133557, 0.320364465};
double energy [] = {0.150,
	 0.200,
	 0.300,
	 0.400,
	 0.500,
	 0.600,
	 0.800,
	 1.,
	 1.50,
	 2.000,
	 3.0,
	 4.0,
	 5.000,
	 6.000,
	 7.0,
	 8.000,
	 9.0,
	 10.000,
	 11.000}; 
int nEgroup= 19;
//Spectrum of capture photons from Ni and Ti
//Ni gamma capture specrum
double fractionNi[]={0.003722,//150
                     0.015513,//200
                     0.048432,//300
                     0.047485,//400
                     0.198059,//500
			   0.002809,//600
			   0.003142,//800
                     0.06579,//1000
                     0.054534,//1500
                     0.028872,//2000
                     0.063882,//3000
                     0.050286,//4000
                     0.035567,//5000
                     0.080326,//6000
			   0.156571,//7000
                     0.130355,//8000
                     0.534153,//9000
			   0.000558,//10000
			   0.000260};//11000


//Ti capture gamma spectrum
double fractionTi[]={0.009326, //0.15                                                                                                                                             
                     0.0,  //0.2                                                                                                                                                  
                     0.001938,//0.3                                                                                                                                               
                     0.302632,//0.4                                                                                                                                               
                     0.000882,//0.5
			   0.000668, //0.6
			   0.000914, //0.8                                                                                                                                            
                     0.023046,//1.0                                                                                                                                               
                     0.947104,//1.5                                                                                                                                               
                     0.232257,//2.0                                                                                                                                               
                     0.086418,//3.0                                                                                                                                               
                     0.162878,//4.0                                                                                                                                               
                     0.11209,//5.0                                                                                                                                                
                     0.013419,//6.0
			   0.0875051, //7.0 
                     0.009083,//8.0
			   0.001923, //9.0                    
                     0.002189,//10.0
			   0.000332};//11.0     
//double fractionB[]={0.0,  0.0,  0.0,  0.0,  0.93, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0,0.0,0.0};
double fractionB[]={0,//0.15
0,//0.2
0,//0.3
2.32983E-06,//0.4
0.935769511,//0.5
1.94926E-06,//0.6
2.22356E-05,//0.8
3.29279E-05,//1.0
0.000248357,//1.5
0.000398671,//2.0
0.000410038,//3.0
0.001042575,//4.0
0.000961964,//5.0
8.714E-05,//6.0
0.000248803,//7.0
0.00017111,//8.0
3.9074E-05,//9.0
7.28E-07,//10.0
6.27e-6};//11.0

/*
//conversion test input
double fraction [] = {0.5,0.5};
double energy [] = {2.0,2.0};
int nEgroup= 2;
*/
//*** SHIELDING DATA TABLES ****//
 // Mashkovich set + NIST data for 15 MeV
// Linear attenuation for concrete 
double AttenuationArgsConc[]={0.15, 0.2,     0.3,    0.4, 0.5,     0.6,    0.8,    1.0,   1.25,   1.5,   2.0,   2.75,   3.0,   4.0,   5.0,   6.0,   8.0,   10.0, 15.0}; // in meV
double AttenuationDataConc[]={31.7, 28.5, 24.6, 21.9, 20.0,   18.5, 16.3,  14.6, 13.1, 11.9, 10.3, 8.74, 8.37, 7.34, 6.65, 6.19, 5.61, 5.29, 4.8208}; // in m^-1
int AttenuationSizeConc[]={18};
// Iron
double AttenuationArgsFe[]={0.15,	 0.2, 	    0.3,	    0.4, 	0.5,    	 0.6,   	 0.8,   	 1.0,  	 1.25, 	  1.5, 	  2.0,	   2.75, 	  3.0, 	  4.0, 	  5.0, 	  6.0, 	  8.0, 	  10.0, 15.0}; // in meV
double AttenuationDataFe[]={139., 	106.,	 83.3, 	71.7,	 64.6,	 59.5, 	52.0, 	46.7, 	42.2, 	38.1, 	33.3,	 29.1, 	28.4,	 26.0, 	24.8, 	24.0, 	23.4, 	23.4, 24.3}; //in m^-1
int AttenuationSizeFe[]={19};
double AttenuationArgsPb[]={0.15,	 0.2, 	    0.3,	    0.4, 	0.5,    	 0.6,   	 0.8,   	 1.0,  	 1.25, 	  1.5, 	  2.0,	   2.75, 	  3.0, 	  4.0, 	  5.0, 	  6.0, 	  8.0, 	  10.0, 15.0}; // in meV
double AttenuationDataPb[]={2180.,	 1070., 	425., 	244., 	170., 	133.,	 95.2, 	77.1, 	65.8, 	57.7, 	50.8, 	47.6, 	46.8, 	47.2, 	48.1, 	49.4,	 52.0, 	55.0,  64.2}; //in m^-1
int AttenuationSizePb[]={19};
/*
//NIST set
//Concrete
double AttenuationArgsConc[]={
0.15,
0.2,
0.3,
0.4,
0.5,
0.6,
0.8,
1.,
1.25,
1.5,
2.,
3.,
4.,
5.,
6.,
8.,
10.,
15.};

double AttenuationDataConc[]={
33.028,
29.486,
25.231,
22.5009,
20.5045,
18.9428,
16.6221,
14.9385,
13.3561,
12.1624,
10.4811,
8.5123,
7.3991,
6.6884,
6.2031,
5.5936,
5.2394,
4.8208};
int AttenuationSizeConc[]={18};




double AttenuationArgsFe[]={
0.15,
0.2,
0.3,
0.4,
0.5,
0.6,
0.8,
1.,
1.25,
1.5,
2.,
3.,
4.,
5.,
6.,
8.,
10.,
15.};

double AttenuationDataFe[]={
1.55E+02,
1.15E+02,
8.65E+01,
7.40E+01,
6.63E+01,
6.07E+01,
5.27E+01,
4.72E+01,
4.21E+01,
3.84E+01,
3.36E+01,
2.85E+01,
2.61E+01,
2.48E+01,
2.41E+01,
2.36E+01,
2.36E+01,
2.43E+01};
int AttenuationSizeFe[]={18};






double AttenuationArgsPb[]={
0.15,
0.2,
0.3,
0.4,
0.5,
0.6,
0.8,
1.,
1.25,
1.5,
2.,
3.,
4.,
5.,
6.,
8.,
10.,
15.}; // in meV
double AttenuationDataPb[]={
2.28E+03,
1.13E+03,
4.57E+02,
2.63E+02,
1.83E+02,
1.42E+02,
1.01E+02,
8.05E+01,
6.66E+01,
5.92E+01,
5.22E+01,
4.80E+01,
4.76E+01,
4.84E+01,
4.98E+01,
5.30E+01,
5.64E+01,
6.42E+01
}; //in m^-1
int AttenuationSizePb[]={18};
*/

/*
//Linear attenuation test input
double AttenuationArgs[]={0.15,  10.0}; // in meV
double AttenuationData[]={7.0, 7.0 }; // in m^-1
int AttenuationSize[]={2};
 */
 
 // Dose buildup factors  concrete
 double BuildupDataConc[]={1., 1.74, 2.26, 2.95, 3.79, 4.51, 5.57, 6.51, 3.18,
	        	      1., 2.82, 5.13, 11.2, 24.2, 42.7, 87.6, 153., 353., 
		      1., 2.52, 4.66, 10.8, 25.6, 48.2, 107., 198., 497.,
		      1., 2.27, 4.03, 8.97, 20.2, 30.4, 75.6, 131, 292, 
		      1., 1.98, 3.24, 6.42, 12.7, 20.7, 37.2, 57.1, 106, 
		      1., 1.77, 2.65, 4.61, 7.97, 11.7, 18.6, 26.0, 42.2,
		      1., 1.67, 2.38, 3.84, 6.20, 8.71, 13.1, 17.7, 27.4, 
		      1., 1.61, 2.18, 3.37, 5.23, 7.15, 10.5, 13.9, 20.9, 
		      1., 1.49, 1.93, 2.80, 4.14, 5.52, 7.86, 10.2, 15.5, 
		      1., 1.41, 1.76, 2.45, 3.51, 4.59, 6.43, 8.31, 12.2, 
		      1., 1.35, 1.64, 2.22, 3.10, 4.01, 5.57, 7.19, 10.6, 
		      1., 1.26, 1.46, 1.86, 2.50, 3.16, 4.34, 5.59, 8.27}; 
		    
  int BuildupSizeConc[] ={12, //energy 
                  9}; // mu d
  double  BuildupArgsConc[]={
                     		      0.05, 0.15, 0.3, 0.5, 1.0, 2.0, 3.0, 4.0, 6.0, 8.0, 10.0, 15.0 // energy in MeV
		      ,
				      0., 1., 2., 4., 7., 10., 15., 20., 30. //mu d 
                      };
//Dose buildup factors Fe
 double BuildupDataFe[]={
            1.,	1.5, 	2.2, 	3.1, 	4.1, 	4.6, 	5.4, 	5.9, //0.1
		1.,	2.0, 	3.1, 	5.3, 	8.9, 	14., 	22., 	31.,  //0.2
		1.,	2.1, 	3.3, 	6.0, 	12., 	23., 	49., 	84.,  //0.4
		1.,	1.98, 	3.09, 	5.98, 	11.7, 	19.2, 	35.4, 	55.6, //0.5
		1.,	1.87, 	2.89, 	5.39, 	10.2, 	16.2, 	28.3, 	42.7, //1.0
		1.,	1.76, 	2.43,	 4.13, 	7.25, 	10.9, 	17.6, 	25.1, //2.0
		1.,	1.55, 	2.15, 	3.51, 	5.85, 	8.51, 	13.5, 	19.1, //3.0 
		1.,	1.45, 	1.94, 	3.03, 	4.91, 	7.11, 	11.2, 	16.0, //4.0
		1.,	1.34, 	1.72, 	2.58, 	4.14, 	6.02, 	9.89, 	14.7, //6.0
		1.,	1.27, 	1.56,	 2.23, 	3.49, 	5.07, 	8.50, 	13.0, //8.0
		1.,	1.20, 	1.42, 	1.95, 	2.99, 	4.35, 	7.54, 	12.4, //9.0
            1.,   1.48, 	1.86, 	2.72, 	4.30 , 	6.37, 	11.4, 	19.1};//15.0
 int BuildupSizeFe[]={12, // energy
	8}; // mu d
double BuildupArgsFe[]={0.1, 0.2, 0.4, 0.5, 1.0, 2.0, 3.0, 4.0, 6.0, 8.0, 10.0, 15.0, // energy in MeV
			0., 1., 2., 4., 7., 10., 15., 20.0};


//Dose buildup factors Pb
 double BuildupDataPb[]={1., 1.01, 1.03, 1.06, 1.15, 1.16, 1.18, 1.19, 
1., 1.11, 1.17, 1.25, 1.34, 1.41, 1.5, 1.56, 
1., 1.17, 1.29, 1.46, 1.58, 1.72, 1.89, 2.02, 
1., 1.24, 1.42, 1.69, 2.00, 2.27, 2.65, 2.73, 
1., 1.37, 1.69, 2.26, 3.02, 3.74, 4.81, 5.86, 
1., 1.39, 1.76, 2.51, 3.66, 4.84, 6.87, 9.00, 
1., 1.34, 1.68, 2.43, 3.75, 5.30, 8.44, 12.3, 
1., 1.27, 1.56, 2.25, 3.61, 5.44, 9.80, 16.3, 
1., 1.21, 1.46, 2.08, 3.44, 5.55, 11.7, 23.6, 
1., 1.18, 1.40, 1.97, 3.34, 5.69, 13.8, 32.7, 
1., 1.14, 1.30, 1.74, 2.89, 5.07, 14.1, 44.6, 
1., 1.11, 1.23, 1.58, 2.52, 4.34, 12.5, 39.2};

 int BuildupSizePb[]={12, // energy
	8}; // mu d
double BuildupArgsPb[]={0.15, 0.30, 0.40, 0.5, 1.0, 2.0, 3.0, 4.0, 5.1, 6.0, 8.0, 10.0,  // energy in MeV
			0., 1., 2., 4., 7., 10., 15., 20.0};




// Flux-to-dose conversion 
/* //NRB-99?
double FtoDArgs[]= {0.15,  0.20, 0.30, 0.40, 0.50, 0.60, 0.80, 1.0, 2.0, 4.0, 6.0, 8.0, 10.0}; // in meV
double FtoDData[] = {3600*0.752E-10, 3600*1.00E-10, 3600*1.51E-10, 3600*2.00E-10, 3600*2.47E-10, 3600*2.91E-10, 3600*3.73E-10, 3600*4.48E-10, 3600*7.49E-10, 3600*12.0E-10, 3600*16.0E-10, 3600*19.9E-10, 3600*23.8E-10};  // from phot/s/m2 to mkSv/hr conversion
int nFtoDgroups= 13;
int FtoDSize[] = {13};
*/
//ESS
double FtoDArgs[]= {
0.15,
0.2,
0.3,
0.4,
0.5,
0.511,
0.6,
0.662,
0.8,
1.,
1.12,
1.33,
1.5,
2.,
3.,
4.,
5.,
6.,
6.13,
8.,
10.,
15.}; // in MeV
double FtoDData[] = {
2.69E-07,
3.60E-07,
5.44E-07,
7.20E-07,
8.89E-07,
9.07E-07,
1.05E-06,
1.14E-06,
1.34E-06,
1.62E-06,
1.76E-06,
2.01E-06,
2.20E-06,
2.69E-06,
3.51E-06,
4.21E-06,
4.82E-06,
5.40E-06,
5.47E-06,
6.70E-06,
7.92E-06,
1.09E-05
};  // from phot/s/m2 to mkSv/hr conversion
int nFtoDgroups= 22;
int FtoDSize[] = {22};



// test input flux to dose
/*
double FtoDArgs[]= {0.15, 10.0}; // in meV
double FtoDData[] = {3600*7.0E-10,3600*7.0E-10};  // from phot/s/m2 to mkSv/hr conversion
int nFtoDgroups= 2;
int FtoDSize[] = {2};
*/
#endif //end of insertion of datatables.
/*** end of insertion to DECLARE section **/
#line 19089 "./ESS_BIFROST_shielding.c"
#undef OutputFile
#undef TotalCaptureFile
#undef TiCaptureFile
#undef NiCaptureFile
#undef Innerspace
#undef MaxRate
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'DoseFe' [87]. */
#define mccompcurname  DoseFe
#define mccompcurtype  Dose_calculator
#define mccompcurindex 87
#define Material mccDoseFe_Material
#define Innerspace mccDoseFe_Innerspace
#define Thickness mccDoseFe_Thickness
#define SteelTubing mccDoseFe_SteelTubing
#define TubingThickness mccDoseFe_TubingThickness
#define NiCaptureFile mccDoseFe_NiCaptureFile
#define TiCaptureFile mccDoseFe_TiCaptureFile
#define TotalCaptureFile mccDoseFe_TotalCaptureFile
#define OutputFile mccDoseFe_OutputFile
#line 93 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Dose_calculator.comp"
#include <dirent.h>
#include <unistd.h>

//*** NEUTRON CONVERSION DATA *****//
#ifndef NEUTRON_GAMMA_DATA
#define NEUTRON_GAMMA_DATA 1
//Photons per capture in NiTi coating
double fraction[]={0.003565789,  0.009694611, 0.028838269, 0.149117282, 0.117348519, 0.042269932, 0.386434136, 0.092896131, 0.046767054, 0.032512648,  0.043547581, 0.040537585, 0.510133557, 0.320364465};
double energy [] = {0.150,
	 0.200,
	 0.300,
	 0.400,
	 0.500,
	 0.600,
	 0.800,
	 1.,
	 1.50,
	 2.000,
	 3.0,
	 4.0,
	 5.000,
	 6.000,
	 7.0,
	 8.000,
	 9.0,
	 10.000,
	 11.000}; 
int nEgroup= 19;
//Spectrum of capture photons from Ni and Ti
//Ni gamma capture specrum
double fractionNi[]={0.003722,//150
                     0.015513,//200
                     0.048432,//300
                     0.047485,//400
                     0.198059,//500
			   0.002809,//600
			   0.003142,//800
                     0.06579,//1000
                     0.054534,//1500
                     0.028872,//2000
                     0.063882,//3000
                     0.050286,//4000
                     0.035567,//5000
                     0.080326,//6000
			   0.156571,//7000
                     0.130355,//8000
                     0.534153,//9000
			   0.000558,//10000
			   0.000260};//11000


//Ti capture gamma spectrum
double fractionTi[]={0.009326, //0.15                                                                                                                                             
                     0.0,  //0.2                                                                                                                                                  
                     0.001938,//0.3                                                                                                                                               
                     0.302632,//0.4                                                                                                                                               
                     0.000882,//0.5
			   0.000668, //0.6
			   0.000914, //0.8                                                                                                                                            
                     0.023046,//1.0                                                                                                                                               
                     0.947104,//1.5                                                                                                                                               
                     0.232257,//2.0                                                                                                                                               
                     0.086418,//3.0                                                                                                                                               
                     0.162878,//4.0                                                                                                                                               
                     0.11209,//5.0                                                                                                                                                
                     0.013419,//6.0
			   0.0875051, //7.0 
                     0.009083,//8.0
			   0.001923, //9.0                    
                     0.002189,//10.0
			   0.000332};//11.0     
//double fractionB[]={0.0,  0.0,  0.0,  0.0,  0.93, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0,0.0,0.0};
double fractionB[]={0,//0.15
0,//0.2
0,//0.3
2.32983E-06,//0.4
0.935769511,//0.5
1.94926E-06,//0.6
2.22356E-05,//0.8
3.29279E-05,//1.0
0.000248357,//1.5
0.000398671,//2.0
0.000410038,//3.0
0.001042575,//4.0
0.000961964,//5.0
8.714E-05,//6.0
0.000248803,//7.0
0.00017111,//8.0
3.9074E-05,//9.0
7.28E-07,//10.0
6.27e-6};//11.0

/*
//conversion test input
double fraction [] = {0.5,0.5};
double energy [] = {2.0,2.0};
int nEgroup= 2;
*/
//*** SHIELDING DATA TABLES ****//
 // Mashkovich set + NIST data for 15 MeV
// Linear attenuation for concrete 
double AttenuationArgsConc[]={0.15, 0.2,     0.3,    0.4, 0.5,     0.6,    0.8,    1.0,   1.25,   1.5,   2.0,   2.75,   3.0,   4.0,   5.0,   6.0,   8.0,   10.0, 15.0}; // in meV
double AttenuationDataConc[]={31.7, 28.5, 24.6, 21.9, 20.0,   18.5, 16.3,  14.6, 13.1, 11.9, 10.3, 8.74, 8.37, 7.34, 6.65, 6.19, 5.61, 5.29, 4.8208}; // in m^-1
int AttenuationSizeConc[]={18};
// Iron
double AttenuationArgsFe[]={0.15,	 0.2, 	    0.3,	    0.4, 	0.5,    	 0.6,   	 0.8,   	 1.0,  	 1.25, 	  1.5, 	  2.0,	   2.75, 	  3.0, 	  4.0, 	  5.0, 	  6.0, 	  8.0, 	  10.0, 15.0}; // in meV
double AttenuationDataFe[]={139., 	106.,	 83.3, 	71.7,	 64.6,	 59.5, 	52.0, 	46.7, 	42.2, 	38.1, 	33.3,	 29.1, 	28.4,	 26.0, 	24.8, 	24.0, 	23.4, 	23.4, 24.3}; //in m^-1
int AttenuationSizeFe[]={19};
double AttenuationArgsPb[]={0.15,	 0.2, 	    0.3,	    0.4, 	0.5,    	 0.6,   	 0.8,   	 1.0,  	 1.25, 	  1.5, 	  2.0,	   2.75, 	  3.0, 	  4.0, 	  5.0, 	  6.0, 	  8.0, 	  10.0, 15.0}; // in meV
double AttenuationDataPb[]={2180.,	 1070., 	425., 	244., 	170., 	133.,	 95.2, 	77.1, 	65.8, 	57.7, 	50.8, 	47.6, 	46.8, 	47.2, 	48.1, 	49.4,	 52.0, 	55.0,  64.2}; //in m^-1
int AttenuationSizePb[]={19};
/*
//NIST set
//Concrete
double AttenuationArgsConc[]={
0.15,
0.2,
0.3,
0.4,
0.5,
0.6,
0.8,
1.,
1.25,
1.5,
2.,
3.,
4.,
5.,
6.,
8.,
10.,
15.};

double AttenuationDataConc[]={
33.028,
29.486,
25.231,
22.5009,
20.5045,
18.9428,
16.6221,
14.9385,
13.3561,
12.1624,
10.4811,
8.5123,
7.3991,
6.6884,
6.2031,
5.5936,
5.2394,
4.8208};
int AttenuationSizeConc[]={18};




double AttenuationArgsFe[]={
0.15,
0.2,
0.3,
0.4,
0.5,
0.6,
0.8,
1.,
1.25,
1.5,
2.,
3.,
4.,
5.,
6.,
8.,
10.,
15.};

double AttenuationDataFe[]={
1.55E+02,
1.15E+02,
8.65E+01,
7.40E+01,
6.63E+01,
6.07E+01,
5.27E+01,
4.72E+01,
4.21E+01,
3.84E+01,
3.36E+01,
2.85E+01,
2.61E+01,
2.48E+01,
2.41E+01,
2.36E+01,
2.36E+01,
2.43E+01};
int AttenuationSizeFe[]={18};






double AttenuationArgsPb[]={
0.15,
0.2,
0.3,
0.4,
0.5,
0.6,
0.8,
1.,
1.25,
1.5,
2.,
3.,
4.,
5.,
6.,
8.,
10.,
15.}; // in meV
double AttenuationDataPb[]={
2.28E+03,
1.13E+03,
4.57E+02,
2.63E+02,
1.83E+02,
1.42E+02,
1.01E+02,
8.05E+01,
6.66E+01,
5.92E+01,
5.22E+01,
4.80E+01,
4.76E+01,
4.84E+01,
4.98E+01,
5.30E+01,
5.64E+01,
6.42E+01
}; //in m^-1
int AttenuationSizePb[]={18};
*/

/*
//Linear attenuation test input
double AttenuationArgs[]={0.15,  10.0}; // in meV
double AttenuationData[]={7.0, 7.0 }; // in m^-1
int AttenuationSize[]={2};
 */
 
 // Dose buildup factors  concrete
 double BuildupDataConc[]={1., 1.74, 2.26, 2.95, 3.79, 4.51, 5.57, 6.51, 3.18,
	        	      1., 2.82, 5.13, 11.2, 24.2, 42.7, 87.6, 153., 353., 
		      1., 2.52, 4.66, 10.8, 25.6, 48.2, 107., 198., 497.,
		      1., 2.27, 4.03, 8.97, 20.2, 30.4, 75.6, 131, 292, 
		      1., 1.98, 3.24, 6.42, 12.7, 20.7, 37.2, 57.1, 106, 
		      1., 1.77, 2.65, 4.61, 7.97, 11.7, 18.6, 26.0, 42.2,
		      1., 1.67, 2.38, 3.84, 6.20, 8.71, 13.1, 17.7, 27.4, 
		      1., 1.61, 2.18, 3.37, 5.23, 7.15, 10.5, 13.9, 20.9, 
		      1., 1.49, 1.93, 2.80, 4.14, 5.52, 7.86, 10.2, 15.5, 
		      1., 1.41, 1.76, 2.45, 3.51, 4.59, 6.43, 8.31, 12.2, 
		      1., 1.35, 1.64, 2.22, 3.10, 4.01, 5.57, 7.19, 10.6, 
		      1., 1.26, 1.46, 1.86, 2.50, 3.16, 4.34, 5.59, 8.27}; 
		    
  int BuildupSizeConc[] ={12, //energy 
                  9}; // mu d
  double  BuildupArgsConc[]={
                     		      0.05, 0.15, 0.3, 0.5, 1.0, 2.0, 3.0, 4.0, 6.0, 8.0, 10.0, 15.0 // energy in MeV
		      ,
				      0., 1., 2., 4., 7., 10., 15., 20., 30. //mu d 
                      };
//Dose buildup factors Fe
 double BuildupDataFe[]={
            1.,	1.5, 	2.2, 	3.1, 	4.1, 	4.6, 	5.4, 	5.9, //0.1
		1.,	2.0, 	3.1, 	5.3, 	8.9, 	14., 	22., 	31.,  //0.2
		1.,	2.1, 	3.3, 	6.0, 	12., 	23., 	49., 	84.,  //0.4
		1.,	1.98, 	3.09, 	5.98, 	11.7, 	19.2, 	35.4, 	55.6, //0.5
		1.,	1.87, 	2.89, 	5.39, 	10.2, 	16.2, 	28.3, 	42.7, //1.0
		1.,	1.76, 	2.43,	 4.13, 	7.25, 	10.9, 	17.6, 	25.1, //2.0
		1.,	1.55, 	2.15, 	3.51, 	5.85, 	8.51, 	13.5, 	19.1, //3.0 
		1.,	1.45, 	1.94, 	3.03, 	4.91, 	7.11, 	11.2, 	16.0, //4.0
		1.,	1.34, 	1.72, 	2.58, 	4.14, 	6.02, 	9.89, 	14.7, //6.0
		1.,	1.27, 	1.56,	 2.23, 	3.49, 	5.07, 	8.50, 	13.0, //8.0
		1.,	1.20, 	1.42, 	1.95, 	2.99, 	4.35, 	7.54, 	12.4, //9.0
            1.,   1.48, 	1.86, 	2.72, 	4.30 , 	6.37, 	11.4, 	19.1};//15.0
 int BuildupSizeFe[]={12, // energy
	8}; // mu d
double BuildupArgsFe[]={0.1, 0.2, 0.4, 0.5, 1.0, 2.0, 3.0, 4.0, 6.0, 8.0, 10.0, 15.0, // energy in MeV
			0., 1., 2., 4., 7., 10., 15., 20.0};


//Dose buildup factors Pb
 double BuildupDataPb[]={1., 1.01, 1.03, 1.06, 1.15, 1.16, 1.18, 1.19, 
1., 1.11, 1.17, 1.25, 1.34, 1.41, 1.5, 1.56, 
1., 1.17, 1.29, 1.46, 1.58, 1.72, 1.89, 2.02, 
1., 1.24, 1.42, 1.69, 2.00, 2.27, 2.65, 2.73, 
1., 1.37, 1.69, 2.26, 3.02, 3.74, 4.81, 5.86, 
1., 1.39, 1.76, 2.51, 3.66, 4.84, 6.87, 9.00, 
1., 1.34, 1.68, 2.43, 3.75, 5.30, 8.44, 12.3, 
1., 1.27, 1.56, 2.25, 3.61, 5.44, 9.80, 16.3, 
1., 1.21, 1.46, 2.08, 3.44, 5.55, 11.7, 23.6, 
1., 1.18, 1.40, 1.97, 3.34, 5.69, 13.8, 32.7, 
1., 1.14, 1.30, 1.74, 2.89, 5.07, 14.1, 44.6, 
1., 1.11, 1.23, 1.58, 2.52, 4.34, 12.5, 39.2};

 int BuildupSizePb[]={12, // energy
	8}; // mu d
double BuildupArgsPb[]={0.15, 0.30, 0.40, 0.5, 1.0, 2.0, 3.0, 4.0, 5.1, 6.0, 8.0, 10.0,  // energy in MeV
			0., 1., 2., 4., 7., 10., 15., 20.0};




// Flux-to-dose conversion 
/* //NRB-99?
double FtoDArgs[]= {0.15,  0.20, 0.30, 0.40, 0.50, 0.60, 0.80, 1.0, 2.0, 4.0, 6.0, 8.0, 10.0}; // in meV
double FtoDData[] = {3600*0.752E-10, 3600*1.00E-10, 3600*1.51E-10, 3600*2.00E-10, 3600*2.47E-10, 3600*2.91E-10, 3600*3.73E-10, 3600*4.48E-10, 3600*7.49E-10, 3600*12.0E-10, 3600*16.0E-10, 3600*19.9E-10, 3600*23.8E-10};  // from phot/s/m2 to mkSv/hr conversion
int nFtoDgroups= 13;
int FtoDSize[] = {13};
*/
//ESS
double FtoDArgs[]= {
0.15,
0.2,
0.3,
0.4,
0.5,
0.511,
0.6,
0.662,
0.8,
1.,
1.12,
1.33,
1.5,
2.,
3.,
4.,
5.,
6.,
6.13,
8.,
10.,
15.}; // in MeV
double FtoDData[] = {
2.69E-07,
3.60E-07,
5.44E-07,
7.20E-07,
8.89E-07,
9.07E-07,
1.05E-06,
1.14E-06,
1.34E-06,
1.62E-06,
1.76E-06,
2.01E-06,
2.20E-06,
2.69E-06,
3.51E-06,
4.21E-06,
4.82E-06,
5.40E-06,
5.47E-06,
6.70E-06,
7.92E-06,
1.09E-05
};  // from phot/s/m2 to mkSv/hr conversion
int nFtoDgroups= 22;
int FtoDSize[] = {22};



// test input flux to dose
/*
double FtoDArgs[]= {0.15, 10.0}; // in meV
double FtoDData[] = {3600*7.0E-10,3600*7.0E-10};  // from phot/s/m2 to mkSv/hr conversion
int nFtoDgroups= 2;
int FtoDSize[] = {2};
*/
#endif //end of insertion of datatables.
/*** end of insertion to DECLARE section **/
#line 19499 "./ESS_BIFROST_shielding.c"
#undef OutputFile
#undef TotalCaptureFile
#undef TiCaptureFile
#undef NiCaptureFile
#undef TubingThickness
#undef SteelTubing
#undef Thickness
#undef Innerspace
#undef Material
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'DoseConc' [88]. */
#define mccompcurname  DoseConc
#define mccompcurtype  Dose_calculator
#define mccompcurindex 88
#define Material mccDoseConc_Material
#define Innerspace mccDoseConc_Innerspace
#define Thickness mccDoseConc_Thickness
#define SteelTubing mccDoseConc_SteelTubing
#define TubingThickness mccDoseConc_TubingThickness
#define NiCaptureFile mccDoseConc_NiCaptureFile
#define TiCaptureFile mccDoseConc_TiCaptureFile
#define TotalCaptureFile mccDoseConc_TotalCaptureFile
#define OutputFile mccDoseConc_OutputFile
#line 93 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Dose_calculator.comp"
#include <dirent.h>
#include <unistd.h>

//*** NEUTRON CONVERSION DATA *****//
#ifndef NEUTRON_GAMMA_DATA
#define NEUTRON_GAMMA_DATA 1
//Photons per capture in NiTi coating
double fraction[]={0.003565789,  0.009694611, 0.028838269, 0.149117282, 0.117348519, 0.042269932, 0.386434136, 0.092896131, 0.046767054, 0.032512648,  0.043547581, 0.040537585, 0.510133557, 0.320364465};
double energy [] = {0.150,
	 0.200,
	 0.300,
	 0.400,
	 0.500,
	 0.600,
	 0.800,
	 1.,
	 1.50,
	 2.000,
	 3.0,
	 4.0,
	 5.000,
	 6.000,
	 7.0,
	 8.000,
	 9.0,
	 10.000,
	 11.000}; 
int nEgroup= 19;
//Spectrum of capture photons from Ni and Ti
//Ni gamma capture specrum
double fractionNi[]={0.003722,//150
                     0.015513,//200
                     0.048432,//300
                     0.047485,//400
                     0.198059,//500
			   0.002809,//600
			   0.003142,//800
                     0.06579,//1000
                     0.054534,//1500
                     0.028872,//2000
                     0.063882,//3000
                     0.050286,//4000
                     0.035567,//5000
                     0.080326,//6000
			   0.156571,//7000
                     0.130355,//8000
                     0.534153,//9000
			   0.000558,//10000
			   0.000260};//11000


//Ti capture gamma spectrum
double fractionTi[]={0.009326, //0.15                                                                                                                                             
                     0.0,  //0.2                                                                                                                                                  
                     0.001938,//0.3                                                                                                                                               
                     0.302632,//0.4                                                                                                                                               
                     0.000882,//0.5
			   0.000668, //0.6
			   0.000914, //0.8                                                                                                                                            
                     0.023046,//1.0                                                                                                                                               
                     0.947104,//1.5                                                                                                                                               
                     0.232257,//2.0                                                                                                                                               
                     0.086418,//3.0                                                                                                                                               
                     0.162878,//4.0                                                                                                                                               
                     0.11209,//5.0                                                                                                                                                
                     0.013419,//6.0
			   0.0875051, //7.0 
                     0.009083,//8.0
			   0.001923, //9.0                    
                     0.002189,//10.0
			   0.000332};//11.0     
//double fractionB[]={0.0,  0.0,  0.0,  0.0,  0.93, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0,0.0,0.0};
double fractionB[]={0,//0.15
0,//0.2
0,//0.3
2.32983E-06,//0.4
0.935769511,//0.5
1.94926E-06,//0.6
2.22356E-05,//0.8
3.29279E-05,//1.0
0.000248357,//1.5
0.000398671,//2.0
0.000410038,//3.0
0.001042575,//4.0
0.000961964,//5.0
8.714E-05,//6.0
0.000248803,//7.0
0.00017111,//8.0
3.9074E-05,//9.0
7.28E-07,//10.0
6.27e-6};//11.0

/*
//conversion test input
double fraction [] = {0.5,0.5};
double energy [] = {2.0,2.0};
int nEgroup= 2;
*/
//*** SHIELDING DATA TABLES ****//
 // Mashkovich set + NIST data for 15 MeV
// Linear attenuation for concrete 
double AttenuationArgsConc[]={0.15, 0.2,     0.3,    0.4, 0.5,     0.6,    0.8,    1.0,   1.25,   1.5,   2.0,   2.75,   3.0,   4.0,   5.0,   6.0,   8.0,   10.0, 15.0}; // in meV
double AttenuationDataConc[]={31.7, 28.5, 24.6, 21.9, 20.0,   18.5, 16.3,  14.6, 13.1, 11.9, 10.3, 8.74, 8.37, 7.34, 6.65, 6.19, 5.61, 5.29, 4.8208}; // in m^-1
int AttenuationSizeConc[]={18};
// Iron
double AttenuationArgsFe[]={0.15,	 0.2, 	    0.3,	    0.4, 	0.5,    	 0.6,   	 0.8,   	 1.0,  	 1.25, 	  1.5, 	  2.0,	   2.75, 	  3.0, 	  4.0, 	  5.0, 	  6.0, 	  8.0, 	  10.0, 15.0}; // in meV
double AttenuationDataFe[]={139., 	106.,	 83.3, 	71.7,	 64.6,	 59.5, 	52.0, 	46.7, 	42.2, 	38.1, 	33.3,	 29.1, 	28.4,	 26.0, 	24.8, 	24.0, 	23.4, 	23.4, 24.3}; //in m^-1
int AttenuationSizeFe[]={19};
double AttenuationArgsPb[]={0.15,	 0.2, 	    0.3,	    0.4, 	0.5,    	 0.6,   	 0.8,   	 1.0,  	 1.25, 	  1.5, 	  2.0,	   2.75, 	  3.0, 	  4.0, 	  5.0, 	  6.0, 	  8.0, 	  10.0, 15.0}; // in meV
double AttenuationDataPb[]={2180.,	 1070., 	425., 	244., 	170., 	133.,	 95.2, 	77.1, 	65.8, 	57.7, 	50.8, 	47.6, 	46.8, 	47.2, 	48.1, 	49.4,	 52.0, 	55.0,  64.2}; //in m^-1
int AttenuationSizePb[]={19};
/*
//NIST set
//Concrete
double AttenuationArgsConc[]={
0.15,
0.2,
0.3,
0.4,
0.5,
0.6,
0.8,
1.,
1.25,
1.5,
2.,
3.,
4.,
5.,
6.,
8.,
10.,
15.};

double AttenuationDataConc[]={
33.028,
29.486,
25.231,
22.5009,
20.5045,
18.9428,
16.6221,
14.9385,
13.3561,
12.1624,
10.4811,
8.5123,
7.3991,
6.6884,
6.2031,
5.5936,
5.2394,
4.8208};
int AttenuationSizeConc[]={18};




double AttenuationArgsFe[]={
0.15,
0.2,
0.3,
0.4,
0.5,
0.6,
0.8,
1.,
1.25,
1.5,
2.,
3.,
4.,
5.,
6.,
8.,
10.,
15.};

double AttenuationDataFe[]={
1.55E+02,
1.15E+02,
8.65E+01,
7.40E+01,
6.63E+01,
6.07E+01,
5.27E+01,
4.72E+01,
4.21E+01,
3.84E+01,
3.36E+01,
2.85E+01,
2.61E+01,
2.48E+01,
2.41E+01,
2.36E+01,
2.36E+01,
2.43E+01};
int AttenuationSizeFe[]={18};






double AttenuationArgsPb[]={
0.15,
0.2,
0.3,
0.4,
0.5,
0.6,
0.8,
1.,
1.25,
1.5,
2.,
3.,
4.,
5.,
6.,
8.,
10.,
15.}; // in meV
double AttenuationDataPb[]={
2.28E+03,
1.13E+03,
4.57E+02,
2.63E+02,
1.83E+02,
1.42E+02,
1.01E+02,
8.05E+01,
6.66E+01,
5.92E+01,
5.22E+01,
4.80E+01,
4.76E+01,
4.84E+01,
4.98E+01,
5.30E+01,
5.64E+01,
6.42E+01
}; //in m^-1
int AttenuationSizePb[]={18};
*/

/*
//Linear attenuation test input
double AttenuationArgs[]={0.15,  10.0}; // in meV
double AttenuationData[]={7.0, 7.0 }; // in m^-1
int AttenuationSize[]={2};
 */
 
 // Dose buildup factors  concrete
 double BuildupDataConc[]={1., 1.74, 2.26, 2.95, 3.79, 4.51, 5.57, 6.51, 3.18,
	        	      1., 2.82, 5.13, 11.2, 24.2, 42.7, 87.6, 153., 353., 
		      1., 2.52, 4.66, 10.8, 25.6, 48.2, 107., 198., 497.,
		      1., 2.27, 4.03, 8.97, 20.2, 30.4, 75.6, 131, 292, 
		      1., 1.98, 3.24, 6.42, 12.7, 20.7, 37.2, 57.1, 106, 
		      1., 1.77, 2.65, 4.61, 7.97, 11.7, 18.6, 26.0, 42.2,
		      1., 1.67, 2.38, 3.84, 6.20, 8.71, 13.1, 17.7, 27.4, 
		      1., 1.61, 2.18, 3.37, 5.23, 7.15, 10.5, 13.9, 20.9, 
		      1., 1.49, 1.93, 2.80, 4.14, 5.52, 7.86, 10.2, 15.5, 
		      1., 1.41, 1.76, 2.45, 3.51, 4.59, 6.43, 8.31, 12.2, 
		      1., 1.35, 1.64, 2.22, 3.10, 4.01, 5.57, 7.19, 10.6, 
		      1., 1.26, 1.46, 1.86, 2.50, 3.16, 4.34, 5.59, 8.27}; 
		    
  int BuildupSizeConc[] ={12, //energy 
                  9}; // mu d
  double  BuildupArgsConc[]={
                     		      0.05, 0.15, 0.3, 0.5, 1.0, 2.0, 3.0, 4.0, 6.0, 8.0, 10.0, 15.0 // energy in MeV
		      ,
				      0., 1., 2., 4., 7., 10., 15., 20., 30. //mu d 
                      };
//Dose buildup factors Fe
 double BuildupDataFe[]={
            1.,	1.5, 	2.2, 	3.1, 	4.1, 	4.6, 	5.4, 	5.9, //0.1
		1.,	2.0, 	3.1, 	5.3, 	8.9, 	14., 	22., 	31.,  //0.2
		1.,	2.1, 	3.3, 	6.0, 	12., 	23., 	49., 	84.,  //0.4
		1.,	1.98, 	3.09, 	5.98, 	11.7, 	19.2, 	35.4, 	55.6, //0.5
		1.,	1.87, 	2.89, 	5.39, 	10.2, 	16.2, 	28.3, 	42.7, //1.0
		1.,	1.76, 	2.43,	 4.13, 	7.25, 	10.9, 	17.6, 	25.1, //2.0
		1.,	1.55, 	2.15, 	3.51, 	5.85, 	8.51, 	13.5, 	19.1, //3.0 
		1.,	1.45, 	1.94, 	3.03, 	4.91, 	7.11, 	11.2, 	16.0, //4.0
		1.,	1.34, 	1.72, 	2.58, 	4.14, 	6.02, 	9.89, 	14.7, //6.0
		1.,	1.27, 	1.56,	 2.23, 	3.49, 	5.07, 	8.50, 	13.0, //8.0
		1.,	1.20, 	1.42, 	1.95, 	2.99, 	4.35, 	7.54, 	12.4, //9.0
            1.,   1.48, 	1.86, 	2.72, 	4.30 , 	6.37, 	11.4, 	19.1};//15.0
 int BuildupSizeFe[]={12, // energy
	8}; // mu d
double BuildupArgsFe[]={0.1, 0.2, 0.4, 0.5, 1.0, 2.0, 3.0, 4.0, 6.0, 8.0, 10.0, 15.0, // energy in MeV
			0., 1., 2., 4., 7., 10., 15., 20.0};


//Dose buildup factors Pb
 double BuildupDataPb[]={1., 1.01, 1.03, 1.06, 1.15, 1.16, 1.18, 1.19, 
1., 1.11, 1.17, 1.25, 1.34, 1.41, 1.5, 1.56, 
1., 1.17, 1.29, 1.46, 1.58, 1.72, 1.89, 2.02, 
1., 1.24, 1.42, 1.69, 2.00, 2.27, 2.65, 2.73, 
1., 1.37, 1.69, 2.26, 3.02, 3.74, 4.81, 5.86, 
1., 1.39, 1.76, 2.51, 3.66, 4.84, 6.87, 9.00, 
1., 1.34, 1.68, 2.43, 3.75, 5.30, 8.44, 12.3, 
1., 1.27, 1.56, 2.25, 3.61, 5.44, 9.80, 16.3, 
1., 1.21, 1.46, 2.08, 3.44, 5.55, 11.7, 23.6, 
1., 1.18, 1.40, 1.97, 3.34, 5.69, 13.8, 32.7, 
1., 1.14, 1.30, 1.74, 2.89, 5.07, 14.1, 44.6, 
1., 1.11, 1.23, 1.58, 2.52, 4.34, 12.5, 39.2};

 int BuildupSizePb[]={12, // energy
	8}; // mu d
double BuildupArgsPb[]={0.15, 0.30, 0.40, 0.5, 1.0, 2.0, 3.0, 4.0, 5.1, 6.0, 8.0, 10.0,  // energy in MeV
			0., 1., 2., 4., 7., 10., 15., 20.0};




// Flux-to-dose conversion 
/* //NRB-99?
double FtoDArgs[]= {0.15,  0.20, 0.30, 0.40, 0.50, 0.60, 0.80, 1.0, 2.0, 4.0, 6.0, 8.0, 10.0}; // in meV
double FtoDData[] = {3600*0.752E-10, 3600*1.00E-10, 3600*1.51E-10, 3600*2.00E-10, 3600*2.47E-10, 3600*2.91E-10, 3600*3.73E-10, 3600*4.48E-10, 3600*7.49E-10, 3600*12.0E-10, 3600*16.0E-10, 3600*19.9E-10, 3600*23.8E-10};  // from phot/s/m2 to mkSv/hr conversion
int nFtoDgroups= 13;
int FtoDSize[] = {13};
*/
//ESS
double FtoDArgs[]= {
0.15,
0.2,
0.3,
0.4,
0.5,
0.511,
0.6,
0.662,
0.8,
1.,
1.12,
1.33,
1.5,
2.,
3.,
4.,
5.,
6.,
6.13,
8.,
10.,
15.}; // in MeV
double FtoDData[] = {
2.69E-07,
3.60E-07,
5.44E-07,
7.20E-07,
8.89E-07,
9.07E-07,
1.05E-06,
1.14E-06,
1.34E-06,
1.62E-06,
1.76E-06,
2.01E-06,
2.20E-06,
2.69E-06,
3.51E-06,
4.21E-06,
4.82E-06,
5.40E-06,
5.47E-06,
6.70E-06,
7.92E-06,
1.09E-05
};  // from phot/s/m2 to mkSv/hr conversion
int nFtoDgroups= 22;
int FtoDSize[] = {22};



// test input flux to dose
/*
double FtoDArgs[]= {0.15, 10.0}; // in meV
double FtoDData[] = {3600*7.0E-10,3600*7.0E-10};  // from phot/s/m2 to mkSv/hr conversion
int nFtoDgroups= 2;
int FtoDSize[] = {2};
*/
#endif //end of insertion of datatables.
/*** end of insertion to DECLARE section **/
#line 19912 "./ESS_BIFROST_shielding.c"
#undef OutputFile
#undef TotalCaptureFile
#undef TiCaptureFile
#undef NiCaptureFile
#undef TubingThickness
#undef SteelTubing
#undef Thickness
#undef Innerspace
#undef Material
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'DoseStandard' [89]. */
#define mccompcurname  DoseStandard
#define mccompcurtype  Dose_calculator
#define mccompcurindex 89
#define Material mccDoseStandard_Material
#define Innerspace mccDoseStandard_Innerspace
#define Thickness mccDoseStandard_Thickness
#define SteelTubing mccDoseStandard_SteelTubing
#define TubingThickness mccDoseStandard_TubingThickness
#define NiCaptureFile mccDoseStandard_NiCaptureFile
#define TiCaptureFile mccDoseStandard_TiCaptureFile
#define TotalCaptureFile mccDoseStandard_TotalCaptureFile
#define OutputFile mccDoseStandard_OutputFile
#line 93 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Dose_calculator.comp"
#include <dirent.h>
#include <unistd.h>

//*** NEUTRON CONVERSION DATA *****//
#ifndef NEUTRON_GAMMA_DATA
#define NEUTRON_GAMMA_DATA 1
//Photons per capture in NiTi coating
double fraction[]={0.003565789,  0.009694611, 0.028838269, 0.149117282, 0.117348519, 0.042269932, 0.386434136, 0.092896131, 0.046767054, 0.032512648,  0.043547581, 0.040537585, 0.510133557, 0.320364465};
double energy [] = {0.150,
	 0.200,
	 0.300,
	 0.400,
	 0.500,
	 0.600,
	 0.800,
	 1.,
	 1.50,
	 2.000,
	 3.0,
	 4.0,
	 5.000,
	 6.000,
	 7.0,
	 8.000,
	 9.0,
	 10.000,
	 11.000}; 
int nEgroup= 19;
//Spectrum of capture photons from Ni and Ti
//Ni gamma capture specrum
double fractionNi[]={0.003722,//150
                     0.015513,//200
                     0.048432,//300
                     0.047485,//400
                     0.198059,//500
			   0.002809,//600
			   0.003142,//800
                     0.06579,//1000
                     0.054534,//1500
                     0.028872,//2000
                     0.063882,//3000
                     0.050286,//4000
                     0.035567,//5000
                     0.080326,//6000
			   0.156571,//7000
                     0.130355,//8000
                     0.534153,//9000
			   0.000558,//10000
			   0.000260};//11000


//Ti capture gamma spectrum
double fractionTi[]={0.009326, //0.15                                                                                                                                             
                     0.0,  //0.2                                                                                                                                                  
                     0.001938,//0.3                                                                                                                                               
                     0.302632,//0.4                                                                                                                                               
                     0.000882,//0.5
			   0.000668, //0.6
			   0.000914, //0.8                                                                                                                                            
                     0.023046,//1.0                                                                                                                                               
                     0.947104,//1.5                                                                                                                                               
                     0.232257,//2.0                                                                                                                                               
                     0.086418,//3.0                                                                                                                                               
                     0.162878,//4.0                                                                                                                                               
                     0.11209,//5.0                                                                                                                                                
                     0.013419,//6.0
			   0.0875051, //7.0 
                     0.009083,//8.0
			   0.001923, //9.0                    
                     0.002189,//10.0
			   0.000332};//11.0     
//double fractionB[]={0.0,  0.0,  0.0,  0.0,  0.93, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0,0.0,0.0};
double fractionB[]={0,//0.15
0,//0.2
0,//0.3
2.32983E-06,//0.4
0.935769511,//0.5
1.94926E-06,//0.6
2.22356E-05,//0.8
3.29279E-05,//1.0
0.000248357,//1.5
0.000398671,//2.0
0.000410038,//3.0
0.001042575,//4.0
0.000961964,//5.0
8.714E-05,//6.0
0.000248803,//7.0
0.00017111,//8.0
3.9074E-05,//9.0
7.28E-07,//10.0
6.27e-6};//11.0

/*
//conversion test input
double fraction [] = {0.5,0.5};
double energy [] = {2.0,2.0};
int nEgroup= 2;
*/
//*** SHIELDING DATA TABLES ****//
 // Mashkovich set + NIST data for 15 MeV
// Linear attenuation for concrete 
double AttenuationArgsConc[]={0.15, 0.2,     0.3,    0.4, 0.5,     0.6,    0.8,    1.0,   1.25,   1.5,   2.0,   2.75,   3.0,   4.0,   5.0,   6.0,   8.0,   10.0, 15.0}; // in meV
double AttenuationDataConc[]={31.7, 28.5, 24.6, 21.9, 20.0,   18.5, 16.3,  14.6, 13.1, 11.9, 10.3, 8.74, 8.37, 7.34, 6.65, 6.19, 5.61, 5.29, 4.8208}; // in m^-1
int AttenuationSizeConc[]={18};
// Iron
double AttenuationArgsFe[]={0.15,	 0.2, 	    0.3,	    0.4, 	0.5,    	 0.6,   	 0.8,   	 1.0,  	 1.25, 	  1.5, 	  2.0,	   2.75, 	  3.0, 	  4.0, 	  5.0, 	  6.0, 	  8.0, 	  10.0, 15.0}; // in meV
double AttenuationDataFe[]={139., 	106.,	 83.3, 	71.7,	 64.6,	 59.5, 	52.0, 	46.7, 	42.2, 	38.1, 	33.3,	 29.1, 	28.4,	 26.0, 	24.8, 	24.0, 	23.4, 	23.4, 24.3}; //in m^-1
int AttenuationSizeFe[]={19};
double AttenuationArgsPb[]={0.15,	 0.2, 	    0.3,	    0.4, 	0.5,    	 0.6,   	 0.8,   	 1.0,  	 1.25, 	  1.5, 	  2.0,	   2.75, 	  3.0, 	  4.0, 	  5.0, 	  6.0, 	  8.0, 	  10.0, 15.0}; // in meV
double AttenuationDataPb[]={2180.,	 1070., 	425., 	244., 	170., 	133.,	 95.2, 	77.1, 	65.8, 	57.7, 	50.8, 	47.6, 	46.8, 	47.2, 	48.1, 	49.4,	 52.0, 	55.0,  64.2}; //in m^-1
int AttenuationSizePb[]={19};
/*
//NIST set
//Concrete
double AttenuationArgsConc[]={
0.15,
0.2,
0.3,
0.4,
0.5,
0.6,
0.8,
1.,
1.25,
1.5,
2.,
3.,
4.,
5.,
6.,
8.,
10.,
15.};

double AttenuationDataConc[]={
33.028,
29.486,
25.231,
22.5009,
20.5045,
18.9428,
16.6221,
14.9385,
13.3561,
12.1624,
10.4811,
8.5123,
7.3991,
6.6884,
6.2031,
5.5936,
5.2394,
4.8208};
int AttenuationSizeConc[]={18};




double AttenuationArgsFe[]={
0.15,
0.2,
0.3,
0.4,
0.5,
0.6,
0.8,
1.,
1.25,
1.5,
2.,
3.,
4.,
5.,
6.,
8.,
10.,
15.};

double AttenuationDataFe[]={
1.55E+02,
1.15E+02,
8.65E+01,
7.40E+01,
6.63E+01,
6.07E+01,
5.27E+01,
4.72E+01,
4.21E+01,
3.84E+01,
3.36E+01,
2.85E+01,
2.61E+01,
2.48E+01,
2.41E+01,
2.36E+01,
2.36E+01,
2.43E+01};
int AttenuationSizeFe[]={18};






double AttenuationArgsPb[]={
0.15,
0.2,
0.3,
0.4,
0.5,
0.6,
0.8,
1.,
1.25,
1.5,
2.,
3.,
4.,
5.,
6.,
8.,
10.,
15.}; // in meV
double AttenuationDataPb[]={
2.28E+03,
1.13E+03,
4.57E+02,
2.63E+02,
1.83E+02,
1.42E+02,
1.01E+02,
8.05E+01,
6.66E+01,
5.92E+01,
5.22E+01,
4.80E+01,
4.76E+01,
4.84E+01,
4.98E+01,
5.30E+01,
5.64E+01,
6.42E+01
}; //in m^-1
int AttenuationSizePb[]={18};
*/

/*
//Linear attenuation test input
double AttenuationArgs[]={0.15,  10.0}; // in meV
double AttenuationData[]={7.0, 7.0 }; // in m^-1
int AttenuationSize[]={2};
 */
 
 // Dose buildup factors  concrete
 double BuildupDataConc[]={1., 1.74, 2.26, 2.95, 3.79, 4.51, 5.57, 6.51, 3.18,
	        	      1., 2.82, 5.13, 11.2, 24.2, 42.7, 87.6, 153., 353., 
		      1., 2.52, 4.66, 10.8, 25.6, 48.2, 107., 198., 497.,
		      1., 2.27, 4.03, 8.97, 20.2, 30.4, 75.6, 131, 292, 
		      1., 1.98, 3.24, 6.42, 12.7, 20.7, 37.2, 57.1, 106, 
		      1., 1.77, 2.65, 4.61, 7.97, 11.7, 18.6, 26.0, 42.2,
		      1., 1.67, 2.38, 3.84, 6.20, 8.71, 13.1, 17.7, 27.4, 
		      1., 1.61, 2.18, 3.37, 5.23, 7.15, 10.5, 13.9, 20.9, 
		      1., 1.49, 1.93, 2.80, 4.14, 5.52, 7.86, 10.2, 15.5, 
		      1., 1.41, 1.76, 2.45, 3.51, 4.59, 6.43, 8.31, 12.2, 
		      1., 1.35, 1.64, 2.22, 3.10, 4.01, 5.57, 7.19, 10.6, 
		      1., 1.26, 1.46, 1.86, 2.50, 3.16, 4.34, 5.59, 8.27}; 
		    
  int BuildupSizeConc[] ={12, //energy 
                  9}; // mu d
  double  BuildupArgsConc[]={
                     		      0.05, 0.15, 0.3, 0.5, 1.0, 2.0, 3.0, 4.0, 6.0, 8.0, 10.0, 15.0 // energy in MeV
		      ,
				      0., 1., 2., 4., 7., 10., 15., 20., 30. //mu d 
                      };
//Dose buildup factors Fe
 double BuildupDataFe[]={
            1.,	1.5, 	2.2, 	3.1, 	4.1, 	4.6, 	5.4, 	5.9, //0.1
		1.,	2.0, 	3.1, 	5.3, 	8.9, 	14., 	22., 	31.,  //0.2
		1.,	2.1, 	3.3, 	6.0, 	12., 	23., 	49., 	84.,  //0.4
		1.,	1.98, 	3.09, 	5.98, 	11.7, 	19.2, 	35.4, 	55.6, //0.5
		1.,	1.87, 	2.89, 	5.39, 	10.2, 	16.2, 	28.3, 	42.7, //1.0
		1.,	1.76, 	2.43,	 4.13, 	7.25, 	10.9, 	17.6, 	25.1, //2.0
		1.,	1.55, 	2.15, 	3.51, 	5.85, 	8.51, 	13.5, 	19.1, //3.0 
		1.,	1.45, 	1.94, 	3.03, 	4.91, 	7.11, 	11.2, 	16.0, //4.0
		1.,	1.34, 	1.72, 	2.58, 	4.14, 	6.02, 	9.89, 	14.7, //6.0
		1.,	1.27, 	1.56,	 2.23, 	3.49, 	5.07, 	8.50, 	13.0, //8.0
		1.,	1.20, 	1.42, 	1.95, 	2.99, 	4.35, 	7.54, 	12.4, //9.0
            1.,   1.48, 	1.86, 	2.72, 	4.30 , 	6.37, 	11.4, 	19.1};//15.0
 int BuildupSizeFe[]={12, // energy
	8}; // mu d
double BuildupArgsFe[]={0.1, 0.2, 0.4, 0.5, 1.0, 2.0, 3.0, 4.0, 6.0, 8.0, 10.0, 15.0, // energy in MeV
			0., 1., 2., 4., 7., 10., 15., 20.0};


//Dose buildup factors Pb
 double BuildupDataPb[]={1., 1.01, 1.03, 1.06, 1.15, 1.16, 1.18, 1.19, 
1., 1.11, 1.17, 1.25, 1.34, 1.41, 1.5, 1.56, 
1., 1.17, 1.29, 1.46, 1.58, 1.72, 1.89, 2.02, 
1., 1.24, 1.42, 1.69, 2.00, 2.27, 2.65, 2.73, 
1., 1.37, 1.69, 2.26, 3.02, 3.74, 4.81, 5.86, 
1., 1.39, 1.76, 2.51, 3.66, 4.84, 6.87, 9.00, 
1., 1.34, 1.68, 2.43, 3.75, 5.30, 8.44, 12.3, 
1., 1.27, 1.56, 2.25, 3.61, 5.44, 9.80, 16.3, 
1., 1.21, 1.46, 2.08, 3.44, 5.55, 11.7, 23.6, 
1., 1.18, 1.40, 1.97, 3.34, 5.69, 13.8, 32.7, 
1., 1.14, 1.30, 1.74, 2.89, 5.07, 14.1, 44.6, 
1., 1.11, 1.23, 1.58, 2.52, 4.34, 12.5, 39.2};

 int BuildupSizePb[]={12, // energy
	8}; // mu d
double BuildupArgsPb[]={0.15, 0.30, 0.40, 0.5, 1.0, 2.0, 3.0, 4.0, 5.1, 6.0, 8.0, 10.0,  // energy in MeV
			0., 1., 2., 4., 7., 10., 15., 20.0};




// Flux-to-dose conversion 
/* //NRB-99?
double FtoDArgs[]= {0.15,  0.20, 0.30, 0.40, 0.50, 0.60, 0.80, 1.0, 2.0, 4.0, 6.0, 8.0, 10.0}; // in meV
double FtoDData[] = {3600*0.752E-10, 3600*1.00E-10, 3600*1.51E-10, 3600*2.00E-10, 3600*2.47E-10, 3600*2.91E-10, 3600*3.73E-10, 3600*4.48E-10, 3600*7.49E-10, 3600*12.0E-10, 3600*16.0E-10, 3600*19.9E-10, 3600*23.8E-10};  // from phot/s/m2 to mkSv/hr conversion
int nFtoDgroups= 13;
int FtoDSize[] = {13};
*/
//ESS
double FtoDArgs[]= {
0.15,
0.2,
0.3,
0.4,
0.5,
0.511,
0.6,
0.662,
0.8,
1.,
1.12,
1.33,
1.5,
2.,
3.,
4.,
5.,
6.,
6.13,
8.,
10.,
15.}; // in MeV
double FtoDData[] = {
2.69E-07,
3.60E-07,
5.44E-07,
7.20E-07,
8.89E-07,
9.07E-07,
1.05E-06,
1.14E-06,
1.34E-06,
1.62E-06,
1.76E-06,
2.01E-06,
2.20E-06,
2.69E-06,
3.51E-06,
4.21E-06,
4.82E-06,
5.40E-06,
5.47E-06,
6.70E-06,
7.92E-06,
1.09E-05
};  // from phot/s/m2 to mkSv/hr conversion
int nFtoDgroups= 22;
int FtoDSize[] = {22};



// test input flux to dose
/*
double FtoDArgs[]= {0.15, 10.0}; // in meV
double FtoDData[] = {3600*7.0E-10,3600*7.0E-10};  // from phot/s/m2 to mkSv/hr conversion
int nFtoDgroups= 2;
int FtoDSize[] = {2};
*/
#endif //end of insertion of datatables.
/*** end of insertion to DECLARE section **/
#line 20325 "./ESS_BIFROST_shielding.c"
#undef OutputFile
#undef TotalCaptureFile
#undef TiCaptureFile
#undef NiCaptureFile
#undef TubingThickness
#undef SteelTubing
#undef Thickness
#undef Innerspace
#undef Material
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Dose5' [90]. */
#define mccompcurname  Dose5
#define mccompcurtype  Dose_calculator
#define mccompcurindex 90
#define Material mccDose5_Material
#define Innerspace mccDose5_Innerspace
#define Thickness mccDose5_Thickness
#define SteelTubing mccDose5_SteelTubing
#define TubingThickness mccDose5_TubingThickness
#define NiCaptureFile mccDose5_NiCaptureFile
#define TiCaptureFile mccDose5_TiCaptureFile
#define TotalCaptureFile mccDose5_TotalCaptureFile
#define OutputFile mccDose5_OutputFile
#line 93 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Dose_calculator.comp"
#include <dirent.h>
#include <unistd.h>

//*** NEUTRON CONVERSION DATA *****//
#ifndef NEUTRON_GAMMA_DATA
#define NEUTRON_GAMMA_DATA 1
//Photons per capture in NiTi coating
double fraction[]={0.003565789,  0.009694611, 0.028838269, 0.149117282, 0.117348519, 0.042269932, 0.386434136, 0.092896131, 0.046767054, 0.032512648,  0.043547581, 0.040537585, 0.510133557, 0.320364465};
double energy [] = {0.150,
	 0.200,
	 0.300,
	 0.400,
	 0.500,
	 0.600,
	 0.800,
	 1.,
	 1.50,
	 2.000,
	 3.0,
	 4.0,
	 5.000,
	 6.000,
	 7.0,
	 8.000,
	 9.0,
	 10.000,
	 11.000}; 
int nEgroup= 19;
//Spectrum of capture photons from Ni and Ti
//Ni gamma capture specrum
double fractionNi[]={0.003722,//150
                     0.015513,//200
                     0.048432,//300
                     0.047485,//400
                     0.198059,//500
			   0.002809,//600
			   0.003142,//800
                     0.06579,//1000
                     0.054534,//1500
                     0.028872,//2000
                     0.063882,//3000
                     0.050286,//4000
                     0.035567,//5000
                     0.080326,//6000
			   0.156571,//7000
                     0.130355,//8000
                     0.534153,//9000
			   0.000558,//10000
			   0.000260};//11000


//Ti capture gamma spectrum
double fractionTi[]={0.009326, //0.15                                                                                                                                             
                     0.0,  //0.2                                                                                                                                                  
                     0.001938,//0.3                                                                                                                                               
                     0.302632,//0.4                                                                                                                                               
                     0.000882,//0.5
			   0.000668, //0.6
			   0.000914, //0.8                                                                                                                                            
                     0.023046,//1.0                                                                                                                                               
                     0.947104,//1.5                                                                                                                                               
                     0.232257,//2.0                                                                                                                                               
                     0.086418,//3.0                                                                                                                                               
                     0.162878,//4.0                                                                                                                                               
                     0.11209,//5.0                                                                                                                                                
                     0.013419,//6.0
			   0.0875051, //7.0 
                     0.009083,//8.0
			   0.001923, //9.0                    
                     0.002189,//10.0
			   0.000332};//11.0     
//double fractionB[]={0.0,  0.0,  0.0,  0.0,  0.93, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0,0.0,0.0};
double fractionB[]={0,//0.15
0,//0.2
0,//0.3
2.32983E-06,//0.4
0.935769511,//0.5
1.94926E-06,//0.6
2.22356E-05,//0.8
3.29279E-05,//1.0
0.000248357,//1.5
0.000398671,//2.0
0.000410038,//3.0
0.001042575,//4.0
0.000961964,//5.0
8.714E-05,//6.0
0.000248803,//7.0
0.00017111,//8.0
3.9074E-05,//9.0
7.28E-07,//10.0
6.27e-6};//11.0

/*
//conversion test input
double fraction [] = {0.5,0.5};
double energy [] = {2.0,2.0};
int nEgroup= 2;
*/
//*** SHIELDING DATA TABLES ****//
 // Mashkovich set + NIST data for 15 MeV
// Linear attenuation for concrete 
double AttenuationArgsConc[]={0.15, 0.2,     0.3,    0.4, 0.5,     0.6,    0.8,    1.0,   1.25,   1.5,   2.0,   2.75,   3.0,   4.0,   5.0,   6.0,   8.0,   10.0, 15.0}; // in meV
double AttenuationDataConc[]={31.7, 28.5, 24.6, 21.9, 20.0,   18.5, 16.3,  14.6, 13.1, 11.9, 10.3, 8.74, 8.37, 7.34, 6.65, 6.19, 5.61, 5.29, 4.8208}; // in m^-1
int AttenuationSizeConc[]={18};
// Iron
double AttenuationArgsFe[]={0.15,	 0.2, 	    0.3,	    0.4, 	0.5,    	 0.6,   	 0.8,   	 1.0,  	 1.25, 	  1.5, 	  2.0,	   2.75, 	  3.0, 	  4.0, 	  5.0, 	  6.0, 	  8.0, 	  10.0, 15.0}; // in meV
double AttenuationDataFe[]={139., 	106.,	 83.3, 	71.7,	 64.6,	 59.5, 	52.0, 	46.7, 	42.2, 	38.1, 	33.3,	 29.1, 	28.4,	 26.0, 	24.8, 	24.0, 	23.4, 	23.4, 24.3}; //in m^-1
int AttenuationSizeFe[]={19};
double AttenuationArgsPb[]={0.15,	 0.2, 	    0.3,	    0.4, 	0.5,    	 0.6,   	 0.8,   	 1.0,  	 1.25, 	  1.5, 	  2.0,	   2.75, 	  3.0, 	  4.0, 	  5.0, 	  6.0, 	  8.0, 	  10.0, 15.0}; // in meV
double AttenuationDataPb[]={2180.,	 1070., 	425., 	244., 	170., 	133.,	 95.2, 	77.1, 	65.8, 	57.7, 	50.8, 	47.6, 	46.8, 	47.2, 	48.1, 	49.4,	 52.0, 	55.0,  64.2}; //in m^-1
int AttenuationSizePb[]={19};
/*
//NIST set
//Concrete
double AttenuationArgsConc[]={
0.15,
0.2,
0.3,
0.4,
0.5,
0.6,
0.8,
1.,
1.25,
1.5,
2.,
3.,
4.,
5.,
6.,
8.,
10.,
15.};

double AttenuationDataConc[]={
33.028,
29.486,
25.231,
22.5009,
20.5045,
18.9428,
16.6221,
14.9385,
13.3561,
12.1624,
10.4811,
8.5123,
7.3991,
6.6884,
6.2031,
5.5936,
5.2394,
4.8208};
int AttenuationSizeConc[]={18};




double AttenuationArgsFe[]={
0.15,
0.2,
0.3,
0.4,
0.5,
0.6,
0.8,
1.,
1.25,
1.5,
2.,
3.,
4.,
5.,
6.,
8.,
10.,
15.};

double AttenuationDataFe[]={
1.55E+02,
1.15E+02,
8.65E+01,
7.40E+01,
6.63E+01,
6.07E+01,
5.27E+01,
4.72E+01,
4.21E+01,
3.84E+01,
3.36E+01,
2.85E+01,
2.61E+01,
2.48E+01,
2.41E+01,
2.36E+01,
2.36E+01,
2.43E+01};
int AttenuationSizeFe[]={18};






double AttenuationArgsPb[]={
0.15,
0.2,
0.3,
0.4,
0.5,
0.6,
0.8,
1.,
1.25,
1.5,
2.,
3.,
4.,
5.,
6.,
8.,
10.,
15.}; // in meV
double AttenuationDataPb[]={
2.28E+03,
1.13E+03,
4.57E+02,
2.63E+02,
1.83E+02,
1.42E+02,
1.01E+02,
8.05E+01,
6.66E+01,
5.92E+01,
5.22E+01,
4.80E+01,
4.76E+01,
4.84E+01,
4.98E+01,
5.30E+01,
5.64E+01,
6.42E+01
}; //in m^-1
int AttenuationSizePb[]={18};
*/

/*
//Linear attenuation test input
double AttenuationArgs[]={0.15,  10.0}; // in meV
double AttenuationData[]={7.0, 7.0 }; // in m^-1
int AttenuationSize[]={2};
 */
 
 // Dose buildup factors  concrete
 double BuildupDataConc[]={1., 1.74, 2.26, 2.95, 3.79, 4.51, 5.57, 6.51, 3.18,
	        	      1., 2.82, 5.13, 11.2, 24.2, 42.7, 87.6, 153., 353., 
		      1., 2.52, 4.66, 10.8, 25.6, 48.2, 107., 198., 497.,
		      1., 2.27, 4.03, 8.97, 20.2, 30.4, 75.6, 131, 292, 
		      1., 1.98, 3.24, 6.42, 12.7, 20.7, 37.2, 57.1, 106, 
		      1., 1.77, 2.65, 4.61, 7.97, 11.7, 18.6, 26.0, 42.2,
		      1., 1.67, 2.38, 3.84, 6.20, 8.71, 13.1, 17.7, 27.4, 
		      1., 1.61, 2.18, 3.37, 5.23, 7.15, 10.5, 13.9, 20.9, 
		      1., 1.49, 1.93, 2.80, 4.14, 5.52, 7.86, 10.2, 15.5, 
		      1., 1.41, 1.76, 2.45, 3.51, 4.59, 6.43, 8.31, 12.2, 
		      1., 1.35, 1.64, 2.22, 3.10, 4.01, 5.57, 7.19, 10.6, 
		      1., 1.26, 1.46, 1.86, 2.50, 3.16, 4.34, 5.59, 8.27}; 
		    
  int BuildupSizeConc[] ={12, //energy 
                  9}; // mu d
  double  BuildupArgsConc[]={
                     		      0.05, 0.15, 0.3, 0.5, 1.0, 2.0, 3.0, 4.0, 6.0, 8.0, 10.0, 15.0 // energy in MeV
		      ,
				      0., 1., 2., 4., 7., 10., 15., 20., 30. //mu d 
                      };
//Dose buildup factors Fe
 double BuildupDataFe[]={
            1.,	1.5, 	2.2, 	3.1, 	4.1, 	4.6, 	5.4, 	5.9, //0.1
		1.,	2.0, 	3.1, 	5.3, 	8.9, 	14., 	22., 	31.,  //0.2
		1.,	2.1, 	3.3, 	6.0, 	12., 	23., 	49., 	84.,  //0.4
		1.,	1.98, 	3.09, 	5.98, 	11.7, 	19.2, 	35.4, 	55.6, //0.5
		1.,	1.87, 	2.89, 	5.39, 	10.2, 	16.2, 	28.3, 	42.7, //1.0
		1.,	1.76, 	2.43,	 4.13, 	7.25, 	10.9, 	17.6, 	25.1, //2.0
		1.,	1.55, 	2.15, 	3.51, 	5.85, 	8.51, 	13.5, 	19.1, //3.0 
		1.,	1.45, 	1.94, 	3.03, 	4.91, 	7.11, 	11.2, 	16.0, //4.0
		1.,	1.34, 	1.72, 	2.58, 	4.14, 	6.02, 	9.89, 	14.7, //6.0
		1.,	1.27, 	1.56,	 2.23, 	3.49, 	5.07, 	8.50, 	13.0, //8.0
		1.,	1.20, 	1.42, 	1.95, 	2.99, 	4.35, 	7.54, 	12.4, //9.0
            1.,   1.48, 	1.86, 	2.72, 	4.30 , 	6.37, 	11.4, 	19.1};//15.0
 int BuildupSizeFe[]={12, // energy
	8}; // mu d
double BuildupArgsFe[]={0.1, 0.2, 0.4, 0.5, 1.0, 2.0, 3.0, 4.0, 6.0, 8.0, 10.0, 15.0, // energy in MeV
			0., 1., 2., 4., 7., 10., 15., 20.0};


//Dose buildup factors Pb
 double BuildupDataPb[]={1., 1.01, 1.03, 1.06, 1.15, 1.16, 1.18, 1.19, 
1., 1.11, 1.17, 1.25, 1.34, 1.41, 1.5, 1.56, 
1., 1.17, 1.29, 1.46, 1.58, 1.72, 1.89, 2.02, 
1., 1.24, 1.42, 1.69, 2.00, 2.27, 2.65, 2.73, 
1., 1.37, 1.69, 2.26, 3.02, 3.74, 4.81, 5.86, 
1., 1.39, 1.76, 2.51, 3.66, 4.84, 6.87, 9.00, 
1., 1.34, 1.68, 2.43, 3.75, 5.30, 8.44, 12.3, 
1., 1.27, 1.56, 2.25, 3.61, 5.44, 9.80, 16.3, 
1., 1.21, 1.46, 2.08, 3.44, 5.55, 11.7, 23.6, 
1., 1.18, 1.40, 1.97, 3.34, 5.69, 13.8, 32.7, 
1., 1.14, 1.30, 1.74, 2.89, 5.07, 14.1, 44.6, 
1., 1.11, 1.23, 1.58, 2.52, 4.34, 12.5, 39.2};

 int BuildupSizePb[]={12, // energy
	8}; // mu d
double BuildupArgsPb[]={0.15, 0.30, 0.40, 0.5, 1.0, 2.0, 3.0, 4.0, 5.1, 6.0, 8.0, 10.0,  // energy in MeV
			0., 1., 2., 4., 7., 10., 15., 20.0};




// Flux-to-dose conversion 
/* //NRB-99?
double FtoDArgs[]= {0.15,  0.20, 0.30, 0.40, 0.50, 0.60, 0.80, 1.0, 2.0, 4.0, 6.0, 8.0, 10.0}; // in meV
double FtoDData[] = {3600*0.752E-10, 3600*1.00E-10, 3600*1.51E-10, 3600*2.00E-10, 3600*2.47E-10, 3600*2.91E-10, 3600*3.73E-10, 3600*4.48E-10, 3600*7.49E-10, 3600*12.0E-10, 3600*16.0E-10, 3600*19.9E-10, 3600*23.8E-10};  // from phot/s/m2 to mkSv/hr conversion
int nFtoDgroups= 13;
int FtoDSize[] = {13};
*/
//ESS
double FtoDArgs[]= {
0.15,
0.2,
0.3,
0.4,
0.5,
0.511,
0.6,
0.662,
0.8,
1.,
1.12,
1.33,
1.5,
2.,
3.,
4.,
5.,
6.,
6.13,
8.,
10.,
15.}; // in MeV
double FtoDData[] = {
2.69E-07,
3.60E-07,
5.44E-07,
7.20E-07,
8.89E-07,
9.07E-07,
1.05E-06,
1.14E-06,
1.34E-06,
1.62E-06,
1.76E-06,
2.01E-06,
2.20E-06,
2.69E-06,
3.51E-06,
4.21E-06,
4.82E-06,
5.40E-06,
5.47E-06,
6.70E-06,
7.92E-06,
1.09E-05
};  // from phot/s/m2 to mkSv/hr conversion
int nFtoDgroups= 22;
int FtoDSize[] = {22};



// test input flux to dose
/*
double FtoDArgs[]= {0.15, 10.0}; // in meV
double FtoDData[] = {3600*7.0E-10,3600*7.0E-10};  // from phot/s/m2 to mkSv/hr conversion
int nFtoDgroups= 2;
int FtoDSize[] = {2};
*/
#endif //end of insertion of datatables.
/*** end of insertion to DECLARE section **/
#line 20738 "./ESS_BIFROST_shielding.c"
#undef OutputFile
#undef TotalCaptureFile
#undef TiCaptureFile
#undef NiCaptureFile
#undef TubingThickness
#undef SteelTubing
#undef Thickness
#undef Innerspace
#undef Material
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

Coords mcposaOrigin, mcposrOrigin;
Rotation mcrotaOrigin, mcrotrOrigin;
Coords mcposaESS_source, mcposrESS_source;
Rotation mcrotaESS_source, mcrotrESS_source;
Coords mcposaStartOfGuide, mcposrStartOfGuide;
Rotation mcrotaStartOfGuide, mcrotrStartOfGuide;
Coords mcposaNBOA, mcposrNBOA;
Rotation mcrotaNBOA, mcrotrNBOA;
Coords mcposaEndOfelement_6, mcposrEndOfelement_6;
Rotation mcrotaEndOfelement_6, mcrotrEndOfelement_6;
Coords mcposaEndOfelement_5, mcposrEndOfelement_5;
Rotation mcrotaEndOfelement_5, mcrotrEndOfelement_5;
Coords mcposacurved_guide_1_0, mcposrcurved_guide_1_0;
Rotation mcrotacurved_guide_1_0, mcrotrcurved_guide_1_0;
Coords mcposacurved_guide_2_0, mcposrcurved_guide_2_0;
Rotation mcrotacurved_guide_2_0, mcrotrcurved_guide_2_0;
Coords mcposacurved_guide_3_0, mcposrcurved_guide_3_0;
Rotation mcrotacurved_guide_3_0, mcrotrcurved_guide_3_0;
Coords mcposacurved_guide_4_0, mcposrcurved_guide_4_0;
Rotation mcrotacurved_guide_4_0, mcrotrcurved_guide_4_0;
Coords mcposacurved_guide_5_beforeChopper, mcposrcurved_guide_5_beforeChopper;
Rotation mcrotacurved_guide_5_beforeChopper, mcrotrcurved_guide_5_beforeChopper;
Coords mcposacurved_guide_5_afterChopper, mcposrcurved_guide_5_afterChopper;
Rotation mcrotacurved_guide_5_afterChopper, mcrotrcurved_guide_5_afterChopper;
Coords mcposacurved_guide_6_0, mcposrcurved_guide_6_0;
Rotation mcrotacurved_guide_6_0, mcrotrcurved_guide_6_0;
Coords mcposacurved_guide_7_0, mcposrcurved_guide_7_0;
Rotation mcrotacurved_guide_7_0, mcrotrcurved_guide_7_0;
Coords mcposacurved_guide_8_0, mcposrcurved_guide_8_0;
Rotation mcrotacurved_guide_8_0, mcrotrcurved_guide_8_0;
Coords mcposacurved_guide_9_0, mcposrcurved_guide_9_0;
Rotation mcrotacurved_guide_9_0, mcrotrcurved_guide_9_0;
Coords mcposacurved_guide_10_0, mcposrcurved_guide_10_0;
Rotation mcrotacurved_guide_10_0, mcrotrcurved_guide_10_0;
Coords mcposacurved_guide_11_0, mcposrcurved_guide_11_0;
Rotation mcrotacurved_guide_11_0, mcrotrcurved_guide_11_0;
Coords mcposacurved_guide_12_0, mcposrcurved_guide_12_0;
Rotation mcrotacurved_guide_12_0, mcrotrcurved_guide_12_0;
Coords mcposacurved_guide_13_0, mcposrcurved_guide_13_0;
Rotation mcrotacurved_guide_13_0, mcrotrcurved_guide_13_0;
Coords mcposacurved_guide_14_0, mcposrcurved_guide_14_0;
Rotation mcrotacurved_guide_14_0, mcrotrcurved_guide_14_0;
Coords mcposacurved_guide_15_0, mcposrcurved_guide_15_0;
Rotation mcrotacurved_guide_15_0, mcrotrcurved_guide_15_0;
Coords mcposacurved_guide_16_0, mcposrcurved_guide_16_0;
Rotation mcrotacurved_guide_16_0, mcrotrcurved_guide_16_0;
Coords mcposacurved_guide_17_0, mcposrcurved_guide_17_0;
Rotation mcrotacurved_guide_17_0, mcrotrcurved_guide_17_0;
Coords mcposacurved_guide_18_beforeChopper, mcposrcurved_guide_18_beforeChopper;
Rotation mcrotacurved_guide_18_beforeChopper, mcrotrcurved_guide_18_beforeChopper;
Coords mcposacurved_guide_18_afterChopper, mcposrcurved_guide_18_afterChopper;
Rotation mcrotacurved_guide_18_afterChopper, mcrotrcurved_guide_18_afterChopper;
Coords mcposacurved_guide_19_0, mcposrcurved_guide_19_0;
Rotation mcrotacurved_guide_19_0, mcrotrcurved_guide_19_0;
Coords mcposacurved_guide_20_0, mcposrcurved_guide_20_0;
Rotation mcrotacurved_guide_20_0, mcrotrcurved_guide_20_0;
Coords mcposacurved_guide_21_0, mcposrcurved_guide_21_0;
Rotation mcrotacurved_guide_21_0, mcrotrcurved_guide_21_0;
Coords mcposacurved_guide_22_0, mcposrcurved_guide_22_0;
Rotation mcrotacurved_guide_22_0, mcrotrcurved_guide_22_0;
Coords mcposacurved_guide_23_0, mcposrcurved_guide_23_0;
Rotation mcrotacurved_guide_23_0, mcrotrcurved_guide_23_0;
Coords mcposacurved_guide_24_0, mcposrcurved_guide_24_0;
Rotation mcrotacurved_guide_24_0, mcrotrcurved_guide_24_0;
Coords mcposacurved_guide_25_0, mcposrcurved_guide_25_0;
Rotation mcrotacurved_guide_25_0, mcrotrcurved_guide_25_0;
Coords mcposacurved_guide_26_0, mcposrcurved_guide_26_0;
Rotation mcrotacurved_guide_26_0, mcrotrcurved_guide_26_0;
Coords mcposacurved_guide_27_0, mcposrcurved_guide_27_0;
Rotation mcrotacurved_guide_27_0, mcrotrcurved_guide_27_0;
Coords mcposacurved_guide_28_0, mcposrcurved_guide_28_0;
Rotation mcrotacurved_guide_28_0, mcrotrcurved_guide_28_0;
Coords mcposacurved_guide_29_0, mcposrcurved_guide_29_0;
Rotation mcrotacurved_guide_29_0, mcrotrcurved_guide_29_0;
Coords mcposacurved_guide_30_0, mcposrcurved_guide_30_0;
Rotation mcrotacurved_guide_30_0, mcrotrcurved_guide_30_0;
Coords mcposacurved_guide_31_0, mcposrcurved_guide_31_0;
Rotation mcrotacurved_guide_31_0, mcrotrcurved_guide_31_0;
Coords mcposacurved_guide_32_0, mcposrcurved_guide_32_0;
Rotation mcrotacurved_guide_32_0, mcrotrcurved_guide_32_0;
Coords mcposacurved_guide_33_0, mcposrcurved_guide_33_0;
Rotation mcrotacurved_guide_33_0, mcrotrcurved_guide_33_0;
Coords mcposacurved_guide_34_0, mcposrcurved_guide_34_0;
Rotation mcrotacurved_guide_34_0, mcrotrcurved_guide_34_0;
Coords mcposacurved_guide_35_0, mcposrcurved_guide_35_0;
Rotation mcrotacurved_guide_35_0, mcrotrcurved_guide_35_0;
Coords mcposacurved_guide_36_0, mcposrcurved_guide_36_0;
Rotation mcrotacurved_guide_36_0, mcrotrcurved_guide_36_0;
Coords mcposaEndOfelement_4, mcposrEndOfelement_4;
Rotation mcrotaEndOfelement_4, mcrotrEndOfelement_4;
Coords mcposalog_P_start, mcposrlog_P_start;
Rotation mcrotalog_P_start, mcrotrlog_P_start;
Coords mcposaelliptical_guide_gravity3, mcposrelliptical_guide_gravity3;
Rotation mcrotaelliptical_guide_gravity3, mcrotrelliptical_guide_gravity3;
Coords mcposaEndOfelement_3, mcposrEndOfelement_3;
Rotation mcrotaEndOfelement_3, mcrotrEndOfelement_3;
Coords mcposastraight_guide_2_1, mcposrstraight_guide_2_1;
Rotation mcrotastraight_guide_2_1, mcrotrstraight_guide_2_1;
Coords mcposastraight_guide_2_2, mcposrstraight_guide_2_2;
Rotation mcrotastraight_guide_2_2, mcrotrstraight_guide_2_2;
Coords mcposaEndOfelement_2, mcposrEndOfelement_2;
Rotation mcrotaEndOfelement_2, mcrotrEndOfelement_2;
Coords mcposaelliptical_guide_gravity1_1, mcposrelliptical_guide_gravity1_1;
Rotation mcrotaelliptical_guide_gravity1_1, mcrotrelliptical_guide_gravity1_1;
Coords mcposaDiwJaw3, mcposrDiwJaw3;
Rotation mcrotaDiwJaw3, mcrotrDiwJaw3;
Coords mcposaelliptical_guide_gravity1_2, mcposrelliptical_guide_gravity1_2;
Rotation mcrotaelliptical_guide_gravity1_2, mcrotrelliptical_guide_gravity1_2;
Coords mcposaDiwJaw2, mcposrDiwJaw2;
Rotation mcrotaDiwJaw2, mcrotrDiwJaw2;
Coords mcposaelliptical_guide_gravity1_3, mcposrelliptical_guide_gravity1_3;
Rotation mcrotaelliptical_guide_gravity1_3, mcrotrelliptical_guide_gravity1_3;
Coords mcposaDiwJaw1, mcposrDiwJaw1;
Rotation mcrotaDiwJaw1, mcrotrDiwJaw1;
Coords mcposaelliptical_guide_gravity1_4, mcposrelliptical_guide_gravity1_4;
Rotation mcrotaelliptical_guide_gravity1_4, mcrotrelliptical_guide_gravity1_4;
Coords mcposaEndOfelement_1, mcposrEndOfelement_1;
Rotation mcrotaEndOfelement_1, mcrotrEndOfelement_1;
Coords mcposaVirtualOutput, mcposrVirtualOutput;
Rotation mcrotaVirtualOutput, mcrotrVirtualOutput;
Coords mcposaDiwJaw0, mcposrDiwJaw0;
Rotation mcrotaDiwJaw0, mcrotrDiwJaw0;
Coords mcposalog_P_stop, mcposrlog_P_stop;
Rotation mcrotalog_P_stop, mcrotrlog_P_stop;
Coords mcposaarm_iter_P1_start, mcposrarm_iter_P1_start;
Rotation mcrotaarm_iter_P1_start, mcrotrarm_iter_P1_start;
Coords mcposaiter_P1_start, mcposriter_P1_start;
Rotation mcrotaiter_P1_start, mcrotriter_P1_start;
Coords mcposaarm_iter_P1_dummy, mcposrarm_iter_P1_dummy;
Rotation mcrotaarm_iter_P1_dummy, mcrotrarm_iter_P1_dummy;
Coords mcposamndP01, mcposrmndP01;
Rotation mcrotamndP01, mcrotrmndP01;
Coords mcposaarm_iter_P1_stop, mcposrarm_iter_P1_stop;
Rotation mcrotaarm_iter_P1_stop, mcrotrarm_iter_P1_stop;
Coords mcposaiter_P1_stop, mcposriter_P1_stop;
Rotation mcrotaiter_P1_stop, mcrotriter_P1_stop;
Coords mcposaa11i, mcposra11i;
Rotation mcrotaa11i, mcrotra11i;
Coords mcposaarm_iter_P2_start, mcposrarm_iter_P2_start;
Rotation mcrotaarm_iter_P2_start, mcrotrarm_iter_P2_start;
Coords mcposaiter_P2_start, mcposriter_P2_start;
Rotation mcrotaiter_P2_start, mcrotriter_P2_start;
Coords mcposaarm_iter_P2_dummy, mcposrarm_iter_P2_dummy;
Rotation mcrotaarm_iter_P2_dummy, mcrotrarm_iter_P2_dummy;
Coords mcposamndP02, mcposrmndP02;
Rotation mcrotamndP02, mcrotrmndP02;
Coords mcposaarm_iter_P2_stop, mcposrarm_iter_P2_stop;
Rotation mcrotaarm_iter_P2_stop, mcrotrarm_iter_P2_stop;
Coords mcposaiter_P2_stop, mcposriter_P2_stop;
Rotation mcrotaiter_P2_stop, mcrotriter_P2_stop;
Coords mcposaa12i, mcposra12i;
Rotation mcrotaa12i, mcrotra12i;
Coords mcposaarm_iter_P3_start, mcposrarm_iter_P3_start;
Rotation mcrotaarm_iter_P3_start, mcrotrarm_iter_P3_start;
Coords mcposaiter_P3_start, mcposriter_P3_start;
Rotation mcrotaiter_P3_start, mcrotriter_P3_start;
Coords mcposaarm_iter_P3_dummy, mcposrarm_iter_P3_dummy;
Rotation mcrotaarm_iter_P3_dummy, mcrotrarm_iter_P3_dummy;
Coords mcposamndP03, mcposrmndP03;
Rotation mcrotamndP03, mcrotrmndP03;
Coords mcposaarm_iter_P3_stop, mcposrarm_iter_P3_stop;
Rotation mcrotaarm_iter_P3_stop, mcrotrarm_iter_P3_stop;
Coords mcposaiter_P3_stop, mcposriter_P3_stop;
Rotation mcrotaiter_P3_stop, mcrotriter_P3_stop;
Coords mcposaa13i, mcposra13i;
Rotation mcrotaa13i, mcrotra13i;
Coords mcposaBeamstop, mcposrBeamstop;
Rotation mcrotaBeamstop, mcrotrBeamstop;
Coords mcposaLmon_guide_end, mcposrLmon_guide_end;
Rotation mcrotaLmon_guide_end, mcrotrLmon_guide_end;
Coords mcposaSCalc, mcposrSCalc;
Rotation mcrotaSCalc, mcrotrSCalc;
Coords mcposaDoseFe, mcposrDoseFe;
Rotation mcrotaDoseFe, mcrotrDoseFe;
Coords mcposaDoseConc, mcposrDoseConc;
Rotation mcrotaDoseConc, mcrotrDoseConc;
Coords mcposaDoseStandard, mcposrDoseStandard;
Rotation mcrotaDoseStandard, mcrotrDoseStandard;
Coords mcposaDose5, mcposrDose5;
Rotation mcrotaDose5, mcrotrDose5;

MCNUM mcnx, mcny, mcnz, mcnvx, mcnvy, mcnvz, mcnt, mcnsx, mcnsy, mcnsz, mcnp;

/* end declare */

void mcinit(void) {
#define mccompcurname  ESS_BIFROST_shielding
#define mccompcurtype  INSTRUMENT
#define mccompcurindex 0
#define mcposaESS_BIFROST_shielding coords_set(0,0,0)
#define WaveMin mcipWaveMin
#define WaveMax mcipWaveMax
#define E_0 mcipE_0
#define L_0 mcipL_0
#define chopPulseOpening mcipchopPulseOpening
#define DivSlit0_width mcipDivSlit0_width
#define DivSlit1_width mcipDivSlit1_width
#define DivSlit2_width mcipDivSlit2_width
#define DivSlit3_width mcipDivSlit3_width
#define Npulse mcipNpulse
#define print mcipprint
#define makeVirtualSource mcipmakeVirtualSource
#define printMValues mcipprintMValues
#define power mcippower
#define BWopen mcipBWopen
#line 211 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
{


// If there is set a value of L_0, overwrite E_0 and calculate E_0 from L_0 
if (L_0>0){
	E_0=81.82/(L_0*L_0);
}



// Following is all the m-values for the entire guide hardcoaded in arrays along with the element lengths for each m-value. 
// It is important to note that the naming convention here goes the opposite way of the neutron path, meaning that mValues1 describes the m-values on the element closest to the sample and mValues6 are closest to the source.

 //// Part 1 //// 
 elementLength1_part_1[0] = 0.50000; 
 mValues1vertical_part_1[0] = 1.50; 
 mValues1horizontal_part_1[0] = 1.50;

 elementLength1_part_1[1] = 0.50000; 
 mValues1vertical_part_1[1] = 1.50; 
 mValues1horizontal_part_1[1] = 1.50;

 elementLength1_part_1[2] = 0.50000; 
 mValues1vertical_part_1[2] = 1.50; 
 mValues1horizontal_part_1[2] = 1.50;

 elementLength1_part_1[3] = 0.50000; 
 mValues1vertical_part_1[3] = 1.50; 
 mValues1horizontal_part_1[3] = 1.50;

 elementLength1_part_1[4] = 0.50000; 
 mValues1vertical_part_1[4] = 1.50; 
 mValues1horizontal_part_1[4] = 1.50;

 elementLength1_part_1[5] = 0.50000; 
 mValues1vertical_part_1[5] = 1.50; 
 mValues1horizontal_part_1[5] = 1.50;

 elementLength1_part_1[6] = 0.50000; 
 mValues1vertical_part_1[6] = 1.50; 
 mValues1horizontal_part_1[6] = 1.50;

 elementLength1_part_1[7] = 0.50000; 
 mValues1vertical_part_1[7] = 1.50; 
 mValues1horizontal_part_1[7] = 1.50;

 elementLength1_part_1[8] = 0.50000; 
 mValues1vertical_part_1[8] = 1.50; 
 mValues1horizontal_part_1[8] = 1.50;

 elementLength1_part_1[9] = 0.50000; 
 mValues1vertical_part_1[9] = 1.50; 
 mValues1horizontal_part_1[9] = 1.50;

 elementLength1_part_1[10] = 0.50000; 
 mValues1vertical_part_1[10] = 1.50; 
 mValues1horizontal_part_1[10] = 1.50;

 elementLength1_part_1[11] = 0.50000; 
 mValues1vertical_part_1[11] = 1.50; 
 mValues1horizontal_part_1[11] = 1.50;

 elementLength1_part_1[12] = 0.50000; 
 mValues1vertical_part_1[12] = 1.50; 
 mValues1horizontal_part_1[12] = 1.50;

 elementLength1_part_1[13] = 0.50000; 
 mValues1vertical_part_1[13] = 1.50; 
 mValues1horizontal_part_1[13] = 1.50;

 elementLength1_part_1[14] = 0.50000; 
 mValues1vertical_part_1[14] = 1.50; 
 mValues1horizontal_part_1[14] = 1.50;

 elementLength1_part_1[15] = 0.50000; 
 mValues1vertical_part_1[15] = 1.50; 
 mValues1horizontal_part_1[15] = 1.50;

 elementLength1_part_1[16] = 0.50000; 
 mValues1vertical_part_1[16] = 1.50; 
 mValues1horizontal_part_1[16] = 1.50;

 elementLength1_part_1[17] = 0.50000; 
 mValues1vertical_part_1[17] = 1.50; 
 mValues1horizontal_part_1[17] = 1.50;

 elementLength1_part_1[18] = 0.50000; 
 mValues1vertical_part_1[18] = 1.50; 
 mValues1horizontal_part_1[18] = 1.50;

 elementLength1_part_1[19] = 0.50000; // Raised vert to 2
 mValues1vertical_part_1[19] =  1.50; 
 mValues1horizontal_part_1[19] = 1.50;

 elementLength1_part_1[20] = 0.50000; 
 mValues1vertical_part_1[20] =  1.50; 
 mValues1horizontal_part_1[20] = 1.50;

 elementLength1_part_1[21] = 0.50000; 
 mValues1vertical_part_1[21] =  1.50; 
 mValues1horizontal_part_1[21] = 1.50;

 elementLength1_part_1[22] = 0.50000; // h=2 v=1.5
 mValues1vertical_part_1[22] =  2.00; 
 mValues1horizontal_part_1[22] = 1.5;

 elementLength1_part_1[23] = 0.50000; 
 mValues1vertical_part_1[23] =  2.00; 
 mValues1horizontal_part_1[23] = 1.5;

 elementLength1_part_1[24] = 0.50000; 
 mValues1vertical_part_1[24] =  2.00; 
 mValues1horizontal_part_1[24] = 1.5;

 elementLength1_part_1[25] = 0.50000; 
 mValues1vertical_part_1[25] =  2.00; 
 mValues1horizontal_part_1[25] = 1.5;

 elementLength1_part_1[26] = 0.50000; 
 mValues1vertical_part_1[26] =  2.00; 
 mValues1horizontal_part_1[26] = 1.5;

 elementLength1_part_1[27] = 0.50000; 
 mValues1vertical_part_1[27] =  2.00; 
 mValues1horizontal_part_1[27] = 1.5;

 elementLength1_part_1[28] = 0.50000; 
 mValues1vertical_part_1[28] =  2.00; 
 mValues1horizontal_part_1[28] = 1.5;

 elementLength1_part_1[29] = 0.50000; 
 mValues1vertical_part_1[29] = 2.00; 
 mValues1horizontal_part_1[29] = 1.5;

 elementLength1_part_1[30] = 0.50000; 
 mValues1vertical_part_1[30] = 2.00; 
 mValues1horizontal_part_1[30] = 1.5;

 elementLength1_part_1[31] = 0.50000; 
 mValues1vertical_part_1[31] = 2.00; 
 mValues1horizontal_part_1[31] = 1.5; //

 elementLength1_part_1[32] = 0.50000; 
 mValues1vertical_part_1[32] = 2.00; 
 mValues1horizontal_part_1[32] = 2.00;

 elementLength1_part_1[33] = 0.50000; 
 mValues1vertical_part_1[33] = 2.00; 
 mValues1horizontal_part_1[33] = 2.00;

 elementLength1_part_1[34] = 0.50000; 
 mValues1vertical_part_1[34] = 2.00; 
 mValues1horizontal_part_1[34] = 2.00;

 elementLength1_part_1[35] = 0.50000; 
 mValues1vertical_part_1[35] = 2.00; 
 mValues1horizontal_part_1[35] = 2.00;

 elementLength1_part_1[36] = 0.01580;  // Gap 
 mValues1vertical_part_1[36] = 0.00; 
 mValues1horizontal_part_1[36] = 0.00;

 elementLength1_part_1[37] = 0.48420; 
 mValues1vertical_part_1[37] = 2.00; 
 mValues1horizontal_part_1[37] = 2.00;

 elementLength1_part_1[38] = 0.50000; 
 mValues1vertical_part_1[38] = 2.50; 
 mValues1horizontal_part_1[38] = 2.5;

 elementLength1_part_1[39] = 0.50000; 
 mValues1vertical_part_1[39] = 2.50; 
 mValues1horizontal_part_1[39] = 2.50;

 elementLength1_part_1[40] = 0.14320; 
 mValues1vertical_part_1[40] = 2.50; 
 mValues1horizontal_part_1[40] = 2.50;

 
 //// Part 2 //// 
 elementLength1_part_2[0] = 0.31680;  // changed from 2.5 / 2.5
 mValues1vertical_part_2[0] = 3.00; 
 mValues1horizontal_part_2[0] = 3.00;

 elementLength1_part_2[1] = 0.50000; 
 mValues1vertical_part_2[1] = 3.00; 
 mValues1horizontal_part_2[1] = 3.00;

 elementLength1_part_2[2] = 0.46320; 
 mValues1vertical_part_2[2] = 3.00; 
 mValues1horizontal_part_2[2] = 3.00;

 
 //// Part 3 //// 
 elementLength1_part_3[0] = 0.0596; 
 mValues1vertical_part_3[0] = 3.00; 
 mValues1horizontal_part_3[0] = 3.00;

 elementLength1_part_3[1] = 0.500; 
 mValues1vertical_part_3[1] = 3.00; 
 mValues1horizontal_part_3[1] = 3.50;

 
 //// Part 4 //// 
 elementLength1_part_4[0] = 0.06670 ; 
 mValues1vertical_part_4[0] = 3.00; 
 mValues1horizontal_part_4[0] = 3.50;

 elementLength1_part_4[1] = 0.50000; 
 mValues1vertical_part_4[1] = 3.50; 
 mValues1horizontal_part_4[1] = 3.5;

// A bit extra due to mismatch in coating lengths after rounding element length to 0.5 meters:
// 0.47 cm of this is applied in last tested version (sep 12 2018)
 elementLength1_part_4[2] = 0.0047;  
 mValues1vertical_part_4[2] = 3.50; 
 mValues1horizontal_part_4[2] = 3.5;

elementLength3S[0]=0.50;
mValues3verticalS[0]=2.000000;
mValues3horizontalS[0]=2.500000;
elementLength3S[1]=0.50;
mValues3verticalS[1]=2.000000;
mValues3horizontalS[1]=2.500000;
elementLength3S[2]=0.50;
mValues3verticalS[2]=2.000000;
mValues3horizontalS[2]=2.500000;
elementLength3S[3]=0.50;
mValues3verticalS[3]=2.000000;
mValues3horizontalS[3]=2.500000;
elementLength3S[4]=0.50;
mValues3verticalS[4]=2.000000;
mValues3horizontalS[4]=2.500000;
elementLength3S[5]=0.50;
mValues3verticalS[5]=2.000000;
mValues3horizontalS[5]=2.500000;
elementLength3S[6]=0.50;
mValues3verticalS[6]=2.000000;
mValues3horizontalS[6]=2.500000;

// Moni gap
elementLength3S[7]=monigap_length;
mValues3verticalS[7]=0;
mValues3horizontalS[7]=0;


elementLength3S[7+1]=0.50-monigap_length;
mValues3verticalS[7+1]=2.000000;
mValues3horizontalS[7+1]=2.000000;
elementLength3S[8+1]=0.50;
mValues3verticalS[8+1]=2.000000;
mValues3horizontalS[8+1]=2.000000;
elementLength3S[9+1]=0.50;
mValues3verticalS[9+1]=2.000000;
mValues3horizontalS[9+1]=2.000000;
elementLength3S[10+1]=0.50;
mValues3verticalS[10+1]=2.000000;
mValues3horizontalS[10+1]=2.000000;
elementLength3S[11+1]=0.50;
mValues3verticalS[11+1]=2.000000;
mValues3horizontalS[11+1]=2.000000;
elementLength3S[12+1]=0.50;
mValues3verticalS[12+1]=2.000000;
mValues3horizontalS[12+1]=2.000000;
elementLength3S[13+1]=0.50;
mValues3verticalS[13+1]=1.500000;
mValues3horizontalS[13+1]=2.000000;
elementLength3S[14+1]=0.50;
mValues3verticalS[14+1]=1.500000;
mValues3horizontalS[14+1]=2.000000;
elementLength3S[15+1]=0.50;
mValues3verticalS[15+1]=1.500000;
mValues3horizontalS[15+1]=2.000000;
elementLength3S[16+1]=0.50;
mValues3verticalS[16+1]=1.500000;
mValues3horizontalS[16+1]=2.000000;
elementLength3S[17+1]=0.50;
mValues3verticalS[17+1]=1.500000;
mValues3horizontalS[17+1]=2.000000;
elementLength3S[18+1]=0.50;
mValues3verticalS[18+1]=1.500000;
mValues3horizontalS[18+1]=2.000000;
elementLength3S[19+1]=0.50;
mValues3verticalS[19+1]=1.500000;
mValues3horizontalS[19+1]=2.000000;
elementLength3S[20+1]=0.50;
mValues3verticalS[20+1]=1.500000;
mValues3horizontalS[20+1]=2.000000;
elementLength3S[21+1]=0.50;
mValues3verticalS[21+1]=1.500000;
mValues3horizontalS[21+1]=2.000000;
elementLength3S[22+1]=0.50;
mValues3verticalS[22+1]=1.500000;
mValues3horizontalS[22+1]=2.000000;
elementLength3S[23+1]=0.50;
mValues3verticalS[23+1]=1.500000;
mValues3horizontalS[23+1]=1.500000;
elementLength3S[24+1]=0.50;
mValues3verticalS[24+1]=1.500000;
mValues3horizontalS[24+1]=1.500000;
elementLength3S[25+1]=0.50;
mValues3verticalS[25+1]=1.500000;
mValues3horizontalS[25+1]=1.500000;
elementLength3S[26+1]=0.50;
mValues3verticalS[26+1]=1.500000;
mValues3horizontalS[26+1]=1.500000;
elementLength3S[27+1]=0.50;
mValues3verticalS[27+1]=1.500000;
mValues3horizontalS[27+1]=1.500000;
elementLength3S[28+1]=0.50;
mValues3verticalS[28+1]=1.500000;
mValues3horizontalS[28+1]=1.500000;
elementLength3S[29+1]=0.50;
mValues3verticalS[29+1]=1.500000;
mValues3horizontalS[29+1]=1.500000;
elementLength3S[30+1]=0.50;
mValues3verticalS[30+1]=1.500000;
mValues3horizontalS[30+1]=1.500000;
elementLength3S[31+1]=0.50;
mValues3verticalS[31+1]=1.500000;
mValues3horizontalS[31+1]=1.500000;
elementLength3S[32+1]=0.50;
mValues3verticalS[32+1]=1.500000;
mValues3horizontalS[32+1]=1.500000;
elementLength3S[33+1]=0.50;
mValues3verticalS[33+1]=1.500000;
mValues3horizontalS[33+1]=1.500000;
elementLength3S[34+1]=0.50;
mValues3verticalS[34+1]=1.500000;
mValues3horizontalS[34+1]=1.500000;
elementLength3S[35+1]=0.50;
mValues3verticalS[35+1]=1.500000;
mValues3horizontalS[35+1]=1.500000;
elementLength3S[36+1]=0.50;
mValues3verticalS[36+1]=1.500000;
mValues3horizontalS[36+1]=1.500000;
elementLength3S[37+1]=0.50;
mValues3verticalS[37+1]=1.500000;
mValues3horizontalS[37+1]=1.500000;
elementLength3S[38+1]=0.50;
mValues3verticalS[38+1]=1.500000;
mValues3horizontalS[38+1]=1.500000;
elementLength3S[39+1]=0.50;
mValues3verticalS[39+1]=1.500000;
mValues3horizontalS[39+1]=1.500000;
elementLength3S[40+1]=0.50;
mValues3verticalS[40+1]=1.500000;
mValues3horizontalS[40+1]=1.500000;
elementLength3S[41+1]=0.50;
mValues3verticalS[41+1]=1.500000;
mValues3horizontalS[41+1]=1.500000;
elementLength3S[42+1]=0.50;
mValues3verticalS[42+1]=1.500000;
mValues3horizontalS[42+1]=1.500000;
elementLength3S[43+1]=0.50;
mValues3verticalS[43+1]=1.500000;
mValues3horizontalS[43+1]=1.500000;
elementLength3S[44+1]=0.50;
mValues3verticalS[44+1]=1.500000;
mValues3horizontalS[44+1]=1.500000;
elementLength3S[45+1]=0.50;
mValues3verticalS[45+1]=1.500000;
mValues3horizontalS[45+1]=1.500000;
elementLength3S[46+1]=0.50;
mValues3verticalS[46+1]=1.500000;
mValues3horizontalS[46+1]=1.500000;
elementLength3S[47+1]=0.50;
mValues3verticalS[47+1]=1.500000;
mValues3horizontalS[47+1]=1.500000;
elementLength3S[48+1]=0.50;
mValues3verticalS[48+1]=1.500000;
mValues3horizontalS[48+1]=1.500000;
elementLength3S[49+1]=0.50 - 0.0712; // Slightly shorter segment last
mValues3verticalS[49+1]=1.500000;
mValues3horizontalS[49+1]=1.500000;


elementLength6S[0]=0.488444444444444;
mValues6verticalS[0]=3.500000;
mValues6horizontalS[0]=3.000000;
elementLength6S[1]=0.488444444444444;
mValues6verticalS[1]=3.500000;
mValues6horizontalS[1]=3.000000;
elementLength6S[2]=0.488444444444444;
mValues6verticalS[2]=3.000000;
mValues6horizontalS[2]=2.500000;
elementLength6S[3]=0.488444444444444;
mValues6verticalS[3]=3.000000;
mValues6horizontalS[3]=2.500000;
elementLength6S[4]=0.488444444444444;
mValues6verticalS[4]=2.500000;
mValues6horizontalS[4]=2.500000;
elementLength6S[5]=0.488444444444444;
mValues6verticalS[5]=2.500000;
mValues6horizontalS[5]=2.000000;
elementLength6S[6]=0.488444444444444;
mValues6verticalS[6]=2.500000;
mValues6horizontalS[6]=1.500000;

elementLength6S[7]=0.061218888888892 ; // Shorter due to window #1
mValues6verticalS[7]=2.500000;
mValues6horizontalS[7]=1.500000;

elementLength6S[8]=0.02349; // feeder window #1
mValues6verticalS[8]=0;
mValues6horizontalS[8]=0;

elementLength6S[9]=0.488444444444444 - 0.061218888888892 - 0.02349; // End of piece 7 (the window and start of the mirror si substracted from its length)
mValues6verticalS[9]=2.500000;
mValues6horizontalS[9]=1.500000;

elementLength6S[10]=0.076264444; // shorter due to window #2
mValues6verticalS[10]=2.000000;
mValues6horizontalS[10]=1.500000;

elementLength6S[11]=0.015; // feeder window #2
mValues6verticalS[11]=0;
mValues6horizontalS[11]=0;

elementLength6S[12]=0.488444444444444 - 0.015 - 0.076264444 - 0.00047; // End of Feeder (after window 2)
mValues6verticalS[12]=2.0;
mValues6horizontalS[12]=1.5;

/************************************************/
/*                  Chopper calculations                    */
/************************************************/
 
PulseHighFluxOffset=2.0e-4; // Time from T0 to high pulse.
ModPulseLengthHighF=2.86e-3; // width of high pulse

InstLength=162.0;
chopPulseDist= 4.41+0.032+2.0-0.1;  // Distance fro moderator to Pulse chapping chopper
//chopFrameOverlap1Pos= 2.0;    // Distance from pulse shapping choppers to first frame owerlap chopper
//chopFrameOverlap2Pos=7.0;     // Distance from pulse shapping choppers to second frame owerlap chopper
//chopBWPos=71.4403;           // Distance from pulse shapping choppers to tail romval chopper

if  (chopPulseFrequencyOrder*chopPulseOpening > 170.0/360.0/14.0) {    /******* Check if pulse shapping chopper opening is large enough for requested frequency or reduce frequency *******/
	 chopPulseFrequencyOrder=floor(170.0/360.0/14.0/chopPulseOpening);
	printf(" \n \n Warning: Impossible combination of chopPulseFrequencyOrder and chopPulseOpening chosen, chopPulseFrequencyOrder reduced to: %f  \n", chopPulseFrequencyOrder);
}

lambda_1=1.0/(0.1106*sqrt(E_0));  /**** general chopper calculations **********/
WavelengthBand = 1/(InstLength-chopPulseDist)/14.0/2.528e-4;
lambda_0=lambda_1-WavelengthBand;
v_0=3956.0/lambda_1;  
v_1=3956.0/lambda_0;

t_samp_center=PulseHighFluxOffset+ModPulseLengthHighF/2.0+(InstLength/v_1+InstLength/v_0)/2.0;
t_samp_0=t_samp_center-1.0/14.0/2.0;
t_samp_1=t_samp_center+1.0/14.0/2.0;

/***********  Pulse shaping chopper calculations **********/
chopPulseOffset=(chopPulseDist/v_1+chopPulseDist/v_0)/2.0+ModPulseLengthHighF/2.0+PulseHighFluxOffset;
chopPulsePossibleOpening=chopPulseDist/v_0-chopPulseOffset;
chopPulsePhaseOffset=  (chopPulseOffset+ chopPulseOpening/2.0)*14.0*chopPulseFrequencyOrder*360.0-170.0/2.0;
chopPulse2PhaseOffset= chopPulsePhaseOffset- 360.0*(chopPulseOpening*14.0*chopPulseFrequencyOrder)+170.0;

if  (chopPulseFrequencyOrder == 0) { 
	chopPulsePhaseOffset= 0;
	chopPulse2PhaseOffset= 0;
		printf(" \n \n Warning: Pulse shaping chopper parked! Setting the offsets to zero");
}


/*********** Frame Overlap chopper calculations ******************/
chopFrameOverlap1Open= 1.0/14.0/InstLength*(chopFrameOverlap1Pos)*1.5 ;
chopFrameOverlap1Offset=(  ( (chopFrameOverlap1Pos)/v_1+(chopFrameOverlap1Pos)/v_0)/2.0+PulseHighFluxOffset+ModPulseLengthHighF/2.0) ;
chopFrameOverlap1PhaseOffset=  (chopFrameOverlap1Offset)*14.0*360.0;

chopFrameOverlap2Open= 1.0/14.0/InstLength*(chopFrameOverlap2Pos)*1.65 ;
chopFrameOverlap2Offset=(  ( (chopFrameOverlap2Pos)/v_1+(chopFrameOverlap2Pos)/v_0)/2.0+PulseHighFluxOffset+ModPulseLengthHighF/2.0) ;
chopFrameOverlap2PhaseOffset=  (chopFrameOverlap2Offset)*14.0*360.0;

/********** Bandwidth chopper calculations ****************/

//chopBW_t0= chopPulseOffset-chopPulseOpening/2.0 + (t_samp_0-(chopPulseOffset-chopPulseOpening/2.0)) / (InstLength-chopPulseDist) * (InstLength-chopBWPos) ;
//chopBW_t1= chopPulseOffset+chopPulseOpening/2.0 + (t_samp_1-(chopPulseOffset+chopPulseOpening/2.0)) / (InstLength-chopPulseDist) * (InstLength-chopBWPos);
chopBW_t0= PulseHighFluxOffset+ModPulseLengthHighF/2.0 + chopBWPos/v_1;
chopBW_t1=  PulseHighFluxOffset+ModPulseLengthHighF/2.0 + chopBWPos/v_0;

chopBWOpen= 360.0/InstLength*(chopBWPos-chopPulseDist*1); //Here Jonas put a multiplier on the choppulsedist
chopBWOffset=(chopBW_t0+chopBW_t1)/2.0;
chopBWPhaseOffset=  (chopBWOffset)*14.0*360.0;

if (printMValues==1) {
	// Will print all coating values to a file if this is toggled on 
	FILE* fp = fopen("CoatingDistributions.txt", "w");
	fprintf(fp,"Coating Distributions. From moderator towards sample:\n");
	fprintf(fp,"m_horizontal , m_vertical , elementlength:\n");
	fprintf(fp,"NBOA:\n");
	for (i = 0 ; i < 13 ; i++){
		fprintf(fp,"%f , %f , %f\n",mValues6horizontalS[i],mValues6verticalS[i],elementLength6S[i]);
	}

	fprintf(fp,"\nCurved section:\n");
	fprintf(fp,"(%f,%f) , %f , %f\n",3.000000,3.500000,2.500000,18.0);
	
	fprintf(fp,"\nExpanding ellipse:\n");
	for (i = 0 ; i < 51 ; i++){
		fprintf(fp,"%f , %f , %f\n",mValues3horizontalS[i],mValues3verticalS[i],elementLength3S[i]);
	}
	
	fprintf(fp,"\nLong Straight Section\n");
	fprintf(fp,"%f , %f , %f\n",1.500000,1.000000,90.0);

	fprintf(fp,"\nFocusing Ellipse\n");
	for (i = 0 ; i < 41 ; i++){
		fprintf(fp,"%f , %f , %f\n", mValues1horizontal_part_1[i], mValues1vertical_part_1[i],elementLength1_part_1[i]);
	}
	fprintf(fp,"2 cm gap for divJaw 3\n");
	for (i = 0 ; i < 3 ; i++){
		fprintf(fp,"%f , %f , %f\n", mValues1horizontal_part_2[i], mValues1vertical_part_2[i],elementLength1_part_2[i]);
	}
	fprintf(fp,"2 cm gap for divJaw 2\n");
	for (i = 0 ; i < 2 ; i++){
		fprintf(fp,"%f , %f , %f\n", mValues1horizontal_part_3[i], mValues1vertical_part_3[i],elementLength1_part_3[i]);
	}
fprintf(fp,"2 cm gap for divJaw 1 \n");
	for (i = 0 ; i < 3 ; i++){
		fprintf(fp,"%f , %f , %f\n", mValues1horizontal_part_4[i], mValues1vertical_part_4[i],elementLength1_part_4[i]);
	}


fclose(fp);
}


printf("\n part 3 length: %f\n",DivSlit2Pos-DivSlit1Gap/2.0-DivSlit2Gap/2.0-DivSlit1Pos);
printf("\n part 4 length: %f\n",DivSlit1Pos-DivSlit1Gap/2.0-sample_dist);

}
#line 21489 "./ESS_BIFROST_shielding.c"
#undef BWopen
#undef power
#undef printMValues
#undef makeVirtualSource
#undef print
#undef Npulse
#undef DivSlit3_width
#undef DivSlit2_width
#undef DivSlit1_width
#undef DivSlit0_width
#undef chopPulseOpening
#undef L_0
#undef E_0
#undef WaveMax
#undef WaveMin
#undef mcposaESS_BIFROST_shielding
#undef mccompcurindex
#undef mccompcurtype
#undef mccompcurname
  /* Computation of coordinate transformations. */
  {
    Coords mctc1, mctc2, mcLastComp;
    Rotation mctr1;
    double mcAccumulatedILength = 0;
    /* Initialize "last" component origin as (0,0,0) */
    mcLastComp = coords_set(0,0,0);

    mcDEBUG_INSTR()
  /* Component initializations. */
    /* Component Origin. */
  /* Setting parameters for component Origin. */
  SIG_MESSAGE("Origin (Init:SetPar)");
#line 39 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mccOrigin_profile, "NULL" ? "NULL" : "", 16384); else mccOrigin_profile[0]='\0';
#line 39 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccOrigin_percent = 10;
#line 39 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccOrigin_flag_save = 0;
#line 39 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccOrigin_minutes = 0;
#line 21530 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("Origin (Init:Place/Rotate)");
  rot_set_rotation(mcrotaOrigin,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 21537 "./ESS_BIFROST_shielding.c"
  rot_copy(mcrotrOrigin, mcrotaOrigin);
  mcposaOrigin = coords_set(
#line 745 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 745 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 745 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 21546 "./ESS_BIFROST_shielding.c"
  mctc1 = coords_neg(mcposaOrigin);
  mcposrOrigin = rot_apply(mcrotaOrigin, mctc1);
  mcDEBUG_COMPONENT("Origin", mcposaOrigin, mcrotaOrigin)
  mccomp_posa[1] = mcposaOrigin;
  mccomp_posr[1] = mcposrOrigin;
  mcNCounter[1]  = mcPCounter[1] = mcP2Counter[1] = 0;
  mcAbsorbProp[1]= 0;
    /* Component ESS_source. */
  /* Setting parameters for component ESS_source. */
  SIG_MESSAGE("ESS_source (Init:SetPar)");
#line 753 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("W") strncpy(mccESS_source_sector, "W" ? "W" : "", 16384); else mccESS_source_sector[0]='\0';
#line 749 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccESS_source_beamline = 4;
#line 749 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccESS_source_yheight = 0.030000;
#line 753 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccESS_source_cold_frac = 0.500000;
#line 108 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccESS_source_target_index = 0;
#line 750 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccESS_source_dist = 1.903398;
#line 751 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccESS_source_focus_xw = 0.068797 + 2 * 0.01277;
#line 752 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccESS_source_focus_yh = 0.03472;
#line 754 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccESS_source_c_performance = 1.0;
#line 754 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccESS_source_t_performance = 1.0;
#line 753 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccESS_source_Lmin = mcipWaveMin;
#line 753 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccESS_source_Lmax = mcipWaveMax;
#line 754 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccESS_source_tmax_multiplier = 1.500000;
#line 754 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccESS_source_n_pulses = mcipNpulse;
#line 753 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccESS_source_acc_power = mcippower;
#line 109 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccESS_source_tfocus_dist = 0;
#line 109 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccESS_source_tfocus_time = 0;
#line 109 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccESS_source_tfocus_width = 0;
#line 21593 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("ESS_source (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 756 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 756 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 756 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 21603 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaOrigin, mcrotaESS_source);
  rot_transpose(mcrotaOrigin, mctr1);
  rot_mul(mcrotaESS_source, mctr1, mcrotrESS_source);
  mctc1 = coords_set(
#line 755 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 755 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 755 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 21614 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaOrigin, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaESS_source = coords_add(mcposaOrigin, mctc2);
  mctc1 = coords_sub(mcposaOrigin, mcposaESS_source);
  mcposrESS_source = rot_apply(mcrotaESS_source, mctc1);
  mcDEBUG_COMPONENT("ESS_source", mcposaESS_source, mcrotaESS_source)
  mccomp_posa[2] = mcposaESS_source;
  mccomp_posr[2] = mcposrESS_source;
  mcNCounter[2]  = mcPCounter[2] = mcP2Counter[2] = 0;
  mcAbsorbProp[2]= 0;
    /* Component StartOfGuide. */
  /* Setting parameters for component StartOfGuide. */
  SIG_MESSAGE("StartOfGuide (Init:SetPar)");

  SIG_MESSAGE("StartOfGuide (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 762 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 762 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (-0.56)*DEG2RAD,
#line 762 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 21637 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaOrigin, mcrotaStartOfGuide);
  rot_transpose(mcrotaESS_source, mctr1);
  rot_mul(mcrotaStartOfGuide, mctr1, mcrotrStartOfGuide);
  mctc1 = coords_set(
#line 761 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.01277,
#line 761 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.000000,
#line 761 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    1.903398 - u);
#line 21648 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaOrigin, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaStartOfGuide = coords_add(mcposaOrigin, mctc2);
  mctc1 = coords_sub(mcposaESS_source, mcposaStartOfGuide);
  mcposrStartOfGuide = rot_apply(mcrotaStartOfGuide, mctc1);
  mcDEBUG_COMPONENT("StartOfGuide", mcposaStartOfGuide, mcrotaStartOfGuide)
  mccomp_posa[3] = mcposaStartOfGuide;
  mccomp_posr[3] = mcposrStartOfGuide;
  mcNCounter[3]  = mcPCounter[3] = mcP2Counter[3] = 0;
  mcAbsorbProp[3]= 0;
    /* Component NBOA. */
  /* Setting parameters for component NBOA. */
  SIG_MESSAGE("NBOA (Init:SetPar)");
#line 765 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_l = 4.39553;
#line 766 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_xwidth = 0.069634;
#line 766 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_yheight = 0.04862;
#line 765 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_linxw = 3.4578;
#line 765 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_loutxw = 0.415155;
#line 765 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_linyh = 1.36;
#line 765 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_loutyh = 3.487681;
#line 171 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_majorAxisxw = 0;
#line 171 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_minorAxisxw = 0;
#line 172 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_majorAxisyh = 0;
#line 172 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_minorAxisyh = 0;
#line 173 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_majorAxisoffsetxw = 0;
#line 174 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_majorAxisoffsetyh = 0;
#line 766 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("mid") strncpy(mccNBOA_dimensionsAt, "mid" ? "mid" : "", 16384); else mccNBOA_dimensionsAt[0]='\0';
#line 176 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("ellipse") strncpy(mccNBOA_option, "ellipse" ? "ellipse" : "", 16384); else mccNBOA_option[0]='\0';
#line 767 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_R0 = 0.990000;
#line 767 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_Qc = 0.021700;
#line 767 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_alpha = 3.100000;
#line 177 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_m = 2;
#line 767 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_W = 0.003000;
#line 178 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_alpharight = -1;
#line 178 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_mright = -1;
#line 179 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_alphaleft = -1;
#line 179 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_mleft = -1;
#line 180 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_alphatop = -1;
#line 180 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_mtop = -1;
#line 181 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_alphabottom = -1;
#line 181 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_mbottom = -1;
#line 182 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("on") strncpy(mccNBOA_verbose, "on" ? "on" : "", 16384); else mccNBOA_verbose[0]='\0';
#line 183 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_enableGravity = 1.0;
#line 184 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccNBOA_curvature = 0;
#line 21724 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("NBOA (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 21731 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaStartOfGuide, mcrotaNBOA);
  rot_transpose(mcrotaStartOfGuide, mctr1);
  rot_mul(mcrotaNBOA, mctr1, mcrotrNBOA);
  mctc1 = coords_set(
#line 768 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 768 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 768 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    u);
#line 21742 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaStartOfGuide, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaNBOA = coords_add(mcposaStartOfGuide, mctc2);
  mctc1 = coords_sub(mcposaStartOfGuide, mcposaNBOA);
  mcposrNBOA = rot_apply(mcrotaNBOA, mctc1);
  mcDEBUG_COMPONENT("NBOA", mcposaNBOA, mcrotaNBOA)
  mccomp_posa[4] = mcposaNBOA;
  mccomp_posr[4] = mcposrNBOA;
  mcNCounter[4]  = mcPCounter[4] = mcP2Counter[4] = 0;
  mcAbsorbProp[4]= 0;
    /* Component EndOfelement_6. */
  /* Setting parameters for component EndOfelement_6. */
  SIG_MESSAGE("EndOfelement_6 (Init:SetPar)");

  SIG_MESSAGE("EndOfelement_6 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 21762 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaNBOA, mcrotaEndOfelement_6);
  rot_transpose(mcrotaNBOA, mctr1);
  rot_mul(mcrotaEndOfelement_6, mctr1, mcrotrEndOfelement_6);
  mctc1 = coords_set(
#line 772 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 772 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 772 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    4.39553 + 2 * u);
#line 21773 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaNBOA, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaEndOfelement_6 = coords_add(mcposaNBOA, mctc2);
  mctc1 = coords_sub(mcposaNBOA, mcposaEndOfelement_6);
  mcposrEndOfelement_6 = rot_apply(mcrotaEndOfelement_6, mctc1);
  mcDEBUG_COMPONENT("EndOfelement_6", mcposaEndOfelement_6, mcrotaEndOfelement_6)
  mccomp_posa[5] = mcposaEndOfelement_6;
  mccomp_posr[5] = mcposrEndOfelement_6;
  mcNCounter[5]  = mcPCounter[5] = mcP2Counter[5] = 0;
  mcAbsorbProp[5]= 0;
    /* Component EndOfelement_5. */
  /* Setting parameters for component EndOfelement_5. */
  SIG_MESSAGE("EndOfelement_5 (Init:SetPar)");

  SIG_MESSAGE("EndOfelement_5 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 21793 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaEndOfelement_6, mcrotaEndOfelement_5);
  rot_transpose(mcrotaEndOfelement_6, mctr1);
  rot_mul(mcrotaEndOfelement_5, mctr1, mcrotrEndOfelement_5);
  mctc1 = coords_set(
#line 858 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 858 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 858 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.081707);
#line 21804 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaEndOfelement_6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaEndOfelement_5 = coords_add(mcposaEndOfelement_6, mctc2);
  mctc1 = coords_sub(mcposaEndOfelement_6, mcposaEndOfelement_5);
  mcposrEndOfelement_5 = rot_apply(mcrotaEndOfelement_5, mctc1);
  mcDEBUG_COMPONENT("EndOfelement_5", mcposaEndOfelement_5, mcrotaEndOfelement_5)
  mccomp_posa[6] = mcposaEndOfelement_5;
  mccomp_posr[6] = mcposrEndOfelement_5;
  mcNCounter[6]  = mcPCounter[6] = mcP2Counter[6] = 0;
  mcAbsorbProp[6]= 0;
    /* Component curved_guide_1_0. */
  /* Setting parameters for component curved_guide_1_0. */
  SIG_MESSAGE("curved_guide_1_0 (Init:SetPar)");
#line 868 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_w1 = 0.029534;
#line 869 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_h1 = 0.047514;
#line 868 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_w2 = 0.029534;
#line 869 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_h2 = 0.047514;
#line 867 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_l = 0.5;
#line 870 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_R0 = 0.990000;
#line 870 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_Qc = 0.021700;
#line 871 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_m = 1.0;
#line 871 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_d = 0.0005;
#line 872 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_mleft = 3.000000;
#line 872 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_mright = 3.500000;
#line 873 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_mtop = 2.500000;
#line 873 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_nhslit = 1;
#line 867 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_1_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_1_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_1_0_reflect[0]='\0';
#line 21886 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_1_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 875 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 875 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 875 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 21896 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaEndOfelement_5, mcrotacurved_guide_1_0);
  rot_transpose(mcrotaEndOfelement_5, mctr1);
  rot_mul(mcrotacurved_guide_1_0, mctr1, mcrotrcurved_guide_1_0);
  mctc1 = coords_set(
#line 874 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 874 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 874 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    u);
#line 21907 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaEndOfelement_5, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_1_0 = coords_add(mcposaEndOfelement_5, mctc2);
  mctc1 = coords_sub(mcposaEndOfelement_5, mcposacurved_guide_1_0);
  mcposrcurved_guide_1_0 = rot_apply(mcrotacurved_guide_1_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_1_0", mcposacurved_guide_1_0, mcrotacurved_guide_1_0)
  mccomp_posa[7] = mcposacurved_guide_1_0;
  mccomp_posr[7] = mcposrcurved_guide_1_0;
  mcNCounter[7]  = mcPCounter[7] = mcP2Counter[7] = 0;
  mcAbsorbProp[7]= 0;
    /* Component curved_guide_2_0. */
  /* Setting parameters for component curved_guide_2_0. */
  SIG_MESSAGE("curved_guide_2_0 (Init:SetPar)");
#line 879 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_w1 = 0.029534;
#line 880 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_h1 = 0.047514;
#line 879 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_w2 = 0.029534;
#line 880 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_h2 = 0.047514;
#line 878 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_l = 0.5;
#line 881 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_R0 = 0.990000;
#line 881 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_Qc = 0.021700;
#line 882 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_m = 1.0;
#line 882 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_d = 0.0005;
#line 883 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_mleft = 3.000000;
#line 883 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_mright = 3.500000;
#line 884 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_mtop = 2.500000;
#line 884 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_nhslit = 1;
#line 878 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_2_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_2_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_2_0_reflect[0]='\0';
#line 21989 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_2_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 886 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 886 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 886 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 21999 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_1_0, mcrotacurved_guide_2_0);
  rot_transpose(mcrotacurved_guide_1_0, mctr1);
  rot_mul(mcrotacurved_guide_2_0, mctr1, mcrotrcurved_guide_2_0);
  mctc1 = coords_set(
#line 885 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 885 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 885 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 22010 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_1_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_2_0 = coords_add(mcposacurved_guide_1_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_1_0, mcposacurved_guide_2_0);
  mcposrcurved_guide_2_0 = rot_apply(mcrotacurved_guide_2_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_2_0", mcposacurved_guide_2_0, mcrotacurved_guide_2_0)
  mccomp_posa[8] = mcposacurved_guide_2_0;
  mccomp_posr[8] = mcposrcurved_guide_2_0;
  mcNCounter[8]  = mcPCounter[8] = mcP2Counter[8] = 0;
  mcAbsorbProp[8]= 0;
    /* Component curved_guide_3_0. */
  /* Setting parameters for component curved_guide_3_0. */
  SIG_MESSAGE("curved_guide_3_0 (Init:SetPar)");
#line 890 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_w1 = 0.029534;
#line 891 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_h1 = 0.047514;
#line 890 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_w2 = 0.029534;
#line 891 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_h2 = 0.047514;
#line 889 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_l = 0.5;
#line 892 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_R0 = 0.990000;
#line 892 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_Qc = 0.021700;
#line 893 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_m = 1.0;
#line 893 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_d = 0.0005;
#line 894 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_mleft = 3.000000;
#line 894 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_mright = 3.500000;
#line 895 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_mtop = 2.500000;
#line 895 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_nhslit = 1;
#line 889 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_3_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_3_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_3_0_reflect[0]='\0';
#line 22092 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_3_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 897 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 897 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 897 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 22102 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_2_0, mcrotacurved_guide_3_0);
  rot_transpose(mcrotacurved_guide_2_0, mctr1);
  rot_mul(mcrotacurved_guide_3_0, mctr1, mcrotrcurved_guide_3_0);
  mctc1 = coords_set(
#line 896 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 896 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 896 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 22113 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_2_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_3_0 = coords_add(mcposacurved_guide_2_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_2_0, mcposacurved_guide_3_0);
  mcposrcurved_guide_3_0 = rot_apply(mcrotacurved_guide_3_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_3_0", mcposacurved_guide_3_0, mcrotacurved_guide_3_0)
  mccomp_posa[9] = mcposacurved_guide_3_0;
  mccomp_posr[9] = mcposrcurved_guide_3_0;
  mcNCounter[9]  = mcPCounter[9] = mcP2Counter[9] = 0;
  mcAbsorbProp[9]= 0;
    /* Component curved_guide_4_0. */
  /* Setting parameters for component curved_guide_4_0. */
  SIG_MESSAGE("curved_guide_4_0 (Init:SetPar)");
#line 902 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_w1 = 0.029534;
#line 903 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_h1 = 0.047514;
#line 902 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_w2 = 0.029534;
#line 903 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_h2 = 0.047514;
#line 901 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_l = 0.5;
#line 904 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_R0 = 0.990000;
#line 904 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_Qc = 0.021700;
#line 905 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_m = 1.0;
#line 905 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_d = 0.0005;
#line 906 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_mleft = 3.000000;
#line 906 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_mright = 3.500000;
#line 907 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_mtop = 2.500000;
#line 907 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_nhslit = 1;
#line 901 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_4_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_4_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_4_0_reflect[0]='\0';
#line 22195 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_4_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 909 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 909 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 909 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 22205 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_3_0, mcrotacurved_guide_4_0);
  rot_transpose(mcrotacurved_guide_3_0, mctr1);
  rot_mul(mcrotacurved_guide_4_0, mctr1, mcrotrcurved_guide_4_0);
  mctc1 = coords_set(
#line 908 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 908 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 908 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 22216 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_3_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_4_0 = coords_add(mcposacurved_guide_3_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_3_0, mcposacurved_guide_4_0);
  mcposrcurved_guide_4_0 = rot_apply(mcrotacurved_guide_4_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_4_0", mcposacurved_guide_4_0, mcrotacurved_guide_4_0)
  mccomp_posa[10] = mcposacurved_guide_4_0;
  mccomp_posr[10] = mcposrcurved_guide_4_0;
  mcNCounter[10]  = mcPCounter[10] = mcP2Counter[10] = 0;
  mcAbsorbProp[10]= 0;
    /* Component curved_guide_5_beforeChopper. */
  /* Setting parameters for component curved_guide_5_beforeChopper. */
  SIG_MESSAGE("curved_guide_5_beforeChopper (Init:SetPar)");
#line 918 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_w1 = 0.029534;
#line 919 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_h1 = 0.047514;
#line 918 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_w2 = 0.029534;
#line 919 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_h2 = 0.047514;
#line 917 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_l = 0.13;
#line 920 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_R0 = 0.990000;
#line 920 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_Qc = 0.021700;
#line 921 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_m = 1.0;
#line 921 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_d = 0.0005;
#line 922 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_mleft = 3.000000;
#line 922 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_mright = 3.500000;
#line 923 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_mtop = 2.500000;
#line 923 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_nhslit = 1;
#line 917 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_beforeChopper_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_5_beforeChopper_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_5_beforeChopper_reflect[0]='\0';
#line 22298 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_5_beforeChopper (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 925 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 925 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 925 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 22308 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_4_0, mcrotacurved_guide_5_beforeChopper);
  rot_transpose(mcrotacurved_guide_4_0, mctr1);
  rot_mul(mcrotacurved_guide_5_beforeChopper, mctr1, mcrotrcurved_guide_5_beforeChopper);
  mctc1 = coords_set(
#line 924 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 924 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 924 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 22319 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_4_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_5_beforeChopper = coords_add(mcposacurved_guide_4_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_4_0, mcposacurved_guide_5_beforeChopper);
  mcposrcurved_guide_5_beforeChopper = rot_apply(mcrotacurved_guide_5_beforeChopper, mctc1);
  mcDEBUG_COMPONENT("curved_guide_5_beforeChopper", mcposacurved_guide_5_beforeChopper, mcrotacurved_guide_5_beforeChopper)
  mccomp_posa[11] = mcposacurved_guide_5_beforeChopper;
  mccomp_posr[11] = mcposrcurved_guide_5_beforeChopper;
  mcNCounter[11]  = mcPCounter[11] = mcP2Counter[11] = 0;
  mcAbsorbProp[11]= 0;
    /* Component curved_guide_5_afterChopper. */
  /* Setting parameters for component curved_guide_5_afterChopper. */
  SIG_MESSAGE("curved_guide_5_afterChopper (Init:SetPar)");
#line 987 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_w1 = 0.029534;
#line 988 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_h1 = 0.047514;
#line 987 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_w2 = 0.029534;
#line 988 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_h2 = 0.047514;
#line 986 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_l = 0.33;
#line 989 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_R0 = 0.990000;
#line 989 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_Qc = 0.021700;
#line 990 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_m = 1.0;
#line 990 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_d = 0.0005;
#line 991 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_mleft = 3.000000;
#line 991 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_mright = 3.500000;
#line 992 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_mtop = 2.500000;
#line 992 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_nhslit = 1;
#line 986 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_5_afterChopper_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_5_afterChopper_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_5_afterChopper_reflect[0]='\0';
#line 22401 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_5_afterChopper (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 994 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 994 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 994 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 22411 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_5_beforeChopper, mcrotacurved_guide_5_afterChopper);
  rot_transpose(mcrotacurved_guide_5_beforeChopper, mctr1);
  rot_mul(mcrotacurved_guide_5_afterChopper, mctr1, mcrotrcurved_guide_5_afterChopper);
  mctc1 = coords_set(
#line 993 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 993 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 993 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.17);
#line 22422 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_5_beforeChopper, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_5_afterChopper = coords_add(mcposacurved_guide_5_beforeChopper, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_5_beforeChopper, mcposacurved_guide_5_afterChopper);
  mcposrcurved_guide_5_afterChopper = rot_apply(mcrotacurved_guide_5_afterChopper, mctc1);
  mcDEBUG_COMPONENT("curved_guide_5_afterChopper", mcposacurved_guide_5_afterChopper, mcrotacurved_guide_5_afterChopper)
  mccomp_posa[12] = mcposacurved_guide_5_afterChopper;
  mccomp_posr[12] = mcposrcurved_guide_5_afterChopper;
  mcNCounter[12]  = mcPCounter[12] = mcP2Counter[12] = 0;
  mcAbsorbProp[12]= 0;
    /* Component curved_guide_6_0. */
  /* Setting parameters for component curved_guide_6_0. */
  SIG_MESSAGE("curved_guide_6_0 (Init:SetPar)");
#line 998 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_w1 = 0.029534;
#line 999 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_h1 = 0.047514;
#line 998 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_w2 = 0.029534;
#line 999 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_h2 = 0.047514;
#line 997 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_l = 0.5;
#line 1000 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_R0 = 0.990000;
#line 1000 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_Qc = 0.021700;
#line 1001 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_m = 1.0;
#line 1001 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_d = 0.0005;
#line 1002 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_mleft = 3.000000;
#line 1002 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_mright = 3.500000;
#line 1003 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_mtop = 2.500000;
#line 1003 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_nhslit = 1;
#line 997 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_6_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_6_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_6_0_reflect[0]='\0';
#line 22504 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_6_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1005 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1005 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1005 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 22514 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_5_afterChopper, mcrotacurved_guide_6_0);
  rot_transpose(mcrotacurved_guide_5_afterChopper, mctr1);
  rot_mul(mcrotacurved_guide_6_0, mctr1, mcrotrcurved_guide_6_0);
  mctc1 = coords_set(
#line 1004 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1004 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1004 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.33 + u);
#line 22525 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_5_afterChopper, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_6_0 = coords_add(mcposacurved_guide_5_afterChopper, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_5_afterChopper, mcposacurved_guide_6_0);
  mcposrcurved_guide_6_0 = rot_apply(mcrotacurved_guide_6_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_6_0", mcposacurved_guide_6_0, mcrotacurved_guide_6_0)
  mccomp_posa[13] = mcposacurved_guide_6_0;
  mccomp_posr[13] = mcposrcurved_guide_6_0;
  mcNCounter[13]  = mcPCounter[13] = mcP2Counter[13] = 0;
  mcAbsorbProp[13]= 0;
    /* Component curved_guide_7_0. */
  /* Setting parameters for component curved_guide_7_0. */
  SIG_MESSAGE("curved_guide_7_0 (Init:SetPar)");
#line 1009 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_w1 = 0.029534;
#line 1010 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_h1 = 0.047514;
#line 1009 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_w2 = 0.029534;
#line 1010 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_h2 = 0.047514;
#line 1008 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_l = 0.5;
#line 1011 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_R0 = 0.990000;
#line 1011 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_Qc = 0.021700;
#line 1012 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_m = 1.0;
#line 1012 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_d = 0.0005;
#line 1013 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_mleft = 3.000000;
#line 1013 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_mright = 3.500000;
#line 1014 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_mtop = 2.500000;
#line 1014 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_nhslit = 1;
#line 1008 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_7_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_7_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_7_0_reflect[0]='\0';
#line 22607 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_7_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1016 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1016 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1016 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 22617 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_6_0, mcrotacurved_guide_7_0);
  rot_transpose(mcrotacurved_guide_6_0, mctr1);
  rot_mul(mcrotacurved_guide_7_0, mctr1, mcrotrcurved_guide_7_0);
  mctc1 = coords_set(
#line 1015 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1015 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1015 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 22628 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_6_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_7_0 = coords_add(mcposacurved_guide_6_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_6_0, mcposacurved_guide_7_0);
  mcposrcurved_guide_7_0 = rot_apply(mcrotacurved_guide_7_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_7_0", mcposacurved_guide_7_0, mcrotacurved_guide_7_0)
  mccomp_posa[14] = mcposacurved_guide_7_0;
  mccomp_posr[14] = mcposrcurved_guide_7_0;
  mcNCounter[14]  = mcPCounter[14] = mcP2Counter[14] = 0;
  mcAbsorbProp[14]= 0;
    /* Component curved_guide_8_0. */
  /* Setting parameters for component curved_guide_8_0. */
  SIG_MESSAGE("curved_guide_8_0 (Init:SetPar)");
#line 1020 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_w1 = 0.029534;
#line 1021 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_h1 = 0.047514;
#line 1020 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_w2 = 0.029534;
#line 1021 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_h2 = 0.047514;
#line 1019 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_l = 0.5;
#line 1022 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_R0 = 0.990000;
#line 1022 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_Qc = 0.021700;
#line 1023 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_m = 1.0;
#line 1023 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_d = 0.0005;
#line 1024 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_mleft = 3.000000;
#line 1024 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_mright = 3.500000;
#line 1025 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_mtop = 2.500000;
#line 1025 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_nhslit = 1;
#line 1019 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_8_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_8_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_8_0_reflect[0]='\0';
#line 22710 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_8_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1027 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1027 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1027 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 22720 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_7_0, mcrotacurved_guide_8_0);
  rot_transpose(mcrotacurved_guide_7_0, mctr1);
  rot_mul(mcrotacurved_guide_8_0, mctr1, mcrotrcurved_guide_8_0);
  mctc1 = coords_set(
#line 1026 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1026 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1026 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 22731 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_7_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_8_0 = coords_add(mcposacurved_guide_7_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_7_0, mcposacurved_guide_8_0);
  mcposrcurved_guide_8_0 = rot_apply(mcrotacurved_guide_8_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_8_0", mcposacurved_guide_8_0, mcrotacurved_guide_8_0)
  mccomp_posa[15] = mcposacurved_guide_8_0;
  mccomp_posr[15] = mcposrcurved_guide_8_0;
  mcNCounter[15]  = mcPCounter[15] = mcP2Counter[15] = 0;
  mcAbsorbProp[15]= 0;
    /* Component curved_guide_9_0. */
  /* Setting parameters for component curved_guide_9_0. */
  SIG_MESSAGE("curved_guide_9_0 (Init:SetPar)");
#line 1031 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_w1 = 0.029534;
#line 1032 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_h1 = 0.047514;
#line 1031 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_w2 = 0.029534;
#line 1032 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_h2 = 0.047514;
#line 1030 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_l = 0.5;
#line 1033 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_R0 = 0.990000;
#line 1033 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_Qc = 0.021700;
#line 1034 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_m = 1.0;
#line 1034 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_d = 0.0005;
#line 1035 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_mleft = 3.000000;
#line 1035 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_mright = 3.500000;
#line 1036 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_mtop = 2.500000;
#line 1036 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_nhslit = 1;
#line 1030 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_9_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_9_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_9_0_reflect[0]='\0';
#line 22813 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_9_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1038 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1038 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1038 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 22823 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_8_0, mcrotacurved_guide_9_0);
  rot_transpose(mcrotacurved_guide_8_0, mctr1);
  rot_mul(mcrotacurved_guide_9_0, mctr1, mcrotrcurved_guide_9_0);
  mctc1 = coords_set(
#line 1037 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1037 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1037 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 22834 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_8_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_9_0 = coords_add(mcposacurved_guide_8_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_8_0, mcposacurved_guide_9_0);
  mcposrcurved_guide_9_0 = rot_apply(mcrotacurved_guide_9_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_9_0", mcposacurved_guide_9_0, mcrotacurved_guide_9_0)
  mccomp_posa[16] = mcposacurved_guide_9_0;
  mccomp_posr[16] = mcposrcurved_guide_9_0;
  mcNCounter[16]  = mcPCounter[16] = mcP2Counter[16] = 0;
  mcAbsorbProp[16]= 0;
    /* Component curved_guide_10_0. */
  /* Setting parameters for component curved_guide_10_0. */
  SIG_MESSAGE("curved_guide_10_0 (Init:SetPar)");
#line 1042 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_w1 = 0.029534;
#line 1043 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_h1 = 0.047514;
#line 1042 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_w2 = 0.029534;
#line 1043 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_h2 = 0.047514;
#line 1041 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_l = 0.5;
#line 1044 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_R0 = 0.990000;
#line 1044 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_Qc = 0.021700;
#line 1045 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_m = 1.0;
#line 1045 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_d = 0.0005;
#line 1046 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_mleft = 3.000000;
#line 1046 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_mright = 3.500000;
#line 1047 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_mtop = 2.500000;
#line 1047 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_nhslit = 1;
#line 1041 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_10_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_10_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_10_0_reflect[0]='\0';
#line 22916 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_10_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1049 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1049 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1049 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 22926 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_9_0, mcrotacurved_guide_10_0);
  rot_transpose(mcrotacurved_guide_9_0, mctr1);
  rot_mul(mcrotacurved_guide_10_0, mctr1, mcrotrcurved_guide_10_0);
  mctc1 = coords_set(
#line 1048 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1048 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1048 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 22937 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_9_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_10_0 = coords_add(mcposacurved_guide_9_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_9_0, mcposacurved_guide_10_0);
  mcposrcurved_guide_10_0 = rot_apply(mcrotacurved_guide_10_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_10_0", mcposacurved_guide_10_0, mcrotacurved_guide_10_0)
  mccomp_posa[17] = mcposacurved_guide_10_0;
  mccomp_posr[17] = mcposrcurved_guide_10_0;
  mcNCounter[17]  = mcPCounter[17] = mcP2Counter[17] = 0;
  mcAbsorbProp[17]= 0;
    /* Component curved_guide_11_0. */
  /* Setting parameters for component curved_guide_11_0. */
  SIG_MESSAGE("curved_guide_11_0 (Init:SetPar)");
#line 1053 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_w1 = 0.029534;
#line 1054 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_h1 = 0.047514;
#line 1053 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_w2 = 0.029534;
#line 1054 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_h2 = 0.047514;
#line 1052 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_l = 0.5;
#line 1055 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_R0 = 0.990000;
#line 1055 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_Qc = 0.021700;
#line 1056 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_m = 1.0;
#line 1056 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_d = 0.0005;
#line 1057 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_mleft = 3.000000;
#line 1057 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_mright = 3.500000;
#line 1058 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_mtop = 2.500000;
#line 1058 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_nhslit = 1;
#line 1052 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_11_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_11_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_11_0_reflect[0]='\0';
#line 23019 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_11_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1060 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1060 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1060 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 23029 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_10_0, mcrotacurved_guide_11_0);
  rot_transpose(mcrotacurved_guide_10_0, mctr1);
  rot_mul(mcrotacurved_guide_11_0, mctr1, mcrotrcurved_guide_11_0);
  mctc1 = coords_set(
#line 1059 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1059 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1059 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 23040 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_10_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_11_0 = coords_add(mcposacurved_guide_10_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_10_0, mcposacurved_guide_11_0);
  mcposrcurved_guide_11_0 = rot_apply(mcrotacurved_guide_11_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_11_0", mcposacurved_guide_11_0, mcrotacurved_guide_11_0)
  mccomp_posa[18] = mcposacurved_guide_11_0;
  mccomp_posr[18] = mcposrcurved_guide_11_0;
  mcNCounter[18]  = mcPCounter[18] = mcP2Counter[18] = 0;
  mcAbsorbProp[18]= 0;
    /* Component curved_guide_12_0. */
  /* Setting parameters for component curved_guide_12_0. */
  SIG_MESSAGE("curved_guide_12_0 (Init:SetPar)");
#line 1064 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_w1 = 0.029534;
#line 1065 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_h1 = 0.047514;
#line 1064 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_w2 = 0.029534;
#line 1065 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_h2 = 0.047514;
#line 1063 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_l = 0.5;
#line 1066 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_R0 = 0.990000;
#line 1066 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_Qc = 0.021700;
#line 1067 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_m = 1.0;
#line 1067 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_d = 0.0005;
#line 1068 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_mleft = 3.000000;
#line 1068 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_mright = 3.500000;
#line 1069 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_mtop = 2.500000;
#line 1069 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_nhslit = 1;
#line 1063 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_12_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_12_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_12_0_reflect[0]='\0';
#line 23122 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_12_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1071 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1071 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1071 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 23132 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_11_0, mcrotacurved_guide_12_0);
  rot_transpose(mcrotacurved_guide_11_0, mctr1);
  rot_mul(mcrotacurved_guide_12_0, mctr1, mcrotrcurved_guide_12_0);
  mctc1 = coords_set(
#line 1070 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1070 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1070 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 23143 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_11_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_12_0 = coords_add(mcposacurved_guide_11_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_11_0, mcposacurved_guide_12_0);
  mcposrcurved_guide_12_0 = rot_apply(mcrotacurved_guide_12_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_12_0", mcposacurved_guide_12_0, mcrotacurved_guide_12_0)
  mccomp_posa[19] = mcposacurved_guide_12_0;
  mccomp_posr[19] = mcposrcurved_guide_12_0;
  mcNCounter[19]  = mcPCounter[19] = mcP2Counter[19] = 0;
  mcAbsorbProp[19]= 0;
    /* Component curved_guide_13_0. */
  /* Setting parameters for component curved_guide_13_0. */
  SIG_MESSAGE("curved_guide_13_0 (Init:SetPar)");
#line 1075 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_w1 = 0.029534;
#line 1076 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_h1 = 0.047514;
#line 1075 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_w2 = 0.029534;
#line 1076 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_h2 = 0.047514;
#line 1074 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_l = 0.5;
#line 1077 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_R0 = 0.990000;
#line 1077 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_Qc = 0.021700;
#line 1078 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_m = 1.0;
#line 1078 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_d = 0.0005;
#line 1079 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_mleft = 3.000000;
#line 1079 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_mright = 3.500000;
#line 1080 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_mtop = 2.500000;
#line 1080 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_nhslit = 1;
#line 1074 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_13_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_13_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_13_0_reflect[0]='\0';
#line 23225 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_13_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1082 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1082 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1082 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 23235 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_12_0, mcrotacurved_guide_13_0);
  rot_transpose(mcrotacurved_guide_12_0, mctr1);
  rot_mul(mcrotacurved_guide_13_0, mctr1, mcrotrcurved_guide_13_0);
  mctc1 = coords_set(
#line 1081 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1081 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1081 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 23246 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_12_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_13_0 = coords_add(mcposacurved_guide_12_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_12_0, mcposacurved_guide_13_0);
  mcposrcurved_guide_13_0 = rot_apply(mcrotacurved_guide_13_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_13_0", mcposacurved_guide_13_0, mcrotacurved_guide_13_0)
  mccomp_posa[20] = mcposacurved_guide_13_0;
  mccomp_posr[20] = mcposrcurved_guide_13_0;
  mcNCounter[20]  = mcPCounter[20] = mcP2Counter[20] = 0;
  mcAbsorbProp[20]= 0;
    /* Component curved_guide_14_0. */
  /* Setting parameters for component curved_guide_14_0. */
  SIG_MESSAGE("curved_guide_14_0 (Init:SetPar)");
#line 1086 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_w1 = 0.029534;
#line 1087 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_h1 = 0.047514;
#line 1086 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_w2 = 0.029534;
#line 1087 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_h2 = 0.047514;
#line 1085 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_l = 0.5;
#line 1088 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_R0 = 0.990000;
#line 1088 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_Qc = 0.021700;
#line 1089 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_m = 1.0;
#line 1089 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_d = 0.0005;
#line 1090 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_mleft = 3.000000;
#line 1090 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_mright = 3.500000;
#line 1091 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_mtop = 2.500000;
#line 1091 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_nhslit = 1;
#line 1085 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_14_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_14_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_14_0_reflect[0]='\0';
#line 23328 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_14_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1093 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1093 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1093 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 23338 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_13_0, mcrotacurved_guide_14_0);
  rot_transpose(mcrotacurved_guide_13_0, mctr1);
  rot_mul(mcrotacurved_guide_14_0, mctr1, mcrotrcurved_guide_14_0);
  mctc1 = coords_set(
#line 1092 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1092 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1092 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 23349 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_13_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_14_0 = coords_add(mcposacurved_guide_13_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_13_0, mcposacurved_guide_14_0);
  mcposrcurved_guide_14_0 = rot_apply(mcrotacurved_guide_14_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_14_0", mcposacurved_guide_14_0, mcrotacurved_guide_14_0)
  mccomp_posa[21] = mcposacurved_guide_14_0;
  mccomp_posr[21] = mcposrcurved_guide_14_0;
  mcNCounter[21]  = mcPCounter[21] = mcP2Counter[21] = 0;
  mcAbsorbProp[21]= 0;
    /* Component curved_guide_15_0. */
  /* Setting parameters for component curved_guide_15_0. */
  SIG_MESSAGE("curved_guide_15_0 (Init:SetPar)");
#line 1097 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_w1 = 0.029534;
#line 1098 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_h1 = 0.047514;
#line 1097 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_w2 = 0.029534;
#line 1098 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_h2 = 0.047514;
#line 1096 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_l = 0.5;
#line 1099 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_R0 = 0.990000;
#line 1099 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_Qc = 0.021700;
#line 1100 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_m = 1.0;
#line 1100 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_d = 0.0005;
#line 1101 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_mleft = 3.000000;
#line 1101 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_mright = 3.500000;
#line 1102 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_mtop = 2.500000;
#line 1102 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_nhslit = 1;
#line 1096 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_15_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_15_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_15_0_reflect[0]='\0';
#line 23431 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_15_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1104 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1104 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1104 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 23441 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_14_0, mcrotacurved_guide_15_0);
  rot_transpose(mcrotacurved_guide_14_0, mctr1);
  rot_mul(mcrotacurved_guide_15_0, mctr1, mcrotrcurved_guide_15_0);
  mctc1 = coords_set(
#line 1103 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1103 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1103 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 23452 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_14_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_15_0 = coords_add(mcposacurved_guide_14_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_14_0, mcposacurved_guide_15_0);
  mcposrcurved_guide_15_0 = rot_apply(mcrotacurved_guide_15_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_15_0", mcposacurved_guide_15_0, mcrotacurved_guide_15_0)
  mccomp_posa[22] = mcposacurved_guide_15_0;
  mccomp_posr[22] = mcposrcurved_guide_15_0;
  mcNCounter[22]  = mcPCounter[22] = mcP2Counter[22] = 0;
  mcAbsorbProp[22]= 0;
    /* Component curved_guide_16_0. */
  /* Setting parameters for component curved_guide_16_0. */
  SIG_MESSAGE("curved_guide_16_0 (Init:SetPar)");
#line 1108 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_w1 = 0.029534;
#line 1109 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_h1 = 0.047514;
#line 1108 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_w2 = 0.029534;
#line 1109 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_h2 = 0.047514;
#line 1107 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_l = 0.5;
#line 1110 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_R0 = 0.990000;
#line 1110 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_Qc = 0.021700;
#line 1111 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_m = 1.0;
#line 1111 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_d = 0.0005;
#line 1112 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_mleft = 3.000000;
#line 1112 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_mright = 3.500000;
#line 1113 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_mtop = 2.500000;
#line 1113 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_nhslit = 1;
#line 1107 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_16_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_16_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_16_0_reflect[0]='\0';
#line 23534 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_16_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1115 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1115 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1115 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 23544 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_15_0, mcrotacurved_guide_16_0);
  rot_transpose(mcrotacurved_guide_15_0, mctr1);
  rot_mul(mcrotacurved_guide_16_0, mctr1, mcrotrcurved_guide_16_0);
  mctc1 = coords_set(
#line 1114 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1114 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1114 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 23555 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_15_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_16_0 = coords_add(mcposacurved_guide_15_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_15_0, mcposacurved_guide_16_0);
  mcposrcurved_guide_16_0 = rot_apply(mcrotacurved_guide_16_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_16_0", mcposacurved_guide_16_0, mcrotacurved_guide_16_0)
  mccomp_posa[23] = mcposacurved_guide_16_0;
  mccomp_posr[23] = mcposrcurved_guide_16_0;
  mcNCounter[23]  = mcPCounter[23] = mcP2Counter[23] = 0;
  mcAbsorbProp[23]= 0;
    /* Component curved_guide_17_0. */
  /* Setting parameters for component curved_guide_17_0. */
  SIG_MESSAGE("curved_guide_17_0 (Init:SetPar)");
#line 1119 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_w1 = 0.029534;
#line 1120 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_h1 = 0.047514;
#line 1119 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_w2 = 0.029534;
#line 1120 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_h2 = 0.047514;
#line 1118 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_l = 0.5;
#line 1121 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_R0 = 0.990000;
#line 1121 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_Qc = 0.021700;
#line 1122 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_m = 1.0;
#line 1122 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_d = 0.0005;
#line 1123 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_mleft = 3.000000;
#line 1123 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_mright = 3.500000;
#line 1124 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_mtop = 2.500000;
#line 1124 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_nhslit = 1;
#line 1118 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_17_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_17_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_17_0_reflect[0]='\0';
#line 23637 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_17_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1126 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1126 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1126 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 23647 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_16_0, mcrotacurved_guide_17_0);
  rot_transpose(mcrotacurved_guide_16_0, mctr1);
  rot_mul(mcrotacurved_guide_17_0, mctr1, mcrotrcurved_guide_17_0);
  mctc1 = coords_set(
#line 1125 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1125 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1125 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 23658 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_16_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_17_0 = coords_add(mcposacurved_guide_16_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_16_0, mcposacurved_guide_17_0);
  mcposrcurved_guide_17_0 = rot_apply(mcrotacurved_guide_17_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_17_0", mcposacurved_guide_17_0, mcrotacurved_guide_17_0)
  mccomp_posa[24] = mcposacurved_guide_17_0;
  mccomp_posr[24] = mcposrcurved_guide_17_0;
  mcNCounter[24]  = mcPCounter[24] = mcP2Counter[24] = 0;
  mcAbsorbProp[24]= 0;
    /* Component curved_guide_18_beforeChopper. */
  /* Setting parameters for component curved_guide_18_beforeChopper. */
  SIG_MESSAGE("curved_guide_18_beforeChopper (Init:SetPar)");
#line 1135 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_w1 = 0.029534;
#line 1136 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_h1 = 0.047514;
#line 1135 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_w2 = 0.029534;
#line 1136 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_h2 = 0.047514;
#line 1134 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_l = 0.07;
#line 1137 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_R0 = 0.990000;
#line 1137 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_Qc = 0.021700;
#line 1138 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_m = 1.0;
#line 1138 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_d = 0.0005;
#line 1139 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_mleft = 3.000000;
#line 1139 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_mright = 3.500000;
#line 1140 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_mtop = 2.500000;
#line 1140 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_nhslit = 1;
#line 1134 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_beforeChopper_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_18_beforeChopper_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_18_beforeChopper_reflect[0]='\0';
#line 23740 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_18_beforeChopper (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1142 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1142 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1142 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 23750 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_17_0, mcrotacurved_guide_18_beforeChopper);
  rot_transpose(mcrotacurved_guide_17_0, mctr1);
  rot_mul(mcrotacurved_guide_18_beforeChopper, mctr1, mcrotrcurved_guide_18_beforeChopper);
  mctc1 = coords_set(
#line 1141 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1141 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1141 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 23761 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_17_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_18_beforeChopper = coords_add(mcposacurved_guide_17_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_17_0, mcposacurved_guide_18_beforeChopper);
  mcposrcurved_guide_18_beforeChopper = rot_apply(mcrotacurved_guide_18_beforeChopper, mctc1);
  mcDEBUG_COMPONENT("curved_guide_18_beforeChopper", mcposacurved_guide_18_beforeChopper, mcrotacurved_guide_18_beforeChopper)
  mccomp_posa[25] = mcposacurved_guide_18_beforeChopper;
  mccomp_posr[25] = mcposrcurved_guide_18_beforeChopper;
  mcNCounter[25]  = mcPCounter[25] = mcP2Counter[25] = 0;
  mcAbsorbProp[25]= 0;
    /* Component curved_guide_18_afterChopper. */
  /* Setting parameters for component curved_guide_18_afterChopper. */
  SIG_MESSAGE("curved_guide_18_afterChopper (Init:SetPar)");
#line 1194 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_w1 = 0.029534;
#line 1195 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_h1 = 0.047514;
#line 1194 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_w2 = 0.029534;
#line 1195 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_h2 = 0.047514;
#line 1193 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_l = 0.39;
#line 1196 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_R0 = 0.990000;
#line 1196 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_Qc = 0.021700;
#line 1197 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_m = 1.0;
#line 1197 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_d = 0.0005;
#line 1198 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_mleft = 3.000000;
#line 1198 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_mright = 3.500000;
#line 1199 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_mtop = 2.500000;
#line 1199 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_nhslit = 1;
#line 1193 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_18_afterChopper_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_18_afterChopper_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_18_afterChopper_reflect[0]='\0';
#line 23843 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_18_afterChopper (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1201 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1201 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1201 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 23853 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_18_beforeChopper, mcrotacurved_guide_18_afterChopper);
  rot_transpose(mcrotacurved_guide_18_beforeChopper, mctr1);
  rot_mul(mcrotacurved_guide_18_afterChopper, mctr1, mcrotrcurved_guide_18_afterChopper);
  mctc1 = coords_set(
#line 1200 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1200 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1200 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.11);
#line 23864 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_18_beforeChopper, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_18_afterChopper = coords_add(mcposacurved_guide_18_beforeChopper, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_18_beforeChopper, mcposacurved_guide_18_afterChopper);
  mcposrcurved_guide_18_afterChopper = rot_apply(mcrotacurved_guide_18_afterChopper, mctc1);
  mcDEBUG_COMPONENT("curved_guide_18_afterChopper", mcposacurved_guide_18_afterChopper, mcrotacurved_guide_18_afterChopper)
  mccomp_posa[26] = mcposacurved_guide_18_afterChopper;
  mccomp_posr[26] = mcposrcurved_guide_18_afterChopper;
  mcNCounter[26]  = mcPCounter[26] = mcP2Counter[26] = 0;
  mcAbsorbProp[26]= 0;
    /* Component curved_guide_19_0. */
  /* Setting parameters for component curved_guide_19_0. */
  SIG_MESSAGE("curved_guide_19_0 (Init:SetPar)");
#line 1205 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_w1 = 0.029534;
#line 1206 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_h1 = 0.047514;
#line 1205 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_w2 = 0.029534;
#line 1206 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_h2 = 0.047514;
#line 1204 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_l = 0.5;
#line 1207 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_R0 = 0.990000;
#line 1207 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_Qc = 0.021700;
#line 1208 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_m = 1.0;
#line 1208 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_d = 0.0005;
#line 1209 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_mleft = 3.000000;
#line 1209 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_mright = 3.500000;
#line 1210 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_mtop = 2.500000;
#line 1210 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_nhslit = 1;
#line 1204 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_19_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_19_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_19_0_reflect[0]='\0';
#line 23946 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_19_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1212 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1212 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1212 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 23956 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_18_afterChopper, mcrotacurved_guide_19_0);
  rot_transpose(mcrotacurved_guide_18_afterChopper, mctr1);
  rot_mul(mcrotacurved_guide_19_0, mctr1, mcrotrcurved_guide_19_0);
  mctc1 = coords_set(
#line 1211 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1211 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1211 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.39 + u);
#line 23967 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_18_afterChopper, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_19_0 = coords_add(mcposacurved_guide_18_afterChopper, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_18_afterChopper, mcposacurved_guide_19_0);
  mcposrcurved_guide_19_0 = rot_apply(mcrotacurved_guide_19_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_19_0", mcposacurved_guide_19_0, mcrotacurved_guide_19_0)
  mccomp_posa[27] = mcposacurved_guide_19_0;
  mccomp_posr[27] = mcposrcurved_guide_19_0;
  mcNCounter[27]  = mcPCounter[27] = mcP2Counter[27] = 0;
  mcAbsorbProp[27]= 0;
    /* Component curved_guide_20_0. */
  /* Setting parameters for component curved_guide_20_0. */
  SIG_MESSAGE("curved_guide_20_0 (Init:SetPar)");
#line 1216 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_w1 = 0.029534;
#line 1217 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_h1 = 0.047514;
#line 1216 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_w2 = 0.029534;
#line 1217 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_h2 = 0.047514;
#line 1215 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_l = 0.5;
#line 1218 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_R0 = 0.990000;
#line 1218 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_Qc = 0.021700;
#line 1219 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_m = 1.0;
#line 1219 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_d = 0.0005;
#line 1220 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_mleft = 3.000000;
#line 1220 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_mright = 3.500000;
#line 1221 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_mtop = 2.500000;
#line 1221 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_nhslit = 1;
#line 1215 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_20_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_20_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_20_0_reflect[0]='\0';
#line 24049 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_20_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1223 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1223 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1223 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 24059 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_19_0, mcrotacurved_guide_20_0);
  rot_transpose(mcrotacurved_guide_19_0, mctr1);
  rot_mul(mcrotacurved_guide_20_0, mctr1, mcrotrcurved_guide_20_0);
  mctc1 = coords_set(
#line 1222 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1222 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1222 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 24070 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_19_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_20_0 = coords_add(mcposacurved_guide_19_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_19_0, mcposacurved_guide_20_0);
  mcposrcurved_guide_20_0 = rot_apply(mcrotacurved_guide_20_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_20_0", mcposacurved_guide_20_0, mcrotacurved_guide_20_0)
  mccomp_posa[28] = mcposacurved_guide_20_0;
  mccomp_posr[28] = mcposrcurved_guide_20_0;
  mcNCounter[28]  = mcPCounter[28] = mcP2Counter[28] = 0;
  mcAbsorbProp[28]= 0;
    /* Component curved_guide_21_0. */
  /* Setting parameters for component curved_guide_21_0. */
  SIG_MESSAGE("curved_guide_21_0 (Init:SetPar)");
#line 1227 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_w1 = 0.029534;
#line 1228 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_h1 = 0.047514;
#line 1227 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_w2 = 0.029534;
#line 1228 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_h2 = 0.047514;
#line 1226 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_l = 0.5;
#line 1229 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_R0 = 0.990000;
#line 1229 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_Qc = 0.021700;
#line 1230 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_m = 1.0;
#line 1230 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_d = 0.0005;
#line 1231 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_mleft = 3.000000;
#line 1231 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_mright = 3.500000;
#line 1232 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_mtop = 2.500000;
#line 1232 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_nhslit = 1;
#line 1226 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_21_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_21_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_21_0_reflect[0]='\0';
#line 24152 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_21_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1234 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1234 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1234 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 24162 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_20_0, mcrotacurved_guide_21_0);
  rot_transpose(mcrotacurved_guide_20_0, mctr1);
  rot_mul(mcrotacurved_guide_21_0, mctr1, mcrotrcurved_guide_21_0);
  mctc1 = coords_set(
#line 1233 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1233 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1233 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 24173 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_20_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_21_0 = coords_add(mcposacurved_guide_20_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_20_0, mcposacurved_guide_21_0);
  mcposrcurved_guide_21_0 = rot_apply(mcrotacurved_guide_21_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_21_0", mcposacurved_guide_21_0, mcrotacurved_guide_21_0)
  mccomp_posa[29] = mcposacurved_guide_21_0;
  mccomp_posr[29] = mcposrcurved_guide_21_0;
  mcNCounter[29]  = mcPCounter[29] = mcP2Counter[29] = 0;
  mcAbsorbProp[29]= 0;
    /* Component curved_guide_22_0. */
  /* Setting parameters for component curved_guide_22_0. */
  SIG_MESSAGE("curved_guide_22_0 (Init:SetPar)");
#line 1238 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_w1 = 0.029534;
#line 1239 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_h1 = 0.047514;
#line 1238 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_w2 = 0.029534;
#line 1239 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_h2 = 0.047514;
#line 1237 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_l = 0.5;
#line 1240 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_R0 = 0.990000;
#line 1240 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_Qc = 0.021700;
#line 1241 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_m = 1.0;
#line 1241 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_d = 0.0005;
#line 1242 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_mleft = 3.000000;
#line 1242 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_mright = 3.500000;
#line 1243 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_mtop = 2.500000;
#line 1243 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_nhslit = 1;
#line 1237 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_22_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_22_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_22_0_reflect[0]='\0';
#line 24255 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_22_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1245 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1245 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1245 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 24265 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_21_0, mcrotacurved_guide_22_0);
  rot_transpose(mcrotacurved_guide_21_0, mctr1);
  rot_mul(mcrotacurved_guide_22_0, mctr1, mcrotrcurved_guide_22_0);
  mctc1 = coords_set(
#line 1244 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1244 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1244 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 24276 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_21_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_22_0 = coords_add(mcposacurved_guide_21_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_21_0, mcposacurved_guide_22_0);
  mcposrcurved_guide_22_0 = rot_apply(mcrotacurved_guide_22_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_22_0", mcposacurved_guide_22_0, mcrotacurved_guide_22_0)
  mccomp_posa[30] = mcposacurved_guide_22_0;
  mccomp_posr[30] = mcposrcurved_guide_22_0;
  mcNCounter[30]  = mcPCounter[30] = mcP2Counter[30] = 0;
  mcAbsorbProp[30]= 0;
    /* Component curved_guide_23_0. */
  /* Setting parameters for component curved_guide_23_0. */
  SIG_MESSAGE("curved_guide_23_0 (Init:SetPar)");
#line 1249 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_w1 = 0.029534;
#line 1250 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_h1 = 0.047514;
#line 1249 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_w2 = 0.029534;
#line 1250 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_h2 = 0.047514;
#line 1248 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_l = 0.5;
#line 1251 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_R0 = 0.990000;
#line 1251 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_Qc = 0.021700;
#line 1252 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_m = 1.0;
#line 1252 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_d = 0.0005;
#line 1253 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_mleft = 3.000000;
#line 1253 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_mright = 3.500000;
#line 1254 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_mtop = 2.500000;
#line 1254 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_nhslit = 1;
#line 1248 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_23_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_23_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_23_0_reflect[0]='\0';
#line 24358 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_23_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1256 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1256 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1256 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 24368 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_22_0, mcrotacurved_guide_23_0);
  rot_transpose(mcrotacurved_guide_22_0, mctr1);
  rot_mul(mcrotacurved_guide_23_0, mctr1, mcrotrcurved_guide_23_0);
  mctc1 = coords_set(
#line 1255 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1255 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1255 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 24379 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_22_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_23_0 = coords_add(mcposacurved_guide_22_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_22_0, mcposacurved_guide_23_0);
  mcposrcurved_guide_23_0 = rot_apply(mcrotacurved_guide_23_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_23_0", mcposacurved_guide_23_0, mcrotacurved_guide_23_0)
  mccomp_posa[31] = mcposacurved_guide_23_0;
  mccomp_posr[31] = mcposrcurved_guide_23_0;
  mcNCounter[31]  = mcPCounter[31] = mcP2Counter[31] = 0;
  mcAbsorbProp[31]= 0;
    /* Component curved_guide_24_0. */
  /* Setting parameters for component curved_guide_24_0. */
  SIG_MESSAGE("curved_guide_24_0 (Init:SetPar)");
#line 1260 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_w1 = 0.029534;
#line 1261 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_h1 = 0.047514;
#line 1260 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_w2 = 0.029534;
#line 1261 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_h2 = 0.047514;
#line 1259 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_l = 0.5;
#line 1262 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_R0 = 0.990000;
#line 1262 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_Qc = 0.021700;
#line 1263 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_m = 1.0;
#line 1263 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_d = 0.0005;
#line 1264 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_mleft = 3.000000;
#line 1264 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_mright = 3.500000;
#line 1265 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_mtop = 2.500000;
#line 1265 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_nhslit = 1;
#line 1259 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_24_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_24_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_24_0_reflect[0]='\0';
#line 24461 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_24_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1267 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1267 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1267 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 24471 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_23_0, mcrotacurved_guide_24_0);
  rot_transpose(mcrotacurved_guide_23_0, mctr1);
  rot_mul(mcrotacurved_guide_24_0, mctr1, mcrotrcurved_guide_24_0);
  mctc1 = coords_set(
#line 1266 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1266 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1266 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 24482 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_23_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_24_0 = coords_add(mcposacurved_guide_23_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_23_0, mcposacurved_guide_24_0);
  mcposrcurved_guide_24_0 = rot_apply(mcrotacurved_guide_24_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_24_0", mcposacurved_guide_24_0, mcrotacurved_guide_24_0)
  mccomp_posa[32] = mcposacurved_guide_24_0;
  mccomp_posr[32] = mcposrcurved_guide_24_0;
  mcNCounter[32]  = mcPCounter[32] = mcP2Counter[32] = 0;
  mcAbsorbProp[32]= 0;
    /* Component curved_guide_25_0. */
  /* Setting parameters for component curved_guide_25_0. */
  SIG_MESSAGE("curved_guide_25_0 (Init:SetPar)");
#line 1271 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_w1 = 0.029534;
#line 1272 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_h1 = 0.047514;
#line 1271 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_w2 = 0.029534;
#line 1272 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_h2 = 0.047514;
#line 1270 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_l = 0.5;
#line 1273 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_R0 = 0.990000;
#line 1273 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_Qc = 0.021700;
#line 1274 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_m = 1.0;
#line 1274 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_d = 0.0005;
#line 1275 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_mleft = 3.000000;
#line 1275 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_mright = 3.500000;
#line 1276 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_mtop = 2.500000;
#line 1276 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_nhslit = 1;
#line 1270 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_25_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_25_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_25_0_reflect[0]='\0';
#line 24564 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_25_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1278 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1278 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1278 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 24574 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_24_0, mcrotacurved_guide_25_0);
  rot_transpose(mcrotacurved_guide_24_0, mctr1);
  rot_mul(mcrotacurved_guide_25_0, mctr1, mcrotrcurved_guide_25_0);
  mctc1 = coords_set(
#line 1277 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1277 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1277 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 24585 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_24_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_25_0 = coords_add(mcposacurved_guide_24_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_24_0, mcposacurved_guide_25_0);
  mcposrcurved_guide_25_0 = rot_apply(mcrotacurved_guide_25_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_25_0", mcposacurved_guide_25_0, mcrotacurved_guide_25_0)
  mccomp_posa[33] = mcposacurved_guide_25_0;
  mccomp_posr[33] = mcposrcurved_guide_25_0;
  mcNCounter[33]  = mcPCounter[33] = mcP2Counter[33] = 0;
  mcAbsorbProp[33]= 0;
    /* Component curved_guide_26_0. */
  /* Setting parameters for component curved_guide_26_0. */
  SIG_MESSAGE("curved_guide_26_0 (Init:SetPar)");
#line 1282 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_w1 = 0.029534;
#line 1283 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_h1 = 0.047514;
#line 1282 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_w2 = 0.029534;
#line 1283 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_h2 = 0.047514;
#line 1281 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_l = 0.5;
#line 1284 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_R0 = 0.990000;
#line 1284 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_Qc = 0.021700;
#line 1285 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_m = 1.0;
#line 1285 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_d = 0.0005;
#line 1286 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_mleft = 3.000000;
#line 1286 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_mright = 3.500000;
#line 1287 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_mtop = 2.500000;
#line 1287 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_nhslit = 1;
#line 1281 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_26_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_26_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_26_0_reflect[0]='\0';
#line 24667 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_26_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1289 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1289 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1289 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 24677 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_25_0, mcrotacurved_guide_26_0);
  rot_transpose(mcrotacurved_guide_25_0, mctr1);
  rot_mul(mcrotacurved_guide_26_0, mctr1, mcrotrcurved_guide_26_0);
  mctc1 = coords_set(
#line 1288 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1288 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1288 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 24688 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_25_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_26_0 = coords_add(mcposacurved_guide_25_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_25_0, mcposacurved_guide_26_0);
  mcposrcurved_guide_26_0 = rot_apply(mcrotacurved_guide_26_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_26_0", mcposacurved_guide_26_0, mcrotacurved_guide_26_0)
  mccomp_posa[34] = mcposacurved_guide_26_0;
  mccomp_posr[34] = mcposrcurved_guide_26_0;
  mcNCounter[34]  = mcPCounter[34] = mcP2Counter[34] = 0;
  mcAbsorbProp[34]= 0;
    /* Component curved_guide_27_0. */
  /* Setting parameters for component curved_guide_27_0. */
  SIG_MESSAGE("curved_guide_27_0 (Init:SetPar)");
#line 1293 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_w1 = 0.029534;
#line 1294 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_h1 = 0.047514;
#line 1293 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_w2 = 0.029534;
#line 1294 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_h2 = 0.047514;
#line 1292 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_l = 0.5;
#line 1295 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_R0 = 0.990000;
#line 1295 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_Qc = 0.021700;
#line 1296 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_m = 1.0;
#line 1296 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_d = 0.0005;
#line 1297 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_mleft = 3.000000;
#line 1297 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_mright = 3.500000;
#line 1298 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_mtop = 2.500000;
#line 1298 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_nhslit = 1;
#line 1292 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_27_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_27_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_27_0_reflect[0]='\0';
#line 24770 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_27_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1300 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1300 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1300 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 24780 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_26_0, mcrotacurved_guide_27_0);
  rot_transpose(mcrotacurved_guide_26_0, mctr1);
  rot_mul(mcrotacurved_guide_27_0, mctr1, mcrotrcurved_guide_27_0);
  mctc1 = coords_set(
#line 1299 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1299 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1299 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 24791 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_26_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_27_0 = coords_add(mcposacurved_guide_26_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_26_0, mcposacurved_guide_27_0);
  mcposrcurved_guide_27_0 = rot_apply(mcrotacurved_guide_27_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_27_0", mcposacurved_guide_27_0, mcrotacurved_guide_27_0)
  mccomp_posa[35] = mcposacurved_guide_27_0;
  mccomp_posr[35] = mcposrcurved_guide_27_0;
  mcNCounter[35]  = mcPCounter[35] = mcP2Counter[35] = 0;
  mcAbsorbProp[35]= 0;
    /* Component curved_guide_28_0. */
  /* Setting parameters for component curved_guide_28_0. */
  SIG_MESSAGE("curved_guide_28_0 (Init:SetPar)");
#line 1304 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_w1 = 0.029534;
#line 1305 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_h1 = 0.047514;
#line 1304 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_w2 = 0.029534;
#line 1305 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_h2 = 0.047514;
#line 1303 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_l = 0.5;
#line 1306 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_R0 = 0.990000;
#line 1306 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_Qc = 0.021700;
#line 1307 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_m = 1.0;
#line 1307 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_d = 0.0005;
#line 1308 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_mleft = 3.000000;
#line 1308 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_mright = 3.500000;
#line 1309 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_mtop = 2.500000;
#line 1309 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_nhslit = 1;
#line 1303 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_28_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_28_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_28_0_reflect[0]='\0';
#line 24873 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_28_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1311 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1311 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1311 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 24883 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_27_0, mcrotacurved_guide_28_0);
  rot_transpose(mcrotacurved_guide_27_0, mctr1);
  rot_mul(mcrotacurved_guide_28_0, mctr1, mcrotrcurved_guide_28_0);
  mctc1 = coords_set(
#line 1310 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1310 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1310 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 24894 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_27_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_28_0 = coords_add(mcposacurved_guide_27_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_27_0, mcposacurved_guide_28_0);
  mcposrcurved_guide_28_0 = rot_apply(mcrotacurved_guide_28_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_28_0", mcposacurved_guide_28_0, mcrotacurved_guide_28_0)
  mccomp_posa[36] = mcposacurved_guide_28_0;
  mccomp_posr[36] = mcposrcurved_guide_28_0;
  mcNCounter[36]  = mcPCounter[36] = mcP2Counter[36] = 0;
  mcAbsorbProp[36]= 0;
    /* Component curved_guide_29_0. */
  /* Setting parameters for component curved_guide_29_0. */
  SIG_MESSAGE("curved_guide_29_0 (Init:SetPar)");
#line 1315 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_w1 = 0.029534;
#line 1316 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_h1 = 0.047514;
#line 1315 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_w2 = 0.029534;
#line 1316 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_h2 = 0.047514;
#line 1314 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_l = 0.5;
#line 1317 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_R0 = 0.990000;
#line 1317 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_Qc = 0.021700;
#line 1318 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_m = 1.0;
#line 1318 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_d = 0.0005;
#line 1319 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_mleft = 3.000000;
#line 1319 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_mright = 3.500000;
#line 1320 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_mtop = 2.500000;
#line 1320 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_nhslit = 1;
#line 1314 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_29_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_29_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_29_0_reflect[0]='\0';
#line 24976 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_29_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1322 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1322 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1322 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 24986 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_28_0, mcrotacurved_guide_29_0);
  rot_transpose(mcrotacurved_guide_28_0, mctr1);
  rot_mul(mcrotacurved_guide_29_0, mctr1, mcrotrcurved_guide_29_0);
  mctc1 = coords_set(
#line 1321 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1321 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1321 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 24997 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_28_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_29_0 = coords_add(mcposacurved_guide_28_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_28_0, mcposacurved_guide_29_0);
  mcposrcurved_guide_29_0 = rot_apply(mcrotacurved_guide_29_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_29_0", mcposacurved_guide_29_0, mcrotacurved_guide_29_0)
  mccomp_posa[37] = mcposacurved_guide_29_0;
  mccomp_posr[37] = mcposrcurved_guide_29_0;
  mcNCounter[37]  = mcPCounter[37] = mcP2Counter[37] = 0;
  mcAbsorbProp[37]= 0;
    /* Component curved_guide_30_0. */
  /* Setting parameters for component curved_guide_30_0. */
  SIG_MESSAGE("curved_guide_30_0 (Init:SetPar)");
#line 1326 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_w1 = 0.029534;
#line 1327 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_h1 = 0.047514;
#line 1326 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_w2 = 0.029534;
#line 1327 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_h2 = 0.047514;
#line 1325 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_l = 0.5;
#line 1328 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_R0 = 0.990000;
#line 1328 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_Qc = 0.021700;
#line 1329 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_m = 1.0;
#line 1329 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_d = 0.0005;
#line 1330 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_mleft = 3.000000;
#line 1330 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_mright = 3.500000;
#line 1331 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_mtop = 2.500000;
#line 1331 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_nhslit = 1;
#line 1325 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_30_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_30_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_30_0_reflect[0]='\0';
#line 25079 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_30_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1333 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1333 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1333 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 25089 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_29_0, mcrotacurved_guide_30_0);
  rot_transpose(mcrotacurved_guide_29_0, mctr1);
  rot_mul(mcrotacurved_guide_30_0, mctr1, mcrotrcurved_guide_30_0);
  mctc1 = coords_set(
#line 1332 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1332 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1332 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 25100 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_29_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_30_0 = coords_add(mcposacurved_guide_29_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_29_0, mcposacurved_guide_30_0);
  mcposrcurved_guide_30_0 = rot_apply(mcrotacurved_guide_30_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_30_0", mcposacurved_guide_30_0, mcrotacurved_guide_30_0)
  mccomp_posa[38] = mcposacurved_guide_30_0;
  mccomp_posr[38] = mcposrcurved_guide_30_0;
  mcNCounter[38]  = mcPCounter[38] = mcP2Counter[38] = 0;
  mcAbsorbProp[38]= 0;
    /* Component curved_guide_31_0. */
  /* Setting parameters for component curved_guide_31_0. */
  SIG_MESSAGE("curved_guide_31_0 (Init:SetPar)");
#line 1337 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_w1 = 0.029534;
#line 1338 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_h1 = 0.047514;
#line 1337 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_w2 = 0.029534;
#line 1338 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_h2 = 0.047514;
#line 1336 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_l = 0.5;
#line 1339 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_R0 = 0.990000;
#line 1339 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_Qc = 0.021700;
#line 1340 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_m = 1.0;
#line 1340 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_d = 0.0005;
#line 1341 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_mleft = 3.000000;
#line 1341 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_mright = 3.500000;
#line 1342 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_mtop = 2.500000;
#line 1342 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_nhslit = 1;
#line 1336 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_31_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_31_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_31_0_reflect[0]='\0';
#line 25182 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_31_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1344 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1344 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1344 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 25192 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_30_0, mcrotacurved_guide_31_0);
  rot_transpose(mcrotacurved_guide_30_0, mctr1);
  rot_mul(mcrotacurved_guide_31_0, mctr1, mcrotrcurved_guide_31_0);
  mctc1 = coords_set(
#line 1343 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1343 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1343 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 25203 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_30_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_31_0 = coords_add(mcposacurved_guide_30_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_30_0, mcposacurved_guide_31_0);
  mcposrcurved_guide_31_0 = rot_apply(mcrotacurved_guide_31_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_31_0", mcposacurved_guide_31_0, mcrotacurved_guide_31_0)
  mccomp_posa[39] = mcposacurved_guide_31_0;
  mccomp_posr[39] = mcposrcurved_guide_31_0;
  mcNCounter[39]  = mcPCounter[39] = mcP2Counter[39] = 0;
  mcAbsorbProp[39]= 0;
    /* Component curved_guide_32_0. */
  /* Setting parameters for component curved_guide_32_0. */
  SIG_MESSAGE("curved_guide_32_0 (Init:SetPar)");
#line 1348 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_w1 = 0.029534;
#line 1349 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_h1 = 0.047514;
#line 1348 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_w2 = 0.029534;
#line 1349 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_h2 = 0.047514;
#line 1347 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_l = 0.5;
#line 1350 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_R0 = 0.990000;
#line 1350 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_Qc = 0.021700;
#line 1351 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_m = 1.0;
#line 1351 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_d = 0.0005;
#line 1352 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_mleft = 3.000000;
#line 1352 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_mright = 3.500000;
#line 1353 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_mtop = 2.500000;
#line 1353 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_nhslit = 1;
#line 1347 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_32_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_32_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_32_0_reflect[0]='\0';
#line 25285 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_32_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1355 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1355 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1355 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 25295 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_31_0, mcrotacurved_guide_32_0);
  rot_transpose(mcrotacurved_guide_31_0, mctr1);
  rot_mul(mcrotacurved_guide_32_0, mctr1, mcrotrcurved_guide_32_0);
  mctc1 = coords_set(
#line 1354 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1354 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1354 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 25306 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_31_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_32_0 = coords_add(mcposacurved_guide_31_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_31_0, mcposacurved_guide_32_0);
  mcposrcurved_guide_32_0 = rot_apply(mcrotacurved_guide_32_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_32_0", mcposacurved_guide_32_0, mcrotacurved_guide_32_0)
  mccomp_posa[40] = mcposacurved_guide_32_0;
  mccomp_posr[40] = mcposrcurved_guide_32_0;
  mcNCounter[40]  = mcPCounter[40] = mcP2Counter[40] = 0;
  mcAbsorbProp[40]= 0;
    /* Component curved_guide_33_0. */
  /* Setting parameters for component curved_guide_33_0. */
  SIG_MESSAGE("curved_guide_33_0 (Init:SetPar)");
#line 1359 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_w1 = 0.029534;
#line 1360 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_h1 = 0.047514;
#line 1359 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_w2 = 0.029534;
#line 1360 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_h2 = 0.047514;
#line 1358 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_l = 0.5;
#line 1361 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_R0 = 0.990000;
#line 1361 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_Qc = 0.021700;
#line 1362 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_m = 1.0;
#line 1362 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_d = 0.0005;
#line 1363 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_mleft = 3.000000;
#line 1363 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_mright = 3.500000;
#line 1364 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_mtop = 2.500000;
#line 1364 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_nhslit = 1;
#line 1358 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_33_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_33_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_33_0_reflect[0]='\0';
#line 25388 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_33_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1366 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1366 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1366 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 25398 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_32_0, mcrotacurved_guide_33_0);
  rot_transpose(mcrotacurved_guide_32_0, mctr1);
  rot_mul(mcrotacurved_guide_33_0, mctr1, mcrotrcurved_guide_33_0);
  mctc1 = coords_set(
#line 1365 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1365 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1365 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 25409 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_32_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_33_0 = coords_add(mcposacurved_guide_32_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_32_0, mcposacurved_guide_33_0);
  mcposrcurved_guide_33_0 = rot_apply(mcrotacurved_guide_33_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_33_0", mcposacurved_guide_33_0, mcrotacurved_guide_33_0)
  mccomp_posa[41] = mcposacurved_guide_33_0;
  mccomp_posr[41] = mcposrcurved_guide_33_0;
  mcNCounter[41]  = mcPCounter[41] = mcP2Counter[41] = 0;
  mcAbsorbProp[41]= 0;
    /* Component curved_guide_34_0. */
  /* Setting parameters for component curved_guide_34_0. */
  SIG_MESSAGE("curved_guide_34_0 (Init:SetPar)");
#line 1370 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_w1 = 0.029534;
#line 1371 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_h1 = 0.047514;
#line 1370 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_w2 = 0.029534;
#line 1371 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_h2 = 0.047514;
#line 1369 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_l = 0.5;
#line 1372 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_R0 = 0.990000;
#line 1372 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_Qc = 0.021700;
#line 1373 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_m = 1.0;
#line 1373 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_d = 0.0005;
#line 1374 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_mleft = 3.000000;
#line 1374 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_mright = 3.500000;
#line 1375 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_mtop = 2.500000;
#line 1375 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_nhslit = 1;
#line 1369 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_34_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_34_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_34_0_reflect[0]='\0';
#line 25491 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_34_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1377 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1377 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1377 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 25501 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_33_0, mcrotacurved_guide_34_0);
  rot_transpose(mcrotacurved_guide_33_0, mctr1);
  rot_mul(mcrotacurved_guide_34_0, mctr1, mcrotrcurved_guide_34_0);
  mctc1 = coords_set(
#line 1376 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1376 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1376 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 25512 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_33_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_34_0 = coords_add(mcposacurved_guide_33_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_33_0, mcposacurved_guide_34_0);
  mcposrcurved_guide_34_0 = rot_apply(mcrotacurved_guide_34_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_34_0", mcposacurved_guide_34_0, mcrotacurved_guide_34_0)
  mccomp_posa[42] = mcposacurved_guide_34_0;
  mccomp_posr[42] = mcposrcurved_guide_34_0;
  mcNCounter[42]  = mcPCounter[42] = mcP2Counter[42] = 0;
  mcAbsorbProp[42]= 0;
    /* Component curved_guide_35_0. */
  /* Setting parameters for component curved_guide_35_0. */
  SIG_MESSAGE("curved_guide_35_0 (Init:SetPar)");
#line 1381 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_w1 = 0.029534;
#line 1382 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_h1 = 0.047514;
#line 1381 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_w2 = 0.029534;
#line 1382 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_h2 = 0.047514;
#line 1380 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_l = 0.5;
#line 1383 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_R0 = 0.990000;
#line 1383 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_Qc = 0.021700;
#line 1384 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_m = 1.0;
#line 1384 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_d = 0.0005;
#line 1385 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_mleft = 3.000000;
#line 1385 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_mright = 3.500000;
#line 1386 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_mtop = 2.500000;
#line 1386 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_nhslit = 1;
#line 1380 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_35_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_35_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_35_0_reflect[0]='\0';
#line 25594 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_35_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1388 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1388 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1388 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 25604 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_34_0, mcrotacurved_guide_35_0);
  rot_transpose(mcrotacurved_guide_34_0, mctr1);
  rot_mul(mcrotacurved_guide_35_0, mctr1, mcrotrcurved_guide_35_0);
  mctc1 = coords_set(
#line 1387 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1387 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1387 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 25615 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_34_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_35_0 = coords_add(mcposacurved_guide_34_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_34_0, mcposacurved_guide_35_0);
  mcposrcurved_guide_35_0 = rot_apply(mcrotacurved_guide_35_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_35_0", mcposacurved_guide_35_0, mcrotacurved_guide_35_0)
  mccomp_posa[43] = mcposacurved_guide_35_0;
  mccomp_posr[43] = mcposrcurved_guide_35_0;
  mcNCounter[43]  = mcPCounter[43] = mcP2Counter[43] = 0;
  mcAbsorbProp[43]= 0;
    /* Component curved_guide_36_0. */
  /* Setting parameters for component curved_guide_36_0. */
  SIG_MESSAGE("curved_guide_36_0 (Init:SetPar)");
#line 1393 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_w1 = 0.029534;
#line 1394 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_h1 = 0.047514;
#line 1393 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_w2 = 0.029534;
#line 1394 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_h2 = 0.047514;
#line 1392 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_l = 0.495689131828;
#line 1395 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_R0 = 0.990000;
#line 1395 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_Qc = 0.021700;
#line 1396 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_m = 1.0;
#line 1396 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_d = 0.0005;
#line 1397 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_mleft = 3.000000;
#line 1397 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_mright = 3.500000;
#line 1398 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_mtop = 2.500000;
#line 1398 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_mbottom = 2.500000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_nhslit = 1;
#line 1392 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcccurved_guide_36_0_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mcccurved_guide_36_0_reflect, "NULL" ? "NULL" : "", 16384); else mcccurved_guide_36_0_reflect[0]='\0';
#line 25697 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("curved_guide_36_0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1400 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1400 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (benderAngle)*DEG2RAD,
#line 1400 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 25707 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_35_0, mcrotacurved_guide_36_0);
  rot_transpose(mcrotacurved_guide_35_0, mctr1);
  rot_mul(mcrotacurved_guide_36_0, mctr1, mcrotrcurved_guide_36_0);
  mctc1 = coords_set(
#line 1399 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1399 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1399 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.500 + u + 6e-5);
#line 25718 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_35_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacurved_guide_36_0 = coords_add(mcposacurved_guide_35_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_35_0, mcposacurved_guide_36_0);
  mcposrcurved_guide_36_0 = rot_apply(mcrotacurved_guide_36_0, mctc1);
  mcDEBUG_COMPONENT("curved_guide_36_0", mcposacurved_guide_36_0, mcrotacurved_guide_36_0)
  mccomp_posa[44] = mcposacurved_guide_36_0;
  mccomp_posr[44] = mcposrcurved_guide_36_0;
  mcNCounter[44]  = mcPCounter[44] = mcP2Counter[44] = 0;
  mcAbsorbProp[44]= 0;
    /* Component EndOfelement_4. */
  /* Setting parameters for component EndOfelement_4. */
  SIG_MESSAGE("EndOfelement_4 (Init:SetPar)");

  SIG_MESSAGE("EndOfelement_4 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25738 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotacurved_guide_36_0, mcrotaEndOfelement_4);
  rot_transpose(mcrotacurved_guide_36_0, mctr1);
  rot_mul(mcrotaEndOfelement_4, mctr1, mcrotrEndOfelement_4);
  mctc1 = coords_set(
#line 1405 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7.57345916228e-10,
#line 1405 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1405 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.495689132 + u);
#line 25749 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotacurved_guide_36_0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaEndOfelement_4 = coords_add(mcposacurved_guide_36_0, mctc2);
  mctc1 = coords_sub(mcposacurved_guide_36_0, mcposaEndOfelement_4);
  mcposrEndOfelement_4 = rot_apply(mcrotaEndOfelement_4, mctc1);
  mcDEBUG_COMPONENT("EndOfelement_4", mcposaEndOfelement_4, mcrotaEndOfelement_4)
  mccomp_posa[45] = mcposaEndOfelement_4;
  mccomp_posr[45] = mcposrEndOfelement_4;
  mcNCounter[45]  = mcPCounter[45] = mcP2Counter[45] = 0;
  mcAbsorbProp[45]= 0;
    /* Component log_P_start. */
  /* Setting parameters for component log_P_start. */
  SIG_MESSAGE("log_P_start (Init:SetPar)");

  SIG_MESSAGE("log_P_start (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25769 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaEndOfelement_4, mcrotalog_P_start);
  rot_transpose(mcrotaEndOfelement_4, mctr1);
  rot_mul(mcrotalog_P_start, mctr1, mcrotrlog_P_start);
  mctc1 = coords_set(
#line 1419 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1419 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1419 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 25780 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaEndOfelement_4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposalog_P_start = coords_add(mcposaEndOfelement_4, mctc2);
  mctc1 = coords_sub(mcposaEndOfelement_4, mcposalog_P_start);
  mcposrlog_P_start = rot_apply(mcrotalog_P_start, mctc1);
  mcDEBUG_COMPONENT("log_P_start", mcposalog_P_start, mcrotalog_P_start)
  mccomp_posa[46] = mcposalog_P_start;
  mccomp_posr[46] = mcposrlog_P_start;
  mcNCounter[46]  = mcPCounter[46] = mcP2Counter[46] = 0;
  mcAbsorbProp[46]= 0;
    /* Component elliptical_guide_gravity3. */
  /* Setting parameters for component elliptical_guide_gravity3. */
  SIG_MESSAGE("elliptical_guide_gravity3 (Init:SetPar)");
#line 1430 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_l = 24.928800;
#line 1431 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_xwidth = 0.060000;
#line 1431 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_yheight = 0.090000;
#line 1430 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_linxw = 3.709727;
#line 1430 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_loutxw = 28.638527;
#line 1430 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_linyh = 4.423828;
#line 1430 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_loutyh = 29.352628;
#line 171 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_majorAxisxw = 0;
#line 171 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_minorAxisxw = 0;
#line 172 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_majorAxisyh = 0;
#line 172 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_minorAxisyh = 0;
#line 173 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_majorAxisoffsetxw = 0;
#line 174 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_majorAxisoffsetyh = 0;
#line 1431 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("mid") strncpy(mccelliptical_guide_gravity3_dimensionsAt, "mid" ? "mid" : "", 16384); else mccelliptical_guide_gravity3_dimensionsAt[0]='\0';
#line 176 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("ellipse") strncpy(mccelliptical_guide_gravity3_option, "ellipse" ? "ellipse" : "", 16384); else mccelliptical_guide_gravity3_option[0]='\0';
#line 1432 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_R0 = 0.990000;
#line 1432 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_Qc = 0.021700;
#line 1432 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_alpha = 3.100000;
#line 177 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_m = 2;
#line 1432 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_W = 0.003000;
#line 178 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_alpharight = -1;
#line 178 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_mright = -1;
#line 179 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_alphaleft = -1;
#line 179 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_mleft = -1;
#line 180 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_alphatop = -1;
#line 180 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_mtop = -1;
#line 181 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_alphabottom = -1;
#line 181 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_mbottom = -1;
#line 182 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("on") strncpy(mccelliptical_guide_gravity3_verbose, "on" ? "on" : "", 16384); else mccelliptical_guide_gravity3_verbose[0]='\0';
#line 183 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_enableGravity = 1.0;
#line 184 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity3_curvature = 0;
#line 25856 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("elliptical_guide_gravity3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1434 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1434 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1434 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 25866 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaEndOfelement_4, mcrotaelliptical_guide_gravity3);
  rot_transpose(mcrotalog_P_start, mctr1);
  rot_mul(mcrotaelliptical_guide_gravity3, mctr1, mcrotrelliptical_guide_gravity3);
  mctc1 = coords_set(
#line 1433 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1433 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1433 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    u);
#line 25877 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaEndOfelement_4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaelliptical_guide_gravity3 = coords_add(mcposaEndOfelement_4, mctc2);
  mctc1 = coords_sub(mcposalog_P_start, mcposaelliptical_guide_gravity3);
  mcposrelliptical_guide_gravity3 = rot_apply(mcrotaelliptical_guide_gravity3, mctc1);
  mcDEBUG_COMPONENT("elliptical_guide_gravity3", mcposaelliptical_guide_gravity3, mcrotaelliptical_guide_gravity3)
  mccomp_posa[47] = mcposaelliptical_guide_gravity3;
  mccomp_posr[47] = mcposrelliptical_guide_gravity3;
  mcNCounter[47]  = mcPCounter[47] = mcP2Counter[47] = 0;
  mcAbsorbProp[47]= 0;
    /* Component EndOfelement_3. */
  /* Setting parameters for component EndOfelement_3. */
  SIG_MESSAGE("EndOfelement_3 (Init:SetPar)");

  SIG_MESSAGE("EndOfelement_3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25897 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaelliptical_guide_gravity3, mcrotaEndOfelement_3);
  rot_transpose(mcrotaelliptical_guide_gravity3, mctr1);
  rot_mul(mcrotaEndOfelement_3, mctr1, mcrotrEndOfelement_3);
  mctc1 = coords_set(
#line 1437 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1437 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1437 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    24.928800 + u);
#line 25908 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaelliptical_guide_gravity3, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaEndOfelement_3 = coords_add(mcposaelliptical_guide_gravity3, mctc2);
  mctc1 = coords_sub(mcposaelliptical_guide_gravity3, mcposaEndOfelement_3);
  mcposrEndOfelement_3 = rot_apply(mcrotaEndOfelement_3, mctc1);
  mcDEBUG_COMPONENT("EndOfelement_3", mcposaEndOfelement_3, mcrotaEndOfelement_3)
  mccomp_posa[48] = mcposaEndOfelement_3;
  mccomp_posr[48] = mcposrEndOfelement_3;
  mcNCounter[48]  = mcPCounter[48] = mcP2Counter[48] = 0;
  mcAbsorbProp[48]= 0;
    /* Component straight_guide_2_1. */
  /* Setting parameters for component straight_guide_2_1. */
  SIG_MESSAGE("straight_guide_2_1 (Init:SetPar)");
#line 1450 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_w1 = 0.060000;
#line 1451 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_h1 = 0.090000;
#line 1450 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_w2 = 0.060000;
#line 1451 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_h2 = 0.090000;
#line 1449 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_l = chopBWPos - startXposition_straight - BW_chopGap / 2;
#line 1452 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_R0 = 0.990000;
#line 1452 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_Qc = 0.021700;
#line 1453 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_m = 1.0;
#line 1453 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_d = 0.0005;
#line 1454 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_mleft = 1.500000;
#line 1454 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_mright = 1.500000;
#line 1455 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_mtop = 1.000000;
#line 1455 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_mbottom = 1.000000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_nhslit = 1;
#line 1449 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_1_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mccstraight_guide_2_1_reflect, "NULL" ? "NULL" : "", 16384); else mccstraight_guide_2_1_reflect[0]='\0';
#line 25990 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("straight_guide_2_1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1457 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1457 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1457 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 26000 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaEndOfelement_3, mcrotastraight_guide_2_1);
  rot_transpose(mcrotaEndOfelement_3, mctr1);
  rot_mul(mcrotastraight_guide_2_1, mctr1, mcrotrstraight_guide_2_1);
  mctc1 = coords_set(
#line 1456 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1456 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1456 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    u);
#line 26011 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaEndOfelement_3, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposastraight_guide_2_1 = coords_add(mcposaEndOfelement_3, mctc2);
  mctc1 = coords_sub(mcposaEndOfelement_3, mcposastraight_guide_2_1);
  mcposrstraight_guide_2_1 = rot_apply(mcrotastraight_guide_2_1, mctc1);
  mcDEBUG_COMPONENT("straight_guide_2_1", mcposastraight_guide_2_1, mcrotastraight_guide_2_1)
  mccomp_posa[49] = mcposastraight_guide_2_1;
  mccomp_posr[49] = mcposrstraight_guide_2_1;
  mcNCounter[49]  = mcPCounter[49] = mcP2Counter[49] = 0;
  mcAbsorbProp[49]= 0;
    /* Component straight_guide_2_2. */
  /* Setting parameters for component straight_guide_2_2. */
  SIG_MESSAGE("straight_guide_2_2 (Init:SetPar)");
#line 1504 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_w1 = 0.060000;
#line 1505 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_h1 = 0.090000;
#line 1504 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_w2 = 0.060000;
#line 1505 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_h2 = 0.090000;
#line 1503 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_l = length2 - chopBWPos + startXposition_straight - BW_chopGap / 2;
#line 1506 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_R0 = 0.990000;
#line 1506 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_Qc = 0.021700;
#line 1507 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_alpha = 3.100000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_m = 1.0;
#line 1507 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_W = 0.003000;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_nslit = 1;
#line 127 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_d = 0.0005;
#line 1508 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_mleft = 1.500000;
#line 1508 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_mright = 1.500000;
#line 1509 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_mtop = 1.000000;
#line 1509 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_mbottom = 1.000000;
#line 128 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_nhslit = 1;
#line 1503 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_G = -9.82;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_aleft = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_aright = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_atop = -1;
#line 129 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_abottom = -1;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_wavy = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_wavy_z = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_wavy_tb = 0;
#line 130 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_wavy_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_chamfers = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_chamfers_z = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_chamfers_lr = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_chamfers_tb = 0;
#line 131 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_nelements = 1;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_nu = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccstraight_guide_2_2_phase = 0;
#line 132 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mccstraight_guide_2_2_reflect, "NULL" ? "NULL" : "", 16384); else mccstraight_guide_2_2_reflect[0]='\0';
#line 26093 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("straight_guide_2_2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1511 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1511 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1511 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 26103 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotastraight_guide_2_1, mcrotastraight_guide_2_2);
  rot_transpose(mcrotastraight_guide_2_1, mctr1);
  rot_mul(mcrotastraight_guide_2_2, mctr1, mcrotrstraight_guide_2_2);
  mctc1 = coords_set(
#line 1510 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1510 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1510 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    BW_chopGap / 2);
#line 26114 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotastraight_guide_2_1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposastraight_guide_2_2 = coords_add(mcposastraight_guide_2_1, mctc2);
  mctc1 = coords_sub(mcposastraight_guide_2_1, mcposastraight_guide_2_2);
  mcposrstraight_guide_2_2 = rot_apply(mcrotastraight_guide_2_2, mctc1);
  mcDEBUG_COMPONENT("straight_guide_2_2", mcposastraight_guide_2_2, mcrotastraight_guide_2_2)
  mccomp_posa[50] = mcposastraight_guide_2_2;
  mccomp_posr[50] = mcposrstraight_guide_2_2;
  mcNCounter[50]  = mcPCounter[50] = mcP2Counter[50] = 0;
  mcAbsorbProp[50]= 0;
    /* Component EndOfelement_2. */
  /* Setting parameters for component EndOfelement_2. */
  SIG_MESSAGE("EndOfelement_2 (Init:SetPar)");

  SIG_MESSAGE("EndOfelement_2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26134 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotastraight_guide_2_2, mcrotaEndOfelement_2);
  rot_transpose(mcrotastraight_guide_2_2, mctr1);
  rot_mul(mcrotaEndOfelement_2, mctr1, mcrotrEndOfelement_2);
  mctc1 = coords_set(
#line 1515 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1515 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1515 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    length2 - chopBWPos + startXposition_straight - BW_chopGap / 2 + u);
#line 26145 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotastraight_guide_2_2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaEndOfelement_2 = coords_add(mcposastraight_guide_2_2, mctc2);
  mctc1 = coords_sub(mcposastraight_guide_2_2, mcposaEndOfelement_2);
  mcposrEndOfelement_2 = rot_apply(mcrotaEndOfelement_2, mctc1);
  mcDEBUG_COMPONENT("EndOfelement_2", mcposaEndOfelement_2, mcrotaEndOfelement_2)
  mccomp_posa[51] = mcposaEndOfelement_2;
  mccomp_posr[51] = mcposrEndOfelement_2;
  mcNCounter[51]  = mcPCounter[51] = mcP2Counter[51] = 0;
  mcAbsorbProp[51]= 0;
    /* Component elliptical_guide_gravity1_1. */
  /* Setting parameters for component elliptical_guide_gravity1_1. */
  SIG_MESSAGE("elliptical_guide_gravity1_1 (Init:SetPar)");
#line 1523 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_l = length1 - DivSlit3Pos - DivSlit3Gap / 2.0 + sample_dist;
#line 1526 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_xwidth = 2 * smallaxis_x1;
#line 1526 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_yheight = 2 * smallaxis_y1;
#line 1523 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_linxw = Linx1;
#line 1524 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_loutxw = Loutx1 + DivSlit3Pos + DivSlit3Gap / 2.0 - sample_dist;
#line 1524 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_linyh = Liny1;
#line 1525 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_loutyh = Louty1 + DivSlit3Pos + DivSlit3Gap / 2.0 - sample_dist;
#line 171 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_majorAxisxw = 0;
#line 171 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_minorAxisxw = 0;
#line 172 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_majorAxisyh = 0;
#line 172 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_minorAxisyh = 0;
#line 173 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_majorAxisoffsetxw = 0;
#line 174 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_majorAxisoffsetyh = 0;
#line 1526 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("mid") strncpy(mccelliptical_guide_gravity1_1_dimensionsAt, "mid" ? "mid" : "", 16384); else mccelliptical_guide_gravity1_1_dimensionsAt[0]='\0';
#line 176 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("ellipse") strncpy(mccelliptical_guide_gravity1_1_option, "ellipse" ? "ellipse" : "", 16384); else mccelliptical_guide_gravity1_1_option[0]='\0';
#line 1527 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_R0 = 0.990000;
#line 1527 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_Qc = 0.021700;
#line 1527 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_alpha = 3.100000;
#line 177 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_m = 2;
#line 1527 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_W = 0.003000;
#line 178 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_alpharight = -1;
#line 178 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_mright = -1;
#line 179 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_alphaleft = -1;
#line 179 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_mleft = -1;
#line 180 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_alphatop = -1;
#line 180 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_mtop = -1;
#line 181 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_alphabottom = -1;
#line 181 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_mbottom = -1;
#line 182 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("on") strncpy(mccelliptical_guide_gravity1_1_verbose, "on" ? "on" : "", 16384); else mccelliptical_guide_gravity1_1_verbose[0]='\0';
#line 183 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_enableGravity = 1.0;
#line 184 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_1_curvature = 0;
#line 26221 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("elliptical_guide_gravity1_1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1529 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1529 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1529 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 26231 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaEndOfelement_2, mcrotaelliptical_guide_gravity1_1);
  rot_transpose(mcrotaEndOfelement_2, mctr1);
  rot_mul(mcrotaelliptical_guide_gravity1_1, mctr1, mcrotrelliptical_guide_gravity1_1);
  mctc1 = coords_set(
#line 1528 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1528 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1528 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    u);
#line 26242 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaEndOfelement_2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaelliptical_guide_gravity1_1 = coords_add(mcposaEndOfelement_2, mctc2);
  mctc1 = coords_sub(mcposaEndOfelement_2, mcposaelliptical_guide_gravity1_1);
  mcposrelliptical_guide_gravity1_1 = rot_apply(mcrotaelliptical_guide_gravity1_1, mctc1);
  mcDEBUG_COMPONENT("elliptical_guide_gravity1_1", mcposaelliptical_guide_gravity1_1, mcrotaelliptical_guide_gravity1_1)
  mccomp_posa[52] = mcposaelliptical_guide_gravity1_1;
  mccomp_posr[52] = mcposrelliptical_guide_gravity1_1;
  mcNCounter[52]  = mcPCounter[52] = mcP2Counter[52] = 0;
  mcAbsorbProp[52]= 0;
    /* Component DiwJaw3. */
  /* Setting parameters for component DiwJaw3. */
  SIG_MESSAGE("DiwJaw3 (Init:SetPar)");
#line 46 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw3_xmin = 0;
#line 46 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw3_xmax = 0;
#line 46 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw3_ymin = 0;
#line 46 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw3_ymax = 0;
#line 46 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw3_radius = 0;
#line 1532 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw3_xwidth = mcipDivSlit3_width;
#line 1532 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw3_yheight = 1;
#line 26270 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("DiwJaw3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26277 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaEndOfelement_2, mcrotaDiwJaw3);
  rot_transpose(mcrotaelliptical_guide_gravity1_1, mctr1);
  rot_mul(mcrotaDiwJaw3, mctr1, mcrotrDiwJaw3);
  mctc1 = coords_set(
#line 1533 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1533 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1533 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    2 * u + length1 - ( DivSlit3Pos - sample_dist ));
#line 26288 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaEndOfelement_2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDiwJaw3 = coords_add(mcposaEndOfelement_2, mctc2);
  mctc1 = coords_sub(mcposaelliptical_guide_gravity1_1, mcposaDiwJaw3);
  mcposrDiwJaw3 = rot_apply(mcrotaDiwJaw3, mctc1);
  mcDEBUG_COMPONENT("DiwJaw3", mcposaDiwJaw3, mcrotaDiwJaw3)
  mccomp_posa[53] = mcposaDiwJaw3;
  mccomp_posr[53] = mcposrDiwJaw3;
  mcNCounter[53]  = mcPCounter[53] = mcP2Counter[53] = 0;
  mcAbsorbProp[53]= 0;
    /* Component elliptical_guide_gravity1_2. */
  /* Setting parameters for component elliptical_guide_gravity1_2. */
  SIG_MESSAGE("elliptical_guide_gravity1_2 (Init:SetPar)");
#line 1536 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_l = DivSlit3Pos - DivSlit2Gap / 2.0 - DivSlit3Gap / 2.0 - DivSlit2Pos;
#line 1539 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_xwidth = 2 * smallaxis_x1;
#line 1539 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_yheight = 2 * smallaxis_y1;
#line 1536 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_linxw = Linx1 + length1 - ( DivSlit3Pos - DivSlit3Gap / 2.0 - sample_dist );
#line 1537 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_loutxw = Loutx1 + DivSlit2Pos + DivSlit2Gap / 2.0 - sample_dist;
#line 1537 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_linyh = Liny1 + length1 - ( DivSlit3Pos - DivSlit3Gap / 2.0 - sample_dist );
#line 1538 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_loutyh = Louty1 + DivSlit2Pos + DivSlit2Gap / 2.0 - sample_dist;
#line 171 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_majorAxisxw = 0;
#line 171 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_minorAxisxw = 0;
#line 172 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_majorAxisyh = 0;
#line 172 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_minorAxisyh = 0;
#line 173 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_majorAxisoffsetxw = 0;
#line 174 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_majorAxisoffsetyh = 0;
#line 1539 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("mid") strncpy(mccelliptical_guide_gravity1_2_dimensionsAt, "mid" ? "mid" : "", 16384); else mccelliptical_guide_gravity1_2_dimensionsAt[0]='\0';
#line 176 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("ellipse") strncpy(mccelliptical_guide_gravity1_2_option, "ellipse" ? "ellipse" : "", 16384); else mccelliptical_guide_gravity1_2_option[0]='\0';
#line 1540 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_R0 = 0.990000;
#line 1540 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_Qc = 0.021700;
#line 1540 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_alpha = 3.100000;
#line 177 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_m = 2;
#line 1540 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_W = 0.003000;
#line 178 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_alpharight = -1;
#line 178 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_mright = -1;
#line 179 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_alphaleft = -1;
#line 179 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_mleft = -1;
#line 180 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_alphatop = -1;
#line 180 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_mtop = -1;
#line 181 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_alphabottom = -1;
#line 181 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_mbottom = -1;
#line 182 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("on") strncpy(mccelliptical_guide_gravity1_2_verbose, "on" ? "on" : "", 16384); else mccelliptical_guide_gravity1_2_verbose[0]='\0';
#line 183 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_enableGravity = 1.0;
#line 184 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_2_curvature = 0;
#line 26364 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("elliptical_guide_gravity1_2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1542 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1542 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1542 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 26374 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaDiwJaw3, mcrotaelliptical_guide_gravity1_2);
  rot_transpose(mcrotaDiwJaw3, mctr1);
  rot_mul(mcrotaelliptical_guide_gravity1_2, mctr1, mcrotrelliptical_guide_gravity1_2);
  mctc1 = coords_set(
#line 1541 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1541 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1541 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    3 * u + length1 - ( DivSlit3Pos - DivSlit3Gap / 2.0 - sample_dist ));
#line 26385 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaEndOfelement_2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaelliptical_guide_gravity1_2 = coords_add(mcposaEndOfelement_2, mctc2);
  mctc1 = coords_sub(mcposaDiwJaw3, mcposaelliptical_guide_gravity1_2);
  mcposrelliptical_guide_gravity1_2 = rot_apply(mcrotaelliptical_guide_gravity1_2, mctc1);
  mcDEBUG_COMPONENT("elliptical_guide_gravity1_2", mcposaelliptical_guide_gravity1_2, mcrotaelliptical_guide_gravity1_2)
  mccomp_posa[54] = mcposaelliptical_guide_gravity1_2;
  mccomp_posr[54] = mcposrelliptical_guide_gravity1_2;
  mcNCounter[54]  = mcPCounter[54] = mcP2Counter[54] = 0;
  mcAbsorbProp[54]= 0;
    /* Component DiwJaw2. */
  /* Setting parameters for component DiwJaw2. */
  SIG_MESSAGE("DiwJaw2 (Init:SetPar)");
#line 46 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw2_xmin = 0;
#line 46 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw2_xmax = 0;
#line 46 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw2_ymin = 0;
#line 46 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw2_ymax = 0;
#line 46 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw2_radius = 0;
#line 1545 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw2_xwidth = mcipDivSlit2_width;
#line 1545 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw2_yheight = 1;
#line 26413 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("DiwJaw2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26420 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaEndOfelement_2, mcrotaDiwJaw2);
  rot_transpose(mcrotaelliptical_guide_gravity1_2, mctr1);
  rot_mul(mcrotaDiwJaw2, mctr1, mcrotrDiwJaw2);
  mctc1 = coords_set(
#line 1546 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1546 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1546 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    u + length1 - ( DivSlit2Pos - sample_dist ));
#line 26431 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaEndOfelement_2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDiwJaw2 = coords_add(mcposaEndOfelement_2, mctc2);
  mctc1 = coords_sub(mcposaelliptical_guide_gravity1_2, mcposaDiwJaw2);
  mcposrDiwJaw2 = rot_apply(mcrotaDiwJaw2, mctc1);
  mcDEBUG_COMPONENT("DiwJaw2", mcposaDiwJaw2, mcrotaDiwJaw2)
  mccomp_posa[55] = mcposaDiwJaw2;
  mccomp_posr[55] = mcposrDiwJaw2;
  mcNCounter[55]  = mcPCounter[55] = mcP2Counter[55] = 0;
  mcAbsorbProp[55]= 0;
    /* Component elliptical_guide_gravity1_3. */
  /* Setting parameters for component elliptical_guide_gravity1_3. */
  SIG_MESSAGE("elliptical_guide_gravity1_3 (Init:SetPar)");
#line 1549 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_l = DivSlit2Pos - DivSlit1Gap / 2.0 - DivSlit2Gap / 2.0 - DivSlit1Pos;
#line 1552 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_xwidth = 2 * smallaxis_x1;
#line 1552 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_yheight = 2 * smallaxis_y1;
#line 1549 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_linxw = Linx1 + length1 - ( DivSlit2Pos - DivSlit2Gap / 2.0 - sample_dist );
#line 1550 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_loutxw = Loutx1 + DivSlit1Pos + DivSlit1Gap / 2.0 - sample_dist;
#line 1550 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_linyh = Liny1 + length1 - ( DivSlit2Pos - DivSlit2Gap / 2.0 - sample_dist );
#line 1551 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_loutyh = Louty1 + DivSlit1Pos + DivSlit1Gap / 2.0 - sample_dist;
#line 171 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_majorAxisxw = 0;
#line 171 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_minorAxisxw = 0;
#line 172 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_majorAxisyh = 0;
#line 172 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_minorAxisyh = 0;
#line 173 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_majorAxisoffsetxw = 0;
#line 174 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_majorAxisoffsetyh = 0;
#line 1552 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("mid") strncpy(mccelliptical_guide_gravity1_3_dimensionsAt, "mid" ? "mid" : "", 16384); else mccelliptical_guide_gravity1_3_dimensionsAt[0]='\0';
#line 176 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("ellipse") strncpy(mccelliptical_guide_gravity1_3_option, "ellipse" ? "ellipse" : "", 16384); else mccelliptical_guide_gravity1_3_option[0]='\0';
#line 1553 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_R0 = 0.990000;
#line 1553 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_Qc = 0.021700;
#line 1553 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_alpha = 3.100000;
#line 177 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_m = 2;
#line 1553 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_W = 0.003000;
#line 178 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_alpharight = -1;
#line 178 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_mright = -1;
#line 179 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_alphaleft = -1;
#line 179 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_mleft = -1;
#line 180 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_alphatop = -1;
#line 180 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_mtop = -1;
#line 181 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_alphabottom = -1;
#line 181 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_mbottom = -1;
#line 182 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("on") strncpy(mccelliptical_guide_gravity1_3_verbose, "on" ? "on" : "", 16384); else mccelliptical_guide_gravity1_3_verbose[0]='\0';
#line 183 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_enableGravity = 1.0;
#line 184 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_3_curvature = 0;
#line 26507 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("elliptical_guide_gravity1_3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1555 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1555 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1555 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 26517 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaDiwJaw2, mcrotaelliptical_guide_gravity1_3);
  rot_transpose(mcrotaDiwJaw2, mctr1);
  rot_mul(mcrotaelliptical_guide_gravity1_3, mctr1, mcrotrelliptical_guide_gravity1_3);
  mctc1 = coords_set(
#line 1554 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1554 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1554 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    4 * u + length1 - ( DivSlit2Pos - DivSlit2Gap / 2.0 - sample_dist ));
#line 26528 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaEndOfelement_2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaelliptical_guide_gravity1_3 = coords_add(mcposaEndOfelement_2, mctc2);
  mctc1 = coords_sub(mcposaDiwJaw2, mcposaelliptical_guide_gravity1_3);
  mcposrelliptical_guide_gravity1_3 = rot_apply(mcrotaelliptical_guide_gravity1_3, mctc1);
  mcDEBUG_COMPONENT("elliptical_guide_gravity1_3", mcposaelliptical_guide_gravity1_3, mcrotaelliptical_guide_gravity1_3)
  mccomp_posa[56] = mcposaelliptical_guide_gravity1_3;
  mccomp_posr[56] = mcposrelliptical_guide_gravity1_3;
  mcNCounter[56]  = mcPCounter[56] = mcP2Counter[56] = 0;
  mcAbsorbProp[56]= 0;
    /* Component DiwJaw1. */
  /* Setting parameters for component DiwJaw1. */
  SIG_MESSAGE("DiwJaw1 (Init:SetPar)");
#line 46 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw1_xmin = 0;
#line 46 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw1_xmax = 0;
#line 46 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw1_ymin = 0;
#line 46 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw1_ymax = 0;
#line 46 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw1_radius = 0;
#line 1558 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw1_xwidth = mcipDivSlit1_width;
#line 1558 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw1_yheight = 1;
#line 26556 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("DiwJaw1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26563 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaEndOfelement_2, mcrotaDiwJaw1);
  rot_transpose(mcrotaelliptical_guide_gravity1_3, mctr1);
  rot_mul(mcrotaDiwJaw1, mctr1, mcrotrDiwJaw1);
  mctc1 = coords_set(
#line 1559 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1559 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1559 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    5 * u + length1 - ( DivSlit1Pos - sample_dist ));
#line 26574 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaEndOfelement_2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDiwJaw1 = coords_add(mcposaEndOfelement_2, mctc2);
  mctc1 = coords_sub(mcposaelliptical_guide_gravity1_3, mcposaDiwJaw1);
  mcposrDiwJaw1 = rot_apply(mcrotaDiwJaw1, mctc1);
  mcDEBUG_COMPONENT("DiwJaw1", mcposaDiwJaw1, mcrotaDiwJaw1)
  mccomp_posa[57] = mcposaDiwJaw1;
  mccomp_posr[57] = mcposrDiwJaw1;
  mcNCounter[57]  = mcPCounter[57] = mcP2Counter[57] = 0;
  mcAbsorbProp[57]= 0;
    /* Component elliptical_guide_gravity1_4. */
  /* Setting parameters for component elliptical_guide_gravity1_4. */
  SIG_MESSAGE("elliptical_guide_gravity1_4 (Init:SetPar)");
#line 1562 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_l = DivSlit1Pos - DivSlit1Gap / 2.0 - sample_dist;
#line 1564 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_xwidth = 2 * smallaxis_x1;
#line 1564 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_yheight = 2 * smallaxis_y1;
#line 1562 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_linxw = Linx1 + length1 - ( DivSlit1Pos - DivSlit1Gap / 2.0 - sample_dist );
#line 1563 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_loutxw = Loutx1;
#line 1563 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_linyh = Liny1 + length1 - ( DivSlit1Pos - DivSlit1Gap / 2.0 - sample_dist );
#line 1563 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_loutyh = Louty1;
#line 171 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_majorAxisxw = 0;
#line 171 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_minorAxisxw = 0;
#line 172 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_majorAxisyh = 0;
#line 172 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_minorAxisyh = 0;
#line 173 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_majorAxisoffsetxw = 0;
#line 174 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_majorAxisoffsetyh = 0;
#line 1564 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("mid") strncpy(mccelliptical_guide_gravity1_4_dimensionsAt, "mid" ? "mid" : "", 16384); else mccelliptical_guide_gravity1_4_dimensionsAt[0]='\0';
#line 176 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("ellipse") strncpy(mccelliptical_guide_gravity1_4_option, "ellipse" ? "ellipse" : "", 16384); else mccelliptical_guide_gravity1_4_option[0]='\0';
#line 1565 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_R0 = 0.990000;
#line 1565 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_Qc = 0.021700;
#line 1565 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_alpha = 3.100000;
#line 177 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_m = 2;
#line 1565 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_W = 0.003000;
#line 178 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_alpharight = -1;
#line 178 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_mright = -1;
#line 179 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_alphaleft = -1;
#line 179 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_mleft = -1;
#line 180 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_alphatop = -1;
#line 180 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_mtop = -1;
#line 181 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_alphabottom = -1;
#line 181 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_mbottom = -1;
#line 182 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("on") strncpy(mccelliptical_guide_gravity1_4_verbose, "on" ? "on" : "", 16384); else mccelliptical_guide_gravity1_4_verbose[0]='\0';
#line 183 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_enableGravity = 1.0;
#line 184 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccelliptical_guide_gravity1_4_curvature = 0;
#line 26650 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("elliptical_guide_gravity1_4 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 1567 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1567 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD,
#line 1567 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    (0)*DEG2RAD);
#line 26660 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaDiwJaw1, mcrotaelliptical_guide_gravity1_4);
  rot_transpose(mcrotaDiwJaw1, mctr1);
  rot_mul(mcrotaelliptical_guide_gravity1_4, mctr1, mcrotrelliptical_guide_gravity1_4);
  mctc1 = coords_set(
#line 1566 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1566 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1566 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    6 * u + length1 - ( DivSlit1Pos - DivSlit1Gap / 2.0 - sample_dist ));
#line 26671 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaEndOfelement_2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaelliptical_guide_gravity1_4 = coords_add(mcposaEndOfelement_2, mctc2);
  mctc1 = coords_sub(mcposaDiwJaw1, mcposaelliptical_guide_gravity1_4);
  mcposrelliptical_guide_gravity1_4 = rot_apply(mcrotaelliptical_guide_gravity1_4, mctc1);
  mcDEBUG_COMPONENT("elliptical_guide_gravity1_4", mcposaelliptical_guide_gravity1_4, mcrotaelliptical_guide_gravity1_4)
  mccomp_posa[58] = mcposaelliptical_guide_gravity1_4;
  mccomp_posr[58] = mcposrelliptical_guide_gravity1_4;
  mcNCounter[58]  = mcPCounter[58] = mcP2Counter[58] = 0;
  mcAbsorbProp[58]= 0;
    /* Component EndOfelement_1. */
  /* Setting parameters for component EndOfelement_1. */
  SIG_MESSAGE("EndOfelement_1 (Init:SetPar)");

  SIG_MESSAGE("EndOfelement_1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26691 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaelliptical_guide_gravity1_4, mcrotaEndOfelement_1);
  rot_transpose(mcrotaelliptical_guide_gravity1_4, mctr1);
  rot_mul(mcrotaEndOfelement_1, mctr1, mcrotrEndOfelement_1);
  mctc1 = coords_set(
#line 1570 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1570 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1570 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    DivSlit1Pos - DivSlit1Gap / 2.0 - sample_dist + u);
#line 26702 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaelliptical_guide_gravity1_4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaEndOfelement_1 = coords_add(mcposaelliptical_guide_gravity1_4, mctc2);
  mctc1 = coords_sub(mcposaelliptical_guide_gravity1_4, mcposaEndOfelement_1);
  mcposrEndOfelement_1 = rot_apply(mcrotaEndOfelement_1, mctc1);
  mcDEBUG_COMPONENT("EndOfelement_1", mcposaEndOfelement_1, mcrotaEndOfelement_1)
  mccomp_posa[59] = mcposaEndOfelement_1;
  mccomp_posr[59] = mcposrEndOfelement_1;
  mcNCounter[59]  = mcPCounter[59] = mcP2Counter[59] = 0;
  mcAbsorbProp[59]= 0;
    /* Component VirtualOutput. */
  /* Setting parameters for component VirtualOutput. */
  SIG_MESSAGE("VirtualOutput (Init:SetPar)");
#line 1573 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("VirtualOutput_endOfGuide.dat") strncpy(mccVirtualOutput_filename, "VirtualOutput_endOfGuide.dat" ? "VirtualOutput_endOfGuide.dat" : "", 16384); else mccVirtualOutput_filename[0]='\0';
#line 61 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccVirtualOutput_bufsize = 0;
#line 26720 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("VirtualOutput (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26727 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaEndOfelement_1, mcrotaVirtualOutput);
  rot_transpose(mcrotaEndOfelement_1, mctr1);
  rot_mul(mcrotaVirtualOutput, mctr1, mcrotrVirtualOutput);
  mctc1 = coords_set(
#line 1574 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1574 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1574 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    u);
#line 26738 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaEndOfelement_1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaVirtualOutput = coords_add(mcposaEndOfelement_1, mctc2);
  mctc1 = coords_sub(mcposaEndOfelement_1, mcposaVirtualOutput);
  mcposrVirtualOutput = rot_apply(mcrotaVirtualOutput, mctc1);
  mcDEBUG_COMPONENT("VirtualOutput", mcposaVirtualOutput, mcrotaVirtualOutput)
  mccomp_posa[60] = mcposaVirtualOutput;
  mccomp_posr[60] = mcposrVirtualOutput;
  mcNCounter[60]  = mcPCounter[60] = mcP2Counter[60] = 0;
  mcAbsorbProp[60]= 0;
    /* Component DiwJaw0. */
  /* Setting parameters for component DiwJaw0. */
  SIG_MESSAGE("DiwJaw0 (Init:SetPar)");
#line 46 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw0_xmin = 0;
#line 46 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw0_xmax = 0;
#line 46 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw0_ymin = 0;
#line 46 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw0_ymax = 0;
#line 46 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw0_radius = 0;
#line 1578 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw0_xwidth = mcipDivSlit0_width;
#line 1578 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDiwJaw0_yheight = 1;
#line 26766 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("DiwJaw0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26773 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaEndOfelement_2, mcrotaDiwJaw0);
  rot_transpose(mcrotaVirtualOutput, mctr1);
  rot_mul(mcrotaDiwJaw0, mctr1, mcrotrDiwJaw0);
  mctc1 = coords_set(
#line 1579 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1579 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1579 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    7 * u + length1 + DivSlit0Gap / 2.0);
#line 26784 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaEndOfelement_2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDiwJaw0 = coords_add(mcposaEndOfelement_2, mctc2);
  mctc1 = coords_sub(mcposaVirtualOutput, mcposaDiwJaw0);
  mcposrDiwJaw0 = rot_apply(mcrotaDiwJaw0, mctc1);
  mcDEBUG_COMPONENT("DiwJaw0", mcposaDiwJaw0, mcrotaDiwJaw0)
  mccomp_posa[61] = mcposaDiwJaw0;
  mccomp_posr[61] = mcposrDiwJaw0;
  mcNCounter[61]  = mcPCounter[61] = mcP2Counter[61] = 0;
  mcAbsorbProp[61]= 0;
    /* Component log_P_stop. */
  /* Setting parameters for component log_P_stop. */
  SIG_MESSAGE("log_P_stop (Init:SetPar)");

  SIG_MESSAGE("log_P_stop (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26804 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaDiwJaw0, mcrotalog_P_stop);
  rot_transpose(mcrotaDiwJaw0, mctr1);
  rot_mul(mcrotalog_P_stop, mctr1, mcrotrlog_P_stop);
  mctc1 = coords_set(
#line 1594 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1594 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1594 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 26815 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaDiwJaw0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposalog_P_stop = coords_add(mcposaDiwJaw0, mctc2);
  mctc1 = coords_sub(mcposaDiwJaw0, mcposalog_P_stop);
  mcposrlog_P_stop = rot_apply(mcrotalog_P_stop, mctc1);
  mcDEBUG_COMPONENT("log_P_stop", mcposalog_P_stop, mcrotalog_P_stop)
  mccomp_posa[62] = mcposalog_P_stop;
  mccomp_posr[62] = mcposrlog_P_stop;
  mcNCounter[62]  = mcPCounter[62] = mcP2Counter[62] = 0;
  mcAbsorbProp[62]= 0;
    /* Component arm_iter_P1_start. */
  /* Setting parameters for component arm_iter_P1_start. */
  SIG_MESSAGE("arm_iter_P1_start (Init:SetPar)");

  SIG_MESSAGE("arm_iter_P1_start (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26835 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaESS_source, mcrotaarm_iter_P1_start);
  rot_transpose(mcrotalog_P_stop, mctr1);
  rot_mul(mcrotaarm_iter_P1_start, mctr1, mcrotrarm_iter_P1_start);
  mctc1 = coords_set(
#line 1605 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1605 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1605 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 26846 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaESS_source, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaarm_iter_P1_start = coords_add(mcposaESS_source, mctc2);
  mctc1 = coords_sub(mcposalog_P_stop, mcposaarm_iter_P1_start);
  mcposrarm_iter_P1_start = rot_apply(mcrotaarm_iter_P1_start, mctc1);
  mcDEBUG_COMPONENT("arm_iter_P1_start", mcposaarm_iter_P1_start, mcrotaarm_iter_P1_start)
  mccomp_posa[63] = mcposaarm_iter_P1_start;
  mccomp_posr[63] = mcposrarm_iter_P1_start;
  mcNCounter[63]  = mcPCounter[63] = mcP2Counter[63] = 0;
  mcAbsorbProp[63]= 0;
    /* Component iter_P1_start. */
  /* Setting parameters for component iter_P1_start. */
  SIG_MESSAGE("iter_P1_start (Init:SetPar)");

  SIG_MESSAGE("iter_P1_start (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26866 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaESS_source, mcrotaiter_P1_start);
  rot_transpose(mcrotaarm_iter_P1_start, mctr1);
  rot_mul(mcrotaiter_P1_start, mctr1, mcrotriter_P1_start);
  mctc1 = coords_set(
#line 1608 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1608 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1608 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 26877 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaESS_source, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaiter_P1_start = coords_add(mcposaESS_source, mctc2);
  mctc1 = coords_sub(mcposaarm_iter_P1_start, mcposaiter_P1_start);
  mcposriter_P1_start = rot_apply(mcrotaiter_P1_start, mctc1);
  mcDEBUG_COMPONENT("iter_P1_start", mcposaiter_P1_start, mcrotaiter_P1_start)
  mccomp_posa[64] = mcposaiter_P1_start;
  mccomp_posr[64] = mcposriter_P1_start;
  mcNCounter[64]  = mcPCounter[64] = mcP2Counter[64] = 0;
  mcAbsorbProp[64]= 0;
    /* Component arm_iter_P1_dummy. */
  /* Setting parameters for component arm_iter_P1_dummy. */
  SIG_MESSAGE("arm_iter_P1_dummy (Init:SetPar)");

  SIG_MESSAGE("arm_iter_P1_dummy (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26897 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaiter_P1_start, mcrotaarm_iter_P1_dummy);
  rot_transpose(mcrotaiter_P1_start, mctr1);
  rot_mul(mcrotaarm_iter_P1_dummy, mctr1, mcrotrarm_iter_P1_dummy);
  mctc1 = coords_set(
#line 1621 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1621 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1621 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 26908 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaiter_P1_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaarm_iter_P1_dummy = coords_add(mcposaiter_P1_start, mctc2);
  mctc1 = coords_sub(mcposaiter_P1_start, mcposaarm_iter_P1_dummy);
  mcposrarm_iter_P1_dummy = rot_apply(mcrotaarm_iter_P1_dummy, mctc1);
  mcDEBUG_COMPONENT("arm_iter_P1_dummy", mcposaarm_iter_P1_dummy, mcrotaarm_iter_P1_dummy)
  mccomp_posa[65] = mcposaarm_iter_P1_dummy;
  mccomp_posr[65] = mcposrarm_iter_P1_dummy;
  mcNCounter[65]  = mcPCounter[65] = mcP2Counter[65] = 0;
  mcAbsorbProp[65]= 0;
    /* Component mndP01. */
  /* Setting parameters for component mndP01. */
  SIG_MESSAGE("mndP01 (Init:SetPar)");
#line 203 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP01_xwidth = 0;
#line 203 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP01_yheight = 0;
#line 203 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP01_zdepth = 0;
#line 204 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP01_xmin = 0;
#line 204 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP01_xmax = 0;
#line 204 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP01_ymin = 0;
#line 204 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP01_ymax = 0;
#line 1624 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP01_zmin = 25.0;
#line 1625 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP01_zmax = 150;
#line 1626 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP01_bins = 250;
#line 205 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP01_min = -1e40;
#line 205 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP01_max = 1e40;
#line 1624 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP01_restore_neutron = 1;
#line 205 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP01_radius = 0;
#line 1626 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("previous no slit  z ") strncpy(mccmndP01_options, "previous no slit  z " ? "previous no slit  z " : "", 16384); else mccmndP01_options[0]='\0';
#line 1626 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NiCapture.dat") strncpy(mccmndP01_filename, "NiCapture.dat" ? "NiCapture.dat" : "", 16384); else mccmndP01_filename[0]='\0';
#line 206 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mccmndP01_geometry, "NULL" ? "NULL" : "", 16384); else mccmndP01_geometry[0]='\0';
#line 207 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mccmndP01_username1, "NULL" ? "NULL" : "", 16384); else mccmndP01_username1[0]='\0';
#line 207 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mccmndP01_username2, "NULL" ? "NULL" : "", 16384); else mccmndP01_username2[0]='\0';
#line 207 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mccmndP01_username3, "NULL" ? "NULL" : "", 16384); else mccmndP01_username3[0]='\0';
#line 208 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP01_nowritefile = 0;
#line 26964 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("mndP01 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26971 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaESS_source, mcrotamndP01);
  rot_transpose(mcrotaarm_iter_P1_dummy, mctr1);
  rot_mul(mcrotamndP01, mctr1, mcrotrmndP01);
  mctc1 = coords_set(
#line 1627 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1627 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1627 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 26982 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaESS_source, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamndP01 = coords_add(mcposaESS_source, mctc2);
  mctc1 = coords_sub(mcposaarm_iter_P1_dummy, mcposamndP01);
  mcposrmndP01 = rot_apply(mcrotamndP01, mctc1);
  mcDEBUG_COMPONENT("mndP01", mcposamndP01, mcrotamndP01)
  mccomp_posa[66] = mcposamndP01;
  mccomp_posr[66] = mcposrmndP01;
  mcNCounter[66]  = mcPCounter[66] = mcP2Counter[66] = 0;
  mcAbsorbProp[66]= 0;
    /* Component arm_iter_P1_stop. */
  /* Setting parameters for component arm_iter_P1_stop. */
  SIG_MESSAGE("arm_iter_P1_stop (Init:SetPar)");

  SIG_MESSAGE("arm_iter_P1_stop (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27002 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotamndP01, mcrotaarm_iter_P1_stop);
  rot_transpose(mcrotamndP01, mctr1);
  rot_mul(mcrotaarm_iter_P1_stop, mctr1, mcrotrarm_iter_P1_stop);
  mctc1 = coords_set(
#line 1630 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1630 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1630 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27013 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotamndP01, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaarm_iter_P1_stop = coords_add(mcposamndP01, mctc2);
  mctc1 = coords_sub(mcposamndP01, mcposaarm_iter_P1_stop);
  mcposrarm_iter_P1_stop = rot_apply(mcrotaarm_iter_P1_stop, mctc1);
  mcDEBUG_COMPONENT("arm_iter_P1_stop", mcposaarm_iter_P1_stop, mcrotaarm_iter_P1_stop)
  mccomp_posa[67] = mcposaarm_iter_P1_stop;
  mccomp_posr[67] = mcposrarm_iter_P1_stop;
  mcNCounter[67]  = mcPCounter[67] = mcP2Counter[67] = 0;
  mcAbsorbProp[67]= 0;
    /* Component iter_P1_stop. */
  /* Setting parameters for component iter_P1_stop. */
  SIG_MESSAGE("iter_P1_stop (Init:SetPar)");
#line 40 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcciter_P1_stop_last = 0;
#line 27029 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("iter_P1_stop (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27036 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaESS_source, mcrotaiter_P1_stop);
  rot_transpose(mcrotaarm_iter_P1_stop, mctr1);
  rot_mul(mcrotaiter_P1_stop, mctr1, mcrotriter_P1_stop);
  mctc1 = coords_set(
#line 1633 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1633 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1633 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27047 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaESS_source, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaiter_P1_stop = coords_add(mcposaESS_source, mctc2);
  mctc1 = coords_sub(mcposaarm_iter_P1_stop, mcposaiter_P1_stop);
  mcposriter_P1_stop = rot_apply(mcrotaiter_P1_stop, mctc1);
  mcDEBUG_COMPONENT("iter_P1_stop", mcposaiter_P1_stop, mcrotaiter_P1_stop)
  mccomp_posa[68] = mcposaiter_P1_stop;
  mccomp_posr[68] = mcposriter_P1_stop;
  mcNCounter[68]  = mcPCounter[68] = mcP2Counter[68] = 0;
  mcAbsorbProp[68]= 0;
    /* Component a11i. */
  /* Setting parameters for component a11i. */
  SIG_MESSAGE("a11i (Init:SetPar)");

  SIG_MESSAGE("a11i (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27067 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaEndOfelement_1, mcrotaa11i);
  rot_transpose(mcrotaiter_P1_stop, mctr1);
  rot_mul(mcrotaa11i, mctr1, mcrotra11i);
  mctc1 = coords_set(
#line 1639 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1639 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1639 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27078 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaEndOfelement_1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaa11i = coords_add(mcposaEndOfelement_1, mctc2);
  mctc1 = coords_sub(mcposaiter_P1_stop, mcposaa11i);
  mcposra11i = rot_apply(mcrotaa11i, mctc1);
  mcDEBUG_COMPONENT("a11i", mcposaa11i, mcrotaa11i)
  mccomp_posa[69] = mcposaa11i;
  mccomp_posr[69] = mcposra11i;
  mcNCounter[69]  = mcPCounter[69] = mcP2Counter[69] = 0;
  mcAbsorbProp[69]= 0;
    /* Component arm_iter_P2_start. */
  /* Setting parameters for component arm_iter_P2_start. */
  SIG_MESSAGE("arm_iter_P2_start (Init:SetPar)");

  SIG_MESSAGE("arm_iter_P2_start (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27098 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaESS_source, mcrotaarm_iter_P2_start);
  rot_transpose(mcrotaa11i, mctr1);
  rot_mul(mcrotaarm_iter_P2_start, mctr1, mcrotrarm_iter_P2_start);
  mctc1 = coords_set(
#line 1650 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1650 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1650 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27109 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaESS_source, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaarm_iter_P2_start = coords_add(mcposaESS_source, mctc2);
  mctc1 = coords_sub(mcposaa11i, mcposaarm_iter_P2_start);
  mcposrarm_iter_P2_start = rot_apply(mcrotaarm_iter_P2_start, mctc1);
  mcDEBUG_COMPONENT("arm_iter_P2_start", mcposaarm_iter_P2_start, mcrotaarm_iter_P2_start)
  mccomp_posa[70] = mcposaarm_iter_P2_start;
  mccomp_posr[70] = mcposrarm_iter_P2_start;
  mcNCounter[70]  = mcPCounter[70] = mcP2Counter[70] = 0;
  mcAbsorbProp[70]= 0;
    /* Component iter_P2_start. */
  /* Setting parameters for component iter_P2_start. */
  SIG_MESSAGE("iter_P2_start (Init:SetPar)");

  SIG_MESSAGE("iter_P2_start (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27129 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaESS_source, mcrotaiter_P2_start);
  rot_transpose(mcrotaarm_iter_P2_start, mctr1);
  rot_mul(mcrotaiter_P2_start, mctr1, mcrotriter_P2_start);
  mctc1 = coords_set(
#line 1653 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1653 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1653 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27140 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaESS_source, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaiter_P2_start = coords_add(mcposaESS_source, mctc2);
  mctc1 = coords_sub(mcposaarm_iter_P2_start, mcposaiter_P2_start);
  mcposriter_P2_start = rot_apply(mcrotaiter_P2_start, mctc1);
  mcDEBUG_COMPONENT("iter_P2_start", mcposaiter_P2_start, mcrotaiter_P2_start)
  mccomp_posa[71] = mcposaiter_P2_start;
  mccomp_posr[71] = mcposriter_P2_start;
  mcNCounter[71]  = mcPCounter[71] = mcP2Counter[71] = 0;
  mcAbsorbProp[71]= 0;
    /* Component arm_iter_P2_dummy. */
  /* Setting parameters for component arm_iter_P2_dummy. */
  SIG_MESSAGE("arm_iter_P2_dummy (Init:SetPar)");

  SIG_MESSAGE("arm_iter_P2_dummy (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27160 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaiter_P2_start, mcrotaarm_iter_P2_dummy);
  rot_transpose(mcrotaiter_P2_start, mctr1);
  rot_mul(mcrotaarm_iter_P2_dummy, mctr1, mcrotrarm_iter_P2_dummy);
  mctc1 = coords_set(
#line 1666 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1666 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1666 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27171 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaiter_P2_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaarm_iter_P2_dummy = coords_add(mcposaiter_P2_start, mctc2);
  mctc1 = coords_sub(mcposaiter_P2_start, mcposaarm_iter_P2_dummy);
  mcposrarm_iter_P2_dummy = rot_apply(mcrotaarm_iter_P2_dummy, mctc1);
  mcDEBUG_COMPONENT("arm_iter_P2_dummy", mcposaarm_iter_P2_dummy, mcrotaarm_iter_P2_dummy)
  mccomp_posa[72] = mcposaarm_iter_P2_dummy;
  mccomp_posr[72] = mcposrarm_iter_P2_dummy;
  mcNCounter[72]  = mcPCounter[72] = mcP2Counter[72] = 0;
  mcAbsorbProp[72]= 0;
    /* Component mndP02. */
  /* Setting parameters for component mndP02. */
  SIG_MESSAGE("mndP02 (Init:SetPar)");
#line 203 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP02_xwidth = 0;
#line 203 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP02_yheight = 0;
#line 203 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP02_zdepth = 0;
#line 204 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP02_xmin = 0;
#line 204 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP02_xmax = 0;
#line 204 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP02_ymin = 0;
#line 204 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP02_ymax = 0;
#line 1669 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP02_zmin = 25.0;
#line 1670 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP02_zmax = 150.0;
#line 1671 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP02_bins = 250;
#line 205 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP02_min = -1e40;
#line 205 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP02_max = 1e40;
#line 1669 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP02_restore_neutron = 1;
#line 205 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP02_radius = 0;
#line 1671 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("previous no slit  z ") strncpy(mccmndP02_options, "previous no slit  z " ? "previous no slit  z " : "", 16384); else mccmndP02_options[0]='\0';
#line 1671 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("TiCapture.dat") strncpy(mccmndP02_filename, "TiCapture.dat" ? "TiCapture.dat" : "", 16384); else mccmndP02_filename[0]='\0';
#line 206 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mccmndP02_geometry, "NULL" ? "NULL" : "", 16384); else mccmndP02_geometry[0]='\0';
#line 207 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mccmndP02_username1, "NULL" ? "NULL" : "", 16384); else mccmndP02_username1[0]='\0';
#line 207 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mccmndP02_username2, "NULL" ? "NULL" : "", 16384); else mccmndP02_username2[0]='\0';
#line 207 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mccmndP02_username3, "NULL" ? "NULL" : "", 16384); else mccmndP02_username3[0]='\0';
#line 208 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP02_nowritefile = 0;
#line 27227 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("mndP02 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27234 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaESS_source, mcrotamndP02);
  rot_transpose(mcrotaarm_iter_P2_dummy, mctr1);
  rot_mul(mcrotamndP02, mctr1, mcrotrmndP02);
  mctc1 = coords_set(
#line 1672 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1672 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1672 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27245 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaESS_source, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamndP02 = coords_add(mcposaESS_source, mctc2);
  mctc1 = coords_sub(mcposaarm_iter_P2_dummy, mcposamndP02);
  mcposrmndP02 = rot_apply(mcrotamndP02, mctc1);
  mcDEBUG_COMPONENT("mndP02", mcposamndP02, mcrotamndP02)
  mccomp_posa[73] = mcposamndP02;
  mccomp_posr[73] = mcposrmndP02;
  mcNCounter[73]  = mcPCounter[73] = mcP2Counter[73] = 0;
  mcAbsorbProp[73]= 0;
    /* Component arm_iter_P2_stop. */
  /* Setting parameters for component arm_iter_P2_stop. */
  SIG_MESSAGE("arm_iter_P2_stop (Init:SetPar)");

  SIG_MESSAGE("arm_iter_P2_stop (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27265 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotamndP02, mcrotaarm_iter_P2_stop);
  rot_transpose(mcrotamndP02, mctr1);
  rot_mul(mcrotaarm_iter_P2_stop, mctr1, mcrotrarm_iter_P2_stop);
  mctc1 = coords_set(
#line 1675 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1675 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1675 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27276 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotamndP02, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaarm_iter_P2_stop = coords_add(mcposamndP02, mctc2);
  mctc1 = coords_sub(mcposamndP02, mcposaarm_iter_P2_stop);
  mcposrarm_iter_P2_stop = rot_apply(mcrotaarm_iter_P2_stop, mctc1);
  mcDEBUG_COMPONENT("arm_iter_P2_stop", mcposaarm_iter_P2_stop, mcrotaarm_iter_P2_stop)
  mccomp_posa[74] = mcposaarm_iter_P2_stop;
  mccomp_posr[74] = mcposrarm_iter_P2_stop;
  mcNCounter[74]  = mcPCounter[74] = mcP2Counter[74] = 0;
  mcAbsorbProp[74]= 0;
    /* Component iter_P2_stop. */
  /* Setting parameters for component iter_P2_stop. */
  SIG_MESSAGE("iter_P2_stop (Init:SetPar)");
#line 40 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcciter_P2_stop_last = 0;
#line 27292 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("iter_P2_stop (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27299 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaESS_source, mcrotaiter_P2_stop);
  rot_transpose(mcrotaarm_iter_P2_stop, mctr1);
  rot_mul(mcrotaiter_P2_stop, mctr1, mcrotriter_P2_stop);
  mctc1 = coords_set(
#line 1678 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1678 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1678 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27310 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaESS_source, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaiter_P2_stop = coords_add(mcposaESS_source, mctc2);
  mctc1 = coords_sub(mcposaarm_iter_P2_stop, mcposaiter_P2_stop);
  mcposriter_P2_stop = rot_apply(mcrotaiter_P2_stop, mctc1);
  mcDEBUG_COMPONENT("iter_P2_stop", mcposaiter_P2_stop, mcrotaiter_P2_stop)
  mccomp_posa[75] = mcposaiter_P2_stop;
  mccomp_posr[75] = mcposriter_P2_stop;
  mcNCounter[75]  = mcPCounter[75] = mcP2Counter[75] = 0;
  mcAbsorbProp[75]= 0;
    /* Component a12i. */
  /* Setting parameters for component a12i. */
  SIG_MESSAGE("a12i (Init:SetPar)");

  SIG_MESSAGE("a12i (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27330 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaEndOfelement_1, mcrotaa12i);
  rot_transpose(mcrotaiter_P2_stop, mctr1);
  rot_mul(mcrotaa12i, mctr1, mcrotra12i);
  mctc1 = coords_set(
#line 1684 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1684 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1684 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27341 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaEndOfelement_1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaa12i = coords_add(mcposaEndOfelement_1, mctc2);
  mctc1 = coords_sub(mcposaiter_P2_stop, mcposaa12i);
  mcposra12i = rot_apply(mcrotaa12i, mctc1);
  mcDEBUG_COMPONENT("a12i", mcposaa12i, mcrotaa12i)
  mccomp_posa[76] = mcposaa12i;
  mccomp_posr[76] = mcposra12i;
  mcNCounter[76]  = mcPCounter[76] = mcP2Counter[76] = 0;
  mcAbsorbProp[76]= 0;
    /* Component arm_iter_P3_start. */
  /* Setting parameters for component arm_iter_P3_start. */
  SIG_MESSAGE("arm_iter_P3_start (Init:SetPar)");

  SIG_MESSAGE("arm_iter_P3_start (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27361 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaESS_source, mcrotaarm_iter_P3_start);
  rot_transpose(mcrotaa12i, mctr1);
  rot_mul(mcrotaarm_iter_P3_start, mctr1, mcrotrarm_iter_P3_start);
  mctc1 = coords_set(
#line 1692 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1692 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1692 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27372 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaESS_source, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaarm_iter_P3_start = coords_add(mcposaESS_source, mctc2);
  mctc1 = coords_sub(mcposaa12i, mcposaarm_iter_P3_start);
  mcposrarm_iter_P3_start = rot_apply(mcrotaarm_iter_P3_start, mctc1);
  mcDEBUG_COMPONENT("arm_iter_P3_start", mcposaarm_iter_P3_start, mcrotaarm_iter_P3_start)
  mccomp_posa[77] = mcposaarm_iter_P3_start;
  mccomp_posr[77] = mcposrarm_iter_P3_start;
  mcNCounter[77]  = mcPCounter[77] = mcP2Counter[77] = 0;
  mcAbsorbProp[77]= 0;
    /* Component iter_P3_start. */
  /* Setting parameters for component iter_P3_start. */
  SIG_MESSAGE("iter_P3_start (Init:SetPar)");

  SIG_MESSAGE("iter_P3_start (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27392 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaESS_source, mcrotaiter_P3_start);
  rot_transpose(mcrotaarm_iter_P3_start, mctr1);
  rot_mul(mcrotaiter_P3_start, mctr1, mcrotriter_P3_start);
  mctc1 = coords_set(
#line 1695 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1695 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1695 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27403 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaESS_source, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaiter_P3_start = coords_add(mcposaESS_source, mctc2);
  mctc1 = coords_sub(mcposaarm_iter_P3_start, mcposaiter_P3_start);
  mcposriter_P3_start = rot_apply(mcrotaiter_P3_start, mctc1);
  mcDEBUG_COMPONENT("iter_P3_start", mcposaiter_P3_start, mcrotaiter_P3_start)
  mccomp_posa[78] = mcposaiter_P3_start;
  mccomp_posr[78] = mcposriter_P3_start;
  mcNCounter[78]  = mcPCounter[78] = mcP2Counter[78] = 0;
  mcAbsorbProp[78]= 0;
    /* Component arm_iter_P3_dummy. */
  /* Setting parameters for component arm_iter_P3_dummy. */
  SIG_MESSAGE("arm_iter_P3_dummy (Init:SetPar)");

  SIG_MESSAGE("arm_iter_P3_dummy (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27423 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaiter_P3_start, mcrotaarm_iter_P3_dummy);
  rot_transpose(mcrotaiter_P3_start, mctr1);
  rot_mul(mcrotaarm_iter_P3_dummy, mctr1, mcrotrarm_iter_P3_dummy);
  mctc1 = coords_set(
#line 1708 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1708 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1708 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27434 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaiter_P3_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaarm_iter_P3_dummy = coords_add(mcposaiter_P3_start, mctc2);
  mctc1 = coords_sub(mcposaiter_P3_start, mcposaarm_iter_P3_dummy);
  mcposrarm_iter_P3_dummy = rot_apply(mcrotaarm_iter_P3_dummy, mctc1);
  mcDEBUG_COMPONENT("arm_iter_P3_dummy", mcposaarm_iter_P3_dummy, mcrotaarm_iter_P3_dummy)
  mccomp_posa[79] = mcposaarm_iter_P3_dummy;
  mccomp_posr[79] = mcposrarm_iter_P3_dummy;
  mcNCounter[79]  = mcPCounter[79] = mcP2Counter[79] = 0;
  mcAbsorbProp[79]= 0;
    /* Component mndP03. */
  /* Setting parameters for component mndP03. */
  SIG_MESSAGE("mndP03 (Init:SetPar)");
#line 203 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP03_xwidth = 0;
#line 203 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP03_yheight = 0;
#line 203 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP03_zdepth = 0;
#line 204 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP03_xmin = 0;
#line 204 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP03_xmax = 0;
#line 204 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP03_ymin = 0;
#line 204 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP03_ymax = 0;
#line 1711 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP03_zmin = 25.0;
#line 1712 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP03_zmax = 150.0;
#line 1713 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP03_bins = 250;
#line 205 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP03_min = -1e40;
#line 205 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP03_max = 1e40;
#line 1711 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP03_restore_neutron = 1;
#line 205 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP03_radius = 0;
#line 1713 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("previous no slit  z ") strncpy(mccmndP03_options, "previous no slit  z " ? "previous no slit  z " : "", 16384); else mccmndP03_options[0]='\0';
#line 1713 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("TotalCapture.dat") strncpy(mccmndP03_filename, "TotalCapture.dat" ? "TotalCapture.dat" : "", 16384); else mccmndP03_filename[0]='\0';
#line 206 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mccmndP03_geometry, "NULL" ? "NULL" : "", 16384); else mccmndP03_geometry[0]='\0';
#line 207 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mccmndP03_username1, "NULL" ? "NULL" : "", 16384); else mccmndP03_username1[0]='\0';
#line 207 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mccmndP03_username2, "NULL" ? "NULL" : "", 16384); else mccmndP03_username2[0]='\0';
#line 207 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NULL") strncpy(mccmndP03_username3, "NULL" ? "NULL" : "", 16384); else mccmndP03_username3[0]='\0';
#line 208 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccmndP03_nowritefile = 0;
#line 27490 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("mndP03 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27497 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaESS_source, mcrotamndP03);
  rot_transpose(mcrotaarm_iter_P3_dummy, mctr1);
  rot_mul(mcrotamndP03, mctr1, mcrotrmndP03);
  mctc1 = coords_set(
#line 1714 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1714 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1714 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27508 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaESS_source, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamndP03 = coords_add(mcposaESS_source, mctc2);
  mctc1 = coords_sub(mcposaarm_iter_P3_dummy, mcposamndP03);
  mcposrmndP03 = rot_apply(mcrotamndP03, mctc1);
  mcDEBUG_COMPONENT("mndP03", mcposamndP03, mcrotamndP03)
  mccomp_posa[80] = mcposamndP03;
  mccomp_posr[80] = mcposrmndP03;
  mcNCounter[80]  = mcPCounter[80] = mcP2Counter[80] = 0;
  mcAbsorbProp[80]= 0;
    /* Component arm_iter_P3_stop. */
  /* Setting parameters for component arm_iter_P3_stop. */
  SIG_MESSAGE("arm_iter_P3_stop (Init:SetPar)");

  SIG_MESSAGE("arm_iter_P3_stop (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27528 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotamndP03, mcrotaarm_iter_P3_stop);
  rot_transpose(mcrotamndP03, mctr1);
  rot_mul(mcrotaarm_iter_P3_stop, mctr1, mcrotrarm_iter_P3_stop);
  mctc1 = coords_set(
#line 1717 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1717 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1717 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27539 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotamndP03, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaarm_iter_P3_stop = coords_add(mcposamndP03, mctc2);
  mctc1 = coords_sub(mcposamndP03, mcposaarm_iter_P3_stop);
  mcposrarm_iter_P3_stop = rot_apply(mcrotaarm_iter_P3_stop, mctc1);
  mcDEBUG_COMPONENT("arm_iter_P3_stop", mcposaarm_iter_P3_stop, mcrotaarm_iter_P3_stop)
  mccomp_posa[81] = mcposaarm_iter_P3_stop;
  mccomp_posr[81] = mcposrarm_iter_P3_stop;
  mcNCounter[81]  = mcPCounter[81] = mcP2Counter[81] = 0;
  mcAbsorbProp[81]= 0;
    /* Component iter_P3_stop. */
  /* Setting parameters for component iter_P3_stop. */
  SIG_MESSAGE("iter_P3_stop (Init:SetPar)");
#line 1719 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mcciter_P3_stop_last = 1;
#line 27555 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("iter_P3_stop (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27562 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaESS_source, mcrotaiter_P3_stop);
  rot_transpose(mcrotaarm_iter_P3_stop, mctr1);
  rot_mul(mcrotaiter_P3_stop, mctr1, mcrotriter_P3_stop);
  mctc1 = coords_set(
#line 1720 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1720 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1720 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27573 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaESS_source, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaiter_P3_stop = coords_add(mcposaESS_source, mctc2);
  mctc1 = coords_sub(mcposaarm_iter_P3_stop, mcposaiter_P3_stop);
  mcposriter_P3_stop = rot_apply(mcrotaiter_P3_stop, mctc1);
  mcDEBUG_COMPONENT("iter_P3_stop", mcposaiter_P3_stop, mcrotaiter_P3_stop)
  mccomp_posa[82] = mcposaiter_P3_stop;
  mccomp_posr[82] = mcposriter_P3_stop;
  mcNCounter[82]  = mcPCounter[82] = mcP2Counter[82] = 0;
  mcAbsorbProp[82]= 0;
    /* Component a13i. */
  /* Setting parameters for component a13i. */
  SIG_MESSAGE("a13i (Init:SetPar)");

  SIG_MESSAGE("a13i (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27593 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaEndOfelement_1, mcrotaa13i);
  rot_transpose(mcrotaiter_P3_stop, mctr1);
  rot_mul(mcrotaa13i, mctr1, mcrotra13i);
  mctc1 = coords_set(
#line 1726 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1726 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1726 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27604 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaEndOfelement_1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaa13i = coords_add(mcposaEndOfelement_1, mctc2);
  mctc1 = coords_sub(mcposaiter_P3_stop, mcposaa13i);
  mcposra13i = rot_apply(mcrotaa13i, mctc1);
  mcDEBUG_COMPONENT("a13i", mcposaa13i, mcrotaa13i)
  mccomp_posa[83] = mcposaa13i;
  mccomp_posr[83] = mcposra13i;
  mcNCounter[83]  = mcPCounter[83] = mcP2Counter[83] = 0;
  mcAbsorbProp[83]= 0;
    /* Component Beamstop. */
  /* Setting parameters for component Beamstop. */
  SIG_MESSAGE("Beamstop (Init:SetPar)");
#line 44 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccBeamstop_xmin = -0.05;
#line 44 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccBeamstop_xmax = 0.05;
#line 44 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccBeamstop_ymin = -0.05;
#line 44 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccBeamstop_ymax = 0.05;
#line 45 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccBeamstop_xwidth = 0;
#line 45 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccBeamstop_yheight = 0;
#line 45 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccBeamstop_radius = 0;
#line 27632 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("Beamstop (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27639 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaEndOfelement_1, mcrotaBeamstop);
  rot_transpose(mcrotaa13i, mctr1);
  rot_mul(mcrotaBeamstop, mctr1, mcrotrBeamstop);
  mctc1 = coords_set(
#line 1735 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1735 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1735 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0.01);
#line 27650 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaEndOfelement_1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaBeamstop = coords_add(mcposaEndOfelement_1, mctc2);
  mctc1 = coords_sub(mcposaa13i, mcposaBeamstop);
  mcposrBeamstop = rot_apply(mcrotaBeamstop, mctc1);
  mcDEBUG_COMPONENT("Beamstop", mcposaBeamstop, mcrotaBeamstop)
  mccomp_posa[84] = mcposaBeamstop;
  mccomp_posr[84] = mcposrBeamstop;
  mcNCounter[84]  = mcPCounter[84] = mcP2Counter[84] = 0;
  mcAbsorbProp[84]= 0;
    /* Component Lmon_guide_end. */
  /* Setting parameters for component Lmon_guide_end. */
  SIG_MESSAGE("Lmon_guide_end (Init:SetPar)");
#line 1740 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("Lmon_guide_end") strncpy(mccLmon_guide_end_filename, "Lmon_guide_end" ? "Lmon_guide_end" : "", 16384); else mccLmon_guide_end_filename[0]='\0';
#line 50 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccLmon_guide_end_xmin = -0.05;
#line 50 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccLmon_guide_end_xmax = 0.05;
#line 50 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccLmon_guide_end_ymin = -0.05;
#line 50 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccLmon_guide_end_ymax = 0.05;
#line 1740 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccLmon_guide_end_xwidth = 0.027704;
#line 1741 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccLmon_guide_end_yheight = 0.027704;
#line 1741 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccLmon_guide_end_Lmin = 0.100000;
#line 1741 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccLmon_guide_end_Lmax = 8.000000;
#line 1740 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccLmon_guide_end_restore_neutron = 1;
#line 51 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccLmon_guide_end_nowritefile = 0;
#line 27686 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("Lmon_guide_end (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27693 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaBeamstop, mcrotaLmon_guide_end);
  rot_transpose(mcrotaBeamstop, mctr1);
  rot_mul(mcrotaLmon_guide_end, mctr1, mcrotrLmon_guide_end);
  mctc1 = coords_set(
#line 1742 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1742 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1742 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    u);
#line 27704 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaBeamstop, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaLmon_guide_end = coords_add(mcposaBeamstop, mctc2);
  mctc1 = coords_sub(mcposaBeamstop, mcposaLmon_guide_end);
  mcposrLmon_guide_end = rot_apply(mcrotaLmon_guide_end, mctc1);
  mcDEBUG_COMPONENT("Lmon_guide_end", mcposaLmon_guide_end, mcrotaLmon_guide_end)
  mccomp_posa[85] = mcposaLmon_guide_end;
  mccomp_posr[85] = mcposrLmon_guide_end;
  mcNCounter[85]  = mcPCounter[85] = mcP2Counter[85] = 0;
  mcAbsorbProp[85]= 0;
    /* Component SCalc. */
  /* Setting parameters for component SCalc. */
  SIG_MESSAGE("SCalc (Init:SetPar)");
#line 1848 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccSCalc_MaxRate = 1.0;
#line 1848 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccSCalc_Innerspace = 0.5;
#line 1848 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NiCapture.dat") strncpy(mccSCalc_NiCaptureFile, "NiCapture.dat" ? "NiCapture.dat" : "", 16384); else mccSCalc_NiCaptureFile[0]='\0';
#line 1848 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("TiCapture.dat") strncpy(mccSCalc_TiCaptureFile, "TiCapture.dat" ? "TiCapture.dat" : "", 16384); else mccSCalc_TiCaptureFile[0]='\0';
#line 1848 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("TotalCapture.dat") strncpy(mccSCalc_TotalCaptureFile, "TotalCapture.dat" ? "TotalCapture.dat" : "", 16384); else mccSCalc_TotalCaptureFile[0]='\0';
#line 1848 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("Shielding.dat") strncpy(mccSCalc_OutputFile, "Shielding.dat" ? "Shielding.dat" : "", 16384); else mccSCalc_OutputFile[0]='\0';
#line 27730 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("SCalc (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27737 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaLmon_guide_end, mcrotaSCalc);
  rot_transpose(mcrotaLmon_guide_end, mctr1);
  rot_mul(mcrotaSCalc, mctr1, mcrotrSCalc);
  mctc1 = coords_set(
#line 1849 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1849 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1849 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27748 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaLmon_guide_end, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaSCalc = coords_add(mcposaLmon_guide_end, mctc2);
  mctc1 = coords_sub(mcposaLmon_guide_end, mcposaSCalc);
  mcposrSCalc = rot_apply(mcrotaSCalc, mctc1);
  mcDEBUG_COMPONENT("SCalc", mcposaSCalc, mcrotaSCalc)
  mccomp_posa[86] = mcposaSCalc;
  mccomp_posr[86] = mcposrSCalc;
  mcNCounter[86]  = mcPCounter[86] = mcP2Counter[86] = 0;
  mcAbsorbProp[86]= 0;
    /* Component DoseFe. */
  /* Setting parameters for component DoseFe. */
  SIG_MESSAGE("DoseFe (Init:SetPar)");
#line 1854 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("Fe") strncpy(mccDoseFe_Material, "Fe" ? "Fe" : "", 16384); else mccDoseFe_Material[0]='\0';
#line 1854 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDoseFe_Innerspace = 0.4;
#line 1854 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDoseFe_Thickness = 0.2;
#line 37 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("") strncpy(mccDoseFe_SteelTubing, "" ? "" : "", 16384); else mccDoseFe_SteelTubing[0]='\0';
#line 37 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDoseFe_TubingThickness = 0.0;
#line 1854 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NiCapture.dat") strncpy(mccDoseFe_NiCaptureFile, "NiCapture.dat" ? "NiCapture.dat" : "", 16384); else mccDoseFe_NiCaptureFile[0]='\0';
#line 1854 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("TiCapture.dat") strncpy(mccDoseFe_TiCaptureFile, "TiCapture.dat" ? "TiCapture.dat" : "", 16384); else mccDoseFe_TiCaptureFile[0]='\0';
#line 1854 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("TotalCapture.dat") strncpy(mccDoseFe_TotalCaptureFile, "TotalCapture.dat" ? "TotalCapture.dat" : "", 16384); else mccDoseFe_TotalCaptureFile[0]='\0';
#line 1854 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("DoseFe.dat") strncpy(mccDoseFe_OutputFile, "DoseFe.dat" ? "DoseFe.dat" : "", 16384); else mccDoseFe_OutputFile[0]='\0';
#line 27780 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("DoseFe (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27787 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaSCalc, mcrotaDoseFe);
  rot_transpose(mcrotaSCalc, mctr1);
  rot_mul(mcrotaDoseFe, mctr1, mcrotrDoseFe);
  mctc1 = coords_set(
#line 1855 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1855 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1855 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27798 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaSCalc, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDoseFe = coords_add(mcposaSCalc, mctc2);
  mctc1 = coords_sub(mcposaSCalc, mcposaDoseFe);
  mcposrDoseFe = rot_apply(mcrotaDoseFe, mctc1);
  mcDEBUG_COMPONENT("DoseFe", mcposaDoseFe, mcrotaDoseFe)
  mccomp_posa[87] = mcposaDoseFe;
  mccomp_posr[87] = mcposrDoseFe;
  mcNCounter[87]  = mcPCounter[87] = mcP2Counter[87] = 0;
  mcAbsorbProp[87]= 0;
    /* Component DoseConc. */
  /* Setting parameters for component DoseConc. */
  SIG_MESSAGE("DoseConc (Init:SetPar)");
#line 1858 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("Concrete") strncpy(mccDoseConc_Material, "Concrete" ? "Concrete" : "", 16384); else mccDoseConc_Material[0]='\0';
#line 1858 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDoseConc_Innerspace = 0.4;
#line 1858 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDoseConc_Thickness = 0.6;
#line 37 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("") strncpy(mccDoseConc_SteelTubing, "" ? "" : "", 16384); else mccDoseConc_SteelTubing[0]='\0';
#line 37 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDoseConc_TubingThickness = 0.0;
#line 1858 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NiCapture.dat") strncpy(mccDoseConc_NiCaptureFile, "NiCapture.dat" ? "NiCapture.dat" : "", 16384); else mccDoseConc_NiCaptureFile[0]='\0';
#line 1858 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("TiCapture.dat") strncpy(mccDoseConc_TiCaptureFile, "TiCapture.dat" ? "TiCapture.dat" : "", 16384); else mccDoseConc_TiCaptureFile[0]='\0';
#line 1858 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("TotalCapture.dat") strncpy(mccDoseConc_TotalCaptureFile, "TotalCapture.dat" ? "TotalCapture.dat" : "", 16384); else mccDoseConc_TotalCaptureFile[0]='\0';
#line 1858 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("DoseConc.dat") strncpy(mccDoseConc_OutputFile, "DoseConc.dat" ? "DoseConc.dat" : "", 16384); else mccDoseConc_OutputFile[0]='\0';
#line 27830 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("DoseConc (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27837 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaDoseFe, mcrotaDoseConc);
  rot_transpose(mcrotaDoseFe, mctr1);
  rot_mul(mcrotaDoseConc, mctr1, mcrotrDoseConc);
  mctc1 = coords_set(
#line 1859 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1859 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1859 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27848 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaDoseFe, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDoseConc = coords_add(mcposaDoseFe, mctc2);
  mctc1 = coords_sub(mcposaDoseFe, mcposaDoseConc);
  mcposrDoseConc = rot_apply(mcrotaDoseConc, mctc1);
  mcDEBUG_COMPONENT("DoseConc", mcposaDoseConc, mcrotaDoseConc)
  mccomp_posa[88] = mcposaDoseConc;
  mccomp_posr[88] = mcposrDoseConc;
  mcNCounter[88]  = mcPCounter[88] = mcP2Counter[88] = 0;
  mcAbsorbProp[88]= 0;
    /* Component DoseStandard. */
  /* Setting parameters for component DoseStandard. */
  SIG_MESSAGE("DoseStandard (Init:SetPar)");
#line 1862 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("Concrete") strncpy(mccDoseStandard_Material, "Concrete" ? "Concrete" : "", 16384); else mccDoseStandard_Material[0]='\0';
#line 1862 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDoseStandard_Innerspace = 0.4;
#line 1862 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDoseStandard_Thickness = 0.4;
#line 1862 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("yes") strncpy(mccDoseStandard_SteelTubing, "yes" ? "yes" : "", 16384); else mccDoseStandard_SteelTubing[0]='\0';
#line 1862 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDoseStandard_TubingThickness = 0.1;
#line 1862 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NiCapture.dat") strncpy(mccDoseStandard_NiCaptureFile, "NiCapture.dat" ? "NiCapture.dat" : "", 16384); else mccDoseStandard_NiCaptureFile[0]='\0';
#line 1862 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("TiCapture.dat") strncpy(mccDoseStandard_TiCaptureFile, "TiCapture.dat" ? "TiCapture.dat" : "", 16384); else mccDoseStandard_TiCaptureFile[0]='\0';
#line 1862 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("TotalCapture.dat") strncpy(mccDoseStandard_TotalCaptureFile, "TotalCapture.dat" ? "TotalCapture.dat" : "", 16384); else mccDoseStandard_TotalCaptureFile[0]='\0';
#line 1862 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("DoseConcTubing.dat") strncpy(mccDoseStandard_OutputFile, "DoseConcTubing.dat" ? "DoseConcTubing.dat" : "", 16384); else mccDoseStandard_OutputFile[0]='\0';
#line 27880 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("DoseStandard (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27887 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaDoseConc, mcrotaDoseStandard);
  rot_transpose(mcrotaDoseConc, mctr1);
  rot_mul(mcrotaDoseStandard, mctr1, mcrotrDoseStandard);
  mctc1 = coords_set(
#line 1863 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1863 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1863 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27898 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaDoseConc, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDoseStandard = coords_add(mcposaDoseConc, mctc2);
  mctc1 = coords_sub(mcposaDoseConc, mcposaDoseStandard);
  mcposrDoseStandard = rot_apply(mcrotaDoseStandard, mctc1);
  mcDEBUG_COMPONENT("DoseStandard", mcposaDoseStandard, mcrotaDoseStandard)
  mccomp_posa[89] = mcposaDoseStandard;
  mccomp_posr[89] = mcposrDoseStandard;
  mcNCounter[89]  = mcPCounter[89] = mcP2Counter[89] = 0;
  mcAbsorbProp[89]= 0;
    /* Component Dose5. */
  /* Setting parameters for component Dose5. */
  SIG_MESSAGE("Dose5 (Init:SetPar)");
#line 1866 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("Concrete") strncpy(mccDose5_Material, "Concrete" ? "Concrete" : "", 16384); else mccDose5_Material[0]='\0';
#line 1866 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDose5_Innerspace = 0.4;
#line 1866 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDose5_Thickness = 0.6;
#line 1866 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("yes") strncpy(mccDose5_SteelTubing, "yes" ? "yes" : "", 16384); else mccDose5_SteelTubing[0]='\0';
#line 1866 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  mccDose5_TubingThickness = 0.05;
#line 1866 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("NiCapture.dat") strncpy(mccDose5_NiCaptureFile, "NiCapture.dat" ? "NiCapture.dat" : "", 16384); else mccDose5_NiCaptureFile[0]='\0';
#line 1866 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("TiCapture.dat") strncpy(mccDose5_TiCaptureFile, "TiCapture.dat" ? "TiCapture.dat" : "", 16384); else mccDose5_TiCaptureFile[0]='\0';
#line 1866 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("TotalCapture.dat") strncpy(mccDose5_TotalCaptureFile, "TotalCapture.dat" ? "TotalCapture.dat" : "", 16384); else mccDose5_TotalCaptureFile[0]='\0';
#line 1866 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
  if("DoseConcTubing5.dat") strncpy(mccDose5_OutputFile, "DoseConcTubing5.dat" ? "DoseConcTubing5.dat" : "", 16384); else mccDose5_OutputFile[0]='\0';
#line 27930 "./ESS_BIFROST_shielding.c"

  SIG_MESSAGE("Dose5 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27937 "./ESS_BIFROST_shielding.c"
  rot_mul(mctr1, mcrotaDoseStandard, mcrotaDose5);
  rot_transpose(mcrotaDoseStandard, mctr1);
  rot_mul(mcrotaDose5, mctr1, mcrotrDose5);
  mctc1 = coords_set(
#line 1867 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1867 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0,
#line 1867 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
    0);
#line 27948 "./ESS_BIFROST_shielding.c"
  rot_transpose(mcrotaDoseStandard, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDose5 = coords_add(mcposaDoseStandard, mctc2);
  mctc1 = coords_sub(mcposaDoseStandard, mcposaDose5);
  mcposrDose5 = rot_apply(mcrotaDose5, mctc1);
  mcDEBUG_COMPONENT("Dose5", mcposaDose5, mcrotaDose5)
  mccomp_posa[90] = mcposaDose5;
  mccomp_posr[90] = mcposrDose5;
  mcNCounter[90]  = mcPCounter[90] = mcP2Counter[90] = 0;
  mcAbsorbProp[90]= 0;
  /* Component initializations. */
  /* Initializations for component Origin. */
  SIG_MESSAGE("Origin (Init)");
#define mccompcurname  Origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccOrigin_IntermediateCnts
#define StartTime mccOrigin_StartTime
#define EndTime mccOrigin_EndTime
#define CurrentTime mccOrigin_CurrentTime
#define profile mccOrigin_profile
#define percent mccOrigin_percent
#define flag_save mccOrigin_flag_save
#define minutes mccOrigin_minutes
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../misc/Progress_bar.comp"
{
IntermediateCnts=0;
StartTime=0;
EndTime=0;
CurrentTime=0;

fprintf(stdout, "[%s] Initialize\n", mcinstrument_name);
  if (percent*mcget_ncount()/100 < 1e5) {
    percent=1e5*100.0/mcget_ncount();
  }
}
#line 27985 "./ESS_BIFROST_shielding.c"
#undef minutes
#undef flag_save
#undef percent
#undef profile
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ESS_source. */
  SIG_MESSAGE("ESS_source (Init)");
#define mccompcurname  ESS_source
#define mccompcurtype  ESS_butterfly
#define mccompcurindex 2
#define cx mccESS_source_cx
#define cz mccESS_source_cz
#define sign_bl_angle mccESS_source_sign_bl_angle
#define orientation_angle mccESS_source_orientation_angle
#define jmax mccESS_source_jmax
#define C1_x mccESS_source_C1_x
#define C1_z mccESS_source_C1_z
#define C2_x mccESS_source_C2_x
#define C2_z mccESS_source_C2_z
#define C3_x mccESS_source_C3_x
#define C3_z mccESS_source_C3_z
#define T1_x mccESS_source_T1_x
#define T1_z mccESS_source_T1_z
#define T2_x mccESS_source_T2_x
#define T2_z mccESS_source_T2_z
#define T3_x mccESS_source_T3_x
#define T3_z mccESS_source_T3_z
#define rC1_x mccESS_source_rC1_x
#define rC1_z mccESS_source_rC1_z
#define rC2_x mccESS_source_rC2_x
#define rC2_z mccESS_source_rC2_z
#define rC3_x mccESS_source_rC3_x
#define rC3_z mccESS_source_rC3_z
#define rT1_x mccESS_source_rT1_x
#define rT1_z mccESS_source_rT1_z
#define rT2_x mccESS_source_rT2_x
#define rT2_z mccESS_source_rT2_z
#define rT3_x mccESS_source_rT3_x
#define rT3_z mccESS_source_rT3_z
#define tx mccESS_source_tx
#define ty mccESS_source_ty
#define tz mccESS_source_tz
#define r11 mccESS_source_r11
#define r12 mccESS_source_r12
#define r21 mccESS_source_r21
#define r22 mccESS_source_r22
#define xf mccESS_source_xf
#define yf mccESS_source_yf
#define zf mccESS_source_zf
#define w_mult mccESS_source_w_mult
#define w_stat mccESS_source_w_stat
#define w_geom mccESS_source_w_geom
#define w_focus mccESS_source_w_focus
#define w_tfocus mccESS_source_w_tfocus
#define w_geom_c mccESS_source_w_geom_c
#define w_geom_t mccESS_source_w_geom_t
#define tx mccESS_source_tx
#define ty mccESS_source_ty
#define tz mccESS_source_tz
#define dt mccESS_source_dt
#define lambda mccESS_source_lambda
#define l_range mccESS_source_l_range
#define k mccESS_source_k
#define v mccESS_source_v
#define r mccESS_source_r
#define dx mccESS_source_dx
#define dy mccESS_source_dy
#define dz mccESS_source_dz
#define internal_angle mccESS_source_internal_angle
#define x0 mccESS_source_x0
#define z0 mccESS_source_z0
#define cos_beamport_angle mccESS_source_cos_beamport_angle
#define sin_beamport_angle mccESS_source_sin_beamport_angle
#define cos_thermal mccESS_source_cos_thermal
#define cos_cold mccESS_source_cos_cold
#define Lmin_sampled mccESS_source_Lmin_sampled
#define Lmax_sampled mccESS_source_Lmax_sampled
#define sector mccESS_source_sector
#define beamline mccESS_source_beamline
#define yheight mccESS_source_yheight
#define cold_frac mccESS_source_cold_frac
#define target_index mccESS_source_target_index
#define dist mccESS_source_dist
#define focus_xw mccESS_source_focus_xw
#define focus_yh mccESS_source_focus_yh
#define c_performance mccESS_source_c_performance
#define t_performance mccESS_source_t_performance
#define Lmin mccESS_source_Lmin
#define Lmax mccESS_source_Lmax
#define tmax_multiplier mccESS_source_tmax_multiplier
#define n_pulses mccESS_source_n_pulses
#define acc_power mccESS_source_acc_power
#define tfocus_dist mccESS_source_tfocus_dist
#define tfocus_time mccESS_source_tfocus_time
#define tfocus_width mccESS_source_tfocus_width
#line 202 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../sources/ESS_butterfly.comp"
{
  if (beamline<4) {
    wfrac_cold=1.0;
    wfrac_thermal=(1-0.072);
  } else {
    wfrac_cold=1.0;
    wfrac_thermal=1.0;
  }

  /* Centering-parameters, which sector are we in? */
  if (strcasestr(sector,"N")) {
    cx = 0.117; cz=0.0; sign_bl_angle=1;
    orientation_angle = BeamlinesN[beamline-1];
    Beamlines = BeamlinesN;
    internal_angle=90-fabs(orientation_angle);
    modextras.beamportangle=nearest_angle(fabs(internal_angle));
    /* Direction-cosines for use with e.g. Brilliance_monitor */
    cos_beamport_angle=cos(fabs(internal_angle)*DEG2RAD);
    sin_beamport_angle=sin(fabs(internal_angle)*DEG2RAD);
    /* correction for projection along the beam / projection on the z=0 plane */
    cos_thermal=cos_beamport_angle;
    cos_cold=cos((fabs(internal_angle)-24.24)*DEG2RAD);
    ColdWidths = ColdWidthNE;
    ThermalWidths = ThermalWidthNE;
    ColdScalars = ColdScalarsN;
    ThermalScalars = ThermalScalarsN;
    jmax=10;
    T1_x=0;
    T1_z=0;
    T2_x=-wfrac_thermal*oversampT*ThermalWidths[beamline-1]/cos_thermal;
    T2_z=0;
    T3_x=((1-wfrac_thermal)*oversampT*ThermalWidths[beamline-1]/cos_thermal);
    T3_z=0;
    C1_x=0;
    C1_z=0;
    C2_x=(wfrac_cold*oversampC*ColdWidths[beamline-1]/cos_cold)*cos(24.24*DEG2RAD);
    C2_z=-(wfrac_cold*oversampC*ColdWidths[beamline-1]/cos_cold)*sin(24.24*DEG2RAD);
    C3_x=-(1-wfrac_cold)*oversampC*ColdWidths[beamline-1]/cos_thermal;
    C3_z=0;   
    isleft=1;
  } else if (strcasestr(sector,"W")) {
    cx = 0.0; cz=0.0; sign_bl_angle=-1;
    orientation_angle = BeamlinesW[beamline-1]; 
    Beamlines = BeamlinesW;
    internal_angle=90-fabs(orientation_angle);
    modextras.beamportangle=nearest_angle(fabs(internal_angle));
    /* Direction-cosines for use with e.g. Brilliance_monitor */
    cos_beamport_angle=cos(fabs(internal_angle)*DEG2RAD);
    sin_beamport_angle=sin(fabs(internal_angle)*DEG2RAD);
    /* correction for projection along the beam / projection on the z=0 plane */
    cos_thermal=cos_beamport_angle;
    cos_cold=cos((fabs(internal_angle)-24.24)*DEG2RAD);
    ColdWidths = ColdWidthSW;
    ThermalWidths = ThermalWidthSW;
    ColdScalars = ColdScalarsW;
    ThermalScalars = ThermalScalarsW;
    jmax=11;
    T1_x=0;
    T1_z=0;
    T2_x=wfrac_thermal*oversampT*ThermalWidths[beamline-1]/cos_thermal;
    T2_z=0;
    T3_x=-((1-wfrac_thermal)*oversampT*ThermalWidths[beamline-1]/cos_thermal);
    T3_z=0;
    C1_x=0;
    C1_z=0;
    C2_x=-(wfrac_cold*oversampC*ColdWidths[beamline-1]/cos_cold)*cos(24.24*DEG2RAD);
    C2_z=-(wfrac_cold*oversampC*ColdWidths[beamline-1]/cos_cold)*sin(24.24*DEG2RAD);
    C3_x=(1-wfrac_cold)*oversampC*ColdWidths[beamline-1]/cos_thermal;
    C3_z=0;    
    isleft=-1;
  } else if (strcasestr(sector,"S")) {
    cx = 0.0; cz=-0.185; sign_bl_angle=1;
    orientation_angle = BeamlinesS[beamline-1]; 
    Beamlines = BeamlinesS;
    internal_angle=90-fabs(orientation_angle);
    modextras.beamportangle=nearest_angle(fabs(internal_angle));
    /* Direction-cosines for use with e.g. Brilliance_monitor */
    cos_beamport_angle=cos(fabs(internal_angle)*DEG2RAD);
    sin_beamport_angle=sin(fabs(internal_angle)*DEG2RAD);
    /* correction for projection along the beam / projection on the z=0 plane */
    cos_thermal=cos_beamport_angle;
    cos_cold=cos((fabs(internal_angle)-24.24)*DEG2RAD);
    //printf("cosines are %g %g internal angle %g\n",cos_thermal,cos_cold,fabs(internal_angle));
    ColdWidths = ColdWidthSW;
    ThermalWidths = ThermalWidthSW;
    ColdScalars = ColdScalarsS;
    ThermalScalars = ThermalScalarsS;
    jmax=11;
    T1_x=0;
    T1_z=0;
    T2_x=wfrac_thermal*oversampT*ThermalWidths[beamline-1]/cos_thermal;
    T2_z=0;
    T3_x=-((1-wfrac_thermal)*oversampT*ThermalWidths[beamline-1]/cos_thermal);
    T3_z=0;
    C1_x=0;
    C1_z=0;
    C2_x=-(wfrac_cold*oversampC*ColdWidths[beamline-1]/cos_cold)*cos(24.24*DEG2RAD);
    C2_z=(wfrac_cold*oversampC*ColdWidths[beamline-1]/cos_cold)*sin(24.24*DEG2RAD);
    C3_x=(1-wfrac_cold)*oversampC*ColdWidths[beamline-1]/cos_thermal;
    C3_z=0;    
    isleft=-1;
  } else if (strcasestr(sector,"E")) {
    cx = 0.117; cz=-0.185; sign_bl_angle=-1;
    orientation_angle = BeamlinesE[beamline-1]; 
    Beamlines = BeamlinesE;
    internal_angle=90-fabs(orientation_angle);
    modextras.beamportangle=nearest_angle(fabs(internal_angle));
    /* Direction-cosines for use with e.g. Brilliance_monitor */
    cos_beamport_angle=cos(fabs(internal_angle)*DEG2RAD);
    sin_beamport_angle=sin(fabs(internal_angle)*DEG2RAD);
    /* correction for projection along the beam / projection on the z=0 plane */
    cos_thermal=cos_beamport_angle;
    cos_cold=cos((fabs(internal_angle)-24.24)*DEG2RAD);
    ColdWidths = ColdWidthNE;
    ThermalWidths = ThermalWidthNE;
    ColdScalars = ColdScalarsE;
    ThermalScalars = ThermalScalarsE;
    jmax=10;
    T1_x=0;
    T1_z=0;
    T2_x=-wfrac_thermal*oversampT*ThermalWidths[beamline-1]/cos_thermal;
    T2_z=0;
    T3_x=((1-wfrac_thermal)*oversampT*ThermalWidths[beamline-1]/cos_thermal);
    T3_z=0;
    C1_x=0;
    C1_z=0;
    C2_x=(wfrac_cold*oversampC*ColdWidths[beamline-1]/cos_cold)*cos(24.24*DEG2RAD);
    C2_z=(wfrac_cold*oversampC*ColdWidths[beamline-1]/cos_cold)*sin(24.24*DEG2RAD);
    C3_x=-(1-wfrac_cold)*oversampC*ColdWidths[beamline-1]/cos_thermal;
    C3_z=0; 
    isleft=1;
  } else {
    fprintf(stderr,"%s: Sector %s is undefined, please use N, W, S or E!\n", NAME_CURRENT_COMP,sector);
    exit(-1);
  }
  if (beamline > jmax || beamline <= 0 ) {
    fprintf(stderr,"%s: beamline no %i is undefined in sector %s, please use 1 <= beamline <= %i\n", NAME_CURRENT_COMP, beamline, sector, jmax);
    exit(-1);
  }

  printf("%s: Setting up for sector %s, beamline %i, global orientation angle is %g, internal angle %g\n", NAME_CURRENT_COMP, sector,beamline,orientation_angle,modextras.beamportangle);
  if (c_performance <= 0) {
    fprintf(stderr,"%s: Cold performance scalar of %g is not allowed. Please select 0 < c_performance\n", NAME_CURRENT_COMP, c_performance);
    exit(-1);
  }
  if (t_performance <= 0) {
    fprintf(stderr,"%s: Thermal performance scalar of %g is not allowed. Please select 0 < t_performance\n", NAME_CURRENT_COMP, t_performance);
    exit(-1);
  }
  if (Lmin>=Lmax || Lmin <= 0 || Lmax < 0) {
    fprintf(stderr,"%s: Unmeaningful definition of wavelength range!\nPlease select Lmin, Lmax > 0 and Lmax > Lmin.\n ERROR - Exiting\n",
           NAME_CURRENT_COMP);
    exit(-1);
  }
  /* Figure out where to aim */
  if (target_index && !dist)
  {
    Coords ToTarget;
    ToTarget = coords_sub(POS_A_COMP_INDEX(INDEX_CURRENT_COMP+target_index),POS_A_CURRENT_COMP);
    ToTarget = rot_apply(ROT_A_CURRENT_COMP, ToTarget);
    coords_get(ToTarget, &tx, &ty, &tz);
    dist=sqrt(tx*tx+ty*ty+tz*tz);
  } else if (!target_index && !dist) {
    fprintf(stderr,"%s: Please choose to set either the dist parameter or specify a target_index.\nExit\n", NAME_CURRENT_COMP);
    exit(-1);
  } else {
    tx=0; ty=0; tz=dist;
  }
  printf("%s: Focusing at rectagle sized %g x %g \n  - positioned at location (x,y,z)=(%g m, %g m, %g m) \n", NAME_CURRENT_COMP, focus_xw, focus_yh, tx, ty, tz);
  if (target_index) {
    printf(" ( from target_index %i -> distance %g )\n", target_index, dist);
  } else {
    printf(" ( from dist parameter -> distance %g )\n", dist);
  }
  printf("%s: Cold and Thermal brilliance performance multiplicators are c_performance=%g and t_performance=%g\n", NAME_CURRENT_COMP, c_performance, t_performance);
  
  /* Calculate orientation matrix for the display and calculations */
  r11 = cos(DEG2RAD*orientation_angle);
  r12 = -sin(DEG2RAD*orientation_angle);
  r21 = sin(DEG2RAD*orientation_angle);
  r22 = cos(DEG2RAD*orientation_angle);
  
  /* Rotated corrdinates of the emission areas */
  rC1_x = r11*C1_z + r12*C1_x;
  rC1_z = r21*C1_z + r22*C1_x;
  rC2_x = r11*C2_z + r12*C2_x;
  rC2_z = r21*C2_z + r22*C2_x;
  rC3_x = r11*C3_z + r12*C3_x;
  rC3_z = r21*C3_z + r22*C3_x;
  rT1_x = r11*T1_z + r12*T1_x;
  rT1_z = r21*T1_z + r22*T1_x;
  rT2_x = r11*T2_z + r12*T2_x;
  rT2_z = r21*T2_z + r22*T2_x;
  rT3_x = r11*T3_z + r12*T3_x;
  rT3_z = r21*T3_z + r22*T3_x;
  /* Moderator half-height */
  delta_y = yheight/2.0;
  /* Other moderator parms */
  modextras.height_c=yheight;
  modextras.Width_c=0.1;
  modextras.Width_t=0.18;
  modextras.height_t=yheight;
  modextras.tmultiplier=tmax_multiplier;
  modextras.extractionangle=120;
  /* "Measured" moderator widths in cm scale */
  modextras.Mwidth_c=100.0*ColdWidths[beamline-1]/cos_cold; //Should it be one or the other here?
  modextras.Mwidth_t=(100.0*ThermalWidths[beamline-1]+0.7)/cos_thermal;
  if (tfocus_width && tfocus_time && tfocus_dist) {
    printf("%s: Using time focusing: Directing neutrons to this time-window:\n   tfocus_width (%g s) wide at tfocus_time (%g s), tfocus_dist (%g m) downstream\n",NAME_CURRENT_COMP, tfocus_width, tfocus_time, tfocus_dist);
  } else if (!tfocus_width && !tfocus_time && !tfocus_dist) {
    printf("%s: NOT using time focusing\n",NAME_CURRENT_COMP);
  } else {
    fprintf(stderr,"%s: Unmeaningful combination tfocus_width (%g s), tfocus_time (%g s) and tfocus_dist (%g m): \n    All must be either==0 (no time focusing) or !=0 (time focusing)\n ERROR - Exiting\n",
	    NAME_CURRENT_COMP, tfocus_width, tfocus_time, tfocus_dist);
    exit(-1);
  }

  /* Specify brilliance fct.'s */
  cold_bril=ESS_2015_Schoenfeldt_cold;
  thermal_bril=ESS_2015_Schoenfeldt_thermal;
  l_range = Lmax-Lmin;
  /* Weight multipliers */
  w_mult=acc_power/5;
  w_stat=1.0/mcget_ncount();
  w_geom_c  = 0.072*yheight*1.0e4;     /* source area correction */
  w_geom_t  = 0.108*yheight*1.0e4;
  w_mult *= l_range;            /* wavelength range correction */
  n_pulses=(double)floor(n_pulses);
  if (n_pulses == 0) n_pulses=1;
}
#line 28319 "./ESS_BIFROST_shielding.c"
#undef tfocus_width
#undef tfocus_time
#undef tfocus_dist
#undef acc_power
#undef n_pulses
#undef tmax_multiplier
#undef Lmax
#undef Lmin
#undef t_performance
#undef c_performance
#undef focus_yh
#undef focus_xw
#undef dist
#undef target_index
#undef cold_frac
#undef yheight
#undef beamline
#undef sector
#undef Lmax_sampled
#undef Lmin_sampled
#undef cos_cold
#undef cos_thermal
#undef sin_beamport_angle
#undef cos_beamport_angle
#undef z0
#undef x0
#undef internal_angle
#undef dz
#undef dy
#undef dx
#undef r
#undef v
#undef k
#undef l_range
#undef lambda
#undef dt
#undef tz
#undef ty
#undef tx
#undef w_geom_t
#undef w_geom_c
#undef w_tfocus
#undef w_focus
#undef w_geom
#undef w_stat
#undef w_mult
#undef zf
#undef yf
#undef xf
#undef r22
#undef r21
#undef r12
#undef r11
#undef tz
#undef ty
#undef tx
#undef rT3_z
#undef rT3_x
#undef rT2_z
#undef rT2_x
#undef rT1_z
#undef rT1_x
#undef rC3_z
#undef rC3_x
#undef rC2_z
#undef rC2_x
#undef rC1_z
#undef rC1_x
#undef T3_z
#undef T3_x
#undef T2_z
#undef T2_x
#undef T1_z
#undef T1_x
#undef C3_z
#undef C3_x
#undef C2_z
#undef C2_x
#undef C1_z
#undef C1_x
#undef jmax
#undef orientation_angle
#undef sign_bl_angle
#undef cz
#undef cx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component StartOfGuide. */
  SIG_MESSAGE("StartOfGuide (Init)");

  /* Initializations for component NBOA. */
  SIG_MESSAGE("NBOA (Init)");
#define mccompcurname  NBOA
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 4
#define mvaluesright mccNBOA_mvaluesright
#define mvaluesleft mccNBOA_mvaluesleft
#define mvaluestop mccNBOA_mvaluestop
#define mvaluesbottom mccNBOA_mvaluesbottom
#define seglength mccNBOA_seglength
#define guideInfo mccNBOA_guideInfo
#define latestParticleCollision mccNBOA_latestParticleCollision
#define Gx mccNBOA_Gx
#define Gy mccNBOA_Gy
#define Gz mccNBOA_Gz
#define Gx0 mccNBOA_Gx0
#define Gy0 mccNBOA_Gy0
#define Gz0 mccNBOA_Gz0
#define Circ mccNBOA_Circ
#define dynamicalSegLength mccNBOA_dynamicalSegLength
#define l mccNBOA_l
#define xwidth mccNBOA_xwidth
#define yheight mccNBOA_yheight
#define linxw mccNBOA_linxw
#define loutxw mccNBOA_loutxw
#define linyh mccNBOA_linyh
#define loutyh mccNBOA_loutyh
#define majorAxisxw mccNBOA_majorAxisxw
#define minorAxisxw mccNBOA_minorAxisxw
#define majorAxisyh mccNBOA_majorAxisyh
#define minorAxisyh mccNBOA_minorAxisyh
#define majorAxisoffsetxw mccNBOA_majorAxisoffsetxw
#define majorAxisoffsetyh mccNBOA_majorAxisoffsetyh
#define dimensionsAt mccNBOA_dimensionsAt
#define option mccNBOA_option
#define R0 mccNBOA_R0
#define Qc mccNBOA_Qc
#define alpha mccNBOA_alpha
#define m mccNBOA_m
#define W mccNBOA_W
#define alpharight mccNBOA_alpharight
#define mright mccNBOA_mright
#define alphaleft mccNBOA_alphaleft
#define mleft mccNBOA_mleft
#define alphatop mccNBOA_alphatop
#define mtop mccNBOA_mtop
#define alphabottom mccNBOA_alphabottom
#define mbottom mccNBOA_mbottom
#define verbose mccNBOA_verbose
#define enableGravity mccNBOA_enableGravity
#define curvature mccNBOA_curvature
#line 829 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
{
	///////////////////////////////////////////////////////////////////////////
	/////////////// Test user input
	///////////////////////////////////////////////////////////////////////////

	if(strcmp(verbose,"on") == 0)
		guideInfo.verboseSetting = 1;
	else guideInfo.verboseSetting = 0;
	

	guideInfo.R0Arr[RightSide] 		= R0;
	guideInfo.QcArr[RightSide] 		= Qc;
	guideInfo.alphaArr[RightSide] 	= alpharight;
	guideInfo.mArr[RightSide] 		= mright;
	guideInfo.WArr[RightSide] 		= W; 

	guideInfo.R0Arr[TopSide] 	 = R0; 
	guideInfo.QcArr[TopSide] 	 = Qc; 
	guideInfo.alphaArr[TopSide]  = alphatop; 
	guideInfo.mArr[TopSide] 	 = mtop;
	guideInfo.WArr[TopSide] 	 = W; 

	guideInfo.R0Arr[LeftSide] 		= R0; 
	guideInfo.QcArr[LeftSide] 		= Qc; 
	guideInfo.alphaArr[LeftSide] 	= alphaleft; 
	guideInfo.mArr[LeftSide] 		= mleft; 
	guideInfo.WArr[LeftSide] 		= W; 

	guideInfo.R0Arr[BottomSide] 	= R0; 
	guideInfo.QcArr[BottomSide] 	= Qc; 
	guideInfo.alphaArr[BottomSide] 	= alphabottom; 
	guideInfo.mArr[BottomSide] 		= mbottom; 
	guideInfo.WArr[BottomSide] 		= W; 

	int sides;
	for (sides = RightSide; sides <= BottomSide; sides++){
		if (guideInfo.alphaArr[sides] == -1) guideInfo.alphaArr[sides] = alpha;
		if (guideInfo.mArr[sides] == -1)	 guideInfo.mArr[sides] = m;
	}
	
	// Test user input for illegal values
	int inputErrors = 0;
	// Lower or equal to zero
	if(l <= 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("length",guideInfo.verboseSetting);
	if(guideInfo.alphaArr[TopSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphatop",guideInfo.verboseSetting);
	if(guideInfo.mArr[TopSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mtop",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[BottomSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphabottom",guideInfo.verboseSetting);
	if(guideInfo.mArr[BottomSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mbottom",guideInfo.verboseSetting);

	if(guideInfo.alphaArr[RightSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alpharight",guideInfo.verboseSetting);
	if(guideInfo.mArr[RightSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mright",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[LeftSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphaleft",guideInfo.verboseSetting);
	if(guideInfo.mArr[LeftSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mleft",guideInfo.verboseSetting);

	// Focal points result in hyperbola instead of an ellipse
	if(l <= -linxw-loutxw) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linw","loutw",linxw,loutxw,guideInfo.verboseSetting);
	if(l <= -linyh-loutyh) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linh","louth",linyh,loutyh,guideInfo.verboseSetting);

	if( strcmp(dimensionsAt,"entrance") != 0 
	 && strcmp(dimensionsAt,"mid") != 0 
	 && strcmp(dimensionsAt,"exit") != 0){
	 	inputErrors += 1;
		printf("dimensionsAt were given an incorrect input."
			   "Input must be string containing \"entrance\",\"mid\" or \"exit\" \n");
	}


	// Terminate program if any input errors occurred
	if(inputErrors != 0 ){
		exit(printf("\nCRITICAL ERROR(S) IN COMPONENT %s" 
				" CONSIDER CHECKING USER INPUT AS %d INPUT ERRORS WAS FOUND.\n",
				NAME_CURRENT_COMP,inputErrors) );
	}


	///////////////////////////////////////////////////////////////////////////
	/////////////// Calculate intern guide values from user input
	///////////////////////////////////////////////////////////////////////////

	/*  Calculate the foci line for the ellipses.
		These can be used to calculate the axes of the ellipses
		using pyth and defination of the ellipse that says distance 
		between the foci and every point on the ellipse is constant.
	*/
	int directDefination = 0;

	if( majorAxisyh != 0 || minorAxisyh != 0 
	 || majorAxisxw != 0 || minorAxisxw != 0)
	{
		directDefination = 1;
		guideInfo.Length = l;	
		
		guideInfo.ellipseMajorAxis[RightSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[RightSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[RightSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[TopSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[TopSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[TopSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[LeftSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[LeftSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[LeftSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[BottomSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[BottomSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[BottomSide] = 0;

		guideInfo.entranceHorizontalWidth =
			2*sqrt(1 - (majorAxisoffsetyh*majorAxisoffsetyh)
			/(majorAxisyh*majorAxisyh) )*minorAxisyh;
		guideInfo.entranceVerticalWidth = 	
			2*sqrt(1 - (majorAxisoffsetxw*majorAxisoffsetxw)
			/(majorAxisxw*majorAxisxw) )*minorAxisxw;
	}

	if ( strcmp(option,"ellipse") == 0 && directDefination == 0)
	{
		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( linxw*linxw + xwidth*xwidth*0.25)
				+ sqrt( (l + loutxw)*(l + loutxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( linyh*linyh + yheight*yheight*0.25)
				+ sqrt( (l + loutyh)*(l + loutyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"exit") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( loutxw*loutxw + xwidth*xwidth*0.25)
				+ sqrt( (l + linxw)*(l + linxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( loutyh*loutyh + yheight*yheight*0.25)
				+ sqrt( (l + linyh)*(l + linyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] =(l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"mid") == 0 ){ 

			guideInfo.Length = l;
			
			guideInfo.ellipseMajorAxis[RightSide] = 
				sqrt( (linxw+l+loutxw)*(linxw+l+loutxw)/4+xwidth*xwidth/4);
			guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = 
				sqrt( (linyh+l+loutyh)*(linyh+l+loutyh)/4+yheight*yheight/4);
			guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];

		}
	}

	guideInfo.entranceHorizontalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[RightSide]
			*guideInfo.ellipseMajorOffset[RightSide]
			/(guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] ) )
		*guideInfo.ellipseMinorAxis[RightSide];
	guideInfo.entranceVerticalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[TopSide]
			*guideInfo.ellipseMajorOffset[TopSide]
			/(guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] ) )
		*guideInfo.ellipseMinorAxis[TopSide];


	if ( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		exit( printf("Critical error in %s; the option for option = halfellipse is currently disabled.",NAME_CURRENT_COMP) );

		double used_focal_vertical;
		double used_focal_horizontal;
		double major_offset_horizontal = 0;
		double major_offset_vertical = 0;

		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+linyh)*(l+linyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+linxw)*(l+linxw) ); 
			major_offset_vertical = l;	
			major_offset_horizontal = l;
		}
		else {	
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+loutyh)*(l+loutyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+loutxw)*(l+loutxw) ); 
		}

		guideInfo.Length = l;

		guideInfo.ellipseMajorAxis[RightSide] = used_focal_horizontal;
		guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

		guideInfo.ellipseMajorOffset[RightSide] = major_offset_horizontal;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = 
								guideInfo.ellipseMajorAxis[RightSide];
		guideInfo.ellipseMinorAxis[LeftSide] = 
								guideInfo.ellipseMinorAxis[RightSide];
		guideInfo.ellipseMajorOffset[LeftSide] = 
								guideInfo.ellipseMajorOffset[RightSide];
		guideInfo.ellipseMinorOffset[LeftSide] = 
								guideInfo.ellipseMinorOffset[RightSide];

		guideInfo.ellipseMajorAxis[TopSide] = used_focal_vertical;
		guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

		guideInfo.ellipseMajorOffset[TopSide] = major_offset_vertical;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = 
								guideInfo.ellipseMajorAxis[TopSide];
		guideInfo.ellipseMinorAxis[BottomSide] = 
								guideInfo.ellipseMinorAxis[TopSide];
		guideInfo.ellipseMajorOffset[BottomSide] = 
								guideInfo.ellipseMajorOffset[TopSide];
		guideInfo.ellipseMinorOffset[BottomSide] = 
								guideInfo.ellipseMinorOffset[TopSide];
	}

	// Applies the properties of the mirrors in the guide given by the user.
	// These variables are used in the reflection functions.

	
	// Sets the mirror type of the guides mirrors
	// These variables are used in the collision functions 
	// to find the type of collision

	// guideInfo.OuterSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[BottomSide] = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_bottom_side_mirror,guideInfo.verboseSetting);

	// guideInfo.InnerSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[BottomSide] =	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_bottom_side_mirror,guideInfo.verboseSetting);

	// Give a warning if all side of the guide is turned off, 
	// as the guide is essentially turned off
	if(    guideInfo.OuterSide[RightSide] 	== 1 
		&& guideInfo.OuterSide[TopSide] 	== 1
		&& guideInfo.OuterSide[LeftSide] 	== 1 
		&& guideInfo.OuterSide[BottomSide]	== 1
		&& guideInfo.InnerSide[RightSide] 	== 1 
		&& guideInfo.InnerSide[TopSide] 	== 1
		&& guideInfo.InnerSide[LeftSide] 	== 1 
		&& guideInfo.InnerSide[BottomSide]  == 1)
		printf("Warning: In %s all the sides of the guide has been disabled,"
				" so it not possible for any particle"
				" to collide with the guide, consider"
				" disabling this component",NAME_CURRENT_COMP);
	
	if(guideInfo.mArr[RightSide] <= 0)  guideInfo.InnerSide[RightSide] = 
														MirrorTypeabsorption;
	if(guideInfo.mArr[TopSide] <= 0) 	 guideInfo.InnerSide[TopSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[LeftSide] <= 0) 	 guideInfo.InnerSide[LeftSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[BottomSide] <= 0) guideInfo.InnerSide[BottomSide] = 
														MirrorTypeabsorption;
	/* if(directDefination == 0){ */
	/* 	guideInfo.entranceHorizontalWidth = xwidth; */
	/* 	guideInfo.entranceVerticalWidth = yheight; */
	/* } */
	
	if( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		guideInfo.entranceHorizontalWidth =
			(guideInfo.ellipseMinorAxis[RightSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[RightSide]
						*guideInfo.ellipseMajorOffset[RightSide] )
			/( guideInfo.ellipseMajorAxis[RightSide]
			  *guideInfo.ellipseMajorAxis[RightSide] ) )
			+ guideInfo.ellipseMinorOffset[RightSide] )*2;
		guideInfo.entranceVerticalWidth = 
			(guideInfo.ellipseMinorAxis[TopSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[TopSide]
						*guideInfo.ellipseMajorOffset[TopSide] )
			/( guideInfo.ellipseMajorAxis[TopSide]
			  *guideInfo.ellipseMajorAxis[TopSide] ) )
			+ guideInfo.ellipseMinorOffset[TopSide] )*2;
	}


	guideInfo.EnclosingBoxOn = 0;

	/*
	double DefaultArray1[8] = { 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0, 1.0};
	double DefaultArray2[8] = { 1.0, 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0};
	double DefaultArray3[8] = {-1.0,-1.0,-1.0,-1.0, 1.0, 1.0, 1.0, 1.0}; 

	guideInfo.EnclosingBoxOn = 0;
	double *xinput;
	if ( xInput != NULL ){ xinput = xInput; guideInfo.EnclosingBoxOn = 1; }
	else { xinput = DefaultArray1; }
	double *yinput;
	if ( yInput != NULL ){ yinput = yInput; guideInfo.EnclosingBoxOn = 1;}
	else { yinput = DefaultArray2; }
	double *zinput;
	if ( zInput != NULL ){ zinput = zInput; guideInfo.EnclosingBoxOn = 1;}
	else { zinput = DefaultArray3; }
	*/

	/*
	double xarray[8] ={ guideInfo.ellipseMinorAxis[0]*xinput[0],
						guideInfo.ellipseMinorAxis[2]*xinput[1],
						guideInfo.ellipseMinorAxis[2]*xinput[2],
						guideInfo.ellipseMinorAxis[0]*xinput[3],
						guideInfo.ellipseMinorAxis[0]*xinput[4],
						guideInfo.ellipseMinorAxis[2]*xinput[5],
						guideInfo.ellipseMinorAxis[2]*xinput[6],
						guideInfo.ellipseMinorAxis[0]*xinput[7] };
	double yarray[8] ={ guideInfo.ellipseMinorAxis[1]*yinput[0],
						guideInfo.ellipseMinorAxis[1]*yinput[1],
						guideInfo.ellipseMinorAxis[3]*yinput[2],
						guideInfo.ellipseMinorAxis[3]*yinput[3],
						guideInfo.ellipseMinorAxis[1]*yinput[4],
						guideInfo.ellipseMinorAxis[1]*yinput[5],
						guideInfo.ellipseMinorAxis[3]*yinput[6],
						guideInfo.ellipseMinorAxis[3]*yinput[7] };
	double zarray[8] ={ guideInfo.Length/2*zinput[0]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[1]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[2]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[3]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[4]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[5]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[6]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[7]+guideInfo.Length/2 };
	int i = 0;
	for(i = 0; i < 8; i++){
		guideInfo.xArray[i] = xarray[i];
		guideInfo.yArray[i] = yarray[i];
		guideInfo.zArray[i] = zarray[i];
	}
	*/

	guideInfo.exitVerticalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide]) 
					)/(guideInfo.ellipseMajorAxis[BottomSide] 
					*guideInfo.ellipseMajorAxis[BottomSide] )
		)*guideInfo.ellipseMinorAxis[BottomSide];

	guideInfo.exitHorizontalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide]) 
					)/(guideInfo.ellipseMajorAxis[RightSide] 
					*guideInfo.ellipseMajorAxis[RightSide] ) 
		)*guideInfo.ellipseMinorAxis[RightSide];

    //////////////////segmentation of m values

	// Are the arrays empty?
	if(mvaluesright != NULL || mvaluesleft != NULL 
	|| mvaluestop != NULL || mvaluesbottom != NULL)
	{
		guideInfo.enableSegments = 1;

		guideInfo.numberOfSegments = sizeof(mvaluesright)/sizeof(mvaluesright[0]);

		//printf("Length is %i\n",guideInfo.numberOfSegments);
		guideInfo.mValuesright = mvaluesright;
		guideInfo.mValuesleft = mvaluesleft;
		guideInfo.mValuestop = mvaluestop;
		guideInfo.mValuesbottom = mvaluesbottom;
		//printf("Seglength ... %f %f %f\n",seglength[0],seglength[1],seglength[2]);

		// Are the arrays of equal length?
		if(seglength == NULL){
			dynamicalSegLength = 
					realloc(dynamicalSegLength,
							guideInfo.numberOfSegments*sizeof(double) );
			int i;
			for (i = 0; i < guideInfo.numberOfSegments; ++i){
				dynamicalSegLength[i] = 
						guideInfo.Length/guideInfo.numberOfSegments;
				}
			guideInfo.segLength = dynamicalSegLength;
		}
		else guideInfo.segLength = seglength;

		if( guideInfo.numberOfSegments != sizeof(mvaluesright)/sizeof(mvaluesright[0]) 
		 || guideInfo.numberOfSegments != sizeof(mvaluesleft)/sizeof(mvaluesleft[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluestop)/sizeof(mvaluestop[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0])
		 || (guideInfo.segLength == NULL
		  & guideInfo.numberOfSegments != sizeof(seglength)/sizeof(guideInfo.segLength[0]) 
		  ) ) {
			
			printf("Error in userinput inside %s, the length of the arrays"
				   " mvalues and seglength are not equal\n",NAME_CURRENT_COMP);
			printf("The length of the arrays are: mValuesright is %lu,"
				   " mvaluesleft is %lu, mvaluestop is %lu, mvaluesbottom is"
				   " %lu and seglength is %lu and should be %d \n; Above assume that the arrays are using double \n",
					sizeof(mvaluesright)/sizeof(double),
					sizeof(mvaluesleft)/sizeof(double),
					sizeof(mvaluestop)/sizeof(double),
					sizeof(mvaluesbottom)/sizeof(double),
					sizeof(guideInfo.segLength)/sizeof(double),
					guideInfo.numberOfSegments	
					);
				
			if ( guideInfo.verboseSetting )	{
				int i;
				
				printf("The Values of mvaluesright is: [");
				for(i=0; i < sizeof(mvaluesright)/sizeof(mvaluesright[0]); i++) 	
						printf("%e,",guideInfo.mValuesright[i] );
				printf("]\n");
				
				printf("The Values of mvaluesleft is: [");
				for(i=0; i < sizeof(mvaluesleft)/sizeof(mvaluesleft[0]); i++) 	
						printf("%e,",guideInfo.mValuesleft[i] );
				printf("]\n");
				
				printf("The Values of mvaluestop is: [");
				for(i=0; i < sizeof(mvaluestop)/sizeof(mvaluestop[0]); i++) 	
						printf("%e,",guideInfo.mValuestop[i] );
				printf("]\n");

				printf("The Values of mvaluesbottom is: [");
				for(i=0; i < sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0]); i++) 
						printf("%e,",guideInfo.mValuesbottom[i] );
				printf("]\n");

				printf("The Values of seglength is: [");
				for(i=0; i < sizeof(guideInfo.segLength)/sizeof(guideInfo.segLength[0]); i++) 
						printf("%e,",guideInfo.segLength[i]);
				printf("]\n");
			}
			exit( printf("Exit due to critical error in userinput for the"
						" component %s, consider having a look at the input"
						" for following: mvaluesright,mvaluesleft,mvaluestop,"
						"mvaluesbottom and/or seglength.",NAME_CURRENT_COMP) );
		}
		//
		double sumOfelements=0;
		int i;
		for(i=0;i< guideInfo.numberOfSegments; i++) {
			sumOfelements += guideInfo.segLength[i];
		}
		if ( guideInfo.verboseSetting 
		&& fabs(sumOfelements-guideInfo.Length) > 1e-9 )
			printf("Error in userinput inside %s, the difference between"
					" guidelength and elements of the seglength array is:"
					"%e consider changes the parameters l or seglength \n",
					NAME_CURRENT_COMP,sumOfelements-guideInfo.Length);
	}
	else guideInfo.enableSegments = 0;


///////////////////////////////////////////////////////////////////////////
/////////////// Calculate gravity vector in the guides coordinatesystem
///////////////////////////////////////////////////////////////////////////

/*
	Sets the local gravity vector equal to the global gravity vector (0,-g,0) 
	and when apply the same rotation matrix as applied to guide. 
*/ 
	if (enableGravity != 0){
		Gx0=0, Gy0=-GRAVITY*enableGravity, Gz0=0;
		Coords mcLocG;
		mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,Gy0,0));
		coords_get(mcLocG, &Gx0, &Gy0, &Gz0);
	}
	Circ=2*PI*curvature;
}
#line 29055 "./ESS_BIFROST_shielding.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component EndOfelement_6. */
  SIG_MESSAGE("EndOfelement_6 (Init)");

  /* Initializations for component EndOfelement_5. */
  SIG_MESSAGE("EndOfelement_5 (Init)");

  /* Initializations for component curved_guide_1_0. */
  SIG_MESSAGE("curved_guide_1_0 (Init)");
#define mccompcurname  curved_guide_1_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 7
#define GVars mcccurved_guide_1_0_GVars
#define pTable mcccurved_guide_1_0_pTable
#define w1 mcccurved_guide_1_0_w1
#define h1 mcccurved_guide_1_0_h1
#define w2 mcccurved_guide_1_0_w2
#define h2 mcccurved_guide_1_0_h2
#define l mcccurved_guide_1_0_l
#define R0 mcccurved_guide_1_0_R0
#define Qc mcccurved_guide_1_0_Qc
#define alpha mcccurved_guide_1_0_alpha
#define m mcccurved_guide_1_0_m
#define W mcccurved_guide_1_0_W
#define nslit mcccurved_guide_1_0_nslit
#define d mcccurved_guide_1_0_d
#define mleft mcccurved_guide_1_0_mleft
#define mright mcccurved_guide_1_0_mright
#define mtop mcccurved_guide_1_0_mtop
#define mbottom mcccurved_guide_1_0_mbottom
#define nhslit mcccurved_guide_1_0_nhslit
#define G mcccurved_guide_1_0_G
#define aleft mcccurved_guide_1_0_aleft
#define aright mcccurved_guide_1_0_aright
#define atop mcccurved_guide_1_0_atop
#define abottom mcccurved_guide_1_0_abottom
#define wavy mcccurved_guide_1_0_wavy
#define wavy_z mcccurved_guide_1_0_wavy_z
#define wavy_tb mcccurved_guide_1_0_wavy_tb
#define wavy_lr mcccurved_guide_1_0_wavy_lr
#define chamfers mcccurved_guide_1_0_chamfers
#define chamfers_z mcccurved_guide_1_0_chamfers_z
#define chamfers_lr mcccurved_guide_1_0_chamfers_lr
#define chamfers_tb mcccurved_guide_1_0_chamfers_tb
#define nelements mcccurved_guide_1_0_nelements
#define nu mcccurved_guide_1_0_nu
#define phase mcccurved_guide_1_0_phase
#define reflect mcccurved_guide_1_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 29205 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_2_0. */
  SIG_MESSAGE("curved_guide_2_0 (Init)");
#define mccompcurname  curved_guide_2_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 8
#define GVars mcccurved_guide_2_0_GVars
#define pTable mcccurved_guide_2_0_pTable
#define w1 mcccurved_guide_2_0_w1
#define h1 mcccurved_guide_2_0_h1
#define w2 mcccurved_guide_2_0_w2
#define h2 mcccurved_guide_2_0_h2
#define l mcccurved_guide_2_0_l
#define R0 mcccurved_guide_2_0_R0
#define Qc mcccurved_guide_2_0_Qc
#define alpha mcccurved_guide_2_0_alpha
#define m mcccurved_guide_2_0_m
#define W mcccurved_guide_2_0_W
#define nslit mcccurved_guide_2_0_nslit
#define d mcccurved_guide_2_0_d
#define mleft mcccurved_guide_2_0_mleft
#define mright mcccurved_guide_2_0_mright
#define mtop mcccurved_guide_2_0_mtop
#define mbottom mcccurved_guide_2_0_mbottom
#define nhslit mcccurved_guide_2_0_nhslit
#define G mcccurved_guide_2_0_G
#define aleft mcccurved_guide_2_0_aleft
#define aright mcccurved_guide_2_0_aright
#define atop mcccurved_guide_2_0_atop
#define abottom mcccurved_guide_2_0_abottom
#define wavy mcccurved_guide_2_0_wavy
#define wavy_z mcccurved_guide_2_0_wavy_z
#define wavy_tb mcccurved_guide_2_0_wavy_tb
#define wavy_lr mcccurved_guide_2_0_wavy_lr
#define chamfers mcccurved_guide_2_0_chamfers
#define chamfers_z mcccurved_guide_2_0_chamfers_z
#define chamfers_lr mcccurved_guide_2_0_chamfers_lr
#define chamfers_tb mcccurved_guide_2_0_chamfers_tb
#define nelements mcccurved_guide_2_0_nelements
#define nu mcccurved_guide_2_0_nu
#define phase mcccurved_guide_2_0_phase
#define reflect mcccurved_guide_2_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 29339 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_3_0. */
  SIG_MESSAGE("curved_guide_3_0 (Init)");
#define mccompcurname  curved_guide_3_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 9
#define GVars mcccurved_guide_3_0_GVars
#define pTable mcccurved_guide_3_0_pTable
#define w1 mcccurved_guide_3_0_w1
#define h1 mcccurved_guide_3_0_h1
#define w2 mcccurved_guide_3_0_w2
#define h2 mcccurved_guide_3_0_h2
#define l mcccurved_guide_3_0_l
#define R0 mcccurved_guide_3_0_R0
#define Qc mcccurved_guide_3_0_Qc
#define alpha mcccurved_guide_3_0_alpha
#define m mcccurved_guide_3_0_m
#define W mcccurved_guide_3_0_W
#define nslit mcccurved_guide_3_0_nslit
#define d mcccurved_guide_3_0_d
#define mleft mcccurved_guide_3_0_mleft
#define mright mcccurved_guide_3_0_mright
#define mtop mcccurved_guide_3_0_mtop
#define mbottom mcccurved_guide_3_0_mbottom
#define nhslit mcccurved_guide_3_0_nhslit
#define G mcccurved_guide_3_0_G
#define aleft mcccurved_guide_3_0_aleft
#define aright mcccurved_guide_3_0_aright
#define atop mcccurved_guide_3_0_atop
#define abottom mcccurved_guide_3_0_abottom
#define wavy mcccurved_guide_3_0_wavy
#define wavy_z mcccurved_guide_3_0_wavy_z
#define wavy_tb mcccurved_guide_3_0_wavy_tb
#define wavy_lr mcccurved_guide_3_0_wavy_lr
#define chamfers mcccurved_guide_3_0_chamfers
#define chamfers_z mcccurved_guide_3_0_chamfers_z
#define chamfers_lr mcccurved_guide_3_0_chamfers_lr
#define chamfers_tb mcccurved_guide_3_0_chamfers_tb
#define nelements mcccurved_guide_3_0_nelements
#define nu mcccurved_guide_3_0_nu
#define phase mcccurved_guide_3_0_phase
#define reflect mcccurved_guide_3_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 29473 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_4_0. */
  SIG_MESSAGE("curved_guide_4_0 (Init)");
#define mccompcurname  curved_guide_4_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 10
#define GVars mcccurved_guide_4_0_GVars
#define pTable mcccurved_guide_4_0_pTable
#define w1 mcccurved_guide_4_0_w1
#define h1 mcccurved_guide_4_0_h1
#define w2 mcccurved_guide_4_0_w2
#define h2 mcccurved_guide_4_0_h2
#define l mcccurved_guide_4_0_l
#define R0 mcccurved_guide_4_0_R0
#define Qc mcccurved_guide_4_0_Qc
#define alpha mcccurved_guide_4_0_alpha
#define m mcccurved_guide_4_0_m
#define W mcccurved_guide_4_0_W
#define nslit mcccurved_guide_4_0_nslit
#define d mcccurved_guide_4_0_d
#define mleft mcccurved_guide_4_0_mleft
#define mright mcccurved_guide_4_0_mright
#define mtop mcccurved_guide_4_0_mtop
#define mbottom mcccurved_guide_4_0_mbottom
#define nhslit mcccurved_guide_4_0_nhslit
#define G mcccurved_guide_4_0_G
#define aleft mcccurved_guide_4_0_aleft
#define aright mcccurved_guide_4_0_aright
#define atop mcccurved_guide_4_0_atop
#define abottom mcccurved_guide_4_0_abottom
#define wavy mcccurved_guide_4_0_wavy
#define wavy_z mcccurved_guide_4_0_wavy_z
#define wavy_tb mcccurved_guide_4_0_wavy_tb
#define wavy_lr mcccurved_guide_4_0_wavy_lr
#define chamfers mcccurved_guide_4_0_chamfers
#define chamfers_z mcccurved_guide_4_0_chamfers_z
#define chamfers_lr mcccurved_guide_4_0_chamfers_lr
#define chamfers_tb mcccurved_guide_4_0_chamfers_tb
#define nelements mcccurved_guide_4_0_nelements
#define nu mcccurved_guide_4_0_nu
#define phase mcccurved_guide_4_0_phase
#define reflect mcccurved_guide_4_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 29607 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_5_beforeChopper. */
  SIG_MESSAGE("curved_guide_5_beforeChopper (Init)");
#define mccompcurname  curved_guide_5_beforeChopper
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 11
#define GVars mcccurved_guide_5_beforeChopper_GVars
#define pTable mcccurved_guide_5_beforeChopper_pTable
#define w1 mcccurved_guide_5_beforeChopper_w1
#define h1 mcccurved_guide_5_beforeChopper_h1
#define w2 mcccurved_guide_5_beforeChopper_w2
#define h2 mcccurved_guide_5_beforeChopper_h2
#define l mcccurved_guide_5_beforeChopper_l
#define R0 mcccurved_guide_5_beforeChopper_R0
#define Qc mcccurved_guide_5_beforeChopper_Qc
#define alpha mcccurved_guide_5_beforeChopper_alpha
#define m mcccurved_guide_5_beforeChopper_m
#define W mcccurved_guide_5_beforeChopper_W
#define nslit mcccurved_guide_5_beforeChopper_nslit
#define d mcccurved_guide_5_beforeChopper_d
#define mleft mcccurved_guide_5_beforeChopper_mleft
#define mright mcccurved_guide_5_beforeChopper_mright
#define mtop mcccurved_guide_5_beforeChopper_mtop
#define mbottom mcccurved_guide_5_beforeChopper_mbottom
#define nhslit mcccurved_guide_5_beforeChopper_nhslit
#define G mcccurved_guide_5_beforeChopper_G
#define aleft mcccurved_guide_5_beforeChopper_aleft
#define aright mcccurved_guide_5_beforeChopper_aright
#define atop mcccurved_guide_5_beforeChopper_atop
#define abottom mcccurved_guide_5_beforeChopper_abottom
#define wavy mcccurved_guide_5_beforeChopper_wavy
#define wavy_z mcccurved_guide_5_beforeChopper_wavy_z
#define wavy_tb mcccurved_guide_5_beforeChopper_wavy_tb
#define wavy_lr mcccurved_guide_5_beforeChopper_wavy_lr
#define chamfers mcccurved_guide_5_beforeChopper_chamfers
#define chamfers_z mcccurved_guide_5_beforeChopper_chamfers_z
#define chamfers_lr mcccurved_guide_5_beforeChopper_chamfers_lr
#define chamfers_tb mcccurved_guide_5_beforeChopper_chamfers_tb
#define nelements mcccurved_guide_5_beforeChopper_nelements
#define nu mcccurved_guide_5_beforeChopper_nu
#define phase mcccurved_guide_5_beforeChopper_phase
#define reflect mcccurved_guide_5_beforeChopper_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 29741 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_5_afterChopper. */
  SIG_MESSAGE("curved_guide_5_afterChopper (Init)");
#define mccompcurname  curved_guide_5_afterChopper
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 12
#define GVars mcccurved_guide_5_afterChopper_GVars
#define pTable mcccurved_guide_5_afterChopper_pTable
#define w1 mcccurved_guide_5_afterChopper_w1
#define h1 mcccurved_guide_5_afterChopper_h1
#define w2 mcccurved_guide_5_afterChopper_w2
#define h2 mcccurved_guide_5_afterChopper_h2
#define l mcccurved_guide_5_afterChopper_l
#define R0 mcccurved_guide_5_afterChopper_R0
#define Qc mcccurved_guide_5_afterChopper_Qc
#define alpha mcccurved_guide_5_afterChopper_alpha
#define m mcccurved_guide_5_afterChopper_m
#define W mcccurved_guide_5_afterChopper_W
#define nslit mcccurved_guide_5_afterChopper_nslit
#define d mcccurved_guide_5_afterChopper_d
#define mleft mcccurved_guide_5_afterChopper_mleft
#define mright mcccurved_guide_5_afterChopper_mright
#define mtop mcccurved_guide_5_afterChopper_mtop
#define mbottom mcccurved_guide_5_afterChopper_mbottom
#define nhslit mcccurved_guide_5_afterChopper_nhslit
#define G mcccurved_guide_5_afterChopper_G
#define aleft mcccurved_guide_5_afterChopper_aleft
#define aright mcccurved_guide_5_afterChopper_aright
#define atop mcccurved_guide_5_afterChopper_atop
#define abottom mcccurved_guide_5_afterChopper_abottom
#define wavy mcccurved_guide_5_afterChopper_wavy
#define wavy_z mcccurved_guide_5_afterChopper_wavy_z
#define wavy_tb mcccurved_guide_5_afterChopper_wavy_tb
#define wavy_lr mcccurved_guide_5_afterChopper_wavy_lr
#define chamfers mcccurved_guide_5_afterChopper_chamfers
#define chamfers_z mcccurved_guide_5_afterChopper_chamfers_z
#define chamfers_lr mcccurved_guide_5_afterChopper_chamfers_lr
#define chamfers_tb mcccurved_guide_5_afterChopper_chamfers_tb
#define nelements mcccurved_guide_5_afterChopper_nelements
#define nu mcccurved_guide_5_afterChopper_nu
#define phase mcccurved_guide_5_afterChopper_phase
#define reflect mcccurved_guide_5_afterChopper_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 29875 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_6_0. */
  SIG_MESSAGE("curved_guide_6_0 (Init)");
#define mccompcurname  curved_guide_6_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 13
#define GVars mcccurved_guide_6_0_GVars
#define pTable mcccurved_guide_6_0_pTable
#define w1 mcccurved_guide_6_0_w1
#define h1 mcccurved_guide_6_0_h1
#define w2 mcccurved_guide_6_0_w2
#define h2 mcccurved_guide_6_0_h2
#define l mcccurved_guide_6_0_l
#define R0 mcccurved_guide_6_0_R0
#define Qc mcccurved_guide_6_0_Qc
#define alpha mcccurved_guide_6_0_alpha
#define m mcccurved_guide_6_0_m
#define W mcccurved_guide_6_0_W
#define nslit mcccurved_guide_6_0_nslit
#define d mcccurved_guide_6_0_d
#define mleft mcccurved_guide_6_0_mleft
#define mright mcccurved_guide_6_0_mright
#define mtop mcccurved_guide_6_0_mtop
#define mbottom mcccurved_guide_6_0_mbottom
#define nhslit mcccurved_guide_6_0_nhslit
#define G mcccurved_guide_6_0_G
#define aleft mcccurved_guide_6_0_aleft
#define aright mcccurved_guide_6_0_aright
#define atop mcccurved_guide_6_0_atop
#define abottom mcccurved_guide_6_0_abottom
#define wavy mcccurved_guide_6_0_wavy
#define wavy_z mcccurved_guide_6_0_wavy_z
#define wavy_tb mcccurved_guide_6_0_wavy_tb
#define wavy_lr mcccurved_guide_6_0_wavy_lr
#define chamfers mcccurved_guide_6_0_chamfers
#define chamfers_z mcccurved_guide_6_0_chamfers_z
#define chamfers_lr mcccurved_guide_6_0_chamfers_lr
#define chamfers_tb mcccurved_guide_6_0_chamfers_tb
#define nelements mcccurved_guide_6_0_nelements
#define nu mcccurved_guide_6_0_nu
#define phase mcccurved_guide_6_0_phase
#define reflect mcccurved_guide_6_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 30009 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_7_0. */
  SIG_MESSAGE("curved_guide_7_0 (Init)");
#define mccompcurname  curved_guide_7_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 14
#define GVars mcccurved_guide_7_0_GVars
#define pTable mcccurved_guide_7_0_pTable
#define w1 mcccurved_guide_7_0_w1
#define h1 mcccurved_guide_7_0_h1
#define w2 mcccurved_guide_7_0_w2
#define h2 mcccurved_guide_7_0_h2
#define l mcccurved_guide_7_0_l
#define R0 mcccurved_guide_7_0_R0
#define Qc mcccurved_guide_7_0_Qc
#define alpha mcccurved_guide_7_0_alpha
#define m mcccurved_guide_7_0_m
#define W mcccurved_guide_7_0_W
#define nslit mcccurved_guide_7_0_nslit
#define d mcccurved_guide_7_0_d
#define mleft mcccurved_guide_7_0_mleft
#define mright mcccurved_guide_7_0_mright
#define mtop mcccurved_guide_7_0_mtop
#define mbottom mcccurved_guide_7_0_mbottom
#define nhslit mcccurved_guide_7_0_nhslit
#define G mcccurved_guide_7_0_G
#define aleft mcccurved_guide_7_0_aleft
#define aright mcccurved_guide_7_0_aright
#define atop mcccurved_guide_7_0_atop
#define abottom mcccurved_guide_7_0_abottom
#define wavy mcccurved_guide_7_0_wavy
#define wavy_z mcccurved_guide_7_0_wavy_z
#define wavy_tb mcccurved_guide_7_0_wavy_tb
#define wavy_lr mcccurved_guide_7_0_wavy_lr
#define chamfers mcccurved_guide_7_0_chamfers
#define chamfers_z mcccurved_guide_7_0_chamfers_z
#define chamfers_lr mcccurved_guide_7_0_chamfers_lr
#define chamfers_tb mcccurved_guide_7_0_chamfers_tb
#define nelements mcccurved_guide_7_0_nelements
#define nu mcccurved_guide_7_0_nu
#define phase mcccurved_guide_7_0_phase
#define reflect mcccurved_guide_7_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 30143 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_8_0. */
  SIG_MESSAGE("curved_guide_8_0 (Init)");
#define mccompcurname  curved_guide_8_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 15
#define GVars mcccurved_guide_8_0_GVars
#define pTable mcccurved_guide_8_0_pTable
#define w1 mcccurved_guide_8_0_w1
#define h1 mcccurved_guide_8_0_h1
#define w2 mcccurved_guide_8_0_w2
#define h2 mcccurved_guide_8_0_h2
#define l mcccurved_guide_8_0_l
#define R0 mcccurved_guide_8_0_R0
#define Qc mcccurved_guide_8_0_Qc
#define alpha mcccurved_guide_8_0_alpha
#define m mcccurved_guide_8_0_m
#define W mcccurved_guide_8_0_W
#define nslit mcccurved_guide_8_0_nslit
#define d mcccurved_guide_8_0_d
#define mleft mcccurved_guide_8_0_mleft
#define mright mcccurved_guide_8_0_mright
#define mtop mcccurved_guide_8_0_mtop
#define mbottom mcccurved_guide_8_0_mbottom
#define nhslit mcccurved_guide_8_0_nhslit
#define G mcccurved_guide_8_0_G
#define aleft mcccurved_guide_8_0_aleft
#define aright mcccurved_guide_8_0_aright
#define atop mcccurved_guide_8_0_atop
#define abottom mcccurved_guide_8_0_abottom
#define wavy mcccurved_guide_8_0_wavy
#define wavy_z mcccurved_guide_8_0_wavy_z
#define wavy_tb mcccurved_guide_8_0_wavy_tb
#define wavy_lr mcccurved_guide_8_0_wavy_lr
#define chamfers mcccurved_guide_8_0_chamfers
#define chamfers_z mcccurved_guide_8_0_chamfers_z
#define chamfers_lr mcccurved_guide_8_0_chamfers_lr
#define chamfers_tb mcccurved_guide_8_0_chamfers_tb
#define nelements mcccurved_guide_8_0_nelements
#define nu mcccurved_guide_8_0_nu
#define phase mcccurved_guide_8_0_phase
#define reflect mcccurved_guide_8_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 30277 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_9_0. */
  SIG_MESSAGE("curved_guide_9_0 (Init)");
#define mccompcurname  curved_guide_9_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 16
#define GVars mcccurved_guide_9_0_GVars
#define pTable mcccurved_guide_9_0_pTable
#define w1 mcccurved_guide_9_0_w1
#define h1 mcccurved_guide_9_0_h1
#define w2 mcccurved_guide_9_0_w2
#define h2 mcccurved_guide_9_0_h2
#define l mcccurved_guide_9_0_l
#define R0 mcccurved_guide_9_0_R0
#define Qc mcccurved_guide_9_0_Qc
#define alpha mcccurved_guide_9_0_alpha
#define m mcccurved_guide_9_0_m
#define W mcccurved_guide_9_0_W
#define nslit mcccurved_guide_9_0_nslit
#define d mcccurved_guide_9_0_d
#define mleft mcccurved_guide_9_0_mleft
#define mright mcccurved_guide_9_0_mright
#define mtop mcccurved_guide_9_0_mtop
#define mbottom mcccurved_guide_9_0_mbottom
#define nhslit mcccurved_guide_9_0_nhslit
#define G mcccurved_guide_9_0_G
#define aleft mcccurved_guide_9_0_aleft
#define aright mcccurved_guide_9_0_aright
#define atop mcccurved_guide_9_0_atop
#define abottom mcccurved_guide_9_0_abottom
#define wavy mcccurved_guide_9_0_wavy
#define wavy_z mcccurved_guide_9_0_wavy_z
#define wavy_tb mcccurved_guide_9_0_wavy_tb
#define wavy_lr mcccurved_guide_9_0_wavy_lr
#define chamfers mcccurved_guide_9_0_chamfers
#define chamfers_z mcccurved_guide_9_0_chamfers_z
#define chamfers_lr mcccurved_guide_9_0_chamfers_lr
#define chamfers_tb mcccurved_guide_9_0_chamfers_tb
#define nelements mcccurved_guide_9_0_nelements
#define nu mcccurved_guide_9_0_nu
#define phase mcccurved_guide_9_0_phase
#define reflect mcccurved_guide_9_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 30411 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_10_0. */
  SIG_MESSAGE("curved_guide_10_0 (Init)");
#define mccompcurname  curved_guide_10_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 17
#define GVars mcccurved_guide_10_0_GVars
#define pTable mcccurved_guide_10_0_pTable
#define w1 mcccurved_guide_10_0_w1
#define h1 mcccurved_guide_10_0_h1
#define w2 mcccurved_guide_10_0_w2
#define h2 mcccurved_guide_10_0_h2
#define l mcccurved_guide_10_0_l
#define R0 mcccurved_guide_10_0_R0
#define Qc mcccurved_guide_10_0_Qc
#define alpha mcccurved_guide_10_0_alpha
#define m mcccurved_guide_10_0_m
#define W mcccurved_guide_10_0_W
#define nslit mcccurved_guide_10_0_nslit
#define d mcccurved_guide_10_0_d
#define mleft mcccurved_guide_10_0_mleft
#define mright mcccurved_guide_10_0_mright
#define mtop mcccurved_guide_10_0_mtop
#define mbottom mcccurved_guide_10_0_mbottom
#define nhslit mcccurved_guide_10_0_nhslit
#define G mcccurved_guide_10_0_G
#define aleft mcccurved_guide_10_0_aleft
#define aright mcccurved_guide_10_0_aright
#define atop mcccurved_guide_10_0_atop
#define abottom mcccurved_guide_10_0_abottom
#define wavy mcccurved_guide_10_0_wavy
#define wavy_z mcccurved_guide_10_0_wavy_z
#define wavy_tb mcccurved_guide_10_0_wavy_tb
#define wavy_lr mcccurved_guide_10_0_wavy_lr
#define chamfers mcccurved_guide_10_0_chamfers
#define chamfers_z mcccurved_guide_10_0_chamfers_z
#define chamfers_lr mcccurved_guide_10_0_chamfers_lr
#define chamfers_tb mcccurved_guide_10_0_chamfers_tb
#define nelements mcccurved_guide_10_0_nelements
#define nu mcccurved_guide_10_0_nu
#define phase mcccurved_guide_10_0_phase
#define reflect mcccurved_guide_10_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 30545 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_11_0. */
  SIG_MESSAGE("curved_guide_11_0 (Init)");
#define mccompcurname  curved_guide_11_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 18
#define GVars mcccurved_guide_11_0_GVars
#define pTable mcccurved_guide_11_0_pTable
#define w1 mcccurved_guide_11_0_w1
#define h1 mcccurved_guide_11_0_h1
#define w2 mcccurved_guide_11_0_w2
#define h2 mcccurved_guide_11_0_h2
#define l mcccurved_guide_11_0_l
#define R0 mcccurved_guide_11_0_R0
#define Qc mcccurved_guide_11_0_Qc
#define alpha mcccurved_guide_11_0_alpha
#define m mcccurved_guide_11_0_m
#define W mcccurved_guide_11_0_W
#define nslit mcccurved_guide_11_0_nslit
#define d mcccurved_guide_11_0_d
#define mleft mcccurved_guide_11_0_mleft
#define mright mcccurved_guide_11_0_mright
#define mtop mcccurved_guide_11_0_mtop
#define mbottom mcccurved_guide_11_0_mbottom
#define nhslit mcccurved_guide_11_0_nhslit
#define G mcccurved_guide_11_0_G
#define aleft mcccurved_guide_11_0_aleft
#define aright mcccurved_guide_11_0_aright
#define atop mcccurved_guide_11_0_atop
#define abottom mcccurved_guide_11_0_abottom
#define wavy mcccurved_guide_11_0_wavy
#define wavy_z mcccurved_guide_11_0_wavy_z
#define wavy_tb mcccurved_guide_11_0_wavy_tb
#define wavy_lr mcccurved_guide_11_0_wavy_lr
#define chamfers mcccurved_guide_11_0_chamfers
#define chamfers_z mcccurved_guide_11_0_chamfers_z
#define chamfers_lr mcccurved_guide_11_0_chamfers_lr
#define chamfers_tb mcccurved_guide_11_0_chamfers_tb
#define nelements mcccurved_guide_11_0_nelements
#define nu mcccurved_guide_11_0_nu
#define phase mcccurved_guide_11_0_phase
#define reflect mcccurved_guide_11_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 30679 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_12_0. */
  SIG_MESSAGE("curved_guide_12_0 (Init)");
#define mccompcurname  curved_guide_12_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 19
#define GVars mcccurved_guide_12_0_GVars
#define pTable mcccurved_guide_12_0_pTable
#define w1 mcccurved_guide_12_0_w1
#define h1 mcccurved_guide_12_0_h1
#define w2 mcccurved_guide_12_0_w2
#define h2 mcccurved_guide_12_0_h2
#define l mcccurved_guide_12_0_l
#define R0 mcccurved_guide_12_0_R0
#define Qc mcccurved_guide_12_0_Qc
#define alpha mcccurved_guide_12_0_alpha
#define m mcccurved_guide_12_0_m
#define W mcccurved_guide_12_0_W
#define nslit mcccurved_guide_12_0_nslit
#define d mcccurved_guide_12_0_d
#define mleft mcccurved_guide_12_0_mleft
#define mright mcccurved_guide_12_0_mright
#define mtop mcccurved_guide_12_0_mtop
#define mbottom mcccurved_guide_12_0_mbottom
#define nhslit mcccurved_guide_12_0_nhslit
#define G mcccurved_guide_12_0_G
#define aleft mcccurved_guide_12_0_aleft
#define aright mcccurved_guide_12_0_aright
#define atop mcccurved_guide_12_0_atop
#define abottom mcccurved_guide_12_0_abottom
#define wavy mcccurved_guide_12_0_wavy
#define wavy_z mcccurved_guide_12_0_wavy_z
#define wavy_tb mcccurved_guide_12_0_wavy_tb
#define wavy_lr mcccurved_guide_12_0_wavy_lr
#define chamfers mcccurved_guide_12_0_chamfers
#define chamfers_z mcccurved_guide_12_0_chamfers_z
#define chamfers_lr mcccurved_guide_12_0_chamfers_lr
#define chamfers_tb mcccurved_guide_12_0_chamfers_tb
#define nelements mcccurved_guide_12_0_nelements
#define nu mcccurved_guide_12_0_nu
#define phase mcccurved_guide_12_0_phase
#define reflect mcccurved_guide_12_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 30813 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_13_0. */
  SIG_MESSAGE("curved_guide_13_0 (Init)");
#define mccompcurname  curved_guide_13_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 20
#define GVars mcccurved_guide_13_0_GVars
#define pTable mcccurved_guide_13_0_pTable
#define w1 mcccurved_guide_13_0_w1
#define h1 mcccurved_guide_13_0_h1
#define w2 mcccurved_guide_13_0_w2
#define h2 mcccurved_guide_13_0_h2
#define l mcccurved_guide_13_0_l
#define R0 mcccurved_guide_13_0_R0
#define Qc mcccurved_guide_13_0_Qc
#define alpha mcccurved_guide_13_0_alpha
#define m mcccurved_guide_13_0_m
#define W mcccurved_guide_13_0_W
#define nslit mcccurved_guide_13_0_nslit
#define d mcccurved_guide_13_0_d
#define mleft mcccurved_guide_13_0_mleft
#define mright mcccurved_guide_13_0_mright
#define mtop mcccurved_guide_13_0_mtop
#define mbottom mcccurved_guide_13_0_mbottom
#define nhslit mcccurved_guide_13_0_nhslit
#define G mcccurved_guide_13_0_G
#define aleft mcccurved_guide_13_0_aleft
#define aright mcccurved_guide_13_0_aright
#define atop mcccurved_guide_13_0_atop
#define abottom mcccurved_guide_13_0_abottom
#define wavy mcccurved_guide_13_0_wavy
#define wavy_z mcccurved_guide_13_0_wavy_z
#define wavy_tb mcccurved_guide_13_0_wavy_tb
#define wavy_lr mcccurved_guide_13_0_wavy_lr
#define chamfers mcccurved_guide_13_0_chamfers
#define chamfers_z mcccurved_guide_13_0_chamfers_z
#define chamfers_lr mcccurved_guide_13_0_chamfers_lr
#define chamfers_tb mcccurved_guide_13_0_chamfers_tb
#define nelements mcccurved_guide_13_0_nelements
#define nu mcccurved_guide_13_0_nu
#define phase mcccurved_guide_13_0_phase
#define reflect mcccurved_guide_13_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 30947 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_14_0. */
  SIG_MESSAGE("curved_guide_14_0 (Init)");
#define mccompcurname  curved_guide_14_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 21
#define GVars mcccurved_guide_14_0_GVars
#define pTable mcccurved_guide_14_0_pTable
#define w1 mcccurved_guide_14_0_w1
#define h1 mcccurved_guide_14_0_h1
#define w2 mcccurved_guide_14_0_w2
#define h2 mcccurved_guide_14_0_h2
#define l mcccurved_guide_14_0_l
#define R0 mcccurved_guide_14_0_R0
#define Qc mcccurved_guide_14_0_Qc
#define alpha mcccurved_guide_14_0_alpha
#define m mcccurved_guide_14_0_m
#define W mcccurved_guide_14_0_W
#define nslit mcccurved_guide_14_0_nslit
#define d mcccurved_guide_14_0_d
#define mleft mcccurved_guide_14_0_mleft
#define mright mcccurved_guide_14_0_mright
#define mtop mcccurved_guide_14_0_mtop
#define mbottom mcccurved_guide_14_0_mbottom
#define nhslit mcccurved_guide_14_0_nhslit
#define G mcccurved_guide_14_0_G
#define aleft mcccurved_guide_14_0_aleft
#define aright mcccurved_guide_14_0_aright
#define atop mcccurved_guide_14_0_atop
#define abottom mcccurved_guide_14_0_abottom
#define wavy mcccurved_guide_14_0_wavy
#define wavy_z mcccurved_guide_14_0_wavy_z
#define wavy_tb mcccurved_guide_14_0_wavy_tb
#define wavy_lr mcccurved_guide_14_0_wavy_lr
#define chamfers mcccurved_guide_14_0_chamfers
#define chamfers_z mcccurved_guide_14_0_chamfers_z
#define chamfers_lr mcccurved_guide_14_0_chamfers_lr
#define chamfers_tb mcccurved_guide_14_0_chamfers_tb
#define nelements mcccurved_guide_14_0_nelements
#define nu mcccurved_guide_14_0_nu
#define phase mcccurved_guide_14_0_phase
#define reflect mcccurved_guide_14_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 31081 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_15_0. */
  SIG_MESSAGE("curved_guide_15_0 (Init)");
#define mccompcurname  curved_guide_15_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 22
#define GVars mcccurved_guide_15_0_GVars
#define pTable mcccurved_guide_15_0_pTable
#define w1 mcccurved_guide_15_0_w1
#define h1 mcccurved_guide_15_0_h1
#define w2 mcccurved_guide_15_0_w2
#define h2 mcccurved_guide_15_0_h2
#define l mcccurved_guide_15_0_l
#define R0 mcccurved_guide_15_0_R0
#define Qc mcccurved_guide_15_0_Qc
#define alpha mcccurved_guide_15_0_alpha
#define m mcccurved_guide_15_0_m
#define W mcccurved_guide_15_0_W
#define nslit mcccurved_guide_15_0_nslit
#define d mcccurved_guide_15_0_d
#define mleft mcccurved_guide_15_0_mleft
#define mright mcccurved_guide_15_0_mright
#define mtop mcccurved_guide_15_0_mtop
#define mbottom mcccurved_guide_15_0_mbottom
#define nhslit mcccurved_guide_15_0_nhslit
#define G mcccurved_guide_15_0_G
#define aleft mcccurved_guide_15_0_aleft
#define aright mcccurved_guide_15_0_aright
#define atop mcccurved_guide_15_0_atop
#define abottom mcccurved_guide_15_0_abottom
#define wavy mcccurved_guide_15_0_wavy
#define wavy_z mcccurved_guide_15_0_wavy_z
#define wavy_tb mcccurved_guide_15_0_wavy_tb
#define wavy_lr mcccurved_guide_15_0_wavy_lr
#define chamfers mcccurved_guide_15_0_chamfers
#define chamfers_z mcccurved_guide_15_0_chamfers_z
#define chamfers_lr mcccurved_guide_15_0_chamfers_lr
#define chamfers_tb mcccurved_guide_15_0_chamfers_tb
#define nelements mcccurved_guide_15_0_nelements
#define nu mcccurved_guide_15_0_nu
#define phase mcccurved_guide_15_0_phase
#define reflect mcccurved_guide_15_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 31215 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_16_0. */
  SIG_MESSAGE("curved_guide_16_0 (Init)");
#define mccompcurname  curved_guide_16_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 23
#define GVars mcccurved_guide_16_0_GVars
#define pTable mcccurved_guide_16_0_pTable
#define w1 mcccurved_guide_16_0_w1
#define h1 mcccurved_guide_16_0_h1
#define w2 mcccurved_guide_16_0_w2
#define h2 mcccurved_guide_16_0_h2
#define l mcccurved_guide_16_0_l
#define R0 mcccurved_guide_16_0_R0
#define Qc mcccurved_guide_16_0_Qc
#define alpha mcccurved_guide_16_0_alpha
#define m mcccurved_guide_16_0_m
#define W mcccurved_guide_16_0_W
#define nslit mcccurved_guide_16_0_nslit
#define d mcccurved_guide_16_0_d
#define mleft mcccurved_guide_16_0_mleft
#define mright mcccurved_guide_16_0_mright
#define mtop mcccurved_guide_16_0_mtop
#define mbottom mcccurved_guide_16_0_mbottom
#define nhslit mcccurved_guide_16_0_nhslit
#define G mcccurved_guide_16_0_G
#define aleft mcccurved_guide_16_0_aleft
#define aright mcccurved_guide_16_0_aright
#define atop mcccurved_guide_16_0_atop
#define abottom mcccurved_guide_16_0_abottom
#define wavy mcccurved_guide_16_0_wavy
#define wavy_z mcccurved_guide_16_0_wavy_z
#define wavy_tb mcccurved_guide_16_0_wavy_tb
#define wavy_lr mcccurved_guide_16_0_wavy_lr
#define chamfers mcccurved_guide_16_0_chamfers
#define chamfers_z mcccurved_guide_16_0_chamfers_z
#define chamfers_lr mcccurved_guide_16_0_chamfers_lr
#define chamfers_tb mcccurved_guide_16_0_chamfers_tb
#define nelements mcccurved_guide_16_0_nelements
#define nu mcccurved_guide_16_0_nu
#define phase mcccurved_guide_16_0_phase
#define reflect mcccurved_guide_16_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 31349 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_17_0. */
  SIG_MESSAGE("curved_guide_17_0 (Init)");
#define mccompcurname  curved_guide_17_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 24
#define GVars mcccurved_guide_17_0_GVars
#define pTable mcccurved_guide_17_0_pTable
#define w1 mcccurved_guide_17_0_w1
#define h1 mcccurved_guide_17_0_h1
#define w2 mcccurved_guide_17_0_w2
#define h2 mcccurved_guide_17_0_h2
#define l mcccurved_guide_17_0_l
#define R0 mcccurved_guide_17_0_R0
#define Qc mcccurved_guide_17_0_Qc
#define alpha mcccurved_guide_17_0_alpha
#define m mcccurved_guide_17_0_m
#define W mcccurved_guide_17_0_W
#define nslit mcccurved_guide_17_0_nslit
#define d mcccurved_guide_17_0_d
#define mleft mcccurved_guide_17_0_mleft
#define mright mcccurved_guide_17_0_mright
#define mtop mcccurved_guide_17_0_mtop
#define mbottom mcccurved_guide_17_0_mbottom
#define nhslit mcccurved_guide_17_0_nhslit
#define G mcccurved_guide_17_0_G
#define aleft mcccurved_guide_17_0_aleft
#define aright mcccurved_guide_17_0_aright
#define atop mcccurved_guide_17_0_atop
#define abottom mcccurved_guide_17_0_abottom
#define wavy mcccurved_guide_17_0_wavy
#define wavy_z mcccurved_guide_17_0_wavy_z
#define wavy_tb mcccurved_guide_17_0_wavy_tb
#define wavy_lr mcccurved_guide_17_0_wavy_lr
#define chamfers mcccurved_guide_17_0_chamfers
#define chamfers_z mcccurved_guide_17_0_chamfers_z
#define chamfers_lr mcccurved_guide_17_0_chamfers_lr
#define chamfers_tb mcccurved_guide_17_0_chamfers_tb
#define nelements mcccurved_guide_17_0_nelements
#define nu mcccurved_guide_17_0_nu
#define phase mcccurved_guide_17_0_phase
#define reflect mcccurved_guide_17_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 31483 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_18_beforeChopper. */
  SIG_MESSAGE("curved_guide_18_beforeChopper (Init)");
#define mccompcurname  curved_guide_18_beforeChopper
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 25
#define GVars mcccurved_guide_18_beforeChopper_GVars
#define pTable mcccurved_guide_18_beforeChopper_pTable
#define w1 mcccurved_guide_18_beforeChopper_w1
#define h1 mcccurved_guide_18_beforeChopper_h1
#define w2 mcccurved_guide_18_beforeChopper_w2
#define h2 mcccurved_guide_18_beforeChopper_h2
#define l mcccurved_guide_18_beforeChopper_l
#define R0 mcccurved_guide_18_beforeChopper_R0
#define Qc mcccurved_guide_18_beforeChopper_Qc
#define alpha mcccurved_guide_18_beforeChopper_alpha
#define m mcccurved_guide_18_beforeChopper_m
#define W mcccurved_guide_18_beforeChopper_W
#define nslit mcccurved_guide_18_beforeChopper_nslit
#define d mcccurved_guide_18_beforeChopper_d
#define mleft mcccurved_guide_18_beforeChopper_mleft
#define mright mcccurved_guide_18_beforeChopper_mright
#define mtop mcccurved_guide_18_beforeChopper_mtop
#define mbottom mcccurved_guide_18_beforeChopper_mbottom
#define nhslit mcccurved_guide_18_beforeChopper_nhslit
#define G mcccurved_guide_18_beforeChopper_G
#define aleft mcccurved_guide_18_beforeChopper_aleft
#define aright mcccurved_guide_18_beforeChopper_aright
#define atop mcccurved_guide_18_beforeChopper_atop
#define abottom mcccurved_guide_18_beforeChopper_abottom
#define wavy mcccurved_guide_18_beforeChopper_wavy
#define wavy_z mcccurved_guide_18_beforeChopper_wavy_z
#define wavy_tb mcccurved_guide_18_beforeChopper_wavy_tb
#define wavy_lr mcccurved_guide_18_beforeChopper_wavy_lr
#define chamfers mcccurved_guide_18_beforeChopper_chamfers
#define chamfers_z mcccurved_guide_18_beforeChopper_chamfers_z
#define chamfers_lr mcccurved_guide_18_beforeChopper_chamfers_lr
#define chamfers_tb mcccurved_guide_18_beforeChopper_chamfers_tb
#define nelements mcccurved_guide_18_beforeChopper_nelements
#define nu mcccurved_guide_18_beforeChopper_nu
#define phase mcccurved_guide_18_beforeChopper_phase
#define reflect mcccurved_guide_18_beforeChopper_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 31617 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_18_afterChopper. */
  SIG_MESSAGE("curved_guide_18_afterChopper (Init)");
#define mccompcurname  curved_guide_18_afterChopper
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 26
#define GVars mcccurved_guide_18_afterChopper_GVars
#define pTable mcccurved_guide_18_afterChopper_pTable
#define w1 mcccurved_guide_18_afterChopper_w1
#define h1 mcccurved_guide_18_afterChopper_h1
#define w2 mcccurved_guide_18_afterChopper_w2
#define h2 mcccurved_guide_18_afterChopper_h2
#define l mcccurved_guide_18_afterChopper_l
#define R0 mcccurved_guide_18_afterChopper_R0
#define Qc mcccurved_guide_18_afterChopper_Qc
#define alpha mcccurved_guide_18_afterChopper_alpha
#define m mcccurved_guide_18_afterChopper_m
#define W mcccurved_guide_18_afterChopper_W
#define nslit mcccurved_guide_18_afterChopper_nslit
#define d mcccurved_guide_18_afterChopper_d
#define mleft mcccurved_guide_18_afterChopper_mleft
#define mright mcccurved_guide_18_afterChopper_mright
#define mtop mcccurved_guide_18_afterChopper_mtop
#define mbottom mcccurved_guide_18_afterChopper_mbottom
#define nhslit mcccurved_guide_18_afterChopper_nhslit
#define G mcccurved_guide_18_afterChopper_G
#define aleft mcccurved_guide_18_afterChopper_aleft
#define aright mcccurved_guide_18_afterChopper_aright
#define atop mcccurved_guide_18_afterChopper_atop
#define abottom mcccurved_guide_18_afterChopper_abottom
#define wavy mcccurved_guide_18_afterChopper_wavy
#define wavy_z mcccurved_guide_18_afterChopper_wavy_z
#define wavy_tb mcccurved_guide_18_afterChopper_wavy_tb
#define wavy_lr mcccurved_guide_18_afterChopper_wavy_lr
#define chamfers mcccurved_guide_18_afterChopper_chamfers
#define chamfers_z mcccurved_guide_18_afterChopper_chamfers_z
#define chamfers_lr mcccurved_guide_18_afterChopper_chamfers_lr
#define chamfers_tb mcccurved_guide_18_afterChopper_chamfers_tb
#define nelements mcccurved_guide_18_afterChopper_nelements
#define nu mcccurved_guide_18_afterChopper_nu
#define phase mcccurved_guide_18_afterChopper_phase
#define reflect mcccurved_guide_18_afterChopper_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 31751 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_19_0. */
  SIG_MESSAGE("curved_guide_19_0 (Init)");
#define mccompcurname  curved_guide_19_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 27
#define GVars mcccurved_guide_19_0_GVars
#define pTable mcccurved_guide_19_0_pTable
#define w1 mcccurved_guide_19_0_w1
#define h1 mcccurved_guide_19_0_h1
#define w2 mcccurved_guide_19_0_w2
#define h2 mcccurved_guide_19_0_h2
#define l mcccurved_guide_19_0_l
#define R0 mcccurved_guide_19_0_R0
#define Qc mcccurved_guide_19_0_Qc
#define alpha mcccurved_guide_19_0_alpha
#define m mcccurved_guide_19_0_m
#define W mcccurved_guide_19_0_W
#define nslit mcccurved_guide_19_0_nslit
#define d mcccurved_guide_19_0_d
#define mleft mcccurved_guide_19_0_mleft
#define mright mcccurved_guide_19_0_mright
#define mtop mcccurved_guide_19_0_mtop
#define mbottom mcccurved_guide_19_0_mbottom
#define nhslit mcccurved_guide_19_0_nhslit
#define G mcccurved_guide_19_0_G
#define aleft mcccurved_guide_19_0_aleft
#define aright mcccurved_guide_19_0_aright
#define atop mcccurved_guide_19_0_atop
#define abottom mcccurved_guide_19_0_abottom
#define wavy mcccurved_guide_19_0_wavy
#define wavy_z mcccurved_guide_19_0_wavy_z
#define wavy_tb mcccurved_guide_19_0_wavy_tb
#define wavy_lr mcccurved_guide_19_0_wavy_lr
#define chamfers mcccurved_guide_19_0_chamfers
#define chamfers_z mcccurved_guide_19_0_chamfers_z
#define chamfers_lr mcccurved_guide_19_0_chamfers_lr
#define chamfers_tb mcccurved_guide_19_0_chamfers_tb
#define nelements mcccurved_guide_19_0_nelements
#define nu mcccurved_guide_19_0_nu
#define phase mcccurved_guide_19_0_phase
#define reflect mcccurved_guide_19_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 31885 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_20_0. */
  SIG_MESSAGE("curved_guide_20_0 (Init)");
#define mccompcurname  curved_guide_20_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 28
#define GVars mcccurved_guide_20_0_GVars
#define pTable mcccurved_guide_20_0_pTable
#define w1 mcccurved_guide_20_0_w1
#define h1 mcccurved_guide_20_0_h1
#define w2 mcccurved_guide_20_0_w2
#define h2 mcccurved_guide_20_0_h2
#define l mcccurved_guide_20_0_l
#define R0 mcccurved_guide_20_0_R0
#define Qc mcccurved_guide_20_0_Qc
#define alpha mcccurved_guide_20_0_alpha
#define m mcccurved_guide_20_0_m
#define W mcccurved_guide_20_0_W
#define nslit mcccurved_guide_20_0_nslit
#define d mcccurved_guide_20_0_d
#define mleft mcccurved_guide_20_0_mleft
#define mright mcccurved_guide_20_0_mright
#define mtop mcccurved_guide_20_0_mtop
#define mbottom mcccurved_guide_20_0_mbottom
#define nhslit mcccurved_guide_20_0_nhslit
#define G mcccurved_guide_20_0_G
#define aleft mcccurved_guide_20_0_aleft
#define aright mcccurved_guide_20_0_aright
#define atop mcccurved_guide_20_0_atop
#define abottom mcccurved_guide_20_0_abottom
#define wavy mcccurved_guide_20_0_wavy
#define wavy_z mcccurved_guide_20_0_wavy_z
#define wavy_tb mcccurved_guide_20_0_wavy_tb
#define wavy_lr mcccurved_guide_20_0_wavy_lr
#define chamfers mcccurved_guide_20_0_chamfers
#define chamfers_z mcccurved_guide_20_0_chamfers_z
#define chamfers_lr mcccurved_guide_20_0_chamfers_lr
#define chamfers_tb mcccurved_guide_20_0_chamfers_tb
#define nelements mcccurved_guide_20_0_nelements
#define nu mcccurved_guide_20_0_nu
#define phase mcccurved_guide_20_0_phase
#define reflect mcccurved_guide_20_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 32019 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_21_0. */
  SIG_MESSAGE("curved_guide_21_0 (Init)");
#define mccompcurname  curved_guide_21_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 29
#define GVars mcccurved_guide_21_0_GVars
#define pTable mcccurved_guide_21_0_pTable
#define w1 mcccurved_guide_21_0_w1
#define h1 mcccurved_guide_21_0_h1
#define w2 mcccurved_guide_21_0_w2
#define h2 mcccurved_guide_21_0_h2
#define l mcccurved_guide_21_0_l
#define R0 mcccurved_guide_21_0_R0
#define Qc mcccurved_guide_21_0_Qc
#define alpha mcccurved_guide_21_0_alpha
#define m mcccurved_guide_21_0_m
#define W mcccurved_guide_21_0_W
#define nslit mcccurved_guide_21_0_nslit
#define d mcccurved_guide_21_0_d
#define mleft mcccurved_guide_21_0_mleft
#define mright mcccurved_guide_21_0_mright
#define mtop mcccurved_guide_21_0_mtop
#define mbottom mcccurved_guide_21_0_mbottom
#define nhslit mcccurved_guide_21_0_nhslit
#define G mcccurved_guide_21_0_G
#define aleft mcccurved_guide_21_0_aleft
#define aright mcccurved_guide_21_0_aright
#define atop mcccurved_guide_21_0_atop
#define abottom mcccurved_guide_21_0_abottom
#define wavy mcccurved_guide_21_0_wavy
#define wavy_z mcccurved_guide_21_0_wavy_z
#define wavy_tb mcccurved_guide_21_0_wavy_tb
#define wavy_lr mcccurved_guide_21_0_wavy_lr
#define chamfers mcccurved_guide_21_0_chamfers
#define chamfers_z mcccurved_guide_21_0_chamfers_z
#define chamfers_lr mcccurved_guide_21_0_chamfers_lr
#define chamfers_tb mcccurved_guide_21_0_chamfers_tb
#define nelements mcccurved_guide_21_0_nelements
#define nu mcccurved_guide_21_0_nu
#define phase mcccurved_guide_21_0_phase
#define reflect mcccurved_guide_21_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 32153 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_22_0. */
  SIG_MESSAGE("curved_guide_22_0 (Init)");
#define mccompcurname  curved_guide_22_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 30
#define GVars mcccurved_guide_22_0_GVars
#define pTable mcccurved_guide_22_0_pTable
#define w1 mcccurved_guide_22_0_w1
#define h1 mcccurved_guide_22_0_h1
#define w2 mcccurved_guide_22_0_w2
#define h2 mcccurved_guide_22_0_h2
#define l mcccurved_guide_22_0_l
#define R0 mcccurved_guide_22_0_R0
#define Qc mcccurved_guide_22_0_Qc
#define alpha mcccurved_guide_22_0_alpha
#define m mcccurved_guide_22_0_m
#define W mcccurved_guide_22_0_W
#define nslit mcccurved_guide_22_0_nslit
#define d mcccurved_guide_22_0_d
#define mleft mcccurved_guide_22_0_mleft
#define mright mcccurved_guide_22_0_mright
#define mtop mcccurved_guide_22_0_mtop
#define mbottom mcccurved_guide_22_0_mbottom
#define nhslit mcccurved_guide_22_0_nhslit
#define G mcccurved_guide_22_0_G
#define aleft mcccurved_guide_22_0_aleft
#define aright mcccurved_guide_22_0_aright
#define atop mcccurved_guide_22_0_atop
#define abottom mcccurved_guide_22_0_abottom
#define wavy mcccurved_guide_22_0_wavy
#define wavy_z mcccurved_guide_22_0_wavy_z
#define wavy_tb mcccurved_guide_22_0_wavy_tb
#define wavy_lr mcccurved_guide_22_0_wavy_lr
#define chamfers mcccurved_guide_22_0_chamfers
#define chamfers_z mcccurved_guide_22_0_chamfers_z
#define chamfers_lr mcccurved_guide_22_0_chamfers_lr
#define chamfers_tb mcccurved_guide_22_0_chamfers_tb
#define nelements mcccurved_guide_22_0_nelements
#define nu mcccurved_guide_22_0_nu
#define phase mcccurved_guide_22_0_phase
#define reflect mcccurved_guide_22_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 32287 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_23_0. */
  SIG_MESSAGE("curved_guide_23_0 (Init)");
#define mccompcurname  curved_guide_23_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 31
#define GVars mcccurved_guide_23_0_GVars
#define pTable mcccurved_guide_23_0_pTable
#define w1 mcccurved_guide_23_0_w1
#define h1 mcccurved_guide_23_0_h1
#define w2 mcccurved_guide_23_0_w2
#define h2 mcccurved_guide_23_0_h2
#define l mcccurved_guide_23_0_l
#define R0 mcccurved_guide_23_0_R0
#define Qc mcccurved_guide_23_0_Qc
#define alpha mcccurved_guide_23_0_alpha
#define m mcccurved_guide_23_0_m
#define W mcccurved_guide_23_0_W
#define nslit mcccurved_guide_23_0_nslit
#define d mcccurved_guide_23_0_d
#define mleft mcccurved_guide_23_0_mleft
#define mright mcccurved_guide_23_0_mright
#define mtop mcccurved_guide_23_0_mtop
#define mbottom mcccurved_guide_23_0_mbottom
#define nhslit mcccurved_guide_23_0_nhslit
#define G mcccurved_guide_23_0_G
#define aleft mcccurved_guide_23_0_aleft
#define aright mcccurved_guide_23_0_aright
#define atop mcccurved_guide_23_0_atop
#define abottom mcccurved_guide_23_0_abottom
#define wavy mcccurved_guide_23_0_wavy
#define wavy_z mcccurved_guide_23_0_wavy_z
#define wavy_tb mcccurved_guide_23_0_wavy_tb
#define wavy_lr mcccurved_guide_23_0_wavy_lr
#define chamfers mcccurved_guide_23_0_chamfers
#define chamfers_z mcccurved_guide_23_0_chamfers_z
#define chamfers_lr mcccurved_guide_23_0_chamfers_lr
#define chamfers_tb mcccurved_guide_23_0_chamfers_tb
#define nelements mcccurved_guide_23_0_nelements
#define nu mcccurved_guide_23_0_nu
#define phase mcccurved_guide_23_0_phase
#define reflect mcccurved_guide_23_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 32421 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_24_0. */
  SIG_MESSAGE("curved_guide_24_0 (Init)");
#define mccompcurname  curved_guide_24_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 32
#define GVars mcccurved_guide_24_0_GVars
#define pTable mcccurved_guide_24_0_pTable
#define w1 mcccurved_guide_24_0_w1
#define h1 mcccurved_guide_24_0_h1
#define w2 mcccurved_guide_24_0_w2
#define h2 mcccurved_guide_24_0_h2
#define l mcccurved_guide_24_0_l
#define R0 mcccurved_guide_24_0_R0
#define Qc mcccurved_guide_24_0_Qc
#define alpha mcccurved_guide_24_0_alpha
#define m mcccurved_guide_24_0_m
#define W mcccurved_guide_24_0_W
#define nslit mcccurved_guide_24_0_nslit
#define d mcccurved_guide_24_0_d
#define mleft mcccurved_guide_24_0_mleft
#define mright mcccurved_guide_24_0_mright
#define mtop mcccurved_guide_24_0_mtop
#define mbottom mcccurved_guide_24_0_mbottom
#define nhslit mcccurved_guide_24_0_nhslit
#define G mcccurved_guide_24_0_G
#define aleft mcccurved_guide_24_0_aleft
#define aright mcccurved_guide_24_0_aright
#define atop mcccurved_guide_24_0_atop
#define abottom mcccurved_guide_24_0_abottom
#define wavy mcccurved_guide_24_0_wavy
#define wavy_z mcccurved_guide_24_0_wavy_z
#define wavy_tb mcccurved_guide_24_0_wavy_tb
#define wavy_lr mcccurved_guide_24_0_wavy_lr
#define chamfers mcccurved_guide_24_0_chamfers
#define chamfers_z mcccurved_guide_24_0_chamfers_z
#define chamfers_lr mcccurved_guide_24_0_chamfers_lr
#define chamfers_tb mcccurved_guide_24_0_chamfers_tb
#define nelements mcccurved_guide_24_0_nelements
#define nu mcccurved_guide_24_0_nu
#define phase mcccurved_guide_24_0_phase
#define reflect mcccurved_guide_24_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 32555 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_25_0. */
  SIG_MESSAGE("curved_guide_25_0 (Init)");
#define mccompcurname  curved_guide_25_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 33
#define GVars mcccurved_guide_25_0_GVars
#define pTable mcccurved_guide_25_0_pTable
#define w1 mcccurved_guide_25_0_w1
#define h1 mcccurved_guide_25_0_h1
#define w2 mcccurved_guide_25_0_w2
#define h2 mcccurved_guide_25_0_h2
#define l mcccurved_guide_25_0_l
#define R0 mcccurved_guide_25_0_R0
#define Qc mcccurved_guide_25_0_Qc
#define alpha mcccurved_guide_25_0_alpha
#define m mcccurved_guide_25_0_m
#define W mcccurved_guide_25_0_W
#define nslit mcccurved_guide_25_0_nslit
#define d mcccurved_guide_25_0_d
#define mleft mcccurved_guide_25_0_mleft
#define mright mcccurved_guide_25_0_mright
#define mtop mcccurved_guide_25_0_mtop
#define mbottom mcccurved_guide_25_0_mbottom
#define nhslit mcccurved_guide_25_0_nhslit
#define G mcccurved_guide_25_0_G
#define aleft mcccurved_guide_25_0_aleft
#define aright mcccurved_guide_25_0_aright
#define atop mcccurved_guide_25_0_atop
#define abottom mcccurved_guide_25_0_abottom
#define wavy mcccurved_guide_25_0_wavy
#define wavy_z mcccurved_guide_25_0_wavy_z
#define wavy_tb mcccurved_guide_25_0_wavy_tb
#define wavy_lr mcccurved_guide_25_0_wavy_lr
#define chamfers mcccurved_guide_25_0_chamfers
#define chamfers_z mcccurved_guide_25_0_chamfers_z
#define chamfers_lr mcccurved_guide_25_0_chamfers_lr
#define chamfers_tb mcccurved_guide_25_0_chamfers_tb
#define nelements mcccurved_guide_25_0_nelements
#define nu mcccurved_guide_25_0_nu
#define phase mcccurved_guide_25_0_phase
#define reflect mcccurved_guide_25_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 32689 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_26_0. */
  SIG_MESSAGE("curved_guide_26_0 (Init)");
#define mccompcurname  curved_guide_26_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 34
#define GVars mcccurved_guide_26_0_GVars
#define pTable mcccurved_guide_26_0_pTable
#define w1 mcccurved_guide_26_0_w1
#define h1 mcccurved_guide_26_0_h1
#define w2 mcccurved_guide_26_0_w2
#define h2 mcccurved_guide_26_0_h2
#define l mcccurved_guide_26_0_l
#define R0 mcccurved_guide_26_0_R0
#define Qc mcccurved_guide_26_0_Qc
#define alpha mcccurved_guide_26_0_alpha
#define m mcccurved_guide_26_0_m
#define W mcccurved_guide_26_0_W
#define nslit mcccurved_guide_26_0_nslit
#define d mcccurved_guide_26_0_d
#define mleft mcccurved_guide_26_0_mleft
#define mright mcccurved_guide_26_0_mright
#define mtop mcccurved_guide_26_0_mtop
#define mbottom mcccurved_guide_26_0_mbottom
#define nhslit mcccurved_guide_26_0_nhslit
#define G mcccurved_guide_26_0_G
#define aleft mcccurved_guide_26_0_aleft
#define aright mcccurved_guide_26_0_aright
#define atop mcccurved_guide_26_0_atop
#define abottom mcccurved_guide_26_0_abottom
#define wavy mcccurved_guide_26_0_wavy
#define wavy_z mcccurved_guide_26_0_wavy_z
#define wavy_tb mcccurved_guide_26_0_wavy_tb
#define wavy_lr mcccurved_guide_26_0_wavy_lr
#define chamfers mcccurved_guide_26_0_chamfers
#define chamfers_z mcccurved_guide_26_0_chamfers_z
#define chamfers_lr mcccurved_guide_26_0_chamfers_lr
#define chamfers_tb mcccurved_guide_26_0_chamfers_tb
#define nelements mcccurved_guide_26_0_nelements
#define nu mcccurved_guide_26_0_nu
#define phase mcccurved_guide_26_0_phase
#define reflect mcccurved_guide_26_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 32823 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_27_0. */
  SIG_MESSAGE("curved_guide_27_0 (Init)");
#define mccompcurname  curved_guide_27_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 35
#define GVars mcccurved_guide_27_0_GVars
#define pTable mcccurved_guide_27_0_pTable
#define w1 mcccurved_guide_27_0_w1
#define h1 mcccurved_guide_27_0_h1
#define w2 mcccurved_guide_27_0_w2
#define h2 mcccurved_guide_27_0_h2
#define l mcccurved_guide_27_0_l
#define R0 mcccurved_guide_27_0_R0
#define Qc mcccurved_guide_27_0_Qc
#define alpha mcccurved_guide_27_0_alpha
#define m mcccurved_guide_27_0_m
#define W mcccurved_guide_27_0_W
#define nslit mcccurved_guide_27_0_nslit
#define d mcccurved_guide_27_0_d
#define mleft mcccurved_guide_27_0_mleft
#define mright mcccurved_guide_27_0_mright
#define mtop mcccurved_guide_27_0_mtop
#define mbottom mcccurved_guide_27_0_mbottom
#define nhslit mcccurved_guide_27_0_nhslit
#define G mcccurved_guide_27_0_G
#define aleft mcccurved_guide_27_0_aleft
#define aright mcccurved_guide_27_0_aright
#define atop mcccurved_guide_27_0_atop
#define abottom mcccurved_guide_27_0_abottom
#define wavy mcccurved_guide_27_0_wavy
#define wavy_z mcccurved_guide_27_0_wavy_z
#define wavy_tb mcccurved_guide_27_0_wavy_tb
#define wavy_lr mcccurved_guide_27_0_wavy_lr
#define chamfers mcccurved_guide_27_0_chamfers
#define chamfers_z mcccurved_guide_27_0_chamfers_z
#define chamfers_lr mcccurved_guide_27_0_chamfers_lr
#define chamfers_tb mcccurved_guide_27_0_chamfers_tb
#define nelements mcccurved_guide_27_0_nelements
#define nu mcccurved_guide_27_0_nu
#define phase mcccurved_guide_27_0_phase
#define reflect mcccurved_guide_27_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 32957 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_28_0. */
  SIG_MESSAGE("curved_guide_28_0 (Init)");
#define mccompcurname  curved_guide_28_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 36
#define GVars mcccurved_guide_28_0_GVars
#define pTable mcccurved_guide_28_0_pTable
#define w1 mcccurved_guide_28_0_w1
#define h1 mcccurved_guide_28_0_h1
#define w2 mcccurved_guide_28_0_w2
#define h2 mcccurved_guide_28_0_h2
#define l mcccurved_guide_28_0_l
#define R0 mcccurved_guide_28_0_R0
#define Qc mcccurved_guide_28_0_Qc
#define alpha mcccurved_guide_28_0_alpha
#define m mcccurved_guide_28_0_m
#define W mcccurved_guide_28_0_W
#define nslit mcccurved_guide_28_0_nslit
#define d mcccurved_guide_28_0_d
#define mleft mcccurved_guide_28_0_mleft
#define mright mcccurved_guide_28_0_mright
#define mtop mcccurved_guide_28_0_mtop
#define mbottom mcccurved_guide_28_0_mbottom
#define nhslit mcccurved_guide_28_0_nhslit
#define G mcccurved_guide_28_0_G
#define aleft mcccurved_guide_28_0_aleft
#define aright mcccurved_guide_28_0_aright
#define atop mcccurved_guide_28_0_atop
#define abottom mcccurved_guide_28_0_abottom
#define wavy mcccurved_guide_28_0_wavy
#define wavy_z mcccurved_guide_28_0_wavy_z
#define wavy_tb mcccurved_guide_28_0_wavy_tb
#define wavy_lr mcccurved_guide_28_0_wavy_lr
#define chamfers mcccurved_guide_28_0_chamfers
#define chamfers_z mcccurved_guide_28_0_chamfers_z
#define chamfers_lr mcccurved_guide_28_0_chamfers_lr
#define chamfers_tb mcccurved_guide_28_0_chamfers_tb
#define nelements mcccurved_guide_28_0_nelements
#define nu mcccurved_guide_28_0_nu
#define phase mcccurved_guide_28_0_phase
#define reflect mcccurved_guide_28_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33091 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_29_0. */
  SIG_MESSAGE("curved_guide_29_0 (Init)");
#define mccompcurname  curved_guide_29_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 37
#define GVars mcccurved_guide_29_0_GVars
#define pTable mcccurved_guide_29_0_pTable
#define w1 mcccurved_guide_29_0_w1
#define h1 mcccurved_guide_29_0_h1
#define w2 mcccurved_guide_29_0_w2
#define h2 mcccurved_guide_29_0_h2
#define l mcccurved_guide_29_0_l
#define R0 mcccurved_guide_29_0_R0
#define Qc mcccurved_guide_29_0_Qc
#define alpha mcccurved_guide_29_0_alpha
#define m mcccurved_guide_29_0_m
#define W mcccurved_guide_29_0_W
#define nslit mcccurved_guide_29_0_nslit
#define d mcccurved_guide_29_0_d
#define mleft mcccurved_guide_29_0_mleft
#define mright mcccurved_guide_29_0_mright
#define mtop mcccurved_guide_29_0_mtop
#define mbottom mcccurved_guide_29_0_mbottom
#define nhslit mcccurved_guide_29_0_nhslit
#define G mcccurved_guide_29_0_G
#define aleft mcccurved_guide_29_0_aleft
#define aright mcccurved_guide_29_0_aright
#define atop mcccurved_guide_29_0_atop
#define abottom mcccurved_guide_29_0_abottom
#define wavy mcccurved_guide_29_0_wavy
#define wavy_z mcccurved_guide_29_0_wavy_z
#define wavy_tb mcccurved_guide_29_0_wavy_tb
#define wavy_lr mcccurved_guide_29_0_wavy_lr
#define chamfers mcccurved_guide_29_0_chamfers
#define chamfers_z mcccurved_guide_29_0_chamfers_z
#define chamfers_lr mcccurved_guide_29_0_chamfers_lr
#define chamfers_tb mcccurved_guide_29_0_chamfers_tb
#define nelements mcccurved_guide_29_0_nelements
#define nu mcccurved_guide_29_0_nu
#define phase mcccurved_guide_29_0_phase
#define reflect mcccurved_guide_29_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33225 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_30_0. */
  SIG_MESSAGE("curved_guide_30_0 (Init)");
#define mccompcurname  curved_guide_30_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 38
#define GVars mcccurved_guide_30_0_GVars
#define pTable mcccurved_guide_30_0_pTable
#define w1 mcccurved_guide_30_0_w1
#define h1 mcccurved_guide_30_0_h1
#define w2 mcccurved_guide_30_0_w2
#define h2 mcccurved_guide_30_0_h2
#define l mcccurved_guide_30_0_l
#define R0 mcccurved_guide_30_0_R0
#define Qc mcccurved_guide_30_0_Qc
#define alpha mcccurved_guide_30_0_alpha
#define m mcccurved_guide_30_0_m
#define W mcccurved_guide_30_0_W
#define nslit mcccurved_guide_30_0_nslit
#define d mcccurved_guide_30_0_d
#define mleft mcccurved_guide_30_0_mleft
#define mright mcccurved_guide_30_0_mright
#define mtop mcccurved_guide_30_0_mtop
#define mbottom mcccurved_guide_30_0_mbottom
#define nhslit mcccurved_guide_30_0_nhslit
#define G mcccurved_guide_30_0_G
#define aleft mcccurved_guide_30_0_aleft
#define aright mcccurved_guide_30_0_aright
#define atop mcccurved_guide_30_0_atop
#define abottom mcccurved_guide_30_0_abottom
#define wavy mcccurved_guide_30_0_wavy
#define wavy_z mcccurved_guide_30_0_wavy_z
#define wavy_tb mcccurved_guide_30_0_wavy_tb
#define wavy_lr mcccurved_guide_30_0_wavy_lr
#define chamfers mcccurved_guide_30_0_chamfers
#define chamfers_z mcccurved_guide_30_0_chamfers_z
#define chamfers_lr mcccurved_guide_30_0_chamfers_lr
#define chamfers_tb mcccurved_guide_30_0_chamfers_tb
#define nelements mcccurved_guide_30_0_nelements
#define nu mcccurved_guide_30_0_nu
#define phase mcccurved_guide_30_0_phase
#define reflect mcccurved_guide_30_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33359 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_31_0. */
  SIG_MESSAGE("curved_guide_31_0 (Init)");
#define mccompcurname  curved_guide_31_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 39
#define GVars mcccurved_guide_31_0_GVars
#define pTable mcccurved_guide_31_0_pTable
#define w1 mcccurved_guide_31_0_w1
#define h1 mcccurved_guide_31_0_h1
#define w2 mcccurved_guide_31_0_w2
#define h2 mcccurved_guide_31_0_h2
#define l mcccurved_guide_31_0_l
#define R0 mcccurved_guide_31_0_R0
#define Qc mcccurved_guide_31_0_Qc
#define alpha mcccurved_guide_31_0_alpha
#define m mcccurved_guide_31_0_m
#define W mcccurved_guide_31_0_W
#define nslit mcccurved_guide_31_0_nslit
#define d mcccurved_guide_31_0_d
#define mleft mcccurved_guide_31_0_mleft
#define mright mcccurved_guide_31_0_mright
#define mtop mcccurved_guide_31_0_mtop
#define mbottom mcccurved_guide_31_0_mbottom
#define nhslit mcccurved_guide_31_0_nhslit
#define G mcccurved_guide_31_0_G
#define aleft mcccurved_guide_31_0_aleft
#define aright mcccurved_guide_31_0_aright
#define atop mcccurved_guide_31_0_atop
#define abottom mcccurved_guide_31_0_abottom
#define wavy mcccurved_guide_31_0_wavy
#define wavy_z mcccurved_guide_31_0_wavy_z
#define wavy_tb mcccurved_guide_31_0_wavy_tb
#define wavy_lr mcccurved_guide_31_0_wavy_lr
#define chamfers mcccurved_guide_31_0_chamfers
#define chamfers_z mcccurved_guide_31_0_chamfers_z
#define chamfers_lr mcccurved_guide_31_0_chamfers_lr
#define chamfers_tb mcccurved_guide_31_0_chamfers_tb
#define nelements mcccurved_guide_31_0_nelements
#define nu mcccurved_guide_31_0_nu
#define phase mcccurved_guide_31_0_phase
#define reflect mcccurved_guide_31_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33493 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_32_0. */
  SIG_MESSAGE("curved_guide_32_0 (Init)");
#define mccompcurname  curved_guide_32_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 40
#define GVars mcccurved_guide_32_0_GVars
#define pTable mcccurved_guide_32_0_pTable
#define w1 mcccurved_guide_32_0_w1
#define h1 mcccurved_guide_32_0_h1
#define w2 mcccurved_guide_32_0_w2
#define h2 mcccurved_guide_32_0_h2
#define l mcccurved_guide_32_0_l
#define R0 mcccurved_guide_32_0_R0
#define Qc mcccurved_guide_32_0_Qc
#define alpha mcccurved_guide_32_0_alpha
#define m mcccurved_guide_32_0_m
#define W mcccurved_guide_32_0_W
#define nslit mcccurved_guide_32_0_nslit
#define d mcccurved_guide_32_0_d
#define mleft mcccurved_guide_32_0_mleft
#define mright mcccurved_guide_32_0_mright
#define mtop mcccurved_guide_32_0_mtop
#define mbottom mcccurved_guide_32_0_mbottom
#define nhslit mcccurved_guide_32_0_nhslit
#define G mcccurved_guide_32_0_G
#define aleft mcccurved_guide_32_0_aleft
#define aright mcccurved_guide_32_0_aright
#define atop mcccurved_guide_32_0_atop
#define abottom mcccurved_guide_32_0_abottom
#define wavy mcccurved_guide_32_0_wavy
#define wavy_z mcccurved_guide_32_0_wavy_z
#define wavy_tb mcccurved_guide_32_0_wavy_tb
#define wavy_lr mcccurved_guide_32_0_wavy_lr
#define chamfers mcccurved_guide_32_0_chamfers
#define chamfers_z mcccurved_guide_32_0_chamfers_z
#define chamfers_lr mcccurved_guide_32_0_chamfers_lr
#define chamfers_tb mcccurved_guide_32_0_chamfers_tb
#define nelements mcccurved_guide_32_0_nelements
#define nu mcccurved_guide_32_0_nu
#define phase mcccurved_guide_32_0_phase
#define reflect mcccurved_guide_32_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33627 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_33_0. */
  SIG_MESSAGE("curved_guide_33_0 (Init)");
#define mccompcurname  curved_guide_33_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 41
#define GVars mcccurved_guide_33_0_GVars
#define pTable mcccurved_guide_33_0_pTable
#define w1 mcccurved_guide_33_0_w1
#define h1 mcccurved_guide_33_0_h1
#define w2 mcccurved_guide_33_0_w2
#define h2 mcccurved_guide_33_0_h2
#define l mcccurved_guide_33_0_l
#define R0 mcccurved_guide_33_0_R0
#define Qc mcccurved_guide_33_0_Qc
#define alpha mcccurved_guide_33_0_alpha
#define m mcccurved_guide_33_0_m
#define W mcccurved_guide_33_0_W
#define nslit mcccurved_guide_33_0_nslit
#define d mcccurved_guide_33_0_d
#define mleft mcccurved_guide_33_0_mleft
#define mright mcccurved_guide_33_0_mright
#define mtop mcccurved_guide_33_0_mtop
#define mbottom mcccurved_guide_33_0_mbottom
#define nhslit mcccurved_guide_33_0_nhslit
#define G mcccurved_guide_33_0_G
#define aleft mcccurved_guide_33_0_aleft
#define aright mcccurved_guide_33_0_aright
#define atop mcccurved_guide_33_0_atop
#define abottom mcccurved_guide_33_0_abottom
#define wavy mcccurved_guide_33_0_wavy
#define wavy_z mcccurved_guide_33_0_wavy_z
#define wavy_tb mcccurved_guide_33_0_wavy_tb
#define wavy_lr mcccurved_guide_33_0_wavy_lr
#define chamfers mcccurved_guide_33_0_chamfers
#define chamfers_z mcccurved_guide_33_0_chamfers_z
#define chamfers_lr mcccurved_guide_33_0_chamfers_lr
#define chamfers_tb mcccurved_guide_33_0_chamfers_tb
#define nelements mcccurved_guide_33_0_nelements
#define nu mcccurved_guide_33_0_nu
#define phase mcccurved_guide_33_0_phase
#define reflect mcccurved_guide_33_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33761 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_34_0. */
  SIG_MESSAGE("curved_guide_34_0 (Init)");
#define mccompcurname  curved_guide_34_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 42
#define GVars mcccurved_guide_34_0_GVars
#define pTable mcccurved_guide_34_0_pTable
#define w1 mcccurved_guide_34_0_w1
#define h1 mcccurved_guide_34_0_h1
#define w2 mcccurved_guide_34_0_w2
#define h2 mcccurved_guide_34_0_h2
#define l mcccurved_guide_34_0_l
#define R0 mcccurved_guide_34_0_R0
#define Qc mcccurved_guide_34_0_Qc
#define alpha mcccurved_guide_34_0_alpha
#define m mcccurved_guide_34_0_m
#define W mcccurved_guide_34_0_W
#define nslit mcccurved_guide_34_0_nslit
#define d mcccurved_guide_34_0_d
#define mleft mcccurved_guide_34_0_mleft
#define mright mcccurved_guide_34_0_mright
#define mtop mcccurved_guide_34_0_mtop
#define mbottom mcccurved_guide_34_0_mbottom
#define nhslit mcccurved_guide_34_0_nhslit
#define G mcccurved_guide_34_0_G
#define aleft mcccurved_guide_34_0_aleft
#define aright mcccurved_guide_34_0_aright
#define atop mcccurved_guide_34_0_atop
#define abottom mcccurved_guide_34_0_abottom
#define wavy mcccurved_guide_34_0_wavy
#define wavy_z mcccurved_guide_34_0_wavy_z
#define wavy_tb mcccurved_guide_34_0_wavy_tb
#define wavy_lr mcccurved_guide_34_0_wavy_lr
#define chamfers mcccurved_guide_34_0_chamfers
#define chamfers_z mcccurved_guide_34_0_chamfers_z
#define chamfers_lr mcccurved_guide_34_0_chamfers_lr
#define chamfers_tb mcccurved_guide_34_0_chamfers_tb
#define nelements mcccurved_guide_34_0_nelements
#define nu mcccurved_guide_34_0_nu
#define phase mcccurved_guide_34_0_phase
#define reflect mcccurved_guide_34_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33895 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_35_0. */
  SIG_MESSAGE("curved_guide_35_0 (Init)");
#define mccompcurname  curved_guide_35_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 43
#define GVars mcccurved_guide_35_0_GVars
#define pTable mcccurved_guide_35_0_pTable
#define w1 mcccurved_guide_35_0_w1
#define h1 mcccurved_guide_35_0_h1
#define w2 mcccurved_guide_35_0_w2
#define h2 mcccurved_guide_35_0_h2
#define l mcccurved_guide_35_0_l
#define R0 mcccurved_guide_35_0_R0
#define Qc mcccurved_guide_35_0_Qc
#define alpha mcccurved_guide_35_0_alpha
#define m mcccurved_guide_35_0_m
#define W mcccurved_guide_35_0_W
#define nslit mcccurved_guide_35_0_nslit
#define d mcccurved_guide_35_0_d
#define mleft mcccurved_guide_35_0_mleft
#define mright mcccurved_guide_35_0_mright
#define mtop mcccurved_guide_35_0_mtop
#define mbottom mcccurved_guide_35_0_mbottom
#define nhslit mcccurved_guide_35_0_nhslit
#define G mcccurved_guide_35_0_G
#define aleft mcccurved_guide_35_0_aleft
#define aright mcccurved_guide_35_0_aright
#define atop mcccurved_guide_35_0_atop
#define abottom mcccurved_guide_35_0_abottom
#define wavy mcccurved_guide_35_0_wavy
#define wavy_z mcccurved_guide_35_0_wavy_z
#define wavy_tb mcccurved_guide_35_0_wavy_tb
#define wavy_lr mcccurved_guide_35_0_wavy_lr
#define chamfers mcccurved_guide_35_0_chamfers
#define chamfers_z mcccurved_guide_35_0_chamfers_z
#define chamfers_lr mcccurved_guide_35_0_chamfers_lr
#define chamfers_tb mcccurved_guide_35_0_chamfers_tb
#define nelements mcccurved_guide_35_0_nelements
#define nu mcccurved_guide_35_0_nu
#define phase mcccurved_guide_35_0_phase
#define reflect mcccurved_guide_35_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34029 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component curved_guide_36_0. */
  SIG_MESSAGE("curved_guide_36_0 (Init)");
#define mccompcurname  curved_guide_36_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 44
#define GVars mcccurved_guide_36_0_GVars
#define pTable mcccurved_guide_36_0_pTable
#define w1 mcccurved_guide_36_0_w1
#define h1 mcccurved_guide_36_0_h1
#define w2 mcccurved_guide_36_0_w2
#define h2 mcccurved_guide_36_0_h2
#define l mcccurved_guide_36_0_l
#define R0 mcccurved_guide_36_0_R0
#define Qc mcccurved_guide_36_0_Qc
#define alpha mcccurved_guide_36_0_alpha
#define m mcccurved_guide_36_0_m
#define W mcccurved_guide_36_0_W
#define nslit mcccurved_guide_36_0_nslit
#define d mcccurved_guide_36_0_d
#define mleft mcccurved_guide_36_0_mleft
#define mright mcccurved_guide_36_0_mright
#define mtop mcccurved_guide_36_0_mtop
#define mbottom mcccurved_guide_36_0_mbottom
#define nhslit mcccurved_guide_36_0_nhslit
#define G mcccurved_guide_36_0_G
#define aleft mcccurved_guide_36_0_aleft
#define aright mcccurved_guide_36_0_aright
#define atop mcccurved_guide_36_0_atop
#define abottom mcccurved_guide_36_0_abottom
#define wavy mcccurved_guide_36_0_wavy
#define wavy_z mcccurved_guide_36_0_wavy_z
#define wavy_tb mcccurved_guide_36_0_wavy_tb
#define wavy_lr mcccurved_guide_36_0_wavy_lr
#define chamfers mcccurved_guide_36_0_chamfers
#define chamfers_z mcccurved_guide_36_0_chamfers_z
#define chamfers_lr mcccurved_guide_36_0_chamfers_lr
#define chamfers_tb mcccurved_guide_36_0_chamfers_tb
#define nelements mcccurved_guide_36_0_nelements
#define nu mcccurved_guide_36_0_nu
#define phase mcccurved_guide_36_0_phase
#define reflect mcccurved_guide_36_0_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34163 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component EndOfelement_4. */
  SIG_MESSAGE("EndOfelement_4 (Init)");

  /* Initializations for component log_P_start. */
  SIG_MESSAGE("log_P_start (Init)");
#define mccompcurname  log_P_start
#define mccompcurtype  Shielding_logger
#define mccompcurindex 46
#line 154 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_logger.comp"
{
  bounce_store_index=0;
  absorbed_in_optics=0;
  Bounce_store=malloc(sizeof(*Bounce_store)*BOUNCE_LOG_SIZE);
  Bounce_store[BOUNCE_LOG_SIZE-1]._p=-1;
}
#line 34219 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component elliptical_guide_gravity3. */
  SIG_MESSAGE("elliptical_guide_gravity3 (Init)");
#define mccompcurname  elliptical_guide_gravity3
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 47
#define mvaluesright mccelliptical_guide_gravity3_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity3_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity3_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity3_mvaluesbottom
#define seglength mccelliptical_guide_gravity3_seglength
#define guideInfo mccelliptical_guide_gravity3_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity3_latestParticleCollision
#define Gx mccelliptical_guide_gravity3_Gx
#define Gy mccelliptical_guide_gravity3_Gy
#define Gz mccelliptical_guide_gravity3_Gz
#define Gx0 mccelliptical_guide_gravity3_Gx0
#define Gy0 mccelliptical_guide_gravity3_Gy0
#define Gz0 mccelliptical_guide_gravity3_Gz0
#define Circ mccelliptical_guide_gravity3_Circ
#define dynamicalSegLength mccelliptical_guide_gravity3_dynamicalSegLength
#define l mccelliptical_guide_gravity3_l
#define xwidth mccelliptical_guide_gravity3_xwidth
#define yheight mccelliptical_guide_gravity3_yheight
#define linxw mccelliptical_guide_gravity3_linxw
#define loutxw mccelliptical_guide_gravity3_loutxw
#define linyh mccelliptical_guide_gravity3_linyh
#define loutyh mccelliptical_guide_gravity3_loutyh
#define majorAxisxw mccelliptical_guide_gravity3_majorAxisxw
#define minorAxisxw mccelliptical_guide_gravity3_minorAxisxw
#define majorAxisyh mccelliptical_guide_gravity3_majorAxisyh
#define minorAxisyh mccelliptical_guide_gravity3_minorAxisyh
#define majorAxisoffsetxw mccelliptical_guide_gravity3_majorAxisoffsetxw
#define majorAxisoffsetyh mccelliptical_guide_gravity3_majorAxisoffsetyh
#define dimensionsAt mccelliptical_guide_gravity3_dimensionsAt
#define option mccelliptical_guide_gravity3_option
#define R0 mccelliptical_guide_gravity3_R0
#define Qc mccelliptical_guide_gravity3_Qc
#define alpha mccelliptical_guide_gravity3_alpha
#define m mccelliptical_guide_gravity3_m
#define W mccelliptical_guide_gravity3_W
#define alpharight mccelliptical_guide_gravity3_alpharight
#define mright mccelliptical_guide_gravity3_mright
#define alphaleft mccelliptical_guide_gravity3_alphaleft
#define mleft mccelliptical_guide_gravity3_mleft
#define alphatop mccelliptical_guide_gravity3_alphatop
#define mtop mccelliptical_guide_gravity3_mtop
#define alphabottom mccelliptical_guide_gravity3_alphabottom
#define mbottom mccelliptical_guide_gravity3_mbottom
#define verbose mccelliptical_guide_gravity3_verbose
#define enableGravity mccelliptical_guide_gravity3_enableGravity
#define curvature mccelliptical_guide_gravity3_curvature
#line 829 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
{
	///////////////////////////////////////////////////////////////////////////
	/////////////// Test user input
	///////////////////////////////////////////////////////////////////////////

	if(strcmp(verbose,"on") == 0)
		guideInfo.verboseSetting = 1;
	else guideInfo.verboseSetting = 0;
	

	guideInfo.R0Arr[RightSide] 		= R0;
	guideInfo.QcArr[RightSide] 		= Qc;
	guideInfo.alphaArr[RightSide] 	= alpharight;
	guideInfo.mArr[RightSide] 		= mright;
	guideInfo.WArr[RightSide] 		= W; 

	guideInfo.R0Arr[TopSide] 	 = R0; 
	guideInfo.QcArr[TopSide] 	 = Qc; 
	guideInfo.alphaArr[TopSide]  = alphatop; 
	guideInfo.mArr[TopSide] 	 = mtop;
	guideInfo.WArr[TopSide] 	 = W; 

	guideInfo.R0Arr[LeftSide] 		= R0; 
	guideInfo.QcArr[LeftSide] 		= Qc; 
	guideInfo.alphaArr[LeftSide] 	= alphaleft; 
	guideInfo.mArr[LeftSide] 		= mleft; 
	guideInfo.WArr[LeftSide] 		= W; 

	guideInfo.R0Arr[BottomSide] 	= R0; 
	guideInfo.QcArr[BottomSide] 	= Qc; 
	guideInfo.alphaArr[BottomSide] 	= alphabottom; 
	guideInfo.mArr[BottomSide] 		= mbottom; 
	guideInfo.WArr[BottomSide] 		= W; 

	int sides;
	for (sides = RightSide; sides <= BottomSide; sides++){
		if (guideInfo.alphaArr[sides] == -1) guideInfo.alphaArr[sides] = alpha;
		if (guideInfo.mArr[sides] == -1)	 guideInfo.mArr[sides] = m;
	}
	
	// Test user input for illegal values
	int inputErrors = 0;
	// Lower or equal to zero
	if(l <= 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("length",guideInfo.verboseSetting);
	if(guideInfo.alphaArr[TopSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphatop",guideInfo.verboseSetting);
	if(guideInfo.mArr[TopSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mtop",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[BottomSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphabottom",guideInfo.verboseSetting);
	if(guideInfo.mArr[BottomSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mbottom",guideInfo.verboseSetting);

	if(guideInfo.alphaArr[RightSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alpharight",guideInfo.verboseSetting);
	if(guideInfo.mArr[RightSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mright",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[LeftSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphaleft",guideInfo.verboseSetting);
	if(guideInfo.mArr[LeftSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mleft",guideInfo.verboseSetting);

	// Focal points result in hyperbola instead of an ellipse
	if(l <= -linxw-loutxw) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linw","loutw",linxw,loutxw,guideInfo.verboseSetting);
	if(l <= -linyh-loutyh) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linh","louth",linyh,loutyh,guideInfo.verboseSetting);

	if( strcmp(dimensionsAt,"entrance") != 0 
	 && strcmp(dimensionsAt,"mid") != 0 
	 && strcmp(dimensionsAt,"exit") != 0){
	 	inputErrors += 1;
		printf("dimensionsAt were given an incorrect input."
			   "Input must be string containing \"entrance\",\"mid\" or \"exit\" \n");
	}


	// Terminate program if any input errors occurred
	if(inputErrors != 0 ){
		exit(printf("\nCRITICAL ERROR(S) IN COMPONENT %s" 
				" CONSIDER CHECKING USER INPUT AS %d INPUT ERRORS WAS FOUND.\n",
				NAME_CURRENT_COMP,inputErrors) );
	}


	///////////////////////////////////////////////////////////////////////////
	/////////////// Calculate intern guide values from user input
	///////////////////////////////////////////////////////////////////////////

	/*  Calculate the foci line for the ellipses.
		These can be used to calculate the axes of the ellipses
		using pyth and defination of the ellipse that says distance 
		between the foci and every point on the ellipse is constant.
	*/
	int directDefination = 0;

	if( majorAxisyh != 0 || minorAxisyh != 0 
	 || majorAxisxw != 0 || minorAxisxw != 0)
	{
		directDefination = 1;
		guideInfo.Length = l;	
		
		guideInfo.ellipseMajorAxis[RightSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[RightSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[RightSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[TopSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[TopSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[TopSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[LeftSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[LeftSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[LeftSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[BottomSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[BottomSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[BottomSide] = 0;

		guideInfo.entranceHorizontalWidth =
			2*sqrt(1 - (majorAxisoffsetyh*majorAxisoffsetyh)
			/(majorAxisyh*majorAxisyh) )*minorAxisyh;
		guideInfo.entranceVerticalWidth = 	
			2*sqrt(1 - (majorAxisoffsetxw*majorAxisoffsetxw)
			/(majorAxisxw*majorAxisxw) )*minorAxisxw;
	}

	if ( strcmp(option,"ellipse") == 0 && directDefination == 0)
	{
		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( linxw*linxw + xwidth*xwidth*0.25)
				+ sqrt( (l + loutxw)*(l + loutxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( linyh*linyh + yheight*yheight*0.25)
				+ sqrt( (l + loutyh)*(l + loutyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"exit") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( loutxw*loutxw + xwidth*xwidth*0.25)
				+ sqrt( (l + linxw)*(l + linxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( loutyh*loutyh + yheight*yheight*0.25)
				+ sqrt( (l + linyh)*(l + linyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] =(l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"mid") == 0 ){ 

			guideInfo.Length = l;
			
			guideInfo.ellipseMajorAxis[RightSide] = 
				sqrt( (linxw+l+loutxw)*(linxw+l+loutxw)/4+xwidth*xwidth/4);
			guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = 
				sqrt( (linyh+l+loutyh)*(linyh+l+loutyh)/4+yheight*yheight/4);
			guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];

		}
	}

	guideInfo.entranceHorizontalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[RightSide]
			*guideInfo.ellipseMajorOffset[RightSide]
			/(guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] ) )
		*guideInfo.ellipseMinorAxis[RightSide];
	guideInfo.entranceVerticalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[TopSide]
			*guideInfo.ellipseMajorOffset[TopSide]
			/(guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] ) )
		*guideInfo.ellipseMinorAxis[TopSide];


	if ( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		exit( printf("Critical error in %s; the option for option = halfellipse is currently disabled.",NAME_CURRENT_COMP) );

		double used_focal_vertical;
		double used_focal_horizontal;
		double major_offset_horizontal = 0;
		double major_offset_vertical = 0;

		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+linyh)*(l+linyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+linxw)*(l+linxw) ); 
			major_offset_vertical = l;	
			major_offset_horizontal = l;
		}
		else {	
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+loutyh)*(l+loutyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+loutxw)*(l+loutxw) ); 
		}

		guideInfo.Length = l;

		guideInfo.ellipseMajorAxis[RightSide] = used_focal_horizontal;
		guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

		guideInfo.ellipseMajorOffset[RightSide] = major_offset_horizontal;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = 
								guideInfo.ellipseMajorAxis[RightSide];
		guideInfo.ellipseMinorAxis[LeftSide] = 
								guideInfo.ellipseMinorAxis[RightSide];
		guideInfo.ellipseMajorOffset[LeftSide] = 
								guideInfo.ellipseMajorOffset[RightSide];
		guideInfo.ellipseMinorOffset[LeftSide] = 
								guideInfo.ellipseMinorOffset[RightSide];

		guideInfo.ellipseMajorAxis[TopSide] = used_focal_vertical;
		guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

		guideInfo.ellipseMajorOffset[TopSide] = major_offset_vertical;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = 
								guideInfo.ellipseMajorAxis[TopSide];
		guideInfo.ellipseMinorAxis[BottomSide] = 
								guideInfo.ellipseMinorAxis[TopSide];
		guideInfo.ellipseMajorOffset[BottomSide] = 
								guideInfo.ellipseMajorOffset[TopSide];
		guideInfo.ellipseMinorOffset[BottomSide] = 
								guideInfo.ellipseMinorOffset[TopSide];
	}

	// Applies the properties of the mirrors in the guide given by the user.
	// These variables are used in the reflection functions.

	
	// Sets the mirror type of the guides mirrors
	// These variables are used in the collision functions 
	// to find the type of collision

	// guideInfo.OuterSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[BottomSide] = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_bottom_side_mirror,guideInfo.verboseSetting);

	// guideInfo.InnerSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[BottomSide] =	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_bottom_side_mirror,guideInfo.verboseSetting);

	// Give a warning if all side of the guide is turned off, 
	// as the guide is essentially turned off
	if(    guideInfo.OuterSide[RightSide] 	== 1 
		&& guideInfo.OuterSide[TopSide] 	== 1
		&& guideInfo.OuterSide[LeftSide] 	== 1 
		&& guideInfo.OuterSide[BottomSide]	== 1
		&& guideInfo.InnerSide[RightSide] 	== 1 
		&& guideInfo.InnerSide[TopSide] 	== 1
		&& guideInfo.InnerSide[LeftSide] 	== 1 
		&& guideInfo.InnerSide[BottomSide]  == 1)
		printf("Warning: In %s all the sides of the guide has been disabled,"
				" so it not possible for any particle"
				" to collide with the guide, consider"
				" disabling this component",NAME_CURRENT_COMP);
	
	if(guideInfo.mArr[RightSide] <= 0)  guideInfo.InnerSide[RightSide] = 
														MirrorTypeabsorption;
	if(guideInfo.mArr[TopSide] <= 0) 	 guideInfo.InnerSide[TopSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[LeftSide] <= 0) 	 guideInfo.InnerSide[LeftSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[BottomSide] <= 0) guideInfo.InnerSide[BottomSide] = 
														MirrorTypeabsorption;
	/* if(directDefination == 0){ */
	/* 	guideInfo.entranceHorizontalWidth = xwidth; */
	/* 	guideInfo.entranceVerticalWidth = yheight; */
	/* } */
	
	if( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		guideInfo.entranceHorizontalWidth =
			(guideInfo.ellipseMinorAxis[RightSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[RightSide]
						*guideInfo.ellipseMajorOffset[RightSide] )
			/( guideInfo.ellipseMajorAxis[RightSide]
			  *guideInfo.ellipseMajorAxis[RightSide] ) )
			+ guideInfo.ellipseMinorOffset[RightSide] )*2;
		guideInfo.entranceVerticalWidth = 
			(guideInfo.ellipseMinorAxis[TopSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[TopSide]
						*guideInfo.ellipseMajorOffset[TopSide] )
			/( guideInfo.ellipseMajorAxis[TopSide]
			  *guideInfo.ellipseMajorAxis[TopSide] ) )
			+ guideInfo.ellipseMinorOffset[TopSide] )*2;
	}


	guideInfo.EnclosingBoxOn = 0;

	/*
	double DefaultArray1[8] = { 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0, 1.0};
	double DefaultArray2[8] = { 1.0, 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0};
	double DefaultArray3[8] = {-1.0,-1.0,-1.0,-1.0, 1.0, 1.0, 1.0, 1.0}; 

	guideInfo.EnclosingBoxOn = 0;
	double *xinput;
	if ( xInput != NULL ){ xinput = xInput; guideInfo.EnclosingBoxOn = 1; }
	else { xinput = DefaultArray1; }
	double *yinput;
	if ( yInput != NULL ){ yinput = yInput; guideInfo.EnclosingBoxOn = 1;}
	else { yinput = DefaultArray2; }
	double *zinput;
	if ( zInput != NULL ){ zinput = zInput; guideInfo.EnclosingBoxOn = 1;}
	else { zinput = DefaultArray3; }
	*/

	/*
	double xarray[8] ={ guideInfo.ellipseMinorAxis[0]*xinput[0],
						guideInfo.ellipseMinorAxis[2]*xinput[1],
						guideInfo.ellipseMinorAxis[2]*xinput[2],
						guideInfo.ellipseMinorAxis[0]*xinput[3],
						guideInfo.ellipseMinorAxis[0]*xinput[4],
						guideInfo.ellipseMinorAxis[2]*xinput[5],
						guideInfo.ellipseMinorAxis[2]*xinput[6],
						guideInfo.ellipseMinorAxis[0]*xinput[7] };
	double yarray[8] ={ guideInfo.ellipseMinorAxis[1]*yinput[0],
						guideInfo.ellipseMinorAxis[1]*yinput[1],
						guideInfo.ellipseMinorAxis[3]*yinput[2],
						guideInfo.ellipseMinorAxis[3]*yinput[3],
						guideInfo.ellipseMinorAxis[1]*yinput[4],
						guideInfo.ellipseMinorAxis[1]*yinput[5],
						guideInfo.ellipseMinorAxis[3]*yinput[6],
						guideInfo.ellipseMinorAxis[3]*yinput[7] };
	double zarray[8] ={ guideInfo.Length/2*zinput[0]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[1]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[2]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[3]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[4]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[5]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[6]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[7]+guideInfo.Length/2 };
	int i = 0;
	for(i = 0; i < 8; i++){
		guideInfo.xArray[i] = xarray[i];
		guideInfo.yArray[i] = yarray[i];
		guideInfo.zArray[i] = zarray[i];
	}
	*/

	guideInfo.exitVerticalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide]) 
					)/(guideInfo.ellipseMajorAxis[BottomSide] 
					*guideInfo.ellipseMajorAxis[BottomSide] )
		)*guideInfo.ellipseMinorAxis[BottomSide];

	guideInfo.exitHorizontalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide]) 
					)/(guideInfo.ellipseMajorAxis[RightSide] 
					*guideInfo.ellipseMajorAxis[RightSide] ) 
		)*guideInfo.ellipseMinorAxis[RightSide];

    //////////////////segmentation of m values

	// Are the arrays empty?
	if(mvaluesright != NULL || mvaluesleft != NULL 
	|| mvaluestop != NULL || mvaluesbottom != NULL)
	{
		guideInfo.enableSegments = 1;

		guideInfo.numberOfSegments = sizeof(mvaluesright)/sizeof(mvaluesright[0]);

		//printf("Length is %i\n",guideInfo.numberOfSegments);
		guideInfo.mValuesright = mvaluesright;
		guideInfo.mValuesleft = mvaluesleft;
		guideInfo.mValuestop = mvaluestop;
		guideInfo.mValuesbottom = mvaluesbottom;
		//printf("Seglength ... %f %f %f\n",seglength[0],seglength[1],seglength[2]);

		// Are the arrays of equal length?
		if(seglength == NULL){
			dynamicalSegLength = 
					realloc(dynamicalSegLength,
							guideInfo.numberOfSegments*sizeof(double) );
			int i;
			for (i = 0; i < guideInfo.numberOfSegments; ++i){
				dynamicalSegLength[i] = 
						guideInfo.Length/guideInfo.numberOfSegments;
				}
			guideInfo.segLength = dynamicalSegLength;
		}
		else guideInfo.segLength = seglength;

		if( guideInfo.numberOfSegments != sizeof(mvaluesright)/sizeof(mvaluesright[0]) 
		 || guideInfo.numberOfSegments != sizeof(mvaluesleft)/sizeof(mvaluesleft[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluestop)/sizeof(mvaluestop[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0])
		 || (guideInfo.segLength == NULL
		  & guideInfo.numberOfSegments != sizeof(seglength)/sizeof(guideInfo.segLength[0]) 
		  ) ) {
			
			printf("Error in userinput inside %s, the length of the arrays"
				   " mvalues and seglength are not equal\n",NAME_CURRENT_COMP);
			printf("The length of the arrays are: mValuesright is %lu,"
				   " mvaluesleft is %lu, mvaluestop is %lu, mvaluesbottom is"
				   " %lu and seglength is %lu and should be %d \n; Above assume that the arrays are using double \n",
					sizeof(mvaluesright)/sizeof(double),
					sizeof(mvaluesleft)/sizeof(double),
					sizeof(mvaluestop)/sizeof(double),
					sizeof(mvaluesbottom)/sizeof(double),
					sizeof(guideInfo.segLength)/sizeof(double),
					guideInfo.numberOfSegments	
					);
				
			if ( guideInfo.verboseSetting )	{
				int i;
				
				printf("The Values of mvaluesright is: [");
				for(i=0; i < sizeof(mvaluesright)/sizeof(mvaluesright[0]); i++) 	
						printf("%e,",guideInfo.mValuesright[i] );
				printf("]\n");
				
				printf("The Values of mvaluesleft is: [");
				for(i=0; i < sizeof(mvaluesleft)/sizeof(mvaluesleft[0]); i++) 	
						printf("%e,",guideInfo.mValuesleft[i] );
				printf("]\n");
				
				printf("The Values of mvaluestop is: [");
				for(i=0; i < sizeof(mvaluestop)/sizeof(mvaluestop[0]); i++) 	
						printf("%e,",guideInfo.mValuestop[i] );
				printf("]\n");

				printf("The Values of mvaluesbottom is: [");
				for(i=0; i < sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0]); i++) 
						printf("%e,",guideInfo.mValuesbottom[i] );
				printf("]\n");

				printf("The Values of seglength is: [");
				for(i=0; i < sizeof(guideInfo.segLength)/sizeof(guideInfo.segLength[0]); i++) 
						printf("%e,",guideInfo.segLength[i]);
				printf("]\n");
			}
			exit( printf("Exit due to critical error in userinput for the"
						" component %s, consider having a look at the input"
						" for following: mvaluesright,mvaluesleft,mvaluestop,"
						"mvaluesbottom and/or seglength.",NAME_CURRENT_COMP) );
		}
		//
		double sumOfelements=0;
		int i;
		for(i=0;i< guideInfo.numberOfSegments; i++) {
			sumOfelements += guideInfo.segLength[i];
		}
		if ( guideInfo.verboseSetting 
		&& fabs(sumOfelements-guideInfo.Length) > 1e-9 )
			printf("Error in userinput inside %s, the difference between"
					" guidelength and elements of the seglength array is:"
					"%e consider changes the parameters l or seglength \n",
					NAME_CURRENT_COMP,sumOfelements-guideInfo.Length);
	}
	else guideInfo.enableSegments = 0;


///////////////////////////////////////////////////////////////////////////
/////////////// Calculate gravity vector in the guides coordinatesystem
///////////////////////////////////////////////////////////////////////////

/*
	Sets the local gravity vector equal to the global gravity vector (0,-g,0) 
	and when apply the same rotation matrix as applied to guide. 
*/ 
	if (enableGravity != 0){
		Gx0=0, Gy0=-GRAVITY*enableGravity, Gz0=0;
		Coords mcLocG;
		mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,Gy0,0));
		coords_get(mcLocG, &Gx0, &Gy0, &Gz0);
	}
	Circ=2*PI*curvature;
}
#line 34867 "./ESS_BIFROST_shielding.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component EndOfelement_3. */
  SIG_MESSAGE("EndOfelement_3 (Init)");

  /* Initializations for component straight_guide_2_1. */
  SIG_MESSAGE("straight_guide_2_1 (Init)");
#define mccompcurname  straight_guide_2_1
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 49
#define GVars mccstraight_guide_2_1_GVars
#define pTable mccstraight_guide_2_1_pTable
#define w1 mccstraight_guide_2_1_w1
#define h1 mccstraight_guide_2_1_h1
#define w2 mccstraight_guide_2_1_w2
#define h2 mccstraight_guide_2_1_h2
#define l mccstraight_guide_2_1_l
#define R0 mccstraight_guide_2_1_R0
#define Qc mccstraight_guide_2_1_Qc
#define alpha mccstraight_guide_2_1_alpha
#define m mccstraight_guide_2_1_m
#define W mccstraight_guide_2_1_W
#define nslit mccstraight_guide_2_1_nslit
#define d mccstraight_guide_2_1_d
#define mleft mccstraight_guide_2_1_mleft
#define mright mccstraight_guide_2_1_mright
#define mtop mccstraight_guide_2_1_mtop
#define mbottom mccstraight_guide_2_1_mbottom
#define nhslit mccstraight_guide_2_1_nhslit
#define G mccstraight_guide_2_1_G
#define aleft mccstraight_guide_2_1_aleft
#define aright mccstraight_guide_2_1_aright
#define atop mccstraight_guide_2_1_atop
#define abottom mccstraight_guide_2_1_abottom
#define wavy mccstraight_guide_2_1_wavy
#define wavy_z mccstraight_guide_2_1_wavy_z
#define wavy_tb mccstraight_guide_2_1_wavy_tb
#define wavy_lr mccstraight_guide_2_1_wavy_lr
#define chamfers mccstraight_guide_2_1_chamfers
#define chamfers_z mccstraight_guide_2_1_chamfers_z
#define chamfers_lr mccstraight_guide_2_1_chamfers_lr
#define chamfers_tb mccstraight_guide_2_1_chamfers_tb
#define nelements mccstraight_guide_2_1_nelements
#define nu mccstraight_guide_2_1_nu
#define phase mccstraight_guide_2_1_phase
#define reflect mccstraight_guide_2_1_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 35014 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component straight_guide_2_2. */
  SIG_MESSAGE("straight_guide_2_2 (Init)");
#define mccompcurname  straight_guide_2_2
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 50
#define GVars mccstraight_guide_2_2_GVars
#define pTable mccstraight_guide_2_2_pTable
#define w1 mccstraight_guide_2_2_w1
#define h1 mccstraight_guide_2_2_h1
#define w2 mccstraight_guide_2_2_w2
#define h2 mccstraight_guide_2_2_h2
#define l mccstraight_guide_2_2_l
#define R0 mccstraight_guide_2_2_R0
#define Qc mccstraight_guide_2_2_Qc
#define alpha mccstraight_guide_2_2_alpha
#define m mccstraight_guide_2_2_m
#define W mccstraight_guide_2_2_W
#define nslit mccstraight_guide_2_2_nslit
#define d mccstraight_guide_2_2_d
#define mleft mccstraight_guide_2_2_mleft
#define mright mccstraight_guide_2_2_mright
#define mtop mccstraight_guide_2_2_mtop
#define mbottom mccstraight_guide_2_2_mbottom
#define nhslit mccstraight_guide_2_2_nhslit
#define G mccstraight_guide_2_2_G
#define aleft mccstraight_guide_2_2_aleft
#define aright mccstraight_guide_2_2_aright
#define atop mccstraight_guide_2_2_atop
#define abottom mccstraight_guide_2_2_abottom
#define wavy mccstraight_guide_2_2_wavy
#define wavy_z mccstraight_guide_2_2_wavy_z
#define wavy_tb mccstraight_guide_2_2_wavy_tb
#define wavy_lr mccstraight_guide_2_2_wavy_lr
#define chamfers mccstraight_guide_2_2_chamfers
#define chamfers_z mccstraight_guide_2_2_chamfers_z
#define chamfers_lr mccstraight_guide_2_2_chamfers_lr
#define chamfers_tb mccstraight_guide_2_2_chamfers_tb
#define nelements mccstraight_guide_2_2_nelements
#define nu mccstraight_guide_2_2_nu
#define phase mccstraight_guide_2_2_phase
#define reflect mccstraight_guide_2_2_reflect
#line 359 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }
    
  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 35148 "./ESS_BIFROST_shielding.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component EndOfelement_2. */
  SIG_MESSAGE("EndOfelement_2 (Init)");

  /* Initializations for component elliptical_guide_gravity1_1. */
  SIG_MESSAGE("elliptical_guide_gravity1_1 (Init)");
#define mccompcurname  elliptical_guide_gravity1_1
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 52
#define mvaluesright mccelliptical_guide_gravity1_1_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_1_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_1_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_1_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_1_seglength
#define guideInfo mccelliptical_guide_gravity1_1_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_1_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_1_Gx
#define Gy mccelliptical_guide_gravity1_1_Gy
#define Gz mccelliptical_guide_gravity1_1_Gz
#define Gx0 mccelliptical_guide_gravity1_1_Gx0
#define Gy0 mccelliptical_guide_gravity1_1_Gy0
#define Gz0 mccelliptical_guide_gravity1_1_Gz0
#define Circ mccelliptical_guide_gravity1_1_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_1_dynamicalSegLength
#define l mccelliptical_guide_gravity1_1_l
#define xwidth mccelliptical_guide_gravity1_1_xwidth
#define yheight mccelliptical_guide_gravity1_1_yheight
#define linxw mccelliptical_guide_gravity1_1_linxw
#define loutxw mccelliptical_guide_gravity1_1_loutxw
#define linyh mccelliptical_guide_gravity1_1_linyh
#define loutyh mccelliptical_guide_gravity1_1_loutyh
#define majorAxisxw mccelliptical_guide_gravity1_1_majorAxisxw
#define minorAxisxw mccelliptical_guide_gravity1_1_minorAxisxw
#define majorAxisyh mccelliptical_guide_gravity1_1_majorAxisyh
#define minorAxisyh mccelliptical_guide_gravity1_1_minorAxisyh
#define majorAxisoffsetxw mccelliptical_guide_gravity1_1_majorAxisoffsetxw
#define majorAxisoffsetyh mccelliptical_guide_gravity1_1_majorAxisoffsetyh
#define dimensionsAt mccelliptical_guide_gravity1_1_dimensionsAt
#define option mccelliptical_guide_gravity1_1_option
#define R0 mccelliptical_guide_gravity1_1_R0
#define Qc mccelliptical_guide_gravity1_1_Qc
#define alpha mccelliptical_guide_gravity1_1_alpha
#define m mccelliptical_guide_gravity1_1_m
#define W mccelliptical_guide_gravity1_1_W
#define alpharight mccelliptical_guide_gravity1_1_alpharight
#define mright mccelliptical_guide_gravity1_1_mright
#define alphaleft mccelliptical_guide_gravity1_1_alphaleft
#define mleft mccelliptical_guide_gravity1_1_mleft
#define alphatop mccelliptical_guide_gravity1_1_alphatop
#define mtop mccelliptical_guide_gravity1_1_mtop
#define alphabottom mccelliptical_guide_gravity1_1_alphabottom
#define mbottom mccelliptical_guide_gravity1_1_mbottom
#define verbose mccelliptical_guide_gravity1_1_verbose
#define enableGravity mccelliptical_guide_gravity1_1_enableGravity
#define curvature mccelliptical_guide_gravity1_1_curvature
#line 829 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
{
	///////////////////////////////////////////////////////////////////////////
	/////////////// Test user input
	///////////////////////////////////////////////////////////////////////////

	if(strcmp(verbose,"on") == 0)
		guideInfo.verboseSetting = 1;
	else guideInfo.verboseSetting = 0;
	

	guideInfo.R0Arr[RightSide] 		= R0;
	guideInfo.QcArr[RightSide] 		= Qc;
	guideInfo.alphaArr[RightSide] 	= alpharight;
	guideInfo.mArr[RightSide] 		= mright;
	guideInfo.WArr[RightSide] 		= W; 

	guideInfo.R0Arr[TopSide] 	 = R0; 
	guideInfo.QcArr[TopSide] 	 = Qc; 
	guideInfo.alphaArr[TopSide]  = alphatop; 
	guideInfo.mArr[TopSide] 	 = mtop;
	guideInfo.WArr[TopSide] 	 = W; 

	guideInfo.R0Arr[LeftSide] 		= R0; 
	guideInfo.QcArr[LeftSide] 		= Qc; 
	guideInfo.alphaArr[LeftSide] 	= alphaleft; 
	guideInfo.mArr[LeftSide] 		= mleft; 
	guideInfo.WArr[LeftSide] 		= W; 

	guideInfo.R0Arr[BottomSide] 	= R0; 
	guideInfo.QcArr[BottomSide] 	= Qc; 
	guideInfo.alphaArr[BottomSide] 	= alphabottom; 
	guideInfo.mArr[BottomSide] 		= mbottom; 
	guideInfo.WArr[BottomSide] 		= W; 

	int sides;
	for (sides = RightSide; sides <= BottomSide; sides++){
		if (guideInfo.alphaArr[sides] == -1) guideInfo.alphaArr[sides] = alpha;
		if (guideInfo.mArr[sides] == -1)	 guideInfo.mArr[sides] = m;
	}
	
	// Test user input for illegal values
	int inputErrors = 0;
	// Lower or equal to zero
	if(l <= 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("length",guideInfo.verboseSetting);
	if(guideInfo.alphaArr[TopSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphatop",guideInfo.verboseSetting);
	if(guideInfo.mArr[TopSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mtop",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[BottomSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphabottom",guideInfo.verboseSetting);
	if(guideInfo.mArr[BottomSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mbottom",guideInfo.verboseSetting);

	if(guideInfo.alphaArr[RightSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alpharight",guideInfo.verboseSetting);
	if(guideInfo.mArr[RightSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mright",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[LeftSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphaleft",guideInfo.verboseSetting);
	if(guideInfo.mArr[LeftSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mleft",guideInfo.verboseSetting);

	// Focal points result in hyperbola instead of an ellipse
	if(l <= -linxw-loutxw) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linw","loutw",linxw,loutxw,guideInfo.verboseSetting);
	if(l <= -linyh-loutyh) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linh","louth",linyh,loutyh,guideInfo.verboseSetting);

	if( strcmp(dimensionsAt,"entrance") != 0 
	 && strcmp(dimensionsAt,"mid") != 0 
	 && strcmp(dimensionsAt,"exit") != 0){
	 	inputErrors += 1;
		printf("dimensionsAt were given an incorrect input."
			   "Input must be string containing \"entrance\",\"mid\" or \"exit\" \n");
	}


	// Terminate program if any input errors occurred
	if(inputErrors != 0 ){
		exit(printf("\nCRITICAL ERROR(S) IN COMPONENT %s" 
				" CONSIDER CHECKING USER INPUT AS %d INPUT ERRORS WAS FOUND.\n",
				NAME_CURRENT_COMP,inputErrors) );
	}


	///////////////////////////////////////////////////////////////////////////
	/////////////// Calculate intern guide values from user input
	///////////////////////////////////////////////////////////////////////////

	/*  Calculate the foci line for the ellipses.
		These can be used to calculate the axes of the ellipses
		using pyth and defination of the ellipse that says distance 
		between the foci and every point on the ellipse is constant.
	*/
	int directDefination = 0;

	if( majorAxisyh != 0 || minorAxisyh != 0 
	 || majorAxisxw != 0 || minorAxisxw != 0)
	{
		directDefination = 1;
		guideInfo.Length = l;	
		
		guideInfo.ellipseMajorAxis[RightSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[RightSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[RightSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[TopSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[TopSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[TopSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[LeftSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[LeftSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[LeftSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[BottomSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[BottomSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[BottomSide] = 0;

		guideInfo.entranceHorizontalWidth =
			2*sqrt(1 - (majorAxisoffsetyh*majorAxisoffsetyh)
			/(majorAxisyh*majorAxisyh) )*minorAxisyh;
		guideInfo.entranceVerticalWidth = 	
			2*sqrt(1 - (majorAxisoffsetxw*majorAxisoffsetxw)
			/(majorAxisxw*majorAxisxw) )*minorAxisxw;
	}

	if ( strcmp(option,"ellipse") == 0 && directDefination == 0)
	{
		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( linxw*linxw + xwidth*xwidth*0.25)
				+ sqrt( (l + loutxw)*(l + loutxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( linyh*linyh + yheight*yheight*0.25)
				+ sqrt( (l + loutyh)*(l + loutyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"exit") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( loutxw*loutxw + xwidth*xwidth*0.25)
				+ sqrt( (l + linxw)*(l + linxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( loutyh*loutyh + yheight*yheight*0.25)
				+ sqrt( (l + linyh)*(l + linyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] =(l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"mid") == 0 ){ 

			guideInfo.Length = l;
			
			guideInfo.ellipseMajorAxis[RightSide] = 
				sqrt( (linxw+l+loutxw)*(linxw+l+loutxw)/4+xwidth*xwidth/4);
			guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = 
				sqrt( (linyh+l+loutyh)*(linyh+l+loutyh)/4+yheight*yheight/4);
			guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];

		}
	}

	guideInfo.entranceHorizontalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[RightSide]
			*guideInfo.ellipseMajorOffset[RightSide]
			/(guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] ) )
		*guideInfo.ellipseMinorAxis[RightSide];
	guideInfo.entranceVerticalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[TopSide]
			*guideInfo.ellipseMajorOffset[TopSide]
			/(guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] ) )
		*guideInfo.ellipseMinorAxis[TopSide];


	if ( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		exit( printf("Critical error in %s; the option for option = halfellipse is currently disabled.",NAME_CURRENT_COMP) );

		double used_focal_vertical;
		double used_focal_horizontal;
		double major_offset_horizontal = 0;
		double major_offset_vertical = 0;

		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+linyh)*(l+linyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+linxw)*(l+linxw) ); 
			major_offset_vertical = l;	
			major_offset_horizontal = l;
		}
		else {	
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+loutyh)*(l+loutyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+loutxw)*(l+loutxw) ); 
		}

		guideInfo.Length = l;

		guideInfo.ellipseMajorAxis[RightSide] = used_focal_horizontal;
		guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

		guideInfo.ellipseMajorOffset[RightSide] = major_offset_horizontal;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = 
								guideInfo.ellipseMajorAxis[RightSide];
		guideInfo.ellipseMinorAxis[LeftSide] = 
								guideInfo.ellipseMinorAxis[RightSide];
		guideInfo.ellipseMajorOffset[LeftSide] = 
								guideInfo.ellipseMajorOffset[RightSide];
		guideInfo.ellipseMinorOffset[LeftSide] = 
								guideInfo.ellipseMinorOffset[RightSide];

		guideInfo.ellipseMajorAxis[TopSide] = used_focal_vertical;
		guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

		guideInfo.ellipseMajorOffset[TopSide] = major_offset_vertical;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = 
								guideInfo.ellipseMajorAxis[TopSide];
		guideInfo.ellipseMinorAxis[BottomSide] = 
								guideInfo.ellipseMinorAxis[TopSide];
		guideInfo.ellipseMajorOffset[BottomSide] = 
								guideInfo.ellipseMajorOffset[TopSide];
		guideInfo.ellipseMinorOffset[BottomSide] = 
								guideInfo.ellipseMinorOffset[TopSide];
	}

	// Applies the properties of the mirrors in the guide given by the user.
	// These variables are used in the reflection functions.

	
	// Sets the mirror type of the guides mirrors
	// These variables are used in the collision functions 
	// to find the type of collision

	// guideInfo.OuterSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[BottomSide] = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_bottom_side_mirror,guideInfo.verboseSetting);

	// guideInfo.InnerSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[BottomSide] =	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_bottom_side_mirror,guideInfo.verboseSetting);

	// Give a warning if all side of the guide is turned off, 
	// as the guide is essentially turned off
	if(    guideInfo.OuterSide[RightSide] 	== 1 
		&& guideInfo.OuterSide[TopSide] 	== 1
		&& guideInfo.OuterSide[LeftSide] 	== 1 
		&& guideInfo.OuterSide[BottomSide]	== 1
		&& guideInfo.InnerSide[RightSide] 	== 1 
		&& guideInfo.InnerSide[TopSide] 	== 1
		&& guideInfo.InnerSide[LeftSide] 	== 1 
		&& guideInfo.InnerSide[BottomSide]  == 1)
		printf("Warning: In %s all the sides of the guide has been disabled,"
				" so it not possible for any particle"
				" to collide with the guide, consider"
				" disabling this component",NAME_CURRENT_COMP);
	
	if(guideInfo.mArr[RightSide] <= 0)  guideInfo.InnerSide[RightSide] = 
														MirrorTypeabsorption;
	if(guideInfo.mArr[TopSide] <= 0) 	 guideInfo.InnerSide[TopSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[LeftSide] <= 0) 	 guideInfo.InnerSide[LeftSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[BottomSide] <= 0) guideInfo.InnerSide[BottomSide] = 
														MirrorTypeabsorption;
	/* if(directDefination == 0){ */
	/* 	guideInfo.entranceHorizontalWidth = xwidth; */
	/* 	guideInfo.entranceVerticalWidth = yheight; */
	/* } */
	
	if( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		guideInfo.entranceHorizontalWidth =
			(guideInfo.ellipseMinorAxis[RightSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[RightSide]
						*guideInfo.ellipseMajorOffset[RightSide] )
			/( guideInfo.ellipseMajorAxis[RightSide]
			  *guideInfo.ellipseMajorAxis[RightSide] ) )
			+ guideInfo.ellipseMinorOffset[RightSide] )*2;
		guideInfo.entranceVerticalWidth = 
			(guideInfo.ellipseMinorAxis[TopSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[TopSide]
						*guideInfo.ellipseMajorOffset[TopSide] )
			/( guideInfo.ellipseMajorAxis[TopSide]
			  *guideInfo.ellipseMajorAxis[TopSide] ) )
			+ guideInfo.ellipseMinorOffset[TopSide] )*2;
	}


	guideInfo.EnclosingBoxOn = 0;

	/*
	double DefaultArray1[8] = { 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0, 1.0};
	double DefaultArray2[8] = { 1.0, 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0};
	double DefaultArray3[8] = {-1.0,-1.0,-1.0,-1.0, 1.0, 1.0, 1.0, 1.0}; 

	guideInfo.EnclosingBoxOn = 0;
	double *xinput;
	if ( xInput != NULL ){ xinput = xInput; guideInfo.EnclosingBoxOn = 1; }
	else { xinput = DefaultArray1; }
	double *yinput;
	if ( yInput != NULL ){ yinput = yInput; guideInfo.EnclosingBoxOn = 1;}
	else { yinput = DefaultArray2; }
	double *zinput;
	if ( zInput != NULL ){ zinput = zInput; guideInfo.EnclosingBoxOn = 1;}
	else { zinput = DefaultArray3; }
	*/

	/*
	double xarray[8] ={ guideInfo.ellipseMinorAxis[0]*xinput[0],
						guideInfo.ellipseMinorAxis[2]*xinput[1],
						guideInfo.ellipseMinorAxis[2]*xinput[2],
						guideInfo.ellipseMinorAxis[0]*xinput[3],
						guideInfo.ellipseMinorAxis[0]*xinput[4],
						guideInfo.ellipseMinorAxis[2]*xinput[5],
						guideInfo.ellipseMinorAxis[2]*xinput[6],
						guideInfo.ellipseMinorAxis[0]*xinput[7] };
	double yarray[8] ={ guideInfo.ellipseMinorAxis[1]*yinput[0],
						guideInfo.ellipseMinorAxis[1]*yinput[1],
						guideInfo.ellipseMinorAxis[3]*yinput[2],
						guideInfo.ellipseMinorAxis[3]*yinput[3],
						guideInfo.ellipseMinorAxis[1]*yinput[4],
						guideInfo.ellipseMinorAxis[1]*yinput[5],
						guideInfo.ellipseMinorAxis[3]*yinput[6],
						guideInfo.ellipseMinorAxis[3]*yinput[7] };
	double zarray[8] ={ guideInfo.Length/2*zinput[0]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[1]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[2]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[3]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[4]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[5]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[6]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[7]+guideInfo.Length/2 };
	int i = 0;
	for(i = 0; i < 8; i++){
		guideInfo.xArray[i] = xarray[i];
		guideInfo.yArray[i] = yarray[i];
		guideInfo.zArray[i] = zarray[i];
	}
	*/

	guideInfo.exitVerticalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide]) 
					)/(guideInfo.ellipseMajorAxis[BottomSide] 
					*guideInfo.ellipseMajorAxis[BottomSide] )
		)*guideInfo.ellipseMinorAxis[BottomSide];

	guideInfo.exitHorizontalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide]) 
					)/(guideInfo.ellipseMajorAxis[RightSide] 
					*guideInfo.ellipseMajorAxis[RightSide] ) 
		)*guideInfo.ellipseMinorAxis[RightSide];

    //////////////////segmentation of m values

	// Are the arrays empty?
	if(mvaluesright != NULL || mvaluesleft != NULL 
	|| mvaluestop != NULL || mvaluesbottom != NULL)
	{
		guideInfo.enableSegments = 1;

		guideInfo.numberOfSegments = sizeof(mvaluesright)/sizeof(mvaluesright[0]);

		//printf("Length is %i\n",guideInfo.numberOfSegments);
		guideInfo.mValuesright = mvaluesright;
		guideInfo.mValuesleft = mvaluesleft;
		guideInfo.mValuestop = mvaluestop;
		guideInfo.mValuesbottom = mvaluesbottom;
		//printf("Seglength ... %f %f %f\n",seglength[0],seglength[1],seglength[2]);

		// Are the arrays of equal length?
		if(seglength == NULL){
			dynamicalSegLength = 
					realloc(dynamicalSegLength,
							guideInfo.numberOfSegments*sizeof(double) );
			int i;
			for (i = 0; i < guideInfo.numberOfSegments; ++i){
				dynamicalSegLength[i] = 
						guideInfo.Length/guideInfo.numberOfSegments;
				}
			guideInfo.segLength = dynamicalSegLength;
		}
		else guideInfo.segLength = seglength;

		if( guideInfo.numberOfSegments != sizeof(mvaluesright)/sizeof(mvaluesright[0]) 
		 || guideInfo.numberOfSegments != sizeof(mvaluesleft)/sizeof(mvaluesleft[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluestop)/sizeof(mvaluestop[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0])
		 || (guideInfo.segLength == NULL
		  & guideInfo.numberOfSegments != sizeof(seglength)/sizeof(guideInfo.segLength[0]) 
		  ) ) {
			
			printf("Error in userinput inside %s, the length of the arrays"
				   " mvalues and seglength are not equal\n",NAME_CURRENT_COMP);
			printf("The length of the arrays are: mValuesright is %lu,"
				   " mvaluesleft is %lu, mvaluestop is %lu, mvaluesbottom is"
				   " %lu and seglength is %lu and should be %d \n; Above assume that the arrays are using double \n",
					sizeof(mvaluesright)/sizeof(double),
					sizeof(mvaluesleft)/sizeof(double),
					sizeof(mvaluestop)/sizeof(double),
					sizeof(mvaluesbottom)/sizeof(double),
					sizeof(guideInfo.segLength)/sizeof(double),
					guideInfo.numberOfSegments	
					);
				
			if ( guideInfo.verboseSetting )	{
				int i;
				
				printf("The Values of mvaluesright is: [");
				for(i=0; i < sizeof(mvaluesright)/sizeof(mvaluesright[0]); i++) 	
						printf("%e,",guideInfo.mValuesright[i] );
				printf("]\n");
				
				printf("The Values of mvaluesleft is: [");
				for(i=0; i < sizeof(mvaluesleft)/sizeof(mvaluesleft[0]); i++) 	
						printf("%e,",guideInfo.mValuesleft[i] );
				printf("]\n");
				
				printf("The Values of mvaluestop is: [");
				for(i=0; i < sizeof(mvaluestop)/sizeof(mvaluestop[0]); i++) 	
						printf("%e,",guideInfo.mValuestop[i] );
				printf("]\n");

				printf("The Values of mvaluesbottom is: [");
				for(i=0; i < sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0]); i++) 
						printf("%e,",guideInfo.mValuesbottom[i] );
				printf("]\n");

				printf("The Values of seglength is: [");
				for(i=0; i < sizeof(guideInfo.segLength)/sizeof(guideInfo.segLength[0]); i++) 
						printf("%e,",guideInfo.segLength[i]);
				printf("]\n");
			}
			exit( printf("Exit due to critical error in userinput for the"
						" component %s, consider having a look at the input"
						" for following: mvaluesright,mvaluesleft,mvaluestop,"
						"mvaluesbottom and/or seglength.",NAME_CURRENT_COMP) );
		}
		//
		double sumOfelements=0;
		int i;
		for(i=0;i< guideInfo.numberOfSegments; i++) {
			sumOfelements += guideInfo.segLength[i];
		}
		if ( guideInfo.verboseSetting 
		&& fabs(sumOfelements-guideInfo.Length) > 1e-9 )
			printf("Error in userinput inside %s, the difference between"
					" guidelength and elements of the seglength array is:"
					"%e consider changes the parameters l or seglength \n",
					NAME_CURRENT_COMP,sumOfelements-guideInfo.Length);
	}
	else guideInfo.enableSegments = 0;


///////////////////////////////////////////////////////////////////////////
/////////////// Calculate gravity vector in the guides coordinatesystem
///////////////////////////////////////////////////////////////////////////

/*
	Sets the local gravity vector equal to the global gravity vector (0,-g,0) 
	and when apply the same rotation matrix as applied to guide. 
*/ 
	if (enableGravity != 0){
		Gx0=0, Gy0=-GRAVITY*enableGravity, Gz0=0;
		Coords mcLocG;
		mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,Gy0,0));
		coords_get(mcLocG, &Gx0, &Gy0, &Gz0);
	}
	Circ=2*PI*curvature;
}
#line 35835 "./ESS_BIFROST_shielding.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component DiwJaw3. */
  SIG_MESSAGE("DiwJaw3 (Init)");
#define mccompcurname  DiwJaw3
#define mccompcurtype  Slit
#define mccompcurindex 53
#define xmin mccDiwJaw3_xmin
#define xmax mccDiwJaw3_xmax
#define ymin mccDiwJaw3_ymin
#define ymax mccDiwJaw3_ymax
#define radius mccDiwJaw3_radius
#define xwidth mccDiwJaw3_xwidth
#define yheight mccDiwJaw3_yheight
#line 50 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Slit.comp"
{
if (xwidth > 0)  { 
  if (!xmin && !xmax) {
    xmax=xwidth/2;  xmin=-xmax;
  } else {
    fprintf(stderr,"Slit: %s: Error: please specify EITHER xmin & xmax or xwidth\n", NAME_CURRENT_COMP); exit(-1);
  }
 }
 if (yheight > 0) { 
   if (!ymin && !ymax) {
     ymax=yheight/2; ymin=-ymax; 
   } else {
     fprintf(stderr,"Slit: %s: Error: please specify EITHER ymin & ymax or ywidth\n", NAME_CURRENT_COMP); exit(-1);
   }
 }
 if (xmin == 0 && xmax == 0 && ymin == 0 && ymax == 0 && radius == 0)
    { fprintf(stderr,"Slit: %s: Warning: Running with CLOSED slit - is this intentional?? \n", NAME_CURRENT_COMP); }

}
#line 35918 "./ESS_BIFROST_shielding.c"
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component elliptical_guide_gravity1_2. */
  SIG_MESSAGE("elliptical_guide_gravity1_2 (Init)");
#define mccompcurname  elliptical_guide_gravity1_2
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 54
#define mvaluesright mccelliptical_guide_gravity1_2_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_2_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_2_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_2_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_2_seglength
#define guideInfo mccelliptical_guide_gravity1_2_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_2_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_2_Gx
#define Gy mccelliptical_guide_gravity1_2_Gy
#define Gz mccelliptical_guide_gravity1_2_Gz
#define Gx0 mccelliptical_guide_gravity1_2_Gx0
#define Gy0 mccelliptical_guide_gravity1_2_Gy0
#define Gz0 mccelliptical_guide_gravity1_2_Gz0
#define Circ mccelliptical_guide_gravity1_2_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_2_dynamicalSegLength
#define l mccelliptical_guide_gravity1_2_l
#define xwidth mccelliptical_guide_gravity1_2_xwidth
#define yheight mccelliptical_guide_gravity1_2_yheight
#define linxw mccelliptical_guide_gravity1_2_linxw
#define loutxw mccelliptical_guide_gravity1_2_loutxw
#define linyh mccelliptical_guide_gravity1_2_linyh
#define loutyh mccelliptical_guide_gravity1_2_loutyh
#define majorAxisxw mccelliptical_guide_gravity1_2_majorAxisxw
#define minorAxisxw mccelliptical_guide_gravity1_2_minorAxisxw
#define majorAxisyh mccelliptical_guide_gravity1_2_majorAxisyh
#define minorAxisyh mccelliptical_guide_gravity1_2_minorAxisyh
#define majorAxisoffsetxw mccelliptical_guide_gravity1_2_majorAxisoffsetxw
#define majorAxisoffsetyh mccelliptical_guide_gravity1_2_majorAxisoffsetyh
#define dimensionsAt mccelliptical_guide_gravity1_2_dimensionsAt
#define option mccelliptical_guide_gravity1_2_option
#define R0 mccelliptical_guide_gravity1_2_R0
#define Qc mccelliptical_guide_gravity1_2_Qc
#define alpha mccelliptical_guide_gravity1_2_alpha
#define m mccelliptical_guide_gravity1_2_m
#define W mccelliptical_guide_gravity1_2_W
#define alpharight mccelliptical_guide_gravity1_2_alpharight
#define mright mccelliptical_guide_gravity1_2_mright
#define alphaleft mccelliptical_guide_gravity1_2_alphaleft
#define mleft mccelliptical_guide_gravity1_2_mleft
#define alphatop mccelliptical_guide_gravity1_2_alphatop
#define mtop mccelliptical_guide_gravity1_2_mtop
#define alphabottom mccelliptical_guide_gravity1_2_alphabottom
#define mbottom mccelliptical_guide_gravity1_2_mbottom
#define verbose mccelliptical_guide_gravity1_2_verbose
#define enableGravity mccelliptical_guide_gravity1_2_enableGravity
#define curvature mccelliptical_guide_gravity1_2_curvature
#line 829 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
{
	///////////////////////////////////////////////////////////////////////////
	/////////////// Test user input
	///////////////////////////////////////////////////////////////////////////

	if(strcmp(verbose,"on") == 0)
		guideInfo.verboseSetting = 1;
	else guideInfo.verboseSetting = 0;
	

	guideInfo.R0Arr[RightSide] 		= R0;
	guideInfo.QcArr[RightSide] 		= Qc;
	guideInfo.alphaArr[RightSide] 	= alpharight;
	guideInfo.mArr[RightSide] 		= mright;
	guideInfo.WArr[RightSide] 		= W; 

	guideInfo.R0Arr[TopSide] 	 = R0; 
	guideInfo.QcArr[TopSide] 	 = Qc; 
	guideInfo.alphaArr[TopSide]  = alphatop; 
	guideInfo.mArr[TopSide] 	 = mtop;
	guideInfo.WArr[TopSide] 	 = W; 

	guideInfo.R0Arr[LeftSide] 		= R0; 
	guideInfo.QcArr[LeftSide] 		= Qc; 
	guideInfo.alphaArr[LeftSide] 	= alphaleft; 
	guideInfo.mArr[LeftSide] 		= mleft; 
	guideInfo.WArr[LeftSide] 		= W; 

	guideInfo.R0Arr[BottomSide] 	= R0; 
	guideInfo.QcArr[BottomSide] 	= Qc; 
	guideInfo.alphaArr[BottomSide] 	= alphabottom; 
	guideInfo.mArr[BottomSide] 		= mbottom; 
	guideInfo.WArr[BottomSide] 		= W; 

	int sides;
	for (sides = RightSide; sides <= BottomSide; sides++){
		if (guideInfo.alphaArr[sides] == -1) guideInfo.alphaArr[sides] = alpha;
		if (guideInfo.mArr[sides] == -1)	 guideInfo.mArr[sides] = m;
	}
	
	// Test user input for illegal values
	int inputErrors = 0;
	// Lower or equal to zero
	if(l <= 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("length",guideInfo.verboseSetting);
	if(guideInfo.alphaArr[TopSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphatop",guideInfo.verboseSetting);
	if(guideInfo.mArr[TopSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mtop",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[BottomSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphabottom",guideInfo.verboseSetting);
	if(guideInfo.mArr[BottomSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mbottom",guideInfo.verboseSetting);

	if(guideInfo.alphaArr[RightSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alpharight",guideInfo.verboseSetting);
	if(guideInfo.mArr[RightSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mright",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[LeftSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphaleft",guideInfo.verboseSetting);
	if(guideInfo.mArr[LeftSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mleft",guideInfo.verboseSetting);

	// Focal points result in hyperbola instead of an ellipse
	if(l <= -linxw-loutxw) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linw","loutw",linxw,loutxw,guideInfo.verboseSetting);
	if(l <= -linyh-loutyh) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linh","louth",linyh,loutyh,guideInfo.verboseSetting);

	if( strcmp(dimensionsAt,"entrance") != 0 
	 && strcmp(dimensionsAt,"mid") != 0 
	 && strcmp(dimensionsAt,"exit") != 0){
	 	inputErrors += 1;
		printf("dimensionsAt were given an incorrect input."
			   "Input must be string containing \"entrance\",\"mid\" or \"exit\" \n");
	}


	// Terminate program if any input errors occurred
	if(inputErrors != 0 ){
		exit(printf("\nCRITICAL ERROR(S) IN COMPONENT %s" 
				" CONSIDER CHECKING USER INPUT AS %d INPUT ERRORS WAS FOUND.\n",
				NAME_CURRENT_COMP,inputErrors) );
	}


	///////////////////////////////////////////////////////////////////////////
	/////////////// Calculate intern guide values from user input
	///////////////////////////////////////////////////////////////////////////

	/*  Calculate the foci line for the ellipses.
		These can be used to calculate the axes of the ellipses
		using pyth and defination of the ellipse that says distance 
		between the foci and every point on the ellipse is constant.
	*/
	int directDefination = 0;

	if( majorAxisyh != 0 || minorAxisyh != 0 
	 || majorAxisxw != 0 || minorAxisxw != 0)
	{
		directDefination = 1;
		guideInfo.Length = l;	
		
		guideInfo.ellipseMajorAxis[RightSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[RightSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[RightSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[TopSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[TopSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[TopSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[LeftSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[LeftSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[LeftSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[BottomSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[BottomSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[BottomSide] = 0;

		guideInfo.entranceHorizontalWidth =
			2*sqrt(1 - (majorAxisoffsetyh*majorAxisoffsetyh)
			/(majorAxisyh*majorAxisyh) )*minorAxisyh;
		guideInfo.entranceVerticalWidth = 	
			2*sqrt(1 - (majorAxisoffsetxw*majorAxisoffsetxw)
			/(majorAxisxw*majorAxisxw) )*minorAxisxw;
	}

	if ( strcmp(option,"ellipse") == 0 && directDefination == 0)
	{
		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( linxw*linxw + xwidth*xwidth*0.25)
				+ sqrt( (l + loutxw)*(l + loutxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( linyh*linyh + yheight*yheight*0.25)
				+ sqrt( (l + loutyh)*(l + loutyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"exit") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( loutxw*loutxw + xwidth*xwidth*0.25)
				+ sqrt( (l + linxw)*(l + linxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( loutyh*loutyh + yheight*yheight*0.25)
				+ sqrt( (l + linyh)*(l + linyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] =(l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"mid") == 0 ){ 

			guideInfo.Length = l;
			
			guideInfo.ellipseMajorAxis[RightSide] = 
				sqrt( (linxw+l+loutxw)*(linxw+l+loutxw)/4+xwidth*xwidth/4);
			guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = 
				sqrt( (linyh+l+loutyh)*(linyh+l+loutyh)/4+yheight*yheight/4);
			guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];

		}
	}

	guideInfo.entranceHorizontalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[RightSide]
			*guideInfo.ellipseMajorOffset[RightSide]
			/(guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] ) )
		*guideInfo.ellipseMinorAxis[RightSide];
	guideInfo.entranceVerticalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[TopSide]
			*guideInfo.ellipseMajorOffset[TopSide]
			/(guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] ) )
		*guideInfo.ellipseMinorAxis[TopSide];


	if ( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		exit( printf("Critical error in %s; the option for option = halfellipse is currently disabled.",NAME_CURRENT_COMP) );

		double used_focal_vertical;
		double used_focal_horizontal;
		double major_offset_horizontal = 0;
		double major_offset_vertical = 0;

		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+linyh)*(l+linyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+linxw)*(l+linxw) ); 
			major_offset_vertical = l;	
			major_offset_horizontal = l;
		}
		else {	
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+loutyh)*(l+loutyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+loutxw)*(l+loutxw) ); 
		}

		guideInfo.Length = l;

		guideInfo.ellipseMajorAxis[RightSide] = used_focal_horizontal;
		guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

		guideInfo.ellipseMajorOffset[RightSide] = major_offset_horizontal;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = 
								guideInfo.ellipseMajorAxis[RightSide];
		guideInfo.ellipseMinorAxis[LeftSide] = 
								guideInfo.ellipseMinorAxis[RightSide];
		guideInfo.ellipseMajorOffset[LeftSide] = 
								guideInfo.ellipseMajorOffset[RightSide];
		guideInfo.ellipseMinorOffset[LeftSide] = 
								guideInfo.ellipseMinorOffset[RightSide];

		guideInfo.ellipseMajorAxis[TopSide] = used_focal_vertical;
		guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

		guideInfo.ellipseMajorOffset[TopSide] = major_offset_vertical;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = 
								guideInfo.ellipseMajorAxis[TopSide];
		guideInfo.ellipseMinorAxis[BottomSide] = 
								guideInfo.ellipseMinorAxis[TopSide];
		guideInfo.ellipseMajorOffset[BottomSide] = 
								guideInfo.ellipseMajorOffset[TopSide];
		guideInfo.ellipseMinorOffset[BottomSide] = 
								guideInfo.ellipseMinorOffset[TopSide];
	}

	// Applies the properties of the mirrors in the guide given by the user.
	// These variables are used in the reflection functions.

	
	// Sets the mirror type of the guides mirrors
	// These variables are used in the collision functions 
	// to find the type of collision

	// guideInfo.OuterSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[BottomSide] = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_bottom_side_mirror,guideInfo.verboseSetting);

	// guideInfo.InnerSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[BottomSide] =	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_bottom_side_mirror,guideInfo.verboseSetting);

	// Give a warning if all side of the guide is turned off, 
	// as the guide is essentially turned off
	if(    guideInfo.OuterSide[RightSide] 	== 1 
		&& guideInfo.OuterSide[TopSide] 	== 1
		&& guideInfo.OuterSide[LeftSide] 	== 1 
		&& guideInfo.OuterSide[BottomSide]	== 1
		&& guideInfo.InnerSide[RightSide] 	== 1 
		&& guideInfo.InnerSide[TopSide] 	== 1
		&& guideInfo.InnerSide[LeftSide] 	== 1 
		&& guideInfo.InnerSide[BottomSide]  == 1)
		printf("Warning: In %s all the sides of the guide has been disabled,"
				" so it not possible for any particle"
				" to collide with the guide, consider"
				" disabling this component",NAME_CURRENT_COMP);
	
	if(guideInfo.mArr[RightSide] <= 0)  guideInfo.InnerSide[RightSide] = 
														MirrorTypeabsorption;
	if(guideInfo.mArr[TopSide] <= 0) 	 guideInfo.InnerSide[TopSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[LeftSide] <= 0) 	 guideInfo.InnerSide[LeftSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[BottomSide] <= 0) guideInfo.InnerSide[BottomSide] = 
														MirrorTypeabsorption;
	/* if(directDefination == 0){ */
	/* 	guideInfo.entranceHorizontalWidth = xwidth; */
	/* 	guideInfo.entranceVerticalWidth = yheight; */
	/* } */
	
	if( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		guideInfo.entranceHorizontalWidth =
			(guideInfo.ellipseMinorAxis[RightSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[RightSide]
						*guideInfo.ellipseMajorOffset[RightSide] )
			/( guideInfo.ellipseMajorAxis[RightSide]
			  *guideInfo.ellipseMajorAxis[RightSide] ) )
			+ guideInfo.ellipseMinorOffset[RightSide] )*2;
		guideInfo.entranceVerticalWidth = 
			(guideInfo.ellipseMinorAxis[TopSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[TopSide]
						*guideInfo.ellipseMajorOffset[TopSide] )
			/( guideInfo.ellipseMajorAxis[TopSide]
			  *guideInfo.ellipseMajorAxis[TopSide] ) )
			+ guideInfo.ellipseMinorOffset[TopSide] )*2;
	}


	guideInfo.EnclosingBoxOn = 0;

	/*
	double DefaultArray1[8] = { 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0, 1.0};
	double DefaultArray2[8] = { 1.0, 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0};
	double DefaultArray3[8] = {-1.0,-1.0,-1.0,-1.0, 1.0, 1.0, 1.0, 1.0}; 

	guideInfo.EnclosingBoxOn = 0;
	double *xinput;
	if ( xInput != NULL ){ xinput = xInput; guideInfo.EnclosingBoxOn = 1; }
	else { xinput = DefaultArray1; }
	double *yinput;
	if ( yInput != NULL ){ yinput = yInput; guideInfo.EnclosingBoxOn = 1;}
	else { yinput = DefaultArray2; }
	double *zinput;
	if ( zInput != NULL ){ zinput = zInput; guideInfo.EnclosingBoxOn = 1;}
	else { zinput = DefaultArray3; }
	*/

	/*
	double xarray[8] ={ guideInfo.ellipseMinorAxis[0]*xinput[0],
						guideInfo.ellipseMinorAxis[2]*xinput[1],
						guideInfo.ellipseMinorAxis[2]*xinput[2],
						guideInfo.ellipseMinorAxis[0]*xinput[3],
						guideInfo.ellipseMinorAxis[0]*xinput[4],
						guideInfo.ellipseMinorAxis[2]*xinput[5],
						guideInfo.ellipseMinorAxis[2]*xinput[6],
						guideInfo.ellipseMinorAxis[0]*xinput[7] };
	double yarray[8] ={ guideInfo.ellipseMinorAxis[1]*yinput[0],
						guideInfo.ellipseMinorAxis[1]*yinput[1],
						guideInfo.ellipseMinorAxis[3]*yinput[2],
						guideInfo.ellipseMinorAxis[3]*yinput[3],
						guideInfo.ellipseMinorAxis[1]*yinput[4],
						guideInfo.ellipseMinorAxis[1]*yinput[5],
						guideInfo.ellipseMinorAxis[3]*yinput[6],
						guideInfo.ellipseMinorAxis[3]*yinput[7] };
	double zarray[8] ={ guideInfo.Length/2*zinput[0]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[1]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[2]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[3]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[4]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[5]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[6]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[7]+guideInfo.Length/2 };
	int i = 0;
	for(i = 0; i < 8; i++){
		guideInfo.xArray[i] = xarray[i];
		guideInfo.yArray[i] = yarray[i];
		guideInfo.zArray[i] = zarray[i];
	}
	*/

	guideInfo.exitVerticalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide]) 
					)/(guideInfo.ellipseMajorAxis[BottomSide] 
					*guideInfo.ellipseMajorAxis[BottomSide] )
		)*guideInfo.ellipseMinorAxis[BottomSide];

	guideInfo.exitHorizontalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide]) 
					)/(guideInfo.ellipseMajorAxis[RightSide] 
					*guideInfo.ellipseMajorAxis[RightSide] ) 
		)*guideInfo.ellipseMinorAxis[RightSide];

    //////////////////segmentation of m values

	// Are the arrays empty?
	if(mvaluesright != NULL || mvaluesleft != NULL 
	|| mvaluestop != NULL || mvaluesbottom != NULL)
	{
		guideInfo.enableSegments = 1;

		guideInfo.numberOfSegments = sizeof(mvaluesright)/sizeof(mvaluesright[0]);

		//printf("Length is %i\n",guideInfo.numberOfSegments);
		guideInfo.mValuesright = mvaluesright;
		guideInfo.mValuesleft = mvaluesleft;
		guideInfo.mValuestop = mvaluestop;
		guideInfo.mValuesbottom = mvaluesbottom;
		//printf("Seglength ... %f %f %f\n",seglength[0],seglength[1],seglength[2]);

		// Are the arrays of equal length?
		if(seglength == NULL){
			dynamicalSegLength = 
					realloc(dynamicalSegLength,
							guideInfo.numberOfSegments*sizeof(double) );
			int i;
			for (i = 0; i < guideInfo.numberOfSegments; ++i){
				dynamicalSegLength[i] = 
						guideInfo.Length/guideInfo.numberOfSegments;
				}
			guideInfo.segLength = dynamicalSegLength;
		}
		else guideInfo.segLength = seglength;

		if( guideInfo.numberOfSegments != sizeof(mvaluesright)/sizeof(mvaluesright[0]) 
		 || guideInfo.numberOfSegments != sizeof(mvaluesleft)/sizeof(mvaluesleft[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluestop)/sizeof(mvaluestop[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0])
		 || (guideInfo.segLength == NULL
		  & guideInfo.numberOfSegments != sizeof(seglength)/sizeof(guideInfo.segLength[0]) 
		  ) ) {
			
			printf("Error in userinput inside %s, the length of the arrays"
				   " mvalues and seglength are not equal\n",NAME_CURRENT_COMP);
			printf("The length of the arrays are: mValuesright is %lu,"
				   " mvaluesleft is %lu, mvaluestop is %lu, mvaluesbottom is"
				   " %lu and seglength is %lu and should be %d \n; Above assume that the arrays are using double \n",
					sizeof(mvaluesright)/sizeof(double),
					sizeof(mvaluesleft)/sizeof(double),
					sizeof(mvaluestop)/sizeof(double),
					sizeof(mvaluesbottom)/sizeof(double),
					sizeof(guideInfo.segLength)/sizeof(double),
					guideInfo.numberOfSegments	
					);
				
			if ( guideInfo.verboseSetting )	{
				int i;
				
				printf("The Values of mvaluesright is: [");
				for(i=0; i < sizeof(mvaluesright)/sizeof(mvaluesright[0]); i++) 	
						printf("%e,",guideInfo.mValuesright[i] );
				printf("]\n");
				
				printf("The Values of mvaluesleft is: [");
				for(i=0; i < sizeof(mvaluesleft)/sizeof(mvaluesleft[0]); i++) 	
						printf("%e,",guideInfo.mValuesleft[i] );
				printf("]\n");
				
				printf("The Values of mvaluestop is: [");
				for(i=0; i < sizeof(mvaluestop)/sizeof(mvaluestop[0]); i++) 	
						printf("%e,",guideInfo.mValuestop[i] );
				printf("]\n");

				printf("The Values of mvaluesbottom is: [");
				for(i=0; i < sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0]); i++) 
						printf("%e,",guideInfo.mValuesbottom[i] );
				printf("]\n");

				printf("The Values of seglength is: [");
				for(i=0; i < sizeof(guideInfo.segLength)/sizeof(guideInfo.segLength[0]); i++) 
						printf("%e,",guideInfo.segLength[i]);
				printf("]\n");
			}
			exit( printf("Exit due to critical error in userinput for the"
						" component %s, consider having a look at the input"
						" for following: mvaluesright,mvaluesleft,mvaluestop,"
						"mvaluesbottom and/or seglength.",NAME_CURRENT_COMP) );
		}
		//
		double sumOfelements=0;
		int i;
		for(i=0;i< guideInfo.numberOfSegments; i++) {
			sumOfelements += guideInfo.segLength[i];
		}
		if ( guideInfo.verboseSetting 
		&& fabs(sumOfelements-guideInfo.Length) > 1e-9 )
			printf("Error in userinput inside %s, the difference between"
					" guidelength and elements of the seglength array is:"
					"%e consider changes the parameters l or seglength \n",
					NAME_CURRENT_COMP,sumOfelements-guideInfo.Length);
	}
	else guideInfo.enableSegments = 0;


///////////////////////////////////////////////////////////////////////////
/////////////// Calculate gravity vector in the guides coordinatesystem
///////////////////////////////////////////////////////////////////////////

/*
	Sets the local gravity vector equal to the global gravity vector (0,-g,0) 
	and when apply the same rotation matrix as applied to guide. 
*/ 
	if (enableGravity != 0){
		Gx0=0, Gy0=-GRAVITY*enableGravity, Gz0=0;
		Coords mcLocG;
		mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,Gy0,0));
		coords_get(mcLocG, &Gx0, &Gy0, &Gz0);
	}
	Circ=2*PI*curvature;
}
#line 36573 "./ESS_BIFROST_shielding.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component DiwJaw2. */
  SIG_MESSAGE("DiwJaw2 (Init)");
#define mccompcurname  DiwJaw2
#define mccompcurtype  Slit
#define mccompcurindex 55
#define xmin mccDiwJaw2_xmin
#define xmax mccDiwJaw2_xmax
#define ymin mccDiwJaw2_ymin
#define ymax mccDiwJaw2_ymax
#define radius mccDiwJaw2_radius
#define xwidth mccDiwJaw2_xwidth
#define yheight mccDiwJaw2_yheight
#line 50 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Slit.comp"
{
if (xwidth > 0)  { 
  if (!xmin && !xmax) {
    xmax=xwidth/2;  xmin=-xmax;
  } else {
    fprintf(stderr,"Slit: %s: Error: please specify EITHER xmin & xmax or xwidth\n", NAME_CURRENT_COMP); exit(-1);
  }
 }
 if (yheight > 0) { 
   if (!ymin && !ymax) {
     ymax=yheight/2; ymin=-ymax; 
   } else {
     fprintf(stderr,"Slit: %s: Error: please specify EITHER ymin & ymax or ywidth\n", NAME_CURRENT_COMP); exit(-1);
   }
 }
 if (xmin == 0 && xmax == 0 && ymin == 0 && ymax == 0 && radius == 0)
    { fprintf(stderr,"Slit: %s: Warning: Running with CLOSED slit - is this intentional?? \n", NAME_CURRENT_COMP); }

}
#line 36656 "./ESS_BIFROST_shielding.c"
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component elliptical_guide_gravity1_3. */
  SIG_MESSAGE("elliptical_guide_gravity1_3 (Init)");
#define mccompcurname  elliptical_guide_gravity1_3
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 56
#define mvaluesright mccelliptical_guide_gravity1_3_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_3_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_3_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_3_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_3_seglength
#define guideInfo mccelliptical_guide_gravity1_3_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_3_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_3_Gx
#define Gy mccelliptical_guide_gravity1_3_Gy
#define Gz mccelliptical_guide_gravity1_3_Gz
#define Gx0 mccelliptical_guide_gravity1_3_Gx0
#define Gy0 mccelliptical_guide_gravity1_3_Gy0
#define Gz0 mccelliptical_guide_gravity1_3_Gz0
#define Circ mccelliptical_guide_gravity1_3_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_3_dynamicalSegLength
#define l mccelliptical_guide_gravity1_3_l
#define xwidth mccelliptical_guide_gravity1_3_xwidth
#define yheight mccelliptical_guide_gravity1_3_yheight
#define linxw mccelliptical_guide_gravity1_3_linxw
#define loutxw mccelliptical_guide_gravity1_3_loutxw
#define linyh mccelliptical_guide_gravity1_3_linyh
#define loutyh mccelliptical_guide_gravity1_3_loutyh
#define majorAxisxw mccelliptical_guide_gravity1_3_majorAxisxw
#define minorAxisxw mccelliptical_guide_gravity1_3_minorAxisxw
#define majorAxisyh mccelliptical_guide_gravity1_3_majorAxisyh
#define minorAxisyh mccelliptical_guide_gravity1_3_minorAxisyh
#define majorAxisoffsetxw mccelliptical_guide_gravity1_3_majorAxisoffsetxw
#define majorAxisoffsetyh mccelliptical_guide_gravity1_3_majorAxisoffsetyh
#define dimensionsAt mccelliptical_guide_gravity1_3_dimensionsAt
#define option mccelliptical_guide_gravity1_3_option
#define R0 mccelliptical_guide_gravity1_3_R0
#define Qc mccelliptical_guide_gravity1_3_Qc
#define alpha mccelliptical_guide_gravity1_3_alpha
#define m mccelliptical_guide_gravity1_3_m
#define W mccelliptical_guide_gravity1_3_W
#define alpharight mccelliptical_guide_gravity1_3_alpharight
#define mright mccelliptical_guide_gravity1_3_mright
#define alphaleft mccelliptical_guide_gravity1_3_alphaleft
#define mleft mccelliptical_guide_gravity1_3_mleft
#define alphatop mccelliptical_guide_gravity1_3_alphatop
#define mtop mccelliptical_guide_gravity1_3_mtop
#define alphabottom mccelliptical_guide_gravity1_3_alphabottom
#define mbottom mccelliptical_guide_gravity1_3_mbottom
#define verbose mccelliptical_guide_gravity1_3_verbose
#define enableGravity mccelliptical_guide_gravity1_3_enableGravity
#define curvature mccelliptical_guide_gravity1_3_curvature
#line 829 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
{
	///////////////////////////////////////////////////////////////////////////
	/////////////// Test user input
	///////////////////////////////////////////////////////////////////////////

	if(strcmp(verbose,"on") == 0)
		guideInfo.verboseSetting = 1;
	else guideInfo.verboseSetting = 0;
	

	guideInfo.R0Arr[RightSide] 		= R0;
	guideInfo.QcArr[RightSide] 		= Qc;
	guideInfo.alphaArr[RightSide] 	= alpharight;
	guideInfo.mArr[RightSide] 		= mright;
	guideInfo.WArr[RightSide] 		= W; 

	guideInfo.R0Arr[TopSide] 	 = R0; 
	guideInfo.QcArr[TopSide] 	 = Qc; 
	guideInfo.alphaArr[TopSide]  = alphatop; 
	guideInfo.mArr[TopSide] 	 = mtop;
	guideInfo.WArr[TopSide] 	 = W; 

	guideInfo.R0Arr[LeftSide] 		= R0; 
	guideInfo.QcArr[LeftSide] 		= Qc; 
	guideInfo.alphaArr[LeftSide] 	= alphaleft; 
	guideInfo.mArr[LeftSide] 		= mleft; 
	guideInfo.WArr[LeftSide] 		= W; 

	guideInfo.R0Arr[BottomSide] 	= R0; 
	guideInfo.QcArr[BottomSide] 	= Qc; 
	guideInfo.alphaArr[BottomSide] 	= alphabottom; 
	guideInfo.mArr[BottomSide] 		= mbottom; 
	guideInfo.WArr[BottomSide] 		= W; 

	int sides;
	for (sides = RightSide; sides <= BottomSide; sides++){
		if (guideInfo.alphaArr[sides] == -1) guideInfo.alphaArr[sides] = alpha;
		if (guideInfo.mArr[sides] == -1)	 guideInfo.mArr[sides] = m;
	}
	
	// Test user input for illegal values
	int inputErrors = 0;
	// Lower or equal to zero
	if(l <= 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("length",guideInfo.verboseSetting);
	if(guideInfo.alphaArr[TopSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphatop",guideInfo.verboseSetting);
	if(guideInfo.mArr[TopSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mtop",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[BottomSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphabottom",guideInfo.verboseSetting);
	if(guideInfo.mArr[BottomSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mbottom",guideInfo.verboseSetting);

	if(guideInfo.alphaArr[RightSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alpharight",guideInfo.verboseSetting);
	if(guideInfo.mArr[RightSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mright",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[LeftSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphaleft",guideInfo.verboseSetting);
	if(guideInfo.mArr[LeftSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mleft",guideInfo.verboseSetting);

	// Focal points result in hyperbola instead of an ellipse
	if(l <= -linxw-loutxw) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linw","loutw",linxw,loutxw,guideInfo.verboseSetting);
	if(l <= -linyh-loutyh) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linh","louth",linyh,loutyh,guideInfo.verboseSetting);

	if( strcmp(dimensionsAt,"entrance") != 0 
	 && strcmp(dimensionsAt,"mid") != 0 
	 && strcmp(dimensionsAt,"exit") != 0){
	 	inputErrors += 1;
		printf("dimensionsAt were given an incorrect input."
			   "Input must be string containing \"entrance\",\"mid\" or \"exit\" \n");
	}


	// Terminate program if any input errors occurred
	if(inputErrors != 0 ){
		exit(printf("\nCRITICAL ERROR(S) IN COMPONENT %s" 
				" CONSIDER CHECKING USER INPUT AS %d INPUT ERRORS WAS FOUND.\n",
				NAME_CURRENT_COMP,inputErrors) );
	}


	///////////////////////////////////////////////////////////////////////////
	/////////////// Calculate intern guide values from user input
	///////////////////////////////////////////////////////////////////////////

	/*  Calculate the foci line for the ellipses.
		These can be used to calculate the axes of the ellipses
		using pyth and defination of the ellipse that says distance 
		between the foci and every point on the ellipse is constant.
	*/
	int directDefination = 0;

	if( majorAxisyh != 0 || minorAxisyh != 0 
	 || majorAxisxw != 0 || minorAxisxw != 0)
	{
		directDefination = 1;
		guideInfo.Length = l;	
		
		guideInfo.ellipseMajorAxis[RightSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[RightSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[RightSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[TopSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[TopSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[TopSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[LeftSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[LeftSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[LeftSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[BottomSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[BottomSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[BottomSide] = 0;

		guideInfo.entranceHorizontalWidth =
			2*sqrt(1 - (majorAxisoffsetyh*majorAxisoffsetyh)
			/(majorAxisyh*majorAxisyh) )*minorAxisyh;
		guideInfo.entranceVerticalWidth = 	
			2*sqrt(1 - (majorAxisoffsetxw*majorAxisoffsetxw)
			/(majorAxisxw*majorAxisxw) )*minorAxisxw;
	}

	if ( strcmp(option,"ellipse") == 0 && directDefination == 0)
	{
		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( linxw*linxw + xwidth*xwidth*0.25)
				+ sqrt( (l + loutxw)*(l + loutxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( linyh*linyh + yheight*yheight*0.25)
				+ sqrt( (l + loutyh)*(l + loutyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"exit") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( loutxw*loutxw + xwidth*xwidth*0.25)
				+ sqrt( (l + linxw)*(l + linxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( loutyh*loutyh + yheight*yheight*0.25)
				+ sqrt( (l + linyh)*(l + linyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] =(l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"mid") == 0 ){ 

			guideInfo.Length = l;
			
			guideInfo.ellipseMajorAxis[RightSide] = 
				sqrt( (linxw+l+loutxw)*(linxw+l+loutxw)/4+xwidth*xwidth/4);
			guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = 
				sqrt( (linyh+l+loutyh)*(linyh+l+loutyh)/4+yheight*yheight/4);
			guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];

		}
	}

	guideInfo.entranceHorizontalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[RightSide]
			*guideInfo.ellipseMajorOffset[RightSide]
			/(guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] ) )
		*guideInfo.ellipseMinorAxis[RightSide];
	guideInfo.entranceVerticalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[TopSide]
			*guideInfo.ellipseMajorOffset[TopSide]
			/(guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] ) )
		*guideInfo.ellipseMinorAxis[TopSide];


	if ( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		exit( printf("Critical error in %s; the option for option = halfellipse is currently disabled.",NAME_CURRENT_COMP) );

		double used_focal_vertical;
		double used_focal_horizontal;
		double major_offset_horizontal = 0;
		double major_offset_vertical = 0;

		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+linyh)*(l+linyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+linxw)*(l+linxw) ); 
			major_offset_vertical = l;	
			major_offset_horizontal = l;
		}
		else {	
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+loutyh)*(l+loutyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+loutxw)*(l+loutxw) ); 
		}

		guideInfo.Length = l;

		guideInfo.ellipseMajorAxis[RightSide] = used_focal_horizontal;
		guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

		guideInfo.ellipseMajorOffset[RightSide] = major_offset_horizontal;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = 
								guideInfo.ellipseMajorAxis[RightSide];
		guideInfo.ellipseMinorAxis[LeftSide] = 
								guideInfo.ellipseMinorAxis[RightSide];
		guideInfo.ellipseMajorOffset[LeftSide] = 
								guideInfo.ellipseMajorOffset[RightSide];
		guideInfo.ellipseMinorOffset[LeftSide] = 
								guideInfo.ellipseMinorOffset[RightSide];

		guideInfo.ellipseMajorAxis[TopSide] = used_focal_vertical;
		guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

		guideInfo.ellipseMajorOffset[TopSide] = major_offset_vertical;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = 
								guideInfo.ellipseMajorAxis[TopSide];
		guideInfo.ellipseMinorAxis[BottomSide] = 
								guideInfo.ellipseMinorAxis[TopSide];
		guideInfo.ellipseMajorOffset[BottomSide] = 
								guideInfo.ellipseMajorOffset[TopSide];
		guideInfo.ellipseMinorOffset[BottomSide] = 
								guideInfo.ellipseMinorOffset[TopSide];
	}

	// Applies the properties of the mirrors in the guide given by the user.
	// These variables are used in the reflection functions.

	
	// Sets the mirror type of the guides mirrors
	// These variables are used in the collision functions 
	// to find the type of collision

	// guideInfo.OuterSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[BottomSide] = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_bottom_side_mirror,guideInfo.verboseSetting);

	// guideInfo.InnerSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[BottomSide] =	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_bottom_side_mirror,guideInfo.verboseSetting);

	// Give a warning if all side of the guide is turned off, 
	// as the guide is essentially turned off
	if(    guideInfo.OuterSide[RightSide] 	== 1 
		&& guideInfo.OuterSide[TopSide] 	== 1
		&& guideInfo.OuterSide[LeftSide] 	== 1 
		&& guideInfo.OuterSide[BottomSide]	== 1
		&& guideInfo.InnerSide[RightSide] 	== 1 
		&& guideInfo.InnerSide[TopSide] 	== 1
		&& guideInfo.InnerSide[LeftSide] 	== 1 
		&& guideInfo.InnerSide[BottomSide]  == 1)
		printf("Warning: In %s all the sides of the guide has been disabled,"
				" so it not possible for any particle"
				" to collide with the guide, consider"
				" disabling this component",NAME_CURRENT_COMP);
	
	if(guideInfo.mArr[RightSide] <= 0)  guideInfo.InnerSide[RightSide] = 
														MirrorTypeabsorption;
	if(guideInfo.mArr[TopSide] <= 0) 	 guideInfo.InnerSide[TopSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[LeftSide] <= 0) 	 guideInfo.InnerSide[LeftSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[BottomSide] <= 0) guideInfo.InnerSide[BottomSide] = 
														MirrorTypeabsorption;
	/* if(directDefination == 0){ */
	/* 	guideInfo.entranceHorizontalWidth = xwidth; */
	/* 	guideInfo.entranceVerticalWidth = yheight; */
	/* } */
	
	if( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		guideInfo.entranceHorizontalWidth =
			(guideInfo.ellipseMinorAxis[RightSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[RightSide]
						*guideInfo.ellipseMajorOffset[RightSide] )
			/( guideInfo.ellipseMajorAxis[RightSide]
			  *guideInfo.ellipseMajorAxis[RightSide] ) )
			+ guideInfo.ellipseMinorOffset[RightSide] )*2;
		guideInfo.entranceVerticalWidth = 
			(guideInfo.ellipseMinorAxis[TopSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[TopSide]
						*guideInfo.ellipseMajorOffset[TopSide] )
			/( guideInfo.ellipseMajorAxis[TopSide]
			  *guideInfo.ellipseMajorAxis[TopSide] ) )
			+ guideInfo.ellipseMinorOffset[TopSide] )*2;
	}


	guideInfo.EnclosingBoxOn = 0;

	/*
	double DefaultArray1[8] = { 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0, 1.0};
	double DefaultArray2[8] = { 1.0, 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0};
	double DefaultArray3[8] = {-1.0,-1.0,-1.0,-1.0, 1.0, 1.0, 1.0, 1.0}; 

	guideInfo.EnclosingBoxOn = 0;
	double *xinput;
	if ( xInput != NULL ){ xinput = xInput; guideInfo.EnclosingBoxOn = 1; }
	else { xinput = DefaultArray1; }
	double *yinput;
	if ( yInput != NULL ){ yinput = yInput; guideInfo.EnclosingBoxOn = 1;}
	else { yinput = DefaultArray2; }
	double *zinput;
	if ( zInput != NULL ){ zinput = zInput; guideInfo.EnclosingBoxOn = 1;}
	else { zinput = DefaultArray3; }
	*/

	/*
	double xarray[8] ={ guideInfo.ellipseMinorAxis[0]*xinput[0],
						guideInfo.ellipseMinorAxis[2]*xinput[1],
						guideInfo.ellipseMinorAxis[2]*xinput[2],
						guideInfo.ellipseMinorAxis[0]*xinput[3],
						guideInfo.ellipseMinorAxis[0]*xinput[4],
						guideInfo.ellipseMinorAxis[2]*xinput[5],
						guideInfo.ellipseMinorAxis[2]*xinput[6],
						guideInfo.ellipseMinorAxis[0]*xinput[7] };
	double yarray[8] ={ guideInfo.ellipseMinorAxis[1]*yinput[0],
						guideInfo.ellipseMinorAxis[1]*yinput[1],
						guideInfo.ellipseMinorAxis[3]*yinput[2],
						guideInfo.ellipseMinorAxis[3]*yinput[3],
						guideInfo.ellipseMinorAxis[1]*yinput[4],
						guideInfo.ellipseMinorAxis[1]*yinput[5],
						guideInfo.ellipseMinorAxis[3]*yinput[6],
						guideInfo.ellipseMinorAxis[3]*yinput[7] };
	double zarray[8] ={ guideInfo.Length/2*zinput[0]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[1]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[2]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[3]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[4]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[5]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[6]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[7]+guideInfo.Length/2 };
	int i = 0;
	for(i = 0; i < 8; i++){
		guideInfo.xArray[i] = xarray[i];
		guideInfo.yArray[i] = yarray[i];
		guideInfo.zArray[i] = zarray[i];
	}
	*/

	guideInfo.exitVerticalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide]) 
					)/(guideInfo.ellipseMajorAxis[BottomSide] 
					*guideInfo.ellipseMajorAxis[BottomSide] )
		)*guideInfo.ellipseMinorAxis[BottomSide];

	guideInfo.exitHorizontalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide]) 
					)/(guideInfo.ellipseMajorAxis[RightSide] 
					*guideInfo.ellipseMajorAxis[RightSide] ) 
		)*guideInfo.ellipseMinorAxis[RightSide];

    //////////////////segmentation of m values

	// Are the arrays empty?
	if(mvaluesright != NULL || mvaluesleft != NULL 
	|| mvaluestop != NULL || mvaluesbottom != NULL)
	{
		guideInfo.enableSegments = 1;

		guideInfo.numberOfSegments = sizeof(mvaluesright)/sizeof(mvaluesright[0]);

		//printf("Length is %i\n",guideInfo.numberOfSegments);
		guideInfo.mValuesright = mvaluesright;
		guideInfo.mValuesleft = mvaluesleft;
		guideInfo.mValuestop = mvaluestop;
		guideInfo.mValuesbottom = mvaluesbottom;
		//printf("Seglength ... %f %f %f\n",seglength[0],seglength[1],seglength[2]);

		// Are the arrays of equal length?
		if(seglength == NULL){
			dynamicalSegLength = 
					realloc(dynamicalSegLength,
							guideInfo.numberOfSegments*sizeof(double) );
			int i;
			for (i = 0; i < guideInfo.numberOfSegments; ++i){
				dynamicalSegLength[i] = 
						guideInfo.Length/guideInfo.numberOfSegments;
				}
			guideInfo.segLength = dynamicalSegLength;
		}
		else guideInfo.segLength = seglength;

		if( guideInfo.numberOfSegments != sizeof(mvaluesright)/sizeof(mvaluesright[0]) 
		 || guideInfo.numberOfSegments != sizeof(mvaluesleft)/sizeof(mvaluesleft[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluestop)/sizeof(mvaluestop[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0])
		 || (guideInfo.segLength == NULL
		  & guideInfo.numberOfSegments != sizeof(seglength)/sizeof(guideInfo.segLength[0]) 
		  ) ) {
			
			printf("Error in userinput inside %s, the length of the arrays"
				   " mvalues and seglength are not equal\n",NAME_CURRENT_COMP);
			printf("The length of the arrays are: mValuesright is %lu,"
				   " mvaluesleft is %lu, mvaluestop is %lu, mvaluesbottom is"
				   " %lu and seglength is %lu and should be %d \n; Above assume that the arrays are using double \n",
					sizeof(mvaluesright)/sizeof(double),
					sizeof(mvaluesleft)/sizeof(double),
					sizeof(mvaluestop)/sizeof(double),
					sizeof(mvaluesbottom)/sizeof(double),
					sizeof(guideInfo.segLength)/sizeof(double),
					guideInfo.numberOfSegments	
					);
				
			if ( guideInfo.verboseSetting )	{
				int i;
				
				printf("The Values of mvaluesright is: [");
				for(i=0; i < sizeof(mvaluesright)/sizeof(mvaluesright[0]); i++) 	
						printf("%e,",guideInfo.mValuesright[i] );
				printf("]\n");
				
				printf("The Values of mvaluesleft is: [");
				for(i=0; i < sizeof(mvaluesleft)/sizeof(mvaluesleft[0]); i++) 	
						printf("%e,",guideInfo.mValuesleft[i] );
				printf("]\n");
				
				printf("The Values of mvaluestop is: [");
				for(i=0; i < sizeof(mvaluestop)/sizeof(mvaluestop[0]); i++) 	
						printf("%e,",guideInfo.mValuestop[i] );
				printf("]\n");

				printf("The Values of mvaluesbottom is: [");
				for(i=0; i < sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0]); i++) 
						printf("%e,",guideInfo.mValuesbottom[i] );
				printf("]\n");

				printf("The Values of seglength is: [");
				for(i=0; i < sizeof(guideInfo.segLength)/sizeof(guideInfo.segLength[0]); i++) 
						printf("%e,",guideInfo.segLength[i]);
				printf("]\n");
			}
			exit( printf("Exit due to critical error in userinput for the"
						" component %s, consider having a look at the input"
						" for following: mvaluesright,mvaluesleft,mvaluestop,"
						"mvaluesbottom and/or seglength.",NAME_CURRENT_COMP) );
		}
		//
		double sumOfelements=0;
		int i;
		for(i=0;i< guideInfo.numberOfSegments; i++) {
			sumOfelements += guideInfo.segLength[i];
		}
		if ( guideInfo.verboseSetting 
		&& fabs(sumOfelements-guideInfo.Length) > 1e-9 )
			printf("Error in userinput inside %s, the difference between"
					" guidelength and elements of the seglength array is:"
					"%e consider changes the parameters l or seglength \n",
					NAME_CURRENT_COMP,sumOfelements-guideInfo.Length);
	}
	else guideInfo.enableSegments = 0;


///////////////////////////////////////////////////////////////////////////
/////////////// Calculate gravity vector in the guides coordinatesystem
///////////////////////////////////////////////////////////////////////////

/*
	Sets the local gravity vector equal to the global gravity vector (0,-g,0) 
	and when apply the same rotation matrix as applied to guide. 
*/ 
	if (enableGravity != 0){
		Gx0=0, Gy0=-GRAVITY*enableGravity, Gz0=0;
		Coords mcLocG;
		mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,Gy0,0));
		coords_get(mcLocG, &Gx0, &Gy0, &Gz0);
	}
	Circ=2*PI*curvature;
}
#line 37311 "./ESS_BIFROST_shielding.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component DiwJaw1. */
  SIG_MESSAGE("DiwJaw1 (Init)");
#define mccompcurname  DiwJaw1
#define mccompcurtype  Slit
#define mccompcurindex 57
#define xmin mccDiwJaw1_xmin
#define xmax mccDiwJaw1_xmax
#define ymin mccDiwJaw1_ymin
#define ymax mccDiwJaw1_ymax
#define radius mccDiwJaw1_radius
#define xwidth mccDiwJaw1_xwidth
#define yheight mccDiwJaw1_yheight
#line 50 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Slit.comp"
{
if (xwidth > 0)  { 
  if (!xmin && !xmax) {
    xmax=xwidth/2;  xmin=-xmax;
  } else {
    fprintf(stderr,"Slit: %s: Error: please specify EITHER xmin & xmax or xwidth\n", NAME_CURRENT_COMP); exit(-1);
  }
 }
 if (yheight > 0) { 
   if (!ymin && !ymax) {
     ymax=yheight/2; ymin=-ymax; 
   } else {
     fprintf(stderr,"Slit: %s: Error: please specify EITHER ymin & ymax or ywidth\n", NAME_CURRENT_COMP); exit(-1);
   }
 }
 if (xmin == 0 && xmax == 0 && ymin == 0 && ymax == 0 && radius == 0)
    { fprintf(stderr,"Slit: %s: Warning: Running with CLOSED slit - is this intentional?? \n", NAME_CURRENT_COMP); }

}
#line 37394 "./ESS_BIFROST_shielding.c"
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component elliptical_guide_gravity1_4. */
  SIG_MESSAGE("elliptical_guide_gravity1_4 (Init)");
#define mccompcurname  elliptical_guide_gravity1_4
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 58
#define mvaluesright mccelliptical_guide_gravity1_4_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_4_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_4_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_4_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_4_seglength
#define guideInfo mccelliptical_guide_gravity1_4_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_4_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_4_Gx
#define Gy mccelliptical_guide_gravity1_4_Gy
#define Gz mccelliptical_guide_gravity1_4_Gz
#define Gx0 mccelliptical_guide_gravity1_4_Gx0
#define Gy0 mccelliptical_guide_gravity1_4_Gy0
#define Gz0 mccelliptical_guide_gravity1_4_Gz0
#define Circ mccelliptical_guide_gravity1_4_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_4_dynamicalSegLength
#define l mccelliptical_guide_gravity1_4_l
#define xwidth mccelliptical_guide_gravity1_4_xwidth
#define yheight mccelliptical_guide_gravity1_4_yheight
#define linxw mccelliptical_guide_gravity1_4_linxw
#define loutxw mccelliptical_guide_gravity1_4_loutxw
#define linyh mccelliptical_guide_gravity1_4_linyh
#define loutyh mccelliptical_guide_gravity1_4_loutyh
#define majorAxisxw mccelliptical_guide_gravity1_4_majorAxisxw
#define minorAxisxw mccelliptical_guide_gravity1_4_minorAxisxw
#define majorAxisyh mccelliptical_guide_gravity1_4_majorAxisyh
#define minorAxisyh mccelliptical_guide_gravity1_4_minorAxisyh
#define majorAxisoffsetxw mccelliptical_guide_gravity1_4_majorAxisoffsetxw
#define majorAxisoffsetyh mccelliptical_guide_gravity1_4_majorAxisoffsetyh
#define dimensionsAt mccelliptical_guide_gravity1_4_dimensionsAt
#define option mccelliptical_guide_gravity1_4_option
#define R0 mccelliptical_guide_gravity1_4_R0
#define Qc mccelliptical_guide_gravity1_4_Qc
#define alpha mccelliptical_guide_gravity1_4_alpha
#define m mccelliptical_guide_gravity1_4_m
#define W mccelliptical_guide_gravity1_4_W
#define alpharight mccelliptical_guide_gravity1_4_alpharight
#define mright mccelliptical_guide_gravity1_4_mright
#define alphaleft mccelliptical_guide_gravity1_4_alphaleft
#define mleft mccelliptical_guide_gravity1_4_mleft
#define alphatop mccelliptical_guide_gravity1_4_alphatop
#define mtop mccelliptical_guide_gravity1_4_mtop
#define alphabottom mccelliptical_guide_gravity1_4_alphabottom
#define mbottom mccelliptical_guide_gravity1_4_mbottom
#define verbose mccelliptical_guide_gravity1_4_verbose
#define enableGravity mccelliptical_guide_gravity1_4_enableGravity
#define curvature mccelliptical_guide_gravity1_4_curvature
#line 829 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
{
	///////////////////////////////////////////////////////////////////////////
	/////////////// Test user input
	///////////////////////////////////////////////////////////////////////////

	if(strcmp(verbose,"on") == 0)
		guideInfo.verboseSetting = 1;
	else guideInfo.verboseSetting = 0;
	

	guideInfo.R0Arr[RightSide] 		= R0;
	guideInfo.QcArr[RightSide] 		= Qc;
	guideInfo.alphaArr[RightSide] 	= alpharight;
	guideInfo.mArr[RightSide] 		= mright;
	guideInfo.WArr[RightSide] 		= W; 

	guideInfo.R0Arr[TopSide] 	 = R0; 
	guideInfo.QcArr[TopSide] 	 = Qc; 
	guideInfo.alphaArr[TopSide]  = alphatop; 
	guideInfo.mArr[TopSide] 	 = mtop;
	guideInfo.WArr[TopSide] 	 = W; 

	guideInfo.R0Arr[LeftSide] 		= R0; 
	guideInfo.QcArr[LeftSide] 		= Qc; 
	guideInfo.alphaArr[LeftSide] 	= alphaleft; 
	guideInfo.mArr[LeftSide] 		= mleft; 
	guideInfo.WArr[LeftSide] 		= W; 

	guideInfo.R0Arr[BottomSide] 	= R0; 
	guideInfo.QcArr[BottomSide] 	= Qc; 
	guideInfo.alphaArr[BottomSide] 	= alphabottom; 
	guideInfo.mArr[BottomSide] 		= mbottom; 
	guideInfo.WArr[BottomSide] 		= W; 

	int sides;
	for (sides = RightSide; sides <= BottomSide; sides++){
		if (guideInfo.alphaArr[sides] == -1) guideInfo.alphaArr[sides] = alpha;
		if (guideInfo.mArr[sides] == -1)	 guideInfo.mArr[sides] = m;
	}
	
	// Test user input for illegal values
	int inputErrors = 0;
	// Lower or equal to zero
	if(l <= 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("length",guideInfo.verboseSetting);
	if(guideInfo.alphaArr[TopSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphatop",guideInfo.verboseSetting);
	if(guideInfo.mArr[TopSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mtop",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[BottomSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphabottom",guideInfo.verboseSetting);
	if(guideInfo.mArr[BottomSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mbottom",guideInfo.verboseSetting);

	if(guideInfo.alphaArr[RightSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alpharight",guideInfo.verboseSetting);
	if(guideInfo.mArr[RightSide] < 0)       inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mright",guideInfo.verboseSetting);
	
	if(guideInfo.alphaArr[LeftSide] < 0) inputErrors += 
				guide_elliptical_illegalInputLessThanZero("alphaleft",guideInfo.verboseSetting);
	if(guideInfo.mArr[LeftSide] < 0)      inputErrors += 
				guide_elliptical_illegalInputLessThanZero("mleft",guideInfo.verboseSetting);

	// Focal points result in hyperbola instead of an ellipse
	if(l <= -linxw-loutxw) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linw","loutw",linxw,loutxw,guideInfo.verboseSetting);
	if(l <= -linyh-loutyh) inputErrors += guide_elliptical_illegalInputFocalPointsHyperbola(
						"linh","louth",linyh,loutyh,guideInfo.verboseSetting);

	if( strcmp(dimensionsAt,"entrance") != 0 
	 && strcmp(dimensionsAt,"mid") != 0 
	 && strcmp(dimensionsAt,"exit") != 0){
	 	inputErrors += 1;
		printf("dimensionsAt were given an incorrect input."
			   "Input must be string containing \"entrance\",\"mid\" or \"exit\" \n");
	}


	// Terminate program if any input errors occurred
	if(inputErrors != 0 ){
		exit(printf("\nCRITICAL ERROR(S) IN COMPONENT %s" 
				" CONSIDER CHECKING USER INPUT AS %d INPUT ERRORS WAS FOUND.\n",
				NAME_CURRENT_COMP,inputErrors) );
	}


	///////////////////////////////////////////////////////////////////////////
	/////////////// Calculate intern guide values from user input
	///////////////////////////////////////////////////////////////////////////

	/*  Calculate the foci line for the ellipses.
		These can be used to calculate the axes of the ellipses
		using pyth and defination of the ellipse that says distance 
		between the foci and every point on the ellipse is constant.
	*/
	int directDefination = 0;

	if( majorAxisyh != 0 || minorAxisyh != 0 
	 || majorAxisxw != 0 || minorAxisxw != 0)
	{
		directDefination = 1;
		guideInfo.Length = l;	
		
		guideInfo.ellipseMajorAxis[RightSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[RightSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[RightSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[TopSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[TopSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[TopSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = majorAxisxw;
		guideInfo.ellipseMinorAxis[LeftSide] = minorAxisxw;
		guideInfo.ellipseMajorOffset[LeftSide] = majorAxisoffsetxw;
		guideInfo.ellipseMinorOffset[LeftSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = majorAxisyh;
		guideInfo.ellipseMinorAxis[BottomSide] = minorAxisyh;
		guideInfo.ellipseMajorOffset[BottomSide] = majorAxisoffsetyh;
		guideInfo.ellipseMinorOffset[BottomSide] = 0;

		guideInfo.entranceHorizontalWidth =
			2*sqrt(1 - (majorAxisoffsetyh*majorAxisoffsetyh)
			/(majorAxisyh*majorAxisyh) )*minorAxisyh;
		guideInfo.entranceVerticalWidth = 	
			2*sqrt(1 - (majorAxisoffsetxw*majorAxisoffsetxw)
			/(majorAxisxw*majorAxisxw) )*minorAxisxw;
	}

	if ( strcmp(option,"ellipse") == 0 && directDefination == 0)
	{
		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( linxw*linxw + xwidth*xwidth*0.25)
				+ sqrt( (l + loutxw)*(l + loutxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( linyh*linyh + yheight*yheight*0.25)
				+ sqrt( (l + loutyh)*(l + loutyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"exit") == 0 ){ 
			double lofbs_horizontal = 
				  sqrt( loutxw*loutxw + xwidth*xwidth*0.25)
				+ sqrt( (l + linxw)*(l + linxw) + xwidth*xwidth*0.25);

			double lofbs_vertical = 
				  sqrt( loutyh*loutyh + yheight*yheight*0.25)
				+ sqrt( (l + linyh)*(l + linyh) + yheight*yheight*0.25);

			guideInfo.Length = l;

			guideInfo.ellipseMajorAxis[RightSide] = lofbs_horizontal/2;
			guideInfo.ellipseMinorAxis[RightSide] =
				sqrt(0.25*lofbs_horizontal*lofbs_horizontal
					-0.25*(l+linxw+loutxw)*(l+linxw+loutxw) );

			guideInfo.ellipseMajorOffset[RightSide] =(l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = lofbs_vertical/2;
			
			guideInfo.ellipseMinorAxis[TopSide] = 
					sqrt(0.25*lofbs_vertical*lofbs_vertical
						-0.25*(l+linyh+loutyh)*(l+linyh+loutyh)	);

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];
		}
		if ( strcmp(dimensionsAt,"mid") == 0 ){ 

			guideInfo.Length = l;
			
			guideInfo.ellipseMajorAxis[RightSide] = 
				sqrt( (linxw+l+loutxw)*(linxw+l+loutxw)/4+xwidth*xwidth/4);
			guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

			guideInfo.ellipseMajorOffset[RightSide] = (l+linxw+loutxw)/2-linxw;
			guideInfo.ellipseMinorOffset[RightSide] = 0;

			guideInfo.ellipseMajorAxis[LeftSide] = 
										guideInfo.ellipseMajorAxis[RightSide];
			guideInfo.ellipseMinorAxis[LeftSide] = 
										guideInfo.ellipseMinorAxis[RightSide];
			guideInfo.ellipseMajorOffset[LeftSide] = 
										guideInfo.ellipseMajorOffset[RightSide];
			guideInfo.ellipseMinorOffset[LeftSide] = 
										guideInfo.ellipseMinorOffset[RightSide];

			guideInfo.ellipseMajorAxis[TopSide] = 
				sqrt( (linyh+l+loutyh)*(linyh+l+loutyh)/4+yheight*yheight/4);
			guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

			guideInfo.ellipseMajorOffset[TopSide] = (l+linyh+loutyh)/2-linyh;
			guideInfo.ellipseMinorOffset[TopSide] = 0;

			guideInfo.ellipseMajorAxis[BottomSide] = 
										guideInfo.ellipseMajorAxis[TopSide];
			guideInfo.ellipseMinorAxis[BottomSide] = 
										guideInfo.ellipseMinorAxis[TopSide];
			guideInfo.ellipseMajorOffset[BottomSide] = 
										guideInfo.ellipseMajorOffset[TopSide];
			guideInfo.ellipseMinorOffset[BottomSide] = 
										guideInfo.ellipseMinorOffset[TopSide];

		}
	}

	guideInfo.entranceHorizontalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[RightSide]
			*guideInfo.ellipseMajorOffset[RightSide]
			/(guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] ) )
		*guideInfo.ellipseMinorAxis[RightSide];
	guideInfo.entranceVerticalWidth = 2*sqrt(
		1 - guideInfo.ellipseMajorOffset[TopSide]
			*guideInfo.ellipseMajorOffset[TopSide]
			/(guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] ) )
		*guideInfo.ellipseMinorAxis[TopSide];


	if ( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		exit( printf("Critical error in %s; the option for option = halfellipse is currently disabled.",NAME_CURRENT_COMP) );

		double used_focal_vertical;
		double used_focal_horizontal;
		double major_offset_horizontal = 0;
		double major_offset_vertical = 0;

		if ( strcmp(dimensionsAt,"entrance") == 0 ){ 
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+linyh)*(l+linyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+linxw)*(l+linxw) ); 
			major_offset_vertical = l;	
			major_offset_horizontal = l;
		}
		else {	
			used_focal_vertical = sqrt( (yheight*yheight)/4 
								+ (l+loutyh)*(l+loutyh) );
			used_focal_horizontal = sqrt( (xwidth*xwidth)/4 
								+ (l+loutxw)*(l+loutxw) ); 
		}

		guideInfo.Length = l;

		guideInfo.ellipseMajorAxis[RightSide] = used_focal_horizontal;
		guideInfo.ellipseMinorAxis[RightSide] = xwidth/2;

		guideInfo.ellipseMajorOffset[RightSide] = major_offset_horizontal;
		guideInfo.ellipseMinorOffset[RightSide] = 0;

		guideInfo.ellipseMajorAxis[LeftSide] = 
								guideInfo.ellipseMajorAxis[RightSide];
		guideInfo.ellipseMinorAxis[LeftSide] = 
								guideInfo.ellipseMinorAxis[RightSide];
		guideInfo.ellipseMajorOffset[LeftSide] = 
								guideInfo.ellipseMajorOffset[RightSide];
		guideInfo.ellipseMinorOffset[LeftSide] = 
								guideInfo.ellipseMinorOffset[RightSide];

		guideInfo.ellipseMajorAxis[TopSide] = used_focal_vertical;
		guideInfo.ellipseMinorAxis[TopSide] = yheight/2;

		guideInfo.ellipseMajorOffset[TopSide] = major_offset_vertical;
		guideInfo.ellipseMinorOffset[TopSide] = 0;

		guideInfo.ellipseMajorAxis[BottomSide] = 
								guideInfo.ellipseMajorAxis[TopSide];
		guideInfo.ellipseMinorAxis[BottomSide] = 
								guideInfo.ellipseMinorAxis[TopSide];
		guideInfo.ellipseMajorOffset[BottomSide] = 
								guideInfo.ellipseMajorOffset[TopSide];
		guideInfo.ellipseMinorOffset[BottomSide] = 
								guideInfo.ellipseMinorOffset[TopSide];
	}

	// Applies the properties of the mirrors in the guide given by the user.
	// These variables are used in the reflection functions.

	
	// Sets the mirror type of the guides mirrors
	// These variables are used in the collision functions 
	// to find the type of collision

	// guideInfo.OuterSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.OuterSide[BottomSide] = 	
	// 	guide_elliptical_getMirrorTypeFromInput(outer_bottom_side_mirror,guideInfo.verboseSetting);

	// guideInfo.InnerSide[RightSide]  = 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_right_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[TopSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_top_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[LeftSide]  	= 	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_left_side_mirror,guideInfo.verboseSetting);
	// guideInfo.InnerSide[BottomSide] =	
	// 	guide_elliptical_getMirrorTypeFromInput(inner_bottom_side_mirror,guideInfo.verboseSetting);

	// Give a warning if all side of the guide is turned off, 
	// as the guide is essentially turned off
	if(    guideInfo.OuterSide[RightSide] 	== 1 
		&& guideInfo.OuterSide[TopSide] 	== 1
		&& guideInfo.OuterSide[LeftSide] 	== 1 
		&& guideInfo.OuterSide[BottomSide]	== 1
		&& guideInfo.InnerSide[RightSide] 	== 1 
		&& guideInfo.InnerSide[TopSide] 	== 1
		&& guideInfo.InnerSide[LeftSide] 	== 1 
		&& guideInfo.InnerSide[BottomSide]  == 1)
		printf("Warning: In %s all the sides of the guide has been disabled,"
				" so it not possible for any particle"
				" to collide with the guide, consider"
				" disabling this component",NAME_CURRENT_COMP);
	
	if(guideInfo.mArr[RightSide] <= 0)  guideInfo.InnerSide[RightSide] = 
														MirrorTypeabsorption;
	if(guideInfo.mArr[TopSide] <= 0) 	 guideInfo.InnerSide[TopSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[LeftSide] <= 0) 	 guideInfo.InnerSide[LeftSide] 	= 
														MirrorTypeabsorption;
	if(guideInfo.mArr[BottomSide] <= 0) guideInfo.InnerSide[BottomSide] = 
														MirrorTypeabsorption;
	/* if(directDefination == 0){ */
	/* 	guideInfo.entranceHorizontalWidth = xwidth; */
	/* 	guideInfo.entranceVerticalWidth = yheight; */
	/* } */
	
	if( strcmp(option,"halfellipse") == 0 && directDefination == 0 ){
		guideInfo.entranceHorizontalWidth =
			(guideInfo.ellipseMinorAxis[RightSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[RightSide]
						*guideInfo.ellipseMajorOffset[RightSide] )
			/( guideInfo.ellipseMajorAxis[RightSide]
			  *guideInfo.ellipseMajorAxis[RightSide] ) )
			+ guideInfo.ellipseMinorOffset[RightSide] )*2;
		guideInfo.entranceVerticalWidth = 
			(guideInfo.ellipseMinorAxis[TopSide]
			* sqrt(1 - ( guideInfo.ellipseMajorOffset[TopSide]
						*guideInfo.ellipseMajorOffset[TopSide] )
			/( guideInfo.ellipseMajorAxis[TopSide]
			  *guideInfo.ellipseMajorAxis[TopSide] ) )
			+ guideInfo.ellipseMinorOffset[TopSide] )*2;
	}


	guideInfo.EnclosingBoxOn = 0;

	/*
	double DefaultArray1[8] = { 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0, 1.0};
	double DefaultArray2[8] = { 1.0, 1.0,-1.0,-1.0, 1.0, 1.0,-1.0,-1.0};
	double DefaultArray3[8] = {-1.0,-1.0,-1.0,-1.0, 1.0, 1.0, 1.0, 1.0}; 

	guideInfo.EnclosingBoxOn = 0;
	double *xinput;
	if ( xInput != NULL ){ xinput = xInput; guideInfo.EnclosingBoxOn = 1; }
	else { xinput = DefaultArray1; }
	double *yinput;
	if ( yInput != NULL ){ yinput = yInput; guideInfo.EnclosingBoxOn = 1;}
	else { yinput = DefaultArray2; }
	double *zinput;
	if ( zInput != NULL ){ zinput = zInput; guideInfo.EnclosingBoxOn = 1;}
	else { zinput = DefaultArray3; }
	*/

	/*
	double xarray[8] ={ guideInfo.ellipseMinorAxis[0]*xinput[0],
						guideInfo.ellipseMinorAxis[2]*xinput[1],
						guideInfo.ellipseMinorAxis[2]*xinput[2],
						guideInfo.ellipseMinorAxis[0]*xinput[3],
						guideInfo.ellipseMinorAxis[0]*xinput[4],
						guideInfo.ellipseMinorAxis[2]*xinput[5],
						guideInfo.ellipseMinorAxis[2]*xinput[6],
						guideInfo.ellipseMinorAxis[0]*xinput[7] };
	double yarray[8] ={ guideInfo.ellipseMinorAxis[1]*yinput[0],
						guideInfo.ellipseMinorAxis[1]*yinput[1],
						guideInfo.ellipseMinorAxis[3]*yinput[2],
						guideInfo.ellipseMinorAxis[3]*yinput[3],
						guideInfo.ellipseMinorAxis[1]*yinput[4],
						guideInfo.ellipseMinorAxis[1]*yinput[5],
						guideInfo.ellipseMinorAxis[3]*yinput[6],
						guideInfo.ellipseMinorAxis[3]*yinput[7] };
	double zarray[8] ={ guideInfo.Length/2*zinput[0]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[1]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[2]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[3]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[4]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[5]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[6]+guideInfo.Length/2,
						guideInfo.Length/2*zinput[7]+guideInfo.Length/2 };
	int i = 0;
	for(i = 0; i < 8; i++){
		guideInfo.xArray[i] = xarray[i];
		guideInfo.yArray[i] = yarray[i];
		guideInfo.zArray[i] = zarray[i];
	}
	*/

	guideInfo.exitVerticalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[BottomSide]) 
					)/(guideInfo.ellipseMajorAxis[BottomSide] 
					*guideInfo.ellipseMajorAxis[BottomSide] )
		)*guideInfo.ellipseMinorAxis[BottomSide];

	guideInfo.exitHorizontalWidth =
		2*sqrt(1 - ( (guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide])
					*(guideInfo.Length-guideInfo.ellipseMajorOffset[RightSide]) 
					)/(guideInfo.ellipseMajorAxis[RightSide] 
					*guideInfo.ellipseMajorAxis[RightSide] ) 
		)*guideInfo.ellipseMinorAxis[RightSide];

    //////////////////segmentation of m values

	// Are the arrays empty?
	if(mvaluesright != NULL || mvaluesleft != NULL 
	|| mvaluestop != NULL || mvaluesbottom != NULL)
	{
		guideInfo.enableSegments = 1;

		guideInfo.numberOfSegments = sizeof(mvaluesright)/sizeof(mvaluesright[0]);

		//printf("Length is %i\n",guideInfo.numberOfSegments);
		guideInfo.mValuesright = mvaluesright;
		guideInfo.mValuesleft = mvaluesleft;
		guideInfo.mValuestop = mvaluestop;
		guideInfo.mValuesbottom = mvaluesbottom;
		//printf("Seglength ... %f %f %f\n",seglength[0],seglength[1],seglength[2]);

		// Are the arrays of equal length?
		if(seglength == NULL){
			dynamicalSegLength = 
					realloc(dynamicalSegLength,
							guideInfo.numberOfSegments*sizeof(double) );
			int i;
			for (i = 0; i < guideInfo.numberOfSegments; ++i){
				dynamicalSegLength[i] = 
						guideInfo.Length/guideInfo.numberOfSegments;
				}
			guideInfo.segLength = dynamicalSegLength;
		}
		else guideInfo.segLength = seglength;

		if( guideInfo.numberOfSegments != sizeof(mvaluesright)/sizeof(mvaluesright[0]) 
		 || guideInfo.numberOfSegments != sizeof(mvaluesleft)/sizeof(mvaluesleft[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluestop)/sizeof(mvaluestop[0])
		 || guideInfo.numberOfSegments != sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0])
		 || (guideInfo.segLength == NULL
		  & guideInfo.numberOfSegments != sizeof(seglength)/sizeof(guideInfo.segLength[0]) 
		  ) ) {
			
			printf("Error in userinput inside %s, the length of the arrays"
				   " mvalues and seglength are not equal\n",NAME_CURRENT_COMP);
			printf("The length of the arrays are: mValuesright is %lu,"
				   " mvaluesleft is %lu, mvaluestop is %lu, mvaluesbottom is"
				   " %lu and seglength is %lu and should be %d \n; Above assume that the arrays are using double \n",
					sizeof(mvaluesright)/sizeof(double),
					sizeof(mvaluesleft)/sizeof(double),
					sizeof(mvaluestop)/sizeof(double),
					sizeof(mvaluesbottom)/sizeof(double),
					sizeof(guideInfo.segLength)/sizeof(double),
					guideInfo.numberOfSegments	
					);
				
			if ( guideInfo.verboseSetting )	{
				int i;
				
				printf("The Values of mvaluesright is: [");
				for(i=0; i < sizeof(mvaluesright)/sizeof(mvaluesright[0]); i++) 	
						printf("%e,",guideInfo.mValuesright[i] );
				printf("]\n");
				
				printf("The Values of mvaluesleft is: [");
				for(i=0; i < sizeof(mvaluesleft)/sizeof(mvaluesleft[0]); i++) 	
						printf("%e,",guideInfo.mValuesleft[i] );
				printf("]\n");
				
				printf("The Values of mvaluestop is: [");
				for(i=0; i < sizeof(mvaluestop)/sizeof(mvaluestop[0]); i++) 	
						printf("%e,",guideInfo.mValuestop[i] );
				printf("]\n");

				printf("The Values of mvaluesbottom is: [");
				for(i=0; i < sizeof(mvaluesbottom)/sizeof(mvaluesbottom[0]); i++) 
						printf("%e,",guideInfo.mValuesbottom[i] );
				printf("]\n");

				printf("The Values of seglength is: [");
				for(i=0; i < sizeof(guideInfo.segLength)/sizeof(guideInfo.segLength[0]); i++) 
						printf("%e,",guideInfo.segLength[i]);
				printf("]\n");
			}
			exit( printf("Exit due to critical error in userinput for the"
						" component %s, consider having a look at the input"
						" for following: mvaluesright,mvaluesleft,mvaluestop,"
						"mvaluesbottom and/or seglength.",NAME_CURRENT_COMP) );
		}
		//
		double sumOfelements=0;
		int i;
		for(i=0;i< guideInfo.numberOfSegments; i++) {
			sumOfelements += guideInfo.segLength[i];
		}
		if ( guideInfo.verboseSetting 
		&& fabs(sumOfelements-guideInfo.Length) > 1e-9 )
			printf("Error in userinput inside %s, the difference between"
					" guidelength and elements of the seglength array is:"
					"%e consider changes the parameters l or seglength \n",
					NAME_CURRENT_COMP,sumOfelements-guideInfo.Length);
	}
	else guideInfo.enableSegments = 0;


///////////////////////////////////////////////////////////////////////////
/////////////// Calculate gravity vector in the guides coordinatesystem
///////////////////////////////////////////////////////////////////////////

/*
	Sets the local gravity vector equal to the global gravity vector (0,-g,0) 
	and when apply the same rotation matrix as applied to guide. 
*/ 
	if (enableGravity != 0){
		Gx0=0, Gy0=-GRAVITY*enableGravity, Gz0=0;
		Coords mcLocG;
		mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,Gy0,0));
		coords_get(mcLocG, &Gx0, &Gy0, &Gz0);
	}
	Circ=2*PI*curvature;
}
#line 38049 "./ESS_BIFROST_shielding.c"
#undef curvature
#undef enableGravity
#undef verbose
#undef mbottom
#undef alphabottom
#undef mtop
#undef alphatop
#undef mleft
#undef alphaleft
#undef mright
#undef alpharight
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef option
#undef dimensionsAt
#undef majorAxisoffsetyh
#undef majorAxisoffsetxw
#undef minorAxisyh
#undef majorAxisyh
#undef minorAxisxw
#undef majorAxisxw
#undef loutyh
#undef linyh
#undef loutxw
#undef linxw
#undef yheight
#undef xwidth
#undef l
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component EndOfelement_1. */
  SIG_MESSAGE("EndOfelement_1 (Init)");

  /* Initializations for component VirtualOutput. */
  SIG_MESSAGE("VirtualOutput (Init)");
#define mccompcurname  VirtualOutput
#define mccompcurtype  Virtual_output
#define mccompcurindex 60
#define DEFS mccVirtualOutput_DEFS
#define Vars mccVirtualOutput_Vars
#define filename mccVirtualOutput_filename
#define bufsize mccVirtualOutput_bufsize
#line 77 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../sources/Virtual_output.comp"
{

  long element_size=85; /* mean size per neutron for ascii storing */

  strcpy(Vars.compcurname, NAME_CURRENT_COMP);

  if (bufsize > 0) sprintf(Vars.option, "list=%g borders", bufsize);
  else strcpy(Vars.option, "list all borders");

  strcat(Vars.option,", x y z vx vy vz t sx sy sz");
  Monitor_nD_Init(&DEFS, &Vars, 0.1, 0.1, 0, 0,0,0,0,0,0,0); /* dims for mcdisplay */
  Vars.compcurpos = POS_A_CURRENT_COMP;

  if (filename && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
    strncpy(Vars.Mon_File, filename, 128);

  if (bufsize > 0)
    printf("Warning: Virtual_output: %s: buffer size=%g not recommended\n", NAME_CURRENT_COMP, bufsize);
  if (bufsize > 0) printf(
           "Virtual_output: %s: Beware virtual output generated file size (max %g Mo)\n"
           "WARNING         Memory required is %g Mo\n", NAME_CURRENT_COMP,
           bufsize*element_size/1e6, bufsize*sizeof(double)/1e6);
}
#line 38136 "./ESS_BIFROST_shielding.c"
#undef bufsize
#undef filename
#undef Vars
#undef DEFS
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component DiwJaw0. */
  SIG_MESSAGE("DiwJaw0 (Init)");
#define mccompcurname  DiwJaw0
#define mccompcurtype  Slit
#define mccompcurindex 61
#define xmin mccDiwJaw0_xmin
#define xmax mccDiwJaw0_xmax
#define ymin mccDiwJaw0_ymin
#define ymax mccDiwJaw0_ymax
#define radius mccDiwJaw0_radius
#define xwidth mccDiwJaw0_xwidth
#define yheight mccDiwJaw0_yheight
#line 50 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Slit.comp"
{
if (xwidth > 0)  { 
  if (!xmin && !xmax) {
    xmax=xwidth/2;  xmin=-xmax;
  } else {
    fprintf(stderr,"Slit: %s: Error: please specify EITHER xmin & xmax or xwidth\n", NAME_CURRENT_COMP); exit(-1);
  }
 }
 if (yheight > 0) { 
   if (!ymin && !ymax) {
     ymax=yheight/2; ymin=-ymax; 
   } else {
     fprintf(stderr,"Slit: %s: Error: please specify EITHER ymin & ymax or ywidth\n", NAME_CURRENT_COMP); exit(-1);
   }
 }
 if (xmin == 0 && xmax == 0 && ymin == 0 && ymax == 0 && radius == 0)
    { fprintf(stderr,"Slit: %s: Warning: Running with CLOSED slit - is this intentional?? \n", NAME_CURRENT_COMP); }

}
#line 38177 "./ESS_BIFROST_shielding.c"
#undef yheight
#undef xwidth
#undef radius
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component log_P_stop. */
  SIG_MESSAGE("log_P_stop (Init)");
#define mccompcurname  log_P_stop
#define mccompcurtype  Shielding_logger_stop
#define mccompcurindex 62
#define logger mcclog_P_stop_logger
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_logger_stop.comp"
{
#ifndef logger
  fprintf(stderr,"Error(%s): Logger undefined - can't stop noexisting logger\n", NAME_CURRENT_COMP);
#endif
logger_buffer_cleared=0;
}
#line 38202 "./ESS_BIFROST_shielding.c"
#undef logger
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component arm_iter_P1_start. */
  SIG_MESSAGE("arm_iter_P1_start (Init)");

  /* Initializations for component iter_P1_start. */
  SIG_MESSAGE("iter_P1_start (Init)");
#define mccompcurname  iter_P1_start
#define mccompcurtype  Shielding_log_iterator_Ni_new
#define mccompcurindex 64
#define compute_func mcciter_P1_start_compute_func
#define nstate_initial mcciter_P1_start_nstate_initial
#define s0 mcciter_P1_start_s0
#define s1 mcciter_P1_start_s1
#line 131 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_Ni_new.comp"
{
  if (compute_func) {
    pseudo_neutron_state_function_Ni=compute_func;
  }else{
    pseudo_neutron_state_function_Ni=exit_neutron_Ni;
  }
  nstate_initial=NULL;
    
  optics_not_hit=0;


}
#line 38233 "./ESS_BIFROST_shielding.c"
#undef s1
#undef s0
#undef nstate_initial
#undef compute_func
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component arm_iter_P1_dummy. */
  SIG_MESSAGE("arm_iter_P1_dummy (Init)");

  /* Initializations for component mndP01. */
  SIG_MESSAGE("mndP01 (Init)");
#define mccompcurname  mndP01
#define mccompcurtype  Monitor_nD
#define mccompcurindex 66
#define user1 mccmndP01_user1
#define user2 mccmndP01_user2
#define user3 mccmndP01_user3
#define DEFS mccmndP01_DEFS
#define Vars mccmndP01_Vars
#define detector mccmndP01_detector
#define offdata mccmndP01_offdata
#define xwidth mccmndP01_xwidth
#define yheight mccmndP01_yheight
#define zdepth mccmndP01_zdepth
#define xmin mccmndP01_xmin
#define xmax mccmndP01_xmax
#define ymin mccmndP01_ymin
#define ymax mccmndP01_ymax
#define zmin mccmndP01_zmin
#define zmax mccmndP01_zmax
#define bins mccmndP01_bins
#define min mccmndP01_min
#define max mccmndP01_max
#define restore_neutron mccmndP01_restore_neutron
#define radius mccmndP01_radius
#define options mccmndP01_options
#define filename mccmndP01_filename
#define geometry mccmndP01_geometry
#define username1 mccmndP01_username1
#define username2 mccmndP01_username2
#define username3 mccmndP01_username3
#define nowritefile mccmndP01_nowritefile
#line 232 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  char tmp[CHAR_BUF_LENGTH];
  strcpy(Vars.compcurname, NAME_CURRENT_COMP);
  if (options != NULL)
    strncpy(Vars.option, options, CHAR_BUF_LENGTH);
  else {
    strcpy(Vars.option, "x y");
    printf("Monitor_nD: %s has no option specified. Setting to PSD ('x y') monitor.\n", NAME_CURRENT_COMP);
  }
  Vars.compcurpos = POS_A_CURRENT_COMP;

  if (strstr(Vars.option, "source"))
    strcat(Vars.option, " list, x y z vx vy vz t sx sy sz ");

  if (bins) { sprintf(tmp, " all bins=%ld ", (long)bins); strcat(Vars.option, tmp); }
  if (min > -FLT_MAX && max < FLT_MAX) { sprintf(tmp, " all limits=[%g %g]", min, max); strcat(Vars.option, tmp); }
  else if (min > -FLT_MAX) { sprintf(tmp, " all min=%g", min); strcat(Vars.option, tmp); }
  else if (max <  FLT_MAX) { sprintf(tmp, " all max=%g", max); strcat(Vars.option, tmp); }

  strncpy(Vars.UserName1,
    username1 && strlen(username1) && strcmp(username1, "0") && strcmp(username1, "NULL") ?
    username1 : "", 128);
  strncpy(Vars.UserName2,
    username2 && strlen(username2) && strcmp(username2, "0") && strcmp(username2, "NULL") ?
    username2 : "", 128);
  strncpy(Vars.UserName3,
    username3 && strlen(username3) && strcmp(username3, "0") && strcmp(username3, "NULL") ?
    username3 : "", 128);
  if (radius) {
    xwidth = zdepth = 2*radius;
    if (yheight && !strstr(Vars.option, "cylinder") && !strstr(Vars.option, "banana") && !strstr(Vars.option, "sphere"))
      strcat(Vars.option, " banana");
    else if (!yheight && !strstr(Vars.option ,"sphere")) {
      strcat(Vars.option, " sphere");
      yheight=2*radius;
    }
  }
  int offflag=0;
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) {
    if (!off_init(  geometry, xwidth, yheight, zdepth, 1, &offdata )) {
      printf("Monitor_nD: %s could not initiate the OFF geometry %s. \n"
             "            Defaulting to normal Monitor dimensions.\n",
             NAME_CURRENT_COMP, geometry);
      strcpy(geometry, "");
    } else {
      offflag=1;
    }
  }

  if (!radius && !xwidth && !yheight && !zdepth && !xmin && !xmax && !ymin && !ymax &&
    !strstr(Vars.option, "previous") && (!geometry || !strlen(geometry)))
    exit(printf("Monitor_nD: %s has no dimension specified. Aborting (radius, xwidth, yheight, zdepth, previous, geometry).\n", NAME_CURRENT_COMP));

  Monitor_nD_Init(&DEFS, &Vars, xwidth, yheight, zdepth, xmin,xmax,ymin,ymax,zmin,zmax,offflag);

  if (Vars.Flag_OFF) {
    offdata.mantidflag=Vars.Flag_mantid;
    offdata.mantidoffset=Vars.Coord_Min[Vars.Coord_Number-1];
  }


  if (filename && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
    strncpy(Vars.Mon_File, filename, 128);

  /* check if user given filename with ext will be used more than once */
  if ( ((Vars.Flag_Multiple && Vars.Coord_Number > 1) || Vars.Flag_List) && strchr(Vars.Mon_File,'.') )
  { char *XY; XY = strrchr(Vars.Mon_File,'.'); *XY='_'; }

  if (restore_neutron) Vars.Flag_parallel=1;
  detector.m = 0;

#ifdef USE_MPI
MPI_MASTER(
  if (strstr(Vars.option, "auto") && mpi_node_count > 1)
    printf("Monitor_nD: %s is using automatic limits option 'auto' together with MPI.\n"
           "WARNING     this may create incorrect distributions (but integrated flux will be right).\n", NAME_CURRENT_COMP);
);
#endif
}
#line 38358 "./ESS_BIFROST_shielding.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component arm_iter_P1_stop. */
  SIG_MESSAGE("arm_iter_P1_stop (Init)");

  /* Initializations for component iter_P1_stop. */
  SIG_MESSAGE("iter_P1_stop (Init)");
#define mccompcurname  iter_P1_stop
#define mccompcurtype  Shielding_log_iterator_stop
#define mccompcurindex 68
#define iterator mcciter_P1_stop_iterator
#define loop mcciter_P1_stop_loop
#define last mcciter_P1_stop_last
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_stop.comp"
{
  loop=1;
}
#line 38406 "./ESS_BIFROST_shielding.c"
#undef last
#undef loop
#undef iterator
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component a11i. */
  SIG_MESSAGE("a11i (Init)");

  /* Initializations for component arm_iter_P2_start. */
  SIG_MESSAGE("arm_iter_P2_start (Init)");

  /* Initializations for component iter_P2_start. */
  SIG_MESSAGE("iter_P2_start (Init)");
#define mccompcurname  iter_P2_start
#define mccompcurtype  Shielding_log_iterator_Ti_new
#define mccompcurindex 71
#define compute_func mcciter_P2_start_compute_func
#define nstate_initial mcciter_P2_start_nstate_initial
#define s0 mcciter_P2_start_s0
#define s1 mcciter_P2_start_s1
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_Ti_new.comp"
{
  if (compute_func) {
    pseudo_neutron_state_function_Ti=compute_func;
  }else{
    pseudo_neutron_state_function_Ti=exit_neutron_Ti;
  }
  nstate_initial=NULL;
    
  optics_not_hit=0;


}
#line 38442 "./ESS_BIFROST_shielding.c"
#undef s1
#undef s0
#undef nstate_initial
#undef compute_func
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component arm_iter_P2_dummy. */
  SIG_MESSAGE("arm_iter_P2_dummy (Init)");

  /* Initializations for component mndP02. */
  SIG_MESSAGE("mndP02 (Init)");
#define mccompcurname  mndP02
#define mccompcurtype  Monitor_nD
#define mccompcurindex 73
#define user1 mccmndP02_user1
#define user2 mccmndP02_user2
#define user3 mccmndP02_user3
#define DEFS mccmndP02_DEFS
#define Vars mccmndP02_Vars
#define detector mccmndP02_detector
#define offdata mccmndP02_offdata
#define xwidth mccmndP02_xwidth
#define yheight mccmndP02_yheight
#define zdepth mccmndP02_zdepth
#define xmin mccmndP02_xmin
#define xmax mccmndP02_xmax
#define ymin mccmndP02_ymin
#define ymax mccmndP02_ymax
#define zmin mccmndP02_zmin
#define zmax mccmndP02_zmax
#define bins mccmndP02_bins
#define min mccmndP02_min
#define max mccmndP02_max
#define restore_neutron mccmndP02_restore_neutron
#define radius mccmndP02_radius
#define options mccmndP02_options
#define filename mccmndP02_filename
#define geometry mccmndP02_geometry
#define username1 mccmndP02_username1
#define username2 mccmndP02_username2
#define username3 mccmndP02_username3
#define nowritefile mccmndP02_nowritefile
#line 232 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  char tmp[CHAR_BUF_LENGTH];
  strcpy(Vars.compcurname, NAME_CURRENT_COMP);
  if (options != NULL)
    strncpy(Vars.option, options, CHAR_BUF_LENGTH);
  else {
    strcpy(Vars.option, "x y");
    printf("Monitor_nD: %s has no option specified. Setting to PSD ('x y') monitor.\n", NAME_CURRENT_COMP);
  }
  Vars.compcurpos = POS_A_CURRENT_COMP;

  if (strstr(Vars.option, "source"))
    strcat(Vars.option, " list, x y z vx vy vz t sx sy sz ");

  if (bins) { sprintf(tmp, " all bins=%ld ", (long)bins); strcat(Vars.option, tmp); }
  if (min > -FLT_MAX && max < FLT_MAX) { sprintf(tmp, " all limits=[%g %g]", min, max); strcat(Vars.option, tmp); }
  else if (min > -FLT_MAX) { sprintf(tmp, " all min=%g", min); strcat(Vars.option, tmp); }
  else if (max <  FLT_MAX) { sprintf(tmp, " all max=%g", max); strcat(Vars.option, tmp); }

  strncpy(Vars.UserName1,
    username1 && strlen(username1) && strcmp(username1, "0") && strcmp(username1, "NULL") ?
    username1 : "", 128);
  strncpy(Vars.UserName2,
    username2 && strlen(username2) && strcmp(username2, "0") && strcmp(username2, "NULL") ?
    username2 : "", 128);
  strncpy(Vars.UserName3,
    username3 && strlen(username3) && strcmp(username3, "0") && strcmp(username3, "NULL") ?
    username3 : "", 128);
  if (radius) {
    xwidth = zdepth = 2*radius;
    if (yheight && !strstr(Vars.option, "cylinder") && !strstr(Vars.option, "banana") && !strstr(Vars.option, "sphere"))
      strcat(Vars.option, " banana");
    else if (!yheight && !strstr(Vars.option ,"sphere")) {
      strcat(Vars.option, " sphere");
      yheight=2*radius;
    }
  }
  int offflag=0;
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) {
    if (!off_init(  geometry, xwidth, yheight, zdepth, 1, &offdata )) {
      printf("Monitor_nD: %s could not initiate the OFF geometry %s. \n"
             "            Defaulting to normal Monitor dimensions.\n",
             NAME_CURRENT_COMP, geometry);
      strcpy(geometry, "");
    } else {
      offflag=1;
    }
  }

  if (!radius && !xwidth && !yheight && !zdepth && !xmin && !xmax && !ymin && !ymax &&
    !strstr(Vars.option, "previous") && (!geometry || !strlen(geometry)))
    exit(printf("Monitor_nD: %s has no dimension specified. Aborting (radius, xwidth, yheight, zdepth, previous, geometry).\n", NAME_CURRENT_COMP));

  Monitor_nD_Init(&DEFS, &Vars, xwidth, yheight, zdepth, xmin,xmax,ymin,ymax,zmin,zmax,offflag);

  if (Vars.Flag_OFF) {
    offdata.mantidflag=Vars.Flag_mantid;
    offdata.mantidoffset=Vars.Coord_Min[Vars.Coord_Number-1];
  }


  if (filename && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
    strncpy(Vars.Mon_File, filename, 128);

  /* check if user given filename with ext will be used more than once */
  if ( ((Vars.Flag_Multiple && Vars.Coord_Number > 1) || Vars.Flag_List) && strchr(Vars.Mon_File,'.') )
  { char *XY; XY = strrchr(Vars.Mon_File,'.'); *XY='_'; }

  if (restore_neutron) Vars.Flag_parallel=1;
  detector.m = 0;

#ifdef USE_MPI
MPI_MASTER(
  if (strstr(Vars.option, "auto") && mpi_node_count > 1)
    printf("Monitor_nD: %s is using automatic limits option 'auto' together with MPI.\n"
           "WARNING     this may create incorrect distributions (but integrated flux will be right).\n", NAME_CURRENT_COMP);
);
#endif
}
#line 38567 "./ESS_BIFROST_shielding.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component arm_iter_P2_stop. */
  SIG_MESSAGE("arm_iter_P2_stop (Init)");

  /* Initializations for component iter_P2_stop. */
  SIG_MESSAGE("iter_P2_stop (Init)");
#define mccompcurname  iter_P2_stop
#define mccompcurtype  Shielding_log_iterator_stop
#define mccompcurindex 75
#define iterator mcciter_P2_stop_iterator
#define loop mcciter_P2_stop_loop
#define last mcciter_P2_stop_last
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_stop.comp"
{
  loop=1;
}
#line 38615 "./ESS_BIFROST_shielding.c"
#undef last
#undef loop
#undef iterator
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component a12i. */
  SIG_MESSAGE("a12i (Init)");

  /* Initializations for component arm_iter_P3_start. */
  SIG_MESSAGE("arm_iter_P3_start (Init)");

  /* Initializations for component iter_P3_start. */
  SIG_MESSAGE("iter_P3_start (Init)");
#define mccompcurname  iter_P3_start
#define mccompcurtype  Shielding_log_iterator_total
#define mccompcurindex 78
#define compute_func mcciter_P3_start_compute_func
#define nstate_initial mcciter_P3_start_nstate_initial
#define s0 mcciter_P3_start_s0
#define s1 mcciter_P3_start_s1
#line 87 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_total.comp"
{
  if (compute_func) {
    pseudo_neutron_state_function=compute_func;
  }else{
    pseudo_neutron_state_function=exit_neutron;
  }
  nstate_initial=NULL;
    
  optics_not_hit=0;


}
#line 38651 "./ESS_BIFROST_shielding.c"
#undef s1
#undef s0
#undef nstate_initial
#undef compute_func
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component arm_iter_P3_dummy. */
  SIG_MESSAGE("arm_iter_P3_dummy (Init)");

  /* Initializations for component mndP03. */
  SIG_MESSAGE("mndP03 (Init)");
#define mccompcurname  mndP03
#define mccompcurtype  Monitor_nD
#define mccompcurindex 80
#define user1 mccmndP03_user1
#define user2 mccmndP03_user2
#define user3 mccmndP03_user3
#define DEFS mccmndP03_DEFS
#define Vars mccmndP03_Vars
#define detector mccmndP03_detector
#define offdata mccmndP03_offdata
#define xwidth mccmndP03_xwidth
#define yheight mccmndP03_yheight
#define zdepth mccmndP03_zdepth
#define xmin mccmndP03_xmin
#define xmax mccmndP03_xmax
#define ymin mccmndP03_ymin
#define ymax mccmndP03_ymax
#define zmin mccmndP03_zmin
#define zmax mccmndP03_zmax
#define bins mccmndP03_bins
#define min mccmndP03_min
#define max mccmndP03_max
#define restore_neutron mccmndP03_restore_neutron
#define radius mccmndP03_radius
#define options mccmndP03_options
#define filename mccmndP03_filename
#define geometry mccmndP03_geometry
#define username1 mccmndP03_username1
#define username2 mccmndP03_username2
#define username3 mccmndP03_username3
#define nowritefile mccmndP03_nowritefile
#line 232 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  char tmp[CHAR_BUF_LENGTH];
  strcpy(Vars.compcurname, NAME_CURRENT_COMP);
  if (options != NULL)
    strncpy(Vars.option, options, CHAR_BUF_LENGTH);
  else {
    strcpy(Vars.option, "x y");
    printf("Monitor_nD: %s has no option specified. Setting to PSD ('x y') monitor.\n", NAME_CURRENT_COMP);
  }
  Vars.compcurpos = POS_A_CURRENT_COMP;

  if (strstr(Vars.option, "source"))
    strcat(Vars.option, " list, x y z vx vy vz t sx sy sz ");

  if (bins) { sprintf(tmp, " all bins=%ld ", (long)bins); strcat(Vars.option, tmp); }
  if (min > -FLT_MAX && max < FLT_MAX) { sprintf(tmp, " all limits=[%g %g]", min, max); strcat(Vars.option, tmp); }
  else if (min > -FLT_MAX) { sprintf(tmp, " all min=%g", min); strcat(Vars.option, tmp); }
  else if (max <  FLT_MAX) { sprintf(tmp, " all max=%g", max); strcat(Vars.option, tmp); }

  strncpy(Vars.UserName1,
    username1 && strlen(username1) && strcmp(username1, "0") && strcmp(username1, "NULL") ?
    username1 : "", 128);
  strncpy(Vars.UserName2,
    username2 && strlen(username2) && strcmp(username2, "0") && strcmp(username2, "NULL") ?
    username2 : "", 128);
  strncpy(Vars.UserName3,
    username3 && strlen(username3) && strcmp(username3, "0") && strcmp(username3, "NULL") ?
    username3 : "", 128);
  if (radius) {
    xwidth = zdepth = 2*radius;
    if (yheight && !strstr(Vars.option, "cylinder") && !strstr(Vars.option, "banana") && !strstr(Vars.option, "sphere"))
      strcat(Vars.option, " banana");
    else if (!yheight && !strstr(Vars.option ,"sphere")) {
      strcat(Vars.option, " sphere");
      yheight=2*radius;
    }
  }
  int offflag=0;
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) {
    if (!off_init(  geometry, xwidth, yheight, zdepth, 1, &offdata )) {
      printf("Monitor_nD: %s could not initiate the OFF geometry %s. \n"
             "            Defaulting to normal Monitor dimensions.\n",
             NAME_CURRENT_COMP, geometry);
      strcpy(geometry, "");
    } else {
      offflag=1;
    }
  }

  if (!radius && !xwidth && !yheight && !zdepth && !xmin && !xmax && !ymin && !ymax &&
    !strstr(Vars.option, "previous") && (!geometry || !strlen(geometry)))
    exit(printf("Monitor_nD: %s has no dimension specified. Aborting (radius, xwidth, yheight, zdepth, previous, geometry).\n", NAME_CURRENT_COMP));

  Monitor_nD_Init(&DEFS, &Vars, xwidth, yheight, zdepth, xmin,xmax,ymin,ymax,zmin,zmax,offflag);

  if (Vars.Flag_OFF) {
    offdata.mantidflag=Vars.Flag_mantid;
    offdata.mantidoffset=Vars.Coord_Min[Vars.Coord_Number-1];
  }


  if (filename && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
    strncpy(Vars.Mon_File, filename, 128);

  /* check if user given filename with ext will be used more than once */
  if ( ((Vars.Flag_Multiple && Vars.Coord_Number > 1) || Vars.Flag_List) && strchr(Vars.Mon_File,'.') )
  { char *XY; XY = strrchr(Vars.Mon_File,'.'); *XY='_'; }

  if (restore_neutron) Vars.Flag_parallel=1;
  detector.m = 0;

#ifdef USE_MPI
MPI_MASTER(
  if (strstr(Vars.option, "auto") && mpi_node_count > 1)
    printf("Monitor_nD: %s is using automatic limits option 'auto' together with MPI.\n"
           "WARNING     this may create incorrect distributions (but integrated flux will be right).\n", NAME_CURRENT_COMP);
);
#endif
}
#line 38776 "./ESS_BIFROST_shielding.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component arm_iter_P3_stop. */
  SIG_MESSAGE("arm_iter_P3_stop (Init)");

  /* Initializations for component iter_P3_stop. */
  SIG_MESSAGE("iter_P3_stop (Init)");
#define mccompcurname  iter_P3_stop
#define mccompcurtype  Shielding_log_iterator_stop
#define mccompcurindex 82
#define iterator mcciter_P3_stop_iterator
#define loop mcciter_P3_stop_loop
#define last mcciter_P3_stop_last
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_stop.comp"
{
  loop=1;
}
#line 38824 "./ESS_BIFROST_shielding.c"
#undef last
#undef loop
#undef iterator
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component a13i. */
  SIG_MESSAGE("a13i (Init)");

  /* Initializations for component Beamstop. */
  SIG_MESSAGE("Beamstop (Init)");
#define mccompcurname  Beamstop
#define mccompcurtype  Beamstop
#define mccompcurindex 84
#define xmin mccBeamstop_xmin
#define xmax mccBeamstop_xmax
#define ymin mccBeamstop_ymin
#define ymax mccBeamstop_ymax
#define xwidth mccBeamstop_xwidth
#define yheight mccBeamstop_yheight
#define radius mccBeamstop_radius
#line 50 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Beamstop.comp"
{
if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
  if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

  if (xmin == 0 && xmax == 0 && ymin == 0 & ymax == 0 && radius == 0)
  { fprintf(stderr,"Beamstop: %s: Error: give geometry\n", NAME_CURRENT_COMP); exit(-1); }
}
#line 38855 "./ESS_BIFROST_shielding.c"
#undef radius
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Lmon_guide_end. */
  SIG_MESSAGE("Lmon_guide_end (Init)");
#define mccompcurname  Lmon_guide_end
#define mccompcurtype  L_monitor
#define mccompcurindex 85
#define nL mccLmon_guide_end_nL
#define L_N mccLmon_guide_end_L_N
#define L_p mccLmon_guide_end_L_p
#define L_p2 mccLmon_guide_end_L_p2
#define filename mccLmon_guide_end_filename
#define xmin mccLmon_guide_end_xmin
#define xmax mccLmon_guide_end_xmax
#define ymin mccLmon_guide_end_ymin
#define ymax mccLmon_guide_end_ymax
#define xwidth mccLmon_guide_end_xwidth
#define yheight mccLmon_guide_end_yheight
#define Lmin mccLmon_guide_end_Lmin
#define Lmax mccLmon_guide_end_Lmax
#define restore_neutron mccLmon_guide_end_restore_neutron
#define nowritefile mccLmon_guide_end_nowritefile
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 38908 "./ESS_BIFROST_shielding.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component SCalc. */
  SIG_MESSAGE("SCalc (Init)");

  /* Initializations for component DoseFe. */
  SIG_MESSAGE("DoseFe (Init)");

  /* Initializations for component DoseConc. */
  SIG_MESSAGE("DoseConc (Init)");

  /* Initializations for component DoseStandard. */
  SIG_MESSAGE("DoseStandard (Init)");

  /* Initializations for component Dose5. */
  SIG_MESSAGE("Dose5 (Init)");

    if(mcdotrace) mcdisplay();
    mcDEBUG_INSTR_END()
  }

} /* end init */

void mcraytrace(void) {
  /* Neutronics-specific defines */
#ifdef NEUTRONICS
extern double mcnx, mcny, mcnz, mcnvx, mcnvy, mcnvz;
extern double mcnt, mcnsx, mcnsy, mcnsz, mcnp;
#endif
  /* End of Neutronics-specific defines */
  /* Copy neutron state to local variables. */
  MCNUM mcnlx = mcnx;
  MCNUM mcnly = mcny;
  MCNUM mcnlz = mcnz;
  MCNUM mcnlvx = mcnvx;
  MCNUM mcnlvy = mcnvy;
  MCNUM mcnlvz = mcnvz;
  MCNUM mcnlt = mcnt;
  MCNUM mcnlsx = mcnsx;
  MCNUM mcnlsy = mcnsy;
  MCNUM mcnlsz = mcnsz;
  MCNUM mcnlp = mcnp;

  mcDEBUG_ENTER()
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define mcabsorb mcabsorbAll
  /* TRACE Component Origin [1] */
  mccoordschange(mcposrOrigin, mcrotrOrigin,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Origin (without coords transformations) */
  mcJumpTrace_Origin:
  SIG_MESSAGE("Origin (Trace)");
  mcDEBUG_COMP("Origin")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompOrigin
  STORE_NEUTRON(1,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[1]++;
  mcPCounter[1] += p;
  mcP2Counter[1] += p*p;
#define mccompcurname  Origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccOrigin_IntermediateCnts
#define StartTime mccOrigin_StartTime
#define EndTime mccOrigin_EndTime
#define CurrentTime mccOrigin_CurrentTime
{   /* Declarations of Origin=Progress_bar() SETTING parameters. */
char* profile = mccOrigin_profile;
MCNUM percent = mccOrigin_percent;
MCNUM flag_save = mccOrigin_flag_save;
MCNUM minutes = mccOrigin_minutes;
#line 70 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../misc/Progress_bar.comp"
{
  double ncount;
  ncount = mcget_run_num();
  if (!StartTime) {
    time(&StartTime); /* compute starting time */
    IntermediateCnts = 1e3;
  }
  time_t NowTime;
  time(&NowTime);
  /* compute initial estimate of computation duration */
  if (!EndTime && ncount >= IntermediateCnts) {
    CurrentTime = NowTime;
    if (difftime(NowTime,StartTime) > 10 && ncount) { /* wait 10 sec before writing ETA */
      EndTime = StartTime + (time_t)(difftime(NowTime,StartTime)
				     *(double)mcget_ncount()/ncount);
      IntermediateCnts = 0;
      fprintf(stdout, "\nTrace ETA ");
      if (difftime(EndTime,StartTime) < 60.0)
        fprintf(stdout, "%g [s] %% ", difftime(EndTime,StartTime));
      else if (difftime(EndTime,StartTime) > 3600.0)
        fprintf(stdout, "%g [h] %% ", difftime(EndTime,StartTime)/3600.0);
      else
        fprintf(stdout, "%g [min] %% ", difftime(EndTime,StartTime)/60.0);
    } else IntermediateCnts += 1e3;
    fflush(stdout);
  }

  /* display percentage when percent or minutes have reached step */
  if (EndTime && mcget_ncount() &&
    (    (minutes && difftime(NowTime,CurrentTime) > minutes*60)
      || (percent && !minutes && ncount >= IntermediateCnts))   )
  {
    fprintf(stdout, "%d ", (int)(ncount*100.0/mcget_ncount())); fflush(stdout);
    CurrentTime = NowTime;

    IntermediateCnts = ncount + percent*mcget_ncount()/100;
    /* check that next intermediate ncount check is a multiple of the desired percentage */
    IntermediateCnts = floor(IntermediateCnts*100/percent/mcget_ncount())*percent*mcget_ncount()/100;
    /* raise flag to indicate that we did something */
    SCATTER;
    if (flag_save) mcsave(NULL);
  }
}
#line 39096 "./ESS_BIFROST_shielding.c"
}   /* End of Origin=Progress_bar() SETTING parameter declarations. */
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompOrigin:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(1,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ESS_source [2] */
  mccoordschange(mcposrESS_source, mcrotrESS_source,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ESS_source (without coords transformations) */
  mcJumpTrace_ESS_source:
  SIG_MESSAGE("ESS_source (Trace)");
  mcDEBUG_COMP("ESS_source")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompESS_source
  STORE_NEUTRON(2,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[2]++;
  mcPCounter[2] += p;
  mcP2Counter[2] += p*p;
#define mccompcurname  ESS_source
#define mccompcurtype  ESS_butterfly
#define mccompcurindex 2
#define cx mccESS_source_cx
#define cz mccESS_source_cz
#define sign_bl_angle mccESS_source_sign_bl_angle
#define orientation_angle mccESS_source_orientation_angle
#define jmax mccESS_source_jmax
#define C1_x mccESS_source_C1_x
#define C1_z mccESS_source_C1_z
#define C2_x mccESS_source_C2_x
#define C2_z mccESS_source_C2_z
#define C3_x mccESS_source_C3_x
#define C3_z mccESS_source_C3_z
#define T1_x mccESS_source_T1_x
#define T1_z mccESS_source_T1_z
#define T2_x mccESS_source_T2_x
#define T2_z mccESS_source_T2_z
#define T3_x mccESS_source_T3_x
#define T3_z mccESS_source_T3_z
#define rC1_x mccESS_source_rC1_x
#define rC1_z mccESS_source_rC1_z
#define rC2_x mccESS_source_rC2_x
#define rC2_z mccESS_source_rC2_z
#define rC3_x mccESS_source_rC3_x
#define rC3_z mccESS_source_rC3_z
#define rT1_x mccESS_source_rT1_x
#define rT1_z mccESS_source_rT1_z
#define rT2_x mccESS_source_rT2_x
#define rT2_z mccESS_source_rT2_z
#define rT3_x mccESS_source_rT3_x
#define rT3_z mccESS_source_rT3_z
#define tx mccESS_source_tx
#define ty mccESS_source_ty
#define tz mccESS_source_tz
#define r11 mccESS_source_r11
#define r12 mccESS_source_r12
#define r21 mccESS_source_r21
#define r22 mccESS_source_r22
#define xf mccESS_source_xf
#define yf mccESS_source_yf
#define zf mccESS_source_zf
#define w_mult mccESS_source_w_mult
#define w_stat mccESS_source_w_stat
#define w_geom mccESS_source_w_geom
#define w_focus mccESS_source_w_focus
#define w_tfocus mccESS_source_w_tfocus
#define w_geom_c mccESS_source_w_geom_c
#define w_geom_t mccESS_source_w_geom_t
#define tx mccESS_source_tx
#define ty mccESS_source_ty
#define tz mccESS_source_tz
#define dt mccESS_source_dt
#define lambda mccESS_source_lambda
#define l_range mccESS_source_l_range
#define k mccESS_source_k
#define v mccESS_source_v
#define r mccESS_source_r
#define dx mccESS_source_dx
#define dy mccESS_source_dy
#define dz mccESS_source_dz
#define internal_angle mccESS_source_internal_angle
#define x0 mccESS_source_x0
#define z0 mccESS_source_z0
#define cos_beamport_angle mccESS_source_cos_beamport_angle
#define sin_beamport_angle mccESS_source_sin_beamport_angle
#define cos_thermal mccESS_source_cos_thermal
#define cos_cold mccESS_source_cos_cold
#define Lmin_sampled mccESS_source_Lmin_sampled
#define Lmax_sampled mccESS_source_Lmax_sampled
{   /* Declarations of ESS_source=ESS_butterfly() SETTING parameters. */
char* sector = mccESS_source_sector;
int beamline = mccESS_source_beamline;
MCNUM yheight = mccESS_source_yheight;
MCNUM cold_frac = mccESS_source_cold_frac;
int target_index = mccESS_source_target_index;
MCNUM dist = mccESS_source_dist;
MCNUM focus_xw = mccESS_source_focus_xw;
MCNUM focus_yh = mccESS_source_focus_yh;
MCNUM c_performance = mccESS_source_c_performance;
MCNUM t_performance = mccESS_source_t_performance;
MCNUM Lmin = mccESS_source_Lmin;
MCNUM Lmax = mccESS_source_Lmax;
MCNUM tmax_multiplier = mccESS_source_tmax_multiplier;
int n_pulses = mccESS_source_n_pulses;
MCNUM acc_power = mccESS_source_acc_power;
MCNUM tfocus_dist = mccESS_source_tfocus_dist;
MCNUM tfocus_time = mccESS_source_tfocus_time;
MCNUM tfocus_width = mccESS_source_tfocus_width;
#line 434 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../sources/ESS_butterfly.comp"
{
  
  /* Cold or thermal event? */
  p=1;
  xtmp = rand01();
  y = randpm1()*delta_y;
  modextras.Y=y;
  if (rand01() < cold_frac) {
    iscold=1;
    if (rand01() < wfrac_cold) { // "Broad face" 
      x = rC1_x + (rC2_x - rC1_x)*xtmp;
      z = rC1_z + (rC2_z - rC1_z)*xtmp;
      x0 = C1_x + (C2_x - C1_x)*xtmp;
      z0 = C1_z + (C2_z - C1_z)*xtmp;
      surf_sign=-1;
      cos_factor=cos_cold;
    } else {
      x = rC1_x + (rC3_x - rC1_x)*xtmp;
      z = rC1_z + (rC3_z - rC1_z)*xtmp;
      x0 = C1_x + (C3_x - C1_x)*xtmp;
      z0 = C1_z + (C3_z - C1_z)*xtmp;    
      surf_sign=1;
      cos_factor=cos_thermal;
    }
    modextras.X=((-1.0*isleft*x0)-dxCold[beamline-1]);
    w_geom=w_geom_c;
  } else {
    iscold=0;
    if (rand01() < wfrac_thermal) { // "Broad face" 
      x = rT1_x + (rT2_x - rT1_x)*xtmp;
      z = rT1_z + (rT2_z - rT1_z)*xtmp;
      x0 = T1_x + (T2_x - T1_x)*xtmp;
      z0 = T1_z + (T2_z - T1_z)*xtmp;
      surf_sign=1;
      cos_factor=cos_thermal;
    } else {
      x = rT1_x + (rT3_x - rT1_x)*xtmp;
      z = rT1_z + (rT3_z - rT1_z)*xtmp;
      x0 = T1_x + (T3_x - T1_x)*xtmp;
      z0 = T1_z + (T3_z - T1_z)*xtmp;
      surf_sign=-1;
      cos_factor=cos_thermal;
    }
    modextras.X=((-1.0*isleft*x0)+dxThermal[beamline-1]);
    w_geom=w_geom_t;
  }

  SCATTER;
  /* Where are we going? */
  randvec_target_rect_real(&xf, &yf, &zf, NULL,
			   tx, ty, tz, focus_xw, focus_yh, ROT_A_CURRENT_COMP, x, y, z, 0);
  w_focus=focus_xw*focus_yh/(tx*tx+ty*ty+tz*tz);
  
  dx = xf-x;
  dy = yf-y;
  dz = zf-z;
  r = sqrt(dx*dx+dy*dy+dz*dz);
  
  lambda = Lmin+l_range*rand01();    /* Choose from uniform distribution */

  k = 2*PI/lambda;
  v = K2V*k;

  vz = v*dz/r;
  vy = v*dy/r;
  vx = v*dx/r;

  /* Are we using time focusing? */
  if (tfocus_width>0) {
    double dt = tfocus_dist/vz;
    t = tfocus_time-dt; /* Set time to hit time window center */
    t += randpm1()*tfocus_width/2.0; 
    if (t<0) ABSORB;                       /* Kill neutron if outside pulse duration */
    if (t>modextras.tmultiplier*ESS_SOURCE_DURATION) ABSORB;
    w_tfocus=tfocus_width/(modextras.tmultiplier*ESS_SOURCE_DURATION);
  } else {
    /* Simple, random wavelength @ random time */
    t = rand01()*modextras.tmultiplier*ESS_SOURCE_DURATION;
    w_tfocus=1;
  }
  
  if (iscold) {          //case: cold moderator
    /* Apply simple engineering reality correction */
    cold_bril( &t,  &p,  lambda,  tfocus_width,  tfocus_time,  dt, modextras);
    p *= c_performance;
    p *= ColdScalars[beamline-1];
  }  else  {                      //case: thermal moderator
    thermal_bril( &t,  &p,  lambda,  tfocus_width,  tfocus_time,  dt, modextras);
    p *= t_performance;
    p *= ThermalScalars[beamline-1];
  }
  
  p*=w_stat*w_focus*w_geom*w_mult*w_tfocus;
  t+=(double)floor((n_pulses)*rand01())/ESS_SOURCE_FREQUENCY;   /* Select a random pulse */
  p*=cos_factor;

  /* Correct weight for sampling of cold vs. thermal events. */
  if (iscold) {
    p /= cold_frac;
  } else {
    p /= (1-cold_frac);
  }
  SCATTER;
}
#line 39396 "./ESS_BIFROST_shielding.c"
}   /* End of ESS_source=ESS_butterfly() SETTING parameter declarations. */
#undef Lmax_sampled
#undef Lmin_sampled
#undef cos_cold
#undef cos_thermal
#undef sin_beamport_angle
#undef cos_beamport_angle
#undef z0
#undef x0
#undef internal_angle
#undef dz
#undef dy
#undef dx
#undef r
#undef v
#undef k
#undef l_range
#undef lambda
#undef dt
#undef tz
#undef ty
#undef tx
#undef w_geom_t
#undef w_geom_c
#undef w_tfocus
#undef w_focus
#undef w_geom
#undef w_stat
#undef w_mult
#undef zf
#undef yf
#undef xf
#undef r22
#undef r21
#undef r12
#undef r11
#undef tz
#undef ty
#undef tx
#undef rT3_z
#undef rT3_x
#undef rT2_z
#undef rT2_x
#undef rT1_z
#undef rT1_x
#undef rC3_z
#undef rC3_x
#undef rC2_z
#undef rC2_x
#undef rC1_z
#undef rC1_x
#undef T3_z
#undef T3_x
#undef T2_z
#undef T2_x
#undef T1_z
#undef T1_x
#undef C3_z
#undef C3_x
#undef C2_z
#undef C2_x
#undef C1_z
#undef C1_x
#undef jmax
#undef orientation_angle
#undef sign_bl_angle
#undef cz
#undef cx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompESS_source:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(2,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component StartOfGuide [3] */
  mccoordschange(mcposrStartOfGuide, mcrotrStartOfGuide,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component StartOfGuide (without coords transformations) */
  mcJumpTrace_StartOfGuide:
  SIG_MESSAGE("StartOfGuide (Trace)");
  mcDEBUG_COMP("StartOfGuide")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompStartOfGuide
  STORE_NEUTRON(3,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[3]++;
  mcPCounter[3] += p;
  mcP2Counter[3] += p*p;
#define mccompcurname  StartOfGuide
#define mccompcurtype  Arm
#define mccompcurindex 3
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompStartOfGuide:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(3,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component NBOA [4] */
  mccoordschange(mcposrNBOA, mcrotrNBOA,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component NBOA (without coords transformations) */
  mcJumpTrace_NBOA:
  SIG_MESSAGE("NBOA (Trace)");
  mcDEBUG_COMP("NBOA")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompNBOA
  STORE_NEUTRON(4,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[4]++;
  mcPCounter[4] += p;
  mcP2Counter[4] += p*p;
#define mccompcurname  NBOA
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 4
#define mvaluesright mccNBOA_mvaluesright
#define mvaluesleft mccNBOA_mvaluesleft
#define mvaluestop mccNBOA_mvaluestop
#define mvaluesbottom mccNBOA_mvaluesbottom
#define seglength mccNBOA_seglength
#define guideInfo mccNBOA_guideInfo
#define latestParticleCollision mccNBOA_latestParticleCollision
#define Gx mccNBOA_Gx
#define Gy mccNBOA_Gy
#define Gz mccNBOA_Gz
#define Gx0 mccNBOA_Gx0
#define Gy0 mccNBOA_Gy0
#define Gz0 mccNBOA_Gz0
#define Circ mccNBOA_Circ
#define dynamicalSegLength mccNBOA_dynamicalSegLength
{   /* Declarations of NBOA=Elliptic_guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM l = mccNBOA_l;
MCNUM xwidth = mccNBOA_xwidth;
MCNUM yheight = mccNBOA_yheight;
MCNUM linxw = mccNBOA_linxw;
MCNUM loutxw = mccNBOA_loutxw;
MCNUM linyh = mccNBOA_linyh;
MCNUM loutyh = mccNBOA_loutyh;
MCNUM majorAxisxw = mccNBOA_majorAxisxw;
MCNUM minorAxisxw = mccNBOA_minorAxisxw;
MCNUM majorAxisyh = mccNBOA_majorAxisyh;
MCNUM minorAxisyh = mccNBOA_minorAxisyh;
MCNUM majorAxisoffsetxw = mccNBOA_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccNBOA_majorAxisoffsetyh;
char* dimensionsAt = mccNBOA_dimensionsAt;
char* option = mccNBOA_option;
MCNUM R0 = mccNBOA_R0;
MCNUM Qc = mccNBOA_Qc;
MCNUM alpha = mccNBOA_alpha;
MCNUM m = mccNBOA_m;
MCNUM W = mccNBOA_W;
MCNUM alpharight = mccNBOA_alpharight;
MCNUM mright = mccNBOA_mright;
MCNUM alphaleft = mccNBOA_alphaleft;
MCNUM mleft = mccNBOA_mleft;
MCNUM alphatop = mccNBOA_alphatop;
MCNUM mtop = mccNBOA_mtop;
MCNUM alphabottom = mccNBOA_alphabottom;
MCNUM mbottom = mccNBOA_mbottom;
char* verbose = mccNBOA_verbose;
MCNUM enableGravity = mccNBOA_enableGravity;
MCNUM curvature = mccNBOA_curvature;
#line 1432 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
{
  PROP_Z0;
  m_local_refl=-1; // RK - added. Comment: neutron entered the guide and hasn't reached the coating yet.
  SCATTER;
  
  double Gloc;
  if (curvature) {
    Gloc=(vx*vx+vy*vy+vz*vz)/curvature;
  } else {
    Gloc=0;
  }
  

	if( !guideInfo.EnclosingBoxOn )
		if( fabs(x) > guideInfo.entranceHorizontalWidth/2.0 
		    || fabs(y) > guideInfo.entranceVerticalWidth/2.0 ) 	{ m_local_refl=-1; // RK - added. 
	// RK - Comment: neutron doesn't make it to the guide opening, doesn't reach coating, setting m_local_refl=-1
		  ABSORB;}


	int bounces = 0;
	for(bounces = 0; bounces <= 1000; bounces++){
	//RK - Comment: now have entered the guide, will assign m_local_refl a value of the coating at the place of the hit.
	  Gx=Gx0; Gy=Gy0; Gz=Gz0;
	  if (curvature) {
	    // Add velocity-dependent, location-dependent approximation to centripetal force for curvature...
	    Gx=Gx0+Gloc*cos(2*PI*z/Circ);Gz=Gz0+Gloc*sin(2*PI*z/Circ);
	  }

		// Find the next intersection between the guide and the neutron.
		int boolean = guide_elliptical_handleGuideIntersection(
							x,y,z,vx,vy,vz,Gx,Gy,Gz,
							&guideInfo,&latestParticleCollision);

		double timeToCollision = 
				latestParticleCollision.delta_time_to_next_collision;

		// Handle special cases.
		//RK -- Comment: this happens when neutron hits precisely the corner of the guide. Assume no coating there
		if(boolean == 0) { m_local_refl=-1; ABSORB;} //if(boolean == 0) ABSORB; // RK -- modified line
		//RK -- Comment: this happens when neutron is travelling parallel to the wall. Assume absorption in the upper coating layer which amounts to setting m=1
		if(timeToCollision < 1e-15) { m_local_refl = 1; ABSORB;}  //if(timeToCollision < 1e-15) ABSORB; // RK -- modified line

		// If the neutron reach the end of the guide, when move 
		// the neutron to the end of guide and leave this component.
		if( z+vz*timeToCollision+0.5*Gz*timeToCollision*timeToCollision 
			>= guideInfo.Length )
		{
			double timeToExit = 0;
			solve_2nd_order(
					&timeToExit,NULL,
					-0.5*Gz,-vz,guideInfo.Length-z-1e-9);
			PROP_GRAV_DT(timeToExit,Gx,Gy,Gz);
			m_local_refl=-1; // RK - added. Comment: exiting guide, no scattering on the coating
			SCATTER;
			break;
		}

		// Move the neutron and handle the reflection.
		PROP_GRAV_DT(timeToCollision,Gx,Gy,Gz);
/*** RK now we are at the point of reflection, have to figure out what the m-value is here. ***/
  if(!guideInfo.enableSegments){
			m_local_refl=guideInfo.mArr[latestParticleCollision.side];
		   }
	else{
    	int currentSegment;
    	double combinedLength = 0;
    	int i;
    	for(i=0; i < guideInfo.numberOfSegments; i++){
    		combinedLength = combinedLength + guideInfo.segLength[i];
    		if(z < combinedLength)	{
    			currentSegment = i; break;
    		}
    	}

		if(latestParticleCollision.side == RightSide)
					m_local_refl = guideInfo.mValuesright[currentSegment];
		if(latestParticleCollision.side == LeftSide)
					m_local_refl=guideInfo.mValuesleft[currentSegment];
		if(latestParticleCollision.side == TopSide)
					m_local_refl = guideInfo.mValuestop[currentSegment];
		if(latestParticleCollision.side == BottomSide)
					m_local_refl = guideInfo.mValuesbottom[currentSegment];
    }
/*****/
		if(latestParticleCollision.collisionType == Absorb){ ABSORB; }
		if(latestParticleCollision.collisionType == Reflex){
			p *= guide_elliptical_handleReflection(x,y,z,&vx,&vy,&vz,
						&guideInfo,&latestParticleCollision); 
			SCATTER;
			if(p == 0) ABSORB; 
		}
	}
	// RK -- this happens when neutron didn't exit after 1000 bounces which is unrealistic situation. m_local_refl remains set to the m-value at last revlection.
	if( fabs(x) > guideInfo.exitHorizontalWidth/2 
	 || fabs(y) > guideInfo.exitVerticalWidth/2 )
		ABSORB;
	
}
#line 39818 "./ESS_BIFROST_shielding.c"
}   /* End of NBOA=Elliptic_guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompNBOA:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(4,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component EndOfelement_6 [5] */
  mccoordschange(mcposrEndOfelement_6, mcrotrEndOfelement_6,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component EndOfelement_6 (without coords transformations) */
  mcJumpTrace_EndOfelement_6:
  SIG_MESSAGE("EndOfelement_6 (Trace)");
  mcDEBUG_COMP("EndOfelement_6")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompEndOfelement_6
  STORE_NEUTRON(5,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[5]++;
  mcPCounter[5] += p;
  mcP2Counter[5] += p*p;
#define mccompcurname  EndOfelement_6
#define mccompcurtype  Arm
#define mccompcurindex 5
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompEndOfelement_6:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(5,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component EndOfelement_5 [6] */
  mccoordschange(mcposrEndOfelement_5, mcrotrEndOfelement_5,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component EndOfelement_5 (without coords transformations) */
  mcJumpTrace_EndOfelement_5:
  SIG_MESSAGE("EndOfelement_5 (Trace)");
  mcDEBUG_COMP("EndOfelement_5")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompEndOfelement_5
  STORE_NEUTRON(6,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[6]++;
  mcPCounter[6] += p;
  mcP2Counter[6] += p*p;
#define mccompcurname  EndOfelement_5
#define mccompcurtype  Arm
#define mccompcurindex 6
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompEndOfelement_5:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(6,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_1_0 [7] */
  mccoordschange(mcposrcurved_guide_1_0, mcrotrcurved_guide_1_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_1_0 (without coords transformations) */
  mcJumpTrace_curved_guide_1_0:
  SIG_MESSAGE("curved_guide_1_0 (Trace)");
  mcDEBUG_COMP("curved_guide_1_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_1_0
  STORE_NEUTRON(7,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[7]++;
  mcPCounter[7] += p;
  mcP2Counter[7] += p*p;
#define mccompcurname  curved_guide_1_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 7
#define GVars mcccurved_guide_1_0_GVars
#define pTable mcccurved_guide_1_0_pTable
{   /* Declarations of curved_guide_1_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_1_0_w1;
MCNUM h1 = mcccurved_guide_1_0_h1;
MCNUM w2 = mcccurved_guide_1_0_w2;
MCNUM h2 = mcccurved_guide_1_0_h2;
MCNUM l = mcccurved_guide_1_0_l;
MCNUM R0 = mcccurved_guide_1_0_R0;
MCNUM Qc = mcccurved_guide_1_0_Qc;
MCNUM alpha = mcccurved_guide_1_0_alpha;
MCNUM m = mcccurved_guide_1_0_m;
MCNUM W = mcccurved_guide_1_0_W;
MCNUM nslit = mcccurved_guide_1_0_nslit;
MCNUM d = mcccurved_guide_1_0_d;
MCNUM mleft = mcccurved_guide_1_0_mleft;
MCNUM mright = mcccurved_guide_1_0_mright;
MCNUM mtop = mcccurved_guide_1_0_mtop;
MCNUM mbottom = mcccurved_guide_1_0_mbottom;
MCNUM nhslit = mcccurved_guide_1_0_nhslit;
MCNUM G = mcccurved_guide_1_0_G;
MCNUM aleft = mcccurved_guide_1_0_aleft;
MCNUM aright = mcccurved_guide_1_0_aright;
MCNUM atop = mcccurved_guide_1_0_atop;
MCNUM abottom = mcccurved_guide_1_0_abottom;
MCNUM wavy = mcccurved_guide_1_0_wavy;
MCNUM wavy_z = mcccurved_guide_1_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_1_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_1_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_1_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_1_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_1_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_1_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_1_0_nelements;
MCNUM nu = mcccurved_guide_1_0_nu;
MCNUM phase = mcccurved_guide_1_0_phase;
char* reflect = mcccurved_guide_1_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 40371 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_1_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_1_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(7,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_2_0 [8] */
  mccoordschange(mcposrcurved_guide_2_0, mcrotrcurved_guide_2_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_2_0 (without coords transformations) */
  mcJumpTrace_curved_guide_2_0:
  SIG_MESSAGE("curved_guide_2_0 (Trace)");
  mcDEBUG_COMP("curved_guide_2_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_2_0
  STORE_NEUTRON(8,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[8]++;
  mcPCounter[8] += p;
  mcP2Counter[8] += p*p;
#define mccompcurname  curved_guide_2_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 8
#define GVars mcccurved_guide_2_0_GVars
#define pTable mcccurved_guide_2_0_pTable
{   /* Declarations of curved_guide_2_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_2_0_w1;
MCNUM h1 = mcccurved_guide_2_0_h1;
MCNUM w2 = mcccurved_guide_2_0_w2;
MCNUM h2 = mcccurved_guide_2_0_h2;
MCNUM l = mcccurved_guide_2_0_l;
MCNUM R0 = mcccurved_guide_2_0_R0;
MCNUM Qc = mcccurved_guide_2_0_Qc;
MCNUM alpha = mcccurved_guide_2_0_alpha;
MCNUM m = mcccurved_guide_2_0_m;
MCNUM W = mcccurved_guide_2_0_W;
MCNUM nslit = mcccurved_guide_2_0_nslit;
MCNUM d = mcccurved_guide_2_0_d;
MCNUM mleft = mcccurved_guide_2_0_mleft;
MCNUM mright = mcccurved_guide_2_0_mright;
MCNUM mtop = mcccurved_guide_2_0_mtop;
MCNUM mbottom = mcccurved_guide_2_0_mbottom;
MCNUM nhslit = mcccurved_guide_2_0_nhslit;
MCNUM G = mcccurved_guide_2_0_G;
MCNUM aleft = mcccurved_guide_2_0_aleft;
MCNUM aright = mcccurved_guide_2_0_aright;
MCNUM atop = mcccurved_guide_2_0_atop;
MCNUM abottom = mcccurved_guide_2_0_abottom;
MCNUM wavy = mcccurved_guide_2_0_wavy;
MCNUM wavy_z = mcccurved_guide_2_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_2_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_2_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_2_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_2_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_2_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_2_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_2_0_nelements;
MCNUM nu = mcccurved_guide_2_0_nu;
MCNUM phase = mcccurved_guide_2_0_phase;
char* reflect = mcccurved_guide_2_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 40705 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_2_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_2_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(8,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_3_0 [9] */
  mccoordschange(mcposrcurved_guide_3_0, mcrotrcurved_guide_3_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_3_0 (without coords transformations) */
  mcJumpTrace_curved_guide_3_0:
  SIG_MESSAGE("curved_guide_3_0 (Trace)");
  mcDEBUG_COMP("curved_guide_3_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_3_0
  STORE_NEUTRON(9,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[9]++;
  mcPCounter[9] += p;
  mcP2Counter[9] += p*p;
#define mccompcurname  curved_guide_3_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 9
#define GVars mcccurved_guide_3_0_GVars
#define pTable mcccurved_guide_3_0_pTable
{   /* Declarations of curved_guide_3_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_3_0_w1;
MCNUM h1 = mcccurved_guide_3_0_h1;
MCNUM w2 = mcccurved_guide_3_0_w2;
MCNUM h2 = mcccurved_guide_3_0_h2;
MCNUM l = mcccurved_guide_3_0_l;
MCNUM R0 = mcccurved_guide_3_0_R0;
MCNUM Qc = mcccurved_guide_3_0_Qc;
MCNUM alpha = mcccurved_guide_3_0_alpha;
MCNUM m = mcccurved_guide_3_0_m;
MCNUM W = mcccurved_guide_3_0_W;
MCNUM nslit = mcccurved_guide_3_0_nslit;
MCNUM d = mcccurved_guide_3_0_d;
MCNUM mleft = mcccurved_guide_3_0_mleft;
MCNUM mright = mcccurved_guide_3_0_mright;
MCNUM mtop = mcccurved_guide_3_0_mtop;
MCNUM mbottom = mcccurved_guide_3_0_mbottom;
MCNUM nhslit = mcccurved_guide_3_0_nhslit;
MCNUM G = mcccurved_guide_3_0_G;
MCNUM aleft = mcccurved_guide_3_0_aleft;
MCNUM aright = mcccurved_guide_3_0_aright;
MCNUM atop = mcccurved_guide_3_0_atop;
MCNUM abottom = mcccurved_guide_3_0_abottom;
MCNUM wavy = mcccurved_guide_3_0_wavy;
MCNUM wavy_z = mcccurved_guide_3_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_3_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_3_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_3_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_3_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_3_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_3_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_3_0_nelements;
MCNUM nu = mcccurved_guide_3_0_nu;
MCNUM phase = mcccurved_guide_3_0_phase;
char* reflect = mcccurved_guide_3_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 41039 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_3_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_3_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(9,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_4_0 [10] */
  mccoordschange(mcposrcurved_guide_4_0, mcrotrcurved_guide_4_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_4_0 (without coords transformations) */
  mcJumpTrace_curved_guide_4_0:
  SIG_MESSAGE("curved_guide_4_0 (Trace)");
  mcDEBUG_COMP("curved_guide_4_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_4_0
  STORE_NEUTRON(10,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[10]++;
  mcPCounter[10] += p;
  mcP2Counter[10] += p*p;
#define mccompcurname  curved_guide_4_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 10
#define GVars mcccurved_guide_4_0_GVars
#define pTable mcccurved_guide_4_0_pTable
{   /* Declarations of curved_guide_4_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_4_0_w1;
MCNUM h1 = mcccurved_guide_4_0_h1;
MCNUM w2 = mcccurved_guide_4_0_w2;
MCNUM h2 = mcccurved_guide_4_0_h2;
MCNUM l = mcccurved_guide_4_0_l;
MCNUM R0 = mcccurved_guide_4_0_R0;
MCNUM Qc = mcccurved_guide_4_0_Qc;
MCNUM alpha = mcccurved_guide_4_0_alpha;
MCNUM m = mcccurved_guide_4_0_m;
MCNUM W = mcccurved_guide_4_0_W;
MCNUM nslit = mcccurved_guide_4_0_nslit;
MCNUM d = mcccurved_guide_4_0_d;
MCNUM mleft = mcccurved_guide_4_0_mleft;
MCNUM mright = mcccurved_guide_4_0_mright;
MCNUM mtop = mcccurved_guide_4_0_mtop;
MCNUM mbottom = mcccurved_guide_4_0_mbottom;
MCNUM nhslit = mcccurved_guide_4_0_nhslit;
MCNUM G = mcccurved_guide_4_0_G;
MCNUM aleft = mcccurved_guide_4_0_aleft;
MCNUM aright = mcccurved_guide_4_0_aright;
MCNUM atop = mcccurved_guide_4_0_atop;
MCNUM abottom = mcccurved_guide_4_0_abottom;
MCNUM wavy = mcccurved_guide_4_0_wavy;
MCNUM wavy_z = mcccurved_guide_4_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_4_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_4_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_4_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_4_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_4_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_4_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_4_0_nelements;
MCNUM nu = mcccurved_guide_4_0_nu;
MCNUM phase = mcccurved_guide_4_0_phase;
char* reflect = mcccurved_guide_4_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 41373 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_4_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_4_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(10,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_5_beforeChopper [11] */
  mccoordschange(mcposrcurved_guide_5_beforeChopper, mcrotrcurved_guide_5_beforeChopper,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_5_beforeChopper (without coords transformations) */
  mcJumpTrace_curved_guide_5_beforeChopper:
  SIG_MESSAGE("curved_guide_5_beforeChopper (Trace)");
  mcDEBUG_COMP("curved_guide_5_beforeChopper")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_5_beforeChopper
  STORE_NEUTRON(11,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[11]++;
  mcPCounter[11] += p;
  mcP2Counter[11] += p*p;
#define mccompcurname  curved_guide_5_beforeChopper
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 11
#define GVars mcccurved_guide_5_beforeChopper_GVars
#define pTable mcccurved_guide_5_beforeChopper_pTable
{   /* Declarations of curved_guide_5_beforeChopper=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_5_beforeChopper_w1;
MCNUM h1 = mcccurved_guide_5_beforeChopper_h1;
MCNUM w2 = mcccurved_guide_5_beforeChopper_w2;
MCNUM h2 = mcccurved_guide_5_beforeChopper_h2;
MCNUM l = mcccurved_guide_5_beforeChopper_l;
MCNUM R0 = mcccurved_guide_5_beforeChopper_R0;
MCNUM Qc = mcccurved_guide_5_beforeChopper_Qc;
MCNUM alpha = mcccurved_guide_5_beforeChopper_alpha;
MCNUM m = mcccurved_guide_5_beforeChopper_m;
MCNUM W = mcccurved_guide_5_beforeChopper_W;
MCNUM nslit = mcccurved_guide_5_beforeChopper_nslit;
MCNUM d = mcccurved_guide_5_beforeChopper_d;
MCNUM mleft = mcccurved_guide_5_beforeChopper_mleft;
MCNUM mright = mcccurved_guide_5_beforeChopper_mright;
MCNUM mtop = mcccurved_guide_5_beforeChopper_mtop;
MCNUM mbottom = mcccurved_guide_5_beforeChopper_mbottom;
MCNUM nhslit = mcccurved_guide_5_beforeChopper_nhslit;
MCNUM G = mcccurved_guide_5_beforeChopper_G;
MCNUM aleft = mcccurved_guide_5_beforeChopper_aleft;
MCNUM aright = mcccurved_guide_5_beforeChopper_aright;
MCNUM atop = mcccurved_guide_5_beforeChopper_atop;
MCNUM abottom = mcccurved_guide_5_beforeChopper_abottom;
MCNUM wavy = mcccurved_guide_5_beforeChopper_wavy;
MCNUM wavy_z = mcccurved_guide_5_beforeChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_5_beforeChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_5_beforeChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_5_beforeChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_5_beforeChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_5_beforeChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_5_beforeChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_5_beforeChopper_nelements;
MCNUM nu = mcccurved_guide_5_beforeChopper_nu;
MCNUM phase = mcccurved_guide_5_beforeChopper_phase;
char* reflect = mcccurved_guide_5_beforeChopper_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 41707 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_5_beforeChopper=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_5_beforeChopper:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(11,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_5_afterChopper [12] */
  mccoordschange(mcposrcurved_guide_5_afterChopper, mcrotrcurved_guide_5_afterChopper,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_5_afterChopper (without coords transformations) */
  mcJumpTrace_curved_guide_5_afterChopper:
  SIG_MESSAGE("curved_guide_5_afterChopper (Trace)");
  mcDEBUG_COMP("curved_guide_5_afterChopper")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_5_afterChopper
  STORE_NEUTRON(12,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[12]++;
  mcPCounter[12] += p;
  mcP2Counter[12] += p*p;
#define mccompcurname  curved_guide_5_afterChopper
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 12
#define GVars mcccurved_guide_5_afterChopper_GVars
#define pTable mcccurved_guide_5_afterChopper_pTable
{   /* Declarations of curved_guide_5_afterChopper=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_5_afterChopper_w1;
MCNUM h1 = mcccurved_guide_5_afterChopper_h1;
MCNUM w2 = mcccurved_guide_5_afterChopper_w2;
MCNUM h2 = mcccurved_guide_5_afterChopper_h2;
MCNUM l = mcccurved_guide_5_afterChopper_l;
MCNUM R0 = mcccurved_guide_5_afterChopper_R0;
MCNUM Qc = mcccurved_guide_5_afterChopper_Qc;
MCNUM alpha = mcccurved_guide_5_afterChopper_alpha;
MCNUM m = mcccurved_guide_5_afterChopper_m;
MCNUM W = mcccurved_guide_5_afterChopper_W;
MCNUM nslit = mcccurved_guide_5_afterChopper_nslit;
MCNUM d = mcccurved_guide_5_afterChopper_d;
MCNUM mleft = mcccurved_guide_5_afterChopper_mleft;
MCNUM mright = mcccurved_guide_5_afterChopper_mright;
MCNUM mtop = mcccurved_guide_5_afterChopper_mtop;
MCNUM mbottom = mcccurved_guide_5_afterChopper_mbottom;
MCNUM nhslit = mcccurved_guide_5_afterChopper_nhslit;
MCNUM G = mcccurved_guide_5_afterChopper_G;
MCNUM aleft = mcccurved_guide_5_afterChopper_aleft;
MCNUM aright = mcccurved_guide_5_afterChopper_aright;
MCNUM atop = mcccurved_guide_5_afterChopper_atop;
MCNUM abottom = mcccurved_guide_5_afterChopper_abottom;
MCNUM wavy = mcccurved_guide_5_afterChopper_wavy;
MCNUM wavy_z = mcccurved_guide_5_afterChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_5_afterChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_5_afterChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_5_afterChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_5_afterChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_5_afterChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_5_afterChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_5_afterChopper_nelements;
MCNUM nu = mcccurved_guide_5_afterChopper_nu;
MCNUM phase = mcccurved_guide_5_afterChopper_phase;
char* reflect = mcccurved_guide_5_afterChopper_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 42041 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_5_afterChopper=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_5_afterChopper:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(12,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_6_0 [13] */
  mccoordschange(mcposrcurved_guide_6_0, mcrotrcurved_guide_6_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_6_0 (without coords transformations) */
  mcJumpTrace_curved_guide_6_0:
  SIG_MESSAGE("curved_guide_6_0 (Trace)");
  mcDEBUG_COMP("curved_guide_6_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_6_0
  STORE_NEUTRON(13,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[13]++;
  mcPCounter[13] += p;
  mcP2Counter[13] += p*p;
#define mccompcurname  curved_guide_6_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 13
#define GVars mcccurved_guide_6_0_GVars
#define pTable mcccurved_guide_6_0_pTable
{   /* Declarations of curved_guide_6_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_6_0_w1;
MCNUM h1 = mcccurved_guide_6_0_h1;
MCNUM w2 = mcccurved_guide_6_0_w2;
MCNUM h2 = mcccurved_guide_6_0_h2;
MCNUM l = mcccurved_guide_6_0_l;
MCNUM R0 = mcccurved_guide_6_0_R0;
MCNUM Qc = mcccurved_guide_6_0_Qc;
MCNUM alpha = mcccurved_guide_6_0_alpha;
MCNUM m = mcccurved_guide_6_0_m;
MCNUM W = mcccurved_guide_6_0_W;
MCNUM nslit = mcccurved_guide_6_0_nslit;
MCNUM d = mcccurved_guide_6_0_d;
MCNUM mleft = mcccurved_guide_6_0_mleft;
MCNUM mright = mcccurved_guide_6_0_mright;
MCNUM mtop = mcccurved_guide_6_0_mtop;
MCNUM mbottom = mcccurved_guide_6_0_mbottom;
MCNUM nhslit = mcccurved_guide_6_0_nhslit;
MCNUM G = mcccurved_guide_6_0_G;
MCNUM aleft = mcccurved_guide_6_0_aleft;
MCNUM aright = mcccurved_guide_6_0_aright;
MCNUM atop = mcccurved_guide_6_0_atop;
MCNUM abottom = mcccurved_guide_6_0_abottom;
MCNUM wavy = mcccurved_guide_6_0_wavy;
MCNUM wavy_z = mcccurved_guide_6_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_6_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_6_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_6_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_6_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_6_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_6_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_6_0_nelements;
MCNUM nu = mcccurved_guide_6_0_nu;
MCNUM phase = mcccurved_guide_6_0_phase;
char* reflect = mcccurved_guide_6_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 42375 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_6_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_6_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(13,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_7_0 [14] */
  mccoordschange(mcposrcurved_guide_7_0, mcrotrcurved_guide_7_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_7_0 (without coords transformations) */
  mcJumpTrace_curved_guide_7_0:
  SIG_MESSAGE("curved_guide_7_0 (Trace)");
  mcDEBUG_COMP("curved_guide_7_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_7_0
  STORE_NEUTRON(14,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[14]++;
  mcPCounter[14] += p;
  mcP2Counter[14] += p*p;
#define mccompcurname  curved_guide_7_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 14
#define GVars mcccurved_guide_7_0_GVars
#define pTable mcccurved_guide_7_0_pTable
{   /* Declarations of curved_guide_7_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_7_0_w1;
MCNUM h1 = mcccurved_guide_7_0_h1;
MCNUM w2 = mcccurved_guide_7_0_w2;
MCNUM h2 = mcccurved_guide_7_0_h2;
MCNUM l = mcccurved_guide_7_0_l;
MCNUM R0 = mcccurved_guide_7_0_R0;
MCNUM Qc = mcccurved_guide_7_0_Qc;
MCNUM alpha = mcccurved_guide_7_0_alpha;
MCNUM m = mcccurved_guide_7_0_m;
MCNUM W = mcccurved_guide_7_0_W;
MCNUM nslit = mcccurved_guide_7_0_nslit;
MCNUM d = mcccurved_guide_7_0_d;
MCNUM mleft = mcccurved_guide_7_0_mleft;
MCNUM mright = mcccurved_guide_7_0_mright;
MCNUM mtop = mcccurved_guide_7_0_mtop;
MCNUM mbottom = mcccurved_guide_7_0_mbottom;
MCNUM nhslit = mcccurved_guide_7_0_nhslit;
MCNUM G = mcccurved_guide_7_0_G;
MCNUM aleft = mcccurved_guide_7_0_aleft;
MCNUM aright = mcccurved_guide_7_0_aright;
MCNUM atop = mcccurved_guide_7_0_atop;
MCNUM abottom = mcccurved_guide_7_0_abottom;
MCNUM wavy = mcccurved_guide_7_0_wavy;
MCNUM wavy_z = mcccurved_guide_7_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_7_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_7_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_7_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_7_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_7_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_7_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_7_0_nelements;
MCNUM nu = mcccurved_guide_7_0_nu;
MCNUM phase = mcccurved_guide_7_0_phase;
char* reflect = mcccurved_guide_7_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 42709 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_7_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_7_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(14,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_8_0 [15] */
  mccoordschange(mcposrcurved_guide_8_0, mcrotrcurved_guide_8_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_8_0 (without coords transformations) */
  mcJumpTrace_curved_guide_8_0:
  SIG_MESSAGE("curved_guide_8_0 (Trace)");
  mcDEBUG_COMP("curved_guide_8_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_8_0
  STORE_NEUTRON(15,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[15]++;
  mcPCounter[15] += p;
  mcP2Counter[15] += p*p;
#define mccompcurname  curved_guide_8_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 15
#define GVars mcccurved_guide_8_0_GVars
#define pTable mcccurved_guide_8_0_pTable
{   /* Declarations of curved_guide_8_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_8_0_w1;
MCNUM h1 = mcccurved_guide_8_0_h1;
MCNUM w2 = mcccurved_guide_8_0_w2;
MCNUM h2 = mcccurved_guide_8_0_h2;
MCNUM l = mcccurved_guide_8_0_l;
MCNUM R0 = mcccurved_guide_8_0_R0;
MCNUM Qc = mcccurved_guide_8_0_Qc;
MCNUM alpha = mcccurved_guide_8_0_alpha;
MCNUM m = mcccurved_guide_8_0_m;
MCNUM W = mcccurved_guide_8_0_W;
MCNUM nslit = mcccurved_guide_8_0_nslit;
MCNUM d = mcccurved_guide_8_0_d;
MCNUM mleft = mcccurved_guide_8_0_mleft;
MCNUM mright = mcccurved_guide_8_0_mright;
MCNUM mtop = mcccurved_guide_8_0_mtop;
MCNUM mbottom = mcccurved_guide_8_0_mbottom;
MCNUM nhslit = mcccurved_guide_8_0_nhslit;
MCNUM G = mcccurved_guide_8_0_G;
MCNUM aleft = mcccurved_guide_8_0_aleft;
MCNUM aright = mcccurved_guide_8_0_aright;
MCNUM atop = mcccurved_guide_8_0_atop;
MCNUM abottom = mcccurved_guide_8_0_abottom;
MCNUM wavy = mcccurved_guide_8_0_wavy;
MCNUM wavy_z = mcccurved_guide_8_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_8_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_8_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_8_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_8_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_8_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_8_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_8_0_nelements;
MCNUM nu = mcccurved_guide_8_0_nu;
MCNUM phase = mcccurved_guide_8_0_phase;
char* reflect = mcccurved_guide_8_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 43043 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_8_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_8_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(15,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_9_0 [16] */
  mccoordschange(mcposrcurved_guide_9_0, mcrotrcurved_guide_9_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_9_0 (without coords transformations) */
  mcJumpTrace_curved_guide_9_0:
  SIG_MESSAGE("curved_guide_9_0 (Trace)");
  mcDEBUG_COMP("curved_guide_9_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_9_0
  STORE_NEUTRON(16,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[16]++;
  mcPCounter[16] += p;
  mcP2Counter[16] += p*p;
#define mccompcurname  curved_guide_9_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 16
#define GVars mcccurved_guide_9_0_GVars
#define pTable mcccurved_guide_9_0_pTable
{   /* Declarations of curved_guide_9_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_9_0_w1;
MCNUM h1 = mcccurved_guide_9_0_h1;
MCNUM w2 = mcccurved_guide_9_0_w2;
MCNUM h2 = mcccurved_guide_9_0_h2;
MCNUM l = mcccurved_guide_9_0_l;
MCNUM R0 = mcccurved_guide_9_0_R0;
MCNUM Qc = mcccurved_guide_9_0_Qc;
MCNUM alpha = mcccurved_guide_9_0_alpha;
MCNUM m = mcccurved_guide_9_0_m;
MCNUM W = mcccurved_guide_9_0_W;
MCNUM nslit = mcccurved_guide_9_0_nslit;
MCNUM d = mcccurved_guide_9_0_d;
MCNUM mleft = mcccurved_guide_9_0_mleft;
MCNUM mright = mcccurved_guide_9_0_mright;
MCNUM mtop = mcccurved_guide_9_0_mtop;
MCNUM mbottom = mcccurved_guide_9_0_mbottom;
MCNUM nhslit = mcccurved_guide_9_0_nhslit;
MCNUM G = mcccurved_guide_9_0_G;
MCNUM aleft = mcccurved_guide_9_0_aleft;
MCNUM aright = mcccurved_guide_9_0_aright;
MCNUM atop = mcccurved_guide_9_0_atop;
MCNUM abottom = mcccurved_guide_9_0_abottom;
MCNUM wavy = mcccurved_guide_9_0_wavy;
MCNUM wavy_z = mcccurved_guide_9_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_9_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_9_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_9_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_9_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_9_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_9_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_9_0_nelements;
MCNUM nu = mcccurved_guide_9_0_nu;
MCNUM phase = mcccurved_guide_9_0_phase;
char* reflect = mcccurved_guide_9_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 43377 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_9_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_9_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(16,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_10_0 [17] */
  mccoordschange(mcposrcurved_guide_10_0, mcrotrcurved_guide_10_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_10_0 (without coords transformations) */
  mcJumpTrace_curved_guide_10_0:
  SIG_MESSAGE("curved_guide_10_0 (Trace)");
  mcDEBUG_COMP("curved_guide_10_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_10_0
  STORE_NEUTRON(17,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[17]++;
  mcPCounter[17] += p;
  mcP2Counter[17] += p*p;
#define mccompcurname  curved_guide_10_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 17
#define GVars mcccurved_guide_10_0_GVars
#define pTable mcccurved_guide_10_0_pTable
{   /* Declarations of curved_guide_10_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_10_0_w1;
MCNUM h1 = mcccurved_guide_10_0_h1;
MCNUM w2 = mcccurved_guide_10_0_w2;
MCNUM h2 = mcccurved_guide_10_0_h2;
MCNUM l = mcccurved_guide_10_0_l;
MCNUM R0 = mcccurved_guide_10_0_R0;
MCNUM Qc = mcccurved_guide_10_0_Qc;
MCNUM alpha = mcccurved_guide_10_0_alpha;
MCNUM m = mcccurved_guide_10_0_m;
MCNUM W = mcccurved_guide_10_0_W;
MCNUM nslit = mcccurved_guide_10_0_nslit;
MCNUM d = mcccurved_guide_10_0_d;
MCNUM mleft = mcccurved_guide_10_0_mleft;
MCNUM mright = mcccurved_guide_10_0_mright;
MCNUM mtop = mcccurved_guide_10_0_mtop;
MCNUM mbottom = mcccurved_guide_10_0_mbottom;
MCNUM nhslit = mcccurved_guide_10_0_nhslit;
MCNUM G = mcccurved_guide_10_0_G;
MCNUM aleft = mcccurved_guide_10_0_aleft;
MCNUM aright = mcccurved_guide_10_0_aright;
MCNUM atop = mcccurved_guide_10_0_atop;
MCNUM abottom = mcccurved_guide_10_0_abottom;
MCNUM wavy = mcccurved_guide_10_0_wavy;
MCNUM wavy_z = mcccurved_guide_10_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_10_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_10_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_10_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_10_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_10_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_10_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_10_0_nelements;
MCNUM nu = mcccurved_guide_10_0_nu;
MCNUM phase = mcccurved_guide_10_0_phase;
char* reflect = mcccurved_guide_10_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 43711 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_10_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_10_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(17,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_11_0 [18] */
  mccoordschange(mcposrcurved_guide_11_0, mcrotrcurved_guide_11_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_11_0 (without coords transformations) */
  mcJumpTrace_curved_guide_11_0:
  SIG_MESSAGE("curved_guide_11_0 (Trace)");
  mcDEBUG_COMP("curved_guide_11_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_11_0
  STORE_NEUTRON(18,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[18]++;
  mcPCounter[18] += p;
  mcP2Counter[18] += p*p;
#define mccompcurname  curved_guide_11_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 18
#define GVars mcccurved_guide_11_0_GVars
#define pTable mcccurved_guide_11_0_pTable
{   /* Declarations of curved_guide_11_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_11_0_w1;
MCNUM h1 = mcccurved_guide_11_0_h1;
MCNUM w2 = mcccurved_guide_11_0_w2;
MCNUM h2 = mcccurved_guide_11_0_h2;
MCNUM l = mcccurved_guide_11_0_l;
MCNUM R0 = mcccurved_guide_11_0_R0;
MCNUM Qc = mcccurved_guide_11_0_Qc;
MCNUM alpha = mcccurved_guide_11_0_alpha;
MCNUM m = mcccurved_guide_11_0_m;
MCNUM W = mcccurved_guide_11_0_W;
MCNUM nslit = mcccurved_guide_11_0_nslit;
MCNUM d = mcccurved_guide_11_0_d;
MCNUM mleft = mcccurved_guide_11_0_mleft;
MCNUM mright = mcccurved_guide_11_0_mright;
MCNUM mtop = mcccurved_guide_11_0_mtop;
MCNUM mbottom = mcccurved_guide_11_0_mbottom;
MCNUM nhslit = mcccurved_guide_11_0_nhslit;
MCNUM G = mcccurved_guide_11_0_G;
MCNUM aleft = mcccurved_guide_11_0_aleft;
MCNUM aright = mcccurved_guide_11_0_aright;
MCNUM atop = mcccurved_guide_11_0_atop;
MCNUM abottom = mcccurved_guide_11_0_abottom;
MCNUM wavy = mcccurved_guide_11_0_wavy;
MCNUM wavy_z = mcccurved_guide_11_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_11_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_11_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_11_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_11_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_11_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_11_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_11_0_nelements;
MCNUM nu = mcccurved_guide_11_0_nu;
MCNUM phase = mcccurved_guide_11_0_phase;
char* reflect = mcccurved_guide_11_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 44045 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_11_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_11_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(18,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_12_0 [19] */
  mccoordschange(mcposrcurved_guide_12_0, mcrotrcurved_guide_12_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_12_0 (without coords transformations) */
  mcJumpTrace_curved_guide_12_0:
  SIG_MESSAGE("curved_guide_12_0 (Trace)");
  mcDEBUG_COMP("curved_guide_12_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_12_0
  STORE_NEUTRON(19,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[19]++;
  mcPCounter[19] += p;
  mcP2Counter[19] += p*p;
#define mccompcurname  curved_guide_12_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 19
#define GVars mcccurved_guide_12_0_GVars
#define pTable mcccurved_guide_12_0_pTable
{   /* Declarations of curved_guide_12_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_12_0_w1;
MCNUM h1 = mcccurved_guide_12_0_h1;
MCNUM w2 = mcccurved_guide_12_0_w2;
MCNUM h2 = mcccurved_guide_12_0_h2;
MCNUM l = mcccurved_guide_12_0_l;
MCNUM R0 = mcccurved_guide_12_0_R0;
MCNUM Qc = mcccurved_guide_12_0_Qc;
MCNUM alpha = mcccurved_guide_12_0_alpha;
MCNUM m = mcccurved_guide_12_0_m;
MCNUM W = mcccurved_guide_12_0_W;
MCNUM nslit = mcccurved_guide_12_0_nslit;
MCNUM d = mcccurved_guide_12_0_d;
MCNUM mleft = mcccurved_guide_12_0_mleft;
MCNUM mright = mcccurved_guide_12_0_mright;
MCNUM mtop = mcccurved_guide_12_0_mtop;
MCNUM mbottom = mcccurved_guide_12_0_mbottom;
MCNUM nhslit = mcccurved_guide_12_0_nhslit;
MCNUM G = mcccurved_guide_12_0_G;
MCNUM aleft = mcccurved_guide_12_0_aleft;
MCNUM aright = mcccurved_guide_12_0_aright;
MCNUM atop = mcccurved_guide_12_0_atop;
MCNUM abottom = mcccurved_guide_12_0_abottom;
MCNUM wavy = mcccurved_guide_12_0_wavy;
MCNUM wavy_z = mcccurved_guide_12_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_12_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_12_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_12_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_12_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_12_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_12_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_12_0_nelements;
MCNUM nu = mcccurved_guide_12_0_nu;
MCNUM phase = mcccurved_guide_12_0_phase;
char* reflect = mcccurved_guide_12_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 44379 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_12_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_12_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(19,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_13_0 [20] */
  mccoordschange(mcposrcurved_guide_13_0, mcrotrcurved_guide_13_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_13_0 (without coords transformations) */
  mcJumpTrace_curved_guide_13_0:
  SIG_MESSAGE("curved_guide_13_0 (Trace)");
  mcDEBUG_COMP("curved_guide_13_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_13_0
  STORE_NEUTRON(20,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[20]++;
  mcPCounter[20] += p;
  mcP2Counter[20] += p*p;
#define mccompcurname  curved_guide_13_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 20
#define GVars mcccurved_guide_13_0_GVars
#define pTable mcccurved_guide_13_0_pTable
{   /* Declarations of curved_guide_13_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_13_0_w1;
MCNUM h1 = mcccurved_guide_13_0_h1;
MCNUM w2 = mcccurved_guide_13_0_w2;
MCNUM h2 = mcccurved_guide_13_0_h2;
MCNUM l = mcccurved_guide_13_0_l;
MCNUM R0 = mcccurved_guide_13_0_R0;
MCNUM Qc = mcccurved_guide_13_0_Qc;
MCNUM alpha = mcccurved_guide_13_0_alpha;
MCNUM m = mcccurved_guide_13_0_m;
MCNUM W = mcccurved_guide_13_0_W;
MCNUM nslit = mcccurved_guide_13_0_nslit;
MCNUM d = mcccurved_guide_13_0_d;
MCNUM mleft = mcccurved_guide_13_0_mleft;
MCNUM mright = mcccurved_guide_13_0_mright;
MCNUM mtop = mcccurved_guide_13_0_mtop;
MCNUM mbottom = mcccurved_guide_13_0_mbottom;
MCNUM nhslit = mcccurved_guide_13_0_nhslit;
MCNUM G = mcccurved_guide_13_0_G;
MCNUM aleft = mcccurved_guide_13_0_aleft;
MCNUM aright = mcccurved_guide_13_0_aright;
MCNUM atop = mcccurved_guide_13_0_atop;
MCNUM abottom = mcccurved_guide_13_0_abottom;
MCNUM wavy = mcccurved_guide_13_0_wavy;
MCNUM wavy_z = mcccurved_guide_13_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_13_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_13_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_13_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_13_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_13_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_13_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_13_0_nelements;
MCNUM nu = mcccurved_guide_13_0_nu;
MCNUM phase = mcccurved_guide_13_0_phase;
char* reflect = mcccurved_guide_13_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 44713 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_13_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_13_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(20,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_14_0 [21] */
  mccoordschange(mcposrcurved_guide_14_0, mcrotrcurved_guide_14_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_14_0 (without coords transformations) */
  mcJumpTrace_curved_guide_14_0:
  SIG_MESSAGE("curved_guide_14_0 (Trace)");
  mcDEBUG_COMP("curved_guide_14_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_14_0
  STORE_NEUTRON(21,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[21]++;
  mcPCounter[21] += p;
  mcP2Counter[21] += p*p;
#define mccompcurname  curved_guide_14_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 21
#define GVars mcccurved_guide_14_0_GVars
#define pTable mcccurved_guide_14_0_pTable
{   /* Declarations of curved_guide_14_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_14_0_w1;
MCNUM h1 = mcccurved_guide_14_0_h1;
MCNUM w2 = mcccurved_guide_14_0_w2;
MCNUM h2 = mcccurved_guide_14_0_h2;
MCNUM l = mcccurved_guide_14_0_l;
MCNUM R0 = mcccurved_guide_14_0_R0;
MCNUM Qc = mcccurved_guide_14_0_Qc;
MCNUM alpha = mcccurved_guide_14_0_alpha;
MCNUM m = mcccurved_guide_14_0_m;
MCNUM W = mcccurved_guide_14_0_W;
MCNUM nslit = mcccurved_guide_14_0_nslit;
MCNUM d = mcccurved_guide_14_0_d;
MCNUM mleft = mcccurved_guide_14_0_mleft;
MCNUM mright = mcccurved_guide_14_0_mright;
MCNUM mtop = mcccurved_guide_14_0_mtop;
MCNUM mbottom = mcccurved_guide_14_0_mbottom;
MCNUM nhslit = mcccurved_guide_14_0_nhslit;
MCNUM G = mcccurved_guide_14_0_G;
MCNUM aleft = mcccurved_guide_14_0_aleft;
MCNUM aright = mcccurved_guide_14_0_aright;
MCNUM atop = mcccurved_guide_14_0_atop;
MCNUM abottom = mcccurved_guide_14_0_abottom;
MCNUM wavy = mcccurved_guide_14_0_wavy;
MCNUM wavy_z = mcccurved_guide_14_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_14_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_14_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_14_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_14_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_14_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_14_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_14_0_nelements;
MCNUM nu = mcccurved_guide_14_0_nu;
MCNUM phase = mcccurved_guide_14_0_phase;
char* reflect = mcccurved_guide_14_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 45047 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_14_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_14_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(21,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_15_0 [22] */
  mccoordschange(mcposrcurved_guide_15_0, mcrotrcurved_guide_15_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_15_0 (without coords transformations) */
  mcJumpTrace_curved_guide_15_0:
  SIG_MESSAGE("curved_guide_15_0 (Trace)");
  mcDEBUG_COMP("curved_guide_15_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_15_0
  STORE_NEUTRON(22,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[22]++;
  mcPCounter[22] += p;
  mcP2Counter[22] += p*p;
#define mccompcurname  curved_guide_15_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 22
#define GVars mcccurved_guide_15_0_GVars
#define pTable mcccurved_guide_15_0_pTable
{   /* Declarations of curved_guide_15_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_15_0_w1;
MCNUM h1 = mcccurved_guide_15_0_h1;
MCNUM w2 = mcccurved_guide_15_0_w2;
MCNUM h2 = mcccurved_guide_15_0_h2;
MCNUM l = mcccurved_guide_15_0_l;
MCNUM R0 = mcccurved_guide_15_0_R0;
MCNUM Qc = mcccurved_guide_15_0_Qc;
MCNUM alpha = mcccurved_guide_15_0_alpha;
MCNUM m = mcccurved_guide_15_0_m;
MCNUM W = mcccurved_guide_15_0_W;
MCNUM nslit = mcccurved_guide_15_0_nslit;
MCNUM d = mcccurved_guide_15_0_d;
MCNUM mleft = mcccurved_guide_15_0_mleft;
MCNUM mright = mcccurved_guide_15_0_mright;
MCNUM mtop = mcccurved_guide_15_0_mtop;
MCNUM mbottom = mcccurved_guide_15_0_mbottom;
MCNUM nhslit = mcccurved_guide_15_0_nhslit;
MCNUM G = mcccurved_guide_15_0_G;
MCNUM aleft = mcccurved_guide_15_0_aleft;
MCNUM aright = mcccurved_guide_15_0_aright;
MCNUM atop = mcccurved_guide_15_0_atop;
MCNUM abottom = mcccurved_guide_15_0_abottom;
MCNUM wavy = mcccurved_guide_15_0_wavy;
MCNUM wavy_z = mcccurved_guide_15_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_15_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_15_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_15_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_15_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_15_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_15_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_15_0_nelements;
MCNUM nu = mcccurved_guide_15_0_nu;
MCNUM phase = mcccurved_guide_15_0_phase;
char* reflect = mcccurved_guide_15_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 45381 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_15_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_15_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(22,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_16_0 [23] */
  mccoordschange(mcposrcurved_guide_16_0, mcrotrcurved_guide_16_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_16_0 (without coords transformations) */
  mcJumpTrace_curved_guide_16_0:
  SIG_MESSAGE("curved_guide_16_0 (Trace)");
  mcDEBUG_COMP("curved_guide_16_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_16_0
  STORE_NEUTRON(23,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[23]++;
  mcPCounter[23] += p;
  mcP2Counter[23] += p*p;
#define mccompcurname  curved_guide_16_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 23
#define GVars mcccurved_guide_16_0_GVars
#define pTable mcccurved_guide_16_0_pTable
{   /* Declarations of curved_guide_16_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_16_0_w1;
MCNUM h1 = mcccurved_guide_16_0_h1;
MCNUM w2 = mcccurved_guide_16_0_w2;
MCNUM h2 = mcccurved_guide_16_0_h2;
MCNUM l = mcccurved_guide_16_0_l;
MCNUM R0 = mcccurved_guide_16_0_R0;
MCNUM Qc = mcccurved_guide_16_0_Qc;
MCNUM alpha = mcccurved_guide_16_0_alpha;
MCNUM m = mcccurved_guide_16_0_m;
MCNUM W = mcccurved_guide_16_0_W;
MCNUM nslit = mcccurved_guide_16_0_nslit;
MCNUM d = mcccurved_guide_16_0_d;
MCNUM mleft = mcccurved_guide_16_0_mleft;
MCNUM mright = mcccurved_guide_16_0_mright;
MCNUM mtop = mcccurved_guide_16_0_mtop;
MCNUM mbottom = mcccurved_guide_16_0_mbottom;
MCNUM nhslit = mcccurved_guide_16_0_nhslit;
MCNUM G = mcccurved_guide_16_0_G;
MCNUM aleft = mcccurved_guide_16_0_aleft;
MCNUM aright = mcccurved_guide_16_0_aright;
MCNUM atop = mcccurved_guide_16_0_atop;
MCNUM abottom = mcccurved_guide_16_0_abottom;
MCNUM wavy = mcccurved_guide_16_0_wavy;
MCNUM wavy_z = mcccurved_guide_16_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_16_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_16_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_16_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_16_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_16_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_16_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_16_0_nelements;
MCNUM nu = mcccurved_guide_16_0_nu;
MCNUM phase = mcccurved_guide_16_0_phase;
char* reflect = mcccurved_guide_16_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 45715 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_16_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_16_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(23,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_17_0 [24] */
  mccoordschange(mcposrcurved_guide_17_0, mcrotrcurved_guide_17_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_17_0 (without coords transformations) */
  mcJumpTrace_curved_guide_17_0:
  SIG_MESSAGE("curved_guide_17_0 (Trace)");
  mcDEBUG_COMP("curved_guide_17_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_17_0
  STORE_NEUTRON(24,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[24]++;
  mcPCounter[24] += p;
  mcP2Counter[24] += p*p;
#define mccompcurname  curved_guide_17_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 24
#define GVars mcccurved_guide_17_0_GVars
#define pTable mcccurved_guide_17_0_pTable
{   /* Declarations of curved_guide_17_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_17_0_w1;
MCNUM h1 = mcccurved_guide_17_0_h1;
MCNUM w2 = mcccurved_guide_17_0_w2;
MCNUM h2 = mcccurved_guide_17_0_h2;
MCNUM l = mcccurved_guide_17_0_l;
MCNUM R0 = mcccurved_guide_17_0_R0;
MCNUM Qc = mcccurved_guide_17_0_Qc;
MCNUM alpha = mcccurved_guide_17_0_alpha;
MCNUM m = mcccurved_guide_17_0_m;
MCNUM W = mcccurved_guide_17_0_W;
MCNUM nslit = mcccurved_guide_17_0_nslit;
MCNUM d = mcccurved_guide_17_0_d;
MCNUM mleft = mcccurved_guide_17_0_mleft;
MCNUM mright = mcccurved_guide_17_0_mright;
MCNUM mtop = mcccurved_guide_17_0_mtop;
MCNUM mbottom = mcccurved_guide_17_0_mbottom;
MCNUM nhslit = mcccurved_guide_17_0_nhslit;
MCNUM G = mcccurved_guide_17_0_G;
MCNUM aleft = mcccurved_guide_17_0_aleft;
MCNUM aright = mcccurved_guide_17_0_aright;
MCNUM atop = mcccurved_guide_17_0_atop;
MCNUM abottom = mcccurved_guide_17_0_abottom;
MCNUM wavy = mcccurved_guide_17_0_wavy;
MCNUM wavy_z = mcccurved_guide_17_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_17_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_17_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_17_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_17_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_17_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_17_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_17_0_nelements;
MCNUM nu = mcccurved_guide_17_0_nu;
MCNUM phase = mcccurved_guide_17_0_phase;
char* reflect = mcccurved_guide_17_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 46049 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_17_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_17_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(24,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_18_beforeChopper [25] */
  mccoordschange(mcposrcurved_guide_18_beforeChopper, mcrotrcurved_guide_18_beforeChopper,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_18_beforeChopper (without coords transformations) */
  mcJumpTrace_curved_guide_18_beforeChopper:
  SIG_MESSAGE("curved_guide_18_beforeChopper (Trace)");
  mcDEBUG_COMP("curved_guide_18_beforeChopper")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_18_beforeChopper
  STORE_NEUTRON(25,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[25]++;
  mcPCounter[25] += p;
  mcP2Counter[25] += p*p;
#define mccompcurname  curved_guide_18_beforeChopper
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 25
#define GVars mcccurved_guide_18_beforeChopper_GVars
#define pTable mcccurved_guide_18_beforeChopper_pTable
{   /* Declarations of curved_guide_18_beforeChopper=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_18_beforeChopper_w1;
MCNUM h1 = mcccurved_guide_18_beforeChopper_h1;
MCNUM w2 = mcccurved_guide_18_beforeChopper_w2;
MCNUM h2 = mcccurved_guide_18_beforeChopper_h2;
MCNUM l = mcccurved_guide_18_beforeChopper_l;
MCNUM R0 = mcccurved_guide_18_beforeChopper_R0;
MCNUM Qc = mcccurved_guide_18_beforeChopper_Qc;
MCNUM alpha = mcccurved_guide_18_beforeChopper_alpha;
MCNUM m = mcccurved_guide_18_beforeChopper_m;
MCNUM W = mcccurved_guide_18_beforeChopper_W;
MCNUM nslit = mcccurved_guide_18_beforeChopper_nslit;
MCNUM d = mcccurved_guide_18_beforeChopper_d;
MCNUM mleft = mcccurved_guide_18_beforeChopper_mleft;
MCNUM mright = mcccurved_guide_18_beforeChopper_mright;
MCNUM mtop = mcccurved_guide_18_beforeChopper_mtop;
MCNUM mbottom = mcccurved_guide_18_beforeChopper_mbottom;
MCNUM nhslit = mcccurved_guide_18_beforeChopper_nhslit;
MCNUM G = mcccurved_guide_18_beforeChopper_G;
MCNUM aleft = mcccurved_guide_18_beforeChopper_aleft;
MCNUM aright = mcccurved_guide_18_beforeChopper_aright;
MCNUM atop = mcccurved_guide_18_beforeChopper_atop;
MCNUM abottom = mcccurved_guide_18_beforeChopper_abottom;
MCNUM wavy = mcccurved_guide_18_beforeChopper_wavy;
MCNUM wavy_z = mcccurved_guide_18_beforeChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_18_beforeChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_18_beforeChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_18_beforeChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_18_beforeChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_18_beforeChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_18_beforeChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_18_beforeChopper_nelements;
MCNUM nu = mcccurved_guide_18_beforeChopper_nu;
MCNUM phase = mcccurved_guide_18_beforeChopper_phase;
char* reflect = mcccurved_guide_18_beforeChopper_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 46383 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_18_beforeChopper=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_18_beforeChopper:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(25,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_18_afterChopper [26] */
  mccoordschange(mcposrcurved_guide_18_afterChopper, mcrotrcurved_guide_18_afterChopper,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_18_afterChopper (without coords transformations) */
  mcJumpTrace_curved_guide_18_afterChopper:
  SIG_MESSAGE("curved_guide_18_afterChopper (Trace)");
  mcDEBUG_COMP("curved_guide_18_afterChopper")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_18_afterChopper
  STORE_NEUTRON(26,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[26]++;
  mcPCounter[26] += p;
  mcP2Counter[26] += p*p;
#define mccompcurname  curved_guide_18_afterChopper
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 26
#define GVars mcccurved_guide_18_afterChopper_GVars
#define pTable mcccurved_guide_18_afterChopper_pTable
{   /* Declarations of curved_guide_18_afterChopper=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_18_afterChopper_w1;
MCNUM h1 = mcccurved_guide_18_afterChopper_h1;
MCNUM w2 = mcccurved_guide_18_afterChopper_w2;
MCNUM h2 = mcccurved_guide_18_afterChopper_h2;
MCNUM l = mcccurved_guide_18_afterChopper_l;
MCNUM R0 = mcccurved_guide_18_afterChopper_R0;
MCNUM Qc = mcccurved_guide_18_afterChopper_Qc;
MCNUM alpha = mcccurved_guide_18_afterChopper_alpha;
MCNUM m = mcccurved_guide_18_afterChopper_m;
MCNUM W = mcccurved_guide_18_afterChopper_W;
MCNUM nslit = mcccurved_guide_18_afterChopper_nslit;
MCNUM d = mcccurved_guide_18_afterChopper_d;
MCNUM mleft = mcccurved_guide_18_afterChopper_mleft;
MCNUM mright = mcccurved_guide_18_afterChopper_mright;
MCNUM mtop = mcccurved_guide_18_afterChopper_mtop;
MCNUM mbottom = mcccurved_guide_18_afterChopper_mbottom;
MCNUM nhslit = mcccurved_guide_18_afterChopper_nhslit;
MCNUM G = mcccurved_guide_18_afterChopper_G;
MCNUM aleft = mcccurved_guide_18_afterChopper_aleft;
MCNUM aright = mcccurved_guide_18_afterChopper_aright;
MCNUM atop = mcccurved_guide_18_afterChopper_atop;
MCNUM abottom = mcccurved_guide_18_afterChopper_abottom;
MCNUM wavy = mcccurved_guide_18_afterChopper_wavy;
MCNUM wavy_z = mcccurved_guide_18_afterChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_18_afterChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_18_afterChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_18_afterChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_18_afterChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_18_afterChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_18_afterChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_18_afterChopper_nelements;
MCNUM nu = mcccurved_guide_18_afterChopper_nu;
MCNUM phase = mcccurved_guide_18_afterChopper_phase;
char* reflect = mcccurved_guide_18_afterChopper_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 46717 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_18_afterChopper=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_18_afterChopper:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(26,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_19_0 [27] */
  mccoordschange(mcposrcurved_guide_19_0, mcrotrcurved_guide_19_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_19_0 (without coords transformations) */
  mcJumpTrace_curved_guide_19_0:
  SIG_MESSAGE("curved_guide_19_0 (Trace)");
  mcDEBUG_COMP("curved_guide_19_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_19_0
  STORE_NEUTRON(27,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[27]++;
  mcPCounter[27] += p;
  mcP2Counter[27] += p*p;
#define mccompcurname  curved_guide_19_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 27
#define GVars mcccurved_guide_19_0_GVars
#define pTable mcccurved_guide_19_0_pTable
{   /* Declarations of curved_guide_19_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_19_0_w1;
MCNUM h1 = mcccurved_guide_19_0_h1;
MCNUM w2 = mcccurved_guide_19_0_w2;
MCNUM h2 = mcccurved_guide_19_0_h2;
MCNUM l = mcccurved_guide_19_0_l;
MCNUM R0 = mcccurved_guide_19_0_R0;
MCNUM Qc = mcccurved_guide_19_0_Qc;
MCNUM alpha = mcccurved_guide_19_0_alpha;
MCNUM m = mcccurved_guide_19_0_m;
MCNUM W = mcccurved_guide_19_0_W;
MCNUM nslit = mcccurved_guide_19_0_nslit;
MCNUM d = mcccurved_guide_19_0_d;
MCNUM mleft = mcccurved_guide_19_0_mleft;
MCNUM mright = mcccurved_guide_19_0_mright;
MCNUM mtop = mcccurved_guide_19_0_mtop;
MCNUM mbottom = mcccurved_guide_19_0_mbottom;
MCNUM nhslit = mcccurved_guide_19_0_nhslit;
MCNUM G = mcccurved_guide_19_0_G;
MCNUM aleft = mcccurved_guide_19_0_aleft;
MCNUM aright = mcccurved_guide_19_0_aright;
MCNUM atop = mcccurved_guide_19_0_atop;
MCNUM abottom = mcccurved_guide_19_0_abottom;
MCNUM wavy = mcccurved_guide_19_0_wavy;
MCNUM wavy_z = mcccurved_guide_19_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_19_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_19_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_19_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_19_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_19_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_19_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_19_0_nelements;
MCNUM nu = mcccurved_guide_19_0_nu;
MCNUM phase = mcccurved_guide_19_0_phase;
char* reflect = mcccurved_guide_19_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 47051 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_19_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_19_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(27,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_20_0 [28] */
  mccoordschange(mcposrcurved_guide_20_0, mcrotrcurved_guide_20_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_20_0 (without coords transformations) */
  mcJumpTrace_curved_guide_20_0:
  SIG_MESSAGE("curved_guide_20_0 (Trace)");
  mcDEBUG_COMP("curved_guide_20_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_20_0
  STORE_NEUTRON(28,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[28]++;
  mcPCounter[28] += p;
  mcP2Counter[28] += p*p;
#define mccompcurname  curved_guide_20_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 28
#define GVars mcccurved_guide_20_0_GVars
#define pTable mcccurved_guide_20_0_pTable
{   /* Declarations of curved_guide_20_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_20_0_w1;
MCNUM h1 = mcccurved_guide_20_0_h1;
MCNUM w2 = mcccurved_guide_20_0_w2;
MCNUM h2 = mcccurved_guide_20_0_h2;
MCNUM l = mcccurved_guide_20_0_l;
MCNUM R0 = mcccurved_guide_20_0_R0;
MCNUM Qc = mcccurved_guide_20_0_Qc;
MCNUM alpha = mcccurved_guide_20_0_alpha;
MCNUM m = mcccurved_guide_20_0_m;
MCNUM W = mcccurved_guide_20_0_W;
MCNUM nslit = mcccurved_guide_20_0_nslit;
MCNUM d = mcccurved_guide_20_0_d;
MCNUM mleft = mcccurved_guide_20_0_mleft;
MCNUM mright = mcccurved_guide_20_0_mright;
MCNUM mtop = mcccurved_guide_20_0_mtop;
MCNUM mbottom = mcccurved_guide_20_0_mbottom;
MCNUM nhslit = mcccurved_guide_20_0_nhslit;
MCNUM G = mcccurved_guide_20_0_G;
MCNUM aleft = mcccurved_guide_20_0_aleft;
MCNUM aright = mcccurved_guide_20_0_aright;
MCNUM atop = mcccurved_guide_20_0_atop;
MCNUM abottom = mcccurved_guide_20_0_abottom;
MCNUM wavy = mcccurved_guide_20_0_wavy;
MCNUM wavy_z = mcccurved_guide_20_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_20_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_20_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_20_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_20_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_20_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_20_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_20_0_nelements;
MCNUM nu = mcccurved_guide_20_0_nu;
MCNUM phase = mcccurved_guide_20_0_phase;
char* reflect = mcccurved_guide_20_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 47385 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_20_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_20_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(28,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_21_0 [29] */
  mccoordschange(mcposrcurved_guide_21_0, mcrotrcurved_guide_21_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_21_0 (without coords transformations) */
  mcJumpTrace_curved_guide_21_0:
  SIG_MESSAGE("curved_guide_21_0 (Trace)");
  mcDEBUG_COMP("curved_guide_21_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_21_0
  STORE_NEUTRON(29,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[29]++;
  mcPCounter[29] += p;
  mcP2Counter[29] += p*p;
#define mccompcurname  curved_guide_21_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 29
#define GVars mcccurved_guide_21_0_GVars
#define pTable mcccurved_guide_21_0_pTable
{   /* Declarations of curved_guide_21_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_21_0_w1;
MCNUM h1 = mcccurved_guide_21_0_h1;
MCNUM w2 = mcccurved_guide_21_0_w2;
MCNUM h2 = mcccurved_guide_21_0_h2;
MCNUM l = mcccurved_guide_21_0_l;
MCNUM R0 = mcccurved_guide_21_0_R0;
MCNUM Qc = mcccurved_guide_21_0_Qc;
MCNUM alpha = mcccurved_guide_21_0_alpha;
MCNUM m = mcccurved_guide_21_0_m;
MCNUM W = mcccurved_guide_21_0_W;
MCNUM nslit = mcccurved_guide_21_0_nslit;
MCNUM d = mcccurved_guide_21_0_d;
MCNUM mleft = mcccurved_guide_21_0_mleft;
MCNUM mright = mcccurved_guide_21_0_mright;
MCNUM mtop = mcccurved_guide_21_0_mtop;
MCNUM mbottom = mcccurved_guide_21_0_mbottom;
MCNUM nhslit = mcccurved_guide_21_0_nhslit;
MCNUM G = mcccurved_guide_21_0_G;
MCNUM aleft = mcccurved_guide_21_0_aleft;
MCNUM aright = mcccurved_guide_21_0_aright;
MCNUM atop = mcccurved_guide_21_0_atop;
MCNUM abottom = mcccurved_guide_21_0_abottom;
MCNUM wavy = mcccurved_guide_21_0_wavy;
MCNUM wavy_z = mcccurved_guide_21_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_21_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_21_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_21_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_21_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_21_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_21_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_21_0_nelements;
MCNUM nu = mcccurved_guide_21_0_nu;
MCNUM phase = mcccurved_guide_21_0_phase;
char* reflect = mcccurved_guide_21_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 47719 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_21_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_21_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(29,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_22_0 [30] */
  mccoordschange(mcposrcurved_guide_22_0, mcrotrcurved_guide_22_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_22_0 (without coords transformations) */
  mcJumpTrace_curved_guide_22_0:
  SIG_MESSAGE("curved_guide_22_0 (Trace)");
  mcDEBUG_COMP("curved_guide_22_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_22_0
  STORE_NEUTRON(30,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[30]++;
  mcPCounter[30] += p;
  mcP2Counter[30] += p*p;
#define mccompcurname  curved_guide_22_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 30
#define GVars mcccurved_guide_22_0_GVars
#define pTable mcccurved_guide_22_0_pTable
{   /* Declarations of curved_guide_22_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_22_0_w1;
MCNUM h1 = mcccurved_guide_22_0_h1;
MCNUM w2 = mcccurved_guide_22_0_w2;
MCNUM h2 = mcccurved_guide_22_0_h2;
MCNUM l = mcccurved_guide_22_0_l;
MCNUM R0 = mcccurved_guide_22_0_R0;
MCNUM Qc = mcccurved_guide_22_0_Qc;
MCNUM alpha = mcccurved_guide_22_0_alpha;
MCNUM m = mcccurved_guide_22_0_m;
MCNUM W = mcccurved_guide_22_0_W;
MCNUM nslit = mcccurved_guide_22_0_nslit;
MCNUM d = mcccurved_guide_22_0_d;
MCNUM mleft = mcccurved_guide_22_0_mleft;
MCNUM mright = mcccurved_guide_22_0_mright;
MCNUM mtop = mcccurved_guide_22_0_mtop;
MCNUM mbottom = mcccurved_guide_22_0_mbottom;
MCNUM nhslit = mcccurved_guide_22_0_nhslit;
MCNUM G = mcccurved_guide_22_0_G;
MCNUM aleft = mcccurved_guide_22_0_aleft;
MCNUM aright = mcccurved_guide_22_0_aright;
MCNUM atop = mcccurved_guide_22_0_atop;
MCNUM abottom = mcccurved_guide_22_0_abottom;
MCNUM wavy = mcccurved_guide_22_0_wavy;
MCNUM wavy_z = mcccurved_guide_22_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_22_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_22_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_22_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_22_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_22_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_22_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_22_0_nelements;
MCNUM nu = mcccurved_guide_22_0_nu;
MCNUM phase = mcccurved_guide_22_0_phase;
char* reflect = mcccurved_guide_22_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 48053 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_22_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_22_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(30,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_23_0 [31] */
  mccoordschange(mcposrcurved_guide_23_0, mcrotrcurved_guide_23_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_23_0 (without coords transformations) */
  mcJumpTrace_curved_guide_23_0:
  SIG_MESSAGE("curved_guide_23_0 (Trace)");
  mcDEBUG_COMP("curved_guide_23_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_23_0
  STORE_NEUTRON(31,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[31]++;
  mcPCounter[31] += p;
  mcP2Counter[31] += p*p;
#define mccompcurname  curved_guide_23_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 31
#define GVars mcccurved_guide_23_0_GVars
#define pTable mcccurved_guide_23_0_pTable
{   /* Declarations of curved_guide_23_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_23_0_w1;
MCNUM h1 = mcccurved_guide_23_0_h1;
MCNUM w2 = mcccurved_guide_23_0_w2;
MCNUM h2 = mcccurved_guide_23_0_h2;
MCNUM l = mcccurved_guide_23_0_l;
MCNUM R0 = mcccurved_guide_23_0_R0;
MCNUM Qc = mcccurved_guide_23_0_Qc;
MCNUM alpha = mcccurved_guide_23_0_alpha;
MCNUM m = mcccurved_guide_23_0_m;
MCNUM W = mcccurved_guide_23_0_W;
MCNUM nslit = mcccurved_guide_23_0_nslit;
MCNUM d = mcccurved_guide_23_0_d;
MCNUM mleft = mcccurved_guide_23_0_mleft;
MCNUM mright = mcccurved_guide_23_0_mright;
MCNUM mtop = mcccurved_guide_23_0_mtop;
MCNUM mbottom = mcccurved_guide_23_0_mbottom;
MCNUM nhslit = mcccurved_guide_23_0_nhslit;
MCNUM G = mcccurved_guide_23_0_G;
MCNUM aleft = mcccurved_guide_23_0_aleft;
MCNUM aright = mcccurved_guide_23_0_aright;
MCNUM atop = mcccurved_guide_23_0_atop;
MCNUM abottom = mcccurved_guide_23_0_abottom;
MCNUM wavy = mcccurved_guide_23_0_wavy;
MCNUM wavy_z = mcccurved_guide_23_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_23_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_23_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_23_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_23_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_23_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_23_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_23_0_nelements;
MCNUM nu = mcccurved_guide_23_0_nu;
MCNUM phase = mcccurved_guide_23_0_phase;
char* reflect = mcccurved_guide_23_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 48387 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_23_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_23_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(31,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_24_0 [32] */
  mccoordschange(mcposrcurved_guide_24_0, mcrotrcurved_guide_24_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_24_0 (without coords transformations) */
  mcJumpTrace_curved_guide_24_0:
  SIG_MESSAGE("curved_guide_24_0 (Trace)");
  mcDEBUG_COMP("curved_guide_24_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_24_0
  STORE_NEUTRON(32,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[32]++;
  mcPCounter[32] += p;
  mcP2Counter[32] += p*p;
#define mccompcurname  curved_guide_24_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 32
#define GVars mcccurved_guide_24_0_GVars
#define pTable mcccurved_guide_24_0_pTable
{   /* Declarations of curved_guide_24_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_24_0_w1;
MCNUM h1 = mcccurved_guide_24_0_h1;
MCNUM w2 = mcccurved_guide_24_0_w2;
MCNUM h2 = mcccurved_guide_24_0_h2;
MCNUM l = mcccurved_guide_24_0_l;
MCNUM R0 = mcccurved_guide_24_0_R0;
MCNUM Qc = mcccurved_guide_24_0_Qc;
MCNUM alpha = mcccurved_guide_24_0_alpha;
MCNUM m = mcccurved_guide_24_0_m;
MCNUM W = mcccurved_guide_24_0_W;
MCNUM nslit = mcccurved_guide_24_0_nslit;
MCNUM d = mcccurved_guide_24_0_d;
MCNUM mleft = mcccurved_guide_24_0_mleft;
MCNUM mright = mcccurved_guide_24_0_mright;
MCNUM mtop = mcccurved_guide_24_0_mtop;
MCNUM mbottom = mcccurved_guide_24_0_mbottom;
MCNUM nhslit = mcccurved_guide_24_0_nhslit;
MCNUM G = mcccurved_guide_24_0_G;
MCNUM aleft = mcccurved_guide_24_0_aleft;
MCNUM aright = mcccurved_guide_24_0_aright;
MCNUM atop = mcccurved_guide_24_0_atop;
MCNUM abottom = mcccurved_guide_24_0_abottom;
MCNUM wavy = mcccurved_guide_24_0_wavy;
MCNUM wavy_z = mcccurved_guide_24_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_24_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_24_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_24_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_24_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_24_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_24_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_24_0_nelements;
MCNUM nu = mcccurved_guide_24_0_nu;
MCNUM phase = mcccurved_guide_24_0_phase;
char* reflect = mcccurved_guide_24_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 48721 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_24_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_24_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(32,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_25_0 [33] */
  mccoordschange(mcposrcurved_guide_25_0, mcrotrcurved_guide_25_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_25_0 (without coords transformations) */
  mcJumpTrace_curved_guide_25_0:
  SIG_MESSAGE("curved_guide_25_0 (Trace)");
  mcDEBUG_COMP("curved_guide_25_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_25_0
  STORE_NEUTRON(33,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[33]++;
  mcPCounter[33] += p;
  mcP2Counter[33] += p*p;
#define mccompcurname  curved_guide_25_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 33
#define GVars mcccurved_guide_25_0_GVars
#define pTable mcccurved_guide_25_0_pTable
{   /* Declarations of curved_guide_25_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_25_0_w1;
MCNUM h1 = mcccurved_guide_25_0_h1;
MCNUM w2 = mcccurved_guide_25_0_w2;
MCNUM h2 = mcccurved_guide_25_0_h2;
MCNUM l = mcccurved_guide_25_0_l;
MCNUM R0 = mcccurved_guide_25_0_R0;
MCNUM Qc = mcccurved_guide_25_0_Qc;
MCNUM alpha = mcccurved_guide_25_0_alpha;
MCNUM m = mcccurved_guide_25_0_m;
MCNUM W = mcccurved_guide_25_0_W;
MCNUM nslit = mcccurved_guide_25_0_nslit;
MCNUM d = mcccurved_guide_25_0_d;
MCNUM mleft = mcccurved_guide_25_0_mleft;
MCNUM mright = mcccurved_guide_25_0_mright;
MCNUM mtop = mcccurved_guide_25_0_mtop;
MCNUM mbottom = mcccurved_guide_25_0_mbottom;
MCNUM nhslit = mcccurved_guide_25_0_nhslit;
MCNUM G = mcccurved_guide_25_0_G;
MCNUM aleft = mcccurved_guide_25_0_aleft;
MCNUM aright = mcccurved_guide_25_0_aright;
MCNUM atop = mcccurved_guide_25_0_atop;
MCNUM abottom = mcccurved_guide_25_0_abottom;
MCNUM wavy = mcccurved_guide_25_0_wavy;
MCNUM wavy_z = mcccurved_guide_25_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_25_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_25_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_25_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_25_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_25_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_25_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_25_0_nelements;
MCNUM nu = mcccurved_guide_25_0_nu;
MCNUM phase = mcccurved_guide_25_0_phase;
char* reflect = mcccurved_guide_25_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 49055 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_25_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_25_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(33,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_26_0 [34] */
  mccoordschange(mcposrcurved_guide_26_0, mcrotrcurved_guide_26_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_26_0 (without coords transformations) */
  mcJumpTrace_curved_guide_26_0:
  SIG_MESSAGE("curved_guide_26_0 (Trace)");
  mcDEBUG_COMP("curved_guide_26_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_26_0
  STORE_NEUTRON(34,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[34]++;
  mcPCounter[34] += p;
  mcP2Counter[34] += p*p;
#define mccompcurname  curved_guide_26_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 34
#define GVars mcccurved_guide_26_0_GVars
#define pTable mcccurved_guide_26_0_pTable
{   /* Declarations of curved_guide_26_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_26_0_w1;
MCNUM h1 = mcccurved_guide_26_0_h1;
MCNUM w2 = mcccurved_guide_26_0_w2;
MCNUM h2 = mcccurved_guide_26_0_h2;
MCNUM l = mcccurved_guide_26_0_l;
MCNUM R0 = mcccurved_guide_26_0_R0;
MCNUM Qc = mcccurved_guide_26_0_Qc;
MCNUM alpha = mcccurved_guide_26_0_alpha;
MCNUM m = mcccurved_guide_26_0_m;
MCNUM W = mcccurved_guide_26_0_W;
MCNUM nslit = mcccurved_guide_26_0_nslit;
MCNUM d = mcccurved_guide_26_0_d;
MCNUM mleft = mcccurved_guide_26_0_mleft;
MCNUM mright = mcccurved_guide_26_0_mright;
MCNUM mtop = mcccurved_guide_26_0_mtop;
MCNUM mbottom = mcccurved_guide_26_0_mbottom;
MCNUM nhslit = mcccurved_guide_26_0_nhslit;
MCNUM G = mcccurved_guide_26_0_G;
MCNUM aleft = mcccurved_guide_26_0_aleft;
MCNUM aright = mcccurved_guide_26_0_aright;
MCNUM atop = mcccurved_guide_26_0_atop;
MCNUM abottom = mcccurved_guide_26_0_abottom;
MCNUM wavy = mcccurved_guide_26_0_wavy;
MCNUM wavy_z = mcccurved_guide_26_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_26_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_26_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_26_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_26_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_26_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_26_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_26_0_nelements;
MCNUM nu = mcccurved_guide_26_0_nu;
MCNUM phase = mcccurved_guide_26_0_phase;
char* reflect = mcccurved_guide_26_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 49389 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_26_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_26_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(34,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_27_0 [35] */
  mccoordschange(mcposrcurved_guide_27_0, mcrotrcurved_guide_27_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_27_0 (without coords transformations) */
  mcJumpTrace_curved_guide_27_0:
  SIG_MESSAGE("curved_guide_27_0 (Trace)");
  mcDEBUG_COMP("curved_guide_27_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_27_0
  STORE_NEUTRON(35,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[35]++;
  mcPCounter[35] += p;
  mcP2Counter[35] += p*p;
#define mccompcurname  curved_guide_27_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 35
#define GVars mcccurved_guide_27_0_GVars
#define pTable mcccurved_guide_27_0_pTable
{   /* Declarations of curved_guide_27_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_27_0_w1;
MCNUM h1 = mcccurved_guide_27_0_h1;
MCNUM w2 = mcccurved_guide_27_0_w2;
MCNUM h2 = mcccurved_guide_27_0_h2;
MCNUM l = mcccurved_guide_27_0_l;
MCNUM R0 = mcccurved_guide_27_0_R0;
MCNUM Qc = mcccurved_guide_27_0_Qc;
MCNUM alpha = mcccurved_guide_27_0_alpha;
MCNUM m = mcccurved_guide_27_0_m;
MCNUM W = mcccurved_guide_27_0_W;
MCNUM nslit = mcccurved_guide_27_0_nslit;
MCNUM d = mcccurved_guide_27_0_d;
MCNUM mleft = mcccurved_guide_27_0_mleft;
MCNUM mright = mcccurved_guide_27_0_mright;
MCNUM mtop = mcccurved_guide_27_0_mtop;
MCNUM mbottom = mcccurved_guide_27_0_mbottom;
MCNUM nhslit = mcccurved_guide_27_0_nhslit;
MCNUM G = mcccurved_guide_27_0_G;
MCNUM aleft = mcccurved_guide_27_0_aleft;
MCNUM aright = mcccurved_guide_27_0_aright;
MCNUM atop = mcccurved_guide_27_0_atop;
MCNUM abottom = mcccurved_guide_27_0_abottom;
MCNUM wavy = mcccurved_guide_27_0_wavy;
MCNUM wavy_z = mcccurved_guide_27_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_27_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_27_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_27_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_27_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_27_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_27_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_27_0_nelements;
MCNUM nu = mcccurved_guide_27_0_nu;
MCNUM phase = mcccurved_guide_27_0_phase;
char* reflect = mcccurved_guide_27_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 49723 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_27_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_27_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(35,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_28_0 [36] */
  mccoordschange(mcposrcurved_guide_28_0, mcrotrcurved_guide_28_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_28_0 (without coords transformations) */
  mcJumpTrace_curved_guide_28_0:
  SIG_MESSAGE("curved_guide_28_0 (Trace)");
  mcDEBUG_COMP("curved_guide_28_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_28_0
  STORE_NEUTRON(36,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[36]++;
  mcPCounter[36] += p;
  mcP2Counter[36] += p*p;
#define mccompcurname  curved_guide_28_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 36
#define GVars mcccurved_guide_28_0_GVars
#define pTable mcccurved_guide_28_0_pTable
{   /* Declarations of curved_guide_28_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_28_0_w1;
MCNUM h1 = mcccurved_guide_28_0_h1;
MCNUM w2 = mcccurved_guide_28_0_w2;
MCNUM h2 = mcccurved_guide_28_0_h2;
MCNUM l = mcccurved_guide_28_0_l;
MCNUM R0 = mcccurved_guide_28_0_R0;
MCNUM Qc = mcccurved_guide_28_0_Qc;
MCNUM alpha = mcccurved_guide_28_0_alpha;
MCNUM m = mcccurved_guide_28_0_m;
MCNUM W = mcccurved_guide_28_0_W;
MCNUM nslit = mcccurved_guide_28_0_nslit;
MCNUM d = mcccurved_guide_28_0_d;
MCNUM mleft = mcccurved_guide_28_0_mleft;
MCNUM mright = mcccurved_guide_28_0_mright;
MCNUM mtop = mcccurved_guide_28_0_mtop;
MCNUM mbottom = mcccurved_guide_28_0_mbottom;
MCNUM nhslit = mcccurved_guide_28_0_nhslit;
MCNUM G = mcccurved_guide_28_0_G;
MCNUM aleft = mcccurved_guide_28_0_aleft;
MCNUM aright = mcccurved_guide_28_0_aright;
MCNUM atop = mcccurved_guide_28_0_atop;
MCNUM abottom = mcccurved_guide_28_0_abottom;
MCNUM wavy = mcccurved_guide_28_0_wavy;
MCNUM wavy_z = mcccurved_guide_28_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_28_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_28_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_28_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_28_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_28_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_28_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_28_0_nelements;
MCNUM nu = mcccurved_guide_28_0_nu;
MCNUM phase = mcccurved_guide_28_0_phase;
char* reflect = mcccurved_guide_28_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 50057 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_28_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_28_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(36,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_29_0 [37] */
  mccoordschange(mcposrcurved_guide_29_0, mcrotrcurved_guide_29_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_29_0 (without coords transformations) */
  mcJumpTrace_curved_guide_29_0:
  SIG_MESSAGE("curved_guide_29_0 (Trace)");
  mcDEBUG_COMP("curved_guide_29_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_29_0
  STORE_NEUTRON(37,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[37]++;
  mcPCounter[37] += p;
  mcP2Counter[37] += p*p;
#define mccompcurname  curved_guide_29_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 37
#define GVars mcccurved_guide_29_0_GVars
#define pTable mcccurved_guide_29_0_pTable
{   /* Declarations of curved_guide_29_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_29_0_w1;
MCNUM h1 = mcccurved_guide_29_0_h1;
MCNUM w2 = mcccurved_guide_29_0_w2;
MCNUM h2 = mcccurved_guide_29_0_h2;
MCNUM l = mcccurved_guide_29_0_l;
MCNUM R0 = mcccurved_guide_29_0_R0;
MCNUM Qc = mcccurved_guide_29_0_Qc;
MCNUM alpha = mcccurved_guide_29_0_alpha;
MCNUM m = mcccurved_guide_29_0_m;
MCNUM W = mcccurved_guide_29_0_W;
MCNUM nslit = mcccurved_guide_29_0_nslit;
MCNUM d = mcccurved_guide_29_0_d;
MCNUM mleft = mcccurved_guide_29_0_mleft;
MCNUM mright = mcccurved_guide_29_0_mright;
MCNUM mtop = mcccurved_guide_29_0_mtop;
MCNUM mbottom = mcccurved_guide_29_0_mbottom;
MCNUM nhslit = mcccurved_guide_29_0_nhslit;
MCNUM G = mcccurved_guide_29_0_G;
MCNUM aleft = mcccurved_guide_29_0_aleft;
MCNUM aright = mcccurved_guide_29_0_aright;
MCNUM atop = mcccurved_guide_29_0_atop;
MCNUM abottom = mcccurved_guide_29_0_abottom;
MCNUM wavy = mcccurved_guide_29_0_wavy;
MCNUM wavy_z = mcccurved_guide_29_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_29_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_29_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_29_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_29_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_29_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_29_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_29_0_nelements;
MCNUM nu = mcccurved_guide_29_0_nu;
MCNUM phase = mcccurved_guide_29_0_phase;
char* reflect = mcccurved_guide_29_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 50391 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_29_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_29_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(37,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_30_0 [38] */
  mccoordschange(mcposrcurved_guide_30_0, mcrotrcurved_guide_30_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_30_0 (without coords transformations) */
  mcJumpTrace_curved_guide_30_0:
  SIG_MESSAGE("curved_guide_30_0 (Trace)");
  mcDEBUG_COMP("curved_guide_30_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_30_0
  STORE_NEUTRON(38,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[38]++;
  mcPCounter[38] += p;
  mcP2Counter[38] += p*p;
#define mccompcurname  curved_guide_30_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 38
#define GVars mcccurved_guide_30_0_GVars
#define pTable mcccurved_guide_30_0_pTable
{   /* Declarations of curved_guide_30_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_30_0_w1;
MCNUM h1 = mcccurved_guide_30_0_h1;
MCNUM w2 = mcccurved_guide_30_0_w2;
MCNUM h2 = mcccurved_guide_30_0_h2;
MCNUM l = mcccurved_guide_30_0_l;
MCNUM R0 = mcccurved_guide_30_0_R0;
MCNUM Qc = mcccurved_guide_30_0_Qc;
MCNUM alpha = mcccurved_guide_30_0_alpha;
MCNUM m = mcccurved_guide_30_0_m;
MCNUM W = mcccurved_guide_30_0_W;
MCNUM nslit = mcccurved_guide_30_0_nslit;
MCNUM d = mcccurved_guide_30_0_d;
MCNUM mleft = mcccurved_guide_30_0_mleft;
MCNUM mright = mcccurved_guide_30_0_mright;
MCNUM mtop = mcccurved_guide_30_0_mtop;
MCNUM mbottom = mcccurved_guide_30_0_mbottom;
MCNUM nhslit = mcccurved_guide_30_0_nhslit;
MCNUM G = mcccurved_guide_30_0_G;
MCNUM aleft = mcccurved_guide_30_0_aleft;
MCNUM aright = mcccurved_guide_30_0_aright;
MCNUM atop = mcccurved_guide_30_0_atop;
MCNUM abottom = mcccurved_guide_30_0_abottom;
MCNUM wavy = mcccurved_guide_30_0_wavy;
MCNUM wavy_z = mcccurved_guide_30_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_30_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_30_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_30_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_30_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_30_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_30_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_30_0_nelements;
MCNUM nu = mcccurved_guide_30_0_nu;
MCNUM phase = mcccurved_guide_30_0_phase;
char* reflect = mcccurved_guide_30_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 50725 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_30_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_30_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(38,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_31_0 [39] */
  mccoordschange(mcposrcurved_guide_31_0, mcrotrcurved_guide_31_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_31_0 (without coords transformations) */
  mcJumpTrace_curved_guide_31_0:
  SIG_MESSAGE("curved_guide_31_0 (Trace)");
  mcDEBUG_COMP("curved_guide_31_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_31_0
  STORE_NEUTRON(39,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[39]++;
  mcPCounter[39] += p;
  mcP2Counter[39] += p*p;
#define mccompcurname  curved_guide_31_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 39
#define GVars mcccurved_guide_31_0_GVars
#define pTable mcccurved_guide_31_0_pTable
{   /* Declarations of curved_guide_31_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_31_0_w1;
MCNUM h1 = mcccurved_guide_31_0_h1;
MCNUM w2 = mcccurved_guide_31_0_w2;
MCNUM h2 = mcccurved_guide_31_0_h2;
MCNUM l = mcccurved_guide_31_0_l;
MCNUM R0 = mcccurved_guide_31_0_R0;
MCNUM Qc = mcccurved_guide_31_0_Qc;
MCNUM alpha = mcccurved_guide_31_0_alpha;
MCNUM m = mcccurved_guide_31_0_m;
MCNUM W = mcccurved_guide_31_0_W;
MCNUM nslit = mcccurved_guide_31_0_nslit;
MCNUM d = mcccurved_guide_31_0_d;
MCNUM mleft = mcccurved_guide_31_0_mleft;
MCNUM mright = mcccurved_guide_31_0_mright;
MCNUM mtop = mcccurved_guide_31_0_mtop;
MCNUM mbottom = mcccurved_guide_31_0_mbottom;
MCNUM nhslit = mcccurved_guide_31_0_nhslit;
MCNUM G = mcccurved_guide_31_0_G;
MCNUM aleft = mcccurved_guide_31_0_aleft;
MCNUM aright = mcccurved_guide_31_0_aright;
MCNUM atop = mcccurved_guide_31_0_atop;
MCNUM abottom = mcccurved_guide_31_0_abottom;
MCNUM wavy = mcccurved_guide_31_0_wavy;
MCNUM wavy_z = mcccurved_guide_31_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_31_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_31_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_31_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_31_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_31_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_31_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_31_0_nelements;
MCNUM nu = mcccurved_guide_31_0_nu;
MCNUM phase = mcccurved_guide_31_0_phase;
char* reflect = mcccurved_guide_31_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 51059 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_31_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_31_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(39,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_32_0 [40] */
  mccoordschange(mcposrcurved_guide_32_0, mcrotrcurved_guide_32_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_32_0 (without coords transformations) */
  mcJumpTrace_curved_guide_32_0:
  SIG_MESSAGE("curved_guide_32_0 (Trace)");
  mcDEBUG_COMP("curved_guide_32_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_32_0
  STORE_NEUTRON(40,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[40]++;
  mcPCounter[40] += p;
  mcP2Counter[40] += p*p;
#define mccompcurname  curved_guide_32_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 40
#define GVars mcccurved_guide_32_0_GVars
#define pTable mcccurved_guide_32_0_pTable
{   /* Declarations of curved_guide_32_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_32_0_w1;
MCNUM h1 = mcccurved_guide_32_0_h1;
MCNUM w2 = mcccurved_guide_32_0_w2;
MCNUM h2 = mcccurved_guide_32_0_h2;
MCNUM l = mcccurved_guide_32_0_l;
MCNUM R0 = mcccurved_guide_32_0_R0;
MCNUM Qc = mcccurved_guide_32_0_Qc;
MCNUM alpha = mcccurved_guide_32_0_alpha;
MCNUM m = mcccurved_guide_32_0_m;
MCNUM W = mcccurved_guide_32_0_W;
MCNUM nslit = mcccurved_guide_32_0_nslit;
MCNUM d = mcccurved_guide_32_0_d;
MCNUM mleft = mcccurved_guide_32_0_mleft;
MCNUM mright = mcccurved_guide_32_0_mright;
MCNUM mtop = mcccurved_guide_32_0_mtop;
MCNUM mbottom = mcccurved_guide_32_0_mbottom;
MCNUM nhslit = mcccurved_guide_32_0_nhslit;
MCNUM G = mcccurved_guide_32_0_G;
MCNUM aleft = mcccurved_guide_32_0_aleft;
MCNUM aright = mcccurved_guide_32_0_aright;
MCNUM atop = mcccurved_guide_32_0_atop;
MCNUM abottom = mcccurved_guide_32_0_abottom;
MCNUM wavy = mcccurved_guide_32_0_wavy;
MCNUM wavy_z = mcccurved_guide_32_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_32_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_32_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_32_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_32_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_32_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_32_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_32_0_nelements;
MCNUM nu = mcccurved_guide_32_0_nu;
MCNUM phase = mcccurved_guide_32_0_phase;
char* reflect = mcccurved_guide_32_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 51393 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_32_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_32_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(40,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_33_0 [41] */
  mccoordschange(mcposrcurved_guide_33_0, mcrotrcurved_guide_33_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_33_0 (without coords transformations) */
  mcJumpTrace_curved_guide_33_0:
  SIG_MESSAGE("curved_guide_33_0 (Trace)");
  mcDEBUG_COMP("curved_guide_33_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_33_0
  STORE_NEUTRON(41,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[41]++;
  mcPCounter[41] += p;
  mcP2Counter[41] += p*p;
#define mccompcurname  curved_guide_33_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 41
#define GVars mcccurved_guide_33_0_GVars
#define pTable mcccurved_guide_33_0_pTable
{   /* Declarations of curved_guide_33_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_33_0_w1;
MCNUM h1 = mcccurved_guide_33_0_h1;
MCNUM w2 = mcccurved_guide_33_0_w2;
MCNUM h2 = mcccurved_guide_33_0_h2;
MCNUM l = mcccurved_guide_33_0_l;
MCNUM R0 = mcccurved_guide_33_0_R0;
MCNUM Qc = mcccurved_guide_33_0_Qc;
MCNUM alpha = mcccurved_guide_33_0_alpha;
MCNUM m = mcccurved_guide_33_0_m;
MCNUM W = mcccurved_guide_33_0_W;
MCNUM nslit = mcccurved_guide_33_0_nslit;
MCNUM d = mcccurved_guide_33_0_d;
MCNUM mleft = mcccurved_guide_33_0_mleft;
MCNUM mright = mcccurved_guide_33_0_mright;
MCNUM mtop = mcccurved_guide_33_0_mtop;
MCNUM mbottom = mcccurved_guide_33_0_mbottom;
MCNUM nhslit = mcccurved_guide_33_0_nhslit;
MCNUM G = mcccurved_guide_33_0_G;
MCNUM aleft = mcccurved_guide_33_0_aleft;
MCNUM aright = mcccurved_guide_33_0_aright;
MCNUM atop = mcccurved_guide_33_0_atop;
MCNUM abottom = mcccurved_guide_33_0_abottom;
MCNUM wavy = mcccurved_guide_33_0_wavy;
MCNUM wavy_z = mcccurved_guide_33_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_33_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_33_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_33_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_33_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_33_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_33_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_33_0_nelements;
MCNUM nu = mcccurved_guide_33_0_nu;
MCNUM phase = mcccurved_guide_33_0_phase;
char* reflect = mcccurved_guide_33_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 51727 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_33_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_33_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(41,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_34_0 [42] */
  mccoordschange(mcposrcurved_guide_34_0, mcrotrcurved_guide_34_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_34_0 (without coords transformations) */
  mcJumpTrace_curved_guide_34_0:
  SIG_MESSAGE("curved_guide_34_0 (Trace)");
  mcDEBUG_COMP("curved_guide_34_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_34_0
  STORE_NEUTRON(42,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[42]++;
  mcPCounter[42] += p;
  mcP2Counter[42] += p*p;
#define mccompcurname  curved_guide_34_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 42
#define GVars mcccurved_guide_34_0_GVars
#define pTable mcccurved_guide_34_0_pTable
{   /* Declarations of curved_guide_34_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_34_0_w1;
MCNUM h1 = mcccurved_guide_34_0_h1;
MCNUM w2 = mcccurved_guide_34_0_w2;
MCNUM h2 = mcccurved_guide_34_0_h2;
MCNUM l = mcccurved_guide_34_0_l;
MCNUM R0 = mcccurved_guide_34_0_R0;
MCNUM Qc = mcccurved_guide_34_0_Qc;
MCNUM alpha = mcccurved_guide_34_0_alpha;
MCNUM m = mcccurved_guide_34_0_m;
MCNUM W = mcccurved_guide_34_0_W;
MCNUM nslit = mcccurved_guide_34_0_nslit;
MCNUM d = mcccurved_guide_34_0_d;
MCNUM mleft = mcccurved_guide_34_0_mleft;
MCNUM mright = mcccurved_guide_34_0_mright;
MCNUM mtop = mcccurved_guide_34_0_mtop;
MCNUM mbottom = mcccurved_guide_34_0_mbottom;
MCNUM nhslit = mcccurved_guide_34_0_nhslit;
MCNUM G = mcccurved_guide_34_0_G;
MCNUM aleft = mcccurved_guide_34_0_aleft;
MCNUM aright = mcccurved_guide_34_0_aright;
MCNUM atop = mcccurved_guide_34_0_atop;
MCNUM abottom = mcccurved_guide_34_0_abottom;
MCNUM wavy = mcccurved_guide_34_0_wavy;
MCNUM wavy_z = mcccurved_guide_34_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_34_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_34_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_34_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_34_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_34_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_34_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_34_0_nelements;
MCNUM nu = mcccurved_guide_34_0_nu;
MCNUM phase = mcccurved_guide_34_0_phase;
char* reflect = mcccurved_guide_34_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 52061 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_34_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_34_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(42,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_35_0 [43] */
  mccoordschange(mcposrcurved_guide_35_0, mcrotrcurved_guide_35_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_35_0 (without coords transformations) */
  mcJumpTrace_curved_guide_35_0:
  SIG_MESSAGE("curved_guide_35_0 (Trace)");
  mcDEBUG_COMP("curved_guide_35_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_35_0
  STORE_NEUTRON(43,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[43]++;
  mcPCounter[43] += p;
  mcP2Counter[43] += p*p;
#define mccompcurname  curved_guide_35_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 43
#define GVars mcccurved_guide_35_0_GVars
#define pTable mcccurved_guide_35_0_pTable
{   /* Declarations of curved_guide_35_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_35_0_w1;
MCNUM h1 = mcccurved_guide_35_0_h1;
MCNUM w2 = mcccurved_guide_35_0_w2;
MCNUM h2 = mcccurved_guide_35_0_h2;
MCNUM l = mcccurved_guide_35_0_l;
MCNUM R0 = mcccurved_guide_35_0_R0;
MCNUM Qc = mcccurved_guide_35_0_Qc;
MCNUM alpha = mcccurved_guide_35_0_alpha;
MCNUM m = mcccurved_guide_35_0_m;
MCNUM W = mcccurved_guide_35_0_W;
MCNUM nslit = mcccurved_guide_35_0_nslit;
MCNUM d = mcccurved_guide_35_0_d;
MCNUM mleft = mcccurved_guide_35_0_mleft;
MCNUM mright = mcccurved_guide_35_0_mright;
MCNUM mtop = mcccurved_guide_35_0_mtop;
MCNUM mbottom = mcccurved_guide_35_0_mbottom;
MCNUM nhslit = mcccurved_guide_35_0_nhslit;
MCNUM G = mcccurved_guide_35_0_G;
MCNUM aleft = mcccurved_guide_35_0_aleft;
MCNUM aright = mcccurved_guide_35_0_aright;
MCNUM atop = mcccurved_guide_35_0_atop;
MCNUM abottom = mcccurved_guide_35_0_abottom;
MCNUM wavy = mcccurved_guide_35_0_wavy;
MCNUM wavy_z = mcccurved_guide_35_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_35_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_35_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_35_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_35_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_35_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_35_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_35_0_nelements;
MCNUM nu = mcccurved_guide_35_0_nu;
MCNUM phase = mcccurved_guide_35_0_phase;
char* reflect = mcccurved_guide_35_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 52395 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_35_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_35_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(43,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component curved_guide_36_0 [44] */
  mccoordschange(mcposrcurved_guide_36_0, mcrotrcurved_guide_36_0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component curved_guide_36_0 (without coords transformations) */
  mcJumpTrace_curved_guide_36_0:
  SIG_MESSAGE("curved_guide_36_0 (Trace)");
  mcDEBUG_COMP("curved_guide_36_0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcurved_guide_36_0
  STORE_NEUTRON(44,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[44]++;
  mcPCounter[44] += p;
  mcP2Counter[44] += p*p;
#define mccompcurname  curved_guide_36_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 44
#define GVars mcccurved_guide_36_0_GVars
#define pTable mcccurved_guide_36_0_pTable
{   /* Declarations of curved_guide_36_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_36_0_w1;
MCNUM h1 = mcccurved_guide_36_0_h1;
MCNUM w2 = mcccurved_guide_36_0_w2;
MCNUM h2 = mcccurved_guide_36_0_h2;
MCNUM l = mcccurved_guide_36_0_l;
MCNUM R0 = mcccurved_guide_36_0_R0;
MCNUM Qc = mcccurved_guide_36_0_Qc;
MCNUM alpha = mcccurved_guide_36_0_alpha;
MCNUM m = mcccurved_guide_36_0_m;
MCNUM W = mcccurved_guide_36_0_W;
MCNUM nslit = mcccurved_guide_36_0_nslit;
MCNUM d = mcccurved_guide_36_0_d;
MCNUM mleft = mcccurved_guide_36_0_mleft;
MCNUM mright = mcccurved_guide_36_0_mright;
MCNUM mtop = mcccurved_guide_36_0_mtop;
MCNUM mbottom = mcccurved_guide_36_0_mbottom;
MCNUM nhslit = mcccurved_guide_36_0_nhslit;
MCNUM G = mcccurved_guide_36_0_G;
MCNUM aleft = mcccurved_guide_36_0_aleft;
MCNUM aright = mcccurved_guide_36_0_aright;
MCNUM atop = mcccurved_guide_36_0_atop;
MCNUM abottom = mcccurved_guide_36_0_abottom;
MCNUM wavy = mcccurved_guide_36_0_wavy;
MCNUM wavy_z = mcccurved_guide_36_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_36_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_36_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_36_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_36_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_36_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_36_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_36_0_nelements;
MCNUM nu = mcccurved_guide_36_0_nu;
MCNUM phase = mcccurved_guide_36_0_phase;
char* reflect = mcccurved_guide_36_0_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 52729 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_36_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcurved_guide_36_0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(44,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component EndOfelement_4 [45] */
  mccoordschange(mcposrEndOfelement_4, mcrotrEndOfelement_4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component EndOfelement_4 (without coords transformations) */
  mcJumpTrace_EndOfelement_4:
  SIG_MESSAGE("EndOfelement_4 (Trace)");
  mcDEBUG_COMP("EndOfelement_4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompEndOfelement_4
  STORE_NEUTRON(45,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[45]++;
  mcPCounter[45] += p;
  mcP2Counter[45] += p*p;
#define mccompcurname  EndOfelement_4
#define mccompcurtype  Arm
#define mccompcurindex 45
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompEndOfelement_4:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(45,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component log_P_start [46] */
  mccoordschange(mcposrlog_P_start, mcrotrlog_P_start,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component log_P_start (without coords transformations) */
  mcJumpTrace_log_P_start:
  SIG_MESSAGE("log_P_start (Trace)");
  mcDEBUG_COMP("log_P_start")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComplog_P_start
  STORE_NEUTRON(46,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[46]++;
  mcPCounter[46] += p;
  mcP2Counter[46] += p*p;
#define mccompcurname  log_P_start
#define mccompcurtype  Shielding_logger
#define mccompcurindex 46
#line 163 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_logger.comp"
{
#undef SCATTER
#define SCATTER SCATTER_LOG

#undef ABSORB
#define ABSORB ABSORB_LOG

/*
#ifdef scatter_logger_stop
#undef scatter_logger_stop
#endif

#define scatter_logger_stop logger
*/
#undef mcabsorb
#define mcabsorb scatter_logger_stop

  bounce_store_index=0;/*we are now starting logging so we should start afresh*/   
  absorbed_in_optics=0;/*we are now starting logging so we should start afresh*/ 
  if (bounce_store_index<BOUNCE_LOG_SIZE){
    struct Generalized_State_t *bp=&(Bounce_store[bounce_store_index]);
    Coords ctmp=POS_A_CURRENT_COMP;
    Coords r = coords_set(x,y,z);
    Coords v = coords_set(vx,vy,vz);
    Coords s = coords_set(sx,sy,sz);

    Coords rg,vg,sg;

    Rotation Rt;
    rot_transpose(ROT_A_CURRENT_COMP,Rt);
    rg=coords_add(rot_apply(Rt,r),ctmp);
    vg=rot_apply(Rt,v);
    sg=rot_apply(Rt,s);
    coords_get(rg,&(bp->_x),&(bp->_y),&(bp->_z));
    coords_get(vg,&(bp->_vx),&(bp->_vy),&(bp->_vz));
    coords_get(sg,&(bp->_sx),&(bp->_sy),&(bp->_sz));
    bp->_t=t;
    bp->_p=p;
    bp->_nid=mcget_run_num();
    bp->_comp=INDEX_CURRENT_COMP;
    bp->_idx=bounce_store_index;
    bp->_mvalue=0.0; // This is the incoming particle. No collision, setting mvalue=0.
   // printf("Starting scatter logger, writing state (%d) to the buffer, r: %g %g %g  v: %g %g %g p: %g\n", bounce_store_index, bp->_x, bp->_y, bp->_z, bp->_vx, bp->_vy, bp->_vz, bp->_p);
    bounce_store_index++;
  }else if(bounce_store_index==BOUNCE_LOG_SIZE && !bounce_store_overrun){
    printf("Warning (%s): Scatter_log overrun - not logging any more SCATTER events\n",NAME_CURRENT_COMP);
    bounce_store_overrun=1;
  }
}
#line 52989 "./ESS_BIFROST_shielding.c"
/* 'log_P_start=Shielding_logger()' component instance extend code */
    SIG_MESSAGE("log_P_start (Trace:Extend)");
#line 1422 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
#ifdef scatter_logger_stop
#undef scatter_logger_stop
#endif
#define scatter_logger_stop log_P_start
#line 52997 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComplog_P_start:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(46,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component elliptical_guide_gravity3 [47] */
  mccoordschange(mcposrelliptical_guide_gravity3, mcrotrelliptical_guide_gravity3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component elliptical_guide_gravity3 (without coords transformations) */
  mcJumpTrace_elliptical_guide_gravity3:
  SIG_MESSAGE("elliptical_guide_gravity3 (Trace)");
  mcDEBUG_COMP("elliptical_guide_gravity3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompelliptical_guide_gravity3
  STORE_NEUTRON(47,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[47]++;
  mcPCounter[47] += p;
  mcP2Counter[47] += p*p;
#define mccompcurname  elliptical_guide_gravity3
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 47
#define mvaluesright mccelliptical_guide_gravity3_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity3_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity3_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity3_mvaluesbottom
#define seglength mccelliptical_guide_gravity3_seglength
#define guideInfo mccelliptical_guide_gravity3_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity3_latestParticleCollision
#define Gx mccelliptical_guide_gravity3_Gx
#define Gy mccelliptical_guide_gravity3_Gy
#define Gz mccelliptical_guide_gravity3_Gz
#define Gx0 mccelliptical_guide_gravity3_Gx0
#define Gy0 mccelliptical_guide_gravity3_Gy0
#define Gz0 mccelliptical_guide_gravity3_Gz0
#define Circ mccelliptical_guide_gravity3_Circ
#define dynamicalSegLength mccelliptical_guide_gravity3_dynamicalSegLength
{   /* Declarations of elliptical_guide_gravity3=Elliptic_guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM l = mccelliptical_guide_gravity3_l;
MCNUM xwidth = mccelliptical_guide_gravity3_xwidth;
MCNUM yheight = mccelliptical_guide_gravity3_yheight;
MCNUM linxw = mccelliptical_guide_gravity3_linxw;
MCNUM loutxw = mccelliptical_guide_gravity3_loutxw;
MCNUM linyh = mccelliptical_guide_gravity3_linyh;
MCNUM loutyh = mccelliptical_guide_gravity3_loutyh;
MCNUM majorAxisxw = mccelliptical_guide_gravity3_majorAxisxw;
MCNUM minorAxisxw = mccelliptical_guide_gravity3_minorAxisxw;
MCNUM majorAxisyh = mccelliptical_guide_gravity3_majorAxisyh;
MCNUM minorAxisyh = mccelliptical_guide_gravity3_minorAxisyh;
MCNUM majorAxisoffsetxw = mccelliptical_guide_gravity3_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccelliptical_guide_gravity3_majorAxisoffsetyh;
char* dimensionsAt = mccelliptical_guide_gravity3_dimensionsAt;
char* option = mccelliptical_guide_gravity3_option;
MCNUM R0 = mccelliptical_guide_gravity3_R0;
MCNUM Qc = mccelliptical_guide_gravity3_Qc;
MCNUM alpha = mccelliptical_guide_gravity3_alpha;
MCNUM m = mccelliptical_guide_gravity3_m;
MCNUM W = mccelliptical_guide_gravity3_W;
MCNUM alpharight = mccelliptical_guide_gravity3_alpharight;
MCNUM mright = mccelliptical_guide_gravity3_mright;
MCNUM alphaleft = mccelliptical_guide_gravity3_alphaleft;
MCNUM mleft = mccelliptical_guide_gravity3_mleft;
MCNUM alphatop = mccelliptical_guide_gravity3_alphatop;
MCNUM mtop = mccelliptical_guide_gravity3_mtop;
MCNUM alphabottom = mccelliptical_guide_gravity3_alphabottom;
MCNUM mbottom = mccelliptical_guide_gravity3_mbottom;
char* verbose = mccelliptical_guide_gravity3_verbose;
MCNUM enableGravity = mccelliptical_guide_gravity3_enableGravity;
MCNUM curvature = mccelliptical_guide_gravity3_curvature;
#line 1432 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
{
  PROP_Z0;
  m_local_refl=-1; // RK - added. Comment: neutron entered the guide and hasn't reached the coating yet.
  SCATTER;
  
  double Gloc;
  if (curvature) {
    Gloc=(vx*vx+vy*vy+vz*vz)/curvature;
  } else {
    Gloc=0;
  }
  

	if( !guideInfo.EnclosingBoxOn )
		if( fabs(x) > guideInfo.entranceHorizontalWidth/2.0 
		    || fabs(y) > guideInfo.entranceVerticalWidth/2.0 ) 	{ m_local_refl=-1; // RK - added. 
	// RK - Comment: neutron doesn't make it to the guide opening, doesn't reach coating, setting m_local_refl=-1
		  ABSORB;}


	int bounces = 0;
	for(bounces = 0; bounces <= 1000; bounces++){
	//RK - Comment: now have entered the guide, will assign m_local_refl a value of the coating at the place of the hit.
	  Gx=Gx0; Gy=Gy0; Gz=Gz0;
	  if (curvature) {
	    // Add velocity-dependent, location-dependent approximation to centripetal force for curvature...
	    Gx=Gx0+Gloc*cos(2*PI*z/Circ);Gz=Gz0+Gloc*sin(2*PI*z/Circ);
	  }

		// Find the next intersection between the guide and the neutron.
		int boolean = guide_elliptical_handleGuideIntersection(
							x,y,z,vx,vy,vz,Gx,Gy,Gz,
							&guideInfo,&latestParticleCollision);

		double timeToCollision = 
				latestParticleCollision.delta_time_to_next_collision;

		// Handle special cases.
		//RK -- Comment: this happens when neutron hits precisely the corner of the guide. Assume no coating there
		if(boolean == 0) { m_local_refl=-1; ABSORB;} //if(boolean == 0) ABSORB; // RK -- modified line
		//RK -- Comment: this happens when neutron is travelling parallel to the wall. Assume absorption in the upper coating layer which amounts to setting m=1
		if(timeToCollision < 1e-15) { m_local_refl = 1; ABSORB;}  //if(timeToCollision < 1e-15) ABSORB; // RK -- modified line

		// If the neutron reach the end of the guide, when move 
		// the neutron to the end of guide and leave this component.
		if( z+vz*timeToCollision+0.5*Gz*timeToCollision*timeToCollision 
			>= guideInfo.Length )
		{
			double timeToExit = 0;
			solve_2nd_order(
					&timeToExit,NULL,
					-0.5*Gz,-vz,guideInfo.Length-z-1e-9);
			PROP_GRAV_DT(timeToExit,Gx,Gy,Gz);
			m_local_refl=-1; // RK - added. Comment: exiting guide, no scattering on the coating
			SCATTER;
			break;
		}

		// Move the neutron and handle the reflection.
		PROP_GRAV_DT(timeToCollision,Gx,Gy,Gz);
/*** RK now we are at the point of reflection, have to figure out what the m-value is here. ***/
  if(!guideInfo.enableSegments){
			m_local_refl=guideInfo.mArr[latestParticleCollision.side];
		   }
	else{
    	int currentSegment;
    	double combinedLength = 0;
    	int i;
    	for(i=0; i < guideInfo.numberOfSegments; i++){
    		combinedLength = combinedLength + guideInfo.segLength[i];
    		if(z < combinedLength)	{
    			currentSegment = i; break;
    		}
    	}

		if(latestParticleCollision.side == RightSide)
					m_local_refl = guideInfo.mValuesright[currentSegment];
		if(latestParticleCollision.side == LeftSide)
					m_local_refl=guideInfo.mValuesleft[currentSegment];
		if(latestParticleCollision.side == TopSide)
					m_local_refl = guideInfo.mValuestop[currentSegment];
		if(latestParticleCollision.side == BottomSide)
					m_local_refl = guideInfo.mValuesbottom[currentSegment];
    }
/*****/
		if(latestParticleCollision.collisionType == Absorb){ ABSORB; }
		if(latestParticleCollision.collisionType == Reflex){
			p *= guide_elliptical_handleReflection(x,y,z,&vx,&vy,&vz,
						&guideInfo,&latestParticleCollision); 
			SCATTER;
			if(p == 0) ABSORB; 
		}
	}
	// RK -- this happens when neutron didn't exit after 1000 bounces which is unrealistic situation. m_local_refl remains set to the m-value at last revlection.
	if( fabs(x) > guideInfo.exitHorizontalWidth/2 
	 || fabs(y) > guideInfo.exitVerticalWidth/2 )
		ABSORB;
	
}
#line 53248 "./ESS_BIFROST_shielding.c"
}   /* End of elliptical_guide_gravity3=Elliptic_guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompelliptical_guide_gravity3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(47,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component EndOfelement_3 [48] */
  mccoordschange(mcposrEndOfelement_3, mcrotrEndOfelement_3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component EndOfelement_3 (without coords transformations) */
  mcJumpTrace_EndOfelement_3:
  SIG_MESSAGE("EndOfelement_3 (Trace)");
  mcDEBUG_COMP("EndOfelement_3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompEndOfelement_3
  STORE_NEUTRON(48,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[48]++;
  mcPCounter[48] += p;
  mcP2Counter[48] += p*p;
#define mccompcurname  EndOfelement_3
#define mccompcurtype  Arm
#define mccompcurindex 48
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompEndOfelement_3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(48,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component straight_guide_2_1 [49] */
  mccoordschange(mcposrstraight_guide_2_1, mcrotrstraight_guide_2_1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component straight_guide_2_1 (without coords transformations) */
  mcJumpTrace_straight_guide_2_1:
  SIG_MESSAGE("straight_guide_2_1 (Trace)");
  mcDEBUG_COMP("straight_guide_2_1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompstraight_guide_2_1
  STORE_NEUTRON(49,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[49]++;
  mcPCounter[49] += p;
  mcP2Counter[49] += p*p;
#define mccompcurname  straight_guide_2_1
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 49
#define GVars mccstraight_guide_2_1_GVars
#define pTable mccstraight_guide_2_1_pTable
{   /* Declarations of straight_guide_2_1=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mccstraight_guide_2_1_w1;
MCNUM h1 = mccstraight_guide_2_1_h1;
MCNUM w2 = mccstraight_guide_2_1_w2;
MCNUM h2 = mccstraight_guide_2_1_h2;
MCNUM l = mccstraight_guide_2_1_l;
MCNUM R0 = mccstraight_guide_2_1_R0;
MCNUM Qc = mccstraight_guide_2_1_Qc;
MCNUM alpha = mccstraight_guide_2_1_alpha;
MCNUM m = mccstraight_guide_2_1_m;
MCNUM W = mccstraight_guide_2_1_W;
MCNUM nslit = mccstraight_guide_2_1_nslit;
MCNUM d = mccstraight_guide_2_1_d;
MCNUM mleft = mccstraight_guide_2_1_mleft;
MCNUM mright = mccstraight_guide_2_1_mright;
MCNUM mtop = mccstraight_guide_2_1_mtop;
MCNUM mbottom = mccstraight_guide_2_1_mbottom;
MCNUM nhslit = mccstraight_guide_2_1_nhslit;
MCNUM G = mccstraight_guide_2_1_G;
MCNUM aleft = mccstraight_guide_2_1_aleft;
MCNUM aright = mccstraight_guide_2_1_aright;
MCNUM atop = mccstraight_guide_2_1_atop;
MCNUM abottom = mccstraight_guide_2_1_abottom;
MCNUM wavy = mccstraight_guide_2_1_wavy;
MCNUM wavy_z = mccstraight_guide_2_1_wavy_z;
MCNUM wavy_tb = mccstraight_guide_2_1_wavy_tb;
MCNUM wavy_lr = mccstraight_guide_2_1_wavy_lr;
MCNUM chamfers = mccstraight_guide_2_1_chamfers;
MCNUM chamfers_z = mccstraight_guide_2_1_chamfers_z;
MCNUM chamfers_lr = mccstraight_guide_2_1_chamfers_lr;
MCNUM chamfers_tb = mccstraight_guide_2_1_chamfers_tb;
MCNUM nelements = mccstraight_guide_2_1_nelements;
MCNUM nu = mccstraight_guide_2_1_nu;
MCNUM phase = mccstraight_guide_2_1_phase;
char* reflect = mccstraight_guide_2_1_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 53698 "./ESS_BIFROST_shielding.c"
}   /* End of straight_guide_2_1=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompstraight_guide_2_1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(49,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component straight_guide_2_2 [50] */
  mccoordschange(mcposrstraight_guide_2_2, mcrotrstraight_guide_2_2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component straight_guide_2_2 (without coords transformations) */
  mcJumpTrace_straight_guide_2_2:
  SIG_MESSAGE("straight_guide_2_2 (Trace)");
  mcDEBUG_COMP("straight_guide_2_2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompstraight_guide_2_2
  STORE_NEUTRON(50,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[50]++;
  mcPCounter[50] += p;
  mcP2Counter[50] += p*p;
#define mccompcurname  straight_guide_2_2
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 50
#define GVars mccstraight_guide_2_2_GVars
#define pTable mccstraight_guide_2_2_pTable
{   /* Declarations of straight_guide_2_2=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mccstraight_guide_2_2_w1;
MCNUM h1 = mccstraight_guide_2_2_h1;
MCNUM w2 = mccstraight_guide_2_2_w2;
MCNUM h2 = mccstraight_guide_2_2_h2;
MCNUM l = mccstraight_guide_2_2_l;
MCNUM R0 = mccstraight_guide_2_2_R0;
MCNUM Qc = mccstraight_guide_2_2_Qc;
MCNUM alpha = mccstraight_guide_2_2_alpha;
MCNUM m = mccstraight_guide_2_2_m;
MCNUM W = mccstraight_guide_2_2_W;
MCNUM nslit = mccstraight_guide_2_2_nslit;
MCNUM d = mccstraight_guide_2_2_d;
MCNUM mleft = mccstraight_guide_2_2_mleft;
MCNUM mright = mccstraight_guide_2_2_mright;
MCNUM mtop = mccstraight_guide_2_2_mtop;
MCNUM mbottom = mccstraight_guide_2_2_mbottom;
MCNUM nhslit = mccstraight_guide_2_2_nhslit;
MCNUM G = mccstraight_guide_2_2_G;
MCNUM aleft = mccstraight_guide_2_2_aleft;
MCNUM aright = mccstraight_guide_2_2_aright;
MCNUM atop = mccstraight_guide_2_2_atop;
MCNUM abottom = mccstraight_guide_2_2_abottom;
MCNUM wavy = mccstraight_guide_2_2_wavy;
MCNUM wavy_z = mccstraight_guide_2_2_wavy_z;
MCNUM wavy_tb = mccstraight_guide_2_2_wavy_tb;
MCNUM wavy_lr = mccstraight_guide_2_2_wavy_lr;
MCNUM chamfers = mccstraight_guide_2_2_chamfers;
MCNUM chamfers_z = mccstraight_guide_2_2_chamfers_z;
MCNUM chamfers_lr = mccstraight_guide_2_2_chamfers_lr;
MCNUM chamfers_tb = mccstraight_guide_2_2_chamfers_tb;
MCNUM nelements = mccstraight_guide_2_2_nelements;
MCNUM nu = mccstraight_guide_2_2_nu;
MCNUM phase = mccstraight_guide_2_2_phase;
char* reflect = mccstraight_guide_2_2_reflect;
#line 412 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }
    
    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
//    if (ret==0) ABSORB; // RK-removed
    if (ret==0){ m_local_refl=-1; ABSORB; };//RK - added. Comment: didnt't reach the coating, setting m_local_refl=-1

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); // else if (angle) ABSORB; // RK - removed
    else if (angle) {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1    
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
     // ABSORB; // RK -removed 
    {m_local_refl=-1; ABSORB;} // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1 
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */
      m_local_refl=-1;// RK -added. Comment: just entered the component, haven't reach the coating yet. No absorption in the coating associated with the scattering. 
      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
   //     ABSORB; // RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  
     }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
//        ABSORB;// RK - removed
    m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);
	/* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
	if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; // ABSORB; // RK - statement removed
     m_local_refl=-1; ABSORB; // RK - added. Comment: didn't reach the coating, setting m_local_refl=-1  before absorbing
  } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        
        m_local_refl = GVars.M[side]; // RK - added line. 
	//RK - Comment: now we know that the neutron has hit the coating, so grabbing m-value of the side. m_local_refl will be modified for special cases under "if" statements below.

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; 
         m_local_refl=-1; // RK - added. Comment: neutron exiting the guide and not hitting the coating, setting m_local_refl=-1  before letting it out
        SCATTER; 
        x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on absorbing walls, setting m_local_refl=-1
	ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; 
	m_local_refl=-1; // RK - added. Comment: assuming no coating on chamfers, setting m_local_refl=-1
	ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];
	// RK - now we are hitting the coating, and the neutron may be either scattered or transmitted, the latter case is handled by ABSORB
        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 54032 "./ESS_BIFROST_shielding.c"
}   /* End of straight_guide_2_2=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompstraight_guide_2_2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(50,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component EndOfelement_2 [51] */
  mccoordschange(mcposrEndOfelement_2, mcrotrEndOfelement_2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component EndOfelement_2 (without coords transformations) */
  mcJumpTrace_EndOfelement_2:
  SIG_MESSAGE("EndOfelement_2 (Trace)");
  mcDEBUG_COMP("EndOfelement_2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompEndOfelement_2
  STORE_NEUTRON(51,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[51]++;
  mcPCounter[51] += p;
  mcP2Counter[51] += p*p;
#define mccompcurname  EndOfelement_2
#define mccompcurtype  Arm
#define mccompcurindex 51
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompEndOfelement_2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(51,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component elliptical_guide_gravity1_1 [52] */
  mccoordschange(mcposrelliptical_guide_gravity1_1, mcrotrelliptical_guide_gravity1_1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component elliptical_guide_gravity1_1 (without coords transformations) */
  mcJumpTrace_elliptical_guide_gravity1_1:
  SIG_MESSAGE("elliptical_guide_gravity1_1 (Trace)");
  mcDEBUG_COMP("elliptical_guide_gravity1_1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompelliptical_guide_gravity1_1
  STORE_NEUTRON(52,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[52]++;
  mcPCounter[52] += p;
  mcP2Counter[52] += p*p;
#define mccompcurname  elliptical_guide_gravity1_1
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 52
#define mvaluesright mccelliptical_guide_gravity1_1_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_1_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_1_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_1_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_1_seglength
#define guideInfo mccelliptical_guide_gravity1_1_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_1_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_1_Gx
#define Gy mccelliptical_guide_gravity1_1_Gy
#define Gz mccelliptical_guide_gravity1_1_Gz
#define Gx0 mccelliptical_guide_gravity1_1_Gx0
#define Gy0 mccelliptical_guide_gravity1_1_Gy0
#define Gz0 mccelliptical_guide_gravity1_1_Gz0
#define Circ mccelliptical_guide_gravity1_1_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_1_dynamicalSegLength
{   /* Declarations of elliptical_guide_gravity1_1=Elliptic_guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM l = mccelliptical_guide_gravity1_1_l;
MCNUM xwidth = mccelliptical_guide_gravity1_1_xwidth;
MCNUM yheight = mccelliptical_guide_gravity1_1_yheight;
MCNUM linxw = mccelliptical_guide_gravity1_1_linxw;
MCNUM loutxw = mccelliptical_guide_gravity1_1_loutxw;
MCNUM linyh = mccelliptical_guide_gravity1_1_linyh;
MCNUM loutyh = mccelliptical_guide_gravity1_1_loutyh;
MCNUM majorAxisxw = mccelliptical_guide_gravity1_1_majorAxisxw;
MCNUM minorAxisxw = mccelliptical_guide_gravity1_1_minorAxisxw;
MCNUM majorAxisyh = mccelliptical_guide_gravity1_1_majorAxisyh;
MCNUM minorAxisyh = mccelliptical_guide_gravity1_1_minorAxisyh;
MCNUM majorAxisoffsetxw = mccelliptical_guide_gravity1_1_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccelliptical_guide_gravity1_1_majorAxisoffsetyh;
char* dimensionsAt = mccelliptical_guide_gravity1_1_dimensionsAt;
char* option = mccelliptical_guide_gravity1_1_option;
MCNUM R0 = mccelliptical_guide_gravity1_1_R0;
MCNUM Qc = mccelliptical_guide_gravity1_1_Qc;
MCNUM alpha = mccelliptical_guide_gravity1_1_alpha;
MCNUM m = mccelliptical_guide_gravity1_1_m;
MCNUM W = mccelliptical_guide_gravity1_1_W;
MCNUM alpharight = mccelliptical_guide_gravity1_1_alpharight;
MCNUM mright = mccelliptical_guide_gravity1_1_mright;
MCNUM alphaleft = mccelliptical_guide_gravity1_1_alphaleft;
MCNUM mleft = mccelliptical_guide_gravity1_1_mleft;
MCNUM alphatop = mccelliptical_guide_gravity1_1_alphatop;
MCNUM mtop = mccelliptical_guide_gravity1_1_mtop;
MCNUM alphabottom = mccelliptical_guide_gravity1_1_alphabottom;
MCNUM mbottom = mccelliptical_guide_gravity1_1_mbottom;
char* verbose = mccelliptical_guide_gravity1_1_verbose;
MCNUM enableGravity = mccelliptical_guide_gravity1_1_enableGravity;
MCNUM curvature = mccelliptical_guide_gravity1_1_curvature;
#line 1432 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
{
  PROP_Z0;
  m_local_refl=-1; // RK - added. Comment: neutron entered the guide and hasn't reached the coating yet.
  SCATTER;
  
  double Gloc;
  if (curvature) {
    Gloc=(vx*vx+vy*vy+vz*vz)/curvature;
  } else {
    Gloc=0;
  }
  

	if( !guideInfo.EnclosingBoxOn )
		if( fabs(x) > guideInfo.entranceHorizontalWidth/2.0 
		    || fabs(y) > guideInfo.entranceVerticalWidth/2.0 ) 	{ m_local_refl=-1; // RK - added. 
	// RK - Comment: neutron doesn't make it to the guide opening, doesn't reach coating, setting m_local_refl=-1
		  ABSORB;}


	int bounces = 0;
	for(bounces = 0; bounces <= 1000; bounces++){
	//RK - Comment: now have entered the guide, will assign m_local_refl a value of the coating at the place of the hit.
	  Gx=Gx0; Gy=Gy0; Gz=Gz0;
	  if (curvature) {
	    // Add velocity-dependent, location-dependent approximation to centripetal force for curvature...
	    Gx=Gx0+Gloc*cos(2*PI*z/Circ);Gz=Gz0+Gloc*sin(2*PI*z/Circ);
	  }

		// Find the next intersection between the guide and the neutron.
		int boolean = guide_elliptical_handleGuideIntersection(
							x,y,z,vx,vy,vz,Gx,Gy,Gz,
							&guideInfo,&latestParticleCollision);

		double timeToCollision = 
				latestParticleCollision.delta_time_to_next_collision;

		// Handle special cases.
		//RK -- Comment: this happens when neutron hits precisely the corner of the guide. Assume no coating there
		if(boolean == 0) { m_local_refl=-1; ABSORB;} //if(boolean == 0) ABSORB; // RK -- modified line
		//RK -- Comment: this happens when neutron is travelling parallel to the wall. Assume absorption in the upper coating layer which amounts to setting m=1
		if(timeToCollision < 1e-15) { m_local_refl = 1; ABSORB;}  //if(timeToCollision < 1e-15) ABSORB; // RK -- modified line

		// If the neutron reach the end of the guide, when move 
		// the neutron to the end of guide and leave this component.
		if( z+vz*timeToCollision+0.5*Gz*timeToCollision*timeToCollision 
			>= guideInfo.Length )
		{
			double timeToExit = 0;
			solve_2nd_order(
					&timeToExit,NULL,
					-0.5*Gz,-vz,guideInfo.Length-z-1e-9);
			PROP_GRAV_DT(timeToExit,Gx,Gy,Gz);
			m_local_refl=-1; // RK - added. Comment: exiting guide, no scattering on the coating
			SCATTER;
			break;
		}

		// Move the neutron and handle the reflection.
		PROP_GRAV_DT(timeToCollision,Gx,Gy,Gz);
/*** RK now we are at the point of reflection, have to figure out what the m-value is here. ***/
  if(!guideInfo.enableSegments){
			m_local_refl=guideInfo.mArr[latestParticleCollision.side];
		   }
	else{
    	int currentSegment;
    	double combinedLength = 0;
    	int i;
    	for(i=0; i < guideInfo.numberOfSegments; i++){
    		combinedLength = combinedLength + guideInfo.segLength[i];
    		if(z < combinedLength)	{
    			currentSegment = i; break;
    		}
    	}

		if(latestParticleCollision.side == RightSide)
					m_local_refl = guideInfo.mValuesright[currentSegment];
		if(latestParticleCollision.side == LeftSide)
					m_local_refl=guideInfo.mValuesleft[currentSegment];
		if(latestParticleCollision.side == TopSide)
					m_local_refl = guideInfo.mValuestop[currentSegment];
		if(latestParticleCollision.side == BottomSide)
					m_local_refl = guideInfo.mValuesbottom[currentSegment];
    }
/*****/
		if(latestParticleCollision.collisionType == Absorb){ ABSORB; }
		if(latestParticleCollision.collisionType == Reflex){
			p *= guide_elliptical_handleReflection(x,y,z,&vx,&vy,&vz,
						&guideInfo,&latestParticleCollision); 
			SCATTER;
			if(p == 0) ABSORB; 
		}
	}
	// RK -- this happens when neutron didn't exit after 1000 bounces which is unrealistic situation. m_local_refl remains set to the m-value at last revlection.
	if( fabs(x) > guideInfo.exitHorizontalWidth/2 
	 || fabs(y) > guideInfo.exitVerticalWidth/2 )
		ABSORB;
	
}
#line 54389 "./ESS_BIFROST_shielding.c"
}   /* End of elliptical_guide_gravity1_1=Elliptic_guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompelliptical_guide_gravity1_1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(52,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component DiwJaw3 [53] */
  mccoordschange(mcposrDiwJaw3, mcrotrDiwJaw3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component DiwJaw3 (without coords transformations) */
  mcJumpTrace_DiwJaw3:
  SIG_MESSAGE("DiwJaw3 (Trace)");
  mcDEBUG_COMP("DiwJaw3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDiwJaw3
  STORE_NEUTRON(53,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[53]++;
  mcPCounter[53] += p;
  mcP2Counter[53] += p*p;
#define mccompcurname  DiwJaw3
#define mccompcurtype  Slit
#define mccompcurindex 53
{   /* Declarations of DiwJaw3=Slit() SETTING parameters. */
MCNUM xmin = mccDiwJaw3_xmin;
MCNUM xmax = mccDiwJaw3_xmax;
MCNUM ymin = mccDiwJaw3_ymin;
MCNUM ymax = mccDiwJaw3_ymax;
MCNUM radius = mccDiwJaw3_radius;
MCNUM xwidth = mccDiwJaw3_xwidth;
MCNUM yheight = mccDiwJaw3_yheight;
#line 71 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Slit.comp"
{
    PROP_Z0;
    if (((radius == 0) && (x<xmin || x>xmax || y<ymin || y>ymax))
	|| ((radius != 0) && (x*x + y*y > radius*radius))) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
      ABSORB;
    }
    else
        SCATTER;
}
#line 54528 "./ESS_BIFROST_shielding.c"
}   /* End of DiwJaw3=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDiwJaw3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(53,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component elliptical_guide_gravity1_2 [54] */
  mccoordschange(mcposrelliptical_guide_gravity1_2, mcrotrelliptical_guide_gravity1_2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component elliptical_guide_gravity1_2 (without coords transformations) */
  mcJumpTrace_elliptical_guide_gravity1_2:
  SIG_MESSAGE("elliptical_guide_gravity1_2 (Trace)");
  mcDEBUG_COMP("elliptical_guide_gravity1_2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompelliptical_guide_gravity1_2
  STORE_NEUTRON(54,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[54]++;
  mcPCounter[54] += p;
  mcP2Counter[54] += p*p;
#define mccompcurname  elliptical_guide_gravity1_2
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 54
#define mvaluesright mccelliptical_guide_gravity1_2_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_2_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_2_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_2_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_2_seglength
#define guideInfo mccelliptical_guide_gravity1_2_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_2_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_2_Gx
#define Gy mccelliptical_guide_gravity1_2_Gy
#define Gz mccelliptical_guide_gravity1_2_Gz
#define Gx0 mccelliptical_guide_gravity1_2_Gx0
#define Gy0 mccelliptical_guide_gravity1_2_Gy0
#define Gz0 mccelliptical_guide_gravity1_2_Gz0
#define Circ mccelliptical_guide_gravity1_2_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_2_dynamicalSegLength
{   /* Declarations of elliptical_guide_gravity1_2=Elliptic_guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM l = mccelliptical_guide_gravity1_2_l;
MCNUM xwidth = mccelliptical_guide_gravity1_2_xwidth;
MCNUM yheight = mccelliptical_guide_gravity1_2_yheight;
MCNUM linxw = mccelliptical_guide_gravity1_2_linxw;
MCNUM loutxw = mccelliptical_guide_gravity1_2_loutxw;
MCNUM linyh = mccelliptical_guide_gravity1_2_linyh;
MCNUM loutyh = mccelliptical_guide_gravity1_2_loutyh;
MCNUM majorAxisxw = mccelliptical_guide_gravity1_2_majorAxisxw;
MCNUM minorAxisxw = mccelliptical_guide_gravity1_2_minorAxisxw;
MCNUM majorAxisyh = mccelliptical_guide_gravity1_2_majorAxisyh;
MCNUM minorAxisyh = mccelliptical_guide_gravity1_2_minorAxisyh;
MCNUM majorAxisoffsetxw = mccelliptical_guide_gravity1_2_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccelliptical_guide_gravity1_2_majorAxisoffsetyh;
char* dimensionsAt = mccelliptical_guide_gravity1_2_dimensionsAt;
char* option = mccelliptical_guide_gravity1_2_option;
MCNUM R0 = mccelliptical_guide_gravity1_2_R0;
MCNUM Qc = mccelliptical_guide_gravity1_2_Qc;
MCNUM alpha = mccelliptical_guide_gravity1_2_alpha;
MCNUM m = mccelliptical_guide_gravity1_2_m;
MCNUM W = mccelliptical_guide_gravity1_2_W;
MCNUM alpharight = mccelliptical_guide_gravity1_2_alpharight;
MCNUM mright = mccelliptical_guide_gravity1_2_mright;
MCNUM alphaleft = mccelliptical_guide_gravity1_2_alphaleft;
MCNUM mleft = mccelliptical_guide_gravity1_2_mleft;
MCNUM alphatop = mccelliptical_guide_gravity1_2_alphatop;
MCNUM mtop = mccelliptical_guide_gravity1_2_mtop;
MCNUM alphabottom = mccelliptical_guide_gravity1_2_alphabottom;
MCNUM mbottom = mccelliptical_guide_gravity1_2_mbottom;
char* verbose = mccelliptical_guide_gravity1_2_verbose;
MCNUM enableGravity = mccelliptical_guide_gravity1_2_enableGravity;
MCNUM curvature = mccelliptical_guide_gravity1_2_curvature;
#line 1432 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
{
  PROP_Z0;
  m_local_refl=-1; // RK - added. Comment: neutron entered the guide and hasn't reached the coating yet.
  SCATTER;
  
  double Gloc;
  if (curvature) {
    Gloc=(vx*vx+vy*vy+vz*vz)/curvature;
  } else {
    Gloc=0;
  }
  

	if( !guideInfo.EnclosingBoxOn )
		if( fabs(x) > guideInfo.entranceHorizontalWidth/2.0 
		    || fabs(y) > guideInfo.entranceVerticalWidth/2.0 ) 	{ m_local_refl=-1; // RK - added. 
	// RK - Comment: neutron doesn't make it to the guide opening, doesn't reach coating, setting m_local_refl=-1
		  ABSORB;}


	int bounces = 0;
	for(bounces = 0; bounces <= 1000; bounces++){
	//RK - Comment: now have entered the guide, will assign m_local_refl a value of the coating at the place of the hit.
	  Gx=Gx0; Gy=Gy0; Gz=Gz0;
	  if (curvature) {
	    // Add velocity-dependent, location-dependent approximation to centripetal force for curvature...
	    Gx=Gx0+Gloc*cos(2*PI*z/Circ);Gz=Gz0+Gloc*sin(2*PI*z/Circ);
	  }

		// Find the next intersection between the guide and the neutron.
		int boolean = guide_elliptical_handleGuideIntersection(
							x,y,z,vx,vy,vz,Gx,Gy,Gz,
							&guideInfo,&latestParticleCollision);

		double timeToCollision = 
				latestParticleCollision.delta_time_to_next_collision;

		// Handle special cases.
		//RK -- Comment: this happens when neutron hits precisely the corner of the guide. Assume no coating there
		if(boolean == 0) { m_local_refl=-1; ABSORB;} //if(boolean == 0) ABSORB; // RK -- modified line
		//RK -- Comment: this happens when neutron is travelling parallel to the wall. Assume absorption in the upper coating layer which amounts to setting m=1
		if(timeToCollision < 1e-15) { m_local_refl = 1; ABSORB;}  //if(timeToCollision < 1e-15) ABSORB; // RK -- modified line

		// If the neutron reach the end of the guide, when move 
		// the neutron to the end of guide and leave this component.
		if( z+vz*timeToCollision+0.5*Gz*timeToCollision*timeToCollision 
			>= guideInfo.Length )
		{
			double timeToExit = 0;
			solve_2nd_order(
					&timeToExit,NULL,
					-0.5*Gz,-vz,guideInfo.Length-z-1e-9);
			PROP_GRAV_DT(timeToExit,Gx,Gy,Gz);
			m_local_refl=-1; // RK - added. Comment: exiting guide, no scattering on the coating
			SCATTER;
			break;
		}

		// Move the neutron and handle the reflection.
		PROP_GRAV_DT(timeToCollision,Gx,Gy,Gz);
/*** RK now we are at the point of reflection, have to figure out what the m-value is here. ***/
  if(!guideInfo.enableSegments){
			m_local_refl=guideInfo.mArr[latestParticleCollision.side];
		   }
	else{
    	int currentSegment;
    	double combinedLength = 0;
    	int i;
    	for(i=0; i < guideInfo.numberOfSegments; i++){
    		combinedLength = combinedLength + guideInfo.segLength[i];
    		if(z < combinedLength)	{
    			currentSegment = i; break;
    		}
    	}

		if(latestParticleCollision.side == RightSide)
					m_local_refl = guideInfo.mValuesright[currentSegment];
		if(latestParticleCollision.side == LeftSide)
					m_local_refl=guideInfo.mValuesleft[currentSegment];
		if(latestParticleCollision.side == TopSide)
					m_local_refl = guideInfo.mValuestop[currentSegment];
		if(latestParticleCollision.side == BottomSide)
					m_local_refl = guideInfo.mValuesbottom[currentSegment];
    }
/*****/
		if(latestParticleCollision.collisionType == Absorb){ ABSORB; }
		if(latestParticleCollision.collisionType == Reflex){
			p *= guide_elliptical_handleReflection(x,y,z,&vx,&vy,&vz,
						&guideInfo,&latestParticleCollision); 
			SCATTER;
			if(p == 0) ABSORB; 
		}
	}
	// RK -- this happens when neutron didn't exit after 1000 bounces which is unrealistic situation. m_local_refl remains set to the m-value at last revlection.
	if( fabs(x) > guideInfo.exitHorizontalWidth/2 
	 || fabs(y) > guideInfo.exitVerticalWidth/2 )
		ABSORB;
	
}
#line 54780 "./ESS_BIFROST_shielding.c"
}   /* End of elliptical_guide_gravity1_2=Elliptic_guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompelliptical_guide_gravity1_2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(54,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component DiwJaw2 [55] */
  mccoordschange(mcposrDiwJaw2, mcrotrDiwJaw2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component DiwJaw2 (without coords transformations) */
  mcJumpTrace_DiwJaw2:
  SIG_MESSAGE("DiwJaw2 (Trace)");
  mcDEBUG_COMP("DiwJaw2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDiwJaw2
  STORE_NEUTRON(55,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[55]++;
  mcPCounter[55] += p;
  mcP2Counter[55] += p*p;
#define mccompcurname  DiwJaw2
#define mccompcurtype  Slit
#define mccompcurindex 55
{   /* Declarations of DiwJaw2=Slit() SETTING parameters. */
MCNUM xmin = mccDiwJaw2_xmin;
MCNUM xmax = mccDiwJaw2_xmax;
MCNUM ymin = mccDiwJaw2_ymin;
MCNUM ymax = mccDiwJaw2_ymax;
MCNUM radius = mccDiwJaw2_radius;
MCNUM xwidth = mccDiwJaw2_xwidth;
MCNUM yheight = mccDiwJaw2_yheight;
#line 71 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Slit.comp"
{
    PROP_Z0;
    if (((radius == 0) && (x<xmin || x>xmax || y<ymin || y>ymax))
	|| ((radius != 0) && (x*x + y*y > radius*radius))) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
      ABSORB;
    }
    else
        SCATTER;
}
#line 54919 "./ESS_BIFROST_shielding.c"
}   /* End of DiwJaw2=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDiwJaw2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(55,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component elliptical_guide_gravity1_3 [56] */
  mccoordschange(mcposrelliptical_guide_gravity1_3, mcrotrelliptical_guide_gravity1_3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component elliptical_guide_gravity1_3 (without coords transformations) */
  mcJumpTrace_elliptical_guide_gravity1_3:
  SIG_MESSAGE("elliptical_guide_gravity1_3 (Trace)");
  mcDEBUG_COMP("elliptical_guide_gravity1_3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompelliptical_guide_gravity1_3
  STORE_NEUTRON(56,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[56]++;
  mcPCounter[56] += p;
  mcP2Counter[56] += p*p;
#define mccompcurname  elliptical_guide_gravity1_3
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 56
#define mvaluesright mccelliptical_guide_gravity1_3_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_3_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_3_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_3_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_3_seglength
#define guideInfo mccelliptical_guide_gravity1_3_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_3_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_3_Gx
#define Gy mccelliptical_guide_gravity1_3_Gy
#define Gz mccelliptical_guide_gravity1_3_Gz
#define Gx0 mccelliptical_guide_gravity1_3_Gx0
#define Gy0 mccelliptical_guide_gravity1_3_Gy0
#define Gz0 mccelliptical_guide_gravity1_3_Gz0
#define Circ mccelliptical_guide_gravity1_3_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_3_dynamicalSegLength
{   /* Declarations of elliptical_guide_gravity1_3=Elliptic_guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM l = mccelliptical_guide_gravity1_3_l;
MCNUM xwidth = mccelliptical_guide_gravity1_3_xwidth;
MCNUM yheight = mccelliptical_guide_gravity1_3_yheight;
MCNUM linxw = mccelliptical_guide_gravity1_3_linxw;
MCNUM loutxw = mccelliptical_guide_gravity1_3_loutxw;
MCNUM linyh = mccelliptical_guide_gravity1_3_linyh;
MCNUM loutyh = mccelliptical_guide_gravity1_3_loutyh;
MCNUM majorAxisxw = mccelliptical_guide_gravity1_3_majorAxisxw;
MCNUM minorAxisxw = mccelliptical_guide_gravity1_3_minorAxisxw;
MCNUM majorAxisyh = mccelliptical_guide_gravity1_3_majorAxisyh;
MCNUM minorAxisyh = mccelliptical_guide_gravity1_3_minorAxisyh;
MCNUM majorAxisoffsetxw = mccelliptical_guide_gravity1_3_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccelliptical_guide_gravity1_3_majorAxisoffsetyh;
char* dimensionsAt = mccelliptical_guide_gravity1_3_dimensionsAt;
char* option = mccelliptical_guide_gravity1_3_option;
MCNUM R0 = mccelliptical_guide_gravity1_3_R0;
MCNUM Qc = mccelliptical_guide_gravity1_3_Qc;
MCNUM alpha = mccelliptical_guide_gravity1_3_alpha;
MCNUM m = mccelliptical_guide_gravity1_3_m;
MCNUM W = mccelliptical_guide_gravity1_3_W;
MCNUM alpharight = mccelliptical_guide_gravity1_3_alpharight;
MCNUM mright = mccelliptical_guide_gravity1_3_mright;
MCNUM alphaleft = mccelliptical_guide_gravity1_3_alphaleft;
MCNUM mleft = mccelliptical_guide_gravity1_3_mleft;
MCNUM alphatop = mccelliptical_guide_gravity1_3_alphatop;
MCNUM mtop = mccelliptical_guide_gravity1_3_mtop;
MCNUM alphabottom = mccelliptical_guide_gravity1_3_alphabottom;
MCNUM mbottom = mccelliptical_guide_gravity1_3_mbottom;
char* verbose = mccelliptical_guide_gravity1_3_verbose;
MCNUM enableGravity = mccelliptical_guide_gravity1_3_enableGravity;
MCNUM curvature = mccelliptical_guide_gravity1_3_curvature;
#line 1432 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
{
  PROP_Z0;
  m_local_refl=-1; // RK - added. Comment: neutron entered the guide and hasn't reached the coating yet.
  SCATTER;
  
  double Gloc;
  if (curvature) {
    Gloc=(vx*vx+vy*vy+vz*vz)/curvature;
  } else {
    Gloc=0;
  }
  

	if( !guideInfo.EnclosingBoxOn )
		if( fabs(x) > guideInfo.entranceHorizontalWidth/2.0 
		    || fabs(y) > guideInfo.entranceVerticalWidth/2.0 ) 	{ m_local_refl=-1; // RK - added. 
	// RK - Comment: neutron doesn't make it to the guide opening, doesn't reach coating, setting m_local_refl=-1
		  ABSORB;}


	int bounces = 0;
	for(bounces = 0; bounces <= 1000; bounces++){
	//RK - Comment: now have entered the guide, will assign m_local_refl a value of the coating at the place of the hit.
	  Gx=Gx0; Gy=Gy0; Gz=Gz0;
	  if (curvature) {
	    // Add velocity-dependent, location-dependent approximation to centripetal force for curvature...
	    Gx=Gx0+Gloc*cos(2*PI*z/Circ);Gz=Gz0+Gloc*sin(2*PI*z/Circ);
	  }

		// Find the next intersection between the guide and the neutron.
		int boolean = guide_elliptical_handleGuideIntersection(
							x,y,z,vx,vy,vz,Gx,Gy,Gz,
							&guideInfo,&latestParticleCollision);

		double timeToCollision = 
				latestParticleCollision.delta_time_to_next_collision;

		// Handle special cases.
		//RK -- Comment: this happens when neutron hits precisely the corner of the guide. Assume no coating there
		if(boolean == 0) { m_local_refl=-1; ABSORB;} //if(boolean == 0) ABSORB; // RK -- modified line
		//RK -- Comment: this happens when neutron is travelling parallel to the wall. Assume absorption in the upper coating layer which amounts to setting m=1
		if(timeToCollision < 1e-15) { m_local_refl = 1; ABSORB;}  //if(timeToCollision < 1e-15) ABSORB; // RK -- modified line

		// If the neutron reach the end of the guide, when move 
		// the neutron to the end of guide and leave this component.
		if( z+vz*timeToCollision+0.5*Gz*timeToCollision*timeToCollision 
			>= guideInfo.Length )
		{
			double timeToExit = 0;
			solve_2nd_order(
					&timeToExit,NULL,
					-0.5*Gz,-vz,guideInfo.Length-z-1e-9);
			PROP_GRAV_DT(timeToExit,Gx,Gy,Gz);
			m_local_refl=-1; // RK - added. Comment: exiting guide, no scattering on the coating
			SCATTER;
			break;
		}

		// Move the neutron and handle the reflection.
		PROP_GRAV_DT(timeToCollision,Gx,Gy,Gz);
/*** RK now we are at the point of reflection, have to figure out what the m-value is here. ***/
  if(!guideInfo.enableSegments){
			m_local_refl=guideInfo.mArr[latestParticleCollision.side];
		   }
	else{
    	int currentSegment;
    	double combinedLength = 0;
    	int i;
    	for(i=0; i < guideInfo.numberOfSegments; i++){
    		combinedLength = combinedLength + guideInfo.segLength[i];
    		if(z < combinedLength)	{
    			currentSegment = i; break;
    		}
    	}

		if(latestParticleCollision.side == RightSide)
					m_local_refl = guideInfo.mValuesright[currentSegment];
		if(latestParticleCollision.side == LeftSide)
					m_local_refl=guideInfo.mValuesleft[currentSegment];
		if(latestParticleCollision.side == TopSide)
					m_local_refl = guideInfo.mValuestop[currentSegment];
		if(latestParticleCollision.side == BottomSide)
					m_local_refl = guideInfo.mValuesbottom[currentSegment];
    }
/*****/
		if(latestParticleCollision.collisionType == Absorb){ ABSORB; }
		if(latestParticleCollision.collisionType == Reflex){
			p *= guide_elliptical_handleReflection(x,y,z,&vx,&vy,&vz,
						&guideInfo,&latestParticleCollision); 
			SCATTER;
			if(p == 0) ABSORB; 
		}
	}
	// RK -- this happens when neutron didn't exit after 1000 bounces which is unrealistic situation. m_local_refl remains set to the m-value at last revlection.
	if( fabs(x) > guideInfo.exitHorizontalWidth/2 
	 || fabs(y) > guideInfo.exitVerticalWidth/2 )
		ABSORB;
	
}
#line 55171 "./ESS_BIFROST_shielding.c"
}   /* End of elliptical_guide_gravity1_3=Elliptic_guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompelliptical_guide_gravity1_3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(56,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component DiwJaw1 [57] */
  mccoordschange(mcposrDiwJaw1, mcrotrDiwJaw1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component DiwJaw1 (without coords transformations) */
  mcJumpTrace_DiwJaw1:
  SIG_MESSAGE("DiwJaw1 (Trace)");
  mcDEBUG_COMP("DiwJaw1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDiwJaw1
  STORE_NEUTRON(57,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[57]++;
  mcPCounter[57] += p;
  mcP2Counter[57] += p*p;
#define mccompcurname  DiwJaw1
#define mccompcurtype  Slit
#define mccompcurindex 57
{   /* Declarations of DiwJaw1=Slit() SETTING parameters. */
MCNUM xmin = mccDiwJaw1_xmin;
MCNUM xmax = mccDiwJaw1_xmax;
MCNUM ymin = mccDiwJaw1_ymin;
MCNUM ymax = mccDiwJaw1_ymax;
MCNUM radius = mccDiwJaw1_radius;
MCNUM xwidth = mccDiwJaw1_xwidth;
MCNUM yheight = mccDiwJaw1_yheight;
#line 71 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Slit.comp"
{
    PROP_Z0;
    if (((radius == 0) && (x<xmin || x>xmax || y<ymin || y>ymax))
	|| ((radius != 0) && (x*x + y*y > radius*radius))) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
      ABSORB;
    }
    else
        SCATTER;
}
#line 55310 "./ESS_BIFROST_shielding.c"
}   /* End of DiwJaw1=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDiwJaw1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(57,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component elliptical_guide_gravity1_4 [58] */
  mccoordschange(mcposrelliptical_guide_gravity1_4, mcrotrelliptical_guide_gravity1_4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component elliptical_guide_gravity1_4 (without coords transformations) */
  mcJumpTrace_elliptical_guide_gravity1_4:
  SIG_MESSAGE("elliptical_guide_gravity1_4 (Trace)");
  mcDEBUG_COMP("elliptical_guide_gravity1_4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompelliptical_guide_gravity1_4
  STORE_NEUTRON(58,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[58]++;
  mcPCounter[58] += p;
  mcP2Counter[58] += p*p;
#define mccompcurname  elliptical_guide_gravity1_4
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 58
#define mvaluesright mccelliptical_guide_gravity1_4_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_4_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_4_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_4_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_4_seglength
#define guideInfo mccelliptical_guide_gravity1_4_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_4_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_4_Gx
#define Gy mccelliptical_guide_gravity1_4_Gy
#define Gz mccelliptical_guide_gravity1_4_Gz
#define Gx0 mccelliptical_guide_gravity1_4_Gx0
#define Gy0 mccelliptical_guide_gravity1_4_Gy0
#define Gz0 mccelliptical_guide_gravity1_4_Gz0
#define Circ mccelliptical_guide_gravity1_4_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_4_dynamicalSegLength
{   /* Declarations of elliptical_guide_gravity1_4=Elliptic_guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM l = mccelliptical_guide_gravity1_4_l;
MCNUM xwidth = mccelliptical_guide_gravity1_4_xwidth;
MCNUM yheight = mccelliptical_guide_gravity1_4_yheight;
MCNUM linxw = mccelliptical_guide_gravity1_4_linxw;
MCNUM loutxw = mccelliptical_guide_gravity1_4_loutxw;
MCNUM linyh = mccelliptical_guide_gravity1_4_linyh;
MCNUM loutyh = mccelliptical_guide_gravity1_4_loutyh;
MCNUM majorAxisxw = mccelliptical_guide_gravity1_4_majorAxisxw;
MCNUM minorAxisxw = mccelliptical_guide_gravity1_4_minorAxisxw;
MCNUM majorAxisyh = mccelliptical_guide_gravity1_4_majorAxisyh;
MCNUM minorAxisyh = mccelliptical_guide_gravity1_4_minorAxisyh;
MCNUM majorAxisoffsetxw = mccelliptical_guide_gravity1_4_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccelliptical_guide_gravity1_4_majorAxisoffsetyh;
char* dimensionsAt = mccelliptical_guide_gravity1_4_dimensionsAt;
char* option = mccelliptical_guide_gravity1_4_option;
MCNUM R0 = mccelliptical_guide_gravity1_4_R0;
MCNUM Qc = mccelliptical_guide_gravity1_4_Qc;
MCNUM alpha = mccelliptical_guide_gravity1_4_alpha;
MCNUM m = mccelliptical_guide_gravity1_4_m;
MCNUM W = mccelliptical_guide_gravity1_4_W;
MCNUM alpharight = mccelliptical_guide_gravity1_4_alpharight;
MCNUM mright = mccelliptical_guide_gravity1_4_mright;
MCNUM alphaleft = mccelliptical_guide_gravity1_4_alphaleft;
MCNUM mleft = mccelliptical_guide_gravity1_4_mleft;
MCNUM alphatop = mccelliptical_guide_gravity1_4_alphatop;
MCNUM mtop = mccelliptical_guide_gravity1_4_mtop;
MCNUM alphabottom = mccelliptical_guide_gravity1_4_alphabottom;
MCNUM mbottom = mccelliptical_guide_gravity1_4_mbottom;
char* verbose = mccelliptical_guide_gravity1_4_verbose;
MCNUM enableGravity = mccelliptical_guide_gravity1_4_enableGravity;
MCNUM curvature = mccelliptical_guide_gravity1_4_curvature;
#line 1432 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
{
  PROP_Z0;
  m_local_refl=-1; // RK - added. Comment: neutron entered the guide and hasn't reached the coating yet.
  SCATTER;
  
  double Gloc;
  if (curvature) {
    Gloc=(vx*vx+vy*vy+vz*vz)/curvature;
  } else {
    Gloc=0;
  }
  

	if( !guideInfo.EnclosingBoxOn )
		if( fabs(x) > guideInfo.entranceHorizontalWidth/2.0 
		    || fabs(y) > guideInfo.entranceVerticalWidth/2.0 ) 	{ m_local_refl=-1; // RK - added. 
	// RK - Comment: neutron doesn't make it to the guide opening, doesn't reach coating, setting m_local_refl=-1
		  ABSORB;}


	int bounces = 0;
	for(bounces = 0; bounces <= 1000; bounces++){
	//RK - Comment: now have entered the guide, will assign m_local_refl a value of the coating at the place of the hit.
	  Gx=Gx0; Gy=Gy0; Gz=Gz0;
	  if (curvature) {
	    // Add velocity-dependent, location-dependent approximation to centripetal force for curvature...
	    Gx=Gx0+Gloc*cos(2*PI*z/Circ);Gz=Gz0+Gloc*sin(2*PI*z/Circ);
	  }

		// Find the next intersection between the guide and the neutron.
		int boolean = guide_elliptical_handleGuideIntersection(
							x,y,z,vx,vy,vz,Gx,Gy,Gz,
							&guideInfo,&latestParticleCollision);

		double timeToCollision = 
				latestParticleCollision.delta_time_to_next_collision;

		// Handle special cases.
		//RK -- Comment: this happens when neutron hits precisely the corner of the guide. Assume no coating there
		if(boolean == 0) { m_local_refl=-1; ABSORB;} //if(boolean == 0) ABSORB; // RK -- modified line
		//RK -- Comment: this happens when neutron is travelling parallel to the wall. Assume absorption in the upper coating layer which amounts to setting m=1
		if(timeToCollision < 1e-15) { m_local_refl = 1; ABSORB;}  //if(timeToCollision < 1e-15) ABSORB; // RK -- modified line

		// If the neutron reach the end of the guide, when move 
		// the neutron to the end of guide and leave this component.
		if( z+vz*timeToCollision+0.5*Gz*timeToCollision*timeToCollision 
			>= guideInfo.Length )
		{
			double timeToExit = 0;
			solve_2nd_order(
					&timeToExit,NULL,
					-0.5*Gz,-vz,guideInfo.Length-z-1e-9);
			PROP_GRAV_DT(timeToExit,Gx,Gy,Gz);
			m_local_refl=-1; // RK - added. Comment: exiting guide, no scattering on the coating
			SCATTER;
			break;
		}

		// Move the neutron and handle the reflection.
		PROP_GRAV_DT(timeToCollision,Gx,Gy,Gz);
/*** RK now we are at the point of reflection, have to figure out what the m-value is here. ***/
  if(!guideInfo.enableSegments){
			m_local_refl=guideInfo.mArr[latestParticleCollision.side];
		   }
	else{
    	int currentSegment;
    	double combinedLength = 0;
    	int i;
    	for(i=0; i < guideInfo.numberOfSegments; i++){
    		combinedLength = combinedLength + guideInfo.segLength[i];
    		if(z < combinedLength)	{
    			currentSegment = i; break;
    		}
    	}

		if(latestParticleCollision.side == RightSide)
					m_local_refl = guideInfo.mValuesright[currentSegment];
		if(latestParticleCollision.side == LeftSide)
					m_local_refl=guideInfo.mValuesleft[currentSegment];
		if(latestParticleCollision.side == TopSide)
					m_local_refl = guideInfo.mValuestop[currentSegment];
		if(latestParticleCollision.side == BottomSide)
					m_local_refl = guideInfo.mValuesbottom[currentSegment];
    }
/*****/
		if(latestParticleCollision.collisionType == Absorb){ ABSORB; }
		if(latestParticleCollision.collisionType == Reflex){
			p *= guide_elliptical_handleReflection(x,y,z,&vx,&vy,&vz,
						&guideInfo,&latestParticleCollision); 
			SCATTER;
			if(p == 0) ABSORB; 
		}
	}
	// RK -- this happens when neutron didn't exit after 1000 bounces which is unrealistic situation. m_local_refl remains set to the m-value at last revlection.
	if( fabs(x) > guideInfo.exitHorizontalWidth/2 
	 || fabs(y) > guideInfo.exitVerticalWidth/2 )
		ABSORB;
	
}
#line 55562 "./ESS_BIFROST_shielding.c"
}   /* End of elliptical_guide_gravity1_4=Elliptic_guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompelliptical_guide_gravity1_4:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(58,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component EndOfelement_1 [59] */
  mccoordschange(mcposrEndOfelement_1, mcrotrEndOfelement_1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component EndOfelement_1 (without coords transformations) */
  mcJumpTrace_EndOfelement_1:
  SIG_MESSAGE("EndOfelement_1 (Trace)");
  mcDEBUG_COMP("EndOfelement_1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompEndOfelement_1
  STORE_NEUTRON(59,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[59]++;
  mcPCounter[59] += p;
  mcP2Counter[59] += p*p;
#define mccompcurname  EndOfelement_1
#define mccompcurtype  Arm
#define mccompcurindex 59
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompEndOfelement_1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(59,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component VirtualOutput [60] */
  mccoordschange(mcposrVirtualOutput, mcrotrVirtualOutput,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component VirtualOutput (without coords transformations) */
  mcJumpTrace_VirtualOutput:
  SIG_MESSAGE("VirtualOutput (Trace)");
  mcDEBUG_COMP("VirtualOutput")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompVirtualOutput
  STORE_NEUTRON(60,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[60]++;
  mcPCounter[60] += p;
  mcP2Counter[60] += p*p;
#define mccompcurname  VirtualOutput
#define mccompcurtype  Virtual_output
#define mccompcurindex 60
#define DEFS mccVirtualOutput_DEFS
#define Vars mccVirtualOutput_Vars
{   /* Declarations of VirtualOutput=Virtual_output() SETTING parameters. */
char* filename = mccVirtualOutput_filename;
MCNUM bufsize = mccVirtualOutput_bufsize;
/* 'VirtualOutput=Virtual_output()' component instance has conditional execution */
if (( mcipmakeVirtualSource == 1 ))

#line 102 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../sources/Virtual_output.comp"
{
  double pp=0;

  /* PROP_Z0; */
  /* transfer current neutron to Monitor_nD vars */
  Vars.cp  = p;
  Vars.cx  = x;
  Vars.cvx = vx;
  Vars.csx = sx;
  Vars.cy  = y;
  Vars.cvy = vy;
  Vars.csy = sy;
  Vars.cz  = z;
  Vars.cvz = vz;
  Vars.csz = sz;
  Vars.ct  = t;

  pp = Monitor_nD_Trace(&DEFS, &Vars, _particle);

  SCATTER;
}
#line 55814 "./ESS_BIFROST_shielding.c"
}   /* End of VirtualOutput=Virtual_output() SETTING parameter declarations. */
#undef Vars
#undef DEFS
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompVirtualOutput:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(60,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component DiwJaw0 [61] */
  mccoordschange(mcposrDiwJaw0, mcrotrDiwJaw0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component DiwJaw0 (without coords transformations) */
  mcJumpTrace_DiwJaw0:
  SIG_MESSAGE("DiwJaw0 (Trace)");
  mcDEBUG_COMP("DiwJaw0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDiwJaw0
  STORE_NEUTRON(61,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[61]++;
  mcPCounter[61] += p;
  mcP2Counter[61] += p*p;
#define mccompcurname  DiwJaw0
#define mccompcurtype  Slit
#define mccompcurindex 61
{   /* Declarations of DiwJaw0=Slit() SETTING parameters. */
MCNUM xmin = mccDiwJaw0_xmin;
MCNUM xmax = mccDiwJaw0_xmax;
MCNUM ymin = mccDiwJaw0_ymin;
MCNUM ymax = mccDiwJaw0_ymax;
MCNUM radius = mccDiwJaw0_radius;
MCNUM xwidth = mccDiwJaw0_xwidth;
MCNUM yheight = mccDiwJaw0_yheight;
#line 71 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Slit.comp"
{
    PROP_Z0;
    if (((radius == 0) && (x<xmin || x>xmax || y<ymin || y>ymax))
	|| ((radius != 0) && (x*x + y*y > radius*radius))) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
      ABSORB;
    }
    else
        SCATTER;
}
#line 55940 "./ESS_BIFROST_shielding.c"
}   /* End of DiwJaw0=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDiwJaw0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(61,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component log_P_stop [62] */
  mccoordschange(mcposrlog_P_stop, mcrotrlog_P_stop,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component log_P_stop (without coords transformations) */
  mcJumpTrace_log_P_stop:
  SIG_MESSAGE("log_P_stop (Trace)");
  mcDEBUG_COMP("log_P_stop")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComplog_P_stop
  STORE_NEUTRON(62,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[62]++;
  mcPCounter[62] += p;
  mcP2Counter[62] += p*p;
#define mccompcurname  log_P_stop
#define mccompcurtype  Shielding_logger_stop
#define mccompcurindex 62
#define logger mcclog_P_stop_logger
#line 63 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_logger_stop.comp"
{

#undef SCATTER
#define SCATTER SCATTER0

#undef ABSORB
#define ABSORB ABSORB0

#undef mcabsorb
#define mcabsorb mcabsorbAll

#ifdef scatter_logger_stop
#undef scatter_logger_stop
#endif

#define scatter_logger_stop logger
scatter_logger_stop:
    
  if (bounce_store_index<BOUNCE_LOG_SIZE){
    struct Generalized_State_t *bp;
    bp=&(Bounce_store[bounce_store_index]);
    bp->_x=0;
    bp->_y=0;
    bp->_z=0;
    bp->_vx=0;
    bp->_vy=0;
    bp->_vz=0;
    bp->_sx=0;
    bp->_sy=0;
    bp->_sz=0;
    bp->_t=0;
    if(absorbed_in_optics==1) bp->_p=-2; else bp->_p=-1;
    bp->_nid=0; 
    bp->_comp=0;
    bounce_store_index++;
  }else if(bounce_store_index==BOUNCE_LOG_SIZE && !bounce_store_overrun){
    printf("Warning (%s): Scatter_log overrun - cannot set stop bit. Aborting\n",NAME_CURRENT_COMP);
    exit(1);
  }
}
#line 56087 "./ESS_BIFROST_shielding.c"
#undef logger
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComplog_P_stop:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(62,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component arm_iter_P1_start [63] */
  mccoordschange(mcposrarm_iter_P1_start, mcrotrarm_iter_P1_start,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component arm_iter_P1_start (without coords transformations) */
  mcJumpTrace_arm_iter_P1_start:
  SIG_MESSAGE("arm_iter_P1_start (Trace)");
  mcDEBUG_COMP("arm_iter_P1_start")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComparm_iter_P1_start
  STORE_NEUTRON(63,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[63]++;
  mcPCounter[63] += p;
  mcP2Counter[63] += p*p;
#define mccompcurname  arm_iter_P1_start
#define mccompcurtype  Arm
#define mccompcurindex 63
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComparm_iter_P1_start:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(63,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component iter_P1_start [64] */
  mccoordschange(mcposriter_P1_start, mcrotriter_P1_start,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component iter_P1_start (without coords transformations) */
  mcJumpTrace_iter_P1_start:
  SIG_MESSAGE("iter_P1_start (Trace)");
  mcDEBUG_COMP("iter_P1_start")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompiter_P1_start
  STORE_NEUTRON(64,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[64]++;
  mcPCounter[64] += p;
  mcP2Counter[64] += p*p;
#define mccompcurname  iter_P1_start
#define mccompcurtype  Shielding_log_iterator_Ni_new
#define mccompcurindex 64
#define compute_func mcciter_P1_start_compute_func
#define nstate_initial mcciter_P1_start_nstate_initial
#define s0 mcciter_P1_start_s0
#define s1 mcciter_P1_start_s1
#line 146 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_Ni_new.comp"
{

//printf("Entering Iterator_Ni\n");
  /*I am the start of the pseudo neutron iterator*/
  if (nstate_initial==NULL){
    optics_not_hit=0; /* Fresh start, resetting variable */
    double *ns=nstate_initial=calloc(11,sizeof(double));
    ns[0]=x;ns[1]=y; ns[2]=z;
    ns[3]=vx;ns[4]=vy;ns[5]=vz;
    ns[6]=t;
    ns[7]=sx;ns[8]=sy;ns[9]=sz;
    ns[10]=p;

    s0=Bounce_store;
    s1=Bounce_store+1;
    /* Remove std. ABSORB to avoid breaking analysis loop */
#undef mcabsorb
#define mcabsorb scatter_iterator_stop


  }
    
 //if (s1->_p!=-1){
   if (s1->_p!=-1 && s1->_p!=-2){
    /*a neutron weight of -1 is nonsensical. I.e. if s1->p>=0, it means there are two states in the log from which we can compute a pseudo-neutron*/
   double nstate[11];
    if ( pseudo_neutron_state_function_Ni(nstate,s0,s1) ){
      printf("Warning: (%s): error reported when computing pseudo neutron\n",NAME_CURRENT_COMP);
    }
    /*set neutron state for subsequent components*/
    x=nstate[0];y=nstate[1];z=nstate[2];
    vx=nstate[3];vy=nstate[4];vz=nstate[5];
    t=nstate[6];
    sx=nstate[7];sy=nstate[8];sz=nstate[9];
    p=nstate[10];
    s0++;
    s1++;
  //  printf("Ni: z=%g\tp=%g\n",z,p);
  }else if (Bounce_store[1]._p==-1){
  /*This can happen now only in the case optics was not hit, i.e. no reflection, no absorption*/
    x=s0->_x;y=s0->_y;z=s0->_z;
    vx=s0->_vx;vy=s0->_vy;vz=s0->_vz;
    t=s0->_t;
    sx=s0->_sx;sy=s0->_sy;sz=s0->_sz;
    p=s0->_p;
    optics_not_hit = 1;
  //  fprintf(stdout,"No interactions with optics. Use \"optics_not_hit\" variable to JUMP at scatter_logger_stop and avoid sending to ScatterLogIterator those neutrons which were actually not scattered.\n");
  } else {
    printf("Here happens what should not happen: s1->_p=%g, Bounce_store[1]._p=%g\n",s1->_p,Bounce_store[1]._p);
    fprintf(stderr,"This should not happen. Period.\n");
    exit(1);
  }

}
#line 56354 "./ESS_BIFROST_shielding.c"
/* 'iter_P1_start=Shielding_log_iterator_Ni_new()' component instance extend code */
    SIG_MESSAGE("iter_P1_start (Trace:Extend)");
#line 1611 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
#ifdef scatter_iterator_stop
#undef scatter_iterator_stop
#endif
#define scatter_iterator_stop iter_P1_start
#line 56362 "./ESS_BIFROST_shielding.c"
if (( optics_not_hit )) goto mcJumpTrace_arm_iter_P1_stop;
#undef s1
#undef s0
#undef nstate_initial
#undef compute_func
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompiter_P1_start:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(64,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component arm_iter_P1_dummy [65] */
  mccoordschange(mcposrarm_iter_P1_dummy, mcrotrarm_iter_P1_dummy,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component arm_iter_P1_dummy (without coords transformations) */
  mcJumpTrace_arm_iter_P1_dummy:
  SIG_MESSAGE("arm_iter_P1_dummy (Trace)");
  mcDEBUG_COMP("arm_iter_P1_dummy")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComparm_iter_P1_dummy
  STORE_NEUTRON(65,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[65]++;
  mcPCounter[65] += p;
  mcP2Counter[65] += p*p;
#define mccompcurname  arm_iter_P1_dummy
#define mccompcurtype  Arm
#define mccompcurindex 65
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComparm_iter_P1_dummy:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(65,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component mndP01 [66] */
  mccoordschange(mcposrmndP01, mcrotrmndP01,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component mndP01 (without coords transformations) */
  mcJumpTrace_mndP01:
  SIG_MESSAGE("mndP01 (Trace)");
  mcDEBUG_COMP("mndP01")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmndP01
  STORE_NEUTRON(66,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[66]++;
  mcPCounter[66] += p;
  mcP2Counter[66] += p*p;
#define mccompcurname  mndP01
#define mccompcurtype  Monitor_nD
#define mccompcurindex 66
#define user1 mccmndP01_user1
#define user2 mccmndP01_user2
#define user3 mccmndP01_user3
#define DEFS mccmndP01_DEFS
#define Vars mccmndP01_Vars
#define detector mccmndP01_detector
#define offdata mccmndP01_offdata
{   /* Declarations of mndP01=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccmndP01_xwidth;
MCNUM yheight = mccmndP01_yheight;
MCNUM zdepth = mccmndP01_zdepth;
MCNUM xmin = mccmndP01_xmin;
MCNUM xmax = mccmndP01_xmax;
MCNUM ymin = mccmndP01_ymin;
MCNUM ymax = mccmndP01_ymax;
MCNUM zmin = mccmndP01_zmin;
MCNUM zmax = mccmndP01_zmax;
MCNUM bins = mccmndP01_bins;
MCNUM min = mccmndP01_min;
MCNUM max = mccmndP01_max;
MCNUM restore_neutron = mccmndP01_restore_neutron;
MCNUM radius = mccmndP01_radius;
char* options = mccmndP01_options;
char* filename = mccmndP01_filename;
char* geometry = mccmndP01_geometry;
char* username1 = mccmndP01_username1;
char* username2 = mccmndP01_username2;
char* username3 = mccmndP01_username3;
int nowritefile = mccmndP01_nowritefile;
#line 313 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  double  XY=0;
  double  t0 = 0;
  double  t1 = 0;
  double  pp;
  int     intersect   = 0;
  char    Flag_Restore = 0;

  if (user1 != FLT_MAX) Vars.UserVariable1 = user1;
  if (user2 != FLT_MAX) Vars.UserVariable2 = user2;
  if (user3 != FLT_MAX) Vars.UserVariable3 = user3;

  /* this is done automatically
    STORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  */

  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    /* determine intersections with object */
    intersect = off_intersect_all(&t0, &t1, NULL, NULL,
       x,y,z, vx, vy, vz, &offdata );
    if (Vars.Flag_mantid) {
      if(intersect) {
        Vars.OFF_polyidx=(offdata.intersects[offdata.nextintersect]).index;
      } else {
        Vars.OFF_polyidx=-1;
      }
    }
  }
  else if ( (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
            || (abs(Vars.Flag_Shape) == DEFS.SHAPE_DISK) ) /* square xy or disk xy */
  {
    // propagate to xy plane and find intersection
    // make sure the event is recoverable afterwards
    t0 = t;
    ALLOW_BACKPROP;
    PROP_Z0;
    if ( (t>=t0) && (z==0.0) ) // forward propagation to xy plane was successful
    {
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
      {
        // square xy
        intersect = (x>=Vars.mxmin && x<=Vars.mxmax && y>=Vars.mymin && y<=Vars.mymax);
      }
      else
      {
        // disk xy
        intersect = (SQR(x) + SQR(y)) <= SQR(Vars.Sphere_Radius);
      }
    }
    else
    {
      intersect=0;
    }
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) /* sphere */
  {
    intersect = sphere_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius);
  /*      intersect = (intersect && t0 > 0); */
  }
  else if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)) /* cylinder */
  {
    intersect = cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius, Vars.Cylinder_Height);
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) /* box */
  {
    intersect = box_intersect(&t0, &t1, x, y, z, vx, vy, vz,
                              fabs(Vars.mxmax-Vars.mxmin), fabs(Vars.mymax-Vars.mymin), fabs(Vars.mzmax-Vars.mzmin));
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_PREVIOUS) /* previous comp */
  { intersect = 1; }

  if (intersect)
  {
    if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND)
     || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)
     || (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) )
    {
      /* check if we have to remove the top/bottom with BANANA shape */
      if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA) && (intersect != 1)) {
        double y0,y1;
        /* propagate to intersection point as temporary variable to check top/bottom */
        y0 = y+t0*vy;
        y1 = y+t1*vy;
        if (fabs(y0) >= Vars.Cylinder_Height/2*0.99) t0 = t1;
        if (fabs(y1) >= Vars.Cylinder_Height/2*0.99) t1 = t0;
      }
      if (t0 < 0 && t1 > 0)
        t0 = t;  /* neutron was already inside ! */
      if (t1 < 0 && t0 > 0) /* neutron exit before entering !! */
        t1 = t;
      /* t0 is now time of incoming intersection with the detection area */
      if ((Vars.Flag_Shape < 0) && (t1 > 0))
        PROP_DT(t1); /* t1 outgoing beam */
      else
        PROP_DT(t0); /* t0 incoming beam */
      /* Final test if we are on lid / bottom of banana/sphere */
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA || abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) {
        if (fabs(y) >= Vars.Cylinder_Height/2*0.99) {
          intersect=0;
          Flag_Restore=1;
        }
      }
    }
  }

  if (intersect)
  {
    /* Now get the data to monitor: current or keep from PreMonitor */
    if (Vars.Flag_UsePreMonitor != 1)
    {
      Vars.cp  = p;
      Vars.cx  = x;
      Vars.cvx = vx;
      Vars.csx = sx;
      Vars.cy  = y;
      Vars.cvy = vy;
      Vars.csy = sy;
      Vars.cz  = z;
      Vars.cvz = vz;
      Vars.csz = sz;
      Vars.ct  = t;
    }

    if ((Vars.He3_pressure > 0) && (t1 != t0) && ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX)))
    {
      XY = exp(-7.417*Vars.He3_pressure*fabs(t1-t0)*2*PI*K2V);
      /* will monitor the absorbed part */
      Vars.cp *= 1-XY;
      /* and modify the neutron weight after monitor, only remains 1-p_detect */
      p *= XY;
    }

    if (Vars.Flag_capture)
    {
      XY = sqrt(Vars.cvx*Vars.cvx+Vars.cvy*Vars.cvy+Vars.cvz*Vars.cvz);
      XY *= V2K;
      if (XY != 0) XY = 2*PI/XY; /* lambda. lambda(2200 m/2) = 1.7985 Angs  */
      Vars.cp *= XY/1.7985;
    }

    pp = Monitor_nD_Trace(&DEFS, &Vars);
    if (pp==0.0)
    { ABSORB;
    }
    else if(pp==1)
    {
      SCATTER;
    }

    if (Vars.Flag_parallel) /* back to neutron state before detection */
      Flag_Restore = 1;
  } /* end if intersection */
  else {
    if (Vars.Flag_Absorb && !Vars.Flag_parallel)
    {
      // restore neutron ray before absorbing for correct mcdisplay
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
      ABSORB;
    }
    else Flag_Restore = 1;  /* no intersection, back to previous state */
  }

  if (Flag_Restore)
  {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 56772 "./ESS_BIFROST_shielding.c"
}   /* End of mndP01=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmndP01:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(66,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component arm_iter_P1_stop [67] */
  mccoordschange(mcposrarm_iter_P1_stop, mcrotrarm_iter_P1_stop,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component arm_iter_P1_stop (without coords transformations) */
  mcJumpTrace_arm_iter_P1_stop:
  SIG_MESSAGE("arm_iter_P1_stop (Trace)");
  mcDEBUG_COMP("arm_iter_P1_stop")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComparm_iter_P1_stop
  STORE_NEUTRON(67,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[67]++;
  mcPCounter[67] += p;
  mcP2Counter[67] += p*p;
#define mccompcurname  arm_iter_P1_stop
#define mccompcurtype  Arm
#define mccompcurindex 67
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComparm_iter_P1_stop:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(67,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component iter_P1_stop [68] */
  mccoordschange(mcposriter_P1_stop, mcrotriter_P1_stop,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component iter_P1_stop (without coords transformations) */
  mcJumpTrace_iter_P1_stop:
  SIG_MESSAGE("iter_P1_stop (Trace)");
  mcDEBUG_COMP("iter_P1_stop")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompiter_P1_stop
  STORE_NEUTRON(68,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[68]++;
  mcPCounter[68] += p;
  mcP2Counter[68] += p*p;
#define mccompcurname  iter_P1_stop
#define mccompcurtype  Shielding_log_iterator_stop
#define mccompcurindex 68
#define iterator mcciter_P1_stop_iterator
#define loop mcciter_P1_stop_loop
{   /* Declarations of iter_P1_stop=Shielding_log_iterator_stop() SETTING parameters. */
int last = mcciter_P1_stop_last;
#line 60 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_stop.comp"
{
#ifdef scatter_iterator_stop
#undef scatter_iterator_stop
#endif
#define scatter_iterator_stop iterator
scatter_iterator_stop:
  loop=1;
  struct Generalized_State_t *s1=MC_GETPAR(iterator,s1);

  if (s1->_p==-1){
    /*we have reached the end - unset loop and reset neutron state to whatever it was before we entered the pseudo neutron iterator*/
    loop=0;
    double *ns=MC_GETPAR(iterator,nstate_initial);
    x=ns[0];y=ns[1];z=ns[2];
    vx=ns[3];vy=ns[4];vz=ns[5];
    t=ns[6];
    sx=ns[7];sy=ns[8];sz=ns[9];
    p=ns[10];

    free(ns);
    MC_GETPAR(iterator,nstate_initial)=NULL;
    /* Restore std ABSORB */
#undef mcabsorb
#define mcabsorb mcabsorbAll
  // printf("No ABSORB after the iterator\n");
  } else if (s1->_p==-2) { 
  /*if the weight equals -2 it means that the neutron was absorbed in components within the scatter_logger (see scatter logger definition) 
    and should not be propagated further after this iterator*/
  // printf("Performing ABSORB after the iterator\n");
   /*we have reached the end - unset loop and reset neutron state to whatever it was before we entered the pseudo neutron iterator*/
    loop=0;
    double *ns=MC_GETPAR(iterator,nstate_initial);
    x=ns[0];y=ns[1];z=ns[2];
    vx=ns[3];vy=ns[4];vz=ns[5];
    t=ns[6];
    sx=ns[7];sy=ns[8];sz=ns[9];
    p=ns[10];

    free(ns);
    MC_GETPAR(iterator,nstate_initial)=NULL;
    /* Restore std ABSORB */
#undef mcabsorb
#define mcabsorb mcabsorbAll
   if (last>0) ABSORB; //Will sample new neutron. 
  }
}
#line 57038 "./ESS_BIFROST_shielding.c"
}   /* End of iter_P1_stop=Shielding_log_iterator_stop() SETTING parameter declarations. */
#undef loop
#undef iterator
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompiter_P1_stop:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(68,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component a11i [69] */
  mccoordschange(mcposra11i, mcrotra11i,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component a11i (without coords transformations) */
  mcJumpTrace_a11i:
  SIG_MESSAGE("a11i (Trace)");
  mcDEBUG_COMP("a11i")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompa11i
  STORE_NEUTRON(69,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[69]++;
  mcPCounter[69] += p;
  mcP2Counter[69] += p*p;
#define mccompcurname  a11i
#define mccompcurtype  Arm
#define mccompcurindex 69
if (( MC_GETPAR ( iter_P1_stop , loop ) )) goto mcJumpTrace_arm_iter_P1_start;
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompa11i:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(69,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component arm_iter_P2_start [70] */
  mccoordschange(mcposrarm_iter_P2_start, mcrotrarm_iter_P2_start,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component arm_iter_P2_start (without coords transformations) */
  mcJumpTrace_arm_iter_P2_start:
  SIG_MESSAGE("arm_iter_P2_start (Trace)");
  mcDEBUG_COMP("arm_iter_P2_start")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComparm_iter_P2_start
  STORE_NEUTRON(70,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[70]++;
  mcPCounter[70] += p;
  mcP2Counter[70] += p*p;
#define mccompcurname  arm_iter_P2_start
#define mccompcurtype  Arm
#define mccompcurindex 70
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComparm_iter_P2_start:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(70,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component iter_P2_start [71] */
  mccoordschange(mcposriter_P2_start, mcrotriter_P2_start,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component iter_P2_start (without coords transformations) */
  mcJumpTrace_iter_P2_start:
  SIG_MESSAGE("iter_P2_start (Trace)");
  mcDEBUG_COMP("iter_P2_start")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompiter_P2_start
  STORE_NEUTRON(71,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[71]++;
  mcPCounter[71] += p;
  mcP2Counter[71] += p*p;
#define mccompcurname  iter_P2_start
#define mccompcurtype  Shielding_log_iterator_Ti_new
#define mccompcurindex 71
#define compute_func mcciter_P2_start_compute_func
#define nstate_initial mcciter_P2_start_nstate_initial
#define s0 mcciter_P2_start_s0
#define s1 mcciter_P2_start_s1
#line 122 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_Ti_new.comp"
{

//printf("Entering Iterator_Ti\n");
  /*I am the start of the pseudo neutron iterator*/
  if (nstate_initial==NULL){
    optics_not_hit=0; /* Fresh start, resetting variable */
    double *ns=nstate_initial=calloc(11,sizeof(double));
    ns[0]=x;ns[1]=y; ns[2]=z;
    ns[3]=vx;ns[4]=vy;ns[5]=vz;
    ns[6]=t;
    ns[7]=sx;ns[8]=sy;ns[9]=sz;
    ns[10]=p;

    s0=Bounce_store;
    s1=Bounce_store+1;
    /* Remove std. ABSORB to avoid breaking analysis loop */
#undef mcabsorb
#define mcabsorb scatter_iterator_stop


  }
    
 //if (s1->_p!=-1){
   if (s1->_p!=-1 && s1->_p!=-2){
    /*a neutron weight of -1 is nonsensical. I.e. if s1->p>=0, it means there are two states in the log from which we can compute a pseudo-neutron*/
   double nstate[11];
    if ( pseudo_neutron_state_function_Ti(nstate,s0,s1) ){
      printf("Warning: (%s): error reported when computing pseudo neutron\n",NAME_CURRENT_COMP);
    }
    /*set neutron state for subsequent components*/
    x=nstate[0];y=nstate[1];z=nstate[2];
    vx=nstate[3];vy=nstate[4];vz=nstate[5];
    t=nstate[6];
    sx=nstate[7];sy=nstate[8];sz=nstate[9];
    p=nstate[10];
    s0++;
    s1++;
 //  printf("Ti: z=%g\tp=%g\n",z,p);
  }else if (Bounce_store[1]._p==-1){
  /*This can happen now only in the case optics was not hit, i.e. no reflection, no absorption*/
    x=s0->_x;y=s0->_y;z=s0->_z;
    vx=s0->_vx;vy=s0->_vy;vz=s0->_vz;
    t=s0->_t;
    sx=s0->_sx;sy=s0->_sy;sz=s0->_sz;
    p=s0->_p;
    optics_not_hit = 1;
  //  fprintf(stdout,"No interactions with optics. Use \"optics_not_hit\" variable to JUMP at scatter_logger_stop and avoid sending to ScatterLogIterator those neutrons which were actually not scattered.\n");
  } else {
    printf("Here happens what should not happen: s1->_p=%g, Bounce_store[1]._p=%g\n",s1->_p,Bounce_store[1]._p);
    fprintf(stderr,"This should not happen. Period.\n");
    exit(1);
  }

}
#line 57411 "./ESS_BIFROST_shielding.c"
/* 'iter_P2_start=Shielding_log_iterator_Ti_new()' component instance extend code */
    SIG_MESSAGE("iter_P2_start (Trace:Extend)");
#line 1656 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
#ifdef scatter_iterator_stop
#undef scatter_iterator_stop
#endif
#define scatter_iterator_stop iter_P2_start
#line 57419 "./ESS_BIFROST_shielding.c"
if (( optics_not_hit )) goto mcJumpTrace_arm_iter_P2_stop;
#undef s1
#undef s0
#undef nstate_initial
#undef compute_func
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompiter_P2_start:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(71,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component arm_iter_P2_dummy [72] */
  mccoordschange(mcposrarm_iter_P2_dummy, mcrotrarm_iter_P2_dummy,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component arm_iter_P2_dummy (without coords transformations) */
  mcJumpTrace_arm_iter_P2_dummy:
  SIG_MESSAGE("arm_iter_P2_dummy (Trace)");
  mcDEBUG_COMP("arm_iter_P2_dummy")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComparm_iter_P2_dummy
  STORE_NEUTRON(72,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[72]++;
  mcPCounter[72] += p;
  mcP2Counter[72] += p*p;
#define mccompcurname  arm_iter_P2_dummy
#define mccompcurtype  Arm
#define mccompcurindex 72
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComparm_iter_P2_dummy:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(72,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component mndP02 [73] */
  mccoordschange(mcposrmndP02, mcrotrmndP02,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component mndP02 (without coords transformations) */
  mcJumpTrace_mndP02:
  SIG_MESSAGE("mndP02 (Trace)");
  mcDEBUG_COMP("mndP02")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmndP02
  STORE_NEUTRON(73,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[73]++;
  mcPCounter[73] += p;
  mcP2Counter[73] += p*p;
#define mccompcurname  mndP02
#define mccompcurtype  Monitor_nD
#define mccompcurindex 73
#define user1 mccmndP02_user1
#define user2 mccmndP02_user2
#define user3 mccmndP02_user3
#define DEFS mccmndP02_DEFS
#define Vars mccmndP02_Vars
#define detector mccmndP02_detector
#define offdata mccmndP02_offdata
{   /* Declarations of mndP02=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccmndP02_xwidth;
MCNUM yheight = mccmndP02_yheight;
MCNUM zdepth = mccmndP02_zdepth;
MCNUM xmin = mccmndP02_xmin;
MCNUM xmax = mccmndP02_xmax;
MCNUM ymin = mccmndP02_ymin;
MCNUM ymax = mccmndP02_ymax;
MCNUM zmin = mccmndP02_zmin;
MCNUM zmax = mccmndP02_zmax;
MCNUM bins = mccmndP02_bins;
MCNUM min = mccmndP02_min;
MCNUM max = mccmndP02_max;
MCNUM restore_neutron = mccmndP02_restore_neutron;
MCNUM radius = mccmndP02_radius;
char* options = mccmndP02_options;
char* filename = mccmndP02_filename;
char* geometry = mccmndP02_geometry;
char* username1 = mccmndP02_username1;
char* username2 = mccmndP02_username2;
char* username3 = mccmndP02_username3;
int nowritefile = mccmndP02_nowritefile;
#line 313 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  double  XY=0;
  double  t0 = 0;
  double  t1 = 0;
  double  pp;
  int     intersect   = 0;
  char    Flag_Restore = 0;

  if (user1 != FLT_MAX) Vars.UserVariable1 = user1;
  if (user2 != FLT_MAX) Vars.UserVariable2 = user2;
  if (user3 != FLT_MAX) Vars.UserVariable3 = user3;

  /* this is done automatically
    STORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  */

  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    /* determine intersections with object */
    intersect = off_intersect_all(&t0, &t1, NULL, NULL,
       x,y,z, vx, vy, vz, &offdata );
    if (Vars.Flag_mantid) {
      if(intersect) {
        Vars.OFF_polyidx=(offdata.intersects[offdata.nextintersect]).index;
      } else {
        Vars.OFF_polyidx=-1;
      }
    }
  }
  else if ( (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
            || (abs(Vars.Flag_Shape) == DEFS.SHAPE_DISK) ) /* square xy or disk xy */
  {
    // propagate to xy plane and find intersection
    // make sure the event is recoverable afterwards
    t0 = t;
    ALLOW_BACKPROP;
    PROP_Z0;
    if ( (t>=t0) && (z==0.0) ) // forward propagation to xy plane was successful
    {
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
      {
        // square xy
        intersect = (x>=Vars.mxmin && x<=Vars.mxmax && y>=Vars.mymin && y<=Vars.mymax);
      }
      else
      {
        // disk xy
        intersect = (SQR(x) + SQR(y)) <= SQR(Vars.Sphere_Radius);
      }
    }
    else
    {
      intersect=0;
    }
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) /* sphere */
  {
    intersect = sphere_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius);
  /*      intersect = (intersect && t0 > 0); */
  }
  else if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)) /* cylinder */
  {
    intersect = cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius, Vars.Cylinder_Height);
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) /* box */
  {
    intersect = box_intersect(&t0, &t1, x, y, z, vx, vy, vz,
                              fabs(Vars.mxmax-Vars.mxmin), fabs(Vars.mymax-Vars.mymin), fabs(Vars.mzmax-Vars.mzmin));
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_PREVIOUS) /* previous comp */
  { intersect = 1; }

  if (intersect)
  {
    if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND)
     || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)
     || (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) )
    {
      /* check if we have to remove the top/bottom with BANANA shape */
      if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA) && (intersect != 1)) {
        double y0,y1;
        /* propagate to intersection point as temporary variable to check top/bottom */
        y0 = y+t0*vy;
        y1 = y+t1*vy;
        if (fabs(y0) >= Vars.Cylinder_Height/2*0.99) t0 = t1;
        if (fabs(y1) >= Vars.Cylinder_Height/2*0.99) t1 = t0;
      }
      if (t0 < 0 && t1 > 0)
        t0 = t;  /* neutron was already inside ! */
      if (t1 < 0 && t0 > 0) /* neutron exit before entering !! */
        t1 = t;
      /* t0 is now time of incoming intersection with the detection area */
      if ((Vars.Flag_Shape < 0) && (t1 > 0))
        PROP_DT(t1); /* t1 outgoing beam */
      else
        PROP_DT(t0); /* t0 incoming beam */
      /* Final test if we are on lid / bottom of banana/sphere */
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA || abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) {
        if (fabs(y) >= Vars.Cylinder_Height/2*0.99) {
          intersect=0;
          Flag_Restore=1;
        }
      }
    }
  }

  if (intersect)
  {
    /* Now get the data to monitor: current or keep from PreMonitor */
    if (Vars.Flag_UsePreMonitor != 1)
    {
      Vars.cp  = p;
      Vars.cx  = x;
      Vars.cvx = vx;
      Vars.csx = sx;
      Vars.cy  = y;
      Vars.cvy = vy;
      Vars.csy = sy;
      Vars.cz  = z;
      Vars.cvz = vz;
      Vars.csz = sz;
      Vars.ct  = t;
    }

    if ((Vars.He3_pressure > 0) && (t1 != t0) && ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX)))
    {
      XY = exp(-7.417*Vars.He3_pressure*fabs(t1-t0)*2*PI*K2V);
      /* will monitor the absorbed part */
      Vars.cp *= 1-XY;
      /* and modify the neutron weight after monitor, only remains 1-p_detect */
      p *= XY;
    }

    if (Vars.Flag_capture)
    {
      XY = sqrt(Vars.cvx*Vars.cvx+Vars.cvy*Vars.cvy+Vars.cvz*Vars.cvz);
      XY *= V2K;
      if (XY != 0) XY = 2*PI/XY; /* lambda. lambda(2200 m/2) = 1.7985 Angs  */
      Vars.cp *= XY/1.7985;
    }

    pp = Monitor_nD_Trace(&DEFS, &Vars);
    if (pp==0.0)
    { ABSORB;
    }
    else if(pp==1)
    {
      SCATTER;
    }

    if (Vars.Flag_parallel) /* back to neutron state before detection */
      Flag_Restore = 1;
  } /* end if intersection */
  else {
    if (Vars.Flag_Absorb && !Vars.Flag_parallel)
    {
      // restore neutron ray before absorbing for correct mcdisplay
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
      ABSORB;
    }
    else Flag_Restore = 1;  /* no intersection, back to previous state */
  }

  if (Flag_Restore)
  {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 57829 "./ESS_BIFROST_shielding.c"
}   /* End of mndP02=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmndP02:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(73,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component arm_iter_P2_stop [74] */
  mccoordschange(mcposrarm_iter_P2_stop, mcrotrarm_iter_P2_stop,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component arm_iter_P2_stop (without coords transformations) */
  mcJumpTrace_arm_iter_P2_stop:
  SIG_MESSAGE("arm_iter_P2_stop (Trace)");
  mcDEBUG_COMP("arm_iter_P2_stop")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComparm_iter_P2_stop
  STORE_NEUTRON(74,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[74]++;
  mcPCounter[74] += p;
  mcP2Counter[74] += p*p;
#define mccompcurname  arm_iter_P2_stop
#define mccompcurtype  Arm
#define mccompcurindex 74
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComparm_iter_P2_stop:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(74,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component iter_P2_stop [75] */
  mccoordschange(mcposriter_P2_stop, mcrotriter_P2_stop,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component iter_P2_stop (without coords transformations) */
  mcJumpTrace_iter_P2_stop:
  SIG_MESSAGE("iter_P2_stop (Trace)");
  mcDEBUG_COMP("iter_P2_stop")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompiter_P2_stop
  STORE_NEUTRON(75,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[75]++;
  mcPCounter[75] += p;
  mcP2Counter[75] += p*p;
#define mccompcurname  iter_P2_stop
#define mccompcurtype  Shielding_log_iterator_stop
#define mccompcurindex 75
#define iterator mcciter_P2_stop_iterator
#define loop mcciter_P2_stop_loop
{   /* Declarations of iter_P2_stop=Shielding_log_iterator_stop() SETTING parameters. */
int last = mcciter_P2_stop_last;
#line 60 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_stop.comp"
{
#ifdef scatter_iterator_stop
#undef scatter_iterator_stop
#endif
#define scatter_iterator_stop iterator
scatter_iterator_stop:
  loop=1;
  struct Generalized_State_t *s1=MC_GETPAR(iterator,s1);

  if (s1->_p==-1){
    /*we have reached the end - unset loop and reset neutron state to whatever it was before we entered the pseudo neutron iterator*/
    loop=0;
    double *ns=MC_GETPAR(iterator,nstate_initial);
    x=ns[0];y=ns[1];z=ns[2];
    vx=ns[3];vy=ns[4];vz=ns[5];
    t=ns[6];
    sx=ns[7];sy=ns[8];sz=ns[9];
    p=ns[10];

    free(ns);
    MC_GETPAR(iterator,nstate_initial)=NULL;
    /* Restore std ABSORB */
#undef mcabsorb
#define mcabsorb mcabsorbAll
  // printf("No ABSORB after the iterator\n");
  } else if (s1->_p==-2) { 
  /*if the weight equals -2 it means that the neutron was absorbed in components within the scatter_logger (see scatter logger definition) 
    and should not be propagated further after this iterator*/
  // printf("Performing ABSORB after the iterator\n");
   /*we have reached the end - unset loop and reset neutron state to whatever it was before we entered the pseudo neutron iterator*/
    loop=0;
    double *ns=MC_GETPAR(iterator,nstate_initial);
    x=ns[0];y=ns[1];z=ns[2];
    vx=ns[3];vy=ns[4];vz=ns[5];
    t=ns[6];
    sx=ns[7];sy=ns[8];sz=ns[9];
    p=ns[10];

    free(ns);
    MC_GETPAR(iterator,nstate_initial)=NULL;
    /* Restore std ABSORB */
#undef mcabsorb
#define mcabsorb mcabsorbAll
   if (last>0) ABSORB; //Will sample new neutron. 
  }
}
#line 58095 "./ESS_BIFROST_shielding.c"
}   /* End of iter_P2_stop=Shielding_log_iterator_stop() SETTING parameter declarations. */
#undef loop
#undef iterator
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompiter_P2_stop:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(75,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component a12i [76] */
  mccoordschange(mcposra12i, mcrotra12i,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component a12i (without coords transformations) */
  mcJumpTrace_a12i:
  SIG_MESSAGE("a12i (Trace)");
  mcDEBUG_COMP("a12i")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompa12i
  STORE_NEUTRON(76,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[76]++;
  mcPCounter[76] += p;
  mcP2Counter[76] += p*p;
#define mccompcurname  a12i
#define mccompcurtype  Arm
#define mccompcurindex 76
if (( MC_GETPAR ( iter_P2_stop , loop ) )) goto mcJumpTrace_arm_iter_P2_start;
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompa12i:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(76,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component arm_iter_P3_start [77] */
  mccoordschange(mcposrarm_iter_P3_start, mcrotrarm_iter_P3_start,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component arm_iter_P3_start (without coords transformations) */
  mcJumpTrace_arm_iter_P3_start:
  SIG_MESSAGE("arm_iter_P3_start (Trace)");
  mcDEBUG_COMP("arm_iter_P3_start")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComparm_iter_P3_start
  STORE_NEUTRON(77,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[77]++;
  mcPCounter[77] += p;
  mcP2Counter[77] += p*p;
#define mccompcurname  arm_iter_P3_start
#define mccompcurtype  Arm
#define mccompcurindex 77
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComparm_iter_P3_start:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(77,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component iter_P3_start [78] */
  mccoordschange(mcposriter_P3_start, mcrotriter_P3_start,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component iter_P3_start (without coords transformations) */
  mcJumpTrace_iter_P3_start:
  SIG_MESSAGE("iter_P3_start (Trace)");
  mcDEBUG_COMP("iter_P3_start")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompiter_P3_start
  STORE_NEUTRON(78,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[78]++;
  mcPCounter[78] += p;
  mcP2Counter[78] += p*p;
#define mccompcurname  iter_P3_start
#define mccompcurtype  Shielding_log_iterator_total
#define mccompcurindex 78
#define compute_func mcciter_P3_start_compute_func
#define nstate_initial mcciter_P3_start_nstate_initial
#define s0 mcciter_P3_start_s0
#define s1 mcciter_P3_start_s1
#line 102 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_total.comp"
{
//printf("Entering Iterator_total\n");
  /*I am the start of the pseudo neutron iterator*/
  if (nstate_initial==NULL){
    optics_not_hit=0; /* Fresh start, resetting variable */
    double *ns=nstate_initial=calloc(11,sizeof(double));
    ns[0]=x;ns[1]=y; ns[2]=z;
    ns[3]=vx;ns[4]=vy;ns[5]=vz;
    ns[6]=t;
    ns[7]=sx;ns[8]=sy;ns[9]=sz;
    ns[10]=p;

    s0=Bounce_store;
    s1=Bounce_store+1;
    /* Remove std. ABSORB to avoid breaking analysis loop */
#undef mcabsorb
#define mcabsorb scatter_iterator_stop


  }
    
 //if (s1->_p!=-1){
   if (s1->_p!=-1 && s1->_p!=-2){
    /*a neutron weight of -1 is nonsensical. I.e. if s1->p>=0, it means there are two states in the log from which we can compute a pseudo-neutron*/
   double nstate[11];
    if ( pseudo_neutron_state_function(nstate,s0,s1) ){
      printf("Warning: (%s): error reported when computing pseudo neutron\n",NAME_CURRENT_COMP);
    }
    /*set neutron state for subsequent components*/
    x=nstate[0];y=nstate[1];z=nstate[2];
    vx=nstate[3];vy=nstate[4];vz=nstate[5];
    t=nstate[6];
    sx=nstate[7];sy=nstate[8];sz=nstate[9];
    p=nstate[10];
    s0++;
    s1++;
 //   printf("Tot: z=%g\tp=%g\n",z,p);
  }else if (Bounce_store[1]._p==-1){
  /*This can happen now only in the case optics was not hit, i.e. no reflection, no absorption*/
    x=s0->_x;y=s0->_y;z=s0->_z;
    vx=s0->_vx;vy=s0->_vy;vz=s0->_vz;
    t=s0->_t;
    sx=s0->_sx;sy=s0->_sy;sz=s0->_sz;
    p=s0->_p;
    optics_not_hit = 1;
  //  fprintf(stdout,"No interactions with optics. Use \"optics_not_hit\" variable to JUMP at scatter_logger_stop and avoid sending to ScatterLogIterator those neutrons which were actually not scattered.\n");
  } else {
    printf("Here happens what should not happen: s1->_p=%g, Bounce_store[1]._p=%g\n",s1->_p,Bounce_store[1]._p);
    fprintf(stderr,"This should not happen. Period.\n");
    exit(1);
  }

}
#line 58467 "./ESS_BIFROST_shielding.c"
/* 'iter_P3_start=Shielding_log_iterator_total()' component instance extend code */
    SIG_MESSAGE("iter_P3_start (Trace:Extend)");
#line 1698 "/zhome/89/0/38697/once/McStas-2.5_CPU_MPICC/ESS_BIFROST_shielding/ESS_BIFROST_shielding.instr"
#ifdef scatter_iterator_stop
#undef scatter_iterator_stop
#endif
#define scatter_iterator_stop iter_P3_start
#line 58475 "./ESS_BIFROST_shielding.c"
if (( optics_not_hit )) goto mcJumpTrace_arm_iter_P3_stop;
#undef s1
#undef s0
#undef nstate_initial
#undef compute_func
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompiter_P3_start:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(78,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component arm_iter_P3_dummy [79] */
  mccoordschange(mcposrarm_iter_P3_dummy, mcrotrarm_iter_P3_dummy,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component arm_iter_P3_dummy (without coords transformations) */
  mcJumpTrace_arm_iter_P3_dummy:
  SIG_MESSAGE("arm_iter_P3_dummy (Trace)");
  mcDEBUG_COMP("arm_iter_P3_dummy")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComparm_iter_P3_dummy
  STORE_NEUTRON(79,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[79]++;
  mcPCounter[79] += p;
  mcP2Counter[79] += p*p;
#define mccompcurname  arm_iter_P3_dummy
#define mccompcurtype  Arm
#define mccompcurindex 79
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComparm_iter_P3_dummy:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(79,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component mndP03 [80] */
  mccoordschange(mcposrmndP03, mcrotrmndP03,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component mndP03 (without coords transformations) */
  mcJumpTrace_mndP03:
  SIG_MESSAGE("mndP03 (Trace)");
  mcDEBUG_COMP("mndP03")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmndP03
  STORE_NEUTRON(80,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[80]++;
  mcPCounter[80] += p;
  mcP2Counter[80] += p*p;
#define mccompcurname  mndP03
#define mccompcurtype  Monitor_nD
#define mccompcurindex 80
#define user1 mccmndP03_user1
#define user2 mccmndP03_user2
#define user3 mccmndP03_user3
#define DEFS mccmndP03_DEFS
#define Vars mccmndP03_Vars
#define detector mccmndP03_detector
#define offdata mccmndP03_offdata
{   /* Declarations of mndP03=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccmndP03_xwidth;
MCNUM yheight = mccmndP03_yheight;
MCNUM zdepth = mccmndP03_zdepth;
MCNUM xmin = mccmndP03_xmin;
MCNUM xmax = mccmndP03_xmax;
MCNUM ymin = mccmndP03_ymin;
MCNUM ymax = mccmndP03_ymax;
MCNUM zmin = mccmndP03_zmin;
MCNUM zmax = mccmndP03_zmax;
MCNUM bins = mccmndP03_bins;
MCNUM min = mccmndP03_min;
MCNUM max = mccmndP03_max;
MCNUM restore_neutron = mccmndP03_restore_neutron;
MCNUM radius = mccmndP03_radius;
char* options = mccmndP03_options;
char* filename = mccmndP03_filename;
char* geometry = mccmndP03_geometry;
char* username1 = mccmndP03_username1;
char* username2 = mccmndP03_username2;
char* username3 = mccmndP03_username3;
int nowritefile = mccmndP03_nowritefile;
#line 313 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  double  XY=0;
  double  t0 = 0;
  double  t1 = 0;
  double  pp;
  int     intersect   = 0;
  char    Flag_Restore = 0;

  if (user1 != FLT_MAX) Vars.UserVariable1 = user1;
  if (user2 != FLT_MAX) Vars.UserVariable2 = user2;
  if (user3 != FLT_MAX) Vars.UserVariable3 = user3;

  /* this is done automatically
    STORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  */

  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    /* determine intersections with object */
    intersect = off_intersect_all(&t0, &t1, NULL, NULL,
       x,y,z, vx, vy, vz, &offdata );
    if (Vars.Flag_mantid) {
      if(intersect) {
        Vars.OFF_polyidx=(offdata.intersects[offdata.nextintersect]).index;
      } else {
        Vars.OFF_polyidx=-1;
      }
    }
  }
  else if ( (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
            || (abs(Vars.Flag_Shape) == DEFS.SHAPE_DISK) ) /* square xy or disk xy */
  {
    // propagate to xy plane and find intersection
    // make sure the event is recoverable afterwards
    t0 = t;
    ALLOW_BACKPROP;
    PROP_Z0;
    if ( (t>=t0) && (z==0.0) ) // forward propagation to xy plane was successful
    {
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
      {
        // square xy
        intersect = (x>=Vars.mxmin && x<=Vars.mxmax && y>=Vars.mymin && y<=Vars.mymax);
      }
      else
      {
        // disk xy
        intersect = (SQR(x) + SQR(y)) <= SQR(Vars.Sphere_Radius);
      }
    }
    else
    {
      intersect=0;
    }
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) /* sphere */
  {
    intersect = sphere_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius);
  /*      intersect = (intersect && t0 > 0); */
  }
  else if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)) /* cylinder */
  {
    intersect = cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius, Vars.Cylinder_Height);
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) /* box */
  {
    intersect = box_intersect(&t0, &t1, x, y, z, vx, vy, vz,
                              fabs(Vars.mxmax-Vars.mxmin), fabs(Vars.mymax-Vars.mymin), fabs(Vars.mzmax-Vars.mzmin));
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_PREVIOUS) /* previous comp */
  { intersect = 1; }

  if (intersect)
  {
    if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND)
     || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)
     || (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) )
    {
      /* check if we have to remove the top/bottom with BANANA shape */
      if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA) && (intersect != 1)) {
        double y0,y1;
        /* propagate to intersection point as temporary variable to check top/bottom */
        y0 = y+t0*vy;
        y1 = y+t1*vy;
        if (fabs(y0) >= Vars.Cylinder_Height/2*0.99) t0 = t1;
        if (fabs(y1) >= Vars.Cylinder_Height/2*0.99) t1 = t0;
      }
      if (t0 < 0 && t1 > 0)
        t0 = t;  /* neutron was already inside ! */
      if (t1 < 0 && t0 > 0) /* neutron exit before entering !! */
        t1 = t;
      /* t0 is now time of incoming intersection with the detection area */
      if ((Vars.Flag_Shape < 0) && (t1 > 0))
        PROP_DT(t1); /* t1 outgoing beam */
      else
        PROP_DT(t0); /* t0 incoming beam */
      /* Final test if we are on lid / bottom of banana/sphere */
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA || abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) {
        if (fabs(y) >= Vars.Cylinder_Height/2*0.99) {
          intersect=0;
          Flag_Restore=1;
        }
      }
    }
  }

  if (intersect)
  {
    /* Now get the data to monitor: current or keep from PreMonitor */
    if (Vars.Flag_UsePreMonitor != 1)
    {
      Vars.cp  = p;
      Vars.cx  = x;
      Vars.cvx = vx;
      Vars.csx = sx;
      Vars.cy  = y;
      Vars.cvy = vy;
      Vars.csy = sy;
      Vars.cz  = z;
      Vars.cvz = vz;
      Vars.csz = sz;
      Vars.ct  = t;
    }

    if ((Vars.He3_pressure > 0) && (t1 != t0) && ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX)))
    {
      XY = exp(-7.417*Vars.He3_pressure*fabs(t1-t0)*2*PI*K2V);
      /* will monitor the absorbed part */
      Vars.cp *= 1-XY;
      /* and modify the neutron weight after monitor, only remains 1-p_detect */
      p *= XY;
    }

    if (Vars.Flag_capture)
    {
      XY = sqrt(Vars.cvx*Vars.cvx+Vars.cvy*Vars.cvy+Vars.cvz*Vars.cvz);
      XY *= V2K;
      if (XY != 0) XY = 2*PI/XY; /* lambda. lambda(2200 m/2) = 1.7985 Angs  */
      Vars.cp *= XY/1.7985;
    }

    pp = Monitor_nD_Trace(&DEFS, &Vars);
    if (pp==0.0)
    { ABSORB;
    }
    else if(pp==1)
    {
      SCATTER;
    }

    if (Vars.Flag_parallel) /* back to neutron state before detection */
      Flag_Restore = 1;
  } /* end if intersection */
  else {
    if (Vars.Flag_Absorb && !Vars.Flag_parallel)
    {
      // restore neutron ray before absorbing for correct mcdisplay
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
      ABSORB;
    }
    else Flag_Restore = 1;  /* no intersection, back to previous state */
  }

  if (Flag_Restore)
  {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 58885 "./ESS_BIFROST_shielding.c"
}   /* End of mndP03=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmndP03:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(80,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component arm_iter_P3_stop [81] */
  mccoordschange(mcposrarm_iter_P3_stop, mcrotrarm_iter_P3_stop,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component arm_iter_P3_stop (without coords transformations) */
  mcJumpTrace_arm_iter_P3_stop:
  SIG_MESSAGE("arm_iter_P3_stop (Trace)");
  mcDEBUG_COMP("arm_iter_P3_stop")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComparm_iter_P3_stop
  STORE_NEUTRON(81,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[81]++;
  mcPCounter[81] += p;
  mcP2Counter[81] += p*p;
#define mccompcurname  arm_iter_P3_stop
#define mccompcurtype  Arm
#define mccompcurindex 81
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComparm_iter_P3_stop:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(81,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component iter_P3_stop [82] */
  mccoordschange(mcposriter_P3_stop, mcrotriter_P3_stop,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component iter_P3_stop (without coords transformations) */
  mcJumpTrace_iter_P3_stop:
  SIG_MESSAGE("iter_P3_stop (Trace)");
  mcDEBUG_COMP("iter_P3_stop")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompiter_P3_stop
  STORE_NEUTRON(82,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[82]++;
  mcPCounter[82] += p;
  mcP2Counter[82] += p*p;
#define mccompcurname  iter_P3_stop
#define mccompcurtype  Shielding_log_iterator_stop
#define mccompcurindex 82
#define iterator mcciter_P3_stop_iterator
#define loop mcciter_P3_stop_loop
{   /* Declarations of iter_P3_stop=Shielding_log_iterator_stop() SETTING parameters. */
int last = mcciter_P3_stop_last;
#line 60 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_stop.comp"
{
#ifdef scatter_iterator_stop
#undef scatter_iterator_stop
#endif
#define scatter_iterator_stop iterator
scatter_iterator_stop:
  loop=1;
  struct Generalized_State_t *s1=MC_GETPAR(iterator,s1);

  if (s1->_p==-1){
    /*we have reached the end - unset loop and reset neutron state to whatever it was before we entered the pseudo neutron iterator*/
    loop=0;
    double *ns=MC_GETPAR(iterator,nstate_initial);
    x=ns[0];y=ns[1];z=ns[2];
    vx=ns[3];vy=ns[4];vz=ns[5];
    t=ns[6];
    sx=ns[7];sy=ns[8];sz=ns[9];
    p=ns[10];

    free(ns);
    MC_GETPAR(iterator,nstate_initial)=NULL;
    /* Restore std ABSORB */
#undef mcabsorb
#define mcabsorb mcabsorbAll
  // printf("No ABSORB after the iterator\n");
  } else if (s1->_p==-2) { 
  /*if the weight equals -2 it means that the neutron was absorbed in components within the scatter_logger (see scatter logger definition) 
    and should not be propagated further after this iterator*/
  // printf("Performing ABSORB after the iterator\n");
   /*we have reached the end - unset loop and reset neutron state to whatever it was before we entered the pseudo neutron iterator*/
    loop=0;
    double *ns=MC_GETPAR(iterator,nstate_initial);
    x=ns[0];y=ns[1];z=ns[2];
    vx=ns[3];vy=ns[4];vz=ns[5];
    t=ns[6];
    sx=ns[7];sy=ns[8];sz=ns[9];
    p=ns[10];

    free(ns);
    MC_GETPAR(iterator,nstate_initial)=NULL;
    /* Restore std ABSORB */
#undef mcabsorb
#define mcabsorb mcabsorbAll
   if (last>0) ABSORB; //Will sample new neutron. 
  }
}
#line 59151 "./ESS_BIFROST_shielding.c"
}   /* End of iter_P3_stop=Shielding_log_iterator_stop() SETTING parameter declarations. */
#undef loop
#undef iterator
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompiter_P3_stop:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(82,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component a13i [83] */
  mccoordschange(mcposra13i, mcrotra13i,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component a13i (without coords transformations) */
  mcJumpTrace_a13i:
  SIG_MESSAGE("a13i (Trace)");
  mcDEBUG_COMP("a13i")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompa13i
  STORE_NEUTRON(83,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[83]++;
  mcPCounter[83] += p;
  mcP2Counter[83] += p*p;
#define mccompcurname  a13i
#define mccompcurtype  Arm
#define mccompcurindex 83
if (( MC_GETPAR ( iter_P3_stop , loop ) )) goto mcJumpTrace_arm_iter_P3_start;
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompa13i:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(83,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Beamstop [84] */
  mccoordschange(mcposrBeamstop, mcrotrBeamstop,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Beamstop (without coords transformations) */
  mcJumpTrace_Beamstop:
  SIG_MESSAGE("Beamstop (Trace)");
  mcDEBUG_COMP("Beamstop")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompBeamstop
  STORE_NEUTRON(84,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[84]++;
  mcPCounter[84] += p;
  mcP2Counter[84] += p*p;
#define mccompcurname  Beamstop
#define mccompcurtype  Beamstop
#define mccompcurindex 84
{   /* Declarations of Beamstop=Beamstop() SETTING parameters. */
MCNUM xmin = mccBeamstop_xmin;
MCNUM xmax = mccBeamstop_xmax;
MCNUM ymin = mccBeamstop_ymin;
MCNUM ymax = mccBeamstop_ymax;
MCNUM xwidth = mccBeamstop_xwidth;
MCNUM yheight = mccBeamstop_yheight;
MCNUM radius = mccBeamstop_radius;
#line 59 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Beamstop.comp"
{
    double Time = t;
    ALLOW_BACKPROP;
    PROP_Z0;
    Time = t - Time;
    if (((Time>=0) && ((radius!=0) && (x*x + y*y <= radius*radius)))
    || ((Time>=0) && (radius==0) && (x>xmin && x<xmax && y>ymin && y<ymax)))
      ABSORB;
    else
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
}
#line 59382 "./ESS_BIFROST_shielding.c"
}   /* End of Beamstop=Beamstop() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompBeamstop:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(84,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Lmon_guide_end [85] */
  mccoordschange(mcposrLmon_guide_end, mcrotrLmon_guide_end,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Lmon_guide_end (without coords transformations) */
  mcJumpTrace_Lmon_guide_end:
  SIG_MESSAGE("Lmon_guide_end (Trace)");
  mcDEBUG_COMP("Lmon_guide_end")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompLmon_guide_end
  STORE_NEUTRON(85,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[85]++;
  mcPCounter[85] += p;
  mcP2Counter[85] += p*p;
#define mccompcurname  Lmon_guide_end
#define mccompcurtype  L_monitor
#define mccompcurindex 85
#define nL mccLmon_guide_end_nL
#define L_N mccLmon_guide_end_L_N
#define L_p mccLmon_guide_end_L_p
#define L_p2 mccLmon_guide_end_L_p2
{   /* Declarations of Lmon_guide_end=L_monitor() SETTING parameters. */
char* filename = mccLmon_guide_end_filename;
MCNUM xmin = mccLmon_guide_end_xmin;
MCNUM xmax = mccLmon_guide_end_xmax;
MCNUM ymin = mccLmon_guide_end_ymin;
MCNUM ymax = mccLmon_guide_end_ymax;
MCNUM xwidth = mccLmon_guide_end_xwidth;
MCNUM yheight = mccLmon_guide_end_yheight;
MCNUM Lmin = mccLmon_guide_end_Lmin;
MCNUM Lmax = mccLmon_guide_end_Lmax;
MCNUM restore_neutron = mccLmon_guide_end_restore_neutron;
int nowritefile = mccLmon_guide_end_nowritefile;
#line 84 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 59525 "./ESS_BIFROST_shielding.c"
}   /* End of Lmon_guide_end=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompLmon_guide_end:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(85,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component SCalc [86] */
  mccoordschange(mcposrSCalc, mcrotrSCalc,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component SCalc (without coords transformations) */
  mcJumpTrace_SCalc:
  SIG_MESSAGE("SCalc (Trace)");
  mcDEBUG_COMP("SCalc")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompSCalc
  STORE_NEUTRON(86,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[86]++;
  mcPCounter[86] += p;
  mcP2Counter[86] += p*p;
#define mccompcurname  SCalc
#define mccompcurtype  Shielding_calculator
#define mccompcurindex 86
{   /* Declarations of SCalc=Shielding_calculator() SETTING parameters. */
MCNUM MaxRate = mccSCalc_MaxRate;
MCNUM Innerspace = mccSCalc_Innerspace;
char* NiCaptureFile = mccSCalc_NiCaptureFile;
char* TiCaptureFile = mccSCalc_TiCaptureFile;
char* TotalCaptureFile = mccSCalc_TotalCaptureFile;
char* OutputFile = mccSCalc_OutputFile;
}   /* End of SCalc=Shielding_calculator() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompSCalc:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(86,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component DoseFe [87] */
  mccoordschange(mcposrDoseFe, mcrotrDoseFe,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component DoseFe (without coords transformations) */
  mcJumpTrace_DoseFe:
  SIG_MESSAGE("DoseFe (Trace)");
  mcDEBUG_COMP("DoseFe")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDoseFe
  STORE_NEUTRON(87,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[87]++;
  mcPCounter[87] += p;
  mcP2Counter[87] += p*p;
#define mccompcurname  DoseFe
#define mccompcurtype  Dose_calculator
#define mccompcurindex 87
{   /* Declarations of DoseFe=Dose_calculator() SETTING parameters. */
char* Material = mccDoseFe_Material;
MCNUM Innerspace = mccDoseFe_Innerspace;
MCNUM Thickness = mccDoseFe_Thickness;
char* SteelTubing = mccDoseFe_SteelTubing;
MCNUM TubingThickness = mccDoseFe_TubingThickness;
char* NiCaptureFile = mccDoseFe_NiCaptureFile;
char* TiCaptureFile = mccDoseFe_TiCaptureFile;
char* TotalCaptureFile = mccDoseFe_TotalCaptureFile;
char* OutputFile = mccDoseFe_OutputFile;
}   /* End of DoseFe=Dose_calculator() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDoseFe:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(87,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component DoseConc [88] */
  mccoordschange(mcposrDoseConc, mcrotrDoseConc,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component DoseConc (without coords transformations) */
  mcJumpTrace_DoseConc:
  SIG_MESSAGE("DoseConc (Trace)");
  mcDEBUG_COMP("DoseConc")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDoseConc
  STORE_NEUTRON(88,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[88]++;
  mcPCounter[88] += p;
  mcP2Counter[88] += p*p;
#define mccompcurname  DoseConc
#define mccompcurtype  Dose_calculator
#define mccompcurindex 88
{   /* Declarations of DoseConc=Dose_calculator() SETTING parameters. */
char* Material = mccDoseConc_Material;
MCNUM Innerspace = mccDoseConc_Innerspace;
MCNUM Thickness = mccDoseConc_Thickness;
char* SteelTubing = mccDoseConc_SteelTubing;
MCNUM TubingThickness = mccDoseConc_TubingThickness;
char* NiCaptureFile = mccDoseConc_NiCaptureFile;
char* TiCaptureFile = mccDoseConc_TiCaptureFile;
char* TotalCaptureFile = mccDoseConc_TotalCaptureFile;
char* OutputFile = mccDoseConc_OutputFile;
}   /* End of DoseConc=Dose_calculator() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDoseConc:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(88,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component DoseStandard [89] */
  mccoordschange(mcposrDoseStandard, mcrotrDoseStandard,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component DoseStandard (without coords transformations) */
  mcJumpTrace_DoseStandard:
  SIG_MESSAGE("DoseStandard (Trace)");
  mcDEBUG_COMP("DoseStandard")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDoseStandard
  STORE_NEUTRON(89,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[89]++;
  mcPCounter[89] += p;
  mcP2Counter[89] += p*p;
#define mccompcurname  DoseStandard
#define mccompcurtype  Dose_calculator
#define mccompcurindex 89
{   /* Declarations of DoseStandard=Dose_calculator() SETTING parameters. */
char* Material = mccDoseStandard_Material;
MCNUM Innerspace = mccDoseStandard_Innerspace;
MCNUM Thickness = mccDoseStandard_Thickness;
char* SteelTubing = mccDoseStandard_SteelTubing;
MCNUM TubingThickness = mccDoseStandard_TubingThickness;
char* NiCaptureFile = mccDoseStandard_NiCaptureFile;
char* TiCaptureFile = mccDoseStandard_TiCaptureFile;
char* TotalCaptureFile = mccDoseStandard_TotalCaptureFile;
char* OutputFile = mccDoseStandard_OutputFile;
}   /* End of DoseStandard=Dose_calculator() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDoseStandard:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(89,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Dose5 [90] */
  mccoordschange(mcposrDose5, mcrotrDose5,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Dose5 (without coords transformations) */
  mcJumpTrace_Dose5:
  SIG_MESSAGE("Dose5 (Trace)");
  mcDEBUG_COMP("Dose5")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDose5
  STORE_NEUTRON(90,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[90]++;
  mcPCounter[90] += p;
  mcP2Counter[90] += p*p;
#define mccompcurname  Dose5
#define mccompcurtype  Dose_calculator
#define mccompcurindex 90
{   /* Declarations of Dose5=Dose_calculator() SETTING parameters. */
char* Material = mccDose5_Material;
MCNUM Innerspace = mccDose5_Innerspace;
MCNUM Thickness = mccDose5_Thickness;
char* SteelTubing = mccDose5_SteelTubing;
MCNUM TubingThickness = mccDose5_TubingThickness;
char* NiCaptureFile = mccDose5_NiCaptureFile;
char* TiCaptureFile = mccDose5_TiCaptureFile;
char* TotalCaptureFile = mccDose5_TotalCaptureFile;
char* OutputFile = mccDose5_OutputFile;
}   /* End of Dose5=Dose_calculator() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDose5:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(90,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  mcabsorbAll:
  mcDEBUG_LEAVE()
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)
  /* Copy neutron state to global variables. */
  mcnx = mcnlx;
  mcny = mcnly;
  mcnz = mcnlz;
  mcnvx = mcnlvx;
  mcnvy = mcnlvy;
  mcnvz = mcnlvz;
  mcnt = mcnlt;
  mcnsx = mcnlsx;
  mcnsy = mcnlsy;
  mcnsz = mcnlsz;
  mcnp = mcnlp;

} /* end trace */

void mcsave(FILE *handle) {
  if (!handle) mcsiminfo_init(NULL);
  /* User component SAVE code. */

  /* User SAVE code for component 'Origin'. */
  SIG_MESSAGE("Origin (Save)");
#define mccompcurname  Origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccOrigin_IntermediateCnts
#define StartTime mccOrigin_StartTime
#define EndTime mccOrigin_EndTime
#define CurrentTime mccOrigin_CurrentTime
{   /* Declarations of Origin=Progress_bar() SETTING parameters. */
char* profile = mccOrigin_profile;
MCNUM percent = mccOrigin_percent;
MCNUM flag_save = mccOrigin_flag_save;
MCNUM minutes = mccOrigin_minutes;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../misc/Progress_bar.comp"
{
  MPI_MASTER(fprintf(stdout, "\nSave [%s]\n", mcinstrument_name););
  if (profile && strlen(profile) && strcmp(profile,"NULL") && strcmp(profile,"0")) {
    char filename[256];
    if (!strlen(profile) || !strcmp(profile,"NULL") || !strcmp(profile,"0")) strcpy(filename, mcinstrument_name);
    else strcpy(filename, profile);
    DETECTOR_OUT_1D(
        "Intensity profiler",
        "Component index [1]",
        "Intensity",
        "prof", 1, mcNUMCOMP, mcNUMCOMP-1,
        &mcNCounter[1],&mcPCounter[1],&mcP2Counter[1],
        filename);

  }
}
#line 60205 "./ESS_BIFROST_shielding.c"
}   /* End of Origin=Progress_bar() SETTING parameter declarations. */
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'VirtualOutput'. */
  SIG_MESSAGE("VirtualOutput (Save)");
#define mccompcurname  VirtualOutput
#define mccompcurtype  Virtual_output
#define mccompcurindex 60
#define DEFS mccVirtualOutput_DEFS
#define Vars mccVirtualOutput_Vars
{   /* Declarations of VirtualOutput=Virtual_output() SETTING parameters. */
char* filename = mccVirtualOutput_filename;
MCNUM bufsize = mccVirtualOutput_bufsize;
#line 125 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../sources/Virtual_output.comp"
{

  Monitor_nD_Save(&DEFS, &Vars);

}
#line 60231 "./ESS_BIFROST_shielding.c"
}   /* End of VirtualOutput=Virtual_output() SETTING parameter declarations. */
#undef Vars
#undef DEFS
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'mndP01'. */
  SIG_MESSAGE("mndP01 (Save)");
#define mccompcurname  mndP01
#define mccompcurtype  Monitor_nD
#define mccompcurindex 66
#define user1 mccmndP01_user1
#define user2 mccmndP01_user2
#define user3 mccmndP01_user3
#define DEFS mccmndP01_DEFS
#define Vars mccmndP01_Vars
#define detector mccmndP01_detector
#define offdata mccmndP01_offdata
{   /* Declarations of mndP01=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccmndP01_xwidth;
MCNUM yheight = mccmndP01_yheight;
MCNUM zdepth = mccmndP01_zdepth;
MCNUM xmin = mccmndP01_xmin;
MCNUM xmax = mccmndP01_xmax;
MCNUM ymin = mccmndP01_ymin;
MCNUM ymax = mccmndP01_ymax;
MCNUM zmin = mccmndP01_zmin;
MCNUM zmax = mccmndP01_zmax;
MCNUM bins = mccmndP01_bins;
MCNUM min = mccmndP01_min;
MCNUM max = mccmndP01_max;
MCNUM restore_neutron = mccmndP01_restore_neutron;
MCNUM radius = mccmndP01_radius;
char* options = mccmndP01_options;
char* filename = mccmndP01_filename;
char* geometry = mccmndP01_geometry;
char* username1 = mccmndP01_username1;
char* username2 = mccmndP01_username2;
char* username3 = mccmndP01_username3;
int nowritefile = mccmndP01_nowritefile;
#line 483 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  /* save results, but do not free pointers */
  if (!nowritefile) {
    detector = Monitor_nD_Save(&DEFS, &Vars);
  }
}
#line 60280 "./ESS_BIFROST_shielding.c"
}   /* End of mndP01=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'mndP02'. */
  SIG_MESSAGE("mndP02 (Save)");
#define mccompcurname  mndP02
#define mccompcurtype  Monitor_nD
#define mccompcurindex 73
#define user1 mccmndP02_user1
#define user2 mccmndP02_user2
#define user3 mccmndP02_user3
#define DEFS mccmndP02_DEFS
#define Vars mccmndP02_Vars
#define detector mccmndP02_detector
#define offdata mccmndP02_offdata
{   /* Declarations of mndP02=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccmndP02_xwidth;
MCNUM yheight = mccmndP02_yheight;
MCNUM zdepth = mccmndP02_zdepth;
MCNUM xmin = mccmndP02_xmin;
MCNUM xmax = mccmndP02_xmax;
MCNUM ymin = mccmndP02_ymin;
MCNUM ymax = mccmndP02_ymax;
MCNUM zmin = mccmndP02_zmin;
MCNUM zmax = mccmndP02_zmax;
MCNUM bins = mccmndP02_bins;
MCNUM min = mccmndP02_min;
MCNUM max = mccmndP02_max;
MCNUM restore_neutron = mccmndP02_restore_neutron;
MCNUM radius = mccmndP02_radius;
char* options = mccmndP02_options;
char* filename = mccmndP02_filename;
char* geometry = mccmndP02_geometry;
char* username1 = mccmndP02_username1;
char* username2 = mccmndP02_username2;
char* username3 = mccmndP02_username3;
int nowritefile = mccmndP02_nowritefile;
#line 483 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  /* save results, but do not free pointers */
  if (!nowritefile) {
    detector = Monitor_nD_Save(&DEFS, &Vars);
  }
}
#line 60334 "./ESS_BIFROST_shielding.c"
}   /* End of mndP02=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'mndP03'. */
  SIG_MESSAGE("mndP03 (Save)");
#define mccompcurname  mndP03
#define mccompcurtype  Monitor_nD
#define mccompcurindex 80
#define user1 mccmndP03_user1
#define user2 mccmndP03_user2
#define user3 mccmndP03_user3
#define DEFS mccmndP03_DEFS
#define Vars mccmndP03_Vars
#define detector mccmndP03_detector
#define offdata mccmndP03_offdata
{   /* Declarations of mndP03=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccmndP03_xwidth;
MCNUM yheight = mccmndP03_yheight;
MCNUM zdepth = mccmndP03_zdepth;
MCNUM xmin = mccmndP03_xmin;
MCNUM xmax = mccmndP03_xmax;
MCNUM ymin = mccmndP03_ymin;
MCNUM ymax = mccmndP03_ymax;
MCNUM zmin = mccmndP03_zmin;
MCNUM zmax = mccmndP03_zmax;
MCNUM bins = mccmndP03_bins;
MCNUM min = mccmndP03_min;
MCNUM max = mccmndP03_max;
MCNUM restore_neutron = mccmndP03_restore_neutron;
MCNUM radius = mccmndP03_radius;
char* options = mccmndP03_options;
char* filename = mccmndP03_filename;
char* geometry = mccmndP03_geometry;
char* username1 = mccmndP03_username1;
char* username2 = mccmndP03_username2;
char* username3 = mccmndP03_username3;
int nowritefile = mccmndP03_nowritefile;
#line 483 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  /* save results, but do not free pointers */
  if (!nowritefile) {
    detector = Monitor_nD_Save(&DEFS, &Vars);
  }
}
#line 60388 "./ESS_BIFROST_shielding.c"
}   /* End of mndP03=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Lmon_guide_end'. */
  SIG_MESSAGE("Lmon_guide_end (Save)");
#define mccompcurname  Lmon_guide_end
#define mccompcurtype  L_monitor
#define mccompcurindex 85
#define nL mccLmon_guide_end_nL
#define L_N mccLmon_guide_end_L_N
#define L_p mccLmon_guide_end_L_p
#define L_p2 mccLmon_guide_end_L_p2
{   /* Declarations of Lmon_guide_end=L_monitor() SETTING parameters. */
char* filename = mccLmon_guide_end_filename;
MCNUM xmin = mccLmon_guide_end_xmin;
MCNUM xmax = mccLmon_guide_end_xmax;
MCNUM ymin = mccLmon_guide_end_ymin;
MCNUM ymax = mccLmon_guide_end_ymax;
MCNUM xwidth = mccLmon_guide_end_xwidth;
MCNUM yheight = mccLmon_guide_end_yheight;
MCNUM Lmin = mccLmon_guide_end_Lmin;
MCNUM Lmax = mccLmon_guide_end_Lmax;
MCNUM restore_neutron = mccLmon_guide_end_restore_neutron;
int nowritefile = mccLmon_guide_end_nowritefile;
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 60434 "./ESS_BIFROST_shielding.c"
}   /* End of Lmon_guide_end=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  if (!handle) mcsiminfo_close(); 
} /* end save */
void mcfinally(void) {
  /* User component FINALLY code. */
  mcsiminfo_init(NULL);
  mcsave(mcsiminfo_file); /* save data when simulation ends */

  /* User FINALLY code for component 'Origin'. */
  SIG_MESSAGE("Origin (Finally)");
#define mccompcurname  Origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccOrigin_IntermediateCnts
#define StartTime mccOrigin_StartTime
#define EndTime mccOrigin_EndTime
#define CurrentTime mccOrigin_CurrentTime
{   /* Declarations of Origin=Progress_bar() SETTING parameters. */
char* profile = mccOrigin_profile;
MCNUM percent = mccOrigin_percent;
MCNUM flag_save = mccOrigin_flag_save;
MCNUM minutes = mccOrigin_minutes;
#line 133 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../misc/Progress_bar.comp"
{
  time_t NowTime;
  time(&NowTime);
  fprintf(stdout, "\nFinally [%s: %s]. Time: ", mcinstrument_name, mcdirname ? mcdirname : ".");
  if (difftime(NowTime,StartTime) < 60.0)
    fprintf(stdout, "%g [s] ", difftime(NowTime,StartTime));
  else if (difftime(NowTime,StartTime) > 3600.0)
    fprintf(stdout, "%g [h] ", difftime(NowTime,StartTime)/3660.0);
  else
    fprintf(stdout, "%g [min] ", difftime(NowTime,StartTime)/60.0);
  fprintf(stdout, "\n");
}
#line 60478 "./ESS_BIFROST_shielding.c"
}   /* End of Origin=Progress_bar() SETTING parameter declarations. */
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[1]) fprintf(stderr, "Warning: No neutron could reach Component[1] Origin\n");
    if (mcAbsorbProp[1]) fprintf(stderr, "Warning: %g events were removed in Component[1] Origin=Progress_bar()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[1]);
    if (!mcNCounter[2]) fprintf(stderr, "Warning: No neutron could reach Component[2] ESS_source\n");
    if (mcAbsorbProp[2]) fprintf(stderr, "Warning: %g events were removed in Component[2] ESS_source=ESS_butterfly()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[2]);
    if (!mcNCounter[3]) fprintf(stderr, "Warning: No neutron could reach Component[3] StartOfGuide\n");
    if (mcAbsorbProp[3]) fprintf(stderr, "Warning: %g events were removed in Component[3] StartOfGuide=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[3]);
    if (!mcNCounter[4]) fprintf(stderr, "Warning: No neutron could reach Component[4] NBOA\n");
    if (mcAbsorbProp[4]) fprintf(stderr, "Warning: %g events were removed in Component[4] NBOA=Elliptic_guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[4]);
    if (!mcNCounter[5]) fprintf(stderr, "Warning: No neutron could reach Component[5] EndOfelement_6\n");
    if (mcAbsorbProp[5]) fprintf(stderr, "Warning: %g events were removed in Component[5] EndOfelement_6=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[5]);
    if (!mcNCounter[6]) fprintf(stderr, "Warning: No neutron could reach Component[6] EndOfelement_5\n");
    if (mcAbsorbProp[6]) fprintf(stderr, "Warning: %g events were removed in Component[6] EndOfelement_5=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[6]);
  /* User FINALLY code for component 'curved_guide_1_0'. */
  SIG_MESSAGE("curved_guide_1_0 (Finally)");
#define mccompcurname  curved_guide_1_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 7
#define GVars mcccurved_guide_1_0_GVars
#define pTable mcccurved_guide_1_0_pTable
{   /* Declarations of curved_guide_1_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_1_0_w1;
MCNUM h1 = mcccurved_guide_1_0_h1;
MCNUM w2 = mcccurved_guide_1_0_w2;
MCNUM h2 = mcccurved_guide_1_0_h2;
MCNUM l = mcccurved_guide_1_0_l;
MCNUM R0 = mcccurved_guide_1_0_R0;
MCNUM Qc = mcccurved_guide_1_0_Qc;
MCNUM alpha = mcccurved_guide_1_0_alpha;
MCNUM m = mcccurved_guide_1_0_m;
MCNUM W = mcccurved_guide_1_0_W;
MCNUM nslit = mcccurved_guide_1_0_nslit;
MCNUM d = mcccurved_guide_1_0_d;
MCNUM mleft = mcccurved_guide_1_0_mleft;
MCNUM mright = mcccurved_guide_1_0_mright;
MCNUM mtop = mcccurved_guide_1_0_mtop;
MCNUM mbottom = mcccurved_guide_1_0_mbottom;
MCNUM nhslit = mcccurved_guide_1_0_nhslit;
MCNUM G = mcccurved_guide_1_0_G;
MCNUM aleft = mcccurved_guide_1_0_aleft;
MCNUM aright = mcccurved_guide_1_0_aright;
MCNUM atop = mcccurved_guide_1_0_atop;
MCNUM abottom = mcccurved_guide_1_0_abottom;
MCNUM wavy = mcccurved_guide_1_0_wavy;
MCNUM wavy_z = mcccurved_guide_1_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_1_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_1_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_1_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_1_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_1_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_1_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_1_0_nelements;
MCNUM nu = mcccurved_guide_1_0_nu;
MCNUM phase = mcccurved_guide_1_0_phase;
char* reflect = mcccurved_guide_1_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 60549 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_1_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[7]) fprintf(stderr, "Warning: No neutron could reach Component[7] curved_guide_1_0\n");
    if (mcAbsorbProp[7]) fprintf(stderr, "Warning: %g events were removed in Component[7] curved_guide_1_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[7]);
  /* User FINALLY code for component 'curved_guide_2_0'. */
  SIG_MESSAGE("curved_guide_2_0 (Finally)");
#define mccompcurname  curved_guide_2_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 8
#define GVars mcccurved_guide_2_0_GVars
#define pTable mcccurved_guide_2_0_pTable
{   /* Declarations of curved_guide_2_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_2_0_w1;
MCNUM h1 = mcccurved_guide_2_0_h1;
MCNUM w2 = mcccurved_guide_2_0_w2;
MCNUM h2 = mcccurved_guide_2_0_h2;
MCNUM l = mcccurved_guide_2_0_l;
MCNUM R0 = mcccurved_guide_2_0_R0;
MCNUM Qc = mcccurved_guide_2_0_Qc;
MCNUM alpha = mcccurved_guide_2_0_alpha;
MCNUM m = mcccurved_guide_2_0_m;
MCNUM W = mcccurved_guide_2_0_W;
MCNUM nslit = mcccurved_guide_2_0_nslit;
MCNUM d = mcccurved_guide_2_0_d;
MCNUM mleft = mcccurved_guide_2_0_mleft;
MCNUM mright = mcccurved_guide_2_0_mright;
MCNUM mtop = mcccurved_guide_2_0_mtop;
MCNUM mbottom = mcccurved_guide_2_0_mbottom;
MCNUM nhslit = mcccurved_guide_2_0_nhslit;
MCNUM G = mcccurved_guide_2_0_G;
MCNUM aleft = mcccurved_guide_2_0_aleft;
MCNUM aright = mcccurved_guide_2_0_aright;
MCNUM atop = mcccurved_guide_2_0_atop;
MCNUM abottom = mcccurved_guide_2_0_abottom;
MCNUM wavy = mcccurved_guide_2_0_wavy;
MCNUM wavy_z = mcccurved_guide_2_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_2_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_2_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_2_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_2_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_2_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_2_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_2_0_nelements;
MCNUM nu = mcccurved_guide_2_0_nu;
MCNUM phase = mcccurved_guide_2_0_phase;
char* reflect = mcccurved_guide_2_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 60608 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_2_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[8]) fprintf(stderr, "Warning: No neutron could reach Component[8] curved_guide_2_0\n");
    if (mcAbsorbProp[8]) fprintf(stderr, "Warning: %g events were removed in Component[8] curved_guide_2_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[8]);
  /* User FINALLY code for component 'curved_guide_3_0'. */
  SIG_MESSAGE("curved_guide_3_0 (Finally)");
#define mccompcurname  curved_guide_3_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 9
#define GVars mcccurved_guide_3_0_GVars
#define pTable mcccurved_guide_3_0_pTable
{   /* Declarations of curved_guide_3_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_3_0_w1;
MCNUM h1 = mcccurved_guide_3_0_h1;
MCNUM w2 = mcccurved_guide_3_0_w2;
MCNUM h2 = mcccurved_guide_3_0_h2;
MCNUM l = mcccurved_guide_3_0_l;
MCNUM R0 = mcccurved_guide_3_0_R0;
MCNUM Qc = mcccurved_guide_3_0_Qc;
MCNUM alpha = mcccurved_guide_3_0_alpha;
MCNUM m = mcccurved_guide_3_0_m;
MCNUM W = mcccurved_guide_3_0_W;
MCNUM nslit = mcccurved_guide_3_0_nslit;
MCNUM d = mcccurved_guide_3_0_d;
MCNUM mleft = mcccurved_guide_3_0_mleft;
MCNUM mright = mcccurved_guide_3_0_mright;
MCNUM mtop = mcccurved_guide_3_0_mtop;
MCNUM mbottom = mcccurved_guide_3_0_mbottom;
MCNUM nhslit = mcccurved_guide_3_0_nhslit;
MCNUM G = mcccurved_guide_3_0_G;
MCNUM aleft = mcccurved_guide_3_0_aleft;
MCNUM aright = mcccurved_guide_3_0_aright;
MCNUM atop = mcccurved_guide_3_0_atop;
MCNUM abottom = mcccurved_guide_3_0_abottom;
MCNUM wavy = mcccurved_guide_3_0_wavy;
MCNUM wavy_z = mcccurved_guide_3_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_3_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_3_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_3_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_3_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_3_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_3_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_3_0_nelements;
MCNUM nu = mcccurved_guide_3_0_nu;
MCNUM phase = mcccurved_guide_3_0_phase;
char* reflect = mcccurved_guide_3_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 60667 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_3_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[9]) fprintf(stderr, "Warning: No neutron could reach Component[9] curved_guide_3_0\n");
    if (mcAbsorbProp[9]) fprintf(stderr, "Warning: %g events were removed in Component[9] curved_guide_3_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[9]);
  /* User FINALLY code for component 'curved_guide_4_0'. */
  SIG_MESSAGE("curved_guide_4_0 (Finally)");
#define mccompcurname  curved_guide_4_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 10
#define GVars mcccurved_guide_4_0_GVars
#define pTable mcccurved_guide_4_0_pTable
{   /* Declarations of curved_guide_4_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_4_0_w1;
MCNUM h1 = mcccurved_guide_4_0_h1;
MCNUM w2 = mcccurved_guide_4_0_w2;
MCNUM h2 = mcccurved_guide_4_0_h2;
MCNUM l = mcccurved_guide_4_0_l;
MCNUM R0 = mcccurved_guide_4_0_R0;
MCNUM Qc = mcccurved_guide_4_0_Qc;
MCNUM alpha = mcccurved_guide_4_0_alpha;
MCNUM m = mcccurved_guide_4_0_m;
MCNUM W = mcccurved_guide_4_0_W;
MCNUM nslit = mcccurved_guide_4_0_nslit;
MCNUM d = mcccurved_guide_4_0_d;
MCNUM mleft = mcccurved_guide_4_0_mleft;
MCNUM mright = mcccurved_guide_4_0_mright;
MCNUM mtop = mcccurved_guide_4_0_mtop;
MCNUM mbottom = mcccurved_guide_4_0_mbottom;
MCNUM nhslit = mcccurved_guide_4_0_nhslit;
MCNUM G = mcccurved_guide_4_0_G;
MCNUM aleft = mcccurved_guide_4_0_aleft;
MCNUM aright = mcccurved_guide_4_0_aright;
MCNUM atop = mcccurved_guide_4_0_atop;
MCNUM abottom = mcccurved_guide_4_0_abottom;
MCNUM wavy = mcccurved_guide_4_0_wavy;
MCNUM wavy_z = mcccurved_guide_4_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_4_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_4_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_4_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_4_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_4_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_4_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_4_0_nelements;
MCNUM nu = mcccurved_guide_4_0_nu;
MCNUM phase = mcccurved_guide_4_0_phase;
char* reflect = mcccurved_guide_4_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 60726 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_4_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[10]) fprintf(stderr, "Warning: No neutron could reach Component[10] curved_guide_4_0\n");
    if (mcAbsorbProp[10]) fprintf(stderr, "Warning: %g events were removed in Component[10] curved_guide_4_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[10]);
  /* User FINALLY code for component 'curved_guide_5_beforeChopper'. */
  SIG_MESSAGE("curved_guide_5_beforeChopper (Finally)");
#define mccompcurname  curved_guide_5_beforeChopper
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 11
#define GVars mcccurved_guide_5_beforeChopper_GVars
#define pTable mcccurved_guide_5_beforeChopper_pTable
{   /* Declarations of curved_guide_5_beforeChopper=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_5_beforeChopper_w1;
MCNUM h1 = mcccurved_guide_5_beforeChopper_h1;
MCNUM w2 = mcccurved_guide_5_beforeChopper_w2;
MCNUM h2 = mcccurved_guide_5_beforeChopper_h2;
MCNUM l = mcccurved_guide_5_beforeChopper_l;
MCNUM R0 = mcccurved_guide_5_beforeChopper_R0;
MCNUM Qc = mcccurved_guide_5_beforeChopper_Qc;
MCNUM alpha = mcccurved_guide_5_beforeChopper_alpha;
MCNUM m = mcccurved_guide_5_beforeChopper_m;
MCNUM W = mcccurved_guide_5_beforeChopper_W;
MCNUM nslit = mcccurved_guide_5_beforeChopper_nslit;
MCNUM d = mcccurved_guide_5_beforeChopper_d;
MCNUM mleft = mcccurved_guide_5_beforeChopper_mleft;
MCNUM mright = mcccurved_guide_5_beforeChopper_mright;
MCNUM mtop = mcccurved_guide_5_beforeChopper_mtop;
MCNUM mbottom = mcccurved_guide_5_beforeChopper_mbottom;
MCNUM nhslit = mcccurved_guide_5_beforeChopper_nhslit;
MCNUM G = mcccurved_guide_5_beforeChopper_G;
MCNUM aleft = mcccurved_guide_5_beforeChopper_aleft;
MCNUM aright = mcccurved_guide_5_beforeChopper_aright;
MCNUM atop = mcccurved_guide_5_beforeChopper_atop;
MCNUM abottom = mcccurved_guide_5_beforeChopper_abottom;
MCNUM wavy = mcccurved_guide_5_beforeChopper_wavy;
MCNUM wavy_z = mcccurved_guide_5_beforeChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_5_beforeChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_5_beforeChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_5_beforeChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_5_beforeChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_5_beforeChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_5_beforeChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_5_beforeChopper_nelements;
MCNUM nu = mcccurved_guide_5_beforeChopper_nu;
MCNUM phase = mcccurved_guide_5_beforeChopper_phase;
char* reflect = mcccurved_guide_5_beforeChopper_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 60785 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_5_beforeChopper=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[11]) fprintf(stderr, "Warning: No neutron could reach Component[11] curved_guide_5_beforeChopper\n");
    if (mcAbsorbProp[11]) fprintf(stderr, "Warning: %g events were removed in Component[11] curved_guide_5_beforeChopper=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[11]);
  /* User FINALLY code for component 'curved_guide_5_afterChopper'. */
  SIG_MESSAGE("curved_guide_5_afterChopper (Finally)");
#define mccompcurname  curved_guide_5_afterChopper
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 12
#define GVars mcccurved_guide_5_afterChopper_GVars
#define pTable mcccurved_guide_5_afterChopper_pTable
{   /* Declarations of curved_guide_5_afterChopper=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_5_afterChopper_w1;
MCNUM h1 = mcccurved_guide_5_afterChopper_h1;
MCNUM w2 = mcccurved_guide_5_afterChopper_w2;
MCNUM h2 = mcccurved_guide_5_afterChopper_h2;
MCNUM l = mcccurved_guide_5_afterChopper_l;
MCNUM R0 = mcccurved_guide_5_afterChopper_R0;
MCNUM Qc = mcccurved_guide_5_afterChopper_Qc;
MCNUM alpha = mcccurved_guide_5_afterChopper_alpha;
MCNUM m = mcccurved_guide_5_afterChopper_m;
MCNUM W = mcccurved_guide_5_afterChopper_W;
MCNUM nslit = mcccurved_guide_5_afterChopper_nslit;
MCNUM d = mcccurved_guide_5_afterChopper_d;
MCNUM mleft = mcccurved_guide_5_afterChopper_mleft;
MCNUM mright = mcccurved_guide_5_afterChopper_mright;
MCNUM mtop = mcccurved_guide_5_afterChopper_mtop;
MCNUM mbottom = mcccurved_guide_5_afterChopper_mbottom;
MCNUM nhslit = mcccurved_guide_5_afterChopper_nhslit;
MCNUM G = mcccurved_guide_5_afterChopper_G;
MCNUM aleft = mcccurved_guide_5_afterChopper_aleft;
MCNUM aright = mcccurved_guide_5_afterChopper_aright;
MCNUM atop = mcccurved_guide_5_afterChopper_atop;
MCNUM abottom = mcccurved_guide_5_afterChopper_abottom;
MCNUM wavy = mcccurved_guide_5_afterChopper_wavy;
MCNUM wavy_z = mcccurved_guide_5_afterChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_5_afterChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_5_afterChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_5_afterChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_5_afterChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_5_afterChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_5_afterChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_5_afterChopper_nelements;
MCNUM nu = mcccurved_guide_5_afterChopper_nu;
MCNUM phase = mcccurved_guide_5_afterChopper_phase;
char* reflect = mcccurved_guide_5_afterChopper_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 60844 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_5_afterChopper=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[12]) fprintf(stderr, "Warning: No neutron could reach Component[12] curved_guide_5_afterChopper\n");
    if (mcAbsorbProp[12]) fprintf(stderr, "Warning: %g events were removed in Component[12] curved_guide_5_afterChopper=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[12]);
  /* User FINALLY code for component 'curved_guide_6_0'. */
  SIG_MESSAGE("curved_guide_6_0 (Finally)");
#define mccompcurname  curved_guide_6_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 13
#define GVars mcccurved_guide_6_0_GVars
#define pTable mcccurved_guide_6_0_pTable
{   /* Declarations of curved_guide_6_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_6_0_w1;
MCNUM h1 = mcccurved_guide_6_0_h1;
MCNUM w2 = mcccurved_guide_6_0_w2;
MCNUM h2 = mcccurved_guide_6_0_h2;
MCNUM l = mcccurved_guide_6_0_l;
MCNUM R0 = mcccurved_guide_6_0_R0;
MCNUM Qc = mcccurved_guide_6_0_Qc;
MCNUM alpha = mcccurved_guide_6_0_alpha;
MCNUM m = mcccurved_guide_6_0_m;
MCNUM W = mcccurved_guide_6_0_W;
MCNUM nslit = mcccurved_guide_6_0_nslit;
MCNUM d = mcccurved_guide_6_0_d;
MCNUM mleft = mcccurved_guide_6_0_mleft;
MCNUM mright = mcccurved_guide_6_0_mright;
MCNUM mtop = mcccurved_guide_6_0_mtop;
MCNUM mbottom = mcccurved_guide_6_0_mbottom;
MCNUM nhslit = mcccurved_guide_6_0_nhslit;
MCNUM G = mcccurved_guide_6_0_G;
MCNUM aleft = mcccurved_guide_6_0_aleft;
MCNUM aright = mcccurved_guide_6_0_aright;
MCNUM atop = mcccurved_guide_6_0_atop;
MCNUM abottom = mcccurved_guide_6_0_abottom;
MCNUM wavy = mcccurved_guide_6_0_wavy;
MCNUM wavy_z = mcccurved_guide_6_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_6_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_6_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_6_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_6_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_6_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_6_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_6_0_nelements;
MCNUM nu = mcccurved_guide_6_0_nu;
MCNUM phase = mcccurved_guide_6_0_phase;
char* reflect = mcccurved_guide_6_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 60903 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_6_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[13]) fprintf(stderr, "Warning: No neutron could reach Component[13] curved_guide_6_0\n");
    if (mcAbsorbProp[13]) fprintf(stderr, "Warning: %g events were removed in Component[13] curved_guide_6_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[13]);
  /* User FINALLY code for component 'curved_guide_7_0'. */
  SIG_MESSAGE("curved_guide_7_0 (Finally)");
#define mccompcurname  curved_guide_7_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 14
#define GVars mcccurved_guide_7_0_GVars
#define pTable mcccurved_guide_7_0_pTable
{   /* Declarations of curved_guide_7_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_7_0_w1;
MCNUM h1 = mcccurved_guide_7_0_h1;
MCNUM w2 = mcccurved_guide_7_0_w2;
MCNUM h2 = mcccurved_guide_7_0_h2;
MCNUM l = mcccurved_guide_7_0_l;
MCNUM R0 = mcccurved_guide_7_0_R0;
MCNUM Qc = mcccurved_guide_7_0_Qc;
MCNUM alpha = mcccurved_guide_7_0_alpha;
MCNUM m = mcccurved_guide_7_0_m;
MCNUM W = mcccurved_guide_7_0_W;
MCNUM nslit = mcccurved_guide_7_0_nslit;
MCNUM d = mcccurved_guide_7_0_d;
MCNUM mleft = mcccurved_guide_7_0_mleft;
MCNUM mright = mcccurved_guide_7_0_mright;
MCNUM mtop = mcccurved_guide_7_0_mtop;
MCNUM mbottom = mcccurved_guide_7_0_mbottom;
MCNUM nhslit = mcccurved_guide_7_0_nhslit;
MCNUM G = mcccurved_guide_7_0_G;
MCNUM aleft = mcccurved_guide_7_0_aleft;
MCNUM aright = mcccurved_guide_7_0_aright;
MCNUM atop = mcccurved_guide_7_0_atop;
MCNUM abottom = mcccurved_guide_7_0_abottom;
MCNUM wavy = mcccurved_guide_7_0_wavy;
MCNUM wavy_z = mcccurved_guide_7_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_7_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_7_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_7_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_7_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_7_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_7_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_7_0_nelements;
MCNUM nu = mcccurved_guide_7_0_nu;
MCNUM phase = mcccurved_guide_7_0_phase;
char* reflect = mcccurved_guide_7_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 60962 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_7_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[14]) fprintf(stderr, "Warning: No neutron could reach Component[14] curved_guide_7_0\n");
    if (mcAbsorbProp[14]) fprintf(stderr, "Warning: %g events were removed in Component[14] curved_guide_7_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[14]);
  /* User FINALLY code for component 'curved_guide_8_0'. */
  SIG_MESSAGE("curved_guide_8_0 (Finally)");
#define mccompcurname  curved_guide_8_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 15
#define GVars mcccurved_guide_8_0_GVars
#define pTable mcccurved_guide_8_0_pTable
{   /* Declarations of curved_guide_8_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_8_0_w1;
MCNUM h1 = mcccurved_guide_8_0_h1;
MCNUM w2 = mcccurved_guide_8_0_w2;
MCNUM h2 = mcccurved_guide_8_0_h2;
MCNUM l = mcccurved_guide_8_0_l;
MCNUM R0 = mcccurved_guide_8_0_R0;
MCNUM Qc = mcccurved_guide_8_0_Qc;
MCNUM alpha = mcccurved_guide_8_0_alpha;
MCNUM m = mcccurved_guide_8_0_m;
MCNUM W = mcccurved_guide_8_0_W;
MCNUM nslit = mcccurved_guide_8_0_nslit;
MCNUM d = mcccurved_guide_8_0_d;
MCNUM mleft = mcccurved_guide_8_0_mleft;
MCNUM mright = mcccurved_guide_8_0_mright;
MCNUM mtop = mcccurved_guide_8_0_mtop;
MCNUM mbottom = mcccurved_guide_8_0_mbottom;
MCNUM nhslit = mcccurved_guide_8_0_nhslit;
MCNUM G = mcccurved_guide_8_0_G;
MCNUM aleft = mcccurved_guide_8_0_aleft;
MCNUM aright = mcccurved_guide_8_0_aright;
MCNUM atop = mcccurved_guide_8_0_atop;
MCNUM abottom = mcccurved_guide_8_0_abottom;
MCNUM wavy = mcccurved_guide_8_0_wavy;
MCNUM wavy_z = mcccurved_guide_8_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_8_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_8_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_8_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_8_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_8_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_8_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_8_0_nelements;
MCNUM nu = mcccurved_guide_8_0_nu;
MCNUM phase = mcccurved_guide_8_0_phase;
char* reflect = mcccurved_guide_8_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 61021 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_8_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[15]) fprintf(stderr, "Warning: No neutron could reach Component[15] curved_guide_8_0\n");
    if (mcAbsorbProp[15]) fprintf(stderr, "Warning: %g events were removed in Component[15] curved_guide_8_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[15]);
  /* User FINALLY code for component 'curved_guide_9_0'. */
  SIG_MESSAGE("curved_guide_9_0 (Finally)");
#define mccompcurname  curved_guide_9_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 16
#define GVars mcccurved_guide_9_0_GVars
#define pTable mcccurved_guide_9_0_pTable
{   /* Declarations of curved_guide_9_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_9_0_w1;
MCNUM h1 = mcccurved_guide_9_0_h1;
MCNUM w2 = mcccurved_guide_9_0_w2;
MCNUM h2 = mcccurved_guide_9_0_h2;
MCNUM l = mcccurved_guide_9_0_l;
MCNUM R0 = mcccurved_guide_9_0_R0;
MCNUM Qc = mcccurved_guide_9_0_Qc;
MCNUM alpha = mcccurved_guide_9_0_alpha;
MCNUM m = mcccurved_guide_9_0_m;
MCNUM W = mcccurved_guide_9_0_W;
MCNUM nslit = mcccurved_guide_9_0_nslit;
MCNUM d = mcccurved_guide_9_0_d;
MCNUM mleft = mcccurved_guide_9_0_mleft;
MCNUM mright = mcccurved_guide_9_0_mright;
MCNUM mtop = mcccurved_guide_9_0_mtop;
MCNUM mbottom = mcccurved_guide_9_0_mbottom;
MCNUM nhslit = mcccurved_guide_9_0_nhslit;
MCNUM G = mcccurved_guide_9_0_G;
MCNUM aleft = mcccurved_guide_9_0_aleft;
MCNUM aright = mcccurved_guide_9_0_aright;
MCNUM atop = mcccurved_guide_9_0_atop;
MCNUM abottom = mcccurved_guide_9_0_abottom;
MCNUM wavy = mcccurved_guide_9_0_wavy;
MCNUM wavy_z = mcccurved_guide_9_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_9_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_9_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_9_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_9_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_9_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_9_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_9_0_nelements;
MCNUM nu = mcccurved_guide_9_0_nu;
MCNUM phase = mcccurved_guide_9_0_phase;
char* reflect = mcccurved_guide_9_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 61080 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_9_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[16]) fprintf(stderr, "Warning: No neutron could reach Component[16] curved_guide_9_0\n");
    if (mcAbsorbProp[16]) fprintf(stderr, "Warning: %g events were removed in Component[16] curved_guide_9_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[16]);
  /* User FINALLY code for component 'curved_guide_10_0'. */
  SIG_MESSAGE("curved_guide_10_0 (Finally)");
#define mccompcurname  curved_guide_10_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 17
#define GVars mcccurved_guide_10_0_GVars
#define pTable mcccurved_guide_10_0_pTable
{   /* Declarations of curved_guide_10_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_10_0_w1;
MCNUM h1 = mcccurved_guide_10_0_h1;
MCNUM w2 = mcccurved_guide_10_0_w2;
MCNUM h2 = mcccurved_guide_10_0_h2;
MCNUM l = mcccurved_guide_10_0_l;
MCNUM R0 = mcccurved_guide_10_0_R0;
MCNUM Qc = mcccurved_guide_10_0_Qc;
MCNUM alpha = mcccurved_guide_10_0_alpha;
MCNUM m = mcccurved_guide_10_0_m;
MCNUM W = mcccurved_guide_10_0_W;
MCNUM nslit = mcccurved_guide_10_0_nslit;
MCNUM d = mcccurved_guide_10_0_d;
MCNUM mleft = mcccurved_guide_10_0_mleft;
MCNUM mright = mcccurved_guide_10_0_mright;
MCNUM mtop = mcccurved_guide_10_0_mtop;
MCNUM mbottom = mcccurved_guide_10_0_mbottom;
MCNUM nhslit = mcccurved_guide_10_0_nhslit;
MCNUM G = mcccurved_guide_10_0_G;
MCNUM aleft = mcccurved_guide_10_0_aleft;
MCNUM aright = mcccurved_guide_10_0_aright;
MCNUM atop = mcccurved_guide_10_0_atop;
MCNUM abottom = mcccurved_guide_10_0_abottom;
MCNUM wavy = mcccurved_guide_10_0_wavy;
MCNUM wavy_z = mcccurved_guide_10_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_10_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_10_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_10_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_10_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_10_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_10_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_10_0_nelements;
MCNUM nu = mcccurved_guide_10_0_nu;
MCNUM phase = mcccurved_guide_10_0_phase;
char* reflect = mcccurved_guide_10_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 61139 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_10_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[17]) fprintf(stderr, "Warning: No neutron could reach Component[17] curved_guide_10_0\n");
    if (mcAbsorbProp[17]) fprintf(stderr, "Warning: %g events were removed in Component[17] curved_guide_10_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[17]);
  /* User FINALLY code for component 'curved_guide_11_0'. */
  SIG_MESSAGE("curved_guide_11_0 (Finally)");
#define mccompcurname  curved_guide_11_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 18
#define GVars mcccurved_guide_11_0_GVars
#define pTable mcccurved_guide_11_0_pTable
{   /* Declarations of curved_guide_11_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_11_0_w1;
MCNUM h1 = mcccurved_guide_11_0_h1;
MCNUM w2 = mcccurved_guide_11_0_w2;
MCNUM h2 = mcccurved_guide_11_0_h2;
MCNUM l = mcccurved_guide_11_0_l;
MCNUM R0 = mcccurved_guide_11_0_R0;
MCNUM Qc = mcccurved_guide_11_0_Qc;
MCNUM alpha = mcccurved_guide_11_0_alpha;
MCNUM m = mcccurved_guide_11_0_m;
MCNUM W = mcccurved_guide_11_0_W;
MCNUM nslit = mcccurved_guide_11_0_nslit;
MCNUM d = mcccurved_guide_11_0_d;
MCNUM mleft = mcccurved_guide_11_0_mleft;
MCNUM mright = mcccurved_guide_11_0_mright;
MCNUM mtop = mcccurved_guide_11_0_mtop;
MCNUM mbottom = mcccurved_guide_11_0_mbottom;
MCNUM nhslit = mcccurved_guide_11_0_nhslit;
MCNUM G = mcccurved_guide_11_0_G;
MCNUM aleft = mcccurved_guide_11_0_aleft;
MCNUM aright = mcccurved_guide_11_0_aright;
MCNUM atop = mcccurved_guide_11_0_atop;
MCNUM abottom = mcccurved_guide_11_0_abottom;
MCNUM wavy = mcccurved_guide_11_0_wavy;
MCNUM wavy_z = mcccurved_guide_11_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_11_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_11_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_11_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_11_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_11_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_11_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_11_0_nelements;
MCNUM nu = mcccurved_guide_11_0_nu;
MCNUM phase = mcccurved_guide_11_0_phase;
char* reflect = mcccurved_guide_11_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 61198 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_11_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[18]) fprintf(stderr, "Warning: No neutron could reach Component[18] curved_guide_11_0\n");
    if (mcAbsorbProp[18]) fprintf(stderr, "Warning: %g events were removed in Component[18] curved_guide_11_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[18]);
  /* User FINALLY code for component 'curved_guide_12_0'. */
  SIG_MESSAGE("curved_guide_12_0 (Finally)");
#define mccompcurname  curved_guide_12_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 19
#define GVars mcccurved_guide_12_0_GVars
#define pTable mcccurved_guide_12_0_pTable
{   /* Declarations of curved_guide_12_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_12_0_w1;
MCNUM h1 = mcccurved_guide_12_0_h1;
MCNUM w2 = mcccurved_guide_12_0_w2;
MCNUM h2 = mcccurved_guide_12_0_h2;
MCNUM l = mcccurved_guide_12_0_l;
MCNUM R0 = mcccurved_guide_12_0_R0;
MCNUM Qc = mcccurved_guide_12_0_Qc;
MCNUM alpha = mcccurved_guide_12_0_alpha;
MCNUM m = mcccurved_guide_12_0_m;
MCNUM W = mcccurved_guide_12_0_W;
MCNUM nslit = mcccurved_guide_12_0_nslit;
MCNUM d = mcccurved_guide_12_0_d;
MCNUM mleft = mcccurved_guide_12_0_mleft;
MCNUM mright = mcccurved_guide_12_0_mright;
MCNUM mtop = mcccurved_guide_12_0_mtop;
MCNUM mbottom = mcccurved_guide_12_0_mbottom;
MCNUM nhslit = mcccurved_guide_12_0_nhslit;
MCNUM G = mcccurved_guide_12_0_G;
MCNUM aleft = mcccurved_guide_12_0_aleft;
MCNUM aright = mcccurved_guide_12_0_aright;
MCNUM atop = mcccurved_guide_12_0_atop;
MCNUM abottom = mcccurved_guide_12_0_abottom;
MCNUM wavy = mcccurved_guide_12_0_wavy;
MCNUM wavy_z = mcccurved_guide_12_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_12_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_12_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_12_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_12_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_12_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_12_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_12_0_nelements;
MCNUM nu = mcccurved_guide_12_0_nu;
MCNUM phase = mcccurved_guide_12_0_phase;
char* reflect = mcccurved_guide_12_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 61257 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_12_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[19]) fprintf(stderr, "Warning: No neutron could reach Component[19] curved_guide_12_0\n");
    if (mcAbsorbProp[19]) fprintf(stderr, "Warning: %g events were removed in Component[19] curved_guide_12_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[19]);
  /* User FINALLY code for component 'curved_guide_13_0'. */
  SIG_MESSAGE("curved_guide_13_0 (Finally)");
#define mccompcurname  curved_guide_13_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 20
#define GVars mcccurved_guide_13_0_GVars
#define pTable mcccurved_guide_13_0_pTable
{   /* Declarations of curved_guide_13_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_13_0_w1;
MCNUM h1 = mcccurved_guide_13_0_h1;
MCNUM w2 = mcccurved_guide_13_0_w2;
MCNUM h2 = mcccurved_guide_13_0_h2;
MCNUM l = mcccurved_guide_13_0_l;
MCNUM R0 = mcccurved_guide_13_0_R0;
MCNUM Qc = mcccurved_guide_13_0_Qc;
MCNUM alpha = mcccurved_guide_13_0_alpha;
MCNUM m = mcccurved_guide_13_0_m;
MCNUM W = mcccurved_guide_13_0_W;
MCNUM nslit = mcccurved_guide_13_0_nslit;
MCNUM d = mcccurved_guide_13_0_d;
MCNUM mleft = mcccurved_guide_13_0_mleft;
MCNUM mright = mcccurved_guide_13_0_mright;
MCNUM mtop = mcccurved_guide_13_0_mtop;
MCNUM mbottom = mcccurved_guide_13_0_mbottom;
MCNUM nhslit = mcccurved_guide_13_0_nhslit;
MCNUM G = mcccurved_guide_13_0_G;
MCNUM aleft = mcccurved_guide_13_0_aleft;
MCNUM aright = mcccurved_guide_13_0_aright;
MCNUM atop = mcccurved_guide_13_0_atop;
MCNUM abottom = mcccurved_guide_13_0_abottom;
MCNUM wavy = mcccurved_guide_13_0_wavy;
MCNUM wavy_z = mcccurved_guide_13_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_13_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_13_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_13_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_13_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_13_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_13_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_13_0_nelements;
MCNUM nu = mcccurved_guide_13_0_nu;
MCNUM phase = mcccurved_guide_13_0_phase;
char* reflect = mcccurved_guide_13_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 61316 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_13_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[20]) fprintf(stderr, "Warning: No neutron could reach Component[20] curved_guide_13_0\n");
    if (mcAbsorbProp[20]) fprintf(stderr, "Warning: %g events were removed in Component[20] curved_guide_13_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[20]);
  /* User FINALLY code for component 'curved_guide_14_0'. */
  SIG_MESSAGE("curved_guide_14_0 (Finally)");
#define mccompcurname  curved_guide_14_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 21
#define GVars mcccurved_guide_14_0_GVars
#define pTable mcccurved_guide_14_0_pTable
{   /* Declarations of curved_guide_14_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_14_0_w1;
MCNUM h1 = mcccurved_guide_14_0_h1;
MCNUM w2 = mcccurved_guide_14_0_w2;
MCNUM h2 = mcccurved_guide_14_0_h2;
MCNUM l = mcccurved_guide_14_0_l;
MCNUM R0 = mcccurved_guide_14_0_R0;
MCNUM Qc = mcccurved_guide_14_0_Qc;
MCNUM alpha = mcccurved_guide_14_0_alpha;
MCNUM m = mcccurved_guide_14_0_m;
MCNUM W = mcccurved_guide_14_0_W;
MCNUM nslit = mcccurved_guide_14_0_nslit;
MCNUM d = mcccurved_guide_14_0_d;
MCNUM mleft = mcccurved_guide_14_0_mleft;
MCNUM mright = mcccurved_guide_14_0_mright;
MCNUM mtop = mcccurved_guide_14_0_mtop;
MCNUM mbottom = mcccurved_guide_14_0_mbottom;
MCNUM nhslit = mcccurved_guide_14_0_nhslit;
MCNUM G = mcccurved_guide_14_0_G;
MCNUM aleft = mcccurved_guide_14_0_aleft;
MCNUM aright = mcccurved_guide_14_0_aright;
MCNUM atop = mcccurved_guide_14_0_atop;
MCNUM abottom = mcccurved_guide_14_0_abottom;
MCNUM wavy = mcccurved_guide_14_0_wavy;
MCNUM wavy_z = mcccurved_guide_14_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_14_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_14_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_14_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_14_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_14_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_14_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_14_0_nelements;
MCNUM nu = mcccurved_guide_14_0_nu;
MCNUM phase = mcccurved_guide_14_0_phase;
char* reflect = mcccurved_guide_14_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 61375 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_14_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[21]) fprintf(stderr, "Warning: No neutron could reach Component[21] curved_guide_14_0\n");
    if (mcAbsorbProp[21]) fprintf(stderr, "Warning: %g events were removed in Component[21] curved_guide_14_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[21]);
  /* User FINALLY code for component 'curved_guide_15_0'. */
  SIG_MESSAGE("curved_guide_15_0 (Finally)");
#define mccompcurname  curved_guide_15_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 22
#define GVars mcccurved_guide_15_0_GVars
#define pTable mcccurved_guide_15_0_pTable
{   /* Declarations of curved_guide_15_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_15_0_w1;
MCNUM h1 = mcccurved_guide_15_0_h1;
MCNUM w2 = mcccurved_guide_15_0_w2;
MCNUM h2 = mcccurved_guide_15_0_h2;
MCNUM l = mcccurved_guide_15_0_l;
MCNUM R0 = mcccurved_guide_15_0_R0;
MCNUM Qc = mcccurved_guide_15_0_Qc;
MCNUM alpha = mcccurved_guide_15_0_alpha;
MCNUM m = mcccurved_guide_15_0_m;
MCNUM W = mcccurved_guide_15_0_W;
MCNUM nslit = mcccurved_guide_15_0_nslit;
MCNUM d = mcccurved_guide_15_0_d;
MCNUM mleft = mcccurved_guide_15_0_mleft;
MCNUM mright = mcccurved_guide_15_0_mright;
MCNUM mtop = mcccurved_guide_15_0_mtop;
MCNUM mbottom = mcccurved_guide_15_0_mbottom;
MCNUM nhslit = mcccurved_guide_15_0_nhslit;
MCNUM G = mcccurved_guide_15_0_G;
MCNUM aleft = mcccurved_guide_15_0_aleft;
MCNUM aright = mcccurved_guide_15_0_aright;
MCNUM atop = mcccurved_guide_15_0_atop;
MCNUM abottom = mcccurved_guide_15_0_abottom;
MCNUM wavy = mcccurved_guide_15_0_wavy;
MCNUM wavy_z = mcccurved_guide_15_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_15_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_15_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_15_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_15_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_15_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_15_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_15_0_nelements;
MCNUM nu = mcccurved_guide_15_0_nu;
MCNUM phase = mcccurved_guide_15_0_phase;
char* reflect = mcccurved_guide_15_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 61434 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_15_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[22]) fprintf(stderr, "Warning: No neutron could reach Component[22] curved_guide_15_0\n");
    if (mcAbsorbProp[22]) fprintf(stderr, "Warning: %g events were removed in Component[22] curved_guide_15_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[22]);
  /* User FINALLY code for component 'curved_guide_16_0'. */
  SIG_MESSAGE("curved_guide_16_0 (Finally)");
#define mccompcurname  curved_guide_16_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 23
#define GVars mcccurved_guide_16_0_GVars
#define pTable mcccurved_guide_16_0_pTable
{   /* Declarations of curved_guide_16_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_16_0_w1;
MCNUM h1 = mcccurved_guide_16_0_h1;
MCNUM w2 = mcccurved_guide_16_0_w2;
MCNUM h2 = mcccurved_guide_16_0_h2;
MCNUM l = mcccurved_guide_16_0_l;
MCNUM R0 = mcccurved_guide_16_0_R0;
MCNUM Qc = mcccurved_guide_16_0_Qc;
MCNUM alpha = mcccurved_guide_16_0_alpha;
MCNUM m = mcccurved_guide_16_0_m;
MCNUM W = mcccurved_guide_16_0_W;
MCNUM nslit = mcccurved_guide_16_0_nslit;
MCNUM d = mcccurved_guide_16_0_d;
MCNUM mleft = mcccurved_guide_16_0_mleft;
MCNUM mright = mcccurved_guide_16_0_mright;
MCNUM mtop = mcccurved_guide_16_0_mtop;
MCNUM mbottom = mcccurved_guide_16_0_mbottom;
MCNUM nhslit = mcccurved_guide_16_0_nhslit;
MCNUM G = mcccurved_guide_16_0_G;
MCNUM aleft = mcccurved_guide_16_0_aleft;
MCNUM aright = mcccurved_guide_16_0_aright;
MCNUM atop = mcccurved_guide_16_0_atop;
MCNUM abottom = mcccurved_guide_16_0_abottom;
MCNUM wavy = mcccurved_guide_16_0_wavy;
MCNUM wavy_z = mcccurved_guide_16_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_16_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_16_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_16_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_16_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_16_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_16_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_16_0_nelements;
MCNUM nu = mcccurved_guide_16_0_nu;
MCNUM phase = mcccurved_guide_16_0_phase;
char* reflect = mcccurved_guide_16_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 61493 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_16_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[23]) fprintf(stderr, "Warning: No neutron could reach Component[23] curved_guide_16_0\n");
    if (mcAbsorbProp[23]) fprintf(stderr, "Warning: %g events were removed in Component[23] curved_guide_16_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[23]);
  /* User FINALLY code for component 'curved_guide_17_0'. */
  SIG_MESSAGE("curved_guide_17_0 (Finally)");
#define mccompcurname  curved_guide_17_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 24
#define GVars mcccurved_guide_17_0_GVars
#define pTable mcccurved_guide_17_0_pTable
{   /* Declarations of curved_guide_17_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_17_0_w1;
MCNUM h1 = mcccurved_guide_17_0_h1;
MCNUM w2 = mcccurved_guide_17_0_w2;
MCNUM h2 = mcccurved_guide_17_0_h2;
MCNUM l = mcccurved_guide_17_0_l;
MCNUM R0 = mcccurved_guide_17_0_R0;
MCNUM Qc = mcccurved_guide_17_0_Qc;
MCNUM alpha = mcccurved_guide_17_0_alpha;
MCNUM m = mcccurved_guide_17_0_m;
MCNUM W = mcccurved_guide_17_0_W;
MCNUM nslit = mcccurved_guide_17_0_nslit;
MCNUM d = mcccurved_guide_17_0_d;
MCNUM mleft = mcccurved_guide_17_0_mleft;
MCNUM mright = mcccurved_guide_17_0_mright;
MCNUM mtop = mcccurved_guide_17_0_mtop;
MCNUM mbottom = mcccurved_guide_17_0_mbottom;
MCNUM nhslit = mcccurved_guide_17_0_nhslit;
MCNUM G = mcccurved_guide_17_0_G;
MCNUM aleft = mcccurved_guide_17_0_aleft;
MCNUM aright = mcccurved_guide_17_0_aright;
MCNUM atop = mcccurved_guide_17_0_atop;
MCNUM abottom = mcccurved_guide_17_0_abottom;
MCNUM wavy = mcccurved_guide_17_0_wavy;
MCNUM wavy_z = mcccurved_guide_17_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_17_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_17_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_17_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_17_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_17_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_17_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_17_0_nelements;
MCNUM nu = mcccurved_guide_17_0_nu;
MCNUM phase = mcccurved_guide_17_0_phase;
char* reflect = mcccurved_guide_17_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 61552 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_17_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[24]) fprintf(stderr, "Warning: No neutron could reach Component[24] curved_guide_17_0\n");
    if (mcAbsorbProp[24]) fprintf(stderr, "Warning: %g events were removed in Component[24] curved_guide_17_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[24]);
  /* User FINALLY code for component 'curved_guide_18_beforeChopper'. */
  SIG_MESSAGE("curved_guide_18_beforeChopper (Finally)");
#define mccompcurname  curved_guide_18_beforeChopper
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 25
#define GVars mcccurved_guide_18_beforeChopper_GVars
#define pTable mcccurved_guide_18_beforeChopper_pTable
{   /* Declarations of curved_guide_18_beforeChopper=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_18_beforeChopper_w1;
MCNUM h1 = mcccurved_guide_18_beforeChopper_h1;
MCNUM w2 = mcccurved_guide_18_beforeChopper_w2;
MCNUM h2 = mcccurved_guide_18_beforeChopper_h2;
MCNUM l = mcccurved_guide_18_beforeChopper_l;
MCNUM R0 = mcccurved_guide_18_beforeChopper_R0;
MCNUM Qc = mcccurved_guide_18_beforeChopper_Qc;
MCNUM alpha = mcccurved_guide_18_beforeChopper_alpha;
MCNUM m = mcccurved_guide_18_beforeChopper_m;
MCNUM W = mcccurved_guide_18_beforeChopper_W;
MCNUM nslit = mcccurved_guide_18_beforeChopper_nslit;
MCNUM d = mcccurved_guide_18_beforeChopper_d;
MCNUM mleft = mcccurved_guide_18_beforeChopper_mleft;
MCNUM mright = mcccurved_guide_18_beforeChopper_mright;
MCNUM mtop = mcccurved_guide_18_beforeChopper_mtop;
MCNUM mbottom = mcccurved_guide_18_beforeChopper_mbottom;
MCNUM nhslit = mcccurved_guide_18_beforeChopper_nhslit;
MCNUM G = mcccurved_guide_18_beforeChopper_G;
MCNUM aleft = mcccurved_guide_18_beforeChopper_aleft;
MCNUM aright = mcccurved_guide_18_beforeChopper_aright;
MCNUM atop = mcccurved_guide_18_beforeChopper_atop;
MCNUM abottom = mcccurved_guide_18_beforeChopper_abottom;
MCNUM wavy = mcccurved_guide_18_beforeChopper_wavy;
MCNUM wavy_z = mcccurved_guide_18_beforeChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_18_beforeChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_18_beforeChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_18_beforeChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_18_beforeChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_18_beforeChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_18_beforeChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_18_beforeChopper_nelements;
MCNUM nu = mcccurved_guide_18_beforeChopper_nu;
MCNUM phase = mcccurved_guide_18_beforeChopper_phase;
char* reflect = mcccurved_guide_18_beforeChopper_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 61611 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_18_beforeChopper=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[25]) fprintf(stderr, "Warning: No neutron could reach Component[25] curved_guide_18_beforeChopper\n");
    if (mcAbsorbProp[25]) fprintf(stderr, "Warning: %g events were removed in Component[25] curved_guide_18_beforeChopper=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[25]);
  /* User FINALLY code for component 'curved_guide_18_afterChopper'. */
  SIG_MESSAGE("curved_guide_18_afterChopper (Finally)");
#define mccompcurname  curved_guide_18_afterChopper
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 26
#define GVars mcccurved_guide_18_afterChopper_GVars
#define pTable mcccurved_guide_18_afterChopper_pTable
{   /* Declarations of curved_guide_18_afterChopper=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_18_afterChopper_w1;
MCNUM h1 = mcccurved_guide_18_afterChopper_h1;
MCNUM w2 = mcccurved_guide_18_afterChopper_w2;
MCNUM h2 = mcccurved_guide_18_afterChopper_h2;
MCNUM l = mcccurved_guide_18_afterChopper_l;
MCNUM R0 = mcccurved_guide_18_afterChopper_R0;
MCNUM Qc = mcccurved_guide_18_afterChopper_Qc;
MCNUM alpha = mcccurved_guide_18_afterChopper_alpha;
MCNUM m = mcccurved_guide_18_afterChopper_m;
MCNUM W = mcccurved_guide_18_afterChopper_W;
MCNUM nslit = mcccurved_guide_18_afterChopper_nslit;
MCNUM d = mcccurved_guide_18_afterChopper_d;
MCNUM mleft = mcccurved_guide_18_afterChopper_mleft;
MCNUM mright = mcccurved_guide_18_afterChopper_mright;
MCNUM mtop = mcccurved_guide_18_afterChopper_mtop;
MCNUM mbottom = mcccurved_guide_18_afterChopper_mbottom;
MCNUM nhslit = mcccurved_guide_18_afterChopper_nhslit;
MCNUM G = mcccurved_guide_18_afterChopper_G;
MCNUM aleft = mcccurved_guide_18_afterChopper_aleft;
MCNUM aright = mcccurved_guide_18_afterChopper_aright;
MCNUM atop = mcccurved_guide_18_afterChopper_atop;
MCNUM abottom = mcccurved_guide_18_afterChopper_abottom;
MCNUM wavy = mcccurved_guide_18_afterChopper_wavy;
MCNUM wavy_z = mcccurved_guide_18_afterChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_18_afterChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_18_afterChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_18_afterChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_18_afterChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_18_afterChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_18_afterChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_18_afterChopper_nelements;
MCNUM nu = mcccurved_guide_18_afterChopper_nu;
MCNUM phase = mcccurved_guide_18_afterChopper_phase;
char* reflect = mcccurved_guide_18_afterChopper_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 61670 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_18_afterChopper=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[26]) fprintf(stderr, "Warning: No neutron could reach Component[26] curved_guide_18_afterChopper\n");
    if (mcAbsorbProp[26]) fprintf(stderr, "Warning: %g events were removed in Component[26] curved_guide_18_afterChopper=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[26]);
  /* User FINALLY code for component 'curved_guide_19_0'. */
  SIG_MESSAGE("curved_guide_19_0 (Finally)");
#define mccompcurname  curved_guide_19_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 27
#define GVars mcccurved_guide_19_0_GVars
#define pTable mcccurved_guide_19_0_pTable
{   /* Declarations of curved_guide_19_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_19_0_w1;
MCNUM h1 = mcccurved_guide_19_0_h1;
MCNUM w2 = mcccurved_guide_19_0_w2;
MCNUM h2 = mcccurved_guide_19_0_h2;
MCNUM l = mcccurved_guide_19_0_l;
MCNUM R0 = mcccurved_guide_19_0_R0;
MCNUM Qc = mcccurved_guide_19_0_Qc;
MCNUM alpha = mcccurved_guide_19_0_alpha;
MCNUM m = mcccurved_guide_19_0_m;
MCNUM W = mcccurved_guide_19_0_W;
MCNUM nslit = mcccurved_guide_19_0_nslit;
MCNUM d = mcccurved_guide_19_0_d;
MCNUM mleft = mcccurved_guide_19_0_mleft;
MCNUM mright = mcccurved_guide_19_0_mright;
MCNUM mtop = mcccurved_guide_19_0_mtop;
MCNUM mbottom = mcccurved_guide_19_0_mbottom;
MCNUM nhslit = mcccurved_guide_19_0_nhslit;
MCNUM G = mcccurved_guide_19_0_G;
MCNUM aleft = mcccurved_guide_19_0_aleft;
MCNUM aright = mcccurved_guide_19_0_aright;
MCNUM atop = mcccurved_guide_19_0_atop;
MCNUM abottom = mcccurved_guide_19_0_abottom;
MCNUM wavy = mcccurved_guide_19_0_wavy;
MCNUM wavy_z = mcccurved_guide_19_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_19_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_19_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_19_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_19_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_19_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_19_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_19_0_nelements;
MCNUM nu = mcccurved_guide_19_0_nu;
MCNUM phase = mcccurved_guide_19_0_phase;
char* reflect = mcccurved_guide_19_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 61729 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_19_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[27]) fprintf(stderr, "Warning: No neutron could reach Component[27] curved_guide_19_0\n");
    if (mcAbsorbProp[27]) fprintf(stderr, "Warning: %g events were removed in Component[27] curved_guide_19_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[27]);
  /* User FINALLY code for component 'curved_guide_20_0'. */
  SIG_MESSAGE("curved_guide_20_0 (Finally)");
#define mccompcurname  curved_guide_20_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 28
#define GVars mcccurved_guide_20_0_GVars
#define pTable mcccurved_guide_20_0_pTable
{   /* Declarations of curved_guide_20_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_20_0_w1;
MCNUM h1 = mcccurved_guide_20_0_h1;
MCNUM w2 = mcccurved_guide_20_0_w2;
MCNUM h2 = mcccurved_guide_20_0_h2;
MCNUM l = mcccurved_guide_20_0_l;
MCNUM R0 = mcccurved_guide_20_0_R0;
MCNUM Qc = mcccurved_guide_20_0_Qc;
MCNUM alpha = mcccurved_guide_20_0_alpha;
MCNUM m = mcccurved_guide_20_0_m;
MCNUM W = mcccurved_guide_20_0_W;
MCNUM nslit = mcccurved_guide_20_0_nslit;
MCNUM d = mcccurved_guide_20_0_d;
MCNUM mleft = mcccurved_guide_20_0_mleft;
MCNUM mright = mcccurved_guide_20_0_mright;
MCNUM mtop = mcccurved_guide_20_0_mtop;
MCNUM mbottom = mcccurved_guide_20_0_mbottom;
MCNUM nhslit = mcccurved_guide_20_0_nhslit;
MCNUM G = mcccurved_guide_20_0_G;
MCNUM aleft = mcccurved_guide_20_0_aleft;
MCNUM aright = mcccurved_guide_20_0_aright;
MCNUM atop = mcccurved_guide_20_0_atop;
MCNUM abottom = mcccurved_guide_20_0_abottom;
MCNUM wavy = mcccurved_guide_20_0_wavy;
MCNUM wavy_z = mcccurved_guide_20_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_20_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_20_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_20_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_20_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_20_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_20_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_20_0_nelements;
MCNUM nu = mcccurved_guide_20_0_nu;
MCNUM phase = mcccurved_guide_20_0_phase;
char* reflect = mcccurved_guide_20_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 61788 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_20_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[28]) fprintf(stderr, "Warning: No neutron could reach Component[28] curved_guide_20_0\n");
    if (mcAbsorbProp[28]) fprintf(stderr, "Warning: %g events were removed in Component[28] curved_guide_20_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[28]);
  /* User FINALLY code for component 'curved_guide_21_0'. */
  SIG_MESSAGE("curved_guide_21_0 (Finally)");
#define mccompcurname  curved_guide_21_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 29
#define GVars mcccurved_guide_21_0_GVars
#define pTable mcccurved_guide_21_0_pTable
{   /* Declarations of curved_guide_21_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_21_0_w1;
MCNUM h1 = mcccurved_guide_21_0_h1;
MCNUM w2 = mcccurved_guide_21_0_w2;
MCNUM h2 = mcccurved_guide_21_0_h2;
MCNUM l = mcccurved_guide_21_0_l;
MCNUM R0 = mcccurved_guide_21_0_R0;
MCNUM Qc = mcccurved_guide_21_0_Qc;
MCNUM alpha = mcccurved_guide_21_0_alpha;
MCNUM m = mcccurved_guide_21_0_m;
MCNUM W = mcccurved_guide_21_0_W;
MCNUM nslit = mcccurved_guide_21_0_nslit;
MCNUM d = mcccurved_guide_21_0_d;
MCNUM mleft = mcccurved_guide_21_0_mleft;
MCNUM mright = mcccurved_guide_21_0_mright;
MCNUM mtop = mcccurved_guide_21_0_mtop;
MCNUM mbottom = mcccurved_guide_21_0_mbottom;
MCNUM nhslit = mcccurved_guide_21_0_nhslit;
MCNUM G = mcccurved_guide_21_0_G;
MCNUM aleft = mcccurved_guide_21_0_aleft;
MCNUM aright = mcccurved_guide_21_0_aright;
MCNUM atop = mcccurved_guide_21_0_atop;
MCNUM abottom = mcccurved_guide_21_0_abottom;
MCNUM wavy = mcccurved_guide_21_0_wavy;
MCNUM wavy_z = mcccurved_guide_21_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_21_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_21_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_21_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_21_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_21_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_21_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_21_0_nelements;
MCNUM nu = mcccurved_guide_21_0_nu;
MCNUM phase = mcccurved_guide_21_0_phase;
char* reflect = mcccurved_guide_21_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 61847 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_21_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[29]) fprintf(stderr, "Warning: No neutron could reach Component[29] curved_guide_21_0\n");
    if (mcAbsorbProp[29]) fprintf(stderr, "Warning: %g events were removed in Component[29] curved_guide_21_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[29]);
  /* User FINALLY code for component 'curved_guide_22_0'. */
  SIG_MESSAGE("curved_guide_22_0 (Finally)");
#define mccompcurname  curved_guide_22_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 30
#define GVars mcccurved_guide_22_0_GVars
#define pTable mcccurved_guide_22_0_pTable
{   /* Declarations of curved_guide_22_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_22_0_w1;
MCNUM h1 = mcccurved_guide_22_0_h1;
MCNUM w2 = mcccurved_guide_22_0_w2;
MCNUM h2 = mcccurved_guide_22_0_h2;
MCNUM l = mcccurved_guide_22_0_l;
MCNUM R0 = mcccurved_guide_22_0_R0;
MCNUM Qc = mcccurved_guide_22_0_Qc;
MCNUM alpha = mcccurved_guide_22_0_alpha;
MCNUM m = mcccurved_guide_22_0_m;
MCNUM W = mcccurved_guide_22_0_W;
MCNUM nslit = mcccurved_guide_22_0_nslit;
MCNUM d = mcccurved_guide_22_0_d;
MCNUM mleft = mcccurved_guide_22_0_mleft;
MCNUM mright = mcccurved_guide_22_0_mright;
MCNUM mtop = mcccurved_guide_22_0_mtop;
MCNUM mbottom = mcccurved_guide_22_0_mbottom;
MCNUM nhslit = mcccurved_guide_22_0_nhslit;
MCNUM G = mcccurved_guide_22_0_G;
MCNUM aleft = mcccurved_guide_22_0_aleft;
MCNUM aright = mcccurved_guide_22_0_aright;
MCNUM atop = mcccurved_guide_22_0_atop;
MCNUM abottom = mcccurved_guide_22_0_abottom;
MCNUM wavy = mcccurved_guide_22_0_wavy;
MCNUM wavy_z = mcccurved_guide_22_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_22_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_22_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_22_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_22_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_22_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_22_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_22_0_nelements;
MCNUM nu = mcccurved_guide_22_0_nu;
MCNUM phase = mcccurved_guide_22_0_phase;
char* reflect = mcccurved_guide_22_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 61906 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_22_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[30]) fprintf(stderr, "Warning: No neutron could reach Component[30] curved_guide_22_0\n");
    if (mcAbsorbProp[30]) fprintf(stderr, "Warning: %g events were removed in Component[30] curved_guide_22_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[30]);
  /* User FINALLY code for component 'curved_guide_23_0'. */
  SIG_MESSAGE("curved_guide_23_0 (Finally)");
#define mccompcurname  curved_guide_23_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 31
#define GVars mcccurved_guide_23_0_GVars
#define pTable mcccurved_guide_23_0_pTable
{   /* Declarations of curved_guide_23_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_23_0_w1;
MCNUM h1 = mcccurved_guide_23_0_h1;
MCNUM w2 = mcccurved_guide_23_0_w2;
MCNUM h2 = mcccurved_guide_23_0_h2;
MCNUM l = mcccurved_guide_23_0_l;
MCNUM R0 = mcccurved_guide_23_0_R0;
MCNUM Qc = mcccurved_guide_23_0_Qc;
MCNUM alpha = mcccurved_guide_23_0_alpha;
MCNUM m = mcccurved_guide_23_0_m;
MCNUM W = mcccurved_guide_23_0_W;
MCNUM nslit = mcccurved_guide_23_0_nslit;
MCNUM d = mcccurved_guide_23_0_d;
MCNUM mleft = mcccurved_guide_23_0_mleft;
MCNUM mright = mcccurved_guide_23_0_mright;
MCNUM mtop = mcccurved_guide_23_0_mtop;
MCNUM mbottom = mcccurved_guide_23_0_mbottom;
MCNUM nhslit = mcccurved_guide_23_0_nhslit;
MCNUM G = mcccurved_guide_23_0_G;
MCNUM aleft = mcccurved_guide_23_0_aleft;
MCNUM aright = mcccurved_guide_23_0_aright;
MCNUM atop = mcccurved_guide_23_0_atop;
MCNUM abottom = mcccurved_guide_23_0_abottom;
MCNUM wavy = mcccurved_guide_23_0_wavy;
MCNUM wavy_z = mcccurved_guide_23_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_23_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_23_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_23_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_23_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_23_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_23_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_23_0_nelements;
MCNUM nu = mcccurved_guide_23_0_nu;
MCNUM phase = mcccurved_guide_23_0_phase;
char* reflect = mcccurved_guide_23_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 61965 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_23_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[31]) fprintf(stderr, "Warning: No neutron could reach Component[31] curved_guide_23_0\n");
    if (mcAbsorbProp[31]) fprintf(stderr, "Warning: %g events were removed in Component[31] curved_guide_23_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[31]);
  /* User FINALLY code for component 'curved_guide_24_0'. */
  SIG_MESSAGE("curved_guide_24_0 (Finally)");
#define mccompcurname  curved_guide_24_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 32
#define GVars mcccurved_guide_24_0_GVars
#define pTable mcccurved_guide_24_0_pTable
{   /* Declarations of curved_guide_24_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_24_0_w1;
MCNUM h1 = mcccurved_guide_24_0_h1;
MCNUM w2 = mcccurved_guide_24_0_w2;
MCNUM h2 = mcccurved_guide_24_0_h2;
MCNUM l = mcccurved_guide_24_0_l;
MCNUM R0 = mcccurved_guide_24_0_R0;
MCNUM Qc = mcccurved_guide_24_0_Qc;
MCNUM alpha = mcccurved_guide_24_0_alpha;
MCNUM m = mcccurved_guide_24_0_m;
MCNUM W = mcccurved_guide_24_0_W;
MCNUM nslit = mcccurved_guide_24_0_nslit;
MCNUM d = mcccurved_guide_24_0_d;
MCNUM mleft = mcccurved_guide_24_0_mleft;
MCNUM mright = mcccurved_guide_24_0_mright;
MCNUM mtop = mcccurved_guide_24_0_mtop;
MCNUM mbottom = mcccurved_guide_24_0_mbottom;
MCNUM nhslit = mcccurved_guide_24_0_nhslit;
MCNUM G = mcccurved_guide_24_0_G;
MCNUM aleft = mcccurved_guide_24_0_aleft;
MCNUM aright = mcccurved_guide_24_0_aright;
MCNUM atop = mcccurved_guide_24_0_atop;
MCNUM abottom = mcccurved_guide_24_0_abottom;
MCNUM wavy = mcccurved_guide_24_0_wavy;
MCNUM wavy_z = mcccurved_guide_24_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_24_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_24_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_24_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_24_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_24_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_24_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_24_0_nelements;
MCNUM nu = mcccurved_guide_24_0_nu;
MCNUM phase = mcccurved_guide_24_0_phase;
char* reflect = mcccurved_guide_24_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 62024 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_24_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[32]) fprintf(stderr, "Warning: No neutron could reach Component[32] curved_guide_24_0\n");
    if (mcAbsorbProp[32]) fprintf(stderr, "Warning: %g events were removed in Component[32] curved_guide_24_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[32]);
  /* User FINALLY code for component 'curved_guide_25_0'. */
  SIG_MESSAGE("curved_guide_25_0 (Finally)");
#define mccompcurname  curved_guide_25_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 33
#define GVars mcccurved_guide_25_0_GVars
#define pTable mcccurved_guide_25_0_pTable
{   /* Declarations of curved_guide_25_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_25_0_w1;
MCNUM h1 = mcccurved_guide_25_0_h1;
MCNUM w2 = mcccurved_guide_25_0_w2;
MCNUM h2 = mcccurved_guide_25_0_h2;
MCNUM l = mcccurved_guide_25_0_l;
MCNUM R0 = mcccurved_guide_25_0_R0;
MCNUM Qc = mcccurved_guide_25_0_Qc;
MCNUM alpha = mcccurved_guide_25_0_alpha;
MCNUM m = mcccurved_guide_25_0_m;
MCNUM W = mcccurved_guide_25_0_W;
MCNUM nslit = mcccurved_guide_25_0_nslit;
MCNUM d = mcccurved_guide_25_0_d;
MCNUM mleft = mcccurved_guide_25_0_mleft;
MCNUM mright = mcccurved_guide_25_0_mright;
MCNUM mtop = mcccurved_guide_25_0_mtop;
MCNUM mbottom = mcccurved_guide_25_0_mbottom;
MCNUM nhslit = mcccurved_guide_25_0_nhslit;
MCNUM G = mcccurved_guide_25_0_G;
MCNUM aleft = mcccurved_guide_25_0_aleft;
MCNUM aright = mcccurved_guide_25_0_aright;
MCNUM atop = mcccurved_guide_25_0_atop;
MCNUM abottom = mcccurved_guide_25_0_abottom;
MCNUM wavy = mcccurved_guide_25_0_wavy;
MCNUM wavy_z = mcccurved_guide_25_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_25_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_25_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_25_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_25_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_25_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_25_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_25_0_nelements;
MCNUM nu = mcccurved_guide_25_0_nu;
MCNUM phase = mcccurved_guide_25_0_phase;
char* reflect = mcccurved_guide_25_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 62083 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_25_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[33]) fprintf(stderr, "Warning: No neutron could reach Component[33] curved_guide_25_0\n");
    if (mcAbsorbProp[33]) fprintf(stderr, "Warning: %g events were removed in Component[33] curved_guide_25_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[33]);
  /* User FINALLY code for component 'curved_guide_26_0'. */
  SIG_MESSAGE("curved_guide_26_0 (Finally)");
#define mccompcurname  curved_guide_26_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 34
#define GVars mcccurved_guide_26_0_GVars
#define pTable mcccurved_guide_26_0_pTable
{   /* Declarations of curved_guide_26_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_26_0_w1;
MCNUM h1 = mcccurved_guide_26_0_h1;
MCNUM w2 = mcccurved_guide_26_0_w2;
MCNUM h2 = mcccurved_guide_26_0_h2;
MCNUM l = mcccurved_guide_26_0_l;
MCNUM R0 = mcccurved_guide_26_0_R0;
MCNUM Qc = mcccurved_guide_26_0_Qc;
MCNUM alpha = mcccurved_guide_26_0_alpha;
MCNUM m = mcccurved_guide_26_0_m;
MCNUM W = mcccurved_guide_26_0_W;
MCNUM nslit = mcccurved_guide_26_0_nslit;
MCNUM d = mcccurved_guide_26_0_d;
MCNUM mleft = mcccurved_guide_26_0_mleft;
MCNUM mright = mcccurved_guide_26_0_mright;
MCNUM mtop = mcccurved_guide_26_0_mtop;
MCNUM mbottom = mcccurved_guide_26_0_mbottom;
MCNUM nhslit = mcccurved_guide_26_0_nhslit;
MCNUM G = mcccurved_guide_26_0_G;
MCNUM aleft = mcccurved_guide_26_0_aleft;
MCNUM aright = mcccurved_guide_26_0_aright;
MCNUM atop = mcccurved_guide_26_0_atop;
MCNUM abottom = mcccurved_guide_26_0_abottom;
MCNUM wavy = mcccurved_guide_26_0_wavy;
MCNUM wavy_z = mcccurved_guide_26_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_26_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_26_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_26_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_26_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_26_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_26_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_26_0_nelements;
MCNUM nu = mcccurved_guide_26_0_nu;
MCNUM phase = mcccurved_guide_26_0_phase;
char* reflect = mcccurved_guide_26_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 62142 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_26_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[34]) fprintf(stderr, "Warning: No neutron could reach Component[34] curved_guide_26_0\n");
    if (mcAbsorbProp[34]) fprintf(stderr, "Warning: %g events were removed in Component[34] curved_guide_26_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[34]);
  /* User FINALLY code for component 'curved_guide_27_0'. */
  SIG_MESSAGE("curved_guide_27_0 (Finally)");
#define mccompcurname  curved_guide_27_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 35
#define GVars mcccurved_guide_27_0_GVars
#define pTable mcccurved_guide_27_0_pTable
{   /* Declarations of curved_guide_27_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_27_0_w1;
MCNUM h1 = mcccurved_guide_27_0_h1;
MCNUM w2 = mcccurved_guide_27_0_w2;
MCNUM h2 = mcccurved_guide_27_0_h2;
MCNUM l = mcccurved_guide_27_0_l;
MCNUM R0 = mcccurved_guide_27_0_R0;
MCNUM Qc = mcccurved_guide_27_0_Qc;
MCNUM alpha = mcccurved_guide_27_0_alpha;
MCNUM m = mcccurved_guide_27_0_m;
MCNUM W = mcccurved_guide_27_0_W;
MCNUM nslit = mcccurved_guide_27_0_nslit;
MCNUM d = mcccurved_guide_27_0_d;
MCNUM mleft = mcccurved_guide_27_0_mleft;
MCNUM mright = mcccurved_guide_27_0_mright;
MCNUM mtop = mcccurved_guide_27_0_mtop;
MCNUM mbottom = mcccurved_guide_27_0_mbottom;
MCNUM nhslit = mcccurved_guide_27_0_nhslit;
MCNUM G = mcccurved_guide_27_0_G;
MCNUM aleft = mcccurved_guide_27_0_aleft;
MCNUM aright = mcccurved_guide_27_0_aright;
MCNUM atop = mcccurved_guide_27_0_atop;
MCNUM abottom = mcccurved_guide_27_0_abottom;
MCNUM wavy = mcccurved_guide_27_0_wavy;
MCNUM wavy_z = mcccurved_guide_27_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_27_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_27_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_27_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_27_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_27_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_27_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_27_0_nelements;
MCNUM nu = mcccurved_guide_27_0_nu;
MCNUM phase = mcccurved_guide_27_0_phase;
char* reflect = mcccurved_guide_27_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 62201 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_27_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[35]) fprintf(stderr, "Warning: No neutron could reach Component[35] curved_guide_27_0\n");
    if (mcAbsorbProp[35]) fprintf(stderr, "Warning: %g events were removed in Component[35] curved_guide_27_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[35]);
  /* User FINALLY code for component 'curved_guide_28_0'. */
  SIG_MESSAGE("curved_guide_28_0 (Finally)");
#define mccompcurname  curved_guide_28_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 36
#define GVars mcccurved_guide_28_0_GVars
#define pTable mcccurved_guide_28_0_pTable
{   /* Declarations of curved_guide_28_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_28_0_w1;
MCNUM h1 = mcccurved_guide_28_0_h1;
MCNUM w2 = mcccurved_guide_28_0_w2;
MCNUM h2 = mcccurved_guide_28_0_h2;
MCNUM l = mcccurved_guide_28_0_l;
MCNUM R0 = mcccurved_guide_28_0_R0;
MCNUM Qc = mcccurved_guide_28_0_Qc;
MCNUM alpha = mcccurved_guide_28_0_alpha;
MCNUM m = mcccurved_guide_28_0_m;
MCNUM W = mcccurved_guide_28_0_W;
MCNUM nslit = mcccurved_guide_28_0_nslit;
MCNUM d = mcccurved_guide_28_0_d;
MCNUM mleft = mcccurved_guide_28_0_mleft;
MCNUM mright = mcccurved_guide_28_0_mright;
MCNUM mtop = mcccurved_guide_28_0_mtop;
MCNUM mbottom = mcccurved_guide_28_0_mbottom;
MCNUM nhslit = mcccurved_guide_28_0_nhslit;
MCNUM G = mcccurved_guide_28_0_G;
MCNUM aleft = mcccurved_guide_28_0_aleft;
MCNUM aright = mcccurved_guide_28_0_aright;
MCNUM atop = mcccurved_guide_28_0_atop;
MCNUM abottom = mcccurved_guide_28_0_abottom;
MCNUM wavy = mcccurved_guide_28_0_wavy;
MCNUM wavy_z = mcccurved_guide_28_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_28_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_28_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_28_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_28_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_28_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_28_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_28_0_nelements;
MCNUM nu = mcccurved_guide_28_0_nu;
MCNUM phase = mcccurved_guide_28_0_phase;
char* reflect = mcccurved_guide_28_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 62260 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_28_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[36]) fprintf(stderr, "Warning: No neutron could reach Component[36] curved_guide_28_0\n");
    if (mcAbsorbProp[36]) fprintf(stderr, "Warning: %g events were removed in Component[36] curved_guide_28_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[36]);
  /* User FINALLY code for component 'curved_guide_29_0'. */
  SIG_MESSAGE("curved_guide_29_0 (Finally)");
#define mccompcurname  curved_guide_29_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 37
#define GVars mcccurved_guide_29_0_GVars
#define pTable mcccurved_guide_29_0_pTable
{   /* Declarations of curved_guide_29_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_29_0_w1;
MCNUM h1 = mcccurved_guide_29_0_h1;
MCNUM w2 = mcccurved_guide_29_0_w2;
MCNUM h2 = mcccurved_guide_29_0_h2;
MCNUM l = mcccurved_guide_29_0_l;
MCNUM R0 = mcccurved_guide_29_0_R0;
MCNUM Qc = mcccurved_guide_29_0_Qc;
MCNUM alpha = mcccurved_guide_29_0_alpha;
MCNUM m = mcccurved_guide_29_0_m;
MCNUM W = mcccurved_guide_29_0_W;
MCNUM nslit = mcccurved_guide_29_0_nslit;
MCNUM d = mcccurved_guide_29_0_d;
MCNUM mleft = mcccurved_guide_29_0_mleft;
MCNUM mright = mcccurved_guide_29_0_mright;
MCNUM mtop = mcccurved_guide_29_0_mtop;
MCNUM mbottom = mcccurved_guide_29_0_mbottom;
MCNUM nhslit = mcccurved_guide_29_0_nhslit;
MCNUM G = mcccurved_guide_29_0_G;
MCNUM aleft = mcccurved_guide_29_0_aleft;
MCNUM aright = mcccurved_guide_29_0_aright;
MCNUM atop = mcccurved_guide_29_0_atop;
MCNUM abottom = mcccurved_guide_29_0_abottom;
MCNUM wavy = mcccurved_guide_29_0_wavy;
MCNUM wavy_z = mcccurved_guide_29_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_29_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_29_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_29_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_29_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_29_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_29_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_29_0_nelements;
MCNUM nu = mcccurved_guide_29_0_nu;
MCNUM phase = mcccurved_guide_29_0_phase;
char* reflect = mcccurved_guide_29_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 62319 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_29_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[37]) fprintf(stderr, "Warning: No neutron could reach Component[37] curved_guide_29_0\n");
    if (mcAbsorbProp[37]) fprintf(stderr, "Warning: %g events were removed in Component[37] curved_guide_29_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[37]);
  /* User FINALLY code for component 'curved_guide_30_0'. */
  SIG_MESSAGE("curved_guide_30_0 (Finally)");
#define mccompcurname  curved_guide_30_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 38
#define GVars mcccurved_guide_30_0_GVars
#define pTable mcccurved_guide_30_0_pTable
{   /* Declarations of curved_guide_30_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_30_0_w1;
MCNUM h1 = mcccurved_guide_30_0_h1;
MCNUM w2 = mcccurved_guide_30_0_w2;
MCNUM h2 = mcccurved_guide_30_0_h2;
MCNUM l = mcccurved_guide_30_0_l;
MCNUM R0 = mcccurved_guide_30_0_R0;
MCNUM Qc = mcccurved_guide_30_0_Qc;
MCNUM alpha = mcccurved_guide_30_0_alpha;
MCNUM m = mcccurved_guide_30_0_m;
MCNUM W = mcccurved_guide_30_0_W;
MCNUM nslit = mcccurved_guide_30_0_nslit;
MCNUM d = mcccurved_guide_30_0_d;
MCNUM mleft = mcccurved_guide_30_0_mleft;
MCNUM mright = mcccurved_guide_30_0_mright;
MCNUM mtop = mcccurved_guide_30_0_mtop;
MCNUM mbottom = mcccurved_guide_30_0_mbottom;
MCNUM nhslit = mcccurved_guide_30_0_nhslit;
MCNUM G = mcccurved_guide_30_0_G;
MCNUM aleft = mcccurved_guide_30_0_aleft;
MCNUM aright = mcccurved_guide_30_0_aright;
MCNUM atop = mcccurved_guide_30_0_atop;
MCNUM abottom = mcccurved_guide_30_0_abottom;
MCNUM wavy = mcccurved_guide_30_0_wavy;
MCNUM wavy_z = mcccurved_guide_30_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_30_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_30_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_30_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_30_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_30_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_30_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_30_0_nelements;
MCNUM nu = mcccurved_guide_30_0_nu;
MCNUM phase = mcccurved_guide_30_0_phase;
char* reflect = mcccurved_guide_30_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 62378 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_30_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[38]) fprintf(stderr, "Warning: No neutron could reach Component[38] curved_guide_30_0\n");
    if (mcAbsorbProp[38]) fprintf(stderr, "Warning: %g events were removed in Component[38] curved_guide_30_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[38]);
  /* User FINALLY code for component 'curved_guide_31_0'. */
  SIG_MESSAGE("curved_guide_31_0 (Finally)");
#define mccompcurname  curved_guide_31_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 39
#define GVars mcccurved_guide_31_0_GVars
#define pTable mcccurved_guide_31_0_pTable
{   /* Declarations of curved_guide_31_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_31_0_w1;
MCNUM h1 = mcccurved_guide_31_0_h1;
MCNUM w2 = mcccurved_guide_31_0_w2;
MCNUM h2 = mcccurved_guide_31_0_h2;
MCNUM l = mcccurved_guide_31_0_l;
MCNUM R0 = mcccurved_guide_31_0_R0;
MCNUM Qc = mcccurved_guide_31_0_Qc;
MCNUM alpha = mcccurved_guide_31_0_alpha;
MCNUM m = mcccurved_guide_31_0_m;
MCNUM W = mcccurved_guide_31_0_W;
MCNUM nslit = mcccurved_guide_31_0_nslit;
MCNUM d = mcccurved_guide_31_0_d;
MCNUM mleft = mcccurved_guide_31_0_mleft;
MCNUM mright = mcccurved_guide_31_0_mright;
MCNUM mtop = mcccurved_guide_31_0_mtop;
MCNUM mbottom = mcccurved_guide_31_0_mbottom;
MCNUM nhslit = mcccurved_guide_31_0_nhslit;
MCNUM G = mcccurved_guide_31_0_G;
MCNUM aleft = mcccurved_guide_31_0_aleft;
MCNUM aright = mcccurved_guide_31_0_aright;
MCNUM atop = mcccurved_guide_31_0_atop;
MCNUM abottom = mcccurved_guide_31_0_abottom;
MCNUM wavy = mcccurved_guide_31_0_wavy;
MCNUM wavy_z = mcccurved_guide_31_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_31_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_31_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_31_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_31_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_31_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_31_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_31_0_nelements;
MCNUM nu = mcccurved_guide_31_0_nu;
MCNUM phase = mcccurved_guide_31_0_phase;
char* reflect = mcccurved_guide_31_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 62437 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_31_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[39]) fprintf(stderr, "Warning: No neutron could reach Component[39] curved_guide_31_0\n");
    if (mcAbsorbProp[39]) fprintf(stderr, "Warning: %g events were removed in Component[39] curved_guide_31_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[39]);
  /* User FINALLY code for component 'curved_guide_32_0'. */
  SIG_MESSAGE("curved_guide_32_0 (Finally)");
#define mccompcurname  curved_guide_32_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 40
#define GVars mcccurved_guide_32_0_GVars
#define pTable mcccurved_guide_32_0_pTable
{   /* Declarations of curved_guide_32_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_32_0_w1;
MCNUM h1 = mcccurved_guide_32_0_h1;
MCNUM w2 = mcccurved_guide_32_0_w2;
MCNUM h2 = mcccurved_guide_32_0_h2;
MCNUM l = mcccurved_guide_32_0_l;
MCNUM R0 = mcccurved_guide_32_0_R0;
MCNUM Qc = mcccurved_guide_32_0_Qc;
MCNUM alpha = mcccurved_guide_32_0_alpha;
MCNUM m = mcccurved_guide_32_0_m;
MCNUM W = mcccurved_guide_32_0_W;
MCNUM nslit = mcccurved_guide_32_0_nslit;
MCNUM d = mcccurved_guide_32_0_d;
MCNUM mleft = mcccurved_guide_32_0_mleft;
MCNUM mright = mcccurved_guide_32_0_mright;
MCNUM mtop = mcccurved_guide_32_0_mtop;
MCNUM mbottom = mcccurved_guide_32_0_mbottom;
MCNUM nhslit = mcccurved_guide_32_0_nhslit;
MCNUM G = mcccurved_guide_32_0_G;
MCNUM aleft = mcccurved_guide_32_0_aleft;
MCNUM aright = mcccurved_guide_32_0_aright;
MCNUM atop = mcccurved_guide_32_0_atop;
MCNUM abottom = mcccurved_guide_32_0_abottom;
MCNUM wavy = mcccurved_guide_32_0_wavy;
MCNUM wavy_z = mcccurved_guide_32_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_32_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_32_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_32_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_32_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_32_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_32_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_32_0_nelements;
MCNUM nu = mcccurved_guide_32_0_nu;
MCNUM phase = mcccurved_guide_32_0_phase;
char* reflect = mcccurved_guide_32_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 62496 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_32_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[40]) fprintf(stderr, "Warning: No neutron could reach Component[40] curved_guide_32_0\n");
    if (mcAbsorbProp[40]) fprintf(stderr, "Warning: %g events were removed in Component[40] curved_guide_32_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[40]);
  /* User FINALLY code for component 'curved_guide_33_0'. */
  SIG_MESSAGE("curved_guide_33_0 (Finally)");
#define mccompcurname  curved_guide_33_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 41
#define GVars mcccurved_guide_33_0_GVars
#define pTable mcccurved_guide_33_0_pTable
{   /* Declarations of curved_guide_33_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_33_0_w1;
MCNUM h1 = mcccurved_guide_33_0_h1;
MCNUM w2 = mcccurved_guide_33_0_w2;
MCNUM h2 = mcccurved_guide_33_0_h2;
MCNUM l = mcccurved_guide_33_0_l;
MCNUM R0 = mcccurved_guide_33_0_R0;
MCNUM Qc = mcccurved_guide_33_0_Qc;
MCNUM alpha = mcccurved_guide_33_0_alpha;
MCNUM m = mcccurved_guide_33_0_m;
MCNUM W = mcccurved_guide_33_0_W;
MCNUM nslit = mcccurved_guide_33_0_nslit;
MCNUM d = mcccurved_guide_33_0_d;
MCNUM mleft = mcccurved_guide_33_0_mleft;
MCNUM mright = mcccurved_guide_33_0_mright;
MCNUM mtop = mcccurved_guide_33_0_mtop;
MCNUM mbottom = mcccurved_guide_33_0_mbottom;
MCNUM nhslit = mcccurved_guide_33_0_nhslit;
MCNUM G = mcccurved_guide_33_0_G;
MCNUM aleft = mcccurved_guide_33_0_aleft;
MCNUM aright = mcccurved_guide_33_0_aright;
MCNUM atop = mcccurved_guide_33_0_atop;
MCNUM abottom = mcccurved_guide_33_0_abottom;
MCNUM wavy = mcccurved_guide_33_0_wavy;
MCNUM wavy_z = mcccurved_guide_33_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_33_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_33_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_33_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_33_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_33_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_33_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_33_0_nelements;
MCNUM nu = mcccurved_guide_33_0_nu;
MCNUM phase = mcccurved_guide_33_0_phase;
char* reflect = mcccurved_guide_33_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 62555 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_33_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[41]) fprintf(stderr, "Warning: No neutron could reach Component[41] curved_guide_33_0\n");
    if (mcAbsorbProp[41]) fprintf(stderr, "Warning: %g events were removed in Component[41] curved_guide_33_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[41]);
  /* User FINALLY code for component 'curved_guide_34_0'. */
  SIG_MESSAGE("curved_guide_34_0 (Finally)");
#define mccompcurname  curved_guide_34_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 42
#define GVars mcccurved_guide_34_0_GVars
#define pTable mcccurved_guide_34_0_pTable
{   /* Declarations of curved_guide_34_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_34_0_w1;
MCNUM h1 = mcccurved_guide_34_0_h1;
MCNUM w2 = mcccurved_guide_34_0_w2;
MCNUM h2 = mcccurved_guide_34_0_h2;
MCNUM l = mcccurved_guide_34_0_l;
MCNUM R0 = mcccurved_guide_34_0_R0;
MCNUM Qc = mcccurved_guide_34_0_Qc;
MCNUM alpha = mcccurved_guide_34_0_alpha;
MCNUM m = mcccurved_guide_34_0_m;
MCNUM W = mcccurved_guide_34_0_W;
MCNUM nslit = mcccurved_guide_34_0_nslit;
MCNUM d = mcccurved_guide_34_0_d;
MCNUM mleft = mcccurved_guide_34_0_mleft;
MCNUM mright = mcccurved_guide_34_0_mright;
MCNUM mtop = mcccurved_guide_34_0_mtop;
MCNUM mbottom = mcccurved_guide_34_0_mbottom;
MCNUM nhslit = mcccurved_guide_34_0_nhslit;
MCNUM G = mcccurved_guide_34_0_G;
MCNUM aleft = mcccurved_guide_34_0_aleft;
MCNUM aright = mcccurved_guide_34_0_aright;
MCNUM atop = mcccurved_guide_34_0_atop;
MCNUM abottom = mcccurved_guide_34_0_abottom;
MCNUM wavy = mcccurved_guide_34_0_wavy;
MCNUM wavy_z = mcccurved_guide_34_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_34_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_34_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_34_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_34_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_34_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_34_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_34_0_nelements;
MCNUM nu = mcccurved_guide_34_0_nu;
MCNUM phase = mcccurved_guide_34_0_phase;
char* reflect = mcccurved_guide_34_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 62614 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_34_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[42]) fprintf(stderr, "Warning: No neutron could reach Component[42] curved_guide_34_0\n");
    if (mcAbsorbProp[42]) fprintf(stderr, "Warning: %g events were removed in Component[42] curved_guide_34_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[42]);
  /* User FINALLY code for component 'curved_guide_35_0'. */
  SIG_MESSAGE("curved_guide_35_0 (Finally)");
#define mccompcurname  curved_guide_35_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 43
#define GVars mcccurved_guide_35_0_GVars
#define pTable mcccurved_guide_35_0_pTable
{   /* Declarations of curved_guide_35_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_35_0_w1;
MCNUM h1 = mcccurved_guide_35_0_h1;
MCNUM w2 = mcccurved_guide_35_0_w2;
MCNUM h2 = mcccurved_guide_35_0_h2;
MCNUM l = mcccurved_guide_35_0_l;
MCNUM R0 = mcccurved_guide_35_0_R0;
MCNUM Qc = mcccurved_guide_35_0_Qc;
MCNUM alpha = mcccurved_guide_35_0_alpha;
MCNUM m = mcccurved_guide_35_0_m;
MCNUM W = mcccurved_guide_35_0_W;
MCNUM nslit = mcccurved_guide_35_0_nslit;
MCNUM d = mcccurved_guide_35_0_d;
MCNUM mleft = mcccurved_guide_35_0_mleft;
MCNUM mright = mcccurved_guide_35_0_mright;
MCNUM mtop = mcccurved_guide_35_0_mtop;
MCNUM mbottom = mcccurved_guide_35_0_mbottom;
MCNUM nhslit = mcccurved_guide_35_0_nhslit;
MCNUM G = mcccurved_guide_35_0_G;
MCNUM aleft = mcccurved_guide_35_0_aleft;
MCNUM aright = mcccurved_guide_35_0_aright;
MCNUM atop = mcccurved_guide_35_0_atop;
MCNUM abottom = mcccurved_guide_35_0_abottom;
MCNUM wavy = mcccurved_guide_35_0_wavy;
MCNUM wavy_z = mcccurved_guide_35_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_35_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_35_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_35_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_35_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_35_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_35_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_35_0_nelements;
MCNUM nu = mcccurved_guide_35_0_nu;
MCNUM phase = mcccurved_guide_35_0_phase;
char* reflect = mcccurved_guide_35_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 62673 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_35_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[43]) fprintf(stderr, "Warning: No neutron could reach Component[43] curved_guide_35_0\n");
    if (mcAbsorbProp[43]) fprintf(stderr, "Warning: %g events were removed in Component[43] curved_guide_35_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[43]);
  /* User FINALLY code for component 'curved_guide_36_0'. */
  SIG_MESSAGE("curved_guide_36_0 (Finally)");
#define mccompcurname  curved_guide_36_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 44
#define GVars mcccurved_guide_36_0_GVars
#define pTable mcccurved_guide_36_0_pTable
{   /* Declarations of curved_guide_36_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_36_0_w1;
MCNUM h1 = mcccurved_guide_36_0_h1;
MCNUM w2 = mcccurved_guide_36_0_w2;
MCNUM h2 = mcccurved_guide_36_0_h2;
MCNUM l = mcccurved_guide_36_0_l;
MCNUM R0 = mcccurved_guide_36_0_R0;
MCNUM Qc = mcccurved_guide_36_0_Qc;
MCNUM alpha = mcccurved_guide_36_0_alpha;
MCNUM m = mcccurved_guide_36_0_m;
MCNUM W = mcccurved_guide_36_0_W;
MCNUM nslit = mcccurved_guide_36_0_nslit;
MCNUM d = mcccurved_guide_36_0_d;
MCNUM mleft = mcccurved_guide_36_0_mleft;
MCNUM mright = mcccurved_guide_36_0_mright;
MCNUM mtop = mcccurved_guide_36_0_mtop;
MCNUM mbottom = mcccurved_guide_36_0_mbottom;
MCNUM nhslit = mcccurved_guide_36_0_nhslit;
MCNUM G = mcccurved_guide_36_0_G;
MCNUM aleft = mcccurved_guide_36_0_aleft;
MCNUM aright = mcccurved_guide_36_0_aright;
MCNUM atop = mcccurved_guide_36_0_atop;
MCNUM abottom = mcccurved_guide_36_0_abottom;
MCNUM wavy = mcccurved_guide_36_0_wavy;
MCNUM wavy_z = mcccurved_guide_36_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_36_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_36_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_36_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_36_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_36_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_36_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_36_0_nelements;
MCNUM nu = mcccurved_guide_36_0_nu;
MCNUM phase = mcccurved_guide_36_0_phase;
char* reflect = mcccurved_guide_36_0_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 62732 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_36_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[44]) fprintf(stderr, "Warning: No neutron could reach Component[44] curved_guide_36_0\n");
    if (mcAbsorbProp[44]) fprintf(stderr, "Warning: %g events were removed in Component[44] curved_guide_36_0=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[44]);
    if (!mcNCounter[45]) fprintf(stderr, "Warning: No neutron could reach Component[45] EndOfelement_4\n");
    if (mcAbsorbProp[45]) fprintf(stderr, "Warning: %g events were removed in Component[45] EndOfelement_4=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[45]);
    if (!mcNCounter[46]) fprintf(stderr, "Warning: No neutron could reach Component[46] log_P_start\n");
    if (mcAbsorbProp[46]) fprintf(stderr, "Warning: %g events were removed in Component[46] log_P_start=Shielding_logger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[46]);
    if (!mcNCounter[47]) fprintf(stderr, "Warning: No neutron could reach Component[47] elliptical_guide_gravity3\n");
    if (mcAbsorbProp[47]) fprintf(stderr, "Warning: %g events were removed in Component[47] elliptical_guide_gravity3=Elliptic_guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[47]);
    if (!mcNCounter[48]) fprintf(stderr, "Warning: No neutron could reach Component[48] EndOfelement_3\n");
    if (mcAbsorbProp[48]) fprintf(stderr, "Warning: %g events were removed in Component[48] EndOfelement_3=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[48]);
  /* User FINALLY code for component 'straight_guide_2_1'. */
  SIG_MESSAGE("straight_guide_2_1 (Finally)");
#define mccompcurname  straight_guide_2_1
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 49
#define GVars mccstraight_guide_2_1_GVars
#define pTable mccstraight_guide_2_1_pTable
{   /* Declarations of straight_guide_2_1=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mccstraight_guide_2_1_w1;
MCNUM h1 = mccstraight_guide_2_1_h1;
MCNUM w2 = mccstraight_guide_2_1_w2;
MCNUM h2 = mccstraight_guide_2_1_h2;
MCNUM l = mccstraight_guide_2_1_l;
MCNUM R0 = mccstraight_guide_2_1_R0;
MCNUM Qc = mccstraight_guide_2_1_Qc;
MCNUM alpha = mccstraight_guide_2_1_alpha;
MCNUM m = mccstraight_guide_2_1_m;
MCNUM W = mccstraight_guide_2_1_W;
MCNUM nslit = mccstraight_guide_2_1_nslit;
MCNUM d = mccstraight_guide_2_1_d;
MCNUM mleft = mccstraight_guide_2_1_mleft;
MCNUM mright = mccstraight_guide_2_1_mright;
MCNUM mtop = mccstraight_guide_2_1_mtop;
MCNUM mbottom = mccstraight_guide_2_1_mbottom;
MCNUM nhslit = mccstraight_guide_2_1_nhslit;
MCNUM G = mccstraight_guide_2_1_G;
MCNUM aleft = mccstraight_guide_2_1_aleft;
MCNUM aright = mccstraight_guide_2_1_aright;
MCNUM atop = mccstraight_guide_2_1_atop;
MCNUM abottom = mccstraight_guide_2_1_abottom;
MCNUM wavy = mccstraight_guide_2_1_wavy;
MCNUM wavy_z = mccstraight_guide_2_1_wavy_z;
MCNUM wavy_tb = mccstraight_guide_2_1_wavy_tb;
MCNUM wavy_lr = mccstraight_guide_2_1_wavy_lr;
MCNUM chamfers = mccstraight_guide_2_1_chamfers;
MCNUM chamfers_z = mccstraight_guide_2_1_chamfers_z;
MCNUM chamfers_lr = mccstraight_guide_2_1_chamfers_lr;
MCNUM chamfers_tb = mccstraight_guide_2_1_chamfers_tb;
MCNUM nelements = mccstraight_guide_2_1_nelements;
MCNUM nu = mccstraight_guide_2_1_nu;
MCNUM phase = mccstraight_guide_2_1_phase;
char* reflect = mccstraight_guide_2_1_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 62799 "./ESS_BIFROST_shielding.c"
}   /* End of straight_guide_2_1=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[49]) fprintf(stderr, "Warning: No neutron could reach Component[49] straight_guide_2_1\n");
    if (mcAbsorbProp[49]) fprintf(stderr, "Warning: %g events were removed in Component[49] straight_guide_2_1=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[49]);
  /* User FINALLY code for component 'straight_guide_2_2'. */
  SIG_MESSAGE("straight_guide_2_2 (Finally)");
#define mccompcurname  straight_guide_2_2
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 50
#define GVars mccstraight_guide_2_2_GVars
#define pTable mccstraight_guide_2_2_pTable
{   /* Declarations of straight_guide_2_2=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mccstraight_guide_2_2_w1;
MCNUM h1 = mccstraight_guide_2_2_h1;
MCNUM w2 = mccstraight_guide_2_2_w2;
MCNUM h2 = mccstraight_guide_2_2_h2;
MCNUM l = mccstraight_guide_2_2_l;
MCNUM R0 = mccstraight_guide_2_2_R0;
MCNUM Qc = mccstraight_guide_2_2_Qc;
MCNUM alpha = mccstraight_guide_2_2_alpha;
MCNUM m = mccstraight_guide_2_2_m;
MCNUM W = mccstraight_guide_2_2_W;
MCNUM nslit = mccstraight_guide_2_2_nslit;
MCNUM d = mccstraight_guide_2_2_d;
MCNUM mleft = mccstraight_guide_2_2_mleft;
MCNUM mright = mccstraight_guide_2_2_mright;
MCNUM mtop = mccstraight_guide_2_2_mtop;
MCNUM mbottom = mccstraight_guide_2_2_mbottom;
MCNUM nhslit = mccstraight_guide_2_2_nhslit;
MCNUM G = mccstraight_guide_2_2_G;
MCNUM aleft = mccstraight_guide_2_2_aleft;
MCNUM aright = mccstraight_guide_2_2_aright;
MCNUM atop = mccstraight_guide_2_2_atop;
MCNUM abottom = mccstraight_guide_2_2_abottom;
MCNUM wavy = mccstraight_guide_2_2_wavy;
MCNUM wavy_z = mccstraight_guide_2_2_wavy_z;
MCNUM wavy_tb = mccstraight_guide_2_2_wavy_tb;
MCNUM wavy_lr = mccstraight_guide_2_2_wavy_lr;
MCNUM chamfers = mccstraight_guide_2_2_chamfers;
MCNUM chamfers_z = mccstraight_guide_2_2_chamfers_z;
MCNUM chamfers_lr = mccstraight_guide_2_2_chamfers_lr;
MCNUM chamfers_tb = mccstraight_guide_2_2_chamfers_tb;
MCNUM nelements = mccstraight_guide_2_2_nelements;
MCNUM nu = mccstraight_guide_2_2_nu;
MCNUM phase = mccstraight_guide_2_2_phase;
char* reflect = mccstraight_guide_2_2_reflect;
#line 603 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 62858 "./ESS_BIFROST_shielding.c"
}   /* End of straight_guide_2_2=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[50]) fprintf(stderr, "Warning: No neutron could reach Component[50] straight_guide_2_2\n");
    if (mcAbsorbProp[50]) fprintf(stderr, "Warning: %g events were removed in Component[50] straight_guide_2_2=Guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[50]);
    if (!mcNCounter[51]) fprintf(stderr, "Warning: No neutron could reach Component[51] EndOfelement_2\n");
    if (mcAbsorbProp[51]) fprintf(stderr, "Warning: %g events were removed in Component[51] EndOfelement_2=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[51]);
    if (!mcNCounter[52]) fprintf(stderr, "Warning: No neutron could reach Component[52] elliptical_guide_gravity1_1\n");
    if (mcAbsorbProp[52]) fprintf(stderr, "Warning: %g events were removed in Component[52] elliptical_guide_gravity1_1=Elliptic_guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[52]);
    if (!mcNCounter[53]) fprintf(stderr, "Warning: No neutron could reach Component[53] DiwJaw3\n");
    if (mcAbsorbProp[53]) fprintf(stderr, "Warning: %g events were removed in Component[53] DiwJaw3=Slit()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[53]);
    if (!mcNCounter[54]) fprintf(stderr, "Warning: No neutron could reach Component[54] elliptical_guide_gravity1_2\n");
    if (mcAbsorbProp[54]) fprintf(stderr, "Warning: %g events were removed in Component[54] elliptical_guide_gravity1_2=Elliptic_guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[54]);
    if (!mcNCounter[55]) fprintf(stderr, "Warning: No neutron could reach Component[55] DiwJaw2\n");
    if (mcAbsorbProp[55]) fprintf(stderr, "Warning: %g events were removed in Component[55] DiwJaw2=Slit()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[55]);
    if (!mcNCounter[56]) fprintf(stderr, "Warning: No neutron could reach Component[56] elliptical_guide_gravity1_3\n");
    if (mcAbsorbProp[56]) fprintf(stderr, "Warning: %g events were removed in Component[56] elliptical_guide_gravity1_3=Elliptic_guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[56]);
    if (!mcNCounter[57]) fprintf(stderr, "Warning: No neutron could reach Component[57] DiwJaw1\n");
    if (mcAbsorbProp[57]) fprintf(stderr, "Warning: %g events were removed in Component[57] DiwJaw1=Slit()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[57]);
    if (!mcNCounter[58]) fprintf(stderr, "Warning: No neutron could reach Component[58] elliptical_guide_gravity1_4\n");
    if (mcAbsorbProp[58]) fprintf(stderr, "Warning: %g events were removed in Component[58] elliptical_guide_gravity1_4=Elliptic_guide_gravity_shieldinglogger()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[58]);
    if (!mcNCounter[59]) fprintf(stderr, "Warning: No neutron could reach Component[59] EndOfelement_1\n");
    if (mcAbsorbProp[59]) fprintf(stderr, "Warning: %g events were removed in Component[59] EndOfelement_1=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[59]);
  /* User FINALLY code for component 'VirtualOutput'. */
  SIG_MESSAGE("VirtualOutput (Finally)");
#define mccompcurname  VirtualOutput
#define mccompcurtype  Virtual_output
#define mccompcurindex 60
#define DEFS mccVirtualOutput_DEFS
#define Vars mccVirtualOutput_Vars
{   /* Declarations of VirtualOutput=Virtual_output() SETTING parameters. */
char* filename = mccVirtualOutput_filename;
MCNUM bufsize = mccVirtualOutput_bufsize;
#line 132 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../sources/Virtual_output.comp"
{
  /* free pointers */
  Monitor_nD_Finally(&DEFS, &Vars);
  if (bufsize) {
    printf("Virtual_output: %s: Saved %Li events (from buffer) in file %s\n",
           NAME_CURRENT_COMP, Vars.Nsum, Vars.Mon_File);
    if (bufsize < Vars.Nsum)
      printf("WARNING         When using this source, intensities must be multiplied\n"
             "                by a factor %g\n", (double)Vars.Nsum/(double)bufsize);
  } else printf("Virtual_output: %s: Saved %Li events (all) in file %s\n", NAME_CURRENT_COMP, Vars.Nsum, Vars.Mon_File);
}
#line 62908 "./ESS_BIFROST_shielding.c"
}   /* End of VirtualOutput=Virtual_output() SETTING parameter declarations. */
#undef Vars
#undef DEFS
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[60]) fprintf(stderr, "Warning: No neutron could reach Component[60] VirtualOutput\n");
    if (mcAbsorbProp[60]) fprintf(stderr, "Warning: %g events were removed in Component[60] VirtualOutput=Virtual_output()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[60]);
    if (!mcNCounter[61]) fprintf(stderr, "Warning: No neutron could reach Component[61] DiwJaw0\n");
    if (mcAbsorbProp[61]) fprintf(stderr, "Warning: %g events were removed in Component[61] DiwJaw0=Slit()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[61]);
  /* User FINALLY code for component 'log_P_stop'. */
  SIG_MESSAGE("log_P_stop (Finally)");
#define mccompcurname  log_P_stop
#define mccompcurtype  Shielding_logger_stop
#define mccompcurindex 62
#define logger mcclog_P_stop_logger
#line 105 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_logger_stop.comp"
{
  /*If we are a logger stop we should also free the memory*/
  int i;
  struct Generalized_State_t *bp;
  for (i=0;i<BOUNCE_LOG_SIZE;i++){
    bp=&(Bounce_store[i]);
    /* maybe this should be in the share block - must be able to discern between different loggers*/       
    /*      printf("SCATTERLOG: %d %lld %g %g %g  %g %g %g  %g  %g %g %g  %g  %d\n", \*/
    /*	     i,bp->_nid,bp->_x,bp->_y,bp->_z, bp->_vx, bp->_vy, bp->_vz, bp->_t, \*/
    /*	     bp->_sx, bp->_sy, bp->_sz, bp->_p, bp->_comp);*/
  }
 if (!logger_buffer_cleared) { free(Bounce_store); logger_buffer_cleared=1;}
 
/*do nothing if the memory has already been freed*/
}
#line 62942 "./ESS_BIFROST_shielding.c"
#undef logger
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[62]) fprintf(stderr, "Warning: No neutron could reach Component[62] log_P_stop\n");
    if (mcAbsorbProp[62]) fprintf(stderr, "Warning: %g events were removed in Component[62] log_P_stop=Shielding_logger_stop()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[62]);
    if (!mcNCounter[63]) fprintf(stderr, "Warning: No neutron could reach Component[63] arm_iter_P1_start\n");
    if (mcAbsorbProp[63]) fprintf(stderr, "Warning: %g events were removed in Component[63] arm_iter_P1_start=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[63]);
    if (!mcNCounter[64]) fprintf(stderr, "Warning: No neutron could reach Component[64] iter_P1_start\n");
    if (mcAbsorbProp[64]) fprintf(stderr, "Warning: %g events were removed in Component[64] iter_P1_start=Shielding_log_iterator_Ni_new()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[64]);
    if (!mcNCounter[65]) fprintf(stderr, "Warning: No neutron could reach Component[65] arm_iter_P1_dummy\n");
    if (mcAbsorbProp[65]) fprintf(stderr, "Warning: %g events were removed in Component[65] arm_iter_P1_dummy=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[65]);
  /* User FINALLY code for component 'mndP01'. */
  SIG_MESSAGE("mndP01 (Finally)");
#define mccompcurname  mndP01
#define mccompcurtype  Monitor_nD
#define mccompcurindex 66
#define user1 mccmndP01_user1
#define user2 mccmndP01_user2
#define user3 mccmndP01_user3
#define DEFS mccmndP01_DEFS
#define Vars mccmndP01_Vars
#define detector mccmndP01_detector
#define offdata mccmndP01_offdata
{   /* Declarations of mndP01=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccmndP01_xwidth;
MCNUM yheight = mccmndP01_yheight;
MCNUM zdepth = mccmndP01_zdepth;
MCNUM xmin = mccmndP01_xmin;
MCNUM xmax = mccmndP01_xmax;
MCNUM ymin = mccmndP01_ymin;
MCNUM ymax = mccmndP01_ymax;
MCNUM zmin = mccmndP01_zmin;
MCNUM zmax = mccmndP01_zmax;
MCNUM bins = mccmndP01_bins;
MCNUM min = mccmndP01_min;
MCNUM max = mccmndP01_max;
MCNUM restore_neutron = mccmndP01_restore_neutron;
MCNUM radius = mccmndP01_radius;
char* options = mccmndP01_options;
char* filename = mccmndP01_filename;
char* geometry = mccmndP01_geometry;
char* username1 = mccmndP01_username1;
char* username2 = mccmndP01_username2;
char* username3 = mccmndP01_username3;
int nowritefile = mccmndP01_nowritefile;
#line 491 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  /* free pointers */
  Monitor_nD_Finally(&DEFS, &Vars);
}
#line 62995 "./ESS_BIFROST_shielding.c"
}   /* End of mndP01=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[66]) fprintf(stderr, "Warning: No neutron could reach Component[66] mndP01\n");
    if (mcAbsorbProp[66]) fprintf(stderr, "Warning: %g events were removed in Component[66] mndP01=Monitor_nD()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[66]);
    if (!mcNCounter[67]) fprintf(stderr, "Warning: No neutron could reach Component[67] arm_iter_P1_stop\n");
    if (mcAbsorbProp[67]) fprintf(stderr, "Warning: %g events were removed in Component[67] arm_iter_P1_stop=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[67]);
    if (!mcNCounter[68]) fprintf(stderr, "Warning: No neutron could reach Component[68] iter_P1_stop\n");
    if (mcAbsorbProp[68]) fprintf(stderr, "Warning: %g events were removed in Component[68] iter_P1_stop=Shielding_log_iterator_stop()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[68]);
    if (!mcNCounter[69]) fprintf(stderr, "Warning: No neutron could reach Component[69] a11i\n");
    if (mcAbsorbProp[69]) fprintf(stderr, "Warning: %g events were removed in Component[69] a11i=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[69]);
    if (!mcNCounter[70]) fprintf(stderr, "Warning: No neutron could reach Component[70] arm_iter_P2_start\n");
    if (mcAbsorbProp[70]) fprintf(stderr, "Warning: %g events were removed in Component[70] arm_iter_P2_start=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[70]);
    if (!mcNCounter[71]) fprintf(stderr, "Warning: No neutron could reach Component[71] iter_P2_start\n");
    if (mcAbsorbProp[71]) fprintf(stderr, "Warning: %g events were removed in Component[71] iter_P2_start=Shielding_log_iterator_Ti_new()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[71]);
    if (!mcNCounter[72]) fprintf(stderr, "Warning: No neutron could reach Component[72] arm_iter_P2_dummy\n");
    if (mcAbsorbProp[72]) fprintf(stderr, "Warning: %g events were removed in Component[72] arm_iter_P2_dummy=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[72]);
  /* User FINALLY code for component 'mndP02'. */
  SIG_MESSAGE("mndP02 (Finally)");
#define mccompcurname  mndP02
#define mccompcurtype  Monitor_nD
#define mccompcurindex 73
#define user1 mccmndP02_user1
#define user2 mccmndP02_user2
#define user3 mccmndP02_user3
#define DEFS mccmndP02_DEFS
#define Vars mccmndP02_Vars
#define detector mccmndP02_detector
#define offdata mccmndP02_offdata
{   /* Declarations of mndP02=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccmndP02_xwidth;
MCNUM yheight = mccmndP02_yheight;
MCNUM zdepth = mccmndP02_zdepth;
MCNUM xmin = mccmndP02_xmin;
MCNUM xmax = mccmndP02_xmax;
MCNUM ymin = mccmndP02_ymin;
MCNUM ymax = mccmndP02_ymax;
MCNUM zmin = mccmndP02_zmin;
MCNUM zmax = mccmndP02_zmax;
MCNUM bins = mccmndP02_bins;
MCNUM min = mccmndP02_min;
MCNUM max = mccmndP02_max;
MCNUM restore_neutron = mccmndP02_restore_neutron;
MCNUM radius = mccmndP02_radius;
char* options = mccmndP02_options;
char* filename = mccmndP02_filename;
char* geometry = mccmndP02_geometry;
char* username1 = mccmndP02_username1;
char* username2 = mccmndP02_username2;
char* username3 = mccmndP02_username3;
int nowritefile = mccmndP02_nowritefile;
#line 491 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  /* free pointers */
  Monitor_nD_Finally(&DEFS, &Vars);
}
#line 63061 "./ESS_BIFROST_shielding.c"
}   /* End of mndP02=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[73]) fprintf(stderr, "Warning: No neutron could reach Component[73] mndP02\n");
    if (mcAbsorbProp[73]) fprintf(stderr, "Warning: %g events were removed in Component[73] mndP02=Monitor_nD()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[73]);
    if (!mcNCounter[74]) fprintf(stderr, "Warning: No neutron could reach Component[74] arm_iter_P2_stop\n");
    if (mcAbsorbProp[74]) fprintf(stderr, "Warning: %g events were removed in Component[74] arm_iter_P2_stop=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[74]);
    if (!mcNCounter[75]) fprintf(stderr, "Warning: No neutron could reach Component[75] iter_P2_stop\n");
    if (mcAbsorbProp[75]) fprintf(stderr, "Warning: %g events were removed in Component[75] iter_P2_stop=Shielding_log_iterator_stop()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[75]);
    if (!mcNCounter[76]) fprintf(stderr, "Warning: No neutron could reach Component[76] a12i\n");
    if (mcAbsorbProp[76]) fprintf(stderr, "Warning: %g events were removed in Component[76] a12i=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[76]);
    if (!mcNCounter[77]) fprintf(stderr, "Warning: No neutron could reach Component[77] arm_iter_P3_start\n");
    if (mcAbsorbProp[77]) fprintf(stderr, "Warning: %g events were removed in Component[77] arm_iter_P3_start=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[77]);
    if (!mcNCounter[78]) fprintf(stderr, "Warning: No neutron could reach Component[78] iter_P3_start\n");
    if (mcAbsorbProp[78]) fprintf(stderr, "Warning: %g events were removed in Component[78] iter_P3_start=Shielding_log_iterator_total()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[78]);
    if (!mcNCounter[79]) fprintf(stderr, "Warning: No neutron could reach Component[79] arm_iter_P3_dummy\n");
    if (mcAbsorbProp[79]) fprintf(stderr, "Warning: %g events were removed in Component[79] arm_iter_P3_dummy=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[79]);
  /* User FINALLY code for component 'mndP03'. */
  SIG_MESSAGE("mndP03 (Finally)");
#define mccompcurname  mndP03
#define mccompcurtype  Monitor_nD
#define mccompcurindex 80
#define user1 mccmndP03_user1
#define user2 mccmndP03_user2
#define user3 mccmndP03_user3
#define DEFS mccmndP03_DEFS
#define Vars mccmndP03_Vars
#define detector mccmndP03_detector
#define offdata mccmndP03_offdata
{   /* Declarations of mndP03=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccmndP03_xwidth;
MCNUM yheight = mccmndP03_yheight;
MCNUM zdepth = mccmndP03_zdepth;
MCNUM xmin = mccmndP03_xmin;
MCNUM xmax = mccmndP03_xmax;
MCNUM ymin = mccmndP03_ymin;
MCNUM ymax = mccmndP03_ymax;
MCNUM zmin = mccmndP03_zmin;
MCNUM zmax = mccmndP03_zmax;
MCNUM bins = mccmndP03_bins;
MCNUM min = mccmndP03_min;
MCNUM max = mccmndP03_max;
MCNUM restore_neutron = mccmndP03_restore_neutron;
MCNUM radius = mccmndP03_radius;
char* options = mccmndP03_options;
char* filename = mccmndP03_filename;
char* geometry = mccmndP03_geometry;
char* username1 = mccmndP03_username1;
char* username2 = mccmndP03_username2;
char* username3 = mccmndP03_username3;
int nowritefile = mccmndP03_nowritefile;
#line 491 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  /* free pointers */
  Monitor_nD_Finally(&DEFS, &Vars);
}
#line 63127 "./ESS_BIFROST_shielding.c"
}   /* End of mndP03=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[80]) fprintf(stderr, "Warning: No neutron could reach Component[80] mndP03\n");
    if (mcAbsorbProp[80]) fprintf(stderr, "Warning: %g events were removed in Component[80] mndP03=Monitor_nD()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[80]);
    if (!mcNCounter[81]) fprintf(stderr, "Warning: No neutron could reach Component[81] arm_iter_P3_stop\n");
    if (mcAbsorbProp[81]) fprintf(stderr, "Warning: %g events were removed in Component[81] arm_iter_P3_stop=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[81]);
    if (!mcNCounter[82]) fprintf(stderr, "Warning: No neutron could reach Component[82] iter_P3_stop\n");
    if (mcAbsorbProp[82]) fprintf(stderr, "Warning: %g events were removed in Component[82] iter_P3_stop=Shielding_log_iterator_stop()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[82]);
    if (!mcNCounter[83]) fprintf(stderr, "Warning: No neutron could reach Component[83] a13i\n");
    if (mcAbsorbProp[83]) fprintf(stderr, "Warning: %g events were removed in Component[83] a13i=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[83]);
    if (!mcNCounter[84]) fprintf(stderr, "Warning: No neutron could reach Component[84] Beamstop\n");
    if (mcAbsorbProp[84]) fprintf(stderr, "Warning: %g events were removed in Component[84] Beamstop=Beamstop()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[84]);
    if (!mcNCounter[85]) fprintf(stderr, "Warning: No neutron could reach Component[85] Lmon_guide_end\n");
    if (mcAbsorbProp[85]) fprintf(stderr, "Warning: %g events were removed in Component[85] Lmon_guide_end=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[85]);
  /* User FINALLY code for component 'SCalc'. */
  SIG_MESSAGE("SCalc (Finally)");
#define mccompcurname  SCalc
#define mccompcurtype  Shielding_calculator
#define mccompcurindex 86
{   /* Declarations of SCalc=Shielding_calculator() SETTING parameters. */
MCNUM MaxRate = mccSCalc_MaxRate;
MCNUM Innerspace = mccSCalc_Innerspace;
char* NiCaptureFile = mccSCalc_NiCaptureFile;
char* TiCaptureFile = mccSCalc_TiCaptureFile;
char* TotalCaptureFile = mccSCalc_TotalCaptureFile;
char* OutputFile = mccSCalc_OutputFile;
#line 488 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_calculator.comp"
{
/**Reading datafiles with capture per bin**/

#ifdef _WIN32
#define separator    "\\"
#else
 #define separator  "/"
#endif




double d1, d2, d3, d4;
int ibin=0,NBINS;
char line[1000],line1[1000];
char dirname[1000];
memset(dirname,0,sizeof(dirname));
strcat(strcat(dirname,mcdirname),separator);

char filename[1000];





FILE *dataIn;

memset(filename,0,sizeof(filename));//resetting filename to NULL string
strcat(strcat(filename,dirname),NiCaptureFile);

printf("Shielding calculator:\n Reading file %s\n",filename);

if( access( filename, R_OK ) != -1 ) {
    // file exists
dataIn=fopen(filename,"r");
} else {
    // file doesn't exist
printf("Shielding calculator could not find file\n%s\nexiting.",NiCaptureFile);
exit(0);
}

if (dataIn==NULL) {printf("Can't open file\n"); exit(0);};
while (fgets(line, 1000,dataIn)!=NULL)
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4) ibin++;
};


NBINS=ibin;

//printf("Shielding calculator:\n Input file contains %d bins.\n", NBINS);

double* zhat =  malloc(NBINS*sizeof(double));
double* Ihat= malloc(NBINS*sizeof(double));
double* IhatNi= malloc(NBINS*sizeof(double));
double* IhatTi= malloc(NBINS*sizeof(double));
rewind(dataIn);
ibin=0;
while (fgets(line, 1000,dataIn)!=NULL)
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		zhat[ibin]=d1;
		IhatNi[ibin]=d2;
		ibin++;
	};
};

//printf("Shielding calculator:\n Closing file %s...",filename);
fclose(dataIn);
//printf("done\n");

memset(filename,0,sizeof(filename));// setting filename to NULL string
strcat(strcat(filename,dirname),TiCaptureFile); //setting filename to TiCapture file
printf("Shielding calculator:\n Next input: %s\n",filename);

if( access( filename, R_OK ) != -1 ) {
    // file exists
dataIn=fopen(filename,"r");
} else {
    // file doesn't exist
printf("Shielding calculator could not find file\n%s\nexiting.",TiCaptureFile);
exit(0);
}

ibin=0;
if (dataIn==NULL) {printf("Can't open file\n"); exit(0);};
while (fgets(line, 1000,dataIn)!=NULL)
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		ibin++;
	};
};
if (ibin!=NBINS){printf("Shielding calculator:\nMismatch in number of bins between input files.\nNo shielding calculation performed, exiting\n");
exit(0);}

rewind(dataIn);


//printf("Shielding calculator:\n Reading file %s\n",filename);
ibin=0;

while (fgets(line, 1000,dataIn))
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		zhat[ibin]=d1;
		IhatTi[ibin]=d2;
		ibin++;
	};
};
fclose(dataIn);


memset(filename,0,sizeof(filename));
strcat(strcat(filename,dirname),TotalCaptureFile);
printf("Shielding calculator:\n Next input: %s\n",filename);

if( access( filename, R_OK ) != -1 ) {
    // file exists
dataIn=fopen(filename,"r");
} else {
    // file doesn't exist
printf("Shielding calculator could not find file\n%s\nexiting.",TotalCaptureFile);
exit(0);
}


ibin=0;
if (dataIn==NULL) {printf("Can't open file\n"); exit(0);};
while (fgets(line, 1000,dataIn)!=NULL)
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		ibin++;
	};
};
if (ibin!=NBINS){printf("Shielding calculator:\nMismatch in number of bins between input files.\nNo shielding calculation performed, exiting\n");
exit(0);}

rewind(dataIn);

//printf("Shielding calculator:\n Reading file %s\n",filename);
ibin=0;
while (fgets(line, 1000,dataIn))
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		zhat[ibin]=d1;
		Ihat[ibin]=d2;
		ibin++;
	};
};
//printf("Shielding calculator:\n Closing file %s...",filename);
fclose(dataIn);
//printf("done\n");

int i,ilayerConc=1,ilayerFe=1,ilayerFeConc=1,ilayerPb=1,iz,iEgroup; // Auxiliary variables

double zbinlength = zhat[2]-zhat[1];



double* RvaluesPb = malloc(NBINS*sizeof(double));
double* RvaluesFe=  malloc(NBINS*sizeof(double));
double* Rvaluesbt= malloc(NBINS*sizeof(double));
double* thicknessPb= malloc(NBINS*sizeof(double));
double* thicknessFe= malloc(NBINS*sizeof(double));
double* thicknessbt= malloc(NBINS*sizeof(double));
double* RvaluesFebt= malloc(NBINS*sizeof(double));
double* thicknessFebt= malloc(NBINS*sizeof(double));

double*  doseFe= malloc(NBINS*sizeof(double));
double* dosebt= malloc(NBINS*sizeof(double));
double* doseFebt= malloc(NBINS*sizeof(double));
double* dosePb= malloc(NBINS*sizeof(double));



  
     /*  for ( i=0; i< NBINS; i++)
         {
           doseFe[i]=0.0; dosebt[i]=0.0;doseFebt[i]=0.0;dosePb[i]=0.0;
         }
*/
 
     for ( iz=0; iz< NBINS; iz++)
       {
         double zc=zhat[iz]; // the z-value for the calculation                                                                                                                 
           double z;

      //CONCRETE 
      // ilayerConc may have already some value calculated for an upstream piece.
	// We start from it and if shielding is too thick, reduce this number.
   do { 
           double  thickbt = (ilayerConc)*stepbt;
           double   Rbt = (0.5*Innerspace) + thickbt;
           Rvaluesbt[iz]=Rbt;
        dosebt[iz]=0.0;
         /*computing the integral*/
           double dFemfp, dPbmfp, dBtmfp,dFebtmfp;
           for (i=0;i<NBINS;i++){
             z=zc-zhat[i];

     	for (iEgroup=0; iEgroup<nEgroup;iEgroup++){
                  double En = energy[iEgroup], fracNi=fractionNi[iEgroup],fracTi=fractionTi[iEgroup], fracB=fractionB[iEgroup];
	dBtmfp=lint(&En,1,AttenuationSizeConc, AttenuationArgsConc, AttenuationDataConc)*(Rbt-(0.5*Innerspace))*sqrt(Rbt*Rbt+z*z)/Rbt;
	double args[]={En,dBtmfp};
                  dosebt[iz] += (fracNi* IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatTi[i]-IhatNi[i])) *0.25/3.1415926*lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData)* exp(-dBtmfp)/(Rbt*Rbt+z*z)*
 		lint(args, 2, BuildupSizeConc,BuildupArgsConc,BuildupDataConc);
	} /* summing energy groups */           
           } /* calculation of integral i=0...NBINS */
ilayerConc--;
  } while ((dosebt[iz] < MaxRate)&&(ilayerConc>0));

//increase ilayerConc until the dose rate requirements are satisfied.
   do { 
           double  thickbt = (ilayerConc)*stepbt;
           double   Rbt = (0.5*Innerspace) + thickbt;
           Rvaluesbt[iz]=Rbt;
        dosebt[iz]=0.0;
         /*computing the integral*/
           double dFemfp, dPbmfp, dBtmfp,dFebtmfp;
           for (i=0;i<NBINS;i++){
             z=zc-zhat[i];

     	for (iEgroup=0; iEgroup<nEgroup;iEgroup++){
                  double En = energy[iEgroup], fracNi=fractionNi[iEgroup],fracTi=fractionTi[iEgroup], fracB=fractionB[iEgroup];
	dBtmfp=lint(&En,1,AttenuationSizeConc, AttenuationArgsConc, AttenuationDataConc)*(Rbt-(0.5*Innerspace))*sqrt(Rbt*Rbt+z*z)/Rbt;
	double args[]={En,dBtmfp};
                  dosebt[iz] += (fracNi* IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatTi[i]-IhatNi[i])) *0.25/3.1415926*lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData)* exp(-dBtmfp)/(Rbt*Rbt+z*z)*
 		lint(args, 2, BuildupSizeConc,BuildupArgsConc,BuildupDataConc);
	} /* summing energy groups */           
           } /* calculation of integral i=0...NBINS */
ilayerConc++;
  } while ((dosebt[iz] >=MaxRate));



         //CONCRETE+TUBING
	do{
           double thickFebt= (ilayerFeConc)*stepcomb;
           double   RFebt=(0.5*Innerspace)+TFe+thickFebt;
           RvaluesFebt[iz]=RFebt;
      doseFebt[iz]=0.0;
         /*computing the integral*/
           double dFemfp, dPbmfp, dBtmfp,dFebtmfp;
           for (i=0;i<NBINS;i++){
             z=zc-zhat[i];
     
	for (iEgroup=0; iEgroup<nEgroup;iEgroup++){
                  double En = energy[iEgroup], fracNi=fractionNi[iEgroup],fracTi=fractionTi[iEgroup], fracB=fractionB[iEgroup];
	
	 dFebtmfp=(lint(&En,1,AttenuationSizeConc, AttenuationArgsConc, AttenuationDataConc)*thickFebt+
		    lint(&En,1,AttenuationSizeFe, AttenuationArgsFe, AttenuationDataFe)*TFe)
		   *sqrt(RFebt*RFebt+z*z)/RFebt;
	double args[]={En,dFebtmfp};
  
             	doseFebt[iz]+= (fracNi*IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatTi[i]-IhatNi[i])) *0.25/3.1415926*
		lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData)* exp(-dFebtmfp)/(RFebt*RFebt+z*z)*
 		lint(args, 2, BuildupSizeConc,BuildupArgsConc,BuildupDataConc);
	} /* summing energy groups */           
           } /* calculation of integral i=0...NBINS */
ilayerFeConc--;
  } while ((doseFebt[iz] < MaxRate)&&(ilayerFeConc>0));


         do { 
           double thickFebt= (ilayerFeConc)*stepcomb;
           double  RFebt=(0.5*Innerspace)+TFe+thickFebt;
           RvaluesFebt[iz]=RFebt;
doseFebt[iz]=0.0;
         /*computing the integral*/
           double dFemfp, dPbmfp, dBtmfp,dFebtmfp;
           for (i=0;i<NBINS;i++){
             z=zc-zhat[i];
     
	for (iEgroup=0; iEgroup<nEgroup;iEgroup++){
                  double En = energy[iEgroup], fracNi=fractionNi[iEgroup],fracTi=fractionTi[iEgroup], fracB=fractionB[iEgroup];
	
	 dFebtmfp=(lint(&En,1,AttenuationSizeConc, AttenuationArgsConc, AttenuationDataConc)*thickFebt+
		    lint(&En,1,AttenuationSizeFe, AttenuationArgsFe, AttenuationDataFe)*TFe)
		   *sqrt(RFebt*RFebt+z*z)/RFebt;
	double args[]={En,dFebtmfp};
  
             	doseFebt[iz]+= (fracNi*IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatTi[i]-IhatNi[i])) *0.25/3.1415926*
		lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData)* exp(-dFebtmfp)/(RFebt*RFebt+z*z)*
 		lint(args, 2, BuildupSizeConc,BuildupArgsConc,BuildupDataConc);
	} /* summing energy groups */           
          } /* calculation of integral i=0...NBINS */
ilayerFeConc++;
  } while ((doseFebt[iz] >=MaxRate));





         //IRON 
         do { 
           double  thickFe = (ilayerFe)*stepFe;
           double  RFe = (0.5*Innerspace) + thickFe;
            RvaluesFe[iz]=RFe;
  doseFe[iz]=0.0;
         /*computing the integral*/
           double dFemfp;
           for (i=0;i<NBINS;i++){
             z=zc-zhat[i];
     
	for (iEgroup=0; iEgroup<nEgroup;iEgroup++){
                  double En = energy[iEgroup], fracNi=fractionNi[iEgroup],fracTi=fractionTi[iEgroup],fracB=fractionB[iEgroup];
                

	dFemfp=lint(&En,1,AttenuationSizeFe, AttenuationArgsFe, AttenuationDataFe)*thickFe*sqrt(RFe*RFe+z*z)/RFe;
	double args[]={En,dFemfp};
                  doseFe[iz] += (fracNi*IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatNi[i]-IhatTi[i])) *0.25/3.1415926*
		lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData)* exp(-dFemfp)/(RFe*RFe+z*z)*
 		lint(args, 2, BuildupSizeFe,BuildupArgsFe,BuildupDataFe);

	} /* summing energy groups */           
           } /* calculation of integral i=0...NBINS */
ilayerFe--;
  } while ((doseFe[iz] <MaxRate)&&(ilayerFe>0));



         do { 
           double  thickFe = (ilayerFe)*stepFe;
           double  RFe = (0.5*Innerspace) + thickFe;
            RvaluesFe[iz]=RFe;
  doseFe[iz]=0.0;
         /*computing the integral*/
           double dFemfp;
           for (i=0;i<NBINS;i++){
             z=zc-zhat[i];
     
	for (iEgroup=0; iEgroup<nEgroup;iEgroup++){
                  double En = energy[iEgroup], fracNi=fractionNi[iEgroup],fracTi=fractionTi[iEgroup],fracB=fractionB[iEgroup];
          	dFemfp=lint(&En,1,AttenuationSizeFe, AttenuationArgsFe, AttenuationDataFe)*(RFe-(0.5*Innerspace))*sqrt(RFe*RFe+z*z)/RFe;
	double args[]={En,dFemfp};
                  doseFe[iz] += (fracNi*IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatNi[i]-IhatTi[i])) *0.25/3.1415926*
		lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData)* exp(-dFemfp)/(RFe*RFe+z*z)*
 		lint(args, 2, BuildupSizeFe,BuildupArgsFe,BuildupDataFe);

	} /* summing energy groups */           
           } /* calculation of integral i=0...NBINS */
ilayerFe++;
  } while ((doseFe[iz] >=MaxRate));





         //LEAD 
         do { 
           double  thickPb = (ilayerPb)*stepPb;
           double  RPb = (0.5*Innerspace) + thickPb;
              RvaluesPb[iz]=RPb;
     dosePb[iz]=0.0;
         /*computing the integral*/
           double dPbmfp;
           for (i=0;i<NBINS;i++){
             z=zc-zhat[i];
     
	for (iEgroup=0; iEgroup<nEgroup;iEgroup++){
                  double En = energy[iEgroup], fracNi=fractionNi[iEgroup],fracTi=fractionTi[iEgroup],fracB=fractionB[iEgroup];
                 
	dPbmfp=lint(&En,1,AttenuationSizePb, AttenuationArgsPb, AttenuationDataPb)*(RPb-(0.5*Innerspace))*sqrt(RPb*RPb+z*z)/RPb;
	double args[]={En,dPbmfp};
           dosePb[iz] += (fracNi*IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatNi[i]-IhatTi[i])) *0.25/3.1415926*
		lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData)* exp(-dPbmfp)/(RPb*RPb+z*z)*
 		lint(args, 2, BuildupSizePb,BuildupArgsPb,BuildupDataPb);

	} /* summing energy groups */           
           } /* calculation of integral i=0...NBINS */
ilayerPb--;
  } while ((dosePb[iz] <MaxRate)&&(ilayerPb>0));


         do { 
           double  thickPb = (ilayerPb)*stepPb;
           double  RPb = (0.5*Innerspace) + thickPb;
              RvaluesPb[iz]=RPb;
 dosePb[iz]=0.0;
         /*computing the integral*/
           double dPbmfp;
           for (i=0;i<NBINS;i++){
             z=zc-zhat[i];
     
	for (iEgroup=0; iEgroup<nEgroup;iEgroup++){
                  double En = energy[iEgroup], fracNi=fractionNi[iEgroup],fracTi=fractionTi[iEgroup],fracB=fractionB[iEgroup];
                 
	dPbmfp=lint(&En,1,AttenuationSizePb, AttenuationArgsPb, AttenuationDataPb)*(RPb-(0.5*Innerspace))*sqrt(RPb*RPb+z*z)/RPb;
	double args[]={En,dPbmfp};
                  dosePb[iz] += (fracNi*IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatNi[i]-IhatTi[i])) *0.25/3.1415926*
		lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData)* exp(-dPbmfp)/(RPb*RPb+z*z)*
 		lint(args, 2, BuildupSizePb,BuildupArgsPb,BuildupDataPb);

	} /* summing energy groups */           
           } /* calculation of integral i=0...NBINS */
ilayerPb++;
  } while ((dosePb[iz] >=MaxRate));


     } /* Position scan  iz */

/* Selection of appropriate radius for the gamma shielding */
   for ( i=0; i< NBINS; i++)
    {
      int index=0;
       thicknessFe[i]=RvaluesFe[i]-(0.5*Innerspace);
       thicknessbt[i]=Rvaluesbt[i]-(0.5*Innerspace);
       thicknessPb[i]=RvaluesPb[i]-(0.5*Innerspace);
      thicknessFebt[i]=RvaluesFebt[i]-(0.5*Innerspace)-TFe;
}

#ifdef _WIN32
#define separator    "\\"
#else
 #define separator  "/"
#endif

FILE *cost_out;
memset(filename,0,sizeof(filename));
strcat(strcat(filename,dirname),OutputFile);
printf("Shielding calculator:\nWriting to file %s\n",filename);
cost_out=fopen(filename,"w");


fprintf(cost_out,"#Required shielding dimensions for the dose rate not to exceed %g uSv/hr at the surface with shielding inner dimensions %g meters\n#Position z,m\tNeutrons Ihat(z),n/s/bin\tNeutrons I(z),n/s/m\tCaptured by Ni /s/bin \tCapturedby Ni /s/m\tCaptured by Ti /s/bin\tCaptured by Ti /s/m\tThickness Pb, m\tThickness Fe, m\tThickness concrete, m (no tubing)\tThickness concrete, m (steel tubing %g cm)\tOuter radius Pb,m\tOuter radius Fe,m\tOuter radius concrete, m\tOuter radius concrete,m (with tubing)\n",MaxRate,Innerspace,100*TFe);

  
  for ( i=0; i< NBINS; i++)
    {
fprintf( cost_out,"%g\t%.4g\t%.4g\t%.4g\t%.4g\t%.4g\t%.4g\t%g\t%g\t%g\t%g\t%g\t%g\t%g\t%g\n",zhat[i],Ihat[i], Ihat[i]/zbinlength, IhatNi[i], IhatNi[i]/zbinlength, IhatTi[i],IhatTi[i]/zbinlength,thicknessPb[i], thicknessFe[i],thicknessbt[i],thicknessFebt[i], RvaluesPb[i],RvaluesFe[i],Rvaluesbt[i],RvaluesFebt[i]);
    }
fclose(cost_out);
free(zhat); free(Ihat); free(IhatNi); free(IhatTi);
free(RvaluesPb);
free(RvaluesFe);
free(Rvaluesbt);
free(thicknessPb);
free(thicknessFe);
free(thicknessbt);
free(RvaluesFebt);
free(thicknessFebt);

free(doseFe);
free(dosebt);
free(doseFebt);
free(dosePb);

printf("Done with writing shielding\n");
}
#line 63625 "./ESS_BIFROST_shielding.c"
}   /* End of SCalc=Shielding_calculator() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[86]) fprintf(stderr, "Warning: No neutron could reach Component[86] SCalc\n");
    if (mcAbsorbProp[86]) fprintf(stderr, "Warning: %g events were removed in Component[86] SCalc=Shielding_calculator()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[86]);
  /* User FINALLY code for component 'DoseFe'. */
  SIG_MESSAGE("DoseFe (Finally)");
#define mccompcurname  DoseFe
#define mccompcurtype  Dose_calculator
#define mccompcurindex 87
{   /* Declarations of DoseFe=Dose_calculator() SETTING parameters. */
char* Material = mccDoseFe_Material;
MCNUM Innerspace = mccDoseFe_Innerspace;
MCNUM Thickness = mccDoseFe_Thickness;
char* SteelTubing = mccDoseFe_SteelTubing;
MCNUM TubingThickness = mccDoseFe_TubingThickness;
char* NiCaptureFile = mccDoseFe_NiCaptureFile;
char* TiCaptureFile = mccDoseFe_TiCaptureFile;
char* TotalCaptureFile = mccDoseFe_TotalCaptureFile;
char* OutputFile = mccDoseFe_OutputFile;
#line 481 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Dose_calculator.comp"
{

/** Define material for dose calculation **/

int imat=0, itubing=0;
if(strcmp(SteelTubing,"yes")==0||strcmp(SteelTubing,"Yes")==0||strcmp(SteelTubing,"YES")==0||strcmp(SteelTubing,"y")==0||strcmp(SteelTubing,"Y")==0||strcmp(SteelTubing,"1")==0){
itubing=1;
imat=0;
printf("Calculating dose for STEEL TUBING\n Outer material will be CONCRETE\n");}
else if((strcmp(Material,"Fe")==0)||(strcmp(Material,"fe")==0)||(strcmp(Material,"Iron")==0)||(strcmp(Material,"iron")==0)||(strcmp(Material,"IRON")==0)){
itubing=0;
imat=1;
printf("Calculating dose for IRON\n");}
else if ((strcmp(Material,"Pb")==0)||(strcmp(Material,"pb")==0)||(strcmp(Material,"Lead")==0)||(strcmp(Material,"lead")==0)||(strcmp(Material,"LEAD")==0))
{itubing=0;
imat=2;
printf("Calculating dose for LEAD\n");}
else if((strcmp(Material,"Conc")==0)||(strcmp(Material,"Concrete")==0)||(strcmp(Material,"conc")==0)||(strcmp(Material,"concrete")==0))
{itubing=0;
imat=0;
printf("Calculating dose for CONCRETE\n");}
else 
{
printf ("No/wrong material specified for dose calculation, possible options: Fe, Pb, concrete\n");
printf ("Using default: concrete\n");
}
/**Reading datafiles with capture per bin**/

#ifdef _WIN32
#define separator    "\\"
#else
 #define separator  "/"
#endif




double d1, d2, d3, d4;
int ibin=0,NBINS;
char line[1000],line1[1000];
char dirname[1000];
memset(dirname,0,sizeof(dirname));
strcat(strcat(dirname,mcdirname),separator);

char filename[1000];





FILE *dataIn;

memset(filename,0,sizeof(filename));//resetting filename to NULL string
strcat(strcat(filename,dirname),NiCaptureFile);

//printf("Shielding calculator:\n Reading file %s\n",filename);

if( access( filename, R_OK ) != -1 ) {
    // file exists
dataIn=fopen(filename,"r");
} else {
    // file doesn't exist
printf("Shielding calculator could not find file\n%s\nexiting.",NiCaptureFile);
exit(0);
}

if (dataIn==NULL) {printf("Can't open file\n"); exit(0);};
while (fgets(line, 1000,dataIn)!=NULL)
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4) ibin++;
};


NBINS=ibin;

//printf("Shielding calculator:\n Input file contains %d bins.\n", NBINS);

double* zhat =  malloc(NBINS*sizeof(double));
double* Ihat= malloc(NBINS*sizeof(double));
double* IhatNi= malloc(NBINS*sizeof(double));
double* IhatTi= malloc(NBINS*sizeof(double));
rewind(dataIn);
ibin=0;
while (fgets(line, 1000,dataIn)!=NULL)
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		zhat[ibin]=d1;
		IhatNi[ibin]=d2;
		ibin++;
	};
};

//printf("Shielding calculator:\n Closing file %s...",filename);
fclose(dataIn);
//printf("done\n");

memset(filename,0,sizeof(filename));// setting filename to NULL string
strcat(strcat(filename,dirname),TiCaptureFile); //setting filename to TiCapture file
//printf("Shielding calculator:\n Next input: %s\n",filename);

if( access( filename, R_OK ) != -1 ) {
    // file exists
dataIn=fopen(filename,"r");
} else {
    // file doesn't exist
printf("Shielding calculator could not find file\n%s\nexiting.",TiCaptureFile);
exit(0);
}

ibin=0;
if (dataIn==NULL) {printf("Can't open file\n"); exit(0);};
while (fgets(line, 1000,dataIn)!=NULL)
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		ibin++;
	};
};
if (ibin!=NBINS){printf("Shielding calculator:\nMismatch in number of bins between input files.\nNo shielding calculation performed, exiting\n");
exit(0);}

rewind(dataIn);


//printf("Shielding calculator:\n Reading file %s\n",filename);
ibin=0;

while (fgets(line, 1000,dataIn))
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		zhat[ibin]=d1;
		IhatTi[ibin]=d2;
		ibin++;
	};
};
fclose(dataIn);


memset(filename,0,sizeof(filename));
strcat(strcat(filename,dirname),TotalCaptureFile);
//printf("Shielding calculator:\n Next input: %s\n",filename);

if( access( filename, R_OK ) != -1 ) {
    // file exists
dataIn=fopen(filename,"r");
} else {
    // file doesn't exist
printf("Shielding calculator could not find file\n%s\nexiting.",TotalCaptureFile);
exit(0);
}


ibin=0;
if (dataIn==NULL) {printf("Can't open file\n"); exit(0);};
while (fgets(line, 1000,dataIn)!=NULL)
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		ibin++;
	};
};
if (ibin!=NBINS){printf("Shielding calculator:\nMismatch in number of bins between input files.\nNo shielding calculation performed, exiting\n");
exit(0);}

rewind(dataIn);

//printf("Shielding calculator:\n Reading file %s\n",filename);
ibin=0;
while (fgets(line, 1000,dataIn))
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		zhat[ibin]=d1;
		Ihat[ibin]=d2;
		ibin++;
	};
};
//printf("Shielding calculator:\n Closing file %s...",filename);
fclose(dataIn);
//printf("done\n");

int i,iz,iEgroup; // Auxiliary variables

double zbinlength = zhat[2]-zhat[1];



double RRR = (0.5*Innerspace)+Thickness+itubing*TubingThickness;
double*  doseUnshielded= malloc(NBINS*sizeof(double));
double* doseShielded= malloc(NBINS*sizeof(double));




/*Moving along the bins, calculating the dose */

  
 
 for ( iz=0; iz< NBINS; iz++)
  {double zc=zhat[iz]; // the z-value for the calculation                                                                                                                 
    double z;
     doseShielded[iz]=0.0;
     doseUnshielded[iz]=0.0;

         /*computing the integral*/
           double dmfp;
      for (i=0;i<NBINS;i++){
             z=zc-zhat[i];

     	for (iEgroup=0; iEgroup<nEgroup;iEgroup++){
                  double En = energy[iEgroup], fracNi=fractionNi[iEgroup],fracTi=fractionTi[iEgroup], fracB=fractionB[iEgroup];
     doseUnshielded[iz]+=(fracNi* IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatTi[i]-IhatNi[i])) *0.25/3.1415926/(RRR*RRR+z*z)*lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData);	
    if (imat==2){//LEAD
    dmfp=lint(&En,1,AttenuationSizePb, AttenuationArgsPb, AttenuationDataPb)*Thickness*sqrt(RRR*RRR+z*z)/RRR;
     double args[]={En,dmfp};
     doseShielded[iz] += (fracNi* IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatTi[i]-IhatNi[i])) *0.25/3.1415926
            *lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData)
             *exp(-dmfp)/(RRR*RRR+z*z)*lint(args, 2, BuildupSizePb,BuildupArgsPb,BuildupDataPb);}
   else if (imat==1){//IRON
    dmfp=lint(&En,1,AttenuationSizeFe, AttenuationArgsFe, AttenuationDataFe)*Thickness*sqrt(RRR*RRR+z*z)/RRR;
     double args[]={En,dmfp};
     doseShielded[iz] += (fracNi* IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatTi[i]-IhatNi[i])) *0.25/3.1415926
            *lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData)
             *exp(-dmfp)/(RRR*RRR+z*z)*lint(args, 2, BuildupSizeFe,BuildupArgsFe,BuildupDataFe);}
    else {//CONCRETE, imat=0, default
    dmfp=lint(&En,1,AttenuationSizeConc, AttenuationArgsConc, AttenuationDataConc)*Thickness*sqrt(RRR*RRR+z*z)/RRR + itubing*lint(&En,1,AttenuationSizeFe, AttenuationArgsFe, AttenuationDataFe)*TubingThickness*sqrt(RRR*RRR+z*z)/RRR;
     double args[]={En,dmfp};
     doseShielded[iz] += (fracNi* IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatTi[i]-IhatNi[i])) *0.25/3.1415926
            *lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData)
             *exp(-dmfp)/(RRR*RRR+z*z)*lint(args, 2, BuildupSizeConc,BuildupArgsConc,BuildupDataConc);}
    
	} /* summing energy groups */           
           } /* calculation of integral i=0...NBINS */
    } /* Position scan  iz */



#ifdef _WIN32
#define separator    "\\"
#else
 #define separator  "/"
#endif

FILE *dose_out;
memset(filename,0,sizeof(filename));
strcat(strcat(filename,dirname),OutputFile);
printf("Dose calculator:\nWriting to file %s\n",filename);
dose_out=fopen(filename,"w");


fprintf(dose_out,"#Dose at the outer surface of lateral %s shielding of thickness %g m\n#Guide is in the center of the innner space of width %g m\n#Presense of Steel Tubing = %s; of %g m\n#Position z,m\tOverall loss, n/s/m\tNi capture, n/s/m,\tTi capture, n/s/m\tDose unshielded, uSv/h\tDose shielded, uSv/h\n",Material, Thickness, Innerspace, SteelTubing,TubingThickness);

  
  for ( i=0; i< NBINS; i++)
    {
fprintf( dose_out,"%g\t%.3g\t%.3g\t%.3g\t%.3g\t%.3g\n",zhat[i], Ihat[i]/zbinlength,  IhatNi[i]/zbinlength, IhatTi[i]/zbinlength,doseUnshielded[i],doseShielded[i]);
    }
fclose(dose_out);
free(zhat); free(Ihat); free(IhatNi); free(IhatTi);
free(doseShielded); free(doseUnshielded);

printf("Done with writing dose rates\n");
}
#line 63920 "./ESS_BIFROST_shielding.c"
}   /* End of DoseFe=Dose_calculator() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[87]) fprintf(stderr, "Warning: No neutron could reach Component[87] DoseFe\n");
    if (mcAbsorbProp[87]) fprintf(stderr, "Warning: %g events were removed in Component[87] DoseFe=Dose_calculator()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[87]);
  /* User FINALLY code for component 'DoseConc'. */
  SIG_MESSAGE("DoseConc (Finally)");
#define mccompcurname  DoseConc
#define mccompcurtype  Dose_calculator
#define mccompcurindex 88
{   /* Declarations of DoseConc=Dose_calculator() SETTING parameters. */
char* Material = mccDoseConc_Material;
MCNUM Innerspace = mccDoseConc_Innerspace;
MCNUM Thickness = mccDoseConc_Thickness;
char* SteelTubing = mccDoseConc_SteelTubing;
MCNUM TubingThickness = mccDoseConc_TubingThickness;
char* NiCaptureFile = mccDoseConc_NiCaptureFile;
char* TiCaptureFile = mccDoseConc_TiCaptureFile;
char* TotalCaptureFile = mccDoseConc_TotalCaptureFile;
char* OutputFile = mccDoseConc_OutputFile;
#line 481 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Dose_calculator.comp"
{

/** Define material for dose calculation **/

int imat=0, itubing=0;
if(strcmp(SteelTubing,"yes")==0||strcmp(SteelTubing,"Yes")==0||strcmp(SteelTubing,"YES")==0||strcmp(SteelTubing,"y")==0||strcmp(SteelTubing,"Y")==0||strcmp(SteelTubing,"1")==0){
itubing=1;
imat=0;
printf("Calculating dose for STEEL TUBING\n Outer material will be CONCRETE\n");}
else if((strcmp(Material,"Fe")==0)||(strcmp(Material,"fe")==0)||(strcmp(Material,"Iron")==0)||(strcmp(Material,"iron")==0)||(strcmp(Material,"IRON")==0)){
itubing=0;
imat=1;
printf("Calculating dose for IRON\n");}
else if ((strcmp(Material,"Pb")==0)||(strcmp(Material,"pb")==0)||(strcmp(Material,"Lead")==0)||(strcmp(Material,"lead")==0)||(strcmp(Material,"LEAD")==0))
{itubing=0;
imat=2;
printf("Calculating dose for LEAD\n");}
else if((strcmp(Material,"Conc")==0)||(strcmp(Material,"Concrete")==0)||(strcmp(Material,"conc")==0)||(strcmp(Material,"concrete")==0))
{itubing=0;
imat=0;
printf("Calculating dose for CONCRETE\n");}
else 
{
printf ("No/wrong material specified for dose calculation, possible options: Fe, Pb, concrete\n");
printf ("Using default: concrete\n");
}
/**Reading datafiles with capture per bin**/

#ifdef _WIN32
#define separator    "\\"
#else
 #define separator  "/"
#endif




double d1, d2, d3, d4;
int ibin=0,NBINS;
char line[1000],line1[1000];
char dirname[1000];
memset(dirname,0,sizeof(dirname));
strcat(strcat(dirname,mcdirname),separator);

char filename[1000];





FILE *dataIn;

memset(filename,0,sizeof(filename));//resetting filename to NULL string
strcat(strcat(filename,dirname),NiCaptureFile);

//printf("Shielding calculator:\n Reading file %s\n",filename);

if( access( filename, R_OK ) != -1 ) {
    // file exists
dataIn=fopen(filename,"r");
} else {
    // file doesn't exist
printf("Shielding calculator could not find file\n%s\nexiting.",NiCaptureFile);
exit(0);
}

if (dataIn==NULL) {printf("Can't open file\n"); exit(0);};
while (fgets(line, 1000,dataIn)!=NULL)
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4) ibin++;
};


NBINS=ibin;

//printf("Shielding calculator:\n Input file contains %d bins.\n", NBINS);

double* zhat =  malloc(NBINS*sizeof(double));
double* Ihat= malloc(NBINS*sizeof(double));
double* IhatNi= malloc(NBINS*sizeof(double));
double* IhatTi= malloc(NBINS*sizeof(double));
rewind(dataIn);
ibin=0;
while (fgets(line, 1000,dataIn)!=NULL)
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		zhat[ibin]=d1;
		IhatNi[ibin]=d2;
		ibin++;
	};
};

//printf("Shielding calculator:\n Closing file %s...",filename);
fclose(dataIn);
//printf("done\n");

memset(filename,0,sizeof(filename));// setting filename to NULL string
strcat(strcat(filename,dirname),TiCaptureFile); //setting filename to TiCapture file
//printf("Shielding calculator:\n Next input: %s\n",filename);

if( access( filename, R_OK ) != -1 ) {
    // file exists
dataIn=fopen(filename,"r");
} else {
    // file doesn't exist
printf("Shielding calculator could not find file\n%s\nexiting.",TiCaptureFile);
exit(0);
}

ibin=0;
if (dataIn==NULL) {printf("Can't open file\n"); exit(0);};
while (fgets(line, 1000,dataIn)!=NULL)
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		ibin++;
	};
};
if (ibin!=NBINS){printf("Shielding calculator:\nMismatch in number of bins between input files.\nNo shielding calculation performed, exiting\n");
exit(0);}

rewind(dataIn);


//printf("Shielding calculator:\n Reading file %s\n",filename);
ibin=0;

while (fgets(line, 1000,dataIn))
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		zhat[ibin]=d1;
		IhatTi[ibin]=d2;
		ibin++;
	};
};
fclose(dataIn);


memset(filename,0,sizeof(filename));
strcat(strcat(filename,dirname),TotalCaptureFile);
//printf("Shielding calculator:\n Next input: %s\n",filename);

if( access( filename, R_OK ) != -1 ) {
    // file exists
dataIn=fopen(filename,"r");
} else {
    // file doesn't exist
printf("Shielding calculator could not find file\n%s\nexiting.",TotalCaptureFile);
exit(0);
}


ibin=0;
if (dataIn==NULL) {printf("Can't open file\n"); exit(0);};
while (fgets(line, 1000,dataIn)!=NULL)
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		ibin++;
	};
};
if (ibin!=NBINS){printf("Shielding calculator:\nMismatch in number of bins between input files.\nNo shielding calculation performed, exiting\n");
exit(0);}

rewind(dataIn);

//printf("Shielding calculator:\n Reading file %s\n",filename);
ibin=0;
while (fgets(line, 1000,dataIn))
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		zhat[ibin]=d1;
		Ihat[ibin]=d2;
		ibin++;
	};
};
//printf("Shielding calculator:\n Closing file %s...",filename);
fclose(dataIn);
//printf("done\n");

int i,iz,iEgroup; // Auxiliary variables

double zbinlength = zhat[2]-zhat[1];



double RRR = (0.5*Innerspace)+Thickness+itubing*TubingThickness;
double*  doseUnshielded= malloc(NBINS*sizeof(double));
double* doseShielded= malloc(NBINS*sizeof(double));




/*Moving along the bins, calculating the dose */

  
 
 for ( iz=0; iz< NBINS; iz++)
  {double zc=zhat[iz]; // the z-value for the calculation                                                                                                                 
    double z;
     doseShielded[iz]=0.0;
     doseUnshielded[iz]=0.0;

         /*computing the integral*/
           double dmfp;
      for (i=0;i<NBINS;i++){
             z=zc-zhat[i];

     	for (iEgroup=0; iEgroup<nEgroup;iEgroup++){
                  double En = energy[iEgroup], fracNi=fractionNi[iEgroup],fracTi=fractionTi[iEgroup], fracB=fractionB[iEgroup];
     doseUnshielded[iz]+=(fracNi* IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatTi[i]-IhatNi[i])) *0.25/3.1415926/(RRR*RRR+z*z)*lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData);	
    if (imat==2){//LEAD
    dmfp=lint(&En,1,AttenuationSizePb, AttenuationArgsPb, AttenuationDataPb)*Thickness*sqrt(RRR*RRR+z*z)/RRR;
     double args[]={En,dmfp};
     doseShielded[iz] += (fracNi* IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatTi[i]-IhatNi[i])) *0.25/3.1415926
            *lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData)
             *exp(-dmfp)/(RRR*RRR+z*z)*lint(args, 2, BuildupSizePb,BuildupArgsPb,BuildupDataPb);}
   else if (imat==1){//IRON
    dmfp=lint(&En,1,AttenuationSizeFe, AttenuationArgsFe, AttenuationDataFe)*Thickness*sqrt(RRR*RRR+z*z)/RRR;
     double args[]={En,dmfp};
     doseShielded[iz] += (fracNi* IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatTi[i]-IhatNi[i])) *0.25/3.1415926
            *lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData)
             *exp(-dmfp)/(RRR*RRR+z*z)*lint(args, 2, BuildupSizeFe,BuildupArgsFe,BuildupDataFe);}
    else {//CONCRETE, imat=0, default
    dmfp=lint(&En,1,AttenuationSizeConc, AttenuationArgsConc, AttenuationDataConc)*Thickness*sqrt(RRR*RRR+z*z)/RRR + itubing*lint(&En,1,AttenuationSizeFe, AttenuationArgsFe, AttenuationDataFe)*TubingThickness*sqrt(RRR*RRR+z*z)/RRR;
     double args[]={En,dmfp};
     doseShielded[iz] += (fracNi* IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatTi[i]-IhatNi[i])) *0.25/3.1415926
            *lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData)
             *exp(-dmfp)/(RRR*RRR+z*z)*lint(args, 2, BuildupSizeConc,BuildupArgsConc,BuildupDataConc);}
    
	} /* summing energy groups */           
           } /* calculation of integral i=0...NBINS */
    } /* Position scan  iz */



#ifdef _WIN32
#define separator    "\\"
#else
 #define separator  "/"
#endif

FILE *dose_out;
memset(filename,0,sizeof(filename));
strcat(strcat(filename,dirname),OutputFile);
printf("Dose calculator:\nWriting to file %s\n",filename);
dose_out=fopen(filename,"w");


fprintf(dose_out,"#Dose at the outer surface of lateral %s shielding of thickness %g m\n#Guide is in the center of the innner space of width %g m\n#Presense of Steel Tubing = %s; of %g m\n#Position z,m\tOverall loss, n/s/m\tNi capture, n/s/m,\tTi capture, n/s/m\tDose unshielded, uSv/h\tDose shielded, uSv/h\n",Material, Thickness, Innerspace, SteelTubing,TubingThickness);

  
  for ( i=0; i< NBINS; i++)
    {
fprintf( dose_out,"%g\t%.3g\t%.3g\t%.3g\t%.3g\t%.3g\n",zhat[i], Ihat[i]/zbinlength,  IhatNi[i]/zbinlength, IhatTi[i]/zbinlength,doseUnshielded[i],doseShielded[i]);
    }
fclose(dose_out);
free(zhat); free(Ihat); free(IhatNi); free(IhatTi);
free(doseShielded); free(doseUnshielded);

printf("Done with writing dose rates\n");
}
#line 64215 "./ESS_BIFROST_shielding.c"
}   /* End of DoseConc=Dose_calculator() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[88]) fprintf(stderr, "Warning: No neutron could reach Component[88] DoseConc\n");
    if (mcAbsorbProp[88]) fprintf(stderr, "Warning: %g events were removed in Component[88] DoseConc=Dose_calculator()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[88]);
  /* User FINALLY code for component 'DoseStandard'. */
  SIG_MESSAGE("DoseStandard (Finally)");
#define mccompcurname  DoseStandard
#define mccompcurtype  Dose_calculator
#define mccompcurindex 89
{   /* Declarations of DoseStandard=Dose_calculator() SETTING parameters. */
char* Material = mccDoseStandard_Material;
MCNUM Innerspace = mccDoseStandard_Innerspace;
MCNUM Thickness = mccDoseStandard_Thickness;
char* SteelTubing = mccDoseStandard_SteelTubing;
MCNUM TubingThickness = mccDoseStandard_TubingThickness;
char* NiCaptureFile = mccDoseStandard_NiCaptureFile;
char* TiCaptureFile = mccDoseStandard_TiCaptureFile;
char* TotalCaptureFile = mccDoseStandard_TotalCaptureFile;
char* OutputFile = mccDoseStandard_OutputFile;
#line 481 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Dose_calculator.comp"
{

/** Define material for dose calculation **/

int imat=0, itubing=0;
if(strcmp(SteelTubing,"yes")==0||strcmp(SteelTubing,"Yes")==0||strcmp(SteelTubing,"YES")==0||strcmp(SteelTubing,"y")==0||strcmp(SteelTubing,"Y")==0||strcmp(SteelTubing,"1")==0){
itubing=1;
imat=0;
printf("Calculating dose for STEEL TUBING\n Outer material will be CONCRETE\n");}
else if((strcmp(Material,"Fe")==0)||(strcmp(Material,"fe")==0)||(strcmp(Material,"Iron")==0)||(strcmp(Material,"iron")==0)||(strcmp(Material,"IRON")==0)){
itubing=0;
imat=1;
printf("Calculating dose for IRON\n");}
else if ((strcmp(Material,"Pb")==0)||(strcmp(Material,"pb")==0)||(strcmp(Material,"Lead")==0)||(strcmp(Material,"lead")==0)||(strcmp(Material,"LEAD")==0))
{itubing=0;
imat=2;
printf("Calculating dose for LEAD\n");}
else if((strcmp(Material,"Conc")==0)||(strcmp(Material,"Concrete")==0)||(strcmp(Material,"conc")==0)||(strcmp(Material,"concrete")==0))
{itubing=0;
imat=0;
printf("Calculating dose for CONCRETE\n");}
else 
{
printf ("No/wrong material specified for dose calculation, possible options: Fe, Pb, concrete\n");
printf ("Using default: concrete\n");
}
/**Reading datafiles with capture per bin**/

#ifdef _WIN32
#define separator    "\\"
#else
 #define separator  "/"
#endif




double d1, d2, d3, d4;
int ibin=0,NBINS;
char line[1000],line1[1000];
char dirname[1000];
memset(dirname,0,sizeof(dirname));
strcat(strcat(dirname,mcdirname),separator);

char filename[1000];





FILE *dataIn;

memset(filename,0,sizeof(filename));//resetting filename to NULL string
strcat(strcat(filename,dirname),NiCaptureFile);

//printf("Shielding calculator:\n Reading file %s\n",filename);

if( access( filename, R_OK ) != -1 ) {
    // file exists
dataIn=fopen(filename,"r");
} else {
    // file doesn't exist
printf("Shielding calculator could not find file\n%s\nexiting.",NiCaptureFile);
exit(0);
}

if (dataIn==NULL) {printf("Can't open file\n"); exit(0);};
while (fgets(line, 1000,dataIn)!=NULL)
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4) ibin++;
};


NBINS=ibin;

//printf("Shielding calculator:\n Input file contains %d bins.\n", NBINS);

double* zhat =  malloc(NBINS*sizeof(double));
double* Ihat= malloc(NBINS*sizeof(double));
double* IhatNi= malloc(NBINS*sizeof(double));
double* IhatTi= malloc(NBINS*sizeof(double));
rewind(dataIn);
ibin=0;
while (fgets(line, 1000,dataIn)!=NULL)
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		zhat[ibin]=d1;
		IhatNi[ibin]=d2;
		ibin++;
	};
};

//printf("Shielding calculator:\n Closing file %s...",filename);
fclose(dataIn);
//printf("done\n");

memset(filename,0,sizeof(filename));// setting filename to NULL string
strcat(strcat(filename,dirname),TiCaptureFile); //setting filename to TiCapture file
//printf("Shielding calculator:\n Next input: %s\n",filename);

if( access( filename, R_OK ) != -1 ) {
    // file exists
dataIn=fopen(filename,"r");
} else {
    // file doesn't exist
printf("Shielding calculator could not find file\n%s\nexiting.",TiCaptureFile);
exit(0);
}

ibin=0;
if (dataIn==NULL) {printf("Can't open file\n"); exit(0);};
while (fgets(line, 1000,dataIn)!=NULL)
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		ibin++;
	};
};
if (ibin!=NBINS){printf("Shielding calculator:\nMismatch in number of bins between input files.\nNo shielding calculation performed, exiting\n");
exit(0);}

rewind(dataIn);


//printf("Shielding calculator:\n Reading file %s\n",filename);
ibin=0;

while (fgets(line, 1000,dataIn))
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		zhat[ibin]=d1;
		IhatTi[ibin]=d2;
		ibin++;
	};
};
fclose(dataIn);


memset(filename,0,sizeof(filename));
strcat(strcat(filename,dirname),TotalCaptureFile);
//printf("Shielding calculator:\n Next input: %s\n",filename);

if( access( filename, R_OK ) != -1 ) {
    // file exists
dataIn=fopen(filename,"r");
} else {
    // file doesn't exist
printf("Shielding calculator could not find file\n%s\nexiting.",TotalCaptureFile);
exit(0);
}


ibin=0;
if (dataIn==NULL) {printf("Can't open file\n"); exit(0);};
while (fgets(line, 1000,dataIn)!=NULL)
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		ibin++;
	};
};
if (ibin!=NBINS){printf("Shielding calculator:\nMismatch in number of bins between input files.\nNo shielding calculation performed, exiting\n");
exit(0);}

rewind(dataIn);

//printf("Shielding calculator:\n Reading file %s\n",filename);
ibin=0;
while (fgets(line, 1000,dataIn))
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		zhat[ibin]=d1;
		Ihat[ibin]=d2;
		ibin++;
	};
};
//printf("Shielding calculator:\n Closing file %s...",filename);
fclose(dataIn);
//printf("done\n");

int i,iz,iEgroup; // Auxiliary variables

double zbinlength = zhat[2]-zhat[1];



double RRR = (0.5*Innerspace)+Thickness+itubing*TubingThickness;
double*  doseUnshielded= malloc(NBINS*sizeof(double));
double* doseShielded= malloc(NBINS*sizeof(double));




/*Moving along the bins, calculating the dose */

  
 
 for ( iz=0; iz< NBINS; iz++)
  {double zc=zhat[iz]; // the z-value for the calculation                                                                                                                 
    double z;
     doseShielded[iz]=0.0;
     doseUnshielded[iz]=0.0;

         /*computing the integral*/
           double dmfp;
      for (i=0;i<NBINS;i++){
             z=zc-zhat[i];

     	for (iEgroup=0; iEgroup<nEgroup;iEgroup++){
                  double En = energy[iEgroup], fracNi=fractionNi[iEgroup],fracTi=fractionTi[iEgroup], fracB=fractionB[iEgroup];
     doseUnshielded[iz]+=(fracNi* IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatTi[i]-IhatNi[i])) *0.25/3.1415926/(RRR*RRR+z*z)*lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData);	
    if (imat==2){//LEAD
    dmfp=lint(&En,1,AttenuationSizePb, AttenuationArgsPb, AttenuationDataPb)*Thickness*sqrt(RRR*RRR+z*z)/RRR;
     double args[]={En,dmfp};
     doseShielded[iz] += (fracNi* IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatTi[i]-IhatNi[i])) *0.25/3.1415926
            *lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData)
             *exp(-dmfp)/(RRR*RRR+z*z)*lint(args, 2, BuildupSizePb,BuildupArgsPb,BuildupDataPb);}
   else if (imat==1){//IRON
    dmfp=lint(&En,1,AttenuationSizeFe, AttenuationArgsFe, AttenuationDataFe)*Thickness*sqrt(RRR*RRR+z*z)/RRR;
     double args[]={En,dmfp};
     doseShielded[iz] += (fracNi* IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatTi[i]-IhatNi[i])) *0.25/3.1415926
            *lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData)
             *exp(-dmfp)/(RRR*RRR+z*z)*lint(args, 2, BuildupSizeFe,BuildupArgsFe,BuildupDataFe);}
    else {//CONCRETE, imat=0, default
    dmfp=lint(&En,1,AttenuationSizeConc, AttenuationArgsConc, AttenuationDataConc)*Thickness*sqrt(RRR*RRR+z*z)/RRR + itubing*lint(&En,1,AttenuationSizeFe, AttenuationArgsFe, AttenuationDataFe)*TubingThickness*sqrt(RRR*RRR+z*z)/RRR;
     double args[]={En,dmfp};
     doseShielded[iz] += (fracNi* IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatTi[i]-IhatNi[i])) *0.25/3.1415926
            *lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData)
             *exp(-dmfp)/(RRR*RRR+z*z)*lint(args, 2, BuildupSizeConc,BuildupArgsConc,BuildupDataConc);}
    
	} /* summing energy groups */           
           } /* calculation of integral i=0...NBINS */
    } /* Position scan  iz */



#ifdef _WIN32
#define separator    "\\"
#else
 #define separator  "/"
#endif

FILE *dose_out;
memset(filename,0,sizeof(filename));
strcat(strcat(filename,dirname),OutputFile);
printf("Dose calculator:\nWriting to file %s\n",filename);
dose_out=fopen(filename,"w");


fprintf(dose_out,"#Dose at the outer surface of lateral %s shielding of thickness %g m\n#Guide is in the center of the innner space of width %g m\n#Presense of Steel Tubing = %s; of %g m\n#Position z,m\tOverall loss, n/s/m\tNi capture, n/s/m,\tTi capture, n/s/m\tDose unshielded, uSv/h\tDose shielded, uSv/h\n",Material, Thickness, Innerspace, SteelTubing,TubingThickness);

  
  for ( i=0; i< NBINS; i++)
    {
fprintf( dose_out,"%g\t%.3g\t%.3g\t%.3g\t%.3g\t%.3g\n",zhat[i], Ihat[i]/zbinlength,  IhatNi[i]/zbinlength, IhatTi[i]/zbinlength,doseUnshielded[i],doseShielded[i]);
    }
fclose(dose_out);
free(zhat); free(Ihat); free(IhatNi); free(IhatTi);
free(doseShielded); free(doseUnshielded);

printf("Done with writing dose rates\n");
}
#line 64510 "./ESS_BIFROST_shielding.c"
}   /* End of DoseStandard=Dose_calculator() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[89]) fprintf(stderr, "Warning: No neutron could reach Component[89] DoseStandard\n");
    if (mcAbsorbProp[89]) fprintf(stderr, "Warning: %g events were removed in Component[89] DoseStandard=Dose_calculator()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[89]);
  /* User FINALLY code for component 'Dose5'. */
  SIG_MESSAGE("Dose5 (Finally)");
#define mccompcurname  Dose5
#define mccompcurtype  Dose_calculator
#define mccompcurindex 90
{   /* Declarations of Dose5=Dose_calculator() SETTING parameters. */
char* Material = mccDose5_Material;
MCNUM Innerspace = mccDose5_Innerspace;
MCNUM Thickness = mccDose5_Thickness;
char* SteelTubing = mccDose5_SteelTubing;
MCNUM TubingThickness = mccDose5_TubingThickness;
char* NiCaptureFile = mccDose5_NiCaptureFile;
char* TiCaptureFile = mccDose5_TiCaptureFile;
char* TotalCaptureFile = mccDose5_TotalCaptureFile;
char* OutputFile = mccDose5_OutputFile;
#line 481 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Dose_calculator.comp"
{

/** Define material for dose calculation **/

int imat=0, itubing=0;
if(strcmp(SteelTubing,"yes")==0||strcmp(SteelTubing,"Yes")==0||strcmp(SteelTubing,"YES")==0||strcmp(SteelTubing,"y")==0||strcmp(SteelTubing,"Y")==0||strcmp(SteelTubing,"1")==0){
itubing=1;
imat=0;
printf("Calculating dose for STEEL TUBING\n Outer material will be CONCRETE\n");}
else if((strcmp(Material,"Fe")==0)||(strcmp(Material,"fe")==0)||(strcmp(Material,"Iron")==0)||(strcmp(Material,"iron")==0)||(strcmp(Material,"IRON")==0)){
itubing=0;
imat=1;
printf("Calculating dose for IRON\n");}
else if ((strcmp(Material,"Pb")==0)||(strcmp(Material,"pb")==0)||(strcmp(Material,"Lead")==0)||(strcmp(Material,"lead")==0)||(strcmp(Material,"LEAD")==0))
{itubing=0;
imat=2;
printf("Calculating dose for LEAD\n");}
else if((strcmp(Material,"Conc")==0)||(strcmp(Material,"Concrete")==0)||(strcmp(Material,"conc")==0)||(strcmp(Material,"concrete")==0))
{itubing=0;
imat=0;
printf("Calculating dose for CONCRETE\n");}
else 
{
printf ("No/wrong material specified for dose calculation, possible options: Fe, Pb, concrete\n");
printf ("Using default: concrete\n");
}
/**Reading datafiles with capture per bin**/

#ifdef _WIN32
#define separator    "\\"
#else
 #define separator  "/"
#endif




double d1, d2, d3, d4;
int ibin=0,NBINS;
char line[1000],line1[1000];
char dirname[1000];
memset(dirname,0,sizeof(dirname));
strcat(strcat(dirname,mcdirname),separator);

char filename[1000];





FILE *dataIn;

memset(filename,0,sizeof(filename));//resetting filename to NULL string
strcat(strcat(filename,dirname),NiCaptureFile);

//printf("Shielding calculator:\n Reading file %s\n",filename);

if( access( filename, R_OK ) != -1 ) {
    // file exists
dataIn=fopen(filename,"r");
} else {
    // file doesn't exist
printf("Shielding calculator could not find file\n%s\nexiting.",NiCaptureFile);
exit(0);
}

if (dataIn==NULL) {printf("Can't open file\n"); exit(0);};
while (fgets(line, 1000,dataIn)!=NULL)
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4) ibin++;
};


NBINS=ibin;

//printf("Shielding calculator:\n Input file contains %d bins.\n", NBINS);

double* zhat =  malloc(NBINS*sizeof(double));
double* Ihat= malloc(NBINS*sizeof(double));
double* IhatNi= malloc(NBINS*sizeof(double));
double* IhatTi= malloc(NBINS*sizeof(double));
rewind(dataIn);
ibin=0;
while (fgets(line, 1000,dataIn)!=NULL)
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		zhat[ibin]=d1;
		IhatNi[ibin]=d2;
		ibin++;
	};
};

//printf("Shielding calculator:\n Closing file %s...",filename);
fclose(dataIn);
//printf("done\n");

memset(filename,0,sizeof(filename));// setting filename to NULL string
strcat(strcat(filename,dirname),TiCaptureFile); //setting filename to TiCapture file
//printf("Shielding calculator:\n Next input: %s\n",filename);

if( access( filename, R_OK ) != -1 ) {
    // file exists
dataIn=fopen(filename,"r");
} else {
    // file doesn't exist
printf("Shielding calculator could not find file\n%s\nexiting.",TiCaptureFile);
exit(0);
}

ibin=0;
if (dataIn==NULL) {printf("Can't open file\n"); exit(0);};
while (fgets(line, 1000,dataIn)!=NULL)
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		ibin++;
	};
};
if (ibin!=NBINS){printf("Shielding calculator:\nMismatch in number of bins between input files.\nNo shielding calculation performed, exiting\n");
exit(0);}

rewind(dataIn);


//printf("Shielding calculator:\n Reading file %s\n",filename);
ibin=0;

while (fgets(line, 1000,dataIn))
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		zhat[ibin]=d1;
		IhatTi[ibin]=d2;
		ibin++;
	};
};
fclose(dataIn);


memset(filename,0,sizeof(filename));
strcat(strcat(filename,dirname),TotalCaptureFile);
//printf("Shielding calculator:\n Next input: %s\n",filename);

if( access( filename, R_OK ) != -1 ) {
    // file exists
dataIn=fopen(filename,"r");
} else {
    // file doesn't exist
printf("Shielding calculator could not find file\n%s\nexiting.",TotalCaptureFile);
exit(0);
}


ibin=0;
if (dataIn==NULL) {printf("Can't open file\n"); exit(0);};
while (fgets(line, 1000,dataIn)!=NULL)
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		ibin++;
	};
};
if (ibin!=NBINS){printf("Shielding calculator:\nMismatch in number of bins between input files.\nNo shielding calculation performed, exiting\n");
exit(0);}

rewind(dataIn);

//printf("Shielding calculator:\n Reading file %s\n",filename);
ibin=0;
while (fgets(line, 1000,dataIn))
{ 
if (*line=='#') continue; // ignore comment line
if(sscanf(line,"%le %le %le %le",&d1, &d2, &d3, &d4)==4)
	{
		zhat[ibin]=d1;
		Ihat[ibin]=d2;
		ibin++;
	};
};
//printf("Shielding calculator:\n Closing file %s...",filename);
fclose(dataIn);
//printf("done\n");

int i,iz,iEgroup; // Auxiliary variables

double zbinlength = zhat[2]-zhat[1];



double RRR = (0.5*Innerspace)+Thickness+itubing*TubingThickness;
double*  doseUnshielded= malloc(NBINS*sizeof(double));
double* doseShielded= malloc(NBINS*sizeof(double));




/*Moving along the bins, calculating the dose */

  
 
 for ( iz=0; iz< NBINS; iz++)
  {double zc=zhat[iz]; // the z-value for the calculation                                                                                                                 
    double z;
     doseShielded[iz]=0.0;
     doseUnshielded[iz]=0.0;

         /*computing the integral*/
           double dmfp;
      for (i=0;i<NBINS;i++){
             z=zc-zhat[i];

     	for (iEgroup=0; iEgroup<nEgroup;iEgroup++){
                  double En = energy[iEgroup], fracNi=fractionNi[iEgroup],fracTi=fractionTi[iEgroup], fracB=fractionB[iEgroup];
     doseUnshielded[iz]+=(fracNi* IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatTi[i]-IhatNi[i])) *0.25/3.1415926/(RRR*RRR+z*z)*lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData);	
    if (imat==2){//LEAD
    dmfp=lint(&En,1,AttenuationSizePb, AttenuationArgsPb, AttenuationDataPb)*Thickness*sqrt(RRR*RRR+z*z)/RRR;
     double args[]={En,dmfp};
     doseShielded[iz] += (fracNi* IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatTi[i]-IhatNi[i])) *0.25/3.1415926
            *lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData)
             *exp(-dmfp)/(RRR*RRR+z*z)*lint(args, 2, BuildupSizePb,BuildupArgsPb,BuildupDataPb);}
   else if (imat==1){//IRON
    dmfp=lint(&En,1,AttenuationSizeFe, AttenuationArgsFe, AttenuationDataFe)*Thickness*sqrt(RRR*RRR+z*z)/RRR;
     double args[]={En,dmfp};
     doseShielded[iz] += (fracNi* IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatTi[i]-IhatNi[i])) *0.25/3.1415926
            *lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData)
             *exp(-dmfp)/(RRR*RRR+z*z)*lint(args, 2, BuildupSizeFe,BuildupArgsFe,BuildupDataFe);}
    else {//CONCRETE, imat=0, default
    dmfp=lint(&En,1,AttenuationSizeConc, AttenuationArgsConc, AttenuationDataConc)*Thickness*sqrt(RRR*RRR+z*z)/RRR + itubing*lint(&En,1,AttenuationSizeFe, AttenuationArgsFe, AttenuationDataFe)*TubingThickness*sqrt(RRR*RRR+z*z)/RRR;
     double args[]={En,dmfp};
     doseShielded[iz] += (fracNi* IhatNi[i]+fracTi*IhatTi[i]+fracB*(Ihat[i]-IhatTi[i]-IhatNi[i])) *0.25/3.1415926
            *lint(&En, 1,  FtoDSize, FtoDArgs,FtoDData)
             *exp(-dmfp)/(RRR*RRR+z*z)*lint(args, 2, BuildupSizeConc,BuildupArgsConc,BuildupDataConc);}
    
	} /* summing energy groups */           
           } /* calculation of integral i=0...NBINS */
    } /* Position scan  iz */



#ifdef _WIN32
#define separator    "\\"
#else
 #define separator  "/"
#endif

FILE *dose_out;
memset(filename,0,sizeof(filename));
strcat(strcat(filename,dirname),OutputFile);
printf("Dose calculator:\nWriting to file %s\n",filename);
dose_out=fopen(filename,"w");


fprintf(dose_out,"#Dose at the outer surface of lateral %s shielding of thickness %g m\n#Guide is in the center of the innner space of width %g m\n#Presense of Steel Tubing = %s; of %g m\n#Position z,m\tOverall loss, n/s/m\tNi capture, n/s/m,\tTi capture, n/s/m\tDose unshielded, uSv/h\tDose shielded, uSv/h\n",Material, Thickness, Innerspace, SteelTubing,TubingThickness);

  
  for ( i=0; i< NBINS; i++)
    {
fprintf( dose_out,"%g\t%.3g\t%.3g\t%.3g\t%.3g\t%.3g\n",zhat[i], Ihat[i]/zbinlength,  IhatNi[i]/zbinlength, IhatTi[i]/zbinlength,doseUnshielded[i],doseShielded[i]);
    }
fclose(dose_out);
free(zhat); free(Ihat); free(IhatNi); free(IhatTi);
free(doseShielded); free(doseUnshielded);

printf("Done with writing dose rates\n");
}
#line 64805 "./ESS_BIFROST_shielding.c"
}   /* End of Dose5=Dose_calculator() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[90]) fprintf(stderr, "Warning: No neutron could reach Component[90] Dose5\n");
    if (mcAbsorbProp[90]) fprintf(stderr, "Warning: %g events were removed in Component[90] Dose5=Dose_calculator()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[90]);
  mcsiminfo_close(); 
} /* end finally */
#define magnify mcdis_magnify
#define line mcdis_line
#define dashed_line mcdis_dashed_line
#define multiline mcdis_multiline
#define rectangle mcdis_rectangle
#define box mcdis_box
#define circle mcdis_circle
#define cylinder mcdis_cylinder
#define sphere mcdis_sphere
void mcdisplay(void) {
  printf("MCDISPLAY: start\n");
  /* Components MCDISPLAY code. */

  /* MCDISPLAY code for component 'Origin'. */
  SIG_MESSAGE("Origin (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Origin");
#define mccompcurname  Origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccOrigin_IntermediateCnts
#define StartTime mccOrigin_StartTime
#define EndTime mccOrigin_EndTime
#define CurrentTime mccOrigin_CurrentTime
{   /* Declarations of Origin=Progress_bar() SETTING parameters. */
char* profile = mccOrigin_profile;
MCNUM percent = mccOrigin_percent;
MCNUM flag_save = mccOrigin_flag_save;
MCNUM minutes = mccOrigin_minutes;
#line 147 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../misc/Progress_bar.comp"
{
  
}
#line 64847 "./ESS_BIFROST_shielding.c"
}   /* End of Origin=Progress_bar() SETTING parameter declarations. */
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ESS_source'. */
  SIG_MESSAGE("ESS_source (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ESS_source");
#define mccompcurname  ESS_source
#define mccompcurtype  ESS_butterfly
#define mccompcurindex 2
#define cx mccESS_source_cx
#define cz mccESS_source_cz
#define sign_bl_angle mccESS_source_sign_bl_angle
#define orientation_angle mccESS_source_orientation_angle
#define jmax mccESS_source_jmax
#define C1_x mccESS_source_C1_x
#define C1_z mccESS_source_C1_z
#define C2_x mccESS_source_C2_x
#define C2_z mccESS_source_C2_z
#define C3_x mccESS_source_C3_x
#define C3_z mccESS_source_C3_z
#define T1_x mccESS_source_T1_x
#define T1_z mccESS_source_T1_z
#define T2_x mccESS_source_T2_x
#define T2_z mccESS_source_T2_z
#define T3_x mccESS_source_T3_x
#define T3_z mccESS_source_T3_z
#define rC1_x mccESS_source_rC1_x
#define rC1_z mccESS_source_rC1_z
#define rC2_x mccESS_source_rC2_x
#define rC2_z mccESS_source_rC2_z
#define rC3_x mccESS_source_rC3_x
#define rC3_z mccESS_source_rC3_z
#define rT1_x mccESS_source_rT1_x
#define rT1_z mccESS_source_rT1_z
#define rT2_x mccESS_source_rT2_x
#define rT2_z mccESS_source_rT2_z
#define rT3_x mccESS_source_rT3_x
#define rT3_z mccESS_source_rT3_z
#define tx mccESS_source_tx
#define ty mccESS_source_ty
#define tz mccESS_source_tz
#define r11 mccESS_source_r11
#define r12 mccESS_source_r12
#define r21 mccESS_source_r21
#define r22 mccESS_source_r22
#define xf mccESS_source_xf
#define yf mccESS_source_yf
#define zf mccESS_source_zf
#define w_mult mccESS_source_w_mult
#define w_stat mccESS_source_w_stat
#define w_geom mccESS_source_w_geom
#define w_focus mccESS_source_w_focus
#define w_tfocus mccESS_source_w_tfocus
#define w_geom_c mccESS_source_w_geom_c
#define w_geom_t mccESS_source_w_geom_t
#define tx mccESS_source_tx
#define ty mccESS_source_ty
#define tz mccESS_source_tz
#define dt mccESS_source_dt
#define lambda mccESS_source_lambda
#define l_range mccESS_source_l_range
#define k mccESS_source_k
#define v mccESS_source_v
#define r mccESS_source_r
#define dx mccESS_source_dx
#define dy mccESS_source_dy
#define dz mccESS_source_dz
#define internal_angle mccESS_source_internal_angle
#define x0 mccESS_source_x0
#define z0 mccESS_source_z0
#define cos_beamport_angle mccESS_source_cos_beamport_angle
#define sin_beamport_angle mccESS_source_sin_beamport_angle
#define cos_thermal mccESS_source_cos_thermal
#define cos_cold mccESS_source_cos_cold
#define Lmin_sampled mccESS_source_Lmin_sampled
#define Lmax_sampled mccESS_source_Lmax_sampled
{   /* Declarations of ESS_source=ESS_butterfly() SETTING parameters. */
char* sector = mccESS_source_sector;
int beamline = mccESS_source_beamline;
MCNUM yheight = mccESS_source_yheight;
MCNUM cold_frac = mccESS_source_cold_frac;
int target_index = mccESS_source_target_index;
MCNUM dist = mccESS_source_dist;
MCNUM focus_xw = mccESS_source_focus_xw;
MCNUM focus_yh = mccESS_source_focus_yh;
MCNUM c_performance = mccESS_source_c_performance;
MCNUM t_performance = mccESS_source_t_performance;
MCNUM Lmin = mccESS_source_Lmin;
MCNUM Lmax = mccESS_source_Lmax;
MCNUM tmax_multiplier = mccESS_source_tmax_multiplier;
int n_pulses = mccESS_source_n_pulses;
MCNUM acc_power = mccESS_source_acc_power;
MCNUM tfocus_dist = mccESS_source_tfocus_dist;
MCNUM tfocus_time = mccESS_source_tfocus_time;
MCNUM tfocus_width = mccESS_source_tfocus_width;
#line 540 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../sources/ESS_butterfly.comp"
{
/* MCDISPLAY-section for the ESS butterfly moderator */

/* Define the positioning of the buttefly sketch */

/* Point sets for the butterfly */
double butterfly_z[] = {-1.9922764e-01, -1.8484553e-01, -2.0252845e-01, -2.0795122e-01, -2.1054471e-01, -2.1030894e-01, -2.0889431e-01, -2.0535772e-01, -2.0134959e-01, -1.9639837e-01, -1.9026829e-01, -1.8390244e-01, -1.7565041e-01, -1.7093496e-01, -1.4617886e-01, -1.2873171e-01, -9.2658537e-02, -4.0552845e-02, -1.7682927e-02, -9.1951221e-03, -2.3577231e-03, 5.1869889e-03, 1.1788619e-02, 1.7918699e-02, 2.3105689e-02, 2.4991869e-02, 2.4756099e-02, 2.2162599e-02, 1.8154469e-02, 1.2731709e-02, 5.6585389e-03, -2.3577214e-04, 1.4146339e-02, -2.9707317e-02, 1.4146339e-02, -4.7154514e-04, 1.5325199e-02, 2.1691059e-02, 2.4991869e-02, 2.4991869e-02, 2.2634149e-02, 1.8154469e-02, 1.1552849e-02, 3.3008089e-03, -6.1300811e-03, -9.1951221e-03, -6.0593496e-02, -9.2658537e-02, -1.7541463e-01, -1.8508130e-01, -1.9309756e-01, -1.9899187e-01, -2.0182114e-01, -2.0582927e-01, -2.0913008e-01, -2.1078049e-01, -2.1007317e-01, -2.0630081e-01, -2.0229268e-01, -1.9828455e-01, -1.8484553e-01, -1.9922764e-01, -1.5584553e-01, -1.9922764e-01};

double butterfly_x[] = {1.4279319e-02, 3.1692034e-10, -1.7654432e-02, -2.5962400e-02, -3.4789615e-02, -4.3876452e-02, -5.1665172e-02, -5.8934642e-02, -6.4646372e-02, -6.9059982e-02, -7.2694722e-02, -7.5031332e-02, -7.6589082e-02, -7.6589082e-02, -7.6848702e-02, -7.6589082e-02, -7.6589082e-02, -7.6589082e-02, -7.6589082e-02, -7.6848702e-02, -7.5290962e-02, -7.2694722e-02, -6.8281112e-02, -6.1790512e-02, -5.3482542e-02, -4.4136082e-02, -3.3491495e-02, -2.5443152e-02, -1.9212176e-02, -1.2981200e-02, -6.2309757e-03, -2.5962368e-04, 1.4538943e-02, 5.8415398e-02, 1.0229185e-01, 1.1709042e-01, 1.3266786e-01, 1.4149508e-01, 1.5213966e-01, 1.6200537e-01, 1.7135184e-01, 1.7888093e-01, 1.8589078e-01, 1.9082364e-01, 1.9290063e-01, 1.9341988e-01, 1.9341988e-01, 1.9341988e-01, 1.9341988e-01, 1.9186213e-01, 1.8822740e-01, 1.8459266e-01, 1.8069830e-01, 1.7602507e-01, 1.6849597e-01, 1.5811101e-01, 1.4928380e-01, 1.3993733e-01, 1.3370636e-01, 1.2981200e-01, 1.1709042e-01, 1.0229185e-01, 5.8415398e-02, 1.4279319e-02};

double butterfly_e_z1[]= {-3.0488e-04,  -5.5017e-02, -3.0488e-04};
double butterfly_e_x1[]= {-4.3103e-04,   5.8521e-02,  1.1701e-01};
double butterfly_e_z2[]= {-1.8501e-01, -1.2719e-01, -1.8501e-01};
double butterfly_e_x2[]= {3.3156e-05,  5.8985e-02,  1.1701e-01};
   


/* Draw the two butterfly shapes at top and bottom level */
magnify("");
double y0;
int j;
double rAx,rAz,rBx,rBz;

for (y0=-delta_y; y0<2*delta_y; y0+=2*delta_y) {
  for (j=0; j<63; j++) {
    
    rAx = r11*(butterfly_z[j]-cz) + r12*(butterfly_x[j]-cx);
    rAz = r21*(butterfly_z[j]-cz) + r22*(butterfly_x[j]-cx);

    rBx = r11*(butterfly_z[j+1]-cz) + r12*(butterfly_x[j+1]-cx);
    rBz = r21*(butterfly_z[j+1]-cz) + r22*(butterfly_x[j+1]-cx);

    line(rAx, y0, rAz, rBx, y0, rBz);

  }
}

/* Draw the "border" between the thermal and cold areas */
for (y0=-delta_y; y0<2*delta_y; y0+=2*delta_y) {
  for (j=0; j<2; j++) {
    
    rAx = r11*(butterfly_e_z1[j]-cz) + r12*(butterfly_e_x1[j]-cx);
    rAz = r21*(butterfly_e_z1[j]-cz) + r22*(butterfly_e_x1[j]-cx);

    rBx = r11*(butterfly_e_z1[j+1]-cz) + r12*(butterfly_e_x1[j+1]-cx);
    rBz = r21*(butterfly_e_z1[j+1]-cz) + r22*(butterfly_e_x1[j+1]-cx);

    line(rAx, y0, rAz, rBx, y0, rBz);

    rAx = r11*(butterfly_e_z2[j]-cz) + r12*(butterfly_e_x2[j]-cx);
    rAz = r21*(butterfly_e_z2[j]-cz) + r22*(butterfly_e_x2[j]-cx);

    rBx = r11*(butterfly_e_z2[j+1]-cz) + r12*(butterfly_e_x2[j+1]-cx);
    rBz = r21*(butterfly_e_z2[j+1]-cz) + r22*(butterfly_e_x2[j+1]-cx);

    line(rAx, y0, rAz, rBx, y0, rBz);
  }
}

/* Indicate the emission planes of cold/thermal moderator */
for (y0=-delta_y; y0<2*delta_y; y0+=2*delta_y) {
  dashed_line(rC1_x, y0, rC1_z, rC2_x, y0, rC2_z, 11);
  dashed_line(rC1_x, y0, rC1_z, rC3_x, y0, rC3_z, 11);
  dashed_line(rT1_x, y0, rT1_z, rT2_x, y0, rT2_z, 11);
  dashed_line(rT1_x, y0, rT1_z, rT3_x, y0, rT3_z, 11);
}
dashed_line(rC1_x, -delta_y, rC1_z, rC1_x, delta_y, rC1_z, 11);
dashed_line(rC2_x, -delta_y, rC2_z, rC2_x, delta_y, rC2_z, 11);
dashed_line(rC3_x, -delta_y, rC3_z, rC3_x, delta_y, rC3_z, 11);
dashed_line(rT1_x, -delta_y, rT1_z, rT1_x, delta_y, rT1_z, 11);
dashed_line(rT2_x, -delta_y, rT2_z, rT2_x, delta_y, rT2_z, 11);
dashed_line(rT3_x, -delta_y, rT3_z, rT3_x, delta_y, rT3_z, 11);


/* Arrow indicating proton beam direction */
double ax,az,bx,bz,bbx,bbz,ccx,ccz;
az = -0.0925-cz;
ax = 0.0585-cx;
bz = -0.0925-cz;
bx = 0.0585+6-cx;
bbx = 0.0585+0.1-cx;
bbz = -0.0925+0.03-cz;
ccx = 0.0585+0.1-cx;
ccz = -0.0925-0.03-cz;
/* rAx,0,rAz is the centre of the moderator */
rAx = r11*(az) + r12*(ax);
rAz = r21*(az) + r22*(ax);
rBx = r11*(bz) + r12*(bx);
rBz = r21*(bz) + r22*(bx);
/* Main part of the arrow */
line(rAx, 0, rAz, rBx, 0, rBz);
/* Inclined lines for arrow head */
rBx = r11*(bbz) + r12*(bbx);
rBz = r21*(bbz) + r22*(bbx);
line(rAx, 0, rAz, rBx, 0, rBz);
rBx = r11*(ccz) + r12*(ccx);
rBz = r21*(ccz) + r22*(ccx);
line(rAx, 0, rAz, rBx, 0, rBz);

/* 120 degree "end of sector" lines */
bbz = 2 * cos(DEG2RAD*61);
bbx = 2 * sin(DEG2RAD*61);
ccz = 2 * cos(-DEG2RAD*61);
ccx = 2 * sin(-DEG2RAD*61);
rBx = r11*(bbz) + r12*(bbx);
rBz = r21*(bbz) + r22*(bbx);
dashed_line(rAx, 0, rAz, rBx+rAx, 0, rBz+rAz,51);
rBx = r11*(ccz) + r12*(ccx);
rBz = r21*(ccz) + r22*(ccx);
dashed_line(rAx, 0, rAz, rBx+rAx, 0, rBz+rAz,51);
bbz = 2 * cos(DEG2RAD*119);
bbx = 2 * sin(DEG2RAD*119);
ccz = 2 * cos(-DEG2RAD*119);
ccx = 2 * sin(-DEG2RAD*119);
rBx = r11*(bbz) + r12*(bbx);
rBz = r21*(bbz) + r22*(bbx);
dashed_line(rAx, 0, rAz, rBx+rAx, 0, rBz+rAz,51);
rBx = r11*(ccz) + r12*(ccx);
rBz = r21*(ccz) + r22*(ccx);
dashed_line(rAx, 0, rAz, rBx+rAx, 0, rBz+rAz,51);
/* Circles indicating extent of the "empty" zone where optics is not allowed */
circle("xz", rAx, 0, rAz, 2.0);
circle("xz", rAx, -0.1, rAz, 2.0);
circle("xz", rAx, 0.1, rAz, 2.0);

/* Circles indicating extent of the target monolith */
circle("xz", rAx, 0, rAz, 5.5);
circle("xz", rAx, -1, rAz, 5.5);
circle("xz", rAx, 1, rAz, 5.5);

/* Beamport "plug" dimensions */
double w1=0.206/2.0, w2=0.276/2.0, l1=2.0+rAz, l2=2.0+rAz+1.75, l3=2.0+rAz+3.5;
line(w1, 0, l1, w1, 0, l2);
line(-w1, 0, l1, -w1, 0, l2);
line(w1, 0, l2, w2, 0, l2);
line(-w1, 0, l2, -w2, 0, l2);
line(w2, 0, l2, w2, 0, l3);
line(-w2, 0, l2, -w2, 0, l3);

/* Draw all the beamlines in "this sector" +1 */
double xx1, yy1, zz1, xx2, yy2, zz2, delta_omega;
for (j=0; j<jmax+1; j++) {
  delta_omega = orientation_angle - Beamlines[j];
  r11 = cos(DEG2RAD*delta_omega);
  r12 = -sin(DEG2RAD*delta_omega);
  r21 = sin(DEG2RAD*delta_omega);
  r22 = cos(DEG2RAD*delta_omega);
  xx1 = r11*(w1) + r12*(l1);
  zz1 = r21*(w1) + r22*(l1);
  xx2 = r11*(w1) + r12*(l2);
  zz2 = r21*(w1) + r22*(l2);
  dashed_line(xx1, 0, zz1, xx2, 0, zz2, 11);
  xx1 = r11*(-w1) + r12*(l1);
  zz1 = r21*(-w1) + r22*(l1);
  xx2 = r11*(-w1) + r12*(l2);
  zz2 = r21*(-w1) + r22*(l2);
  dashed_line(xx1, 0, zz1, xx2, 0, zz2, 11);
  xx1 = r11*(w2) + r12*(l2);
  zz1 = r21*(w2) + r22*(l2);
  xx2 = r11*(w2) + r12*(l3);
  zz2 = r21*(w2) + r22*(l3);
  dashed_line(xx1, 0, zz1, xx2, 0, zz2, 11);
  xx1 = r11*(-w2) + r12*(l2);
  zz1 = r21*(-w2) + r22*(l2);
  xx2 = r11*(-w2) + r12*(l3);
  zz2 = r21*(-w2) + r22*(l3);
  dashed_line(xx1, 0, zz1, xx2, 0, zz2, 11);
}

/* Show instrument axis... */
dashed_line(0,0,0,0,0,2+rAz,21);

/* Draw up the "focusing rectangle" */ 
/* Horizontal direction vector @ focusing area */
vec_prod(xx1,yy1,zz1,tx,ty,tz,0.0,1.0,0.0);
NORM(xx1,yy1,zz1);
vec_prod(xx2,yy2,zz2,tx,ty,tz,xx1,yy1,zz1);
NORM(xx2,yy2,zz2);
xx1*=focus_xw/2.0; yy1*=focus_xw/2.0; zz1*=focus_xw/2.0;
xx2*=focus_yh/2.0; yy2*=focus_yh/2.0; zz2*=focus_yh/2.0;
printf("Normal vectors pointing in directions\n %g %g %g and \n %g %g %g \n",xx1,yy1,zz1,xx2,yy2,zz2);
dashed_line(tx -xx1 -xx2, ty -yy1 -yy2, tz -zz1 -zz2,
	    tx +xx1 -xx2, ty +yy1 -yy2, tz +zz1 -zz2,5);
dashed_line(tx -xx1 +xx2, ty -yy1 +yy2, tz -zz1 +zz2,
	    tx +xx1 +xx2, ty +yy1 +yy2, tz +zz1 +zz2,5);

dashed_line(tx -xx1 -xx2, ty -yy1 -yy2, tz -zz1 -zz2,
	    tx -xx1 +xx2, ty -yy1 +yy2, tz -zz1 +zz2,5);
dashed_line(tx +xx1 -xx2, ty +yy1 -yy2, tz +zz1 -zz2,
	    tx +xx1 +xx2, ty +yy1 +yy2, tz +zz1 +zz2,5);

}
#line 65142 "./ESS_BIFROST_shielding.c"
}   /* End of ESS_source=ESS_butterfly() SETTING parameter declarations. */
#undef Lmax_sampled
#undef Lmin_sampled
#undef cos_cold
#undef cos_thermal
#undef sin_beamport_angle
#undef cos_beamport_angle
#undef z0
#undef x0
#undef internal_angle
#undef dz
#undef dy
#undef dx
#undef r
#undef v
#undef k
#undef l_range
#undef lambda
#undef dt
#undef tz
#undef ty
#undef tx
#undef w_geom_t
#undef w_geom_c
#undef w_tfocus
#undef w_focus
#undef w_geom
#undef w_stat
#undef w_mult
#undef zf
#undef yf
#undef xf
#undef r22
#undef r21
#undef r12
#undef r11
#undef tz
#undef ty
#undef tx
#undef rT3_z
#undef rT3_x
#undef rT2_z
#undef rT2_x
#undef rT1_z
#undef rT1_x
#undef rC3_z
#undef rC3_x
#undef rC2_z
#undef rC2_x
#undef rC1_z
#undef rC1_x
#undef T3_z
#undef T3_x
#undef T2_z
#undef T2_x
#undef T1_z
#undef T1_x
#undef C3_z
#undef C3_x
#undef C2_z
#undef C2_x
#undef C1_z
#undef C1_x
#undef jmax
#undef orientation_angle
#undef sign_bl_angle
#undef cz
#undef cx
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'StartOfGuide'. */
  SIG_MESSAGE("StartOfGuide (McDisplay)");
  printf("MCDISPLAY: component %s\n", "StartOfGuide");
#define mccompcurname  StartOfGuide
#define mccompcurtype  Arm
#define mccompcurindex 3
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 65229 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'NBOA'. */
  SIG_MESSAGE("NBOA (McDisplay)");
  printf("MCDISPLAY: component %s\n", "NBOA");
#define mccompcurname  NBOA
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 4
#define mvaluesright mccNBOA_mvaluesright
#define mvaluesleft mccNBOA_mvaluesleft
#define mvaluestop mccNBOA_mvaluestop
#define mvaluesbottom mccNBOA_mvaluesbottom
#define seglength mccNBOA_seglength
#define guideInfo mccNBOA_guideInfo
#define latestParticleCollision mccNBOA_latestParticleCollision
#define Gx mccNBOA_Gx
#define Gy mccNBOA_Gy
#define Gz mccNBOA_Gz
#define Gx0 mccNBOA_Gx0
#define Gy0 mccNBOA_Gy0
#define Gz0 mccNBOA_Gz0
#define Circ mccNBOA_Circ
#define dynamicalSegLength mccNBOA_dynamicalSegLength
{   /* Declarations of NBOA=Elliptic_guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM l = mccNBOA_l;
MCNUM xwidth = mccNBOA_xwidth;
MCNUM yheight = mccNBOA_yheight;
MCNUM linxw = mccNBOA_linxw;
MCNUM loutxw = mccNBOA_loutxw;
MCNUM linyh = mccNBOA_linyh;
MCNUM loutyh = mccNBOA_loutyh;
MCNUM majorAxisxw = mccNBOA_majorAxisxw;
MCNUM minorAxisxw = mccNBOA_minorAxisxw;
MCNUM majorAxisyh = mccNBOA_majorAxisyh;
MCNUM minorAxisyh = mccNBOA_minorAxisyh;
MCNUM majorAxisoffsetxw = mccNBOA_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccNBOA_majorAxisoffsetyh;
char* dimensionsAt = mccNBOA_dimensionsAt;
char* option = mccNBOA_option;
MCNUM R0 = mccNBOA_R0;
MCNUM Qc = mccNBOA_Qc;
MCNUM alpha = mccNBOA_alpha;
MCNUM m = mccNBOA_m;
MCNUM W = mccNBOA_W;
MCNUM alpharight = mccNBOA_alpharight;
MCNUM mright = mccNBOA_mright;
MCNUM alphaleft = mccNBOA_alphaleft;
MCNUM mleft = mccNBOA_mleft;
MCNUM alphatop = mccNBOA_alphatop;
MCNUM mtop = mccNBOA_mtop;
MCNUM alphabottom = mccNBOA_alphabottom;
MCNUM mbottom = mccNBOA_mbottom;
char* verbose = mccNBOA_verbose;
MCNUM enableGravity = mccNBOA_enableGravity;
MCNUM curvature = mccNBOA_curvature;
#line 1538 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
{


	// Calculate the points need to draw approximation of the ellipses
	// defining the guide 

	// the number of lines used to draw one side of the guide
	int ApproximationMirrors = 500; 

	// The start of the guide
	double zvalue=0;

	// The the different in z between point used to draw the ellipse
	double zdelta = guideInfo.Length/(1.0*ApproximationMirrors);

	// The vector used to store the points defining the lines
	double xplus[ApproximationMirrors+1];
	double xminus[ApproximationMirrors+1];
	double yplus[ApproximationMirrors+1];
	double yminus[ApproximationMirrors+1];

	// Temperary values for the loop
	double tempx;
	double tempy;

	/*
		Calculate the second coordinates to the points on the ellipse with z_i 
		as the first coordinate. We transform the point to the coordinate system 
		there the ellipse is a unit circle. And use the defination of this circle 
		to find second coordinate (x^2+z^2 = 1)
	*/

	/////////////////////////////////////////////////////////
	double Length;
	double entranceHorizontalWidth;
	double entranceVerticalWidth;	
	
	// ellipses infomation
	double ellipseMajorAxis[4],		ellipseMinorAxis[4];
	double ellipseMajorOffset[4],	ellipseMinorOffset[4];

	enum Side {RightSide,TopSide,LeftSide,BottomSide,None};
	/////////////////////////////////////////////////////////

	int i = 0;
	double tempz = 0;
	for(i=0;i<ApproximationMirrors+1;i++){
		
		tempx = sqrt(
			guideInfo.ellipseMinorAxis[RightSide]
			*guideInfo.ellipseMinorAxis[RightSide]
			-(	guideInfo.ellipseMinorAxis[RightSide]
				*guideInfo.ellipseMinorAxis[RightSide] )
			/(	guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
		);

		xplus[i] =  tempx + guideInfo.ellipseMinorOffset[RightSide];
		xminus[i]= -tempx + guideInfo.ellipseMinorOffset[RightSide];
		
		tempy = sqrt(
			guideInfo.ellipseMinorAxis[TopSide]
			*guideInfo.ellipseMinorAxis[TopSide]
			-(	guideInfo.ellipseMinorAxis[TopSide]
				*guideInfo.ellipseMinorAxis[TopSide] )
			/(	guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
		);
		
		yplus[i] =  tempy + guideInfo.ellipseMinorOffset[TopSide];
		yminus[i]= -tempy + guideInfo.ellipseMinorOffset[TopSide];
	}

	///// Draw lines

	// Drawing lines orthogonal with the z direction.
	// at both ends of the guide and at the boardest place at the guide

	// These may not give correct result if one of the ends are closed

	int j=0;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 	  , yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta,xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j],0 		, zvalue+j*zdelta);
			
	j=ApproximationMirrors;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j],zvalue+j*zdelta,xminus[j] , yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	    , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		 , zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j], 0 		 , zvalue+j*zdelta);

			  
			  
	// find boardest place on the guide and draw a band around the guide
	int m0;
	double boardestPlace = 0;
	int boardestPlaceNumber = 0;
	for(m0=0; m0<ApproximationMirrors; m0++){
		if( boardestPlace <= fabs(yplus[m0]) ){
			boardestPlace = fabs(yplus[m0]);
			boardestPlaceNumber = m0;
		}
	}
	j = boardestPlaceNumber;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta, xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta, xplus[j], 0 		 , zvalue+j*zdelta);


			  
	// Drawing lines parallel with the z direction
			  
	int k=0;
	for(k=0; k < ApproximationMirrors; k++){
		
		line( xplus[k], yplus[k], zvalue+k*zdelta,xplus[k+1], yplus[k+1], zvalue+(k+1)*zdelta);
		line( xminus[k],yplus[k], zvalue+k*zdelta,xminus[k+1],yplus[k+1], zvalue+(k+1)*zdelta);
		
		line( xplus[k], yminus[k],zvalue+k*zdelta,xplus[k+1], yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],yminus[k],zvalue+k*zdelta,xminus[k+1],yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],0 		, zvalue+k*zdelta, xminus[k+1],0 	, zvalue+(k+1)*zdelta);
		line( xplus[k], 0 		, zvalue+k*zdelta, xplus[k+1], 0 	, zvalue+(k+1)*zdelta);
		
		line( 0 	, yminus[k],  zvalue+k*zdelta, 0 	  	,yminus[k+1],zvalue+(k+1)*zdelta);
		line( 0 	,yplus[k]  , zvalue+k*zdelta , 0 		,yplus[k] , zvalue+(k+1)*zdelta);
		
		}

		if(guideInfo.EnclosingBoxOn){
			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );

			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );
			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
		}
}
#line 65477 "./ESS_BIFROST_shielding.c"
}   /* End of NBOA=Elliptic_guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'EndOfelement_6'. */
  SIG_MESSAGE("EndOfelement_6 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "EndOfelement_6");
#define mccompcurname  EndOfelement_6
#define mccompcurtype  Arm
#define mccompcurindex 5
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 65512 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'EndOfelement_5'. */
  SIG_MESSAGE("EndOfelement_5 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "EndOfelement_5");
#define mccompcurname  EndOfelement_5
#define mccompcurtype  Arm
#define mccompcurindex 6
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 65531 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_1_0'. */
  SIG_MESSAGE("curved_guide_1_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_1_0");
#define mccompcurname  curved_guide_1_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 7
#define GVars mcccurved_guide_1_0_GVars
#define pTable mcccurved_guide_1_0_pTable
{   /* Declarations of curved_guide_1_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_1_0_w1;
MCNUM h1 = mcccurved_guide_1_0_h1;
MCNUM w2 = mcccurved_guide_1_0_w2;
MCNUM h2 = mcccurved_guide_1_0_h2;
MCNUM l = mcccurved_guide_1_0_l;
MCNUM R0 = mcccurved_guide_1_0_R0;
MCNUM Qc = mcccurved_guide_1_0_Qc;
MCNUM alpha = mcccurved_guide_1_0_alpha;
MCNUM m = mcccurved_guide_1_0_m;
MCNUM W = mcccurved_guide_1_0_W;
MCNUM nslit = mcccurved_guide_1_0_nslit;
MCNUM d = mcccurved_guide_1_0_d;
MCNUM mleft = mcccurved_guide_1_0_mleft;
MCNUM mright = mcccurved_guide_1_0_mright;
MCNUM mtop = mcccurved_guide_1_0_mtop;
MCNUM mbottom = mcccurved_guide_1_0_mbottom;
MCNUM nhslit = mcccurved_guide_1_0_nhslit;
MCNUM G = mcccurved_guide_1_0_G;
MCNUM aleft = mcccurved_guide_1_0_aleft;
MCNUM aright = mcccurved_guide_1_0_aright;
MCNUM atop = mcccurved_guide_1_0_atop;
MCNUM abottom = mcccurved_guide_1_0_abottom;
MCNUM wavy = mcccurved_guide_1_0_wavy;
MCNUM wavy_z = mcccurved_guide_1_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_1_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_1_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_1_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_1_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_1_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_1_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_1_0_nelements;
MCNUM nu = mcccurved_guide_1_0_nu;
MCNUM phase = mcccurved_guide_1_0_phase;
char* reflect = mcccurved_guide_1_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 65642 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_1_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_2_0'. */
  SIG_MESSAGE("curved_guide_2_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_2_0");
#define mccompcurname  curved_guide_2_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 8
#define GVars mcccurved_guide_2_0_GVars
#define pTable mcccurved_guide_2_0_pTable
{   /* Declarations of curved_guide_2_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_2_0_w1;
MCNUM h1 = mcccurved_guide_2_0_h1;
MCNUM w2 = mcccurved_guide_2_0_w2;
MCNUM h2 = mcccurved_guide_2_0_h2;
MCNUM l = mcccurved_guide_2_0_l;
MCNUM R0 = mcccurved_guide_2_0_R0;
MCNUM Qc = mcccurved_guide_2_0_Qc;
MCNUM alpha = mcccurved_guide_2_0_alpha;
MCNUM m = mcccurved_guide_2_0_m;
MCNUM W = mcccurved_guide_2_0_W;
MCNUM nslit = mcccurved_guide_2_0_nslit;
MCNUM d = mcccurved_guide_2_0_d;
MCNUM mleft = mcccurved_guide_2_0_mleft;
MCNUM mright = mcccurved_guide_2_0_mright;
MCNUM mtop = mcccurved_guide_2_0_mtop;
MCNUM mbottom = mcccurved_guide_2_0_mbottom;
MCNUM nhslit = mcccurved_guide_2_0_nhslit;
MCNUM G = mcccurved_guide_2_0_G;
MCNUM aleft = mcccurved_guide_2_0_aleft;
MCNUM aright = mcccurved_guide_2_0_aright;
MCNUM atop = mcccurved_guide_2_0_atop;
MCNUM abottom = mcccurved_guide_2_0_abottom;
MCNUM wavy = mcccurved_guide_2_0_wavy;
MCNUM wavy_z = mcccurved_guide_2_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_2_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_2_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_2_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_2_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_2_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_2_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_2_0_nelements;
MCNUM nu = mcccurved_guide_2_0_nu;
MCNUM phase = mcccurved_guide_2_0_phase;
char* reflect = mcccurved_guide_2_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 65756 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_2_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_3_0'. */
  SIG_MESSAGE("curved_guide_3_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_3_0");
#define mccompcurname  curved_guide_3_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 9
#define GVars mcccurved_guide_3_0_GVars
#define pTable mcccurved_guide_3_0_pTable
{   /* Declarations of curved_guide_3_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_3_0_w1;
MCNUM h1 = mcccurved_guide_3_0_h1;
MCNUM w2 = mcccurved_guide_3_0_w2;
MCNUM h2 = mcccurved_guide_3_0_h2;
MCNUM l = mcccurved_guide_3_0_l;
MCNUM R0 = mcccurved_guide_3_0_R0;
MCNUM Qc = mcccurved_guide_3_0_Qc;
MCNUM alpha = mcccurved_guide_3_0_alpha;
MCNUM m = mcccurved_guide_3_0_m;
MCNUM W = mcccurved_guide_3_0_W;
MCNUM nslit = mcccurved_guide_3_0_nslit;
MCNUM d = mcccurved_guide_3_0_d;
MCNUM mleft = mcccurved_guide_3_0_mleft;
MCNUM mright = mcccurved_guide_3_0_mright;
MCNUM mtop = mcccurved_guide_3_0_mtop;
MCNUM mbottom = mcccurved_guide_3_0_mbottom;
MCNUM nhslit = mcccurved_guide_3_0_nhslit;
MCNUM G = mcccurved_guide_3_0_G;
MCNUM aleft = mcccurved_guide_3_0_aleft;
MCNUM aright = mcccurved_guide_3_0_aright;
MCNUM atop = mcccurved_guide_3_0_atop;
MCNUM abottom = mcccurved_guide_3_0_abottom;
MCNUM wavy = mcccurved_guide_3_0_wavy;
MCNUM wavy_z = mcccurved_guide_3_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_3_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_3_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_3_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_3_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_3_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_3_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_3_0_nelements;
MCNUM nu = mcccurved_guide_3_0_nu;
MCNUM phase = mcccurved_guide_3_0_phase;
char* reflect = mcccurved_guide_3_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 65870 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_3_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_4_0'. */
  SIG_MESSAGE("curved_guide_4_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_4_0");
#define mccompcurname  curved_guide_4_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 10
#define GVars mcccurved_guide_4_0_GVars
#define pTable mcccurved_guide_4_0_pTable
{   /* Declarations of curved_guide_4_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_4_0_w1;
MCNUM h1 = mcccurved_guide_4_0_h1;
MCNUM w2 = mcccurved_guide_4_0_w2;
MCNUM h2 = mcccurved_guide_4_0_h2;
MCNUM l = mcccurved_guide_4_0_l;
MCNUM R0 = mcccurved_guide_4_0_R0;
MCNUM Qc = mcccurved_guide_4_0_Qc;
MCNUM alpha = mcccurved_guide_4_0_alpha;
MCNUM m = mcccurved_guide_4_0_m;
MCNUM W = mcccurved_guide_4_0_W;
MCNUM nslit = mcccurved_guide_4_0_nslit;
MCNUM d = mcccurved_guide_4_0_d;
MCNUM mleft = mcccurved_guide_4_0_mleft;
MCNUM mright = mcccurved_guide_4_0_mright;
MCNUM mtop = mcccurved_guide_4_0_mtop;
MCNUM mbottom = mcccurved_guide_4_0_mbottom;
MCNUM nhslit = mcccurved_guide_4_0_nhslit;
MCNUM G = mcccurved_guide_4_0_G;
MCNUM aleft = mcccurved_guide_4_0_aleft;
MCNUM aright = mcccurved_guide_4_0_aright;
MCNUM atop = mcccurved_guide_4_0_atop;
MCNUM abottom = mcccurved_guide_4_0_abottom;
MCNUM wavy = mcccurved_guide_4_0_wavy;
MCNUM wavy_z = mcccurved_guide_4_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_4_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_4_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_4_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_4_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_4_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_4_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_4_0_nelements;
MCNUM nu = mcccurved_guide_4_0_nu;
MCNUM phase = mcccurved_guide_4_0_phase;
char* reflect = mcccurved_guide_4_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 65984 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_4_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_5_beforeChopper'. */
  SIG_MESSAGE("curved_guide_5_beforeChopper (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_5_beforeChopper");
#define mccompcurname  curved_guide_5_beforeChopper
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 11
#define GVars mcccurved_guide_5_beforeChopper_GVars
#define pTable mcccurved_guide_5_beforeChopper_pTable
{   /* Declarations of curved_guide_5_beforeChopper=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_5_beforeChopper_w1;
MCNUM h1 = mcccurved_guide_5_beforeChopper_h1;
MCNUM w2 = mcccurved_guide_5_beforeChopper_w2;
MCNUM h2 = mcccurved_guide_5_beforeChopper_h2;
MCNUM l = mcccurved_guide_5_beforeChopper_l;
MCNUM R0 = mcccurved_guide_5_beforeChopper_R0;
MCNUM Qc = mcccurved_guide_5_beforeChopper_Qc;
MCNUM alpha = mcccurved_guide_5_beforeChopper_alpha;
MCNUM m = mcccurved_guide_5_beforeChopper_m;
MCNUM W = mcccurved_guide_5_beforeChopper_W;
MCNUM nslit = mcccurved_guide_5_beforeChopper_nslit;
MCNUM d = mcccurved_guide_5_beforeChopper_d;
MCNUM mleft = mcccurved_guide_5_beforeChopper_mleft;
MCNUM mright = mcccurved_guide_5_beforeChopper_mright;
MCNUM mtop = mcccurved_guide_5_beforeChopper_mtop;
MCNUM mbottom = mcccurved_guide_5_beforeChopper_mbottom;
MCNUM nhslit = mcccurved_guide_5_beforeChopper_nhslit;
MCNUM G = mcccurved_guide_5_beforeChopper_G;
MCNUM aleft = mcccurved_guide_5_beforeChopper_aleft;
MCNUM aright = mcccurved_guide_5_beforeChopper_aright;
MCNUM atop = mcccurved_guide_5_beforeChopper_atop;
MCNUM abottom = mcccurved_guide_5_beforeChopper_abottom;
MCNUM wavy = mcccurved_guide_5_beforeChopper_wavy;
MCNUM wavy_z = mcccurved_guide_5_beforeChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_5_beforeChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_5_beforeChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_5_beforeChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_5_beforeChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_5_beforeChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_5_beforeChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_5_beforeChopper_nelements;
MCNUM nu = mcccurved_guide_5_beforeChopper_nu;
MCNUM phase = mcccurved_guide_5_beforeChopper_phase;
char* reflect = mcccurved_guide_5_beforeChopper_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 66098 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_5_beforeChopper=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_5_afterChopper'. */
  SIG_MESSAGE("curved_guide_5_afterChopper (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_5_afterChopper");
#define mccompcurname  curved_guide_5_afterChopper
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 12
#define GVars mcccurved_guide_5_afterChopper_GVars
#define pTable mcccurved_guide_5_afterChopper_pTable
{   /* Declarations of curved_guide_5_afterChopper=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_5_afterChopper_w1;
MCNUM h1 = mcccurved_guide_5_afterChopper_h1;
MCNUM w2 = mcccurved_guide_5_afterChopper_w2;
MCNUM h2 = mcccurved_guide_5_afterChopper_h2;
MCNUM l = mcccurved_guide_5_afterChopper_l;
MCNUM R0 = mcccurved_guide_5_afterChopper_R0;
MCNUM Qc = mcccurved_guide_5_afterChopper_Qc;
MCNUM alpha = mcccurved_guide_5_afterChopper_alpha;
MCNUM m = mcccurved_guide_5_afterChopper_m;
MCNUM W = mcccurved_guide_5_afterChopper_W;
MCNUM nslit = mcccurved_guide_5_afterChopper_nslit;
MCNUM d = mcccurved_guide_5_afterChopper_d;
MCNUM mleft = mcccurved_guide_5_afterChopper_mleft;
MCNUM mright = mcccurved_guide_5_afterChopper_mright;
MCNUM mtop = mcccurved_guide_5_afterChopper_mtop;
MCNUM mbottom = mcccurved_guide_5_afterChopper_mbottom;
MCNUM nhslit = mcccurved_guide_5_afterChopper_nhslit;
MCNUM G = mcccurved_guide_5_afterChopper_G;
MCNUM aleft = mcccurved_guide_5_afterChopper_aleft;
MCNUM aright = mcccurved_guide_5_afterChopper_aright;
MCNUM atop = mcccurved_guide_5_afterChopper_atop;
MCNUM abottom = mcccurved_guide_5_afterChopper_abottom;
MCNUM wavy = mcccurved_guide_5_afterChopper_wavy;
MCNUM wavy_z = mcccurved_guide_5_afterChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_5_afterChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_5_afterChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_5_afterChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_5_afterChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_5_afterChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_5_afterChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_5_afterChopper_nelements;
MCNUM nu = mcccurved_guide_5_afterChopper_nu;
MCNUM phase = mcccurved_guide_5_afterChopper_phase;
char* reflect = mcccurved_guide_5_afterChopper_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 66212 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_5_afterChopper=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_6_0'. */
  SIG_MESSAGE("curved_guide_6_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_6_0");
#define mccompcurname  curved_guide_6_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 13
#define GVars mcccurved_guide_6_0_GVars
#define pTable mcccurved_guide_6_0_pTable
{   /* Declarations of curved_guide_6_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_6_0_w1;
MCNUM h1 = mcccurved_guide_6_0_h1;
MCNUM w2 = mcccurved_guide_6_0_w2;
MCNUM h2 = mcccurved_guide_6_0_h2;
MCNUM l = mcccurved_guide_6_0_l;
MCNUM R0 = mcccurved_guide_6_0_R0;
MCNUM Qc = mcccurved_guide_6_0_Qc;
MCNUM alpha = mcccurved_guide_6_0_alpha;
MCNUM m = mcccurved_guide_6_0_m;
MCNUM W = mcccurved_guide_6_0_W;
MCNUM nslit = mcccurved_guide_6_0_nslit;
MCNUM d = mcccurved_guide_6_0_d;
MCNUM mleft = mcccurved_guide_6_0_mleft;
MCNUM mright = mcccurved_guide_6_0_mright;
MCNUM mtop = mcccurved_guide_6_0_mtop;
MCNUM mbottom = mcccurved_guide_6_0_mbottom;
MCNUM nhslit = mcccurved_guide_6_0_nhslit;
MCNUM G = mcccurved_guide_6_0_G;
MCNUM aleft = mcccurved_guide_6_0_aleft;
MCNUM aright = mcccurved_guide_6_0_aright;
MCNUM atop = mcccurved_guide_6_0_atop;
MCNUM abottom = mcccurved_guide_6_0_abottom;
MCNUM wavy = mcccurved_guide_6_0_wavy;
MCNUM wavy_z = mcccurved_guide_6_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_6_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_6_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_6_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_6_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_6_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_6_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_6_0_nelements;
MCNUM nu = mcccurved_guide_6_0_nu;
MCNUM phase = mcccurved_guide_6_0_phase;
char* reflect = mcccurved_guide_6_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 66326 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_6_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_7_0'. */
  SIG_MESSAGE("curved_guide_7_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_7_0");
#define mccompcurname  curved_guide_7_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 14
#define GVars mcccurved_guide_7_0_GVars
#define pTable mcccurved_guide_7_0_pTable
{   /* Declarations of curved_guide_7_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_7_0_w1;
MCNUM h1 = mcccurved_guide_7_0_h1;
MCNUM w2 = mcccurved_guide_7_0_w2;
MCNUM h2 = mcccurved_guide_7_0_h2;
MCNUM l = mcccurved_guide_7_0_l;
MCNUM R0 = mcccurved_guide_7_0_R0;
MCNUM Qc = mcccurved_guide_7_0_Qc;
MCNUM alpha = mcccurved_guide_7_0_alpha;
MCNUM m = mcccurved_guide_7_0_m;
MCNUM W = mcccurved_guide_7_0_W;
MCNUM nslit = mcccurved_guide_7_0_nslit;
MCNUM d = mcccurved_guide_7_0_d;
MCNUM mleft = mcccurved_guide_7_0_mleft;
MCNUM mright = mcccurved_guide_7_0_mright;
MCNUM mtop = mcccurved_guide_7_0_mtop;
MCNUM mbottom = mcccurved_guide_7_0_mbottom;
MCNUM nhslit = mcccurved_guide_7_0_nhslit;
MCNUM G = mcccurved_guide_7_0_G;
MCNUM aleft = mcccurved_guide_7_0_aleft;
MCNUM aright = mcccurved_guide_7_0_aright;
MCNUM atop = mcccurved_guide_7_0_atop;
MCNUM abottom = mcccurved_guide_7_0_abottom;
MCNUM wavy = mcccurved_guide_7_0_wavy;
MCNUM wavy_z = mcccurved_guide_7_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_7_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_7_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_7_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_7_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_7_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_7_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_7_0_nelements;
MCNUM nu = mcccurved_guide_7_0_nu;
MCNUM phase = mcccurved_guide_7_0_phase;
char* reflect = mcccurved_guide_7_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 66440 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_7_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_8_0'. */
  SIG_MESSAGE("curved_guide_8_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_8_0");
#define mccompcurname  curved_guide_8_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 15
#define GVars mcccurved_guide_8_0_GVars
#define pTable mcccurved_guide_8_0_pTable
{   /* Declarations of curved_guide_8_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_8_0_w1;
MCNUM h1 = mcccurved_guide_8_0_h1;
MCNUM w2 = mcccurved_guide_8_0_w2;
MCNUM h2 = mcccurved_guide_8_0_h2;
MCNUM l = mcccurved_guide_8_0_l;
MCNUM R0 = mcccurved_guide_8_0_R0;
MCNUM Qc = mcccurved_guide_8_0_Qc;
MCNUM alpha = mcccurved_guide_8_0_alpha;
MCNUM m = mcccurved_guide_8_0_m;
MCNUM W = mcccurved_guide_8_0_W;
MCNUM nslit = mcccurved_guide_8_0_nslit;
MCNUM d = mcccurved_guide_8_0_d;
MCNUM mleft = mcccurved_guide_8_0_mleft;
MCNUM mright = mcccurved_guide_8_0_mright;
MCNUM mtop = mcccurved_guide_8_0_mtop;
MCNUM mbottom = mcccurved_guide_8_0_mbottom;
MCNUM nhslit = mcccurved_guide_8_0_nhslit;
MCNUM G = mcccurved_guide_8_0_G;
MCNUM aleft = mcccurved_guide_8_0_aleft;
MCNUM aright = mcccurved_guide_8_0_aright;
MCNUM atop = mcccurved_guide_8_0_atop;
MCNUM abottom = mcccurved_guide_8_0_abottom;
MCNUM wavy = mcccurved_guide_8_0_wavy;
MCNUM wavy_z = mcccurved_guide_8_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_8_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_8_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_8_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_8_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_8_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_8_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_8_0_nelements;
MCNUM nu = mcccurved_guide_8_0_nu;
MCNUM phase = mcccurved_guide_8_0_phase;
char* reflect = mcccurved_guide_8_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 66554 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_8_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_9_0'. */
  SIG_MESSAGE("curved_guide_9_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_9_0");
#define mccompcurname  curved_guide_9_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 16
#define GVars mcccurved_guide_9_0_GVars
#define pTable mcccurved_guide_9_0_pTable
{   /* Declarations of curved_guide_9_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_9_0_w1;
MCNUM h1 = mcccurved_guide_9_0_h1;
MCNUM w2 = mcccurved_guide_9_0_w2;
MCNUM h2 = mcccurved_guide_9_0_h2;
MCNUM l = mcccurved_guide_9_0_l;
MCNUM R0 = mcccurved_guide_9_0_R0;
MCNUM Qc = mcccurved_guide_9_0_Qc;
MCNUM alpha = mcccurved_guide_9_0_alpha;
MCNUM m = mcccurved_guide_9_0_m;
MCNUM W = mcccurved_guide_9_0_W;
MCNUM nslit = mcccurved_guide_9_0_nslit;
MCNUM d = mcccurved_guide_9_0_d;
MCNUM mleft = mcccurved_guide_9_0_mleft;
MCNUM mright = mcccurved_guide_9_0_mright;
MCNUM mtop = mcccurved_guide_9_0_mtop;
MCNUM mbottom = mcccurved_guide_9_0_mbottom;
MCNUM nhslit = mcccurved_guide_9_0_nhslit;
MCNUM G = mcccurved_guide_9_0_G;
MCNUM aleft = mcccurved_guide_9_0_aleft;
MCNUM aright = mcccurved_guide_9_0_aright;
MCNUM atop = mcccurved_guide_9_0_atop;
MCNUM abottom = mcccurved_guide_9_0_abottom;
MCNUM wavy = mcccurved_guide_9_0_wavy;
MCNUM wavy_z = mcccurved_guide_9_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_9_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_9_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_9_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_9_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_9_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_9_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_9_0_nelements;
MCNUM nu = mcccurved_guide_9_0_nu;
MCNUM phase = mcccurved_guide_9_0_phase;
char* reflect = mcccurved_guide_9_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 66668 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_9_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_10_0'. */
  SIG_MESSAGE("curved_guide_10_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_10_0");
#define mccompcurname  curved_guide_10_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 17
#define GVars mcccurved_guide_10_0_GVars
#define pTable mcccurved_guide_10_0_pTable
{   /* Declarations of curved_guide_10_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_10_0_w1;
MCNUM h1 = mcccurved_guide_10_0_h1;
MCNUM w2 = mcccurved_guide_10_0_w2;
MCNUM h2 = mcccurved_guide_10_0_h2;
MCNUM l = mcccurved_guide_10_0_l;
MCNUM R0 = mcccurved_guide_10_0_R0;
MCNUM Qc = mcccurved_guide_10_0_Qc;
MCNUM alpha = mcccurved_guide_10_0_alpha;
MCNUM m = mcccurved_guide_10_0_m;
MCNUM W = mcccurved_guide_10_0_W;
MCNUM nslit = mcccurved_guide_10_0_nslit;
MCNUM d = mcccurved_guide_10_0_d;
MCNUM mleft = mcccurved_guide_10_0_mleft;
MCNUM mright = mcccurved_guide_10_0_mright;
MCNUM mtop = mcccurved_guide_10_0_mtop;
MCNUM mbottom = mcccurved_guide_10_0_mbottom;
MCNUM nhslit = mcccurved_guide_10_0_nhslit;
MCNUM G = mcccurved_guide_10_0_G;
MCNUM aleft = mcccurved_guide_10_0_aleft;
MCNUM aright = mcccurved_guide_10_0_aright;
MCNUM atop = mcccurved_guide_10_0_atop;
MCNUM abottom = mcccurved_guide_10_0_abottom;
MCNUM wavy = mcccurved_guide_10_0_wavy;
MCNUM wavy_z = mcccurved_guide_10_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_10_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_10_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_10_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_10_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_10_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_10_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_10_0_nelements;
MCNUM nu = mcccurved_guide_10_0_nu;
MCNUM phase = mcccurved_guide_10_0_phase;
char* reflect = mcccurved_guide_10_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 66782 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_10_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_11_0'. */
  SIG_MESSAGE("curved_guide_11_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_11_0");
#define mccompcurname  curved_guide_11_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 18
#define GVars mcccurved_guide_11_0_GVars
#define pTable mcccurved_guide_11_0_pTable
{   /* Declarations of curved_guide_11_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_11_0_w1;
MCNUM h1 = mcccurved_guide_11_0_h1;
MCNUM w2 = mcccurved_guide_11_0_w2;
MCNUM h2 = mcccurved_guide_11_0_h2;
MCNUM l = mcccurved_guide_11_0_l;
MCNUM R0 = mcccurved_guide_11_0_R0;
MCNUM Qc = mcccurved_guide_11_0_Qc;
MCNUM alpha = mcccurved_guide_11_0_alpha;
MCNUM m = mcccurved_guide_11_0_m;
MCNUM W = mcccurved_guide_11_0_W;
MCNUM nslit = mcccurved_guide_11_0_nslit;
MCNUM d = mcccurved_guide_11_0_d;
MCNUM mleft = mcccurved_guide_11_0_mleft;
MCNUM mright = mcccurved_guide_11_0_mright;
MCNUM mtop = mcccurved_guide_11_0_mtop;
MCNUM mbottom = mcccurved_guide_11_0_mbottom;
MCNUM nhslit = mcccurved_guide_11_0_nhslit;
MCNUM G = mcccurved_guide_11_0_G;
MCNUM aleft = mcccurved_guide_11_0_aleft;
MCNUM aright = mcccurved_guide_11_0_aright;
MCNUM atop = mcccurved_guide_11_0_atop;
MCNUM abottom = mcccurved_guide_11_0_abottom;
MCNUM wavy = mcccurved_guide_11_0_wavy;
MCNUM wavy_z = mcccurved_guide_11_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_11_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_11_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_11_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_11_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_11_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_11_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_11_0_nelements;
MCNUM nu = mcccurved_guide_11_0_nu;
MCNUM phase = mcccurved_guide_11_0_phase;
char* reflect = mcccurved_guide_11_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 66896 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_11_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_12_0'. */
  SIG_MESSAGE("curved_guide_12_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_12_0");
#define mccompcurname  curved_guide_12_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 19
#define GVars mcccurved_guide_12_0_GVars
#define pTable mcccurved_guide_12_0_pTable
{   /* Declarations of curved_guide_12_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_12_0_w1;
MCNUM h1 = mcccurved_guide_12_0_h1;
MCNUM w2 = mcccurved_guide_12_0_w2;
MCNUM h2 = mcccurved_guide_12_0_h2;
MCNUM l = mcccurved_guide_12_0_l;
MCNUM R0 = mcccurved_guide_12_0_R0;
MCNUM Qc = mcccurved_guide_12_0_Qc;
MCNUM alpha = mcccurved_guide_12_0_alpha;
MCNUM m = mcccurved_guide_12_0_m;
MCNUM W = mcccurved_guide_12_0_W;
MCNUM nslit = mcccurved_guide_12_0_nslit;
MCNUM d = mcccurved_guide_12_0_d;
MCNUM mleft = mcccurved_guide_12_0_mleft;
MCNUM mright = mcccurved_guide_12_0_mright;
MCNUM mtop = mcccurved_guide_12_0_mtop;
MCNUM mbottom = mcccurved_guide_12_0_mbottom;
MCNUM nhslit = mcccurved_guide_12_0_nhslit;
MCNUM G = mcccurved_guide_12_0_G;
MCNUM aleft = mcccurved_guide_12_0_aleft;
MCNUM aright = mcccurved_guide_12_0_aright;
MCNUM atop = mcccurved_guide_12_0_atop;
MCNUM abottom = mcccurved_guide_12_0_abottom;
MCNUM wavy = mcccurved_guide_12_0_wavy;
MCNUM wavy_z = mcccurved_guide_12_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_12_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_12_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_12_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_12_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_12_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_12_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_12_0_nelements;
MCNUM nu = mcccurved_guide_12_0_nu;
MCNUM phase = mcccurved_guide_12_0_phase;
char* reflect = mcccurved_guide_12_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 67010 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_12_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_13_0'. */
  SIG_MESSAGE("curved_guide_13_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_13_0");
#define mccompcurname  curved_guide_13_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 20
#define GVars mcccurved_guide_13_0_GVars
#define pTable mcccurved_guide_13_0_pTable
{   /* Declarations of curved_guide_13_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_13_0_w1;
MCNUM h1 = mcccurved_guide_13_0_h1;
MCNUM w2 = mcccurved_guide_13_0_w2;
MCNUM h2 = mcccurved_guide_13_0_h2;
MCNUM l = mcccurved_guide_13_0_l;
MCNUM R0 = mcccurved_guide_13_0_R0;
MCNUM Qc = mcccurved_guide_13_0_Qc;
MCNUM alpha = mcccurved_guide_13_0_alpha;
MCNUM m = mcccurved_guide_13_0_m;
MCNUM W = mcccurved_guide_13_0_W;
MCNUM nslit = mcccurved_guide_13_0_nslit;
MCNUM d = mcccurved_guide_13_0_d;
MCNUM mleft = mcccurved_guide_13_0_mleft;
MCNUM mright = mcccurved_guide_13_0_mright;
MCNUM mtop = mcccurved_guide_13_0_mtop;
MCNUM mbottom = mcccurved_guide_13_0_mbottom;
MCNUM nhslit = mcccurved_guide_13_0_nhslit;
MCNUM G = mcccurved_guide_13_0_G;
MCNUM aleft = mcccurved_guide_13_0_aleft;
MCNUM aright = mcccurved_guide_13_0_aright;
MCNUM atop = mcccurved_guide_13_0_atop;
MCNUM abottom = mcccurved_guide_13_0_abottom;
MCNUM wavy = mcccurved_guide_13_0_wavy;
MCNUM wavy_z = mcccurved_guide_13_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_13_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_13_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_13_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_13_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_13_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_13_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_13_0_nelements;
MCNUM nu = mcccurved_guide_13_0_nu;
MCNUM phase = mcccurved_guide_13_0_phase;
char* reflect = mcccurved_guide_13_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 67124 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_13_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_14_0'. */
  SIG_MESSAGE("curved_guide_14_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_14_0");
#define mccompcurname  curved_guide_14_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 21
#define GVars mcccurved_guide_14_0_GVars
#define pTable mcccurved_guide_14_0_pTable
{   /* Declarations of curved_guide_14_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_14_0_w1;
MCNUM h1 = mcccurved_guide_14_0_h1;
MCNUM w2 = mcccurved_guide_14_0_w2;
MCNUM h2 = mcccurved_guide_14_0_h2;
MCNUM l = mcccurved_guide_14_0_l;
MCNUM R0 = mcccurved_guide_14_0_R0;
MCNUM Qc = mcccurved_guide_14_0_Qc;
MCNUM alpha = mcccurved_guide_14_0_alpha;
MCNUM m = mcccurved_guide_14_0_m;
MCNUM W = mcccurved_guide_14_0_W;
MCNUM nslit = mcccurved_guide_14_0_nslit;
MCNUM d = mcccurved_guide_14_0_d;
MCNUM mleft = mcccurved_guide_14_0_mleft;
MCNUM mright = mcccurved_guide_14_0_mright;
MCNUM mtop = mcccurved_guide_14_0_mtop;
MCNUM mbottom = mcccurved_guide_14_0_mbottom;
MCNUM nhslit = mcccurved_guide_14_0_nhslit;
MCNUM G = mcccurved_guide_14_0_G;
MCNUM aleft = mcccurved_guide_14_0_aleft;
MCNUM aright = mcccurved_guide_14_0_aright;
MCNUM atop = mcccurved_guide_14_0_atop;
MCNUM abottom = mcccurved_guide_14_0_abottom;
MCNUM wavy = mcccurved_guide_14_0_wavy;
MCNUM wavy_z = mcccurved_guide_14_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_14_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_14_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_14_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_14_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_14_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_14_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_14_0_nelements;
MCNUM nu = mcccurved_guide_14_0_nu;
MCNUM phase = mcccurved_guide_14_0_phase;
char* reflect = mcccurved_guide_14_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 67238 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_14_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_15_0'. */
  SIG_MESSAGE("curved_guide_15_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_15_0");
#define mccompcurname  curved_guide_15_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 22
#define GVars mcccurved_guide_15_0_GVars
#define pTable mcccurved_guide_15_0_pTable
{   /* Declarations of curved_guide_15_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_15_0_w1;
MCNUM h1 = mcccurved_guide_15_0_h1;
MCNUM w2 = mcccurved_guide_15_0_w2;
MCNUM h2 = mcccurved_guide_15_0_h2;
MCNUM l = mcccurved_guide_15_0_l;
MCNUM R0 = mcccurved_guide_15_0_R0;
MCNUM Qc = mcccurved_guide_15_0_Qc;
MCNUM alpha = mcccurved_guide_15_0_alpha;
MCNUM m = mcccurved_guide_15_0_m;
MCNUM W = mcccurved_guide_15_0_W;
MCNUM nslit = mcccurved_guide_15_0_nslit;
MCNUM d = mcccurved_guide_15_0_d;
MCNUM mleft = mcccurved_guide_15_0_mleft;
MCNUM mright = mcccurved_guide_15_0_mright;
MCNUM mtop = mcccurved_guide_15_0_mtop;
MCNUM mbottom = mcccurved_guide_15_0_mbottom;
MCNUM nhslit = mcccurved_guide_15_0_nhslit;
MCNUM G = mcccurved_guide_15_0_G;
MCNUM aleft = mcccurved_guide_15_0_aleft;
MCNUM aright = mcccurved_guide_15_0_aright;
MCNUM atop = mcccurved_guide_15_0_atop;
MCNUM abottom = mcccurved_guide_15_0_abottom;
MCNUM wavy = mcccurved_guide_15_0_wavy;
MCNUM wavy_z = mcccurved_guide_15_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_15_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_15_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_15_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_15_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_15_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_15_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_15_0_nelements;
MCNUM nu = mcccurved_guide_15_0_nu;
MCNUM phase = mcccurved_guide_15_0_phase;
char* reflect = mcccurved_guide_15_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 67352 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_15_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_16_0'. */
  SIG_MESSAGE("curved_guide_16_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_16_0");
#define mccompcurname  curved_guide_16_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 23
#define GVars mcccurved_guide_16_0_GVars
#define pTable mcccurved_guide_16_0_pTable
{   /* Declarations of curved_guide_16_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_16_0_w1;
MCNUM h1 = mcccurved_guide_16_0_h1;
MCNUM w2 = mcccurved_guide_16_0_w2;
MCNUM h2 = mcccurved_guide_16_0_h2;
MCNUM l = mcccurved_guide_16_0_l;
MCNUM R0 = mcccurved_guide_16_0_R0;
MCNUM Qc = mcccurved_guide_16_0_Qc;
MCNUM alpha = mcccurved_guide_16_0_alpha;
MCNUM m = mcccurved_guide_16_0_m;
MCNUM W = mcccurved_guide_16_0_W;
MCNUM nslit = mcccurved_guide_16_0_nslit;
MCNUM d = mcccurved_guide_16_0_d;
MCNUM mleft = mcccurved_guide_16_0_mleft;
MCNUM mright = mcccurved_guide_16_0_mright;
MCNUM mtop = mcccurved_guide_16_0_mtop;
MCNUM mbottom = mcccurved_guide_16_0_mbottom;
MCNUM nhslit = mcccurved_guide_16_0_nhslit;
MCNUM G = mcccurved_guide_16_0_G;
MCNUM aleft = mcccurved_guide_16_0_aleft;
MCNUM aright = mcccurved_guide_16_0_aright;
MCNUM atop = mcccurved_guide_16_0_atop;
MCNUM abottom = mcccurved_guide_16_0_abottom;
MCNUM wavy = mcccurved_guide_16_0_wavy;
MCNUM wavy_z = mcccurved_guide_16_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_16_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_16_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_16_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_16_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_16_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_16_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_16_0_nelements;
MCNUM nu = mcccurved_guide_16_0_nu;
MCNUM phase = mcccurved_guide_16_0_phase;
char* reflect = mcccurved_guide_16_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 67466 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_16_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_17_0'. */
  SIG_MESSAGE("curved_guide_17_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_17_0");
#define mccompcurname  curved_guide_17_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 24
#define GVars mcccurved_guide_17_0_GVars
#define pTable mcccurved_guide_17_0_pTable
{   /* Declarations of curved_guide_17_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_17_0_w1;
MCNUM h1 = mcccurved_guide_17_0_h1;
MCNUM w2 = mcccurved_guide_17_0_w2;
MCNUM h2 = mcccurved_guide_17_0_h2;
MCNUM l = mcccurved_guide_17_0_l;
MCNUM R0 = mcccurved_guide_17_0_R0;
MCNUM Qc = mcccurved_guide_17_0_Qc;
MCNUM alpha = mcccurved_guide_17_0_alpha;
MCNUM m = mcccurved_guide_17_0_m;
MCNUM W = mcccurved_guide_17_0_W;
MCNUM nslit = mcccurved_guide_17_0_nslit;
MCNUM d = mcccurved_guide_17_0_d;
MCNUM mleft = mcccurved_guide_17_0_mleft;
MCNUM mright = mcccurved_guide_17_0_mright;
MCNUM mtop = mcccurved_guide_17_0_mtop;
MCNUM mbottom = mcccurved_guide_17_0_mbottom;
MCNUM nhslit = mcccurved_guide_17_0_nhslit;
MCNUM G = mcccurved_guide_17_0_G;
MCNUM aleft = mcccurved_guide_17_0_aleft;
MCNUM aright = mcccurved_guide_17_0_aright;
MCNUM atop = mcccurved_guide_17_0_atop;
MCNUM abottom = mcccurved_guide_17_0_abottom;
MCNUM wavy = mcccurved_guide_17_0_wavy;
MCNUM wavy_z = mcccurved_guide_17_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_17_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_17_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_17_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_17_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_17_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_17_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_17_0_nelements;
MCNUM nu = mcccurved_guide_17_0_nu;
MCNUM phase = mcccurved_guide_17_0_phase;
char* reflect = mcccurved_guide_17_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 67580 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_17_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_18_beforeChopper'. */
  SIG_MESSAGE("curved_guide_18_beforeChopper (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_18_beforeChopper");
#define mccompcurname  curved_guide_18_beforeChopper
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 25
#define GVars mcccurved_guide_18_beforeChopper_GVars
#define pTable mcccurved_guide_18_beforeChopper_pTable
{   /* Declarations of curved_guide_18_beforeChopper=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_18_beforeChopper_w1;
MCNUM h1 = mcccurved_guide_18_beforeChopper_h1;
MCNUM w2 = mcccurved_guide_18_beforeChopper_w2;
MCNUM h2 = mcccurved_guide_18_beforeChopper_h2;
MCNUM l = mcccurved_guide_18_beforeChopper_l;
MCNUM R0 = mcccurved_guide_18_beforeChopper_R0;
MCNUM Qc = mcccurved_guide_18_beforeChopper_Qc;
MCNUM alpha = mcccurved_guide_18_beforeChopper_alpha;
MCNUM m = mcccurved_guide_18_beforeChopper_m;
MCNUM W = mcccurved_guide_18_beforeChopper_W;
MCNUM nslit = mcccurved_guide_18_beforeChopper_nslit;
MCNUM d = mcccurved_guide_18_beforeChopper_d;
MCNUM mleft = mcccurved_guide_18_beforeChopper_mleft;
MCNUM mright = mcccurved_guide_18_beforeChopper_mright;
MCNUM mtop = mcccurved_guide_18_beforeChopper_mtop;
MCNUM mbottom = mcccurved_guide_18_beforeChopper_mbottom;
MCNUM nhslit = mcccurved_guide_18_beforeChopper_nhslit;
MCNUM G = mcccurved_guide_18_beforeChopper_G;
MCNUM aleft = mcccurved_guide_18_beforeChopper_aleft;
MCNUM aright = mcccurved_guide_18_beforeChopper_aright;
MCNUM atop = mcccurved_guide_18_beforeChopper_atop;
MCNUM abottom = mcccurved_guide_18_beforeChopper_abottom;
MCNUM wavy = mcccurved_guide_18_beforeChopper_wavy;
MCNUM wavy_z = mcccurved_guide_18_beforeChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_18_beforeChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_18_beforeChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_18_beforeChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_18_beforeChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_18_beforeChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_18_beforeChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_18_beforeChopper_nelements;
MCNUM nu = mcccurved_guide_18_beforeChopper_nu;
MCNUM phase = mcccurved_guide_18_beforeChopper_phase;
char* reflect = mcccurved_guide_18_beforeChopper_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 67694 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_18_beforeChopper=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_18_afterChopper'. */
  SIG_MESSAGE("curved_guide_18_afterChopper (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_18_afterChopper");
#define mccompcurname  curved_guide_18_afterChopper
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 26
#define GVars mcccurved_guide_18_afterChopper_GVars
#define pTable mcccurved_guide_18_afterChopper_pTable
{   /* Declarations of curved_guide_18_afterChopper=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_18_afterChopper_w1;
MCNUM h1 = mcccurved_guide_18_afterChopper_h1;
MCNUM w2 = mcccurved_guide_18_afterChopper_w2;
MCNUM h2 = mcccurved_guide_18_afterChopper_h2;
MCNUM l = mcccurved_guide_18_afterChopper_l;
MCNUM R0 = mcccurved_guide_18_afterChopper_R0;
MCNUM Qc = mcccurved_guide_18_afterChopper_Qc;
MCNUM alpha = mcccurved_guide_18_afterChopper_alpha;
MCNUM m = mcccurved_guide_18_afterChopper_m;
MCNUM W = mcccurved_guide_18_afterChopper_W;
MCNUM nslit = mcccurved_guide_18_afterChopper_nslit;
MCNUM d = mcccurved_guide_18_afterChopper_d;
MCNUM mleft = mcccurved_guide_18_afterChopper_mleft;
MCNUM mright = mcccurved_guide_18_afterChopper_mright;
MCNUM mtop = mcccurved_guide_18_afterChopper_mtop;
MCNUM mbottom = mcccurved_guide_18_afterChopper_mbottom;
MCNUM nhslit = mcccurved_guide_18_afterChopper_nhslit;
MCNUM G = mcccurved_guide_18_afterChopper_G;
MCNUM aleft = mcccurved_guide_18_afterChopper_aleft;
MCNUM aright = mcccurved_guide_18_afterChopper_aright;
MCNUM atop = mcccurved_guide_18_afterChopper_atop;
MCNUM abottom = mcccurved_guide_18_afterChopper_abottom;
MCNUM wavy = mcccurved_guide_18_afterChopper_wavy;
MCNUM wavy_z = mcccurved_guide_18_afterChopper_wavy_z;
MCNUM wavy_tb = mcccurved_guide_18_afterChopper_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_18_afterChopper_wavy_lr;
MCNUM chamfers = mcccurved_guide_18_afterChopper_chamfers;
MCNUM chamfers_z = mcccurved_guide_18_afterChopper_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_18_afterChopper_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_18_afterChopper_chamfers_tb;
MCNUM nelements = mcccurved_guide_18_afterChopper_nelements;
MCNUM nu = mcccurved_guide_18_afterChopper_nu;
MCNUM phase = mcccurved_guide_18_afterChopper_phase;
char* reflect = mcccurved_guide_18_afterChopper_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 67808 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_18_afterChopper=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_19_0'. */
  SIG_MESSAGE("curved_guide_19_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_19_0");
#define mccompcurname  curved_guide_19_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 27
#define GVars mcccurved_guide_19_0_GVars
#define pTable mcccurved_guide_19_0_pTable
{   /* Declarations of curved_guide_19_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_19_0_w1;
MCNUM h1 = mcccurved_guide_19_0_h1;
MCNUM w2 = mcccurved_guide_19_0_w2;
MCNUM h2 = mcccurved_guide_19_0_h2;
MCNUM l = mcccurved_guide_19_0_l;
MCNUM R0 = mcccurved_guide_19_0_R0;
MCNUM Qc = mcccurved_guide_19_0_Qc;
MCNUM alpha = mcccurved_guide_19_0_alpha;
MCNUM m = mcccurved_guide_19_0_m;
MCNUM W = mcccurved_guide_19_0_W;
MCNUM nslit = mcccurved_guide_19_0_nslit;
MCNUM d = mcccurved_guide_19_0_d;
MCNUM mleft = mcccurved_guide_19_0_mleft;
MCNUM mright = mcccurved_guide_19_0_mright;
MCNUM mtop = mcccurved_guide_19_0_mtop;
MCNUM mbottom = mcccurved_guide_19_0_mbottom;
MCNUM nhslit = mcccurved_guide_19_0_nhslit;
MCNUM G = mcccurved_guide_19_0_G;
MCNUM aleft = mcccurved_guide_19_0_aleft;
MCNUM aright = mcccurved_guide_19_0_aright;
MCNUM atop = mcccurved_guide_19_0_atop;
MCNUM abottom = mcccurved_guide_19_0_abottom;
MCNUM wavy = mcccurved_guide_19_0_wavy;
MCNUM wavy_z = mcccurved_guide_19_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_19_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_19_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_19_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_19_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_19_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_19_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_19_0_nelements;
MCNUM nu = mcccurved_guide_19_0_nu;
MCNUM phase = mcccurved_guide_19_0_phase;
char* reflect = mcccurved_guide_19_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 67922 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_19_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_20_0'. */
  SIG_MESSAGE("curved_guide_20_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_20_0");
#define mccompcurname  curved_guide_20_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 28
#define GVars mcccurved_guide_20_0_GVars
#define pTable mcccurved_guide_20_0_pTable
{   /* Declarations of curved_guide_20_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_20_0_w1;
MCNUM h1 = mcccurved_guide_20_0_h1;
MCNUM w2 = mcccurved_guide_20_0_w2;
MCNUM h2 = mcccurved_guide_20_0_h2;
MCNUM l = mcccurved_guide_20_0_l;
MCNUM R0 = mcccurved_guide_20_0_R0;
MCNUM Qc = mcccurved_guide_20_0_Qc;
MCNUM alpha = mcccurved_guide_20_0_alpha;
MCNUM m = mcccurved_guide_20_0_m;
MCNUM W = mcccurved_guide_20_0_W;
MCNUM nslit = mcccurved_guide_20_0_nslit;
MCNUM d = mcccurved_guide_20_0_d;
MCNUM mleft = mcccurved_guide_20_0_mleft;
MCNUM mright = mcccurved_guide_20_0_mright;
MCNUM mtop = mcccurved_guide_20_0_mtop;
MCNUM mbottom = mcccurved_guide_20_0_mbottom;
MCNUM nhslit = mcccurved_guide_20_0_nhslit;
MCNUM G = mcccurved_guide_20_0_G;
MCNUM aleft = mcccurved_guide_20_0_aleft;
MCNUM aright = mcccurved_guide_20_0_aright;
MCNUM atop = mcccurved_guide_20_0_atop;
MCNUM abottom = mcccurved_guide_20_0_abottom;
MCNUM wavy = mcccurved_guide_20_0_wavy;
MCNUM wavy_z = mcccurved_guide_20_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_20_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_20_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_20_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_20_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_20_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_20_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_20_0_nelements;
MCNUM nu = mcccurved_guide_20_0_nu;
MCNUM phase = mcccurved_guide_20_0_phase;
char* reflect = mcccurved_guide_20_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 68036 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_20_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_21_0'. */
  SIG_MESSAGE("curved_guide_21_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_21_0");
#define mccompcurname  curved_guide_21_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 29
#define GVars mcccurved_guide_21_0_GVars
#define pTable mcccurved_guide_21_0_pTable
{   /* Declarations of curved_guide_21_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_21_0_w1;
MCNUM h1 = mcccurved_guide_21_0_h1;
MCNUM w2 = mcccurved_guide_21_0_w2;
MCNUM h2 = mcccurved_guide_21_0_h2;
MCNUM l = mcccurved_guide_21_0_l;
MCNUM R0 = mcccurved_guide_21_0_R0;
MCNUM Qc = mcccurved_guide_21_0_Qc;
MCNUM alpha = mcccurved_guide_21_0_alpha;
MCNUM m = mcccurved_guide_21_0_m;
MCNUM W = mcccurved_guide_21_0_W;
MCNUM nslit = mcccurved_guide_21_0_nslit;
MCNUM d = mcccurved_guide_21_0_d;
MCNUM mleft = mcccurved_guide_21_0_mleft;
MCNUM mright = mcccurved_guide_21_0_mright;
MCNUM mtop = mcccurved_guide_21_0_mtop;
MCNUM mbottom = mcccurved_guide_21_0_mbottom;
MCNUM nhslit = mcccurved_guide_21_0_nhslit;
MCNUM G = mcccurved_guide_21_0_G;
MCNUM aleft = mcccurved_guide_21_0_aleft;
MCNUM aright = mcccurved_guide_21_0_aright;
MCNUM atop = mcccurved_guide_21_0_atop;
MCNUM abottom = mcccurved_guide_21_0_abottom;
MCNUM wavy = mcccurved_guide_21_0_wavy;
MCNUM wavy_z = mcccurved_guide_21_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_21_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_21_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_21_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_21_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_21_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_21_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_21_0_nelements;
MCNUM nu = mcccurved_guide_21_0_nu;
MCNUM phase = mcccurved_guide_21_0_phase;
char* reflect = mcccurved_guide_21_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 68150 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_21_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_22_0'. */
  SIG_MESSAGE("curved_guide_22_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_22_0");
#define mccompcurname  curved_guide_22_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 30
#define GVars mcccurved_guide_22_0_GVars
#define pTable mcccurved_guide_22_0_pTable
{   /* Declarations of curved_guide_22_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_22_0_w1;
MCNUM h1 = mcccurved_guide_22_0_h1;
MCNUM w2 = mcccurved_guide_22_0_w2;
MCNUM h2 = mcccurved_guide_22_0_h2;
MCNUM l = mcccurved_guide_22_0_l;
MCNUM R0 = mcccurved_guide_22_0_R0;
MCNUM Qc = mcccurved_guide_22_0_Qc;
MCNUM alpha = mcccurved_guide_22_0_alpha;
MCNUM m = mcccurved_guide_22_0_m;
MCNUM W = mcccurved_guide_22_0_W;
MCNUM nslit = mcccurved_guide_22_0_nslit;
MCNUM d = mcccurved_guide_22_0_d;
MCNUM mleft = mcccurved_guide_22_0_mleft;
MCNUM mright = mcccurved_guide_22_0_mright;
MCNUM mtop = mcccurved_guide_22_0_mtop;
MCNUM mbottom = mcccurved_guide_22_0_mbottom;
MCNUM nhslit = mcccurved_guide_22_0_nhslit;
MCNUM G = mcccurved_guide_22_0_G;
MCNUM aleft = mcccurved_guide_22_0_aleft;
MCNUM aright = mcccurved_guide_22_0_aright;
MCNUM atop = mcccurved_guide_22_0_atop;
MCNUM abottom = mcccurved_guide_22_0_abottom;
MCNUM wavy = mcccurved_guide_22_0_wavy;
MCNUM wavy_z = mcccurved_guide_22_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_22_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_22_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_22_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_22_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_22_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_22_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_22_0_nelements;
MCNUM nu = mcccurved_guide_22_0_nu;
MCNUM phase = mcccurved_guide_22_0_phase;
char* reflect = mcccurved_guide_22_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 68264 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_22_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_23_0'. */
  SIG_MESSAGE("curved_guide_23_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_23_0");
#define mccompcurname  curved_guide_23_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 31
#define GVars mcccurved_guide_23_0_GVars
#define pTable mcccurved_guide_23_0_pTable
{   /* Declarations of curved_guide_23_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_23_0_w1;
MCNUM h1 = mcccurved_guide_23_0_h1;
MCNUM w2 = mcccurved_guide_23_0_w2;
MCNUM h2 = mcccurved_guide_23_0_h2;
MCNUM l = mcccurved_guide_23_0_l;
MCNUM R0 = mcccurved_guide_23_0_R0;
MCNUM Qc = mcccurved_guide_23_0_Qc;
MCNUM alpha = mcccurved_guide_23_0_alpha;
MCNUM m = mcccurved_guide_23_0_m;
MCNUM W = mcccurved_guide_23_0_W;
MCNUM nslit = mcccurved_guide_23_0_nslit;
MCNUM d = mcccurved_guide_23_0_d;
MCNUM mleft = mcccurved_guide_23_0_mleft;
MCNUM mright = mcccurved_guide_23_0_mright;
MCNUM mtop = mcccurved_guide_23_0_mtop;
MCNUM mbottom = mcccurved_guide_23_0_mbottom;
MCNUM nhslit = mcccurved_guide_23_0_nhslit;
MCNUM G = mcccurved_guide_23_0_G;
MCNUM aleft = mcccurved_guide_23_0_aleft;
MCNUM aright = mcccurved_guide_23_0_aright;
MCNUM atop = mcccurved_guide_23_0_atop;
MCNUM abottom = mcccurved_guide_23_0_abottom;
MCNUM wavy = mcccurved_guide_23_0_wavy;
MCNUM wavy_z = mcccurved_guide_23_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_23_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_23_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_23_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_23_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_23_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_23_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_23_0_nelements;
MCNUM nu = mcccurved_guide_23_0_nu;
MCNUM phase = mcccurved_guide_23_0_phase;
char* reflect = mcccurved_guide_23_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 68378 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_23_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_24_0'. */
  SIG_MESSAGE("curved_guide_24_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_24_0");
#define mccompcurname  curved_guide_24_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 32
#define GVars mcccurved_guide_24_0_GVars
#define pTable mcccurved_guide_24_0_pTable
{   /* Declarations of curved_guide_24_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_24_0_w1;
MCNUM h1 = mcccurved_guide_24_0_h1;
MCNUM w2 = mcccurved_guide_24_0_w2;
MCNUM h2 = mcccurved_guide_24_0_h2;
MCNUM l = mcccurved_guide_24_0_l;
MCNUM R0 = mcccurved_guide_24_0_R0;
MCNUM Qc = mcccurved_guide_24_0_Qc;
MCNUM alpha = mcccurved_guide_24_0_alpha;
MCNUM m = mcccurved_guide_24_0_m;
MCNUM W = mcccurved_guide_24_0_W;
MCNUM nslit = mcccurved_guide_24_0_nslit;
MCNUM d = mcccurved_guide_24_0_d;
MCNUM mleft = mcccurved_guide_24_0_mleft;
MCNUM mright = mcccurved_guide_24_0_mright;
MCNUM mtop = mcccurved_guide_24_0_mtop;
MCNUM mbottom = mcccurved_guide_24_0_mbottom;
MCNUM nhslit = mcccurved_guide_24_0_nhslit;
MCNUM G = mcccurved_guide_24_0_G;
MCNUM aleft = mcccurved_guide_24_0_aleft;
MCNUM aright = mcccurved_guide_24_0_aright;
MCNUM atop = mcccurved_guide_24_0_atop;
MCNUM abottom = mcccurved_guide_24_0_abottom;
MCNUM wavy = mcccurved_guide_24_0_wavy;
MCNUM wavy_z = mcccurved_guide_24_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_24_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_24_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_24_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_24_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_24_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_24_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_24_0_nelements;
MCNUM nu = mcccurved_guide_24_0_nu;
MCNUM phase = mcccurved_guide_24_0_phase;
char* reflect = mcccurved_guide_24_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 68492 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_24_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_25_0'. */
  SIG_MESSAGE("curved_guide_25_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_25_0");
#define mccompcurname  curved_guide_25_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 33
#define GVars mcccurved_guide_25_0_GVars
#define pTable mcccurved_guide_25_0_pTable
{   /* Declarations of curved_guide_25_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_25_0_w1;
MCNUM h1 = mcccurved_guide_25_0_h1;
MCNUM w2 = mcccurved_guide_25_0_w2;
MCNUM h2 = mcccurved_guide_25_0_h2;
MCNUM l = mcccurved_guide_25_0_l;
MCNUM R0 = mcccurved_guide_25_0_R0;
MCNUM Qc = mcccurved_guide_25_0_Qc;
MCNUM alpha = mcccurved_guide_25_0_alpha;
MCNUM m = mcccurved_guide_25_0_m;
MCNUM W = mcccurved_guide_25_0_W;
MCNUM nslit = mcccurved_guide_25_0_nslit;
MCNUM d = mcccurved_guide_25_0_d;
MCNUM mleft = mcccurved_guide_25_0_mleft;
MCNUM mright = mcccurved_guide_25_0_mright;
MCNUM mtop = mcccurved_guide_25_0_mtop;
MCNUM mbottom = mcccurved_guide_25_0_mbottom;
MCNUM nhslit = mcccurved_guide_25_0_nhslit;
MCNUM G = mcccurved_guide_25_0_G;
MCNUM aleft = mcccurved_guide_25_0_aleft;
MCNUM aright = mcccurved_guide_25_0_aright;
MCNUM atop = mcccurved_guide_25_0_atop;
MCNUM abottom = mcccurved_guide_25_0_abottom;
MCNUM wavy = mcccurved_guide_25_0_wavy;
MCNUM wavy_z = mcccurved_guide_25_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_25_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_25_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_25_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_25_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_25_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_25_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_25_0_nelements;
MCNUM nu = mcccurved_guide_25_0_nu;
MCNUM phase = mcccurved_guide_25_0_phase;
char* reflect = mcccurved_guide_25_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 68606 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_25_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_26_0'. */
  SIG_MESSAGE("curved_guide_26_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_26_0");
#define mccompcurname  curved_guide_26_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 34
#define GVars mcccurved_guide_26_0_GVars
#define pTable mcccurved_guide_26_0_pTable
{   /* Declarations of curved_guide_26_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_26_0_w1;
MCNUM h1 = mcccurved_guide_26_0_h1;
MCNUM w2 = mcccurved_guide_26_0_w2;
MCNUM h2 = mcccurved_guide_26_0_h2;
MCNUM l = mcccurved_guide_26_0_l;
MCNUM R0 = mcccurved_guide_26_0_R0;
MCNUM Qc = mcccurved_guide_26_0_Qc;
MCNUM alpha = mcccurved_guide_26_0_alpha;
MCNUM m = mcccurved_guide_26_0_m;
MCNUM W = mcccurved_guide_26_0_W;
MCNUM nslit = mcccurved_guide_26_0_nslit;
MCNUM d = mcccurved_guide_26_0_d;
MCNUM mleft = mcccurved_guide_26_0_mleft;
MCNUM mright = mcccurved_guide_26_0_mright;
MCNUM mtop = mcccurved_guide_26_0_mtop;
MCNUM mbottom = mcccurved_guide_26_0_mbottom;
MCNUM nhslit = mcccurved_guide_26_0_nhslit;
MCNUM G = mcccurved_guide_26_0_G;
MCNUM aleft = mcccurved_guide_26_0_aleft;
MCNUM aright = mcccurved_guide_26_0_aright;
MCNUM atop = mcccurved_guide_26_0_atop;
MCNUM abottom = mcccurved_guide_26_0_abottom;
MCNUM wavy = mcccurved_guide_26_0_wavy;
MCNUM wavy_z = mcccurved_guide_26_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_26_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_26_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_26_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_26_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_26_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_26_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_26_0_nelements;
MCNUM nu = mcccurved_guide_26_0_nu;
MCNUM phase = mcccurved_guide_26_0_phase;
char* reflect = mcccurved_guide_26_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 68720 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_26_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_27_0'. */
  SIG_MESSAGE("curved_guide_27_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_27_0");
#define mccompcurname  curved_guide_27_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 35
#define GVars mcccurved_guide_27_0_GVars
#define pTable mcccurved_guide_27_0_pTable
{   /* Declarations of curved_guide_27_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_27_0_w1;
MCNUM h1 = mcccurved_guide_27_0_h1;
MCNUM w2 = mcccurved_guide_27_0_w2;
MCNUM h2 = mcccurved_guide_27_0_h2;
MCNUM l = mcccurved_guide_27_0_l;
MCNUM R0 = mcccurved_guide_27_0_R0;
MCNUM Qc = mcccurved_guide_27_0_Qc;
MCNUM alpha = mcccurved_guide_27_0_alpha;
MCNUM m = mcccurved_guide_27_0_m;
MCNUM W = mcccurved_guide_27_0_W;
MCNUM nslit = mcccurved_guide_27_0_nslit;
MCNUM d = mcccurved_guide_27_0_d;
MCNUM mleft = mcccurved_guide_27_0_mleft;
MCNUM mright = mcccurved_guide_27_0_mright;
MCNUM mtop = mcccurved_guide_27_0_mtop;
MCNUM mbottom = mcccurved_guide_27_0_mbottom;
MCNUM nhslit = mcccurved_guide_27_0_nhslit;
MCNUM G = mcccurved_guide_27_0_G;
MCNUM aleft = mcccurved_guide_27_0_aleft;
MCNUM aright = mcccurved_guide_27_0_aright;
MCNUM atop = mcccurved_guide_27_0_atop;
MCNUM abottom = mcccurved_guide_27_0_abottom;
MCNUM wavy = mcccurved_guide_27_0_wavy;
MCNUM wavy_z = mcccurved_guide_27_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_27_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_27_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_27_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_27_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_27_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_27_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_27_0_nelements;
MCNUM nu = mcccurved_guide_27_0_nu;
MCNUM phase = mcccurved_guide_27_0_phase;
char* reflect = mcccurved_guide_27_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 68834 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_27_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_28_0'. */
  SIG_MESSAGE("curved_guide_28_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_28_0");
#define mccompcurname  curved_guide_28_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 36
#define GVars mcccurved_guide_28_0_GVars
#define pTable mcccurved_guide_28_0_pTable
{   /* Declarations of curved_guide_28_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_28_0_w1;
MCNUM h1 = mcccurved_guide_28_0_h1;
MCNUM w2 = mcccurved_guide_28_0_w2;
MCNUM h2 = mcccurved_guide_28_0_h2;
MCNUM l = mcccurved_guide_28_0_l;
MCNUM R0 = mcccurved_guide_28_0_R0;
MCNUM Qc = mcccurved_guide_28_0_Qc;
MCNUM alpha = mcccurved_guide_28_0_alpha;
MCNUM m = mcccurved_guide_28_0_m;
MCNUM W = mcccurved_guide_28_0_W;
MCNUM nslit = mcccurved_guide_28_0_nslit;
MCNUM d = mcccurved_guide_28_0_d;
MCNUM mleft = mcccurved_guide_28_0_mleft;
MCNUM mright = mcccurved_guide_28_0_mright;
MCNUM mtop = mcccurved_guide_28_0_mtop;
MCNUM mbottom = mcccurved_guide_28_0_mbottom;
MCNUM nhslit = mcccurved_guide_28_0_nhslit;
MCNUM G = mcccurved_guide_28_0_G;
MCNUM aleft = mcccurved_guide_28_0_aleft;
MCNUM aright = mcccurved_guide_28_0_aright;
MCNUM atop = mcccurved_guide_28_0_atop;
MCNUM abottom = mcccurved_guide_28_0_abottom;
MCNUM wavy = mcccurved_guide_28_0_wavy;
MCNUM wavy_z = mcccurved_guide_28_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_28_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_28_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_28_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_28_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_28_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_28_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_28_0_nelements;
MCNUM nu = mcccurved_guide_28_0_nu;
MCNUM phase = mcccurved_guide_28_0_phase;
char* reflect = mcccurved_guide_28_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 68948 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_28_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_29_0'. */
  SIG_MESSAGE("curved_guide_29_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_29_0");
#define mccompcurname  curved_guide_29_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 37
#define GVars mcccurved_guide_29_0_GVars
#define pTable mcccurved_guide_29_0_pTable
{   /* Declarations of curved_guide_29_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_29_0_w1;
MCNUM h1 = mcccurved_guide_29_0_h1;
MCNUM w2 = mcccurved_guide_29_0_w2;
MCNUM h2 = mcccurved_guide_29_0_h2;
MCNUM l = mcccurved_guide_29_0_l;
MCNUM R0 = mcccurved_guide_29_0_R0;
MCNUM Qc = mcccurved_guide_29_0_Qc;
MCNUM alpha = mcccurved_guide_29_0_alpha;
MCNUM m = mcccurved_guide_29_0_m;
MCNUM W = mcccurved_guide_29_0_W;
MCNUM nslit = mcccurved_guide_29_0_nslit;
MCNUM d = mcccurved_guide_29_0_d;
MCNUM mleft = mcccurved_guide_29_0_mleft;
MCNUM mright = mcccurved_guide_29_0_mright;
MCNUM mtop = mcccurved_guide_29_0_mtop;
MCNUM mbottom = mcccurved_guide_29_0_mbottom;
MCNUM nhslit = mcccurved_guide_29_0_nhslit;
MCNUM G = mcccurved_guide_29_0_G;
MCNUM aleft = mcccurved_guide_29_0_aleft;
MCNUM aright = mcccurved_guide_29_0_aright;
MCNUM atop = mcccurved_guide_29_0_atop;
MCNUM abottom = mcccurved_guide_29_0_abottom;
MCNUM wavy = mcccurved_guide_29_0_wavy;
MCNUM wavy_z = mcccurved_guide_29_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_29_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_29_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_29_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_29_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_29_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_29_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_29_0_nelements;
MCNUM nu = mcccurved_guide_29_0_nu;
MCNUM phase = mcccurved_guide_29_0_phase;
char* reflect = mcccurved_guide_29_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 69062 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_29_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_30_0'. */
  SIG_MESSAGE("curved_guide_30_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_30_0");
#define mccompcurname  curved_guide_30_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 38
#define GVars mcccurved_guide_30_0_GVars
#define pTable mcccurved_guide_30_0_pTable
{   /* Declarations of curved_guide_30_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_30_0_w1;
MCNUM h1 = mcccurved_guide_30_0_h1;
MCNUM w2 = mcccurved_guide_30_0_w2;
MCNUM h2 = mcccurved_guide_30_0_h2;
MCNUM l = mcccurved_guide_30_0_l;
MCNUM R0 = mcccurved_guide_30_0_R0;
MCNUM Qc = mcccurved_guide_30_0_Qc;
MCNUM alpha = mcccurved_guide_30_0_alpha;
MCNUM m = mcccurved_guide_30_0_m;
MCNUM W = mcccurved_guide_30_0_W;
MCNUM nslit = mcccurved_guide_30_0_nslit;
MCNUM d = mcccurved_guide_30_0_d;
MCNUM mleft = mcccurved_guide_30_0_mleft;
MCNUM mright = mcccurved_guide_30_0_mright;
MCNUM mtop = mcccurved_guide_30_0_mtop;
MCNUM mbottom = mcccurved_guide_30_0_mbottom;
MCNUM nhslit = mcccurved_guide_30_0_nhslit;
MCNUM G = mcccurved_guide_30_0_G;
MCNUM aleft = mcccurved_guide_30_0_aleft;
MCNUM aright = mcccurved_guide_30_0_aright;
MCNUM atop = mcccurved_guide_30_0_atop;
MCNUM abottom = mcccurved_guide_30_0_abottom;
MCNUM wavy = mcccurved_guide_30_0_wavy;
MCNUM wavy_z = mcccurved_guide_30_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_30_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_30_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_30_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_30_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_30_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_30_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_30_0_nelements;
MCNUM nu = mcccurved_guide_30_0_nu;
MCNUM phase = mcccurved_guide_30_0_phase;
char* reflect = mcccurved_guide_30_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 69176 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_30_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_31_0'. */
  SIG_MESSAGE("curved_guide_31_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_31_0");
#define mccompcurname  curved_guide_31_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 39
#define GVars mcccurved_guide_31_0_GVars
#define pTable mcccurved_guide_31_0_pTable
{   /* Declarations of curved_guide_31_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_31_0_w1;
MCNUM h1 = mcccurved_guide_31_0_h1;
MCNUM w2 = mcccurved_guide_31_0_w2;
MCNUM h2 = mcccurved_guide_31_0_h2;
MCNUM l = mcccurved_guide_31_0_l;
MCNUM R0 = mcccurved_guide_31_0_R0;
MCNUM Qc = mcccurved_guide_31_0_Qc;
MCNUM alpha = mcccurved_guide_31_0_alpha;
MCNUM m = mcccurved_guide_31_0_m;
MCNUM W = mcccurved_guide_31_0_W;
MCNUM nslit = mcccurved_guide_31_0_nslit;
MCNUM d = mcccurved_guide_31_0_d;
MCNUM mleft = mcccurved_guide_31_0_mleft;
MCNUM mright = mcccurved_guide_31_0_mright;
MCNUM mtop = mcccurved_guide_31_0_mtop;
MCNUM mbottom = mcccurved_guide_31_0_mbottom;
MCNUM nhslit = mcccurved_guide_31_0_nhslit;
MCNUM G = mcccurved_guide_31_0_G;
MCNUM aleft = mcccurved_guide_31_0_aleft;
MCNUM aright = mcccurved_guide_31_0_aright;
MCNUM atop = mcccurved_guide_31_0_atop;
MCNUM abottom = mcccurved_guide_31_0_abottom;
MCNUM wavy = mcccurved_guide_31_0_wavy;
MCNUM wavy_z = mcccurved_guide_31_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_31_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_31_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_31_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_31_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_31_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_31_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_31_0_nelements;
MCNUM nu = mcccurved_guide_31_0_nu;
MCNUM phase = mcccurved_guide_31_0_phase;
char* reflect = mcccurved_guide_31_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 69290 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_31_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_32_0'. */
  SIG_MESSAGE("curved_guide_32_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_32_0");
#define mccompcurname  curved_guide_32_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 40
#define GVars mcccurved_guide_32_0_GVars
#define pTable mcccurved_guide_32_0_pTable
{   /* Declarations of curved_guide_32_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_32_0_w1;
MCNUM h1 = mcccurved_guide_32_0_h1;
MCNUM w2 = mcccurved_guide_32_0_w2;
MCNUM h2 = mcccurved_guide_32_0_h2;
MCNUM l = mcccurved_guide_32_0_l;
MCNUM R0 = mcccurved_guide_32_0_R0;
MCNUM Qc = mcccurved_guide_32_0_Qc;
MCNUM alpha = mcccurved_guide_32_0_alpha;
MCNUM m = mcccurved_guide_32_0_m;
MCNUM W = mcccurved_guide_32_0_W;
MCNUM nslit = mcccurved_guide_32_0_nslit;
MCNUM d = mcccurved_guide_32_0_d;
MCNUM mleft = mcccurved_guide_32_0_mleft;
MCNUM mright = mcccurved_guide_32_0_mright;
MCNUM mtop = mcccurved_guide_32_0_mtop;
MCNUM mbottom = mcccurved_guide_32_0_mbottom;
MCNUM nhslit = mcccurved_guide_32_0_nhslit;
MCNUM G = mcccurved_guide_32_0_G;
MCNUM aleft = mcccurved_guide_32_0_aleft;
MCNUM aright = mcccurved_guide_32_0_aright;
MCNUM atop = mcccurved_guide_32_0_atop;
MCNUM abottom = mcccurved_guide_32_0_abottom;
MCNUM wavy = mcccurved_guide_32_0_wavy;
MCNUM wavy_z = mcccurved_guide_32_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_32_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_32_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_32_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_32_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_32_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_32_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_32_0_nelements;
MCNUM nu = mcccurved_guide_32_0_nu;
MCNUM phase = mcccurved_guide_32_0_phase;
char* reflect = mcccurved_guide_32_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 69404 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_32_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_33_0'. */
  SIG_MESSAGE("curved_guide_33_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_33_0");
#define mccompcurname  curved_guide_33_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 41
#define GVars mcccurved_guide_33_0_GVars
#define pTable mcccurved_guide_33_0_pTable
{   /* Declarations of curved_guide_33_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_33_0_w1;
MCNUM h1 = mcccurved_guide_33_0_h1;
MCNUM w2 = mcccurved_guide_33_0_w2;
MCNUM h2 = mcccurved_guide_33_0_h2;
MCNUM l = mcccurved_guide_33_0_l;
MCNUM R0 = mcccurved_guide_33_0_R0;
MCNUM Qc = mcccurved_guide_33_0_Qc;
MCNUM alpha = mcccurved_guide_33_0_alpha;
MCNUM m = mcccurved_guide_33_0_m;
MCNUM W = mcccurved_guide_33_0_W;
MCNUM nslit = mcccurved_guide_33_0_nslit;
MCNUM d = mcccurved_guide_33_0_d;
MCNUM mleft = mcccurved_guide_33_0_mleft;
MCNUM mright = mcccurved_guide_33_0_mright;
MCNUM mtop = mcccurved_guide_33_0_mtop;
MCNUM mbottom = mcccurved_guide_33_0_mbottom;
MCNUM nhslit = mcccurved_guide_33_0_nhslit;
MCNUM G = mcccurved_guide_33_0_G;
MCNUM aleft = mcccurved_guide_33_0_aleft;
MCNUM aright = mcccurved_guide_33_0_aright;
MCNUM atop = mcccurved_guide_33_0_atop;
MCNUM abottom = mcccurved_guide_33_0_abottom;
MCNUM wavy = mcccurved_guide_33_0_wavy;
MCNUM wavy_z = mcccurved_guide_33_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_33_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_33_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_33_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_33_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_33_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_33_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_33_0_nelements;
MCNUM nu = mcccurved_guide_33_0_nu;
MCNUM phase = mcccurved_guide_33_0_phase;
char* reflect = mcccurved_guide_33_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 69518 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_33_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_34_0'. */
  SIG_MESSAGE("curved_guide_34_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_34_0");
#define mccompcurname  curved_guide_34_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 42
#define GVars mcccurved_guide_34_0_GVars
#define pTable mcccurved_guide_34_0_pTable
{   /* Declarations of curved_guide_34_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_34_0_w1;
MCNUM h1 = mcccurved_guide_34_0_h1;
MCNUM w2 = mcccurved_guide_34_0_w2;
MCNUM h2 = mcccurved_guide_34_0_h2;
MCNUM l = mcccurved_guide_34_0_l;
MCNUM R0 = mcccurved_guide_34_0_R0;
MCNUM Qc = mcccurved_guide_34_0_Qc;
MCNUM alpha = mcccurved_guide_34_0_alpha;
MCNUM m = mcccurved_guide_34_0_m;
MCNUM W = mcccurved_guide_34_0_W;
MCNUM nslit = mcccurved_guide_34_0_nslit;
MCNUM d = mcccurved_guide_34_0_d;
MCNUM mleft = mcccurved_guide_34_0_mleft;
MCNUM mright = mcccurved_guide_34_0_mright;
MCNUM mtop = mcccurved_guide_34_0_mtop;
MCNUM mbottom = mcccurved_guide_34_0_mbottom;
MCNUM nhslit = mcccurved_guide_34_0_nhslit;
MCNUM G = mcccurved_guide_34_0_G;
MCNUM aleft = mcccurved_guide_34_0_aleft;
MCNUM aright = mcccurved_guide_34_0_aright;
MCNUM atop = mcccurved_guide_34_0_atop;
MCNUM abottom = mcccurved_guide_34_0_abottom;
MCNUM wavy = mcccurved_guide_34_0_wavy;
MCNUM wavy_z = mcccurved_guide_34_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_34_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_34_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_34_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_34_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_34_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_34_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_34_0_nelements;
MCNUM nu = mcccurved_guide_34_0_nu;
MCNUM phase = mcccurved_guide_34_0_phase;
char* reflect = mcccurved_guide_34_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 69632 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_34_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_35_0'. */
  SIG_MESSAGE("curved_guide_35_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_35_0");
#define mccompcurname  curved_guide_35_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 43
#define GVars mcccurved_guide_35_0_GVars
#define pTable mcccurved_guide_35_0_pTable
{   /* Declarations of curved_guide_35_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_35_0_w1;
MCNUM h1 = mcccurved_guide_35_0_h1;
MCNUM w2 = mcccurved_guide_35_0_w2;
MCNUM h2 = mcccurved_guide_35_0_h2;
MCNUM l = mcccurved_guide_35_0_l;
MCNUM R0 = mcccurved_guide_35_0_R0;
MCNUM Qc = mcccurved_guide_35_0_Qc;
MCNUM alpha = mcccurved_guide_35_0_alpha;
MCNUM m = mcccurved_guide_35_0_m;
MCNUM W = mcccurved_guide_35_0_W;
MCNUM nslit = mcccurved_guide_35_0_nslit;
MCNUM d = mcccurved_guide_35_0_d;
MCNUM mleft = mcccurved_guide_35_0_mleft;
MCNUM mright = mcccurved_guide_35_0_mright;
MCNUM mtop = mcccurved_guide_35_0_mtop;
MCNUM mbottom = mcccurved_guide_35_0_mbottom;
MCNUM nhslit = mcccurved_guide_35_0_nhslit;
MCNUM G = mcccurved_guide_35_0_G;
MCNUM aleft = mcccurved_guide_35_0_aleft;
MCNUM aright = mcccurved_guide_35_0_aright;
MCNUM atop = mcccurved_guide_35_0_atop;
MCNUM abottom = mcccurved_guide_35_0_abottom;
MCNUM wavy = mcccurved_guide_35_0_wavy;
MCNUM wavy_z = mcccurved_guide_35_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_35_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_35_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_35_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_35_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_35_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_35_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_35_0_nelements;
MCNUM nu = mcccurved_guide_35_0_nu;
MCNUM phase = mcccurved_guide_35_0_phase;
char* reflect = mcccurved_guide_35_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 69746 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_35_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'curved_guide_36_0'. */
  SIG_MESSAGE("curved_guide_36_0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "curved_guide_36_0");
#define mccompcurname  curved_guide_36_0
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 44
#define GVars mcccurved_guide_36_0_GVars
#define pTable mcccurved_guide_36_0_pTable
{   /* Declarations of curved_guide_36_0=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mcccurved_guide_36_0_w1;
MCNUM h1 = mcccurved_guide_36_0_h1;
MCNUM w2 = mcccurved_guide_36_0_w2;
MCNUM h2 = mcccurved_guide_36_0_h2;
MCNUM l = mcccurved_guide_36_0_l;
MCNUM R0 = mcccurved_guide_36_0_R0;
MCNUM Qc = mcccurved_guide_36_0_Qc;
MCNUM alpha = mcccurved_guide_36_0_alpha;
MCNUM m = mcccurved_guide_36_0_m;
MCNUM W = mcccurved_guide_36_0_W;
MCNUM nslit = mcccurved_guide_36_0_nslit;
MCNUM d = mcccurved_guide_36_0_d;
MCNUM mleft = mcccurved_guide_36_0_mleft;
MCNUM mright = mcccurved_guide_36_0_mright;
MCNUM mtop = mcccurved_guide_36_0_mtop;
MCNUM mbottom = mcccurved_guide_36_0_mbottom;
MCNUM nhslit = mcccurved_guide_36_0_nhslit;
MCNUM G = mcccurved_guide_36_0_G;
MCNUM aleft = mcccurved_guide_36_0_aleft;
MCNUM aright = mcccurved_guide_36_0_aright;
MCNUM atop = mcccurved_guide_36_0_atop;
MCNUM abottom = mcccurved_guide_36_0_abottom;
MCNUM wavy = mcccurved_guide_36_0_wavy;
MCNUM wavy_z = mcccurved_guide_36_0_wavy_z;
MCNUM wavy_tb = mcccurved_guide_36_0_wavy_tb;
MCNUM wavy_lr = mcccurved_guide_36_0_wavy_lr;
MCNUM chamfers = mcccurved_guide_36_0_chamfers;
MCNUM chamfers_z = mcccurved_guide_36_0_chamfers_z;
MCNUM chamfers_lr = mcccurved_guide_36_0_chamfers_lr;
MCNUM chamfers_tb = mcccurved_guide_36_0_chamfers_tb;
MCNUM nelements = mcccurved_guide_36_0_nelements;
MCNUM nu = mcccurved_guide_36_0_nu;
MCNUM phase = mcccurved_guide_36_0_phase;
char* reflect = mcccurved_guide_36_0_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 69860 "./ESS_BIFROST_shielding.c"
}   /* End of curved_guide_36_0=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'EndOfelement_4'. */
  SIG_MESSAGE("EndOfelement_4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "EndOfelement_4");
#define mccompcurname  EndOfelement_4
#define mccompcurtype  Arm
#define mccompcurindex 45
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 69882 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'elliptical_guide_gravity3'. */
  SIG_MESSAGE("elliptical_guide_gravity3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "elliptical_guide_gravity3");
#define mccompcurname  elliptical_guide_gravity3
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 47
#define mvaluesright mccelliptical_guide_gravity3_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity3_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity3_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity3_mvaluesbottom
#define seglength mccelliptical_guide_gravity3_seglength
#define guideInfo mccelliptical_guide_gravity3_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity3_latestParticleCollision
#define Gx mccelliptical_guide_gravity3_Gx
#define Gy mccelliptical_guide_gravity3_Gy
#define Gz mccelliptical_guide_gravity3_Gz
#define Gx0 mccelliptical_guide_gravity3_Gx0
#define Gy0 mccelliptical_guide_gravity3_Gy0
#define Gz0 mccelliptical_guide_gravity3_Gz0
#define Circ mccelliptical_guide_gravity3_Circ
#define dynamicalSegLength mccelliptical_guide_gravity3_dynamicalSegLength
{   /* Declarations of elliptical_guide_gravity3=Elliptic_guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM l = mccelliptical_guide_gravity3_l;
MCNUM xwidth = mccelliptical_guide_gravity3_xwidth;
MCNUM yheight = mccelliptical_guide_gravity3_yheight;
MCNUM linxw = mccelliptical_guide_gravity3_linxw;
MCNUM loutxw = mccelliptical_guide_gravity3_loutxw;
MCNUM linyh = mccelliptical_guide_gravity3_linyh;
MCNUM loutyh = mccelliptical_guide_gravity3_loutyh;
MCNUM majorAxisxw = mccelliptical_guide_gravity3_majorAxisxw;
MCNUM minorAxisxw = mccelliptical_guide_gravity3_minorAxisxw;
MCNUM majorAxisyh = mccelliptical_guide_gravity3_majorAxisyh;
MCNUM minorAxisyh = mccelliptical_guide_gravity3_minorAxisyh;
MCNUM majorAxisoffsetxw = mccelliptical_guide_gravity3_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccelliptical_guide_gravity3_majorAxisoffsetyh;
char* dimensionsAt = mccelliptical_guide_gravity3_dimensionsAt;
char* option = mccelliptical_guide_gravity3_option;
MCNUM R0 = mccelliptical_guide_gravity3_R0;
MCNUM Qc = mccelliptical_guide_gravity3_Qc;
MCNUM alpha = mccelliptical_guide_gravity3_alpha;
MCNUM m = mccelliptical_guide_gravity3_m;
MCNUM W = mccelliptical_guide_gravity3_W;
MCNUM alpharight = mccelliptical_guide_gravity3_alpharight;
MCNUM mright = mccelliptical_guide_gravity3_mright;
MCNUM alphaleft = mccelliptical_guide_gravity3_alphaleft;
MCNUM mleft = mccelliptical_guide_gravity3_mleft;
MCNUM alphatop = mccelliptical_guide_gravity3_alphatop;
MCNUM mtop = mccelliptical_guide_gravity3_mtop;
MCNUM alphabottom = mccelliptical_guide_gravity3_alphabottom;
MCNUM mbottom = mccelliptical_guide_gravity3_mbottom;
char* verbose = mccelliptical_guide_gravity3_verbose;
MCNUM enableGravity = mccelliptical_guide_gravity3_enableGravity;
MCNUM curvature = mccelliptical_guide_gravity3_curvature;
#line 1538 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
{


	// Calculate the points need to draw approximation of the ellipses
	// defining the guide 

	// the number of lines used to draw one side of the guide
	int ApproximationMirrors = 500; 

	// The start of the guide
	double zvalue=0;

	// The the different in z between point used to draw the ellipse
	double zdelta = guideInfo.Length/(1.0*ApproximationMirrors);

	// The vector used to store the points defining the lines
	double xplus[ApproximationMirrors+1];
	double xminus[ApproximationMirrors+1];
	double yplus[ApproximationMirrors+1];
	double yminus[ApproximationMirrors+1];

	// Temperary values for the loop
	double tempx;
	double tempy;

	/*
		Calculate the second coordinates to the points on the ellipse with z_i 
		as the first coordinate. We transform the point to the coordinate system 
		there the ellipse is a unit circle. And use the defination of this circle 
		to find second coordinate (x^2+z^2 = 1)
	*/

	/////////////////////////////////////////////////////////
	double Length;
	double entranceHorizontalWidth;
	double entranceVerticalWidth;	
	
	// ellipses infomation
	double ellipseMajorAxis[4],		ellipseMinorAxis[4];
	double ellipseMajorOffset[4],	ellipseMinorOffset[4];

	enum Side {RightSide,TopSide,LeftSide,BottomSide,None};
	/////////////////////////////////////////////////////////

	int i = 0;
	double tempz = 0;
	for(i=0;i<ApproximationMirrors+1;i++){
		
		tempx = sqrt(
			guideInfo.ellipseMinorAxis[RightSide]
			*guideInfo.ellipseMinorAxis[RightSide]
			-(	guideInfo.ellipseMinorAxis[RightSide]
				*guideInfo.ellipseMinorAxis[RightSide] )
			/(	guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
		);

		xplus[i] =  tempx + guideInfo.ellipseMinorOffset[RightSide];
		xminus[i]= -tempx + guideInfo.ellipseMinorOffset[RightSide];
		
		tempy = sqrt(
			guideInfo.ellipseMinorAxis[TopSide]
			*guideInfo.ellipseMinorAxis[TopSide]
			-(	guideInfo.ellipseMinorAxis[TopSide]
				*guideInfo.ellipseMinorAxis[TopSide] )
			/(	guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
		);
		
		yplus[i] =  tempy + guideInfo.ellipseMinorOffset[TopSide];
		yminus[i]= -tempy + guideInfo.ellipseMinorOffset[TopSide];
	}

	///// Draw lines

	// Drawing lines orthogonal with the z direction.
	// at both ends of the guide and at the boardest place at the guide

	// These may not give correct result if one of the ends are closed

	int j=0;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 	  , yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta,xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j],0 		, zvalue+j*zdelta);
			
	j=ApproximationMirrors;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j],zvalue+j*zdelta,xminus[j] , yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	    , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		 , zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j], 0 		 , zvalue+j*zdelta);

			  
			  
	// find boardest place on the guide and draw a band around the guide
	int m0;
	double boardestPlace = 0;
	int boardestPlaceNumber = 0;
	for(m0=0; m0<ApproximationMirrors; m0++){
		if( boardestPlace <= fabs(yplus[m0]) ){
			boardestPlace = fabs(yplus[m0]);
			boardestPlaceNumber = m0;
		}
	}
	j = boardestPlaceNumber;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta, xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta, xplus[j], 0 		 , zvalue+j*zdelta);


			  
	// Drawing lines parallel with the z direction
			  
	int k=0;
	for(k=0; k < ApproximationMirrors; k++){
		
		line( xplus[k], yplus[k], zvalue+k*zdelta,xplus[k+1], yplus[k+1], zvalue+(k+1)*zdelta);
		line( xminus[k],yplus[k], zvalue+k*zdelta,xminus[k+1],yplus[k+1], zvalue+(k+1)*zdelta);
		
		line( xplus[k], yminus[k],zvalue+k*zdelta,xplus[k+1], yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],yminus[k],zvalue+k*zdelta,xminus[k+1],yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],0 		, zvalue+k*zdelta, xminus[k+1],0 	, zvalue+(k+1)*zdelta);
		line( xplus[k], 0 		, zvalue+k*zdelta, xplus[k+1], 0 	, zvalue+(k+1)*zdelta);
		
		line( 0 	, yminus[k],  zvalue+k*zdelta, 0 	  	,yminus[k+1],zvalue+(k+1)*zdelta);
		line( 0 	,yplus[k]  , zvalue+k*zdelta , 0 		,yplus[k] , zvalue+(k+1)*zdelta);
		
		}

		if(guideInfo.EnclosingBoxOn){
			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );

			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );
			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
		}
}
#line 70130 "./ESS_BIFROST_shielding.c"
}   /* End of elliptical_guide_gravity3=Elliptic_guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'EndOfelement_3'. */
  SIG_MESSAGE("EndOfelement_3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "EndOfelement_3");
#define mccompcurname  EndOfelement_3
#define mccompcurtype  Arm
#define mccompcurindex 48
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 70165 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'straight_guide_2_1'. */
  SIG_MESSAGE("straight_guide_2_1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "straight_guide_2_1");
#define mccompcurname  straight_guide_2_1
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 49
#define GVars mccstraight_guide_2_1_GVars
#define pTable mccstraight_guide_2_1_pTable
{   /* Declarations of straight_guide_2_1=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mccstraight_guide_2_1_w1;
MCNUM h1 = mccstraight_guide_2_1_h1;
MCNUM w2 = mccstraight_guide_2_1_w2;
MCNUM h2 = mccstraight_guide_2_1_h2;
MCNUM l = mccstraight_guide_2_1_l;
MCNUM R0 = mccstraight_guide_2_1_R0;
MCNUM Qc = mccstraight_guide_2_1_Qc;
MCNUM alpha = mccstraight_guide_2_1_alpha;
MCNUM m = mccstraight_guide_2_1_m;
MCNUM W = mccstraight_guide_2_1_W;
MCNUM nslit = mccstraight_guide_2_1_nslit;
MCNUM d = mccstraight_guide_2_1_d;
MCNUM mleft = mccstraight_guide_2_1_mleft;
MCNUM mright = mccstraight_guide_2_1_mright;
MCNUM mtop = mccstraight_guide_2_1_mtop;
MCNUM mbottom = mccstraight_guide_2_1_mbottom;
MCNUM nhslit = mccstraight_guide_2_1_nhslit;
MCNUM G = mccstraight_guide_2_1_G;
MCNUM aleft = mccstraight_guide_2_1_aleft;
MCNUM aright = mccstraight_guide_2_1_aright;
MCNUM atop = mccstraight_guide_2_1_atop;
MCNUM abottom = mccstraight_guide_2_1_abottom;
MCNUM wavy = mccstraight_guide_2_1_wavy;
MCNUM wavy_z = mccstraight_guide_2_1_wavy_z;
MCNUM wavy_tb = mccstraight_guide_2_1_wavy_tb;
MCNUM wavy_lr = mccstraight_guide_2_1_wavy_lr;
MCNUM chamfers = mccstraight_guide_2_1_chamfers;
MCNUM chamfers_z = mccstraight_guide_2_1_chamfers_z;
MCNUM chamfers_lr = mccstraight_guide_2_1_chamfers_lr;
MCNUM chamfers_tb = mccstraight_guide_2_1_chamfers_tb;
MCNUM nelements = mccstraight_guide_2_1_nelements;
MCNUM nu = mccstraight_guide_2_1_nu;
MCNUM phase = mccstraight_guide_2_1_phase;
char* reflect = mccstraight_guide_2_1_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 70276 "./ESS_BIFROST_shielding.c"
}   /* End of straight_guide_2_1=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'straight_guide_2_2'. */
  SIG_MESSAGE("straight_guide_2_2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "straight_guide_2_2");
#define mccompcurname  straight_guide_2_2
#define mccompcurtype  Guide_gravity_shieldinglogger
#define mccompcurindex 50
#define GVars mccstraight_guide_2_2_GVars
#define pTable mccstraight_guide_2_2_pTable
{   /* Declarations of straight_guide_2_2=Guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM w1 = mccstraight_guide_2_2_w1;
MCNUM h1 = mccstraight_guide_2_2_h1;
MCNUM w2 = mccstraight_guide_2_2_w2;
MCNUM h2 = mccstraight_guide_2_2_h2;
MCNUM l = mccstraight_guide_2_2_l;
MCNUM R0 = mccstraight_guide_2_2_R0;
MCNUM Qc = mccstraight_guide_2_2_Qc;
MCNUM alpha = mccstraight_guide_2_2_alpha;
MCNUM m = mccstraight_guide_2_2_m;
MCNUM W = mccstraight_guide_2_2_W;
MCNUM nslit = mccstraight_guide_2_2_nslit;
MCNUM d = mccstraight_guide_2_2_d;
MCNUM mleft = mccstraight_guide_2_2_mleft;
MCNUM mright = mccstraight_guide_2_2_mright;
MCNUM mtop = mccstraight_guide_2_2_mtop;
MCNUM mbottom = mccstraight_guide_2_2_mbottom;
MCNUM nhslit = mccstraight_guide_2_2_nhslit;
MCNUM G = mccstraight_guide_2_2_G;
MCNUM aleft = mccstraight_guide_2_2_aleft;
MCNUM aright = mccstraight_guide_2_2_aright;
MCNUM atop = mccstraight_guide_2_2_atop;
MCNUM abottom = mccstraight_guide_2_2_abottom;
MCNUM wavy = mccstraight_guide_2_2_wavy;
MCNUM wavy_z = mccstraight_guide_2_2_wavy_z;
MCNUM wavy_tb = mccstraight_guide_2_2_wavy_tb;
MCNUM wavy_lr = mccstraight_guide_2_2_wavy_lr;
MCNUM chamfers = mccstraight_guide_2_2_chamfers;
MCNUM chamfers_z = mccstraight_guide_2_2_chamfers_z;
MCNUM chamfers_lr = mccstraight_guide_2_2_chamfers_lr;
MCNUM chamfers_tb = mccstraight_guide_2_2_chamfers_tb;
MCNUM nelements = mccstraight_guide_2_2_nelements;
MCNUM nu = mccstraight_guide_2_2_nu;
MCNUM phase = mccstraight_guide_2_2_phase;
char* reflect = mccstraight_guide_2_2_reflect;
#line 612 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_gravity_shieldinglogger.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    magnify("xy");
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    magnify("");
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 70390 "./ESS_BIFROST_shielding.c"
}   /* End of straight_guide_2_2=Guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'EndOfelement_2'. */
  SIG_MESSAGE("EndOfelement_2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "EndOfelement_2");
#define mccompcurname  EndOfelement_2
#define mccompcurtype  Arm
#define mccompcurindex 51
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 70412 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'elliptical_guide_gravity1_1'. */
  SIG_MESSAGE("elliptical_guide_gravity1_1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "elliptical_guide_gravity1_1");
#define mccompcurname  elliptical_guide_gravity1_1
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 52
#define mvaluesright mccelliptical_guide_gravity1_1_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_1_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_1_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_1_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_1_seglength
#define guideInfo mccelliptical_guide_gravity1_1_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_1_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_1_Gx
#define Gy mccelliptical_guide_gravity1_1_Gy
#define Gz mccelliptical_guide_gravity1_1_Gz
#define Gx0 mccelliptical_guide_gravity1_1_Gx0
#define Gy0 mccelliptical_guide_gravity1_1_Gy0
#define Gz0 mccelliptical_guide_gravity1_1_Gz0
#define Circ mccelliptical_guide_gravity1_1_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_1_dynamicalSegLength
{   /* Declarations of elliptical_guide_gravity1_1=Elliptic_guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM l = mccelliptical_guide_gravity1_1_l;
MCNUM xwidth = mccelliptical_guide_gravity1_1_xwidth;
MCNUM yheight = mccelliptical_guide_gravity1_1_yheight;
MCNUM linxw = mccelliptical_guide_gravity1_1_linxw;
MCNUM loutxw = mccelliptical_guide_gravity1_1_loutxw;
MCNUM linyh = mccelliptical_guide_gravity1_1_linyh;
MCNUM loutyh = mccelliptical_guide_gravity1_1_loutyh;
MCNUM majorAxisxw = mccelliptical_guide_gravity1_1_majorAxisxw;
MCNUM minorAxisxw = mccelliptical_guide_gravity1_1_minorAxisxw;
MCNUM majorAxisyh = mccelliptical_guide_gravity1_1_majorAxisyh;
MCNUM minorAxisyh = mccelliptical_guide_gravity1_1_minorAxisyh;
MCNUM majorAxisoffsetxw = mccelliptical_guide_gravity1_1_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccelliptical_guide_gravity1_1_majorAxisoffsetyh;
char* dimensionsAt = mccelliptical_guide_gravity1_1_dimensionsAt;
char* option = mccelliptical_guide_gravity1_1_option;
MCNUM R0 = mccelliptical_guide_gravity1_1_R0;
MCNUM Qc = mccelliptical_guide_gravity1_1_Qc;
MCNUM alpha = mccelliptical_guide_gravity1_1_alpha;
MCNUM m = mccelliptical_guide_gravity1_1_m;
MCNUM W = mccelliptical_guide_gravity1_1_W;
MCNUM alpharight = mccelliptical_guide_gravity1_1_alpharight;
MCNUM mright = mccelliptical_guide_gravity1_1_mright;
MCNUM alphaleft = mccelliptical_guide_gravity1_1_alphaleft;
MCNUM mleft = mccelliptical_guide_gravity1_1_mleft;
MCNUM alphatop = mccelliptical_guide_gravity1_1_alphatop;
MCNUM mtop = mccelliptical_guide_gravity1_1_mtop;
MCNUM alphabottom = mccelliptical_guide_gravity1_1_alphabottom;
MCNUM mbottom = mccelliptical_guide_gravity1_1_mbottom;
char* verbose = mccelliptical_guide_gravity1_1_verbose;
MCNUM enableGravity = mccelliptical_guide_gravity1_1_enableGravity;
MCNUM curvature = mccelliptical_guide_gravity1_1_curvature;
#line 1538 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
{


	// Calculate the points need to draw approximation of the ellipses
	// defining the guide 

	// the number of lines used to draw one side of the guide
	int ApproximationMirrors = 500; 

	// The start of the guide
	double zvalue=0;

	// The the different in z between point used to draw the ellipse
	double zdelta = guideInfo.Length/(1.0*ApproximationMirrors);

	// The vector used to store the points defining the lines
	double xplus[ApproximationMirrors+1];
	double xminus[ApproximationMirrors+1];
	double yplus[ApproximationMirrors+1];
	double yminus[ApproximationMirrors+1];

	// Temperary values for the loop
	double tempx;
	double tempy;

	/*
		Calculate the second coordinates to the points on the ellipse with z_i 
		as the first coordinate. We transform the point to the coordinate system 
		there the ellipse is a unit circle. And use the defination of this circle 
		to find second coordinate (x^2+z^2 = 1)
	*/

	/////////////////////////////////////////////////////////
	double Length;
	double entranceHorizontalWidth;
	double entranceVerticalWidth;	
	
	// ellipses infomation
	double ellipseMajorAxis[4],		ellipseMinorAxis[4];
	double ellipseMajorOffset[4],	ellipseMinorOffset[4];

	enum Side {RightSide,TopSide,LeftSide,BottomSide,None};
	/////////////////////////////////////////////////////////

	int i = 0;
	double tempz = 0;
	for(i=0;i<ApproximationMirrors+1;i++){
		
		tempx = sqrt(
			guideInfo.ellipseMinorAxis[RightSide]
			*guideInfo.ellipseMinorAxis[RightSide]
			-(	guideInfo.ellipseMinorAxis[RightSide]
				*guideInfo.ellipseMinorAxis[RightSide] )
			/(	guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
		);

		xplus[i] =  tempx + guideInfo.ellipseMinorOffset[RightSide];
		xminus[i]= -tempx + guideInfo.ellipseMinorOffset[RightSide];
		
		tempy = sqrt(
			guideInfo.ellipseMinorAxis[TopSide]
			*guideInfo.ellipseMinorAxis[TopSide]
			-(	guideInfo.ellipseMinorAxis[TopSide]
				*guideInfo.ellipseMinorAxis[TopSide] )
			/(	guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
		);
		
		yplus[i] =  tempy + guideInfo.ellipseMinorOffset[TopSide];
		yminus[i]= -tempy + guideInfo.ellipseMinorOffset[TopSide];
	}

	///// Draw lines

	// Drawing lines orthogonal with the z direction.
	// at both ends of the guide and at the boardest place at the guide

	// These may not give correct result if one of the ends are closed

	int j=0;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 	  , yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta,xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j],0 		, zvalue+j*zdelta);
			
	j=ApproximationMirrors;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j],zvalue+j*zdelta,xminus[j] , yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	    , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		 , zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j], 0 		 , zvalue+j*zdelta);

			  
			  
	// find boardest place on the guide and draw a band around the guide
	int m0;
	double boardestPlace = 0;
	int boardestPlaceNumber = 0;
	for(m0=0; m0<ApproximationMirrors; m0++){
		if( boardestPlace <= fabs(yplus[m0]) ){
			boardestPlace = fabs(yplus[m0]);
			boardestPlaceNumber = m0;
		}
	}
	j = boardestPlaceNumber;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta, xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta, xplus[j], 0 		 , zvalue+j*zdelta);


			  
	// Drawing lines parallel with the z direction
			  
	int k=0;
	for(k=0; k < ApproximationMirrors; k++){
		
		line( xplus[k], yplus[k], zvalue+k*zdelta,xplus[k+1], yplus[k+1], zvalue+(k+1)*zdelta);
		line( xminus[k],yplus[k], zvalue+k*zdelta,xminus[k+1],yplus[k+1], zvalue+(k+1)*zdelta);
		
		line( xplus[k], yminus[k],zvalue+k*zdelta,xplus[k+1], yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],yminus[k],zvalue+k*zdelta,xminus[k+1],yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],0 		, zvalue+k*zdelta, xminus[k+1],0 	, zvalue+(k+1)*zdelta);
		line( xplus[k], 0 		, zvalue+k*zdelta, xplus[k+1], 0 	, zvalue+(k+1)*zdelta);
		
		line( 0 	, yminus[k],  zvalue+k*zdelta, 0 	  	,yminus[k+1],zvalue+(k+1)*zdelta);
		line( 0 	,yplus[k]  , zvalue+k*zdelta , 0 		,yplus[k] , zvalue+(k+1)*zdelta);
		
		}

		if(guideInfo.EnclosingBoxOn){
			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );

			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );
			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
		}
}
#line 70660 "./ESS_BIFROST_shielding.c"
}   /* End of elliptical_guide_gravity1_1=Elliptic_guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'DiwJaw3'. */
  SIG_MESSAGE("DiwJaw3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "DiwJaw3");
#define mccompcurname  DiwJaw3
#define mccompcurtype  Slit
#define mccompcurindex 53
{   /* Declarations of DiwJaw3=Slit() SETTING parameters. */
MCNUM xmin = mccDiwJaw3_xmin;
MCNUM xmax = mccDiwJaw3_xmax;
MCNUM ymin = mccDiwJaw3_ymin;
MCNUM ymax = mccDiwJaw3_ymax;
MCNUM radius = mccDiwJaw3_radius;
MCNUM xwidth = mccDiwJaw3_xwidth;
MCNUM yheight = mccDiwJaw3_yheight;
#line 83 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Slit.comp"
{
  
  if (radius == 0) {
    double xw, yh;
    xw = (xmax - xmin)/2.0;
    yh = (ymax - ymin)/2.0;
    multiline(3, xmin-xw, (double)ymax, 0.0,
              (double)xmin, (double)ymax, 0.0,
              (double)xmin, ymax+yh, 0.0);
    multiline(3, xmax+xw, (double)ymax, 0.0,
              (double)xmax, (double)ymax, 0.0,
              (double)xmax, ymax+yh, 0.0);
    multiline(3, xmin-xw, (double)ymin, 0.0,
              (double)xmin, (double)ymin, 0.0,
              (double)xmin, ymin-yh, 0.0);
    multiline(3, xmax+xw, (double)ymin, 0.0,
              (double)xmax, (double)ymin, 0.0,
              (double)xmax, ymin-yh, 0.0);
  } else {
    circle("xy",0,0,0,radius);
  }
}
#line 70718 "./ESS_BIFROST_shielding.c"
}   /* End of DiwJaw3=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'elliptical_guide_gravity1_2'. */
  SIG_MESSAGE("elliptical_guide_gravity1_2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "elliptical_guide_gravity1_2");
#define mccompcurname  elliptical_guide_gravity1_2
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 54
#define mvaluesright mccelliptical_guide_gravity1_2_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_2_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_2_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_2_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_2_seglength
#define guideInfo mccelliptical_guide_gravity1_2_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_2_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_2_Gx
#define Gy mccelliptical_guide_gravity1_2_Gy
#define Gz mccelliptical_guide_gravity1_2_Gz
#define Gx0 mccelliptical_guide_gravity1_2_Gx0
#define Gy0 mccelliptical_guide_gravity1_2_Gy0
#define Gz0 mccelliptical_guide_gravity1_2_Gz0
#define Circ mccelliptical_guide_gravity1_2_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_2_dynamicalSegLength
{   /* Declarations of elliptical_guide_gravity1_2=Elliptic_guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM l = mccelliptical_guide_gravity1_2_l;
MCNUM xwidth = mccelliptical_guide_gravity1_2_xwidth;
MCNUM yheight = mccelliptical_guide_gravity1_2_yheight;
MCNUM linxw = mccelliptical_guide_gravity1_2_linxw;
MCNUM loutxw = mccelliptical_guide_gravity1_2_loutxw;
MCNUM linyh = mccelliptical_guide_gravity1_2_linyh;
MCNUM loutyh = mccelliptical_guide_gravity1_2_loutyh;
MCNUM majorAxisxw = mccelliptical_guide_gravity1_2_majorAxisxw;
MCNUM minorAxisxw = mccelliptical_guide_gravity1_2_minorAxisxw;
MCNUM majorAxisyh = mccelliptical_guide_gravity1_2_majorAxisyh;
MCNUM minorAxisyh = mccelliptical_guide_gravity1_2_minorAxisyh;
MCNUM majorAxisoffsetxw = mccelliptical_guide_gravity1_2_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccelliptical_guide_gravity1_2_majorAxisoffsetyh;
char* dimensionsAt = mccelliptical_guide_gravity1_2_dimensionsAt;
char* option = mccelliptical_guide_gravity1_2_option;
MCNUM R0 = mccelliptical_guide_gravity1_2_R0;
MCNUM Qc = mccelliptical_guide_gravity1_2_Qc;
MCNUM alpha = mccelliptical_guide_gravity1_2_alpha;
MCNUM m = mccelliptical_guide_gravity1_2_m;
MCNUM W = mccelliptical_guide_gravity1_2_W;
MCNUM alpharight = mccelliptical_guide_gravity1_2_alpharight;
MCNUM mright = mccelliptical_guide_gravity1_2_mright;
MCNUM alphaleft = mccelliptical_guide_gravity1_2_alphaleft;
MCNUM mleft = mccelliptical_guide_gravity1_2_mleft;
MCNUM alphatop = mccelliptical_guide_gravity1_2_alphatop;
MCNUM mtop = mccelliptical_guide_gravity1_2_mtop;
MCNUM alphabottom = mccelliptical_guide_gravity1_2_alphabottom;
MCNUM mbottom = mccelliptical_guide_gravity1_2_mbottom;
char* verbose = mccelliptical_guide_gravity1_2_verbose;
MCNUM enableGravity = mccelliptical_guide_gravity1_2_enableGravity;
MCNUM curvature = mccelliptical_guide_gravity1_2_curvature;
#line 1538 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
{


	// Calculate the points need to draw approximation of the ellipses
	// defining the guide 

	// the number of lines used to draw one side of the guide
	int ApproximationMirrors = 500; 

	// The start of the guide
	double zvalue=0;

	// The the different in z between point used to draw the ellipse
	double zdelta = guideInfo.Length/(1.0*ApproximationMirrors);

	// The vector used to store the points defining the lines
	double xplus[ApproximationMirrors+1];
	double xminus[ApproximationMirrors+1];
	double yplus[ApproximationMirrors+1];
	double yminus[ApproximationMirrors+1];

	// Temperary values for the loop
	double tempx;
	double tempy;

	/*
		Calculate the second coordinates to the points on the ellipse with z_i 
		as the first coordinate. We transform the point to the coordinate system 
		there the ellipse is a unit circle. And use the defination of this circle 
		to find second coordinate (x^2+z^2 = 1)
	*/

	/////////////////////////////////////////////////////////
	double Length;
	double entranceHorizontalWidth;
	double entranceVerticalWidth;	
	
	// ellipses infomation
	double ellipseMajorAxis[4],		ellipseMinorAxis[4];
	double ellipseMajorOffset[4],	ellipseMinorOffset[4];

	enum Side {RightSide,TopSide,LeftSide,BottomSide,None};
	/////////////////////////////////////////////////////////

	int i = 0;
	double tempz = 0;
	for(i=0;i<ApproximationMirrors+1;i++){
		
		tempx = sqrt(
			guideInfo.ellipseMinorAxis[RightSide]
			*guideInfo.ellipseMinorAxis[RightSide]
			-(	guideInfo.ellipseMinorAxis[RightSide]
				*guideInfo.ellipseMinorAxis[RightSide] )
			/(	guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
		);

		xplus[i] =  tempx + guideInfo.ellipseMinorOffset[RightSide];
		xminus[i]= -tempx + guideInfo.ellipseMinorOffset[RightSide];
		
		tempy = sqrt(
			guideInfo.ellipseMinorAxis[TopSide]
			*guideInfo.ellipseMinorAxis[TopSide]
			-(	guideInfo.ellipseMinorAxis[TopSide]
				*guideInfo.ellipseMinorAxis[TopSide] )
			/(	guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
		);
		
		yplus[i] =  tempy + guideInfo.ellipseMinorOffset[TopSide];
		yminus[i]= -tempy + guideInfo.ellipseMinorOffset[TopSide];
	}

	///// Draw lines

	// Drawing lines orthogonal with the z direction.
	// at both ends of the guide and at the boardest place at the guide

	// These may not give correct result if one of the ends are closed

	int j=0;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 	  , yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta,xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j],0 		, zvalue+j*zdelta);
			
	j=ApproximationMirrors;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j],zvalue+j*zdelta,xminus[j] , yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	    , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		 , zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j], 0 		 , zvalue+j*zdelta);

			  
			  
	// find boardest place on the guide and draw a band around the guide
	int m0;
	double boardestPlace = 0;
	int boardestPlaceNumber = 0;
	for(m0=0; m0<ApproximationMirrors; m0++){
		if( boardestPlace <= fabs(yplus[m0]) ){
			boardestPlace = fabs(yplus[m0]);
			boardestPlaceNumber = m0;
		}
	}
	j = boardestPlaceNumber;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta, xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta, xplus[j], 0 		 , zvalue+j*zdelta);


			  
	// Drawing lines parallel with the z direction
			  
	int k=0;
	for(k=0; k < ApproximationMirrors; k++){
		
		line( xplus[k], yplus[k], zvalue+k*zdelta,xplus[k+1], yplus[k+1], zvalue+(k+1)*zdelta);
		line( xminus[k],yplus[k], zvalue+k*zdelta,xminus[k+1],yplus[k+1], zvalue+(k+1)*zdelta);
		
		line( xplus[k], yminus[k],zvalue+k*zdelta,xplus[k+1], yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],yminus[k],zvalue+k*zdelta,xminus[k+1],yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],0 		, zvalue+k*zdelta, xminus[k+1],0 	, zvalue+(k+1)*zdelta);
		line( xplus[k], 0 		, zvalue+k*zdelta, xplus[k+1], 0 	, zvalue+(k+1)*zdelta);
		
		line( 0 	, yminus[k],  zvalue+k*zdelta, 0 	  	,yminus[k+1],zvalue+(k+1)*zdelta);
		line( 0 	,yplus[k]  , zvalue+k*zdelta , 0 		,yplus[k] , zvalue+(k+1)*zdelta);
		
		}

		if(guideInfo.EnclosingBoxOn){
			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );

			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );
			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
		}
}
#line 70967 "./ESS_BIFROST_shielding.c"
}   /* End of elliptical_guide_gravity1_2=Elliptic_guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'DiwJaw2'. */
  SIG_MESSAGE("DiwJaw2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "DiwJaw2");
#define mccompcurname  DiwJaw2
#define mccompcurtype  Slit
#define mccompcurindex 55
{   /* Declarations of DiwJaw2=Slit() SETTING parameters. */
MCNUM xmin = mccDiwJaw2_xmin;
MCNUM xmax = mccDiwJaw2_xmax;
MCNUM ymin = mccDiwJaw2_ymin;
MCNUM ymax = mccDiwJaw2_ymax;
MCNUM radius = mccDiwJaw2_radius;
MCNUM xwidth = mccDiwJaw2_xwidth;
MCNUM yheight = mccDiwJaw2_yheight;
#line 83 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Slit.comp"
{
  
  if (radius == 0) {
    double xw, yh;
    xw = (xmax - xmin)/2.0;
    yh = (ymax - ymin)/2.0;
    multiline(3, xmin-xw, (double)ymax, 0.0,
              (double)xmin, (double)ymax, 0.0,
              (double)xmin, ymax+yh, 0.0);
    multiline(3, xmax+xw, (double)ymax, 0.0,
              (double)xmax, (double)ymax, 0.0,
              (double)xmax, ymax+yh, 0.0);
    multiline(3, xmin-xw, (double)ymin, 0.0,
              (double)xmin, (double)ymin, 0.0,
              (double)xmin, ymin-yh, 0.0);
    multiline(3, xmax+xw, (double)ymin, 0.0,
              (double)xmax, (double)ymin, 0.0,
              (double)xmax, ymin-yh, 0.0);
  } else {
    circle("xy",0,0,0,radius);
  }
}
#line 71025 "./ESS_BIFROST_shielding.c"
}   /* End of DiwJaw2=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'elliptical_guide_gravity1_3'. */
  SIG_MESSAGE("elliptical_guide_gravity1_3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "elliptical_guide_gravity1_3");
#define mccompcurname  elliptical_guide_gravity1_3
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 56
#define mvaluesright mccelliptical_guide_gravity1_3_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_3_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_3_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_3_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_3_seglength
#define guideInfo mccelliptical_guide_gravity1_3_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_3_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_3_Gx
#define Gy mccelliptical_guide_gravity1_3_Gy
#define Gz mccelliptical_guide_gravity1_3_Gz
#define Gx0 mccelliptical_guide_gravity1_3_Gx0
#define Gy0 mccelliptical_guide_gravity1_3_Gy0
#define Gz0 mccelliptical_guide_gravity1_3_Gz0
#define Circ mccelliptical_guide_gravity1_3_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_3_dynamicalSegLength
{   /* Declarations of elliptical_guide_gravity1_3=Elliptic_guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM l = mccelliptical_guide_gravity1_3_l;
MCNUM xwidth = mccelliptical_guide_gravity1_3_xwidth;
MCNUM yheight = mccelliptical_guide_gravity1_3_yheight;
MCNUM linxw = mccelliptical_guide_gravity1_3_linxw;
MCNUM loutxw = mccelliptical_guide_gravity1_3_loutxw;
MCNUM linyh = mccelliptical_guide_gravity1_3_linyh;
MCNUM loutyh = mccelliptical_guide_gravity1_3_loutyh;
MCNUM majorAxisxw = mccelliptical_guide_gravity1_3_majorAxisxw;
MCNUM minorAxisxw = mccelliptical_guide_gravity1_3_minorAxisxw;
MCNUM majorAxisyh = mccelliptical_guide_gravity1_3_majorAxisyh;
MCNUM minorAxisyh = mccelliptical_guide_gravity1_3_minorAxisyh;
MCNUM majorAxisoffsetxw = mccelliptical_guide_gravity1_3_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccelliptical_guide_gravity1_3_majorAxisoffsetyh;
char* dimensionsAt = mccelliptical_guide_gravity1_3_dimensionsAt;
char* option = mccelliptical_guide_gravity1_3_option;
MCNUM R0 = mccelliptical_guide_gravity1_3_R0;
MCNUM Qc = mccelliptical_guide_gravity1_3_Qc;
MCNUM alpha = mccelliptical_guide_gravity1_3_alpha;
MCNUM m = mccelliptical_guide_gravity1_3_m;
MCNUM W = mccelliptical_guide_gravity1_3_W;
MCNUM alpharight = mccelliptical_guide_gravity1_3_alpharight;
MCNUM mright = mccelliptical_guide_gravity1_3_mright;
MCNUM alphaleft = mccelliptical_guide_gravity1_3_alphaleft;
MCNUM mleft = mccelliptical_guide_gravity1_3_mleft;
MCNUM alphatop = mccelliptical_guide_gravity1_3_alphatop;
MCNUM mtop = mccelliptical_guide_gravity1_3_mtop;
MCNUM alphabottom = mccelliptical_guide_gravity1_3_alphabottom;
MCNUM mbottom = mccelliptical_guide_gravity1_3_mbottom;
char* verbose = mccelliptical_guide_gravity1_3_verbose;
MCNUM enableGravity = mccelliptical_guide_gravity1_3_enableGravity;
MCNUM curvature = mccelliptical_guide_gravity1_3_curvature;
#line 1538 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
{


	// Calculate the points need to draw approximation of the ellipses
	// defining the guide 

	// the number of lines used to draw one side of the guide
	int ApproximationMirrors = 500; 

	// The start of the guide
	double zvalue=0;

	// The the different in z between point used to draw the ellipse
	double zdelta = guideInfo.Length/(1.0*ApproximationMirrors);

	// The vector used to store the points defining the lines
	double xplus[ApproximationMirrors+1];
	double xminus[ApproximationMirrors+1];
	double yplus[ApproximationMirrors+1];
	double yminus[ApproximationMirrors+1];

	// Temperary values for the loop
	double tempx;
	double tempy;

	/*
		Calculate the second coordinates to the points on the ellipse with z_i 
		as the first coordinate. We transform the point to the coordinate system 
		there the ellipse is a unit circle. And use the defination of this circle 
		to find second coordinate (x^2+z^2 = 1)
	*/

	/////////////////////////////////////////////////////////
	double Length;
	double entranceHorizontalWidth;
	double entranceVerticalWidth;	
	
	// ellipses infomation
	double ellipseMajorAxis[4],		ellipseMinorAxis[4];
	double ellipseMajorOffset[4],	ellipseMinorOffset[4];

	enum Side {RightSide,TopSide,LeftSide,BottomSide,None};
	/////////////////////////////////////////////////////////

	int i = 0;
	double tempz = 0;
	for(i=0;i<ApproximationMirrors+1;i++){
		
		tempx = sqrt(
			guideInfo.ellipseMinorAxis[RightSide]
			*guideInfo.ellipseMinorAxis[RightSide]
			-(	guideInfo.ellipseMinorAxis[RightSide]
				*guideInfo.ellipseMinorAxis[RightSide] )
			/(	guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
		);

		xplus[i] =  tempx + guideInfo.ellipseMinorOffset[RightSide];
		xminus[i]= -tempx + guideInfo.ellipseMinorOffset[RightSide];
		
		tempy = sqrt(
			guideInfo.ellipseMinorAxis[TopSide]
			*guideInfo.ellipseMinorAxis[TopSide]
			-(	guideInfo.ellipseMinorAxis[TopSide]
				*guideInfo.ellipseMinorAxis[TopSide] )
			/(	guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
		);
		
		yplus[i] =  tempy + guideInfo.ellipseMinorOffset[TopSide];
		yminus[i]= -tempy + guideInfo.ellipseMinorOffset[TopSide];
	}

	///// Draw lines

	// Drawing lines orthogonal with the z direction.
	// at both ends of the guide and at the boardest place at the guide

	// These may not give correct result if one of the ends are closed

	int j=0;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 	  , yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta,xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j],0 		, zvalue+j*zdelta);
			
	j=ApproximationMirrors;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j],zvalue+j*zdelta,xminus[j] , yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	    , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		 , zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j], 0 		 , zvalue+j*zdelta);

			  
			  
	// find boardest place on the guide and draw a band around the guide
	int m0;
	double boardestPlace = 0;
	int boardestPlaceNumber = 0;
	for(m0=0; m0<ApproximationMirrors; m0++){
		if( boardestPlace <= fabs(yplus[m0]) ){
			boardestPlace = fabs(yplus[m0]);
			boardestPlaceNumber = m0;
		}
	}
	j = boardestPlaceNumber;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta, xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta, xplus[j], 0 		 , zvalue+j*zdelta);


			  
	// Drawing lines parallel with the z direction
			  
	int k=0;
	for(k=0; k < ApproximationMirrors; k++){
		
		line( xplus[k], yplus[k], zvalue+k*zdelta,xplus[k+1], yplus[k+1], zvalue+(k+1)*zdelta);
		line( xminus[k],yplus[k], zvalue+k*zdelta,xminus[k+1],yplus[k+1], zvalue+(k+1)*zdelta);
		
		line( xplus[k], yminus[k],zvalue+k*zdelta,xplus[k+1], yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],yminus[k],zvalue+k*zdelta,xminus[k+1],yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],0 		, zvalue+k*zdelta, xminus[k+1],0 	, zvalue+(k+1)*zdelta);
		line( xplus[k], 0 		, zvalue+k*zdelta, xplus[k+1], 0 	, zvalue+(k+1)*zdelta);
		
		line( 0 	, yminus[k],  zvalue+k*zdelta, 0 	  	,yminus[k+1],zvalue+(k+1)*zdelta);
		line( 0 	,yplus[k]  , zvalue+k*zdelta , 0 		,yplus[k] , zvalue+(k+1)*zdelta);
		
		}

		if(guideInfo.EnclosingBoxOn){
			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );

			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );
			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
		}
}
#line 71274 "./ESS_BIFROST_shielding.c"
}   /* End of elliptical_guide_gravity1_3=Elliptic_guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'DiwJaw1'. */
  SIG_MESSAGE("DiwJaw1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "DiwJaw1");
#define mccompcurname  DiwJaw1
#define mccompcurtype  Slit
#define mccompcurindex 57
{   /* Declarations of DiwJaw1=Slit() SETTING parameters. */
MCNUM xmin = mccDiwJaw1_xmin;
MCNUM xmax = mccDiwJaw1_xmax;
MCNUM ymin = mccDiwJaw1_ymin;
MCNUM ymax = mccDiwJaw1_ymax;
MCNUM radius = mccDiwJaw1_radius;
MCNUM xwidth = mccDiwJaw1_xwidth;
MCNUM yheight = mccDiwJaw1_yheight;
#line 83 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Slit.comp"
{
  
  if (radius == 0) {
    double xw, yh;
    xw = (xmax - xmin)/2.0;
    yh = (ymax - ymin)/2.0;
    multiline(3, xmin-xw, (double)ymax, 0.0,
              (double)xmin, (double)ymax, 0.0,
              (double)xmin, ymax+yh, 0.0);
    multiline(3, xmax+xw, (double)ymax, 0.0,
              (double)xmax, (double)ymax, 0.0,
              (double)xmax, ymax+yh, 0.0);
    multiline(3, xmin-xw, (double)ymin, 0.0,
              (double)xmin, (double)ymin, 0.0,
              (double)xmin, ymin-yh, 0.0);
    multiline(3, xmax+xw, (double)ymin, 0.0,
              (double)xmax, (double)ymin, 0.0,
              (double)xmax, ymin-yh, 0.0);
  } else {
    circle("xy",0,0,0,radius);
  }
}
#line 71332 "./ESS_BIFROST_shielding.c"
}   /* End of DiwJaw1=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'elliptical_guide_gravity1_4'. */
  SIG_MESSAGE("elliptical_guide_gravity1_4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "elliptical_guide_gravity1_4");
#define mccompcurname  elliptical_guide_gravity1_4
#define mccompcurtype  Elliptic_guide_gravity_shieldinglogger
#define mccompcurindex 58
#define mvaluesright mccelliptical_guide_gravity1_4_mvaluesright
#define mvaluesleft mccelliptical_guide_gravity1_4_mvaluesleft
#define mvaluestop mccelliptical_guide_gravity1_4_mvaluestop
#define mvaluesbottom mccelliptical_guide_gravity1_4_mvaluesbottom
#define seglength mccelliptical_guide_gravity1_4_seglength
#define guideInfo mccelliptical_guide_gravity1_4_guideInfo
#define latestParticleCollision mccelliptical_guide_gravity1_4_latestParticleCollision
#define Gx mccelliptical_guide_gravity1_4_Gx
#define Gy mccelliptical_guide_gravity1_4_Gy
#define Gz mccelliptical_guide_gravity1_4_Gz
#define Gx0 mccelliptical_guide_gravity1_4_Gx0
#define Gy0 mccelliptical_guide_gravity1_4_Gy0
#define Gz0 mccelliptical_guide_gravity1_4_Gz0
#define Circ mccelliptical_guide_gravity1_4_Circ
#define dynamicalSegLength mccelliptical_guide_gravity1_4_dynamicalSegLength
{   /* Declarations of elliptical_guide_gravity1_4=Elliptic_guide_gravity_shieldinglogger() SETTING parameters. */
MCNUM l = mccelliptical_guide_gravity1_4_l;
MCNUM xwidth = mccelliptical_guide_gravity1_4_xwidth;
MCNUM yheight = mccelliptical_guide_gravity1_4_yheight;
MCNUM linxw = mccelliptical_guide_gravity1_4_linxw;
MCNUM loutxw = mccelliptical_guide_gravity1_4_loutxw;
MCNUM linyh = mccelliptical_guide_gravity1_4_linyh;
MCNUM loutyh = mccelliptical_guide_gravity1_4_loutyh;
MCNUM majorAxisxw = mccelliptical_guide_gravity1_4_majorAxisxw;
MCNUM minorAxisxw = mccelliptical_guide_gravity1_4_minorAxisxw;
MCNUM majorAxisyh = mccelliptical_guide_gravity1_4_majorAxisyh;
MCNUM minorAxisyh = mccelliptical_guide_gravity1_4_minorAxisyh;
MCNUM majorAxisoffsetxw = mccelliptical_guide_gravity1_4_majorAxisoffsetxw;
MCNUM majorAxisoffsetyh = mccelliptical_guide_gravity1_4_majorAxisoffsetyh;
char* dimensionsAt = mccelliptical_guide_gravity1_4_dimensionsAt;
char* option = mccelliptical_guide_gravity1_4_option;
MCNUM R0 = mccelliptical_guide_gravity1_4_R0;
MCNUM Qc = mccelliptical_guide_gravity1_4_Qc;
MCNUM alpha = mccelliptical_guide_gravity1_4_alpha;
MCNUM m = mccelliptical_guide_gravity1_4_m;
MCNUM W = mccelliptical_guide_gravity1_4_W;
MCNUM alpharight = mccelliptical_guide_gravity1_4_alpharight;
MCNUM mright = mccelliptical_guide_gravity1_4_mright;
MCNUM alphaleft = mccelliptical_guide_gravity1_4_alphaleft;
MCNUM mleft = mccelliptical_guide_gravity1_4_mleft;
MCNUM alphatop = mccelliptical_guide_gravity1_4_alphatop;
MCNUM mtop = mccelliptical_guide_gravity1_4_mtop;
MCNUM alphabottom = mccelliptical_guide_gravity1_4_alphabottom;
MCNUM mbottom = mccelliptical_guide_gravity1_4_mbottom;
char* verbose = mccelliptical_guide_gravity1_4_verbose;
MCNUM enableGravity = mccelliptical_guide_gravity1_4_enableGravity;
MCNUM curvature = mccelliptical_guide_gravity1_4_curvature;
#line 1538 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Elliptic_guide_gravity_shieldinglogger.comp"
{


	// Calculate the points need to draw approximation of the ellipses
	// defining the guide 

	// the number of lines used to draw one side of the guide
	int ApproximationMirrors = 500; 

	// The start of the guide
	double zvalue=0;

	// The the different in z between point used to draw the ellipse
	double zdelta = guideInfo.Length/(1.0*ApproximationMirrors);

	// The vector used to store the points defining the lines
	double xplus[ApproximationMirrors+1];
	double xminus[ApproximationMirrors+1];
	double yplus[ApproximationMirrors+1];
	double yminus[ApproximationMirrors+1];

	// Temperary values for the loop
	double tempx;
	double tempy;

	/*
		Calculate the second coordinates to the points on the ellipse with z_i 
		as the first coordinate. We transform the point to the coordinate system 
		there the ellipse is a unit circle. And use the defination of this circle 
		to find second coordinate (x^2+z^2 = 1)
	*/

	/////////////////////////////////////////////////////////
	double Length;
	double entranceHorizontalWidth;
	double entranceVerticalWidth;	
	
	// ellipses infomation
	double ellipseMajorAxis[4],		ellipseMinorAxis[4];
	double ellipseMajorOffset[4],	ellipseMinorOffset[4];

	enum Side {RightSide,TopSide,LeftSide,BottomSide,None};
	/////////////////////////////////////////////////////////

	int i = 0;
	double tempz = 0;
	for(i=0;i<ApproximationMirrors+1;i++){
		
		tempx = sqrt(
			guideInfo.ellipseMinorAxis[RightSide]
			*guideInfo.ellipseMinorAxis[RightSide]
			-(	guideInfo.ellipseMinorAxis[RightSide]
				*guideInfo.ellipseMinorAxis[RightSide] )
			/(	guideInfo.ellipseMajorAxis[RightSide]
				*guideInfo.ellipseMajorAxis[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[RightSide] )
		);

		xplus[i] =  tempx + guideInfo.ellipseMinorOffset[RightSide];
		xminus[i]= -tempx + guideInfo.ellipseMinorOffset[RightSide];
		
		tempy = sqrt(
			guideInfo.ellipseMinorAxis[TopSide]
			*guideInfo.ellipseMinorAxis[TopSide]
			-(	guideInfo.ellipseMinorAxis[TopSide]
				*guideInfo.ellipseMinorAxis[TopSide] )
			/(	guideInfo.ellipseMajorAxis[TopSide]
				*guideInfo.ellipseMajorAxis[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
			*( zvalue+zdelta*i-guideInfo.ellipseMajorOffset[TopSide] )
		);
		
		yplus[i] =  tempy + guideInfo.ellipseMinorOffset[TopSide];
		yminus[i]= -tempy + guideInfo.ellipseMinorOffset[TopSide];
	}

	///// Draw lines

	// Drawing lines orthogonal with the z direction.
	// at both ends of the guide and at the boardest place at the guide

	// These may not give correct result if one of the ends are closed

	int j=0;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 	  , yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta,xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j],0 		, zvalue+j*zdelta);
			
	j=ApproximationMirrors;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j],zvalue+j*zdelta,xminus[j] , yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	    , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		 , zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta,xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta,xplus[j], 0 		 , zvalue+j*zdelta);

			  
			  
	// find boardest place on the guide and draw a band around the guide
	int m0;
	double boardestPlace = 0;
	int boardestPlaceNumber = 0;
	for(m0=0; m0<ApproximationMirrors; m0++){
		if( boardestPlace <= fabs(yplus[m0]) ){
			boardestPlace = fabs(yplus[m0]);
			boardestPlaceNumber = m0;
		}
	}
	j = boardestPlaceNumber;

	line( xplus[j], yplus[j], zvalue+j*zdelta,0 		, yplus[j], zvalue+j*zdelta);
	line( 0 	   , yplus[j], zvalue+j*zdelta,xminus[j], yplus[j], zvalue+j*zdelta);
	line( xminus[j], yminus[j], zvalue+j*zdelta,0 	   , yminus[j], zvalue+j*zdelta);
	line( 0, 		yminus[j], zvalue+j*zdelta, xplus[j], yminus[j], zvalue+j*zdelta);
	line( xminus[j],yplus[j], zvalue+j*zdelta, xminus[j],0 		, zvalue+j*zdelta);
	line( xminus[j],0 		 , zvalue+j*zdelta, xminus[j],yminus[j], zvalue+j*zdelta);
	line( xplus[j], 0, 		  zvalue+j*zdelta, xplus[j], yplus[j], zvalue+j*zdelta);
	line( xplus[j], yminus[j], zvalue+j*zdelta, xplus[j], 0 		 , zvalue+j*zdelta);


			  
	// Drawing lines parallel with the z direction
			  
	int k=0;
	for(k=0; k < ApproximationMirrors; k++){
		
		line( xplus[k], yplus[k], zvalue+k*zdelta,xplus[k+1], yplus[k+1], zvalue+(k+1)*zdelta);
		line( xminus[k],yplus[k], zvalue+k*zdelta,xminus[k+1],yplus[k+1], zvalue+(k+1)*zdelta);
		
		line( xplus[k], yminus[k],zvalue+k*zdelta,xplus[k+1], yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],yminus[k],zvalue+k*zdelta,xminus[k+1],yminus[k+1],zvalue+(k+1)*zdelta);
		
		line( xminus[k],0 		, zvalue+k*zdelta, xminus[k+1],0 	, zvalue+(k+1)*zdelta);
		line( xplus[k], 0 		, zvalue+k*zdelta, xplus[k+1], 0 	, zvalue+(k+1)*zdelta);
		
		line( 0 	, yminus[k],  zvalue+k*zdelta, 0 	  	,yminus[k+1],zvalue+(k+1)*zdelta);
		line( 0 	,yplus[k]  , zvalue+k*zdelta , 0 		,yplus[k] , zvalue+(k+1)*zdelta);
		
		}

		if(guideInfo.EnclosingBoxOn){
			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );

			dashed_line( guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],
							guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],10 );
			dashed_line( guideInfo.xArray[4],guideInfo.yArray[4],guideInfo.zArray[4],
							guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],10 );
			dashed_line( guideInfo.xArray[7],guideInfo.yArray[7],guideInfo.zArray[7],
							guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],10 );
			dashed_line( guideInfo.xArray[3],guideInfo.yArray[3],guideInfo.zArray[3],
							guideInfo.xArray[0],guideInfo.yArray[0],guideInfo.zArray[0],10 );

			dashed_line( guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],
							guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],10 );
			dashed_line( guideInfo.xArray[5],guideInfo.yArray[5],guideInfo.zArray[5],
							guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],10 );
			dashed_line( guideInfo.xArray[6],guideInfo.yArray[6],guideInfo.zArray[6],
							guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],10 );
			dashed_line( guideInfo.xArray[2],guideInfo.yArray[2],guideInfo.zArray[2],
							guideInfo.xArray[1],guideInfo.yArray[1],guideInfo.zArray[1],10 );
		}
}
#line 71581 "./ESS_BIFROST_shielding.c"
}   /* End of elliptical_guide_gravity1_4=Elliptic_guide_gravity_shieldinglogger() SETTING parameter declarations. */
#undef dynamicalSegLength
#undef Circ
#undef Gz0
#undef Gy0
#undef Gx0
#undef Gz
#undef Gy
#undef Gx
#undef latestParticleCollision
#undef guideInfo
#undef seglength
#undef mvaluesbottom
#undef mvaluestop
#undef mvaluesleft
#undef mvaluesright
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'EndOfelement_1'. */
  SIG_MESSAGE("EndOfelement_1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "EndOfelement_1");
#define mccompcurname  EndOfelement_1
#define mccompcurtype  Arm
#define mccompcurindex 59
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 71616 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'VirtualOutput'. */
  SIG_MESSAGE("VirtualOutput (McDisplay)");
  printf("MCDISPLAY: component %s\n", "VirtualOutput");
#define mccompcurname  VirtualOutput
#define mccompcurtype  Virtual_output
#define mccompcurindex 60
#define DEFS mccVirtualOutput_DEFS
#define Vars mccVirtualOutput_Vars
{   /* Declarations of VirtualOutput=Virtual_output() SETTING parameters. */
char* filename = mccVirtualOutput_filename;
MCNUM bufsize = mccVirtualOutput_bufsize;
#line 145 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../sources/Virtual_output.comp"
{
  Monitor_nD_McDisplay(&DEFS, &Vars);
}
#line 71636 "./ESS_BIFROST_shielding.c"
}   /* End of VirtualOutput=Virtual_output() SETTING parameter declarations. */
#undef Vars
#undef DEFS
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'DiwJaw0'. */
  SIG_MESSAGE("DiwJaw0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "DiwJaw0");
#define mccompcurname  DiwJaw0
#define mccompcurtype  Slit
#define mccompcurindex 61
{   /* Declarations of DiwJaw0=Slit() SETTING parameters. */
MCNUM xmin = mccDiwJaw0_xmin;
MCNUM xmax = mccDiwJaw0_xmax;
MCNUM ymin = mccDiwJaw0_ymin;
MCNUM ymax = mccDiwJaw0_ymax;
MCNUM radius = mccDiwJaw0_radius;
MCNUM xwidth = mccDiwJaw0_xwidth;
MCNUM yheight = mccDiwJaw0_yheight;
#line 83 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Slit.comp"
{
  
  if (radius == 0) {
    double xw, yh;
    xw = (xmax - xmin)/2.0;
    yh = (ymax - ymin)/2.0;
    multiline(3, xmin-xw, (double)ymax, 0.0,
              (double)xmin, (double)ymax, 0.0,
              (double)xmin, ymax+yh, 0.0);
    multiline(3, xmax+xw, (double)ymax, 0.0,
              (double)xmax, (double)ymax, 0.0,
              (double)xmax, ymax+yh, 0.0);
    multiline(3, xmin-xw, (double)ymin, 0.0,
              (double)xmin, (double)ymin, 0.0,
              (double)xmin, ymin-yh, 0.0);
    multiline(3, xmax+xw, (double)ymin, 0.0,
              (double)xmax, (double)ymin, 0.0,
              (double)xmax, ymin-yh, 0.0);
  } else {
    circle("xy",0,0,0,radius);
  }
}
#line 71681 "./ESS_BIFROST_shielding.c"
}   /* End of DiwJaw0=Slit() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'arm_iter_P1_start'. */
  SIG_MESSAGE("arm_iter_P1_start (McDisplay)");
  printf("MCDISPLAY: component %s\n", "arm_iter_P1_start");
#define mccompcurname  arm_iter_P1_start
#define mccompcurtype  Arm
#define mccompcurindex 63
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 71701 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'iter_P1_start'. */
  SIG_MESSAGE("iter_P1_start (McDisplay)");
  printf("MCDISPLAY: component %s\n", "iter_P1_start");
#define mccompcurname  iter_P1_start
#define mccompcurtype  Shielding_log_iterator_Ni_new
#define mccompcurindex 64
#define compute_func mcciter_P1_start_compute_func
#define nstate_initial mcciter_P1_start_nstate_initial
#define s0 mcciter_P1_start_s0
#define s1 mcciter_P1_start_s1
#line 202 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_Ni_new.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 71724 "./ESS_BIFROST_shielding.c"
#undef s1
#undef s0
#undef nstate_initial
#undef compute_func
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'arm_iter_P1_dummy'. */
  SIG_MESSAGE("arm_iter_P1_dummy (McDisplay)");
  printf("MCDISPLAY: component %s\n", "arm_iter_P1_dummy");
#define mccompcurname  arm_iter_P1_dummy
#define mccompcurtype  Arm
#define mccompcurindex 65
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 71747 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'mndP01'. */
  SIG_MESSAGE("mndP01 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "mndP01");
#define mccompcurname  mndP01
#define mccompcurtype  Monitor_nD
#define mccompcurindex 66
#define user1 mccmndP01_user1
#define user2 mccmndP01_user2
#define user3 mccmndP01_user3
#define DEFS mccmndP01_DEFS
#define Vars mccmndP01_Vars
#define detector mccmndP01_detector
#define offdata mccmndP01_offdata
{   /* Declarations of mndP01=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccmndP01_xwidth;
MCNUM yheight = mccmndP01_yheight;
MCNUM zdepth = mccmndP01_zdepth;
MCNUM xmin = mccmndP01_xmin;
MCNUM xmax = mccmndP01_xmax;
MCNUM ymin = mccmndP01_ymin;
MCNUM ymax = mccmndP01_ymax;
MCNUM zmin = mccmndP01_zmin;
MCNUM zmax = mccmndP01_zmax;
MCNUM bins = mccmndP01_bins;
MCNUM min = mccmndP01_min;
MCNUM max = mccmndP01_max;
MCNUM restore_neutron = mccmndP01_restore_neutron;
MCNUM radius = mccmndP01_radius;
char* options = mccmndP01_options;
char* filename = mccmndP01_filename;
char* geometry = mccmndP01_geometry;
char* username1 = mccmndP01_username1;
char* username2 = mccmndP01_username2;
char* username3 = mccmndP01_username3;
int nowritefile = mccmndP01_nowritefile;
#line 497 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    off_display(offdata);
  } else {
    Monitor_nD_McDisplay(&DEFS, &Vars);
  }
}
#line 71796 "./ESS_BIFROST_shielding.c"
}   /* End of mndP01=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'arm_iter_P1_stop'. */
  SIG_MESSAGE("arm_iter_P1_stop (McDisplay)");
  printf("MCDISPLAY: component %s\n", "arm_iter_P1_stop");
#define mccompcurname  arm_iter_P1_stop
#define mccompcurtype  Arm
#define mccompcurindex 67
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 71823 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'iter_P1_stop'. */
  SIG_MESSAGE("iter_P1_stop (McDisplay)");
  printf("MCDISPLAY: component %s\n", "iter_P1_stop");
#define mccompcurname  iter_P1_stop
#define mccompcurtype  Shielding_log_iterator_stop
#define mccompcurindex 68
#define iterator mcciter_P1_stop_iterator
#define loop mcciter_P1_stop_loop
{   /* Declarations of iter_P1_stop=Shielding_log_iterator_stop() SETTING parameters. */
int last = mcciter_P1_stop_last;
#line 108 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_stop.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 71846 "./ESS_BIFROST_shielding.c"
}   /* End of iter_P1_stop=Shielding_log_iterator_stop() SETTING parameter declarations. */
#undef loop
#undef iterator
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'a11i'. */
  SIG_MESSAGE("a11i (McDisplay)");
  printf("MCDISPLAY: component %s\n", "a11i");
#define mccompcurname  a11i
#define mccompcurtype  Arm
#define mccompcurindex 69
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 71868 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'arm_iter_P2_start'. */
  SIG_MESSAGE("arm_iter_P2_start (McDisplay)");
  printf("MCDISPLAY: component %s\n", "arm_iter_P2_start");
#define mccompcurname  arm_iter_P2_start
#define mccompcurtype  Arm
#define mccompcurindex 70
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 71887 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'iter_P2_start'. */
  SIG_MESSAGE("iter_P2_start (McDisplay)");
  printf("MCDISPLAY: component %s\n", "iter_P2_start");
#define mccompcurname  iter_P2_start
#define mccompcurtype  Shielding_log_iterator_Ti_new
#define mccompcurindex 71
#define compute_func mcciter_P2_start_compute_func
#define nstate_initial mcciter_P2_start_nstate_initial
#define s0 mcciter_P2_start_s0
#define s1 mcciter_P2_start_s1
#line 178 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_Ti_new.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 71910 "./ESS_BIFROST_shielding.c"
#undef s1
#undef s0
#undef nstate_initial
#undef compute_func
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'arm_iter_P2_dummy'. */
  SIG_MESSAGE("arm_iter_P2_dummy (McDisplay)");
  printf("MCDISPLAY: component %s\n", "arm_iter_P2_dummy");
#define mccompcurname  arm_iter_P2_dummy
#define mccompcurtype  Arm
#define mccompcurindex 72
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 71933 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'mndP02'. */
  SIG_MESSAGE("mndP02 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "mndP02");
#define mccompcurname  mndP02
#define mccompcurtype  Monitor_nD
#define mccompcurindex 73
#define user1 mccmndP02_user1
#define user2 mccmndP02_user2
#define user3 mccmndP02_user3
#define DEFS mccmndP02_DEFS
#define Vars mccmndP02_Vars
#define detector mccmndP02_detector
#define offdata mccmndP02_offdata
{   /* Declarations of mndP02=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccmndP02_xwidth;
MCNUM yheight = mccmndP02_yheight;
MCNUM zdepth = mccmndP02_zdepth;
MCNUM xmin = mccmndP02_xmin;
MCNUM xmax = mccmndP02_xmax;
MCNUM ymin = mccmndP02_ymin;
MCNUM ymax = mccmndP02_ymax;
MCNUM zmin = mccmndP02_zmin;
MCNUM zmax = mccmndP02_zmax;
MCNUM bins = mccmndP02_bins;
MCNUM min = mccmndP02_min;
MCNUM max = mccmndP02_max;
MCNUM restore_neutron = mccmndP02_restore_neutron;
MCNUM radius = mccmndP02_radius;
char* options = mccmndP02_options;
char* filename = mccmndP02_filename;
char* geometry = mccmndP02_geometry;
char* username1 = mccmndP02_username1;
char* username2 = mccmndP02_username2;
char* username3 = mccmndP02_username3;
int nowritefile = mccmndP02_nowritefile;
#line 497 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    off_display(offdata);
  } else {
    Monitor_nD_McDisplay(&DEFS, &Vars);
  }
}
#line 71982 "./ESS_BIFROST_shielding.c"
}   /* End of mndP02=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'arm_iter_P2_stop'. */
  SIG_MESSAGE("arm_iter_P2_stop (McDisplay)");
  printf("MCDISPLAY: component %s\n", "arm_iter_P2_stop");
#define mccompcurname  arm_iter_P2_stop
#define mccompcurtype  Arm
#define mccompcurindex 74
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 72009 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'iter_P2_stop'. */
  SIG_MESSAGE("iter_P2_stop (McDisplay)");
  printf("MCDISPLAY: component %s\n", "iter_P2_stop");
#define mccompcurname  iter_P2_stop
#define mccompcurtype  Shielding_log_iterator_stop
#define mccompcurindex 75
#define iterator mcciter_P2_stop_iterator
#define loop mcciter_P2_stop_loop
{   /* Declarations of iter_P2_stop=Shielding_log_iterator_stop() SETTING parameters. */
int last = mcciter_P2_stop_last;
#line 108 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_stop.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 72032 "./ESS_BIFROST_shielding.c"
}   /* End of iter_P2_stop=Shielding_log_iterator_stop() SETTING parameter declarations. */
#undef loop
#undef iterator
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'a12i'. */
  SIG_MESSAGE("a12i (McDisplay)");
  printf("MCDISPLAY: component %s\n", "a12i");
#define mccompcurname  a12i
#define mccompcurtype  Arm
#define mccompcurindex 76
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 72054 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'arm_iter_P3_start'. */
  SIG_MESSAGE("arm_iter_P3_start (McDisplay)");
  printf("MCDISPLAY: component %s\n", "arm_iter_P3_start");
#define mccompcurname  arm_iter_P3_start
#define mccompcurtype  Arm
#define mccompcurindex 77
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 72073 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'iter_P3_start'. */
  SIG_MESSAGE("iter_P3_start (McDisplay)");
  printf("MCDISPLAY: component %s\n", "iter_P3_start");
#define mccompcurname  iter_P3_start
#define mccompcurtype  Shielding_log_iterator_total
#define mccompcurindex 78
#define compute_func mcciter_P3_start_compute_func
#define nstate_initial mcciter_P3_start_nstate_initial
#define s0 mcciter_P3_start_s0
#define s1 mcciter_P3_start_s1
#line 157 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_total.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 72096 "./ESS_BIFROST_shielding.c"
#undef s1
#undef s0
#undef nstate_initial
#undef compute_func
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'arm_iter_P3_dummy'. */
  SIG_MESSAGE("arm_iter_P3_dummy (McDisplay)");
  printf("MCDISPLAY: component %s\n", "arm_iter_P3_dummy");
#define mccompcurname  arm_iter_P3_dummy
#define mccompcurtype  Arm
#define mccompcurindex 79
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 72119 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'mndP03'. */
  SIG_MESSAGE("mndP03 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "mndP03");
#define mccompcurname  mndP03
#define mccompcurtype  Monitor_nD
#define mccompcurindex 80
#define user1 mccmndP03_user1
#define user2 mccmndP03_user2
#define user3 mccmndP03_user3
#define DEFS mccmndP03_DEFS
#define Vars mccmndP03_Vars
#define detector mccmndP03_detector
#define offdata mccmndP03_offdata
{   /* Declarations of mndP03=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccmndP03_xwidth;
MCNUM yheight = mccmndP03_yheight;
MCNUM zdepth = mccmndP03_zdepth;
MCNUM xmin = mccmndP03_xmin;
MCNUM xmax = mccmndP03_xmax;
MCNUM ymin = mccmndP03_ymin;
MCNUM ymax = mccmndP03_ymax;
MCNUM zmin = mccmndP03_zmin;
MCNUM zmax = mccmndP03_zmax;
MCNUM bins = mccmndP03_bins;
MCNUM min = mccmndP03_min;
MCNUM max = mccmndP03_max;
MCNUM restore_neutron = mccmndP03_restore_neutron;
MCNUM radius = mccmndP03_radius;
char* options = mccmndP03_options;
char* filename = mccmndP03_filename;
char* geometry = mccmndP03_geometry;
char* username1 = mccmndP03_username1;
char* username2 = mccmndP03_username2;
char* username3 = mccmndP03_username3;
int nowritefile = mccmndP03_nowritefile;
#line 497 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    off_display(offdata);
  } else {
    Monitor_nD_McDisplay(&DEFS, &Vars);
  }
}
#line 72168 "./ESS_BIFROST_shielding.c"
}   /* End of mndP03=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'arm_iter_P3_stop'. */
  SIG_MESSAGE("arm_iter_P3_stop (McDisplay)");
  printf("MCDISPLAY: component %s\n", "arm_iter_P3_stop");
#define mccompcurname  arm_iter_P3_stop
#define mccompcurtype  Arm
#define mccompcurindex 81
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 72195 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'iter_P3_stop'. */
  SIG_MESSAGE("iter_P3_stop (McDisplay)");
  printf("MCDISPLAY: component %s\n", "iter_P3_stop");
#define mccompcurname  iter_P3_stop
#define mccompcurtype  Shielding_log_iterator_stop
#define mccompcurindex 82
#define iterator mcciter_P3_stop_iterator
#define loop mcciter_P3_stop_loop
{   /* Declarations of iter_P3_stop=Shielding_log_iterator_stop() SETTING parameters. */
int last = mcciter_P3_stop_last;
#line 108 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Shielding_log_iterator_stop.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 72218 "./ESS_BIFROST_shielding.c"
}   /* End of iter_P3_stop=Shielding_log_iterator_stop() SETTING parameter declarations. */
#undef loop
#undef iterator
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'a13i'. */
  SIG_MESSAGE("a13i (McDisplay)");
  printf("MCDISPLAY: component %s\n", "a13i");
#define mccompcurname  a13i
#define mccompcurtype  Arm
#define mccompcurindex 83
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 72240 "./ESS_BIFROST_shielding.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Beamstop'. */
  SIG_MESSAGE("Beamstop (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Beamstop");
#define mccompcurname  Beamstop
#define mccompcurtype  Beamstop
#define mccompcurindex 84
{   /* Declarations of Beamstop=Beamstop() SETTING parameters. */
MCNUM xmin = mccBeamstop_xmin;
MCNUM xmax = mccBeamstop_xmax;
MCNUM ymin = mccBeamstop_ymin;
MCNUM ymax = mccBeamstop_ymax;
MCNUM xwidth = mccBeamstop_xwidth;
MCNUM yheight = mccBeamstop_yheight;
MCNUM radius = mccBeamstop_radius;
#line 72 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Beamstop.comp"
{
  
  if (radius != 0)
    circle("xy", 0, 0, 0, radius);
  else
    multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 72271 "./ESS_BIFROST_shielding.c"
}   /* End of Beamstop=Beamstop() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Lmon_guide_end'. */
  SIG_MESSAGE("Lmon_guide_end (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Lmon_guide_end");
#define mccompcurname  Lmon_guide_end
#define mccompcurtype  L_monitor
#define mccompcurindex 85
#define nL mccLmon_guide_end_nL
#define L_N mccLmon_guide_end_L_N
#define L_p mccLmon_guide_end_L_p
#define L_p2 mccLmon_guide_end_L_p2
{   /* Declarations of Lmon_guide_end=L_monitor() SETTING parameters. */
char* filename = mccLmon_guide_end_filename;
MCNUM xmin = mccLmon_guide_end_xmin;
MCNUM xmax = mccLmon_guide_end_xmax;
MCNUM ymin = mccLmon_guide_end_ymin;
MCNUM ymax = mccLmon_guide_end_ymax;
MCNUM xwidth = mccLmon_guide_end_xwidth;
MCNUM yheight = mccLmon_guide_end_yheight;
MCNUM Lmin = mccLmon_guide_end_Lmin;
MCNUM Lmax = mccLmon_guide_end_Lmax;
MCNUM restore_neutron = mccLmon_guide_end_restore_neutron;
int nowritefile = mccLmon_guide_end_nowritefile;
#line 120 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 72308 "./ESS_BIFROST_shielding.c"
}   /* End of Lmon_guide_end=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  printf("MCDISPLAY: end\n");
} /* end display */
#undef magnify
#undef line
#undef dashed_line
#undef multiline
#undef rectangle
#undef box
#undef circle
#undef cylinder
#undef sphere
/* end of generated C code ./ESS_BIFROST_shielding.c */
