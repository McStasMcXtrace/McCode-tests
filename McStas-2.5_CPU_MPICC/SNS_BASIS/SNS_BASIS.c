/* Automatically generated file. Do not edit. 
 * Format:     ANSI C source code
 * Creator:    McStas <http://www.mcstas.org>
 * Instrument: /zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr (SNS_BASIS)
 * Date:       Wed Nov 20 00:47:52 2019
 * File:       ./SNS_BASIS.c
 * Compile:    cc -o SNS_BASIS.out ./SNS_BASIS.c 
 * CFLAGS=
 */


#define MCCODE_STRING "McStas 2.5 - Nov. 19, 2019"
#define FLAVOR "mcstas"
#define FLAVOR_UPPER "MCSTAS"
#define MC_USE_DEFAULT_MAIN
#define MC_TRACE_ENABLED
#define MC_EMBEDDED_RUNTIME

#line 1 "mccode-r.h"
/*******************************************************************************
*
* McCode, neutron/xray ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mccode-r.h
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McStas 2.5
* Version: $Revision$
*
* Runtime system header for McStas/McXtrace.
*
* In order to use this library as an external library, the following variables
* and macros must be declared (see details in the code)
*
*   struct mcinputtable_struct mcinputtable[];
*   int mcnumipar;
*   char mcinstrument_name[], mcinstrument_source[];
*   int mctraceenabled, mcdefaultmain;
*   extern MCNUM  mccomp_storein[];
*   extern MCNUM  mcAbsorbProp[];
*   extern MCNUM  mcScattered;
*   #define MCCODE_STRING "the McStas/McXtrace version"
*
* Usage: Automatically embbeded in the c code.
*
* $Id$
*
*******************************************************************************/

#ifndef MCCODE_R_H
#define MCCODE_R_H "$Revision$"

#include <math.h>
#include <string.h>
#include <strings.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <limits.h>
#include <errno.h>
#include <time.h>
#include <float.h>
#include <inttypes.h>

/* If the runtime is embedded in the simulation program, some definitions can
   be made static. */

#ifdef MC_EMBEDDED_RUNTIME
#define mcstatic static
#else
#define mcstatic
#endif

#ifdef __dest_os
#if (__dest_os == __mac_os)
#define MAC
#endif
#endif

#ifdef __FreeBSD__
#define NEED_STAT_H
#endif

#if defined(__APPLE__) && defined(__GNUC__)
#define NEED_STAT_H
#endif

#ifdef NEED_STAT_H
#include <sys/stat.h>
#endif

#ifndef MC_PATHSEP_C
#ifdef WIN32
#define MC_PATHSEP_C '\\'
#define MC_PATHSEP_S "\\"
#else  /* !WIN32 */
#define MC_PATHSEP_C '/'
#define MC_PATHSEP_S "/"
#endif /* !WIN32 */
#endif /* MC_PATHSEP_C */

#ifndef WIN32
#ifndef _POSIX_SOURCE
#define _POSIX_SOURCE 1
#endif
#endif

/* the version string is replaced when building distribution with mkdist */
#ifndef MCCODE_STRING
#define MCCODE_STRING "McStas 2.5 - Nov. 19, 2019"
#endif

#ifndef MCCODE_DATE
#define MCCODE_DATE "Nov. 19, 2019"
#endif

#ifndef MCCODE_VERSION
#define MCCODE_VERSION "2.5"
#endif

#ifndef MCCODE_NAME
#define MCCODE_NAME "McStas"
#endif

#ifndef MCCODE_PARTICLE
#define MCCODE_PARTICLE "neutron"
#endif

#ifndef MCCODE_LIBENV
#define MCCODE_LIBENV "MCSTAS"
#endif

#ifndef FLAVOR_UPPER
#define FLAVOR_UPPER MCCODE_NAME
#endif

#ifdef MC_PORTABLE
#ifndef NOSIGNALS
#define NOSIGNALS 1
#endif
#endif

#ifdef MAC
#ifndef NOSIGNALS
#define NOSIGNALS 1
#endif
#endif

#if (USE_MPI == 0)
#undef USE_MPI
#endif

#ifdef USE_MPI  /* default is to disable signals with MPI, as MPICH uses them to communicate */
#ifndef NOSIGNALS
#define NOSIGNALS 1
#endif
#endif

#if (NOSIGNALS == 0)
#undef NOSIGNALS
#endif

/* Note: the enum instr_formal_types definition MUST be kept
   synchronized with the one in mccode.h and with the
   instr_formal_type_names array in cogen.c. */
enum instr_formal_types
  {
    instr_type_double, instr_type_int, instr_type_string
  };
struct mcinputtable_struct { /* defines instrument parameters */
  char *name; /* name of parameter */
  void *par;  /* pointer to instrument parameter (variable) */
  enum instr_formal_types type;
  char *val;  /* default value */
};

typedef double MCNUM;
typedef struct {MCNUM x, y, z;} Coords;
typedef MCNUM Rotation[3][3];

/* the following variables are defined in the McStas generated C code
   but should be defined externally in case of independent library usage */
#ifndef DANSE
extern struct mcinputtable_struct mcinputtable[]; /* list of instrument parameters */
extern int    mcnumipar;                          /* number of instrument parameters */
extern char   mcinstrument_name[], mcinstrument_source[]; /* instrument name and filename */
extern char  *mcinstrument_exe;                           /* executable path = argv[0] or NULL */
extern MCNUM  mccomp_storein[]; /* 11 coords * number of components in instrument */
extern MCNUM  mcAbsorbProp[];
extern MCNUM  mcScattered;      /* number of SCATTER calls in current component */
extern MCNUM  mcRestore;        /* Flag to indicate if neutron needs to be restored */
#ifndef MC_ANCIENT_COMPATIBILITY
extern int mctraceenabled, mcdefaultmain;
#endif
#endif


/* Useful macros ============================================================ */

/* MPI stuff */

#ifdef USE_MPI
#include "mpi.h"

#ifdef OMPI_MPI_H  /* openmpi does not use signals: we may install our sighandler */
#undef NOSIGNALS
#endif

/*
 * MPI_MASTER(i):
 * execution of i only on master node
 */
#define MPI_MASTER(statement) { \
  if(mpi_node_rank == mpi_node_root)\
  { statement; } \
}

#ifndef MPI_REDUCE_BLOCKSIZE
#define MPI_REDUCE_BLOCKSIZE 1000
#endif

int mc_MPI_Sum(double* buf, long count);
int mc_MPI_Send(void *sbuf, long count, MPI_Datatype dtype, int dest);
int mc_MPI_Recv(void *rbuf, long count, MPI_Datatype dtype, int source);

/* MPI_Finalize exits gracefully and should be preferred to MPI_Abort */
#define exit(code) do {                                   \
    MPI_Finalize();                                       \
    exit(code);                                           \
  } while(0)

#else /* !USE_MPI */
#define MPI_MASTER(instr) instr
#endif /* USE_MPI */

#ifdef USE_MPI
static int mpi_node_count;
#endif

#ifdef USE_THREADS  /* user want threads */
#error Threading (USE_THREADS) support has been removed for very poor efficiency. Use MPI/SSH grid instead.
#endif


void   mcset_ncount(unsigned long long count);    /* wrapper to get mcncount */
unsigned long long int mcget_ncount(void);            /* wrapper to set mcncount */
unsigned long long mcget_run_num(void);           /* wrapper to get mcrun_num=0:mcncount */


/* Following part is only embedded when not redundant with mccode.h ========= */

#ifndef MCCODE_H

#ifndef NOSIGNALS
#include <signal.h>
#define SIG_MESSAGE(msg) strcpy(mcsig_message, msg);
#else
#define SIG_MESSAGE(msg)
#endif /* !NOSIGNALS */

/* Useful macros and constants ============================================== */

#ifndef FLT_MAX
#define FLT_MAX         3.40282347E+38F /* max decimal value of a "float" */
#endif

#ifndef MIN
#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
#endif
#ifndef SQR
#define SQR(x) ( (x) * (x) )
#endif
#ifndef SIGN
#define SIGN(x) (((x)>0.0)?(1):(-1))
#endif

#ifndef PI
# ifdef M_PI
#  define PI M_PI
# else
/* When using c99 in the CFLAGS, some of these consts
   are lost... Perhaps we should in fact include everything from
   https://www.gnu.org/software/libc/manual/html_node/Mathematical-Constants.html
*/
#  define PI 3.14159265358979323846
#  define M_PI PI
#  define M_PI_2 M_PI/2.0
#  define M_PI_4 M_PI/4.0
#  define M_1_PI 1.0/M_PI
#  define M_2_PI 2*M_1_PI
#  define M_2_SQRTPI 2/sqrt(M_PI)
#  define M_SQRT2 sqrt(2)
#  define M_SQRT1_2 sqrt(1/2)
# endif
#endif

#define RAD2MIN  ((180*60)/PI)
#define MIN2RAD  (PI/(180*60))
#define DEG2RAD  (PI/180)
#define RAD2DEG  (180/PI)
#define FWHM2RMS 0.424660900144    /* Convert between full-width-half-max and */
#define RMS2FWHM 2.35482004503     /* root-mean-square (standard deviation) */
#define HBAR     1.05457168e-34    /* [Js] h bar Planck constant CODATA 2002 */
#define MNEUTRON 1.67492728e-27    /* [kg] mass of neutron CODATA 2002 */
#define GRAVITY  9.81              /* [m/s^2] gravitational acceleration */
#define NA       6.02214179e23     /* [#atoms/g .mole] Avogadro's number*/


/* wrapper to get absolute and relative position of comp */
/* mccomp_posa and mccomp_posr are defined in McStas generated C code */
#define POS_A_COMP_INDEX(index) \
    (mccomp_posa[index])
#define POS_R_COMP_INDEX(index) \
    (mccomp_posr[index])
/* number of SCATTER calls in current comp: mcScattered defined in generated C code */
#define SCATTERED mcScattered
/* Flag to indicate if neutron needs to be restored: mcRestore defined in generated C code */
#define RESTORE mcRestore


/* Retrieve component information from the kernel */
/* Name, position and orientation (both absolute and relative)  */
/* Any component: For "redundancy", see comment by KN */
#define tmp_name_comp(comp) #comp
#define NAME_COMP(comp) tmp_name_comp(comp)
#define tmp_pos_a_comp(comp) (mcposa ## comp)
#define POS_A_COMP(comp) tmp_pos_a_comp(comp)
#define tmp_pos_r_comp(comp) (mcposr ## comp)
#define POS_R_COMP(comp) tmp_pos_r_comp(comp)
#define tmp_rot_a_comp(comp) (mcrota ## comp)
#define ROT_A_COMP(comp) tmp_rot_a_comp(comp)
#define tmp_rot_r_comp(comp) (mcrotr ## comp)
#define ROT_R_COMP(comp) tmp_rot_r_comp(comp)

/* Current component name, index, position and orientation */
#define NAME_CURRENT_COMP  NAME_COMP(mccompcurname)
#define INDEX_CURRENT_COMP mccompcurindex
#define POS_A_CURRENT_COMP POS_A_COMP(mccompcurname)
#define POS_R_CURRENT_COMP POS_R_COMP(mccompcurname)
#define ROT_A_CURRENT_COMP ROT_A_COMP(mccompcurname)
#define ROT_R_CURRENT_COMP ROT_R_COMP(mccompcurname)

/* Note: The two-stage approach to MC_GETPAR is NOT redundant; without it,
* after #define C sample, MC_GETPAR(C,x) would refer to component C, not to
* component sample. Such are the joys of ANSI C.

* Anyway the usage of MCGETPAR requires that we use sometimes bare names...
*/
#define MC_GETPAR2(comp, par) (mcc ## comp ## _ ## par)
#define MC_GETPAR(comp, par) MC_GETPAR2(comp,par)

/* MCDISPLAY/trace and debugging message sent to stdout */
#ifdef MC_TRACE_ENABLED
#define DEBUG
#endif

#ifdef DEBUG
#define mcDEBUG_INSTR() if(!mcdotrace); else { printf("\nINSTRUMENT:\n"); printf("Instrument '%s' (%s)\n", mcinstrument_name, mcinstrument_source); }
#define mcDEBUG_COMPONENT(name,c,t) if(!mcdotrace); else {\
  printf("COMPONENT: \"%s\"\n" \
         "POS: %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", \
         name, c.x, c.y, c.z, t[0][0], t[0][1], t[0][2], \
         t[1][0], t[1][1], t[1][2], t[2][0], t[2][1], t[2][2]); \
  mcAccumulatedILength += coords_len(coords_sub(mcLastComp,c)); \
  printf("Component %30s AT (%g,%g,%g)    %g m from origin\n", name, c.x, c.y, c.z, mcAccumulatedILength); \
  mcLastComp=c;\
  }
#define mcDEBUG_INSTR_END() if(!mcdotrace); else printf("INSTRUMENT END:\n");
#define mcDEBUG_ENTER() if(!mcdotrace); else printf("ENTER:\n");
#define mcDEBUG_COMP(c) if(!mcdotrace); else printf("COMP: \"%s\"\n", c);
#define mcDEBUG_LEAVE() if(!mcdotrace); else printf("LEAVE:\n");
#define mcDEBUG_ABSORB() if(!mcdotrace); else printf("ABSORB:\n");
#else
#define mcDEBUG_INSTR()
#define mcDEBUG_COMPONENT(name,c,t)
#define mcDEBUG_INSTR_END()
#define mcDEBUG_ENTER()
#define mcDEBUG_COMP(c)
#define mcDEBUG_LEAVE()
#define mcDEBUG_ABSORB()
#endif

// mcDEBUG_STATE and mcDEBUG_SCATTER are defined by mcstas-r.h and mcxtrace-r.h



#ifdef TEST
#define test_printf printf
#else
#define test_printf while(0) printf
#endif

/* send MCDISPLAY message to stdout to show gemoetry */
void mcdis_magnify(char *what);
void mcdis_line(double x1, double y1, double z1,
                double x2, double y2, double z2);
void mcdis_dashed_linemcdis_dashed_line(double x1, double y1, double z1,
		       double x2, double y2, double z2, int n);
void mcdis_multiline(int count, ...);
void mcdis_rectangle(char* plane, double x, double y, double z,
		     double width, double height);
void mcdis_box(double x, double y, double z,
	       double width, double height, double length);
void mcdis_circle(char *plane, double x, double y, double z, double r);
void mcdis_Circle(double x, double y, double z, double r, double nx, double ny, double nz);
void mcdis_cylinder( double x, double y, double z,
        double r, double height, int N, double nx, double ny, double nz);
void mcdis_sphere(double x, double y, double z, double r, int N);

/* selection of random number generator. default is MT */
#ifndef MC_RAND_ALG
#define MC_RAND_ALG 1
#endif

#if MC_RAND_ALG == 0
   /* Use system random() (not recommended). */
#  define MC_RAND_MAX RAND_MAX
#elif MC_RAND_ALG == 1
   /* "Mersenne Twister", by Makoto Matsumoto and Takuji Nishimura. */
#  define MC_RAND_MAX ((unsigned long)0xffffffff)
#  define random mt_random
#  define srandom mt_srandom
#elif MC_RAND_ALG == 2
   /* Algorithm used in McStas CVS-080208 and earlier (not recommended). */
#  define MC_RAND_MAX 0x7fffffff
#  define random mc_random
#  define srandom mc_srandom
#else
#  error "Bad value for random number generator choice."
#endif

typedef int mc_int32_t;
mc_int32_t mc_random(void);
void mc_srandom (unsigned int x);
unsigned long mt_random(void);
void mt_srandom (unsigned long x);

double rand01();
double randpm1();
double rand0max(double max);
double randminmax(double min, double max);

double randnorm(void);
double randtriangle(void);

#ifndef DANSE
void mcinit(void);
void mcraytrace(void);
void mcsave(FILE *);
void mcfinally(void);
void mcdisplay(void);
#endif

/* simple vector algebra ==================================================== */
#define vec_prod(x, y, z, x1, y1, z1, x2, y2, z2) \
	vec_prod_func(&x, &y, &z, x1, y1, z1, x2, y2, z2)
mcstatic void vec_prod_func(double *x, double *y, double *z,
		double x1, double y1, double z1, double x2, double y2, double z2);

mcstatic double scalar_prod(
		double x1, double y1, double z1, double x2, double y2, double z2);

#define NORM(x,y,z) \
	norm_func(&x, &y, &z)
mcstatic void norm_func(double *x, double *y, double *z) {
	double temp = (*x * *x) + (*y * *y) + (*z * *z);
	if (temp != 0) {
		temp = sqrt(temp);
		*x /= temp;
		*y /= temp;
		*z /= temp;
	}
}
#define normal_vec(nx, ny, nz, x, y, z) \
    normal_vec_func(&(nx), &(ny), &(nz), x, y, z)
mcstatic void normal_vec_func(double *nx, double *ny, double *nz,
    double x, double y, double z);

/**
 * Rotate the vector vx,vy,vz psi radians around the vector ax,ay,az
 * and put the result in x,y,z.
 */
#define rotate(x, y, z, vx, vy, vz, phi, ax, ay, az) \
  do { \
    double mcrt_tmpx = (ax), mcrt_tmpy = (ay), mcrt_tmpz = (az); \
    double mcrt_vp, mcrt_vpx, mcrt_vpy, mcrt_vpz; \
    double mcrt_vnx, mcrt_vny, mcrt_vnz, mcrt_vn1x, mcrt_vn1y, mcrt_vn1z; \
    double mcrt_bx, mcrt_by, mcrt_bz; \
    double mcrt_cos, mcrt_sin; \
    NORM(mcrt_tmpx, mcrt_tmpy, mcrt_tmpz); \
    mcrt_vp = scalar_prod((vx), (vy), (vz), mcrt_tmpx, mcrt_tmpy, mcrt_tmpz); \
    mcrt_vpx = mcrt_vp*mcrt_tmpx; \
    mcrt_vpy = mcrt_vp*mcrt_tmpy; \
    mcrt_vpz = mcrt_vp*mcrt_tmpz; \
    mcrt_vnx = (vx) - mcrt_vpx; \
    mcrt_vny = (vy) - mcrt_vpy; \
    mcrt_vnz = (vz) - mcrt_vpz; \
    vec_prod(mcrt_bx, mcrt_by, mcrt_bz, \
             mcrt_tmpx, mcrt_tmpy, mcrt_tmpz, mcrt_vnx, mcrt_vny, mcrt_vnz); \
    mcrt_cos = cos((phi)); mcrt_sin = sin((phi)); \
    mcrt_vn1x = mcrt_vnx*mcrt_cos + mcrt_bx*mcrt_sin; \
    mcrt_vn1y = mcrt_vny*mcrt_cos + mcrt_by*mcrt_sin; \
    mcrt_vn1z = mcrt_vnz*mcrt_cos + mcrt_bz*mcrt_sin; \
    (x) = mcrt_vpx + mcrt_vn1x; \
    (y) = mcrt_vpy + mcrt_vn1y; \
    (z) = mcrt_vpz + mcrt_vn1z; \
  } while(0)

/**
 * Mirror (xyz) in the plane given by the point (rx,ry,rz) and normal (nx,ny,nz)
 *
 * TODO: This define is seemingly never used...
 */
#define mirror(x,y,z,rx,ry,rz,nx,ny,nz) \
  do { \
    double mcrt_tmpx= (nx), mcrt_tmpy = (ny), mcrt_tmpz = (nz); \
    double mcrt_tmpt; \
    NORM(mcrt_tmpx, mcrt_tmpy, mcrt_tmpz); \
    mcrt_tmpt=scalar_prod((rx),(ry),(rz),mcrt_tmpx,mcrt_tmpy,mcrt_tmpz); \
    (x) = rx -2 * mcrt_tmpt*mcrt_rmpx; \
    (y) = ry -2 * mcrt_tmpt*mcrt_rmpy; \
    (z) = rz -2 * mcrt_tmpt*mcrt_rmpz; \
  } while (0)

Coords coords_set(MCNUM x, MCNUM y, MCNUM z);
Coords coords_get(Coords a, MCNUM *x, MCNUM *y, MCNUM *z);
Coords coords_add(Coords a, Coords b);
Coords coords_sub(Coords a, Coords b);
Coords coords_neg(Coords a);
Coords coords_scale(Coords b, double scale);
double coords_sp(Coords a, Coords b);
Coords coords_xp(Coords b, Coords c);
double coords_len(Coords a);
void   coords_print(Coords a);
mcstatic void coords_norm(Coords* c);

void rot_set_rotation(Rotation t, double phx, double phy, double phz);
int  rot_test_identity(Rotation t);
void rot_mul(Rotation t1, Rotation t2, Rotation t3);
void rot_copy(Rotation dest, Rotation src);
void rot_transpose(Rotation src, Rotation dst);
Coords rot_apply(Rotation t, Coords a);

void mccoordschange(Coords a, Rotation t, double *x, double *y, double *z,
    double *vx, double *vy, double *vz, double *sx, double *sy, double *sz);
void
mccoordschange_polarisation(Rotation t, double *sx, double *sy, double *sz);

double mcestimate_error(double N, double p1, double p2);
void mcreadparams(void);

/* this is now in mcstas-r.h and mcxtrace-r.h as the number of state parameters is no longer equal*/
/* void mcsetstate(double x, double y, double z, double vx, double vy, double vz,
                double t, double sx, double sy, double sz, double p);
*/
void mcgenstate(void);

/* trajectory/shape intersection routines */
int inside_rectangle(double, double, double, double);
int box_intersect(double *dt_in, double *dt_out, double x, double y, double z,
    double vx, double vy, double vz, double dx, double dy, double dz);
int cylinder_intersect(double *t0, double *t1, double x, double y, double z,
    double vx, double vy, double vz, double r, double h);
int sphere_intersect(double *t0, double *t1, double x, double y, double z,
                 double vx, double vy, double vz, double r);
/* second order equation roots */
int solve_2nd_order(double *t1, double *t2,
    double A,  double B,  double C);

/* random vector generation to shape */
void randvec_target_circle(double *xo, double *yo, double *zo,
    double *solid_angle, double xi, double yi, double zi, double radius);
#define randvec_target_sphere randvec_target_circle
void randvec_target_rect_angular(double *xo, double *yo, double *zo,
    double *solid_angle,
               double xi, double yi, double zi, double height, double width, Rotation A);
#define randvec_target_rect(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9)  randvec_target_rect_real(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,0,0,0,1)
void randvec_target_rect_real(double *xo, double *yo, double *zo,
    double *solid_angle,
	       double xi, double yi, double zi, double height, double width, Rotation A,
			 double lx, double ly, double lz, int order);

/* this is the main() */
int mccode_main(int argc, char *argv[]);


#endif /* !MCCODE_H */

#ifndef MCCODE_R_IO_H
#define MCCODE_R_IO_H "$Revision$"

#if (USE_NEXUS == 0)
#undef USE_NEXUS
#endif

#ifndef CHAR_BUF_LENGTH
#define CHAR_BUF_LENGTH 1024
#endif

/* I/O section part ========================================================= */

/* ========================================================================== */

/*                               MCCODE_R_IO_C                                */

/* ========================================================================== */


/* main DETECTOR structure which stores most information to write to data files */
struct mcdetector_struct {
  char   filename[CHAR_BUF_LENGTH];   /* file name of monitor */
  char   position[CHAR_BUF_LENGTH];   /* position of detector component */
  char   component[CHAR_BUF_LENGTH];  /* component instance name */
  char   instrument[CHAR_BUF_LENGTH]; /* instrument name */
  char   type[CHAR_BUF_LENGTH];       /* data type, e.g. 0d, 1d, 2d, 3d */
  char   user[CHAR_BUF_LENGTH];       /* user name, e.g. HOME */
  char   date[CHAR_BUF_LENGTH];       /* date of simulation end/write time */
  char   title[CHAR_BUF_LENGTH];      /* title of detector */
  char   xlabel[CHAR_BUF_LENGTH];     /* X axis label */
  char   ylabel[CHAR_BUF_LENGTH];     /* Y axis label */
  char   zlabel[CHAR_BUF_LENGTH];     /* Z axis label */
  char   xvar[CHAR_BUF_LENGTH];       /* X variable name */
  char   yvar[CHAR_BUF_LENGTH];       /* Y variable name */
  char   zvar[CHAR_BUF_LENGTH];       /* Z variable name */
  char   ncount[CHAR_BUF_LENGTH];     /* number of events initially generated */
  char   limits[CHAR_BUF_LENGTH];     /* X Y Z limits, e.g. [xmin xmax ymin ymax zmin zmax] */
  char   variables[CHAR_BUF_LENGTH];  /* variables written into data block */
  char   statistics[CHAR_BUF_LENGTH]; /* center, mean and half width along axis */
  char   signal[CHAR_BUF_LENGTH];     /* min max and mean of signal (data block) */
  char   values[CHAR_BUF_LENGTH];     /* integrated values e.g. [I I_err N] */
  double xmin,xmax;                   /* min max of axes */
  double ymin,ymax;
  double zmin,zmax;
  double intensity;                   /* integrated values for data block */
  double error;
  double events;
  double min;                         /* statistics for data block */
  double max;
  double mean;
  double centerX;                     /* statistics for axes */
  double halfwidthX;
  double centerY;
  double halfwidthY;
  int    rank;                        /* dimensionaly of monitor, e.g. 0 1 2 3 */
  char   istransposed;                /* flag to transpose matrix for some formats */

  long   m,n,p;                       /* dimensions of data block and along axes */
  long   date_l;                      /* same as date, but in sec since 1970 */

  double *p0, *p1, *p2;               /* pointers to saved data, NULL when freed */
  char   format[CHAR_BUF_LENGTH];    /* format for file generation */
};

typedef struct mcdetector_struct MCDETECTOR;

static   char *mcdirname             = NULL;      /* name of output directory */
static   char *mcsiminfo_name        = "mccode";  /* default output sim file name */
char    *mcformat                    = NULL;      /* NULL (default) or a specific format */

/* file I/O definitions and function prototypes */

#ifndef MC_EMBEDDED_RUNTIME /* the mcstatic variables (from mccode-r.c) */
extern FILE * mcsiminfo_file;     /* handle to the output siminfo file */
extern int    mcgravitation;      /* flag to enable gravitation */
extern int    mcdotrace;          /* flag to print MCDISPLAY messages */
#else
mcstatic FILE *mcsiminfo_file        = NULL;
#endif

/* I/O function prototypes ================================================== */

/* output functions */
MCDETECTOR mcdetector_out_0D(char *t, double p0, double p1, double p2, char *c, Coords pos);
MCDETECTOR mcdetector_out_1D(char *t, char *xl, char *yl,
                  char *xvar, double x1, double x2, long n,
                  double *p0, double *p1, double *p2, char *f, char *c, Coords pos);
MCDETECTOR mcdetector_out_2D(char *t, char *xl, char *yl,
                  double x1, double x2, double y1, double y2, long m,
                  long n, double *p0, double *p1, double *p2, char *f,
                  char *c, Coords pos);
MCDETECTOR mcdetector_out_list(char *t, char *xl, char *yl,
                  long m, long n,
                  double *p1, char *f,
                  char *c, Coords posa);

/* wrappers to output functions, that automatically set NAME and POSITION */
#define DETECTOR_OUT(p0,p1,p2) mcdetector_out_0D(NAME_CURRENT_COMP,p0,p1,p2,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)
#define DETECTOR_OUT_0D(t,p0,p1,p2) mcdetector_out_0D(t,p0,p1,p2,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)
#define DETECTOR_OUT_1D(t,xl,yl,xvar,x1,x2,n,p0,p1,p2,f) \
     mcdetector_out_1D(t,xl,yl,xvar,x1,x2,n,p0,p1,p2,f,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)
#define DETECTOR_OUT_2D(t,xl,yl,x1,x2,y1,y2,m,n,p0,p1,p2,f) \
     mcdetector_out_2D(t,xl,yl,x1,x2,y1,y2,m,n,p0,p1,p2,f,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)

#ifdef USE_NEXUS
#include "napi.h"
NXhandle nxhandle;
#endif

#endif /* ndef MCCODE_R_IO_H */

#endif /* MCCODE_R_H */
/* End of file "mccode-r.h". */

#line 712 "./SNS_BASIS.c"

#line 1 "mcstas-r.h"
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mcstas-r.h
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McStas X.Y
* Version: $Revision$
*
* Runtime system header for McStas.
*
* In order to use this library as an external library, the following variables
* and macros must be declared (see details in the code)
*
*   struct mcinputtable_struct mcinputtable[];
*   int mcnumipar;
*   char mcinstrument_name[], mcinstrument_source[];
*   int mctraceenabled, mcdefaultmain;
*   extern MCNUM  mccomp_storein[];
*   extern MCNUM  mcAbsorbProp[];
*   extern MCNUM  mcScattered;
*   #define MCCODE_STRING "the McStas version"
*
* Usage: Automatically embbeded in the c code.
*
* $Id$
*
*******************************************************************************/

#ifndef MCSTAS_R_H
#define MCSTAS_R_H "$Revision$"

/* Following part is only embedded when not redundent with mcstas.h ========= */

#ifndef MCCODE_H

#define AA2MS    629.622368        /* Convert k[1/AA] to v[m/s] */
#define MS2AA    1.58825361e-3     /* Convert v[m/s] to k[1/AA] */
#define K2V      AA2MS
#define V2K      MS2AA
#define Q2V      AA2MS
#define V2Q      MS2AA
#define SE2V     437.393377        /* Convert sqrt(E)[meV] to v[m/s] */
#define VS2E     5.22703725e-6     /* Convert (v[m/s])**2 to E[meV] */

#define SCATTER do {mcDEBUG_SCATTER(mcnlx, mcnly, mcnlz, mcnlvx, mcnlvy, mcnlvz, \
        mcnlt,mcnlsx,mcnlsy,mcnlsz, mcnlp); mcScattered++;} while(0)
#define ABSORB do {mcDEBUG_STATE(mcnlx, mcnly, mcnlz, mcnlvx, mcnlvy, mcnlvz, \
        mcnlt,mcnlsx,mcnlsy,mcnlsz, mcnlp); mcDEBUG_ABSORB(); MAGNET_OFF; goto mcabsorb;} while(0)

#define STORE_NEUTRON(index, x, y, z, vx, vy, vz, t, sx, sy, sz, p) \
  mcstore_neutron(mccomp_storein,index, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
#define RESTORE_NEUTRON(index, x, y, z, vx, vy, vz, t, sx, sy, sz, p) \
  mcrestore_neutron(mccomp_storein,index, &x, &y, &z, &vx, &vy, &vz, &t, &sx, &sy, &sz, &p);

#define MAGNET_ON \
  do { \
    mcMagnet = 1; \
  } while(0)

#define MAGNET_OFF \
  do { \
    mcMagnet = 0; \
  } while(0)

#define ALLOW_BACKPROP \
  do { \
    mcallowbackprop = 1; \
  } while(0)

#define DISALLOW_BACKPROP \
  do { \
    mcallowbackprop = 0; \
  } while(0)

#define PROP_MAGNET(dt) \
  do { \
  }while (0)
    /* change coordinates from local system to magnet system */
/*    Rotation rotLM, rotTemp; \
      Coords   posLM = coords_sub(POS_A_CURRENT_COMP, mcMagnetPos); \
      rot_transpose(ROT_A_CURRENT_COMP, rotTemp); \
      rot_mul(rotTemp, mcMagnetRot, rotLM); \
      mcMagnetPrecession(mcnlx, mcnly, mcnlz, mcnlt, mcnlvx, mcnlvy, mcnlvz, \
               &mcnlsx, &mcnlsy, &mcnlsz, dt, posLM, rotLM); \
      } while(0)
*/

#define mcPROP_DT(dt) \
  do { \
    if (mcMagnet && dt > 0) PROP_MAGNET(dt);\
    mcnlx += mcnlvx*(dt); \
    mcnly += mcnlvy*(dt); \
    mcnlz += mcnlvz*(dt); \
    mcnlt += (dt); \
    if (isnan(p) || isinf(p)) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }\
  } while(0)

/* ADD: E. Farhi, Aug 6th, 2001 PROP_GRAV_DT propagation with acceleration */
#define PROP_GRAV_DT(dt, Ax, Ay, Az) \
  do { \
    if(dt < 0 && mcallowbackprop == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }\
    if (mcMagnet) printf("Spin precession gravity\n"); \
    mcnlx  += mcnlvx*(dt) + (Ax)*(dt)*(dt)/2; \
    mcnly  += mcnlvy*(dt) + (Ay)*(dt)*(dt)/2; \
    mcnlz  += mcnlvz*(dt) + (Az)*(dt)*(dt)/2; \
    mcnlvx += (Ax)*(dt); \
    mcnlvy += (Ay)*(dt); \
    mcnlvz += (Az)*(dt); \
    mcnlt  += (dt); \
    DISALLOW_BACKPROP;\
  } while(0)


#define PROP_DT(dt) \
  do { \
    if(dt < 0) { RESTORE=1; goto mcabsorbComp; }; \
    if (mcgravitation) { Coords mcLocG; double mc_gx, mc_gy, mc_gz; \
    mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,-GRAVITY,0)); \
    coords_get(mcLocG, &mc_gx, &mc_gy, &mc_gz); \
    PROP_GRAV_DT(dt, mc_gx, mc_gy, mc_gz); } \
    else mcPROP_DT(dt); \
    DISALLOW_BACKPROP;\
  } while(0)


#define PROP_Z0 \
  do { \
    if (mcgravitation) { Coords mcLocG; int mc_ret; \
    double mc_dt, mc_gx, mc_gy, mc_gz; \
    mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,-GRAVITY,0)); \
    coords_get(mcLocG, &mc_gx, &mc_gy, &mc_gz); \
    mc_ret = solve_2nd_order(&mc_dt, NULL, -mc_gz/2, -mcnlvz, -mcnlz); \
    if (mc_ret && mc_dt>=0) {PROP_GRAV_DT(mc_dt, mc_gx, mc_gy, mc_gz); mcnlz=0;}\
    else { if (mcallowbackprop ==0) {mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }}; }\
    else mcPROP_Z0; \
    DISALLOW_BACKPROP;\
  } while(0)

#define mcPROP_Z0 \
  do { \
    double mc_dt; \
    if(mcnlvz == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mc_dt = -mcnlz/mcnlvz; \
    if(mc_dt < 0 && mcallowbackprop == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mcPROP_DT(mc_dt); \
    mcnlz = 0; \
    DISALLOW_BACKPROP;\
  } while(0)

#define PROP_X0 \
  do { \
    if (mcgravitation) { Coords mcLocG; int mc_ret; \
    double mc_dt, mc_gx, mc_gy, mc_gz; \
    mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,-GRAVITY,0)); \
    coords_get(mcLocG, &mc_gx, &mc_gy, &mc_gz); \
    mc_ret = solve_2nd_order(&mc_dt, NULL, -mc_gx/2, -mcnlvx, -mcnlx); \
    if (mc_ret && mc_dt>=0) PROP_GRAV_DT(mc_dt, mc_gx, mc_gy, mc_gz); \
    else { if (mcallowbackprop ==0) {mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }}; }\
    else mcPROP_X0; \
    DISALLOW_BACKPROP;\
  } while(0)

#define mcPROP_X0 \
  do { \
    double mc_dt; \
    if(mcnlvx == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mc_dt = -mcnlx/mcnlvx; \
    if(mc_dt < 0 && mcallowbackprop == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mcPROP_DT(mc_dt); \
    mcnlx = 0; \
    DISALLOW_BACKPROP;\
  } while(0)

#define PROP_Y0 \
  do { \
    if (mcgravitation) { Coords mcLocG; int mc_ret; \
    double mc_dt, mc_gx, mc_gy, mc_gz; \
    mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,-GRAVITY,0)); \
    coords_get(mcLocG, &mc_gx, &mc_gy, &mc_gz); \
    mc_ret = solve_2nd_order(&mc_dt, NULL, -mc_gy/2, -mcnlvy, -mcnly); \
    if (mc_ret && mc_dt>=0) PROP_GRAV_DT(mc_dt, mc_gx, mc_gy, mc_gz); \
    else { if (mcallowbackprop ==0) {mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }}; }\
    else mcPROP_Y0; \
    DISALLOW_BACKPROP;\
  } while(0)


#define mcPROP_Y0 \
  do { \
    double mc_dt; \
    if(mcnlvy == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mc_dt = -mcnly/mcnlvy; \
    if(mc_dt < 0 && mcallowbackprop == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mcPROP_DT(mc_dt); \
    mcnly = 0; \
    DISALLOW_BACKPROP; \
  } while(0)

/*moved from mccode-r.h*/
void mcsetstate(double x, double y, double z, double vx, double vy, double vz,
                double t, double sx, double sy, double sz, double p);

#ifdef DEBUG

#define mcDEBUG_STATE(x,y,z,vx,vy,vz,t,sx,sy,sz,p) if(!mcdotrace); else \
  printf("STATE: %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", \
         x,y,z,vx,vy,vz,t,sx,sy,sz,p);
#define mcDEBUG_SCATTER(x,y,z,vx,vy,vz,t,sx,sy,sz,p) if(!mcdotrace); else \
  printf("SCATTER: %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", \
         x,y,z,vx,vy,vz,t,sx,sy,sz,p);

#else

#define mcDEBUG_STATE(x,y,z,vx,vy,vz,t,sx,sy,sz,p)
#define mcDEBUG_SCATTER(x,y,z,vx,vy,vz,t,sx,sy,sz,p)

#endif

#endif /* !MCCODE_H */

#endif /* MCSTAS_R_H */
/* End of file "mcstas-r.h". */

#line 945 "./SNS_BASIS.c"

#line 1 "mccode-r.c"
/*******************************************************************************
*
* McCode, neutron/xray ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mccode-r.c
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McStas X.Y/McXtrace X.Y
* Version: $Revision$
*
* Runtime system for McStas and McXtrace.
* Embedded within instrument in runtime mode.
* Contains SECTIONS:
*   MPI handling (sum, send, recv)
*   format definitions
*   I/O
*   mcdisplay support
*   random numbers
*   coordinates handling
*   vectors math (solve 2nd order, normals, randvec...)
*   parameter handling
*   signal and main handlers
*
* Usage: Automatically embbeded in the c code whenever required.
*
* $Id$
*
*******************************************************************************/

/*******************************************************************************
* The I/O format definitions and functions
*******************************************************************************/


/** Include header files to avoid implicit declarations (not allowed on LLVM) */
#include <ctype.h>
#include <sys/types.h>

// UNIX specific headers (non-Windows)
#if defined(__unix__) || defined(__APPLE__)
#include <unistd.h>
#endif

#include <sys/stat.h>

#ifdef _WIN32 
#include <direct.h>
# define  mkdir( D, M )   _mkdir( D ) 
#endif 

#ifndef DANSE
#ifdef MC_ANCIENT_COMPATIBILITY
int mctraceenabled = 0;
int mcdefaultmain  = 0;
#endif
/* else defined directly in the McCode generated C code */

static   long mcseed                 = 0; /* seed for random generator */
static   long mcstartdate            = 0; /* start simulation time */
static   int  mcdisable_output_files = 0; /* --no-output-files */
mcstatic int  mcgravitation          = 0; /* use gravitation flag, for PROP macros */
int      mcMagnet                    = 0; /* magnet stack flag */
mcstatic int  mcdotrace              = 0; /* flag for --trace and messages for DISPLAY */
int      mcallowbackprop             = 0;         /* flag to enable negative/backprop */

/* Number of particle histories to simulate. */
#ifdef NEUTRONICS
mcstatic unsigned long long int mcncount             = 1;
mcstatic unsigned long long int mcrun_num            = 0;
#else
mcstatic unsigned long long int mcncount             = 1000000;
mcstatic unsigned long long int mcrun_num            = 0;
#endif /* NEUTRONICS */

#else
#include "mcstas-globals.h"
#endif /* !DANSE */

/* SECTION: MPI handling ==================================================== */

#ifdef USE_MPI
/* MPI rank */
static int mpi_node_rank;
static int mpi_node_root = 0;


/*******************************************************************************
* mc_MPI_Reduce: Gathers arrays from MPI nodes using Reduce function.
*******************************************************************************/
int mc_MPI_Sum(double *sbuf, long count)
{
  if (!sbuf || count <= 0) return(MPI_SUCCESS); /* nothing to reduce */
  else {
    /* we must cut the buffer into blocks not exceeding the MPI max buffer size of 32000 */
    long   offset=0;
    double *rbuf=NULL;
    int    length=MPI_REDUCE_BLOCKSIZE; /* defined in mccode-r.h */
    int    i=0;
    rbuf = calloc(count, sizeof(double));
    if (!rbuf)
      exit(-fprintf(stderr, "Error: Out of memory %li (mc_MPI_Sum)\n", count*sizeof(double)));
    while (offset < count) {
      if (!length || offset+length > count-1) length=count-offset;
      else length=MPI_REDUCE_BLOCKSIZE;
      if (MPI_Reduce((double*)(sbuf+offset), (double*)(rbuf+offset),
              length, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD) != MPI_SUCCESS)
        return MPI_ERR_COUNT;
      offset += length;
    }

    for (i=0; i<count; i++) sbuf[i] = rbuf[i];
    free(rbuf);
  }
  return MPI_SUCCESS;
} /* mc_MPI_Sum */

/*******************************************************************************
* mc_MPI_Send: Send array to MPI node by blocks to avoid buffer limit
*******************************************************************************/
int mc_MPI_Send(void *sbuf,
                  long count, MPI_Datatype dtype,
                  int dest)
{
  int dsize;
  long offset=0;
  int  tag=1;
  int  length=MPI_REDUCE_BLOCKSIZE; /* defined in mccode-r.h */

  if (!sbuf || count <= 0) return(MPI_SUCCESS); /* nothing to send */
  MPI_Type_size(dtype, &dsize);

  while (offset < count) {
    if (offset+length > count-1) length=count-offset;
    else length=MPI_REDUCE_BLOCKSIZE;
    if (MPI_Send((void*)(sbuf+offset*dsize), length, dtype, dest, tag++, MPI_COMM_WORLD) != MPI_SUCCESS)
      return MPI_ERR_COUNT;
    offset += length;
  }

  return MPI_SUCCESS;
} /* mc_MPI_Send */

/*******************************************************************************
* mc_MPI_Recv: Receives arrays from MPI nodes by blocks to avoid buffer limit
*             the buffer must have been allocated previously.
*******************************************************************************/
int mc_MPI_Recv(void *sbuf,
                  long count, MPI_Datatype dtype,
                  int source)
{
  int dsize;
  long offset=0;
  int  tag=1;
  int  length=MPI_REDUCE_BLOCKSIZE; /* defined in mccode-r.h */

  if (!sbuf || count <= 0) return(MPI_SUCCESS); /* nothing to recv */
  MPI_Type_size(dtype, &dsize);

  while (offset < count) {
    if (offset+length > count-1) length=count-offset;
    else length=MPI_REDUCE_BLOCKSIZE;
    if (MPI_Recv((void*)(sbuf+offset*dsize), length, dtype, source, tag++,
            MPI_COMM_WORLD, MPI_STATUS_IGNORE) != MPI_SUCCESS)
      return MPI_ERR_COUNT;
    offset += length;
  }

  return MPI_SUCCESS;
} /* mc_MPI_Recv */

#endif /* USE_MPI */

/* SECTION: parameters handling ============================================= */

/* Instrument input parameter type handling. */
/*******************************************************************************
* mcparm_double: extract double value from 's' into 'vptr'
*******************************************************************************/
static int
mcparm_double(char *s, void *vptr)
{
  char *p;
  double *v = (double *)vptr;

  if (!s) { *v = 0; return(1); }
  *v = strtod(s, &p);
  if(*s == '\0' || (p != NULL && *p != '\0') || errno == ERANGE)
    return 0;                        /* Failed */
  else
    return 1;                        /* Success */
}

/*******************************************************************************
* mcparminfo_double: display parameter type double
*******************************************************************************/
static char *
mcparminfo_double(char *parmname)
{
  return "double";
}

/*******************************************************************************
* mcparmerror_double: display error message when failed extract double
*******************************************************************************/
static void
mcparmerror_double(char *parm, char *val)
{
  fprintf(stderr, "Error: Invalid value '%s' for floating point parameter %s (mcparmerror_double)\n",
          val, parm);
}

/*******************************************************************************
* mcparmprinter_double: convert double to string
*******************************************************************************/
static void
mcparmprinter_double(char *f, void *vptr)
{
  double *v = (double *)vptr;
  sprintf(f, "%g", *v);
}

/*******************************************************************************
* mcparm_int: extract int value from 's' into 'vptr'
*******************************************************************************/
static int
mcparm_int(char *s, void *vptr)
{
  char *p;
  int *v = (int *)vptr;
  long x;

  if (!s) { *v = 0; return(1); }
  *v = 0;
  x = strtol(s, &p, 10);
  if(x < INT_MIN || x > INT_MAX)
    return 0;                        /* Under/overflow */
  *v = x;
  if(*s == '\0' || (p != NULL && *p != '\0') || errno == ERANGE)
    return 0;                        /* Failed */
  else
    return 1;                        /* Success */
}

/*******************************************************************************
* mcparminfo_int: display parameter type int
*******************************************************************************/
static char *
mcparminfo_int(char *parmname)
{
  return "int";
}

/*******************************************************************************
* mcparmerror_int: display error message when failed extract int
*******************************************************************************/
static void
mcparmerror_int(char *parm, char *val)
{
  fprintf(stderr, "Error: Invalid value '%s' for integer parameter %s (mcparmerror_int)\n",
          val, parm);
}

/*******************************************************************************
* mcparmprinter_int: convert int to string
*******************************************************************************/
static void
mcparmprinter_int(char *f, void *vptr)
{
  int *v = (int *)vptr;
  sprintf(f, "%d", *v);
}

/*******************************************************************************
* mcparm_string: extract char* value from 's' into 'vptr' (copy)
*******************************************************************************/
static int
mcparm_string(char *s, void *vptr)
{
  char **v = (char **)vptr;
  if (!s) { *v = NULL; return(1); }
  *v = (char *)malloc(strlen(s) + 1);
  if(*v == NULL)
  {
    exit(-fprintf(stderr, "Error: Out of memory %li (mcparm_string).\n", (long)strlen(s) + 1));
  }
  strcpy(*v, s);
  return 1;                        /* Success */
}

/*******************************************************************************
* mcparminfo_string: display parameter type string
*******************************************************************************/
static char *
mcparminfo_string(char *parmname)
{
  return "string";
}

/*******************************************************************************
* mcparmerror_string: display error message when failed extract string
*******************************************************************************/
static void
mcparmerror_string(char *parm, char *val)
{
  fprintf(stderr, "Error: Invalid value '%s' for string parameter %s (mcparmerror_string)\n",
          val, parm);
}

/*******************************************************************************
* mcparmprinter_string: convert string to string (including esc chars)
*******************************************************************************/
static void
mcparmprinter_string(char *f, void *vptr)
{
  char **v = (char **)vptr;
  char *p;

  if (!*v) { *f='\0'; return; }
  strcpy(f, "");
  for(p = *v; *p != '\0'; p++)
  {
    switch(*p)
    {
      case '\n':
        strcat(f, "\\n");
        break;
      case '\r':
        strcat(f, "\\r");
        break;
      case '"':
        strcat(f, "\\\"");
        break;
      case '\\':
        strcat(f, "\\\\");
        break;
      default:
        strncat(f, p, 1);
    }
  }
  /* strcat(f, "\""); */
} /* mcparmprinter_string */

/* now we may define the parameter structure, using previous functions */
static struct
  {
    int (*getparm)(char *, void *);
    char * (*parminfo)(char *);
    void (*error)(char *, char *);
    void (*printer)(char *, void *);
} mcinputtypes[] = {
  {
    mcparm_double, mcparminfo_double, mcparmerror_double,
    mcparmprinter_double
  }, {
    mcparm_int, mcparminfo_int, mcparmerror_int,
    mcparmprinter_int
  }, {
    mcparm_string, mcparminfo_string, mcparmerror_string,
    mcparmprinter_string
  }
};

/*******************************************************************************
* mcestimate_error: compute sigma from N,p,p2 in Gaussian large numbers approx
*******************************************************************************/
double mcestimate_error(double N, double p1, double p2)
{
  double pmean, n1;
  if(N <= 1)
    return p1;
  pmean = p1 / N;
  n1 = N - 1;
  /* Note: underflow may cause p2 to become zero; the fabs() below guards
     against this. */
  return sqrt((N/n1)*fabs(p2 - pmean*pmean));
}

double (*mcestimate_error_p)
  (double V2, double psum, double p2sum)=mcestimate_error;

/* ========================================================================== */

/*                               MCCODE_R_IO_C                                */

/* ========================================================================== */

#ifndef MCCODE_R_IO_C
#define MCCODE_R_IO_C "$Revision$"

/* SECTION: file i/o handling ================================================ */

#ifndef HAVE_STRCASESTR
// from msysgit: https://code.google.com/p/msysgit/source/browse/compat/strcasestr.c
char *strcasestr(const char *haystack, const char *needle)
{
  int nlen = strlen(needle);
  int hlen = strlen(haystack) - nlen + 1;
  int i;

  for (i = 0; i < hlen; i++) {
    int j;
    for (j = 0; j < nlen; j++) {
            unsigned char c1 = haystack[i+j];
            unsigned char c2 = needle[j];
            if (toupper(c1) != toupper(c2))
                    goto next;
    }
    return (char *) haystack + i;
  next:
    ;
  }
  return NULL;
}


#endif
#ifndef HAVE_STRCASECMP
int strcasecmp( const char *s1, const char *s2 )
{
  int c1, c2;
  do {
    c1 = tolower( (unsigned char) *s1++ );
    c2 = tolower( (unsigned char) *s2++ );
  } while (c1 == c2 && c1 != 0);
  return c2 > c1 ? -1 : c1 > c2;
}
#endif

/*******************************************************************************
* mcfull_file: allocates a full file name=mcdirname+file. Catenate extension if missing.
*******************************************************************************/
char *mcfull_file(char *name, char *ext)
{
  int   dirlen=0;
  char *mem   =NULL;

  dirlen = mcdirname ? strlen(mcdirname) : 0;
  mem = (char*)malloc(dirlen + strlen(name) + CHAR_BUF_LENGTH);
  if(!mem) {
    exit(-fprintf(stderr, "Error: Out of memory %li (mcfull_file)\n", (long)(dirlen + strlen(name) + 256)));
  }
  strcpy(mem, "");

  /* prepend directory name to path if name does not contain a path */
  if (dirlen > 0 && !strchr(name, MC_PATHSEP_C)) {
    strcat(mem, mcdirname);
    strcat(mem, MC_PATHSEP_S);
  } /* dirlen */

  strcat(mem, name);
  if (!strchr(name, '.') && ext && strlen(ext))
  { /* add extension if not in file name already */
    strcat(mem, ".");
    strcat(mem, ext);
  }
  return(mem);
} /* mcfull_file */

/*******************************************************************************
* mcnew_file: opens a new file within mcdirname if non NULL
*             the file is opened in "a" (append, create if does not exist)
*             the extension 'ext' is added if the file name does not include one.
*             the last argument is set to 0 if file did not exist, else to 1.
*******************************************************************************/
FILE *mcnew_file(char *name, char *ext, int *exists)
{
  char *mem;
  FILE *file=NULL;

  if (!name || strlen(name) == 0 || mcdisable_output_files) return(NULL);
  
  mem  = mcfull_file(name, ext); /* create mcdirname/name.ext */
  
  /* check for existence */
  file = fopen(mem, "r"); /* for reading -> fails if does not exist */
  if (file) {
    fclose(file);
    *exists=1;
  } else
    *exists=0;
  
  /* open the file for writing/appending */
#ifdef USE_NEXUS
  if (mcformat && strcasestr(mcformat, "NeXus")) {
    /* NXhandle nxhandle is defined in the .h with USE_NEXUS */
    NXaccess mode = (*exists ? NXACC_CREATE5 | NXACC_RDWR : NXACC_CREATE5);
      
    if (NXopen(mem, mode, &nxhandle) != NX_OK)
      file = NULL;
    else
      file = (FILE*)&nxhandle; /* to make it non NULL */
  } else
#endif
    file = fopen(mem, "a+"); 
    
  if(!file)
    fprintf(stderr, "Warning: could not open output file '%s' for %s (mcnew_file)\n", 
      mem, *exists ? "append" : "create");
  free(mem);

  return file;
} /* mcnew_file */

/*******************************************************************************
* mcdetector_statistics: compute detector statistics, error bars, [x I I_err N] 1D
* RETURN:            updated detector structure
* Used by: mcdetector_import
*******************************************************************************/
MCDETECTOR mcdetector_statistics(
  MCDETECTOR detector)
{

  if (!detector.p1 || !detector.m || detector.filename[0] == '\0')
    return(detector);
  
  /* compute statistics and update MCDETECTOR structure ===================== */
  double sum_z  = 0, min_z  = 0, max_z  = 0;
  double fmon_x =0,  smon_x = 0, fmon_y =0, smon_y=0, mean_z=0;
  double Nsum=0, P2sum=0;

  double sum_xz = 0, sum_yz = 0, sum_x = 0, sum_y = 0, sum_x2z = 0, sum_y2z = 0;
  int    i,j;
  char   hasnan=0, hasinf=0;
  char   israw = ((char*)strcasestr(detector.format,"raw") != NULL);
  double *this_p1=NULL; /* new 1D McCode array [x I E N]. Freed after writing data */

  /* if McCode/PGPLOT and rank==1 we create a new m*4 data block=[x I E N] */
  if (detector.rank == 1 && strcasestr(detector.format,"McCode")) {
    this_p1 = (double *)calloc(detector.m*detector.n*detector.p*4, sizeof(double));
    if (!this_p1)
      exit(-fprintf(stderr, "Error: Out of memory creating %li 1D " MCCODE_STRING " data set for file '%s' (mcdetector_import)\n",
        detector.m*detector.n*detector.p*4*sizeof(double*), detector.filename));
  }

  max_z = min_z = detector.p1[0];
  
  /* compute sum and moments (not for lists) */
  if (!strcasestr(detector.format,"list") && detector.m)
  for(j = 0; j < detector.n*detector.p; j++)
  {
    for(i = 0; i < detector.m; i++)
    {
      double x,y,z;
      double N, E;
      long   index= !detector.istransposed ? i*detector.n*detector.p + j : i+j*detector.m;
      char   hasnaninf=0;

      if (detector.m) 
        x = detector.xmin + (i + 0.5)/detector.m*(detector.xmax - detector.xmin); 
      else x = 0;
      if (detector.n && detector.p) 
        y = detector.ymin + (j + 0.5)/detector.n/detector.p*(detector.ymax - detector.ymin); 
      else y = 0;
      z = detector.p1[index];
      N = detector.p0 ? detector.p0[index] : 1;
      E = detector.p2 ? detector.p2[index] : 0;
      if (detector.p2 && !israw) 
        detector.p2[index] = (*mcestimate_error_p)(detector.p0[index],detector.p1[index],detector.p2[index]); /* set sigma */
      
      if (detector.rank == 1 && this_p1 && strcasestr(detector.format,"McCode")) {
        /* fill-in 1D McCode array [x I E N] */
        this_p1[index*4]   = x;
        this_p1[index*4+1] = z;
        this_p1[index*4+2] = detector.p2 ? detector.p2[index] : 0;
        this_p1[index*4+3] = N;
      }
      
      if (isnan(z) || isnan(E) || isnan(N)) hasnaninf=hasnan=1;
      if (isinf(z) || isinf(E) || isinf(N)) hasnaninf=hasinf=1;

      /* compute stats integrals */
      if (!hasnaninf) {
        sum_xz += x*z;
        sum_yz += y*z;
        sum_x  += x;
        sum_y  += y;
        sum_z  += z;
        sum_x2z += x*x*z;
        sum_y2z += y*y*z;
        if (z > max_z) max_z = z;
        if (z < min_z) min_z = z;

        Nsum += N;
        P2sum += E;
      }

    }
  } /* for j */

  /* compute 1st and 2nd moments. For lists, sum_z=0 so this is skipped. */
  if (sum_z && detector.n*detector.m*detector.p)
  {
    fmon_x = sum_xz/sum_z;
    fmon_y = sum_yz/sum_z;
    smon_x = sum_x2z/sum_z-fmon_x*fmon_x; smon_x = smon_x > 0 ? sqrt(smon_x) : 0;
    smon_y = sum_y2z/sum_z-fmon_y*fmon_y; smon_y = smon_y > 0 ? sqrt(smon_y) : 0;
    mean_z = sum_z/detector.n/detector.m/detector.p;
  }
  /* store statistics into detector */
  detector.intensity = sum_z;
  detector.error     = Nsum ? (*mcestimate_error_p)(Nsum, sum_z, P2sum) : 0;
  detector.events    = Nsum;
  detector.min       = min_z;
  detector.max       = max_z;
  detector.mean      = mean_z;
  detector.centerX   = fmon_x;
  detector.halfwidthX= smon_x;
  detector.centerY   = fmon_y;
  detector.halfwidthY= smon_y;

  /* if McCode/PGPLOT and rank==1 replace p1 with new m*4 1D McCode and clear others */
  if (detector.rank == 1 && this_p1 && strcasestr(detector.format,"McCode")) {
    
    detector.p1 = this_p1;
    detector.n  = detector.m; detector.m  = 4;
    detector.p0 = detector.p2 = NULL;
    detector.istransposed = 1;
  }

  if (detector.n*detector.m*detector.p > 1)
    snprintf(detector.signal, CHAR_BUF_LENGTH, 
      "Min=%g; Max=%g; Mean=%g;", detector.min, detector.max, detector.mean);
  else
    strcpy(detector.signal, "None");
  snprintf(detector.values, CHAR_BUF_LENGTH,
    "%g %g %g", detector.intensity, detector.error, detector.events);

  switch (detector.rank) {
    case 1:  snprintf(detector.statistics, CHAR_BUF_LENGTH, "X0=%g; dX=%g;",
      detector.centerX, detector.halfwidthX); break;
    case 2:
    case 3:  snprintf(detector.statistics, CHAR_BUF_LENGTH, "X0=%g; dX=%g; Y0=%g; dY=%g;",
      detector.centerX, detector.halfwidthX, detector.centerY, detector.halfwidthY);
      break;
    default: strcpy(detector.statistics, "None");
  }
  
  if (hasnan)
    printf("WARNING: Nan detected in component/file %s %s\n", 
      detector.component, strlen(detector.filename) ? detector.filename : "");
  if (hasinf)
    printf("WARNING: Inf detected in component/file %s %s\n", 
      detector.component, strlen(detector.filename) ? detector.filename : "");
  
  return(detector);
  
} /* mcdetector_statistics */

/*******************************************************************************
* mcdetector_import: build detector structure, merge non-lists from MPI
*                    compute basic stat, write "Detector:" line
* RETURN:            detector structure. Invalid data if detector.p1 == NULL
*                    Invalid detector sets m=0 and filename=""
*                    Simulation data  sets m=0 and filename=mcsiminfo_name
* This function is equivalent to the old 'mcdetector_out', returning a structure
*******************************************************************************/
MCDETECTOR mcdetector_import(
  char *format,
  char *component, char *title,
  long m, long n,  long p,
  char *xlabel, char *ylabel, char *zlabel,
  char *xvar, char *yvar, char *zvar,
  double x1, double x2, double y1, double y2, double z1, double z2,
  char *filename,
  double *p0, double *p1, double *p2,
  Coords position)
{
  time_t t;       /* for detector.date */
  long   date_l;  /* date as a long number */
  char   istransposed=0;
  char   c[CHAR_BUF_LENGTH]; /* temp var for signal label */

  MCDETECTOR detector;

  /* build MCDETECTOR structure ============================================= */
  /* make sure we do not have NULL for char fields */

  /* these also apply to simfile */
  strncpy (detector.filename,  filename ? filename : "",        CHAR_BUF_LENGTH);
  strncpy (detector.format,    format   ? format   : "McCode" , CHAR_BUF_LENGTH);
  /* add extension if missing */
  if (strlen(detector.filename) && !strchr(detector.filename, '.'))
  { /* add extension if not in file name already */
    strcat(detector.filename, ".dat");
  }
  strncpy (detector.component, component ? component : MCCODE_STRING " component", CHAR_BUF_LENGTH);

  snprintf(detector.instrument, CHAR_BUF_LENGTH, "%s (%s)", mcinstrument_name, mcinstrument_source);
  snprintf(detector.user, CHAR_BUF_LENGTH,      "%s on %s",
        getenv("USER") ? getenv("USER") : MCCODE_NAME,
        getenv("HOST") ? getenv("HOST") : "localhost");
  time(&t);         /* get current write time */
  date_l = (long)t; /* same but as a long */
  snprintf(detector.date, CHAR_BUF_LENGTH, "%s", ctime(&t));
  if (strlen(detector.date))   detector.date[strlen(detector.date)-1] = '\0'; /* remove last \n in date */
  detector.date_l = date_l;

  if (!mcget_run_num() || mcget_run_num() >= mcget_ncount())
    snprintf(detector.ncount, CHAR_BUF_LENGTH, "%llu", mcget_ncount()
#ifdef USE_MPI
*mpi_node_count
#endif
  );
  else
    snprintf(detector.ncount, CHAR_BUF_LENGTH, "%g/%g", (double)mcget_run_num(), (double)mcget_ncount());

  detector.p0         = p0;
  detector.p1         = p1;
  detector.p2         = p2;

  /* handle transposition (not for NeXus) */
  if (!strcasestr(detector.format, "NeXus")) {
    if (m<0 || n<0 || p<0)             istransposed = !istransposed;
    if (strcasestr(detector.format, "transpose")) istransposed = !istransposed;
    if (istransposed) { /* do the swap once for all */
      long i=m; m=n; n=i;
    }
  }

  m=labs(m); n=labs(n); p=labs(p); /* make sure dimensions are positive */
  detector.istransposed = istransposed;

  /* determine detector rank (dimensionality) */
  if (!m || !n || !p || !p1) detector.rank = 4; /* invalid: exit with m=0 filename="" */
  else if (m*n*p == 1)       detector.rank = 0; /* 0D */
  else if (n == 1 || m == 1) detector.rank = 1; /* 1D */
  else if (p == 1)           detector.rank = 2; /* 2D */
  else                       detector.rank = 3; /* 3D */

  /* from rank, set type */
  switch (detector.rank) {
    case 0:  strcpy(detector.type,  "array_0d"); m=n=p=1; break;
    case 1:  snprintf(detector.type, CHAR_BUF_LENGTH, "array_1d(%ld)", m*n*p); m *= n*p; n=p=1; break;
    case 2:  snprintf(detector.type, CHAR_BUF_LENGTH, "array_2d(%ld, %ld)", m, n*p); n *= p; p=1; break;
    case 3:  snprintf(detector.type, CHAR_BUF_LENGTH, "array_3d(%ld, %ld, %ld)", m, n, p); break;
    default: m=0; strcpy(detector.type, ""); strcpy(detector.filename, "");/* invalid */
  }

  detector.m    = m;
  detector.n    = n;
  detector.p    = p;

  /* these only apply to detector files ===================================== */

  snprintf(detector.position, CHAR_BUF_LENGTH, "%g %g %g", position.x, position.y, position.z);
  /* may also store actual detector orientation in the future */

  strncpy(detector.title,      title && strlen(title) ? title : component,       CHAR_BUF_LENGTH);
  strncpy(detector.xlabel,     xlabel && strlen(xlabel) ? xlabel : "X", CHAR_BUF_LENGTH); /* axis labels */
  strncpy(detector.ylabel,     ylabel && strlen(ylabel) ? ylabel : "Y", CHAR_BUF_LENGTH);
  strncpy(detector.zlabel,     zlabel && strlen(zlabel) ? zlabel : "Z", CHAR_BUF_LENGTH);
  strncpy(detector.xvar,       xvar && strlen(xvar) ? xvar :       "x", CHAR_BUF_LENGTH); /* axis variables */
  strncpy(detector.yvar,       yvar && strlen(yvar) ? yvar :       detector.xvar, CHAR_BUF_LENGTH);
  strncpy(detector.zvar,       zvar && strlen(zvar) ? zvar :       detector.yvar, CHAR_BUF_LENGTH);

  /* set "variables" as e.g. "I I_err N" */
  strcpy(c, "I ");
  if (strlen(detector.zvar))      strncpy(c, detector.zvar,32);
  else if (strlen(detector.yvar)) strncpy(c, detector.yvar,32);
  else if (strlen(detector.xvar)) strncpy(c, detector.xvar,32);

  if (detector.rank == 1)
    snprintf(detector.variables, CHAR_BUF_LENGTH, "%s %s %s_err N", detector.xvar, c, c);
  else
    snprintf(detector.variables, CHAR_BUF_LENGTH, "%s %s_err N", c, c);

  /* limits */
  detector.xmin = x1;
  detector.xmax = x2;
  detector.ymin = y1;
  detector.ymax = y2;
  detector.zmin = z1;
  detector.zmax = z2;
  if (abs(detector.rank) == 1)
    snprintf(detector.limits, CHAR_BUF_LENGTH, "%g %g", x1, x2);
  else if (detector.rank == 2)
    snprintf(detector.limits, CHAR_BUF_LENGTH, "%g %g %g %g", x1, x2, y1, y2);
  else
    snprintf(detector.limits, CHAR_BUF_LENGTH, "%g %g %g %g %g %g", x1, x2, y1, y2, z1, z2);

  /* if MPI and nodes_nb > 1: reduce data sets when using MPI =============== */
#ifdef USE_MPI
  if (!strcasestr(detector.format,"list") && mpi_node_count > 1 && m) {
    /* we save additive data: reduce everything into mpi_node_root */
    if (p0) mc_MPI_Sum(p0, m*n*p);
    if (p1) mc_MPI_Sum(p1, m*n*p);
    if (p2) mc_MPI_Sum(p2, m*n*p);
    if (!p0) {  /* additive signal must be then divided by the number of nodes */
      int i;
      for (i=0; i<m*n*p; i++) {
        p1[i] /= mpi_node_count;
        if (p2) p2[i] /= mpi_node_count;
      }
    }
  }
#endif /* USE_MPI */

  /* compute statistics, Nsum, intensity, Error bars */
  detector = mcdetector_statistics(detector);

#ifdef USE_MPI
  /* slaves are done */
  if(mpi_node_rank != mpi_node_root) {
    return detector;
  }
#endif

  /* output "Detector:" line ================================================ */
  /* when this is a detector written by a component (not the SAVE from instrument),
     not an event lists */
  if (!m) return(detector);
  if (!strcasestr(detector.format,"list")) {
    if (!strcmp(detector.component, mcinstrument_name)) {
      if (strlen(detector.filename))  /* we name it from its filename, or from its title */
        strncpy(c, detector.filename, CHAR_BUF_LENGTH);
      else
        snprintf(c, CHAR_BUF_LENGTH, "%s", mcinstrument_name);
    } else
      strncpy(c, detector.component, CHAR_BUF_LENGTH);  /* usual detectors written by components */

    printf("Detector: %s_I=%g %s_ERR=%g %s_N=%g",
           c, detector.intensity,
           c, detector.error,
           c, detector.events);
    printf(" \"%s\"\n", strlen(detector.filename) ? detector.filename : detector.component);
  }
  

  return(detector);
} /* mcdetector_import */

/* end MCDETECTOR import section ============================================ */

















/* ========================================================================== */

/*                               ASCII output                                 */
/*     The SIM file is YAML based, the data files have '#' headers            */

/* ========================================================================== */


/*******************************************************************************
* mcinfo_out: output instrument tags/info (only in SIM)
* Used in: mcsiminfo_init (ascii), mcinfo(stdout)
*******************************************************************************/
static void mcinfo_out(char *pre, FILE *f)
{
  char Parameters[CHAR_BUF_LENGTH] = "";
  int  i;

  if (!f || mcdisable_output_files) return;

  /* create parameter string ================================================ */
  for(i = 0; i < mcnumipar; i++)
  {
    char ThisParam[CHAR_BUF_LENGTH];
    if (strlen(mcinputtable[i].name) > CHAR_BUF_LENGTH) break;
    snprintf(ThisParam, CHAR_BUF_LENGTH, " %s(%s)", mcinputtable[i].name,
            (*mcinputtypes[mcinputtable[i].type].parminfo)
                (mcinputtable[i].name));
    strcat(Parameters, ThisParam);
    if (strlen(Parameters) >= CHAR_BUF_LENGTH-64) break;
  }

  /* output data ============================================================ */
  if (f != stdout)
    fprintf(f, "%sFile: %s%c%s\n",    pre, mcdirname, MC_PATHSEP_C, mcsiminfo_name);
  else
    fprintf(f, "%sCreator: %s\n",     pre, MCCODE_STRING);

  fprintf(f, "%sSource: %s\n",   pre, mcinstrument_source);
  fprintf(f, "%sParameters: %s\n",    pre, Parameters);
  
  fprintf(f, "%sTrace_enabled: %s\n", pre, mctraceenabled ? "yes" : "no");
  fprintf(f, "%sDefault_main: %s\n",  pre, mcdefaultmain ?  "yes" : "no");
  fprintf(f, "%sEmbedded_runtime: %s\n", pre, 
#ifdef MC_EMBEDDED_RUNTIME
         "yes"
#else
         "no"
#endif
         );

  fflush(f);
} /* mcinfo_out */

/*******************************************************************************
* mcruninfo_out_backend: output simulation tags/info (both in SIM and data files)
* Used in: mcsiminfo_init (ascii case), mcdetector_out_xD_ascii, mcinfo(stdout)
*******************************************************************************/
static void mcruninfo_out_backend(char *pre, FILE *f, int info)
{
  int i;
  char Parameters[CHAR_BUF_LENGTH];

  if (!f || mcdisable_output_files) return;

  fprintf(f, "%sFormat: %s%s\n",      pre, 
    mcformat && strlen(mcformat) ? mcformat : MCCODE_NAME,
    mcformat && strcasestr(mcformat,"McCode") ? " with text headers" : "");
  fprintf(f, "%sURL: %s\n",         pre, "http://www.mccode.org");
  fprintf(f, "%sCreator: %s\n",     pre, MCCODE_STRING);
  fprintf(f, "%sInstrument: %s\n", pre, mcinstrument_source);
  fprintf(f, "%sNcount: %llu\n",        pre, mcget_ncount());
  fprintf(f, "%sTrace: %s\n",       pre, mcdotrace ? "yes" : "no");
  fprintf(f, "%sGravitation: %s\n", pre, mcgravitation ? "yes" : "no");
  snprintf(Parameters, CHAR_BUF_LENGTH, "%ld", mcseed);
  fprintf(f, "%sSeed: %s\n",        pre, Parameters);
  fprintf(f, "%sDirectory: %s\n",        pre, mcdirname ? mcdirname : ".");
#ifdef USE_MPI
  if (mpi_node_count > 1)
    fprintf(f, "%sNodes: %i\n",        pre, mpi_node_count);
#endif

  /* output parameter string ================================================ */
  for(i = 0; i < mcnumipar; i++) {
      if (!info){
          (*mcinputtypes[mcinputtable[i].type].printer)(Parameters, mcinputtable[i].par);
          fprintf(f, "%sParam: %s=%s\n", pre, mcinputtable[i].name, Parameters);
      }else{
        /*if an info run, some variables might not have values. Flag these by "NULL"*/
	if(mcinputtable[i].val && strlen(mcinputtable[i].val)){
            /* ... those with defautl values*/
            (*mcinputtypes[mcinputtable[i].type].printer)(Parameters, mcinputtable[i].par);
            fprintf(f, "%sParam: %s=%s\n", pre, mcinputtable[i].name, Parameters);
        }else{
            /* ... and those without */
            fprintf(f, "%sParam: %s=NULL\n", pre, mcinputtable[i].name);
	}
      }
  }
} /* mcruninfo_out_backend */

/************************
* wrapper function to mcruninfo_out_backend
*  Regular runs use this whereas the single call from mcinfo is directly to the backend
*************************/
static void mcruninfo_out(char *pre, FILE *f){
    mcruninfo_out_backend(pre,f,0);
}

/*******************************************************************************
* mcsiminfo_out:    wrapper to fprintf(mcsiminfo_file)
*******************************************************************************/
void mcsiminfo_out(char *format, ...)
{
  va_list ap;

  if(mcsiminfo_file && !mcdisable_output_files)
  {
    va_start(ap, format);
    vfprintf(mcsiminfo_file, format, ap);
    va_end(ap);
  }
} /* mcsiminfo_out */


/*******************************************************************************
* mcdatainfo_out: output detector header
*   mcdatainfo_out(prefix, file_handle, detector) writes info to data file
*******************************************************************************/
static void
mcdatainfo_out(char *pre, FILE *f, MCDETECTOR detector)
{
  if (!f || !detector.m || mcdisable_output_files) return;
  
  /* output data ============================================================ */
  fprintf(f, "%sDate: %s (%li)\n",       pre, detector.date, detector.date_l);
  fprintf(f, "%stype: %s\n",       pre, detector.type);
  fprintf(f, "%sSource: %s\n",     pre, detector.instrument);
  fprintf(f, "%scomponent: %s\n",  pre, detector.component);
  fprintf(f, "%sposition: %s\n",   pre, detector.position);

  fprintf(f, "%stitle: %s\n",      pre, detector.title);
  fprintf(f, !mcget_run_num() || mcget_run_num() >= mcget_ncount() ?
             "%sNcount: %s\n" : 
             "%sratio: %s\n",  pre, detector.ncount);

  if (strlen(detector.filename)) {
    fprintf(f, "%sfilename: %s\n", pre, detector.filename);
  }

  fprintf(f, "%sstatistics: %s\n", pre, detector.statistics);
  fprintf(f, "%ssignal: %s\n",     pre, detector.signal);
  fprintf(f, "%svalues: %s\n",     pre, detector.values);

  if (detector.rank >= 1)
  {
    fprintf(f, "%sxvar: %s\n",     pre, detector.xvar);
    fprintf(f, "%syvar: %s\n",     pre, detector.yvar);
    fprintf(f, "%sxlabel: %s\n",   pre, detector.xlabel);
    fprintf(f, "%sylabel: %s\n",   pre, detector.ylabel);
    if (detector.rank > 1) {
      fprintf(f, "%szvar: %s\n",   pre, detector.zvar);
      fprintf(f, "%szlabel: %s\n", pre, detector.zlabel);
    }
  }

  fprintf(f, 
    abs(detector.rank)==1 ?
             "%sxlimits: %s\n" : 
             "%sxylimits: %s\n", pre, detector.limits);
  fprintf(f, "%svariables: %s\n", pre, 
    strcasestr(detector.format, "list") ? detector.ylabel : detector.variables);
    
  fflush(f);

} /* mcdatainfo_out */

/* mcdetector_out_array_ascii: output a single array to a file
 *   m: columns
 *   n: rows
 *   p: array
 *   f: file handle (already opened)
 */
static void mcdetector_out_array_ascii(long m, long n, double *p, FILE *f, char istransposed)
{
  if(f)
  {
    int i,j;
    for(j = 0; j < n; j++)
    {
      for(i = 0; i < m; i++)
      {
          fprintf(f, "%.10g ", p[!istransposed ? i*n + j : j*m+i]);
      }
      fprintf(f,"\n");
    }
  }
} /* mcdetector_out_array_ascii */

/*******************************************************************************
* mcdetector_out_0D_ascii: called by mcdetector_out_0D for ascii output
*******************************************************************************/
MCDETECTOR mcdetector_out_0D_ascii(MCDETECTOR detector)
{
  int exists=0;
  FILE *outfile = NULL;
  
  /* Write data set information to simulation description file. */
  MPI_MASTER(
    mcsiminfo_out("\nbegin data\n"); // detector.component
    mcdatainfo_out("  ", mcsiminfo_file, detector);
    mcsiminfo_out("end data\n");
    /* Don't write if filename is NULL: mcnew_file handles this (return NULL) */
    outfile = mcnew_file(detector.component, "dat", &exists);
    if(outfile)
    {
      /* write data file header and entry in simulation description file */
      mcruninfo_out( "# ", outfile);
      mcdatainfo_out("# ", outfile, detector);
      /* write I I_err N */
      fprintf(outfile, "%g %g %g\n", 
        detector.intensity, detector.error, detector.events);
      fclose(outfile);
    }
  ); /* MPI_MASTER */
  return(detector);
} /* mcdetector_out_0D_ascii */

/*******************************************************************************
* mcdetector_out_1D_ascii: called by mcdetector_out_1D for ascii output
*******************************************************************************/
MCDETECTOR mcdetector_out_1D_ascii(MCDETECTOR detector)
{
  int exists=0;
  FILE *outfile = NULL;

  MPI_MASTER(
    /* Write data set information to simulation description file. */
    mcsiminfo_out("\nbegin data\n"); // detector.filename
    mcdatainfo_out("  ", mcsiminfo_file, detector);
    mcsiminfo_out("end data\n");
    /* Loop over array elements, writing to file. */
    /* Don't write if filename is NULL: mcnew_file handles this (return NULL) */
    outfile = mcnew_file(detector.filename, "dat", &exists);
    if(outfile)
    {
      /* write data file header and entry in simulation description file */
      mcruninfo_out( "# ", outfile);
      mcdatainfo_out("# ", outfile, detector);
      /* output the 1D array columns */
      mcdetector_out_array_ascii(detector.m, detector.n, detector.p1, outfile, detector.istransposed);
      
      fclose(outfile);
    }
  ); /* MPI_MASTER */
  return(detector);
  
}  /* mcdetector_out_1D_ascii */

/*******************************************************************************
* mcdetector_out_2D_ascii: called by mcdetector_out_2D for ascii output
*******************************************************************************/
MCDETECTOR mcdetector_out_2D_ascii(MCDETECTOR detector)
{
  int exists=0;
  FILE *outfile = NULL;
  
  MPI_MASTER(
    /* Loop over array elements, writing to file. */
    /* Don't write if filename is NULL: mcnew_file handles this (return NULL) */
    outfile = mcnew_file(detector.filename, "dat", &exists);
    if(outfile)
    {
      /* write header only if file has just been created (not appending) */
      if (!exists) {
        /* Write data set information to simulation description file. */
        mcsiminfo_out("\nbegin data\n"); // detector.filename
        mcdatainfo_out("  ", mcsiminfo_file, detector);
        mcsiminfo_out("end data\n");
      
        mcruninfo_out( "# ", outfile);
        mcdatainfo_out("# ", outfile,   detector);
        fprintf(outfile, "# Data [%s/%s] %s:\n", detector.component, detector.filename, detector.zvar);
      }
      mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p1, 
        outfile, detector.istransposed);
      if (detector.p2) {
        fprintf(outfile, "# Errors [%s/%s] %s_err:\n", detector.component, detector.filename, detector.zvar);
        mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p2, 
          outfile, detector.istransposed);
      }
      if (detector.p0) {
        fprintf(outfile, "# Events [%s/%s] N:\n", detector.component, detector.filename);
        mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p0, 
          outfile, detector.istransposed);
      }
      fclose(outfile);
      
      if (!exists) {
        if (strcasestr(detector.format, "list"))
          printf("Events:   \"%s\"\n",  
            strlen(detector.filename) ? detector.filename : detector.component);
      }
    } /* if outfile */
  ); /* MPI_MASTER */
#ifdef USE_MPI
  if (strcasestr(detector.format, "list") && mpi_node_count > 1) {
    int node_i=0;
    /* loop along MPI nodes to write sequentially */
    for(node_i=0; node_i<mpi_node_count; node_i++) {
      /* MPI: slaves wait for the master to write its block, then append theirs */
      MPI_Barrier(MPI_COMM_WORLD);
      if (node_i != mpi_node_root && node_i == mpi_node_rank) {
        if(strlen(detector.filename) && !mcdisable_output_files)	/* Don't write if filename is NULL */
          outfile = mcnew_file(detector.filename, "dat", &exists);
        if (!exists)
          fprintf(stderr, "Warning: [MPI node %i] file '%s' does not exist yet, "
                          "MASTER should have opened it before.\n",
            mpi_node_rank, detector.filename);
        if(outfile) {
          mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p1, 
            outfile, detector.istransposed);
          fclose(outfile);
        }
      }
    }
  } /* if strcasestr list */
#endif
  return(detector);
} /* mcdetector_out_2D_ascii */

/*******************************************************************************
* strcpy_valid: makes a valid string for variable names.
*   copy 'original' into 'valid', replacing invalid characters by '_'
*   char arrays must be pre-allocated
*******************************************************************************/
static char *strcpy_valid(char *valid, char *original)
{
  long i;
  int  n=32; /* max length of valid names */

  if (original == NULL || !strlen(original)) return(NULL);

  if (n > strlen(original)) n = strlen(original);
  else original += strlen(original)-n;
  strncpy(valid, original, n);

  for (i=0; i < n; i++)
  {
    if ( (valid[i] > 122)
      || (valid[i] < 32)
      || (strchr("!\"#$%&'()*+,-.:;<=>?@[\\]^`/ \n\r\t", valid[i]) != NULL) )
    {
      if (i) valid[i] = '_'; else valid[i] = 'm';
    }
  }
  valid[i] = '\0';

  return(valid);
} /* strcpy_valid */

/* end ascii output section ================================================= */







#ifdef USE_NEXUS

/* ========================================================================== */

/*                               NeXus output                                 */

/* ========================================================================== */

#define nxprintf(...)    nxstr('d', __VA_ARGS__)
#define nxprintattr(...) nxstr('a', __VA_ARGS__)

/*******************************************************************************
* nxstr: output a tag=value data set (char) in NeXus/current group
*   when 'format' is larger that 1024 chars it is used as value for the 'tag'
*   else the value is assembled with format and following arguments.
*   type='d' -> data set
*        'a' -> attribute for current data set
*******************************************************************************/
static int nxstr(char type, NXhandle *f, char *tag, char *format, ...)
{
  va_list ap;
  char value[CHAR_BUF_LENGTH];
  int  i;
  int  ret=NX_OK;
  
  if (!tag || !format || !strlen(tag) || !strlen(format)) return(NX_OK);
  
  /* assemble the value string */
  if (strlen(format) < CHAR_BUF_LENGTH) {
    va_start(ap, format);
    ret = vsnprintf(value, CHAR_BUF_LENGTH, format, ap);
    va_end(ap);
  
    i = strlen(value);
  } else {
    i = strlen(format);
  }

  if (type == 'd') {
    /* open/put/close data set */
    if (NXmakedata (f, tag, NX_CHAR, 1, &i) != NX_OK) return(NX_ERROR);
    NXopendata (f, tag);
    if (strlen(format) < CHAR_BUF_LENGTH)
      ret = NXputdata  (f, value);
    else
      ret = NXputdata  (f, format);
    NXclosedata(f);
  } else {
    if (strlen(format) < CHAR_BUF_LENGTH)
      ret = NXputattr  (f, tag, value, strlen(value), NX_CHAR);
    else
      ret = NXputattr  (f, tag, format, strlen(format), NX_CHAR);
  }
  
  return(ret);
  
} /* nxstr */

/*******************************************************************************
* mcinfo_readfile: read a full file into a string buffer which is allocated
*   Think to free the buffer after use.
* Used in: mcinfo_out_nexus (nexus)
*******************************************************************************/
char *mcinfo_readfile(char *filename)
{
  FILE *f = fopen(filename, "rb");
  if (!f) return(NULL);
  fseek(f, 0, SEEK_END);
  long fsize = ftell(f);
  rewind(f);
  char *string = malloc(fsize + 1);
  if (string) {
    int n = fread(string, fsize, 1, f);
    fclose(f);

    string[fsize] = 0;
  }
  return(string);
}

/*******************************************************************************
* mcinfo_out: output instrument/simulation groups in NeXus file
* Used in: mcsiminfo_init (nexus)
*******************************************************************************/
static void mcinfo_out_nexus(NXhandle f)
{
  FILE  *fid;     /* for intrument source code/C/IDF */
  char  *buffer=NULL;
  time_t t     =time(NULL); /* for date */
  char   entry0[CHAR_BUF_LENGTH];
  int    count=0;
  char   name[CHAR_BUF_LENGTH];
  char   class[CHAR_BUF_LENGTH];
  
  if (!f || mcdisable_output_files) return;
  
  /* write NeXus NXroot attributes */
  /* automatically added: file_name, HDF5_Version, file_time, NeXus_version */ 
  nxprintattr(f, "creator",   "%s generated with " MCCODE_STRING, mcinstrument_name);
  
  /* count the number of existing NXentry and create the next one */
  NXgetgroupinfo(f, &count, name, class);
  sprintf(entry0, "entry%i", count+1);

  /* create the main NXentry (mandatory in NeXus) */
  if (NXmakegroup(f, entry0, "NXentry") == NX_OK) 
  if (NXopengroup(f, entry0, "NXentry") == NX_OK) {
    
    nxprintf(nxhandle, "program_name", MCCODE_STRING);
    nxprintf(f, "start_time", ctime(&t));
    nxprintf(f, "title", "%s%s%s simulation generated by instrument %s", 
      mcdirname && strlen(mcdirname) ? mcdirname : ".", MC_PATHSEP_S, mcsiminfo_name,
      mcinstrument_name);
    nxprintattr(f, "program_name", MCCODE_STRING);
    nxprintattr(f, "instrument",   mcinstrument_name);
    nxprintattr(f, "simulation",   "%s%s%s",
        mcdirname && strlen(mcdirname) ? mcdirname : ".", MC_PATHSEP_S, mcsiminfo_name);

    /* write NeXus instrument group */
    if (NXmakegroup(f, "instrument", "NXinstrument") == NX_OK)
    if (NXopengroup(f, "instrument", "NXinstrument") == NX_OK) {
      int   i;
      char *string=NULL;

      /* write NeXus parameters(types) data =================================== */
      string = (char*)malloc(CHAR_BUF_LENGTH);
      if (string) {
        strcpy(string, "");
        for(i = 0; i < mcnumipar; i++)
        {
          char ThisParam[CHAR_BUF_LENGTH];
          snprintf(ThisParam, CHAR_BUF_LENGTH, " %s(%s)", mcinputtable[i].name,
                  (*mcinputtypes[mcinputtable[i].type].parminfo)
                      (mcinputtable[i].name));
          if (strlen(string) + strlen(ThisParam) < CHAR_BUF_LENGTH)
            strcat(string, ThisParam);
        }
        nxprintattr(f, "Parameters",    string);
        free(string);
      }
        
      nxprintattr(f, "name",          mcinstrument_name);
      nxprintf   (f, "name",          mcinstrument_name);
      nxprintattr(f, "Source",        mcinstrument_source);
      
      nxprintattr(f, "Trace_enabled", mctraceenabled ? "yes" : "no");
      nxprintattr(f, "Default_main",  mcdefaultmain ?  "yes" : "no");
      nxprintattr(f, "Embedded_runtime",  
  #ifdef MC_EMBEDDED_RUNTIME
           "yes"
  #else
           "no"
  #endif
           );
           
      /* add instrument source code when available */
      buffer = mcinfo_readfile(mcinstrument_source);
      if (buffer && strlen(buffer)) {
        long length=strlen(buffer);
        nxprintf (f, "description", buffer);
        NXopendata(f,"description");
        nxprintattr(f, "file_name", mcinstrument_source);
        nxprintattr(f, "file_size", "%li", length);
        nxprintattr(f, "MCCODE_STRING", MCCODE_STRING);
        NXclosedata(f);
        nxprintf (f,"instrument_source", "%s " MCCODE_NAME " " MCCODE_PARTICLE " Monte Carlo simulation", mcinstrument_name);
        free(buffer);
      } else
        nxprintf (f, "description", "File %s not found (instrument description %s is missing)", 
          mcinstrument_source, mcinstrument_name);
      
      /* add Mantid/IDF.xml when available */
      char *IDFfile=NULL;
      IDFfile = (char*)malloc(CHAR_BUF_LENGTH);
      sprintf(IDFfile,"%s%s",mcinstrument_source,".xml");
      buffer = mcinfo_readfile(IDFfile);
      if (buffer && strlen(buffer)) {
        NXmakegroup (nxhandle, "instrument_xml", "NXnote");
        NXopengroup (nxhandle, "instrument_xml", "NXnote");
        nxprintf(f, "data", buffer);
        nxprintf(f, "description", "IDF.xml file found with instrument %s", mcinstrument_source);
        nxprintf(f, "type", "text/xml");
        NXclosegroup(f); /* instrument_xml */
        free(buffer);
      }
      free(IDFfile);
      NXclosegroup(f); /* instrument */
    } /* NXinstrument */

    /* write NeXus simulation group */
    if (NXmakegroup(f, "simulation", "NXnote") == NX_OK)
    if (NXopengroup(f, "simulation", "NXnote") == NX_OK) {

      nxprintattr(f, "name",   "%s%s%s",
        mcdirname && strlen(mcdirname) ? mcdirname : ".", MC_PATHSEP_S, mcsiminfo_name);
      
      nxprintf   (f, "name",      "%s",     mcsiminfo_name);
      nxprintattr(f, "Format",    mcformat && strlen(mcformat) ? mcformat : MCCODE_NAME);
      nxprintattr(f, "URL",       "http://www.mccode.org");
      nxprintattr(f, "program",   MCCODE_STRING);
      nxprintattr(f, "Instrument",mcinstrument_source);
      nxprintattr(f, "Trace",     mcdotrace ?     "yes" : "no");
      nxprintattr(f, "Gravitation",mcgravitation ? "yes" : "no");
      nxprintattr(f, "Seed",      "%li", mcseed);
      nxprintattr(f, "Directory", mcdirname);
    #ifdef USE_MPI
      if (mpi_node_count > 1)
        nxprintf(f, "Nodes", "%i",        mpi_node_count);
    #endif
    
      /* output parameter string ================================================ */
      if (NXmakegroup(f, "Param", "NXparameters") == NX_OK)
      if (NXopengroup(f, "Param", "NXparameters") == NX_OK) {
        int i;
        char string[CHAR_BUF_LENGTH];
        for(i = 0; i < mcnumipar; i++) {
          if (mcget_run_num() || (mcinputtable[i].val && strlen(mcinputtable[i].val))) {
            if (mcinputtable[i].par == NULL)
              strncpy(string, (mcinputtable[i].val ? mcinputtable[i].val : ""), CHAR_BUF_LENGTH);
            else
              (*mcinputtypes[mcinputtable[i].type].printer)(string, mcinputtable[i].par);

            nxprintf(f,  mcinputtable[i].name, "%s", string);
            nxprintattr(f, mcinputtable[i].name, string);
          }
        }
        NXclosegroup(f); /* Param */
      } /* NXparameters */
      
      NXclosegroup(f); /* simulation */
    } /* NXsimulation */
    
    /* create a group to hold all monitors */
    NXmakegroup(f, "data", "NXdetector");

    /* leave the NXentry opened (closed at exit) */
  } /* NXentry */
} /* mcinfo_out_nexus */

/*******************************************************************************
* mcdatainfo_out_nexus: output detector header
*   mcdatainfo_out_nexus(detector) create group and write info to NeXus data file
*   open data:NXdetector then filename:NXdata and write headers/attributes
*   requires: NXentry to be opened
*******************************************************************************/
static void
mcdatainfo_out_nexus(NXhandle f, MCDETECTOR detector)
{
  char data_name[32];
  if (!f || !detector.m || mcdisable_output_files) return;
  
  strcpy_valid(data_name, 
    detector.filename && strlen(detector.filename) ? 
      detector.filename : detector.component);

  /* the NXdetector group has been created in mcinfo_out_nexus (mcsiminfo_init) */
  if (NXopengroup(f, "data", "NXdetector") == NX_OK) {

    /* create and open the data group */
    /* this may fail when appending to list -> ignore/skip */
    NXMDisableErrorReporting(); /* unactivate NeXus error messages, as creation may fail */
    
    if (NXmakegroup(f, data_name, "NXdata") == NX_OK)
    if (NXopengroup(f, data_name, "NXdata") == NX_OK) {
    
      /* output metadata (as attributes) ======================================== */
      nxprintattr(f, "Date",       detector.date);
      nxprintattr(f, "type",       detector.type);
      nxprintattr(f, "Source",     detector.instrument);
      nxprintattr(f, "component",  detector.component);
      nxprintattr(f, "position",   detector.position);

      nxprintattr(f, "title",      detector.title);
      nxprintattr(f, !mcget_run_num() || mcget_run_num() >= mcget_ncount() ?
                 "Ncount" : 
                 "ratio",  detector.ncount);

      if (strlen(detector.filename)) {
        nxprintattr(f, "filename", detector.filename);
      }

      nxprintattr(f, "statistics", detector.statistics);
      nxprintattr(f, "signal",     detector.signal);
      nxprintattr(f, "values",     detector.values);

      if (detector.rank >= 1)
      {
        nxprintattr(f, "xvar",     detector.xvar);
        nxprintattr(f, "yvar",     detector.yvar);
        nxprintattr(f, "xlabel",   detector.xlabel);
        nxprintattr(f, "ylabel",   detector.ylabel);
        if (detector.rank > 1) {
          nxprintattr(f, "zvar",   detector.zvar);
          nxprintattr(f, "zlabel", detector.zlabel);
        }
      }

      nxprintattr(f, abs(detector.rank)==1 ?
                 "xlimits" : 
                 "xylimits", detector.limits);
      nxprintattr(f, "variables", 
        strcasestr(detector.format, "list") ? detector.ylabel : detector.variables);
      nxprintf(f, "distance", detector.position);
      nxprintf(f, "acquisition_mode",
        strcasestr(detector.format, "list") ? "event" : "summed");
        
      NXclosegroup(f);
    } /* NXdata (filename) */
    NXMEnableErrorReporting();  /* re-enable NeXus error messages */
    NXclosegroup(f);
  } /* NXdetector (data) */
  
} /* mcdatainfo_out_nexus */

/*******************************************************************************
* mcdetector_out_axis_nexus: write detector axis into current NXdata
*   requires: NXdata to be opened
*******************************************************************************/
int mcdetector_out_axis_nexus(NXhandle f, char *label, char *var, int rank, long length, double min, double max)
{
  if (!f || length <= 1 || mcdisable_output_files || max == min) return(NX_OK);
  else {
    double axis[length];
    char valid[32];
    int dim=(int)length;
    int i;
    int nprimary=1;
    /* create an axis from [min:max] */
    for(i = 0; i < length; i++)
      axis[i] = min+(max-min)*(i+0.5)/length;
    /* create the data set */
    strcpy_valid(valid, label);
    NXcompmakedata(f, valid, NX_FLOAT64, 1, &dim, NX_COMP_LZW, &dim);
    /* open it */
    if (NXopendata(f, valid) != NX_OK) {
      fprintf(stderr, "Warning: could not open axis rank %i '%s' (NeXus)\n",
        rank, valid);
      return(NX_ERROR);
    }
    /* put the axis and its attributes */
    NXputdata  (f, axis);
    nxprintattr(f, "long_name",  label);
    nxprintattr(f, "short_name", var);
    NXputattr  (f, "axis",       &rank,     1, NX_INT32);
    nxprintattr(f, "units",      var);
    NXputattr  (f, "primary",    &nprimary, 1, NX_INT32);
    NXclosedata(f);
    
    return(NX_OK);
  }
} /* mcdetector_out_axis_nexus */

/*******************************************************************************
* mcdetector_out_array_nexus: write detector array into current NXdata (1D,2D)
*   requires: NXdata to be opened
*******************************************************************************/
int mcdetector_out_array_nexus(NXhandle f, char *part, double *data, MCDETECTOR detector)
{
  
  int dims[3]={detector.m,detector.n,detector.p};  /* number of elements to write */
  int signal=1;
  int exists=0;
  int current_dims[3]={0,0,0};
  int ret=NX_OK;
  
  if (!f || !data || !detector.m || mcdisable_output_files) return(NX_OK);
  
  /* when this is a list, we set 1st dimension to NX_UNLIMITED for creation */
  if (strcasestr(detector.format, "list")) dims[0] = NX_UNLIMITED;
  
  /* create the data set in NXdata group */
  NXMDisableErrorReporting(); /* unactivate NeXus error messages, as creation may fail */
  /* NXcompmakedata fails with NX_UNLIMITED */
  if (strcasestr(detector.format, "list"))
    ret = NXmakedata(    f, part, NX_FLOAT64, detector.rank, dims);
  else
    ret = NXcompmakedata(f, part, NX_FLOAT64, detector.rank, dims, NX_COMP_LZW, dims);
  if (ret != NX_OK) {
    /* failed: data set already exists */
    int datatype=0;
    int rank=0;
    exists=1;
    /* inquire current size of data set (nb of events stored) */
    NXopendata(f, part);
    NXgetinfo(f, &rank, current_dims, &datatype);
    NXclosedata(f);
  }
  NXMEnableErrorReporting();  /* re-enable NeXus error messages */
  dims[0] = detector.m; /* restore actual dimension from data writing */
  
  /* open the data set */
  if (NXopendata(f, part) == NX_ERROR) {
    fprintf(stderr, "Warning: could not open DataSet %s '%s' (NeXus)\n",
      part, detector.title);
    return(NX_ERROR);
  }
  if (strcasestr(detector.format, "list")) {
    current_dims[1] = current_dims[2] = 0; /* set starting location for writing slab */
    NXputslab(f, data, current_dims, dims);
    if (!exists)
      printf("Events:   \"%s\"\n",  
        strlen(detector.filename) ? detector.filename : detector.component);
  } else {
    NXputdata (f, data);
  }
  
  if (strstr(part,"data") || strstr(part, "events")) {
    NXputattr(f, "signal", &signal, 1, NX_INT32);
    nxprintattr(f, "short_name", detector.filename && strlen(detector.filename) ? 
      detector.filename : detector.component);
  }
  nxprintattr(f, "long_name", "%s '%s'", part, detector.title);
  NXclosedata(f);
  
  return(NX_OK);
} /* mcdetector_out_array_nexus */

/*******************************************************************************
* mcdetector_out_data_nexus: write detector axes+data into current NXdata
*   The data:NXdetector is opened, then filename:NXdata
*   requires: NXentry to be opened
*******************************************************************************/
int mcdetector_out_data_nexus(NXhandle f, MCDETECTOR detector)
{
  char data_name[32];
  
  if (!f || !detector.m || mcdisable_output_files) return(NX_OK);
  
  strcpy_valid(data_name, 
    detector.filename && strlen(detector.filename) ? 
      detector.filename : detector.component);

  /* the NXdetector group has been created in mcinfo_out_nexus (mcsiminfo_init) */
  if (NXopengroup(f, "data", "NXdetector") == NX_OK) {

    /* the NXdata group has been created in mcdatainfo_out_nexus */
    if (NXopengroup(f, data_name, "NXdata") == NX_OK) {
  
      /* write axes, for histogram data sets, not for lists */
      if (!strcasestr(detector.format, "list")) {
        mcdetector_out_axis_nexus(f, detector.xlabel, detector.xvar, 
          1, detector.m, detector.xmin, detector.xmax);
          
        mcdetector_out_axis_nexus(f, detector.ylabel, detector.yvar, 
          2, detector.n, detector.ymin, detector.ymax);
          
        mcdetector_out_axis_nexus(f, detector.zlabel, detector.zvar, 
          3, detector.p, detector.zmin, detector.zmax);

      } /* !list */
      
      /* write the actual data (appended if already exists) */
      if (!strcasestr(detector.format, "list")) {
        mcdetector_out_array_nexus(f, "data", detector.p1, detector);
        mcdetector_out_array_nexus(f, "errors", detector.p2, detector);
        mcdetector_out_array_nexus(f, "ncount", detector.p0, detector);
      } else
        mcdetector_out_array_nexus(  f, "events", detector.p1, detector);
      
      NXclosegroup(f);
    } /* NXdata */
    NXclosegroup(f);
  } /* NXdetector */
  
  return(NX_OK);
} /* mcdetector_out_array_nexus */

#ifdef USE_MPI
/*******************************************************************************
* mcdetector_out_list_slaves: slaves send their list data to master which writes
*   requires: NXentry to be opened
* WARNING: this method has a flaw: it requires all nodes to flush the lists
*   the same number of times. In case one node is just below the buffer size
*   when finishing (e.g. monitor_nd), it may not trigger save but others may. 
*   Then the number of recv/send is not constant along nodes, and simulation stalls.  
*******************************************************************************/
MCDETECTOR mcdetector_out_list_slaves(MCDETECTOR detector)
{
  int     node_i=0;
  MPI_MASTER(
	     printf("\n** MPI master gathering slave node list data ** \n");
  );
  
  if (mpi_node_rank != mpi_node_root) {
    /* MPI slave: slaves send their data to master: 2 MPI_Send calls */
    /* m, n, p must be sent first, since all slaves do not have the same number of events */
    int mnp[3]={detector.m,detector.n,detector.p};

    if (mc_MPI_Send(mnp, 3, MPI_INT, mpi_node_root)!= MPI_SUCCESS)
      fprintf(stderr, "Warning: proc %i to master: MPI_Send mnp list error (mcdetector_out_list_slaves)\n", mpi_node_rank);
    if (!detector.p1
     || mc_MPI_Send(detector.p1, mnp[0]*mnp[1]*mnp[2], MPI_DOUBLE, mpi_node_root) != MPI_SUCCESS)
      fprintf(stderr, "Warning: proc %i to master: MPI_Send p1 list error: mnp=%i (mcdetector_out_list_slaves)\n", mpi_node_rank, abs(mnp[0]*mnp[1]*mnp[2]));
    /* slaves are done: sent mnp and p1 */
    return (detector);
  } /* end slaves */

  /* MPI master: receive data from slaves sequentially: 2 MPI_Recv calls */

  if (mpi_node_rank == mpi_node_root) {
    for(node_i=0; node_i<mpi_node_count; node_i++) {
      double *this_p1=NULL;                               /* buffer to hold the list from slaves */
      int     mnp[3]={0,0,0};  /* size of this buffer */
      if (node_i != mpi_node_root) { /* get data from slaves */
	if (mc_MPI_Recv(mnp, 3, MPI_INT, node_i) != MPI_SUCCESS)
	  fprintf(stderr, "Warning: master from proc %i: "
		  "MPI_Recv mnp list error (mcdetector_write_data)\n", node_i);
	if (mnp[0]*mnp[1]*mnp[2]) {
	  this_p1 = (double *)calloc(mnp[0]*mnp[1]*mnp[2], sizeof(double));
	  if (!this_p1 || mc_MPI_Recv(this_p1, abs(mnp[0]*mnp[1]*mnp[2]), MPI_DOUBLE, node_i)!= MPI_SUCCESS)
	    fprintf(stderr, "Warning: master from proc %i: "
		    "MPI_Recv p1 list error: mnp=%i (mcdetector_write_data)\n", node_i, mnp[0]*mnp[1]*mnp[2]);
	  else {
	    printf(". MPI master writing data for slave node %i\n",node_i);
	    detector.p1 = this_p1;
	    detector.m  = mnp[0]; detector.n  = mnp[1]; detector.p  = mnp[2];
	    
	    mcdetector_out_data_nexus(nxhandle, detector);
	  }
	}
      } /* if not master */
    } /* for */
  MPI_MASTER(
	     printf("\n** Done ** \n");
  );   
  }
}
#endif

MCDETECTOR mcdetector_out_0D_nexus(MCDETECTOR detector)
{
  /* Write data set information to NeXus file. */
  MPI_MASTER(
    mcdatainfo_out_nexus(nxhandle, detector);
  );
  
  return(detector);
} /* mcdetector_out_0D_ascii */

MCDETECTOR mcdetector_out_1D_nexus(MCDETECTOR detector_inc)
{
  MCDETECTOR detector = detector_inc;
  MPI_MASTER(
  mcdatainfo_out_nexus(nxhandle, detector);
  mcdetector_out_data_nexus(nxhandle, detector);
  );
  return(detector);
} /* mcdetector_out_1D_ascii */

MCDETECTOR mcdetector_out_2D_nexus(MCDETECTOR detector_inc)
{
  MCDETECTOR detector = detector_inc;
  MPI_MASTER(
  mcdatainfo_out_nexus(nxhandle, detector);
  mcdetector_out_data_nexus(nxhandle, detector);
  );
  
#ifdef USE_MPI // and USE_NEXUS
  /* NeXus: slave nodes have master write their lists */
  if (strcasestr(detector.format, "list") && mpi_node_count > 1) {
    mcdetector_out_list_slaves(detector);
  }
#endif /* USE_MPI */

  return(detector);
} /* mcdetector_out_2D_nexus */

#endif /* USE_NEXUS*/








/* ========================================================================== */

/*                            Main input functions                            */
/*            DETECTOR_OUT_xD function calls -> ascii or NeXus                */

/* ========================================================================== */

/*******************************************************************************
* mcsiminfo_init:   open SIM and write header
*******************************************************************************/
FILE *mcsiminfo_init(FILE *f)
{
  int exists=0;
  int index;
  
  /* check format */      
  if (!mcformat || !strlen(mcformat) 
   || !strcasecmp(mcformat, "MCSTAS") || !strcasecmp(mcformat, "MCXTRACE") 
   || !strcasecmp(mcformat, "PGPLOT") || !strcasecmp(mcformat, "GNUPLOT") || !strcasecmp(mcformat, "MCCODE")
   || !strcasecmp(mcformat, "MATLAB")) {
    mcformat="McCode";
#ifdef USE_NEXUS
  } else if (strcasestr(mcformat, "NeXus")) {
    /* Do nothing */
#endif
  } else {
    fprintf(stderr,
	    "Warning: You have requested the output format %s which is unsupported by this binary. Resetting to standard %s format.\n",mcformat ,"McCode");
    mcformat="McCode";
  }
  
  /* open the SIM file if not defined yet */
  if (mcsiminfo_file || mcdisable_output_files) 
    return (mcsiminfo_file);
    
#ifdef USE_NEXUS
  /* only master writes NeXus header: calls NXopen(nxhandle) */
  if (mcformat && strcasestr(mcformat, "NeXus")) {
	  MPI_MASTER(
	  mcsiminfo_file = mcnew_file(mcsiminfo_name, "h5", &exists);
    if(!mcsiminfo_file)
      fprintf(stderr,
	      "Warning: could not open simulation description file '%s'\n",
	      mcsiminfo_name);
	  else
	    mcinfo_out_nexus(nxhandle);
	  );
    return(mcsiminfo_file); /* points to nxhandle */
  }
#endif
  
  /* write main description file (only MASTER) */
  MPI_MASTER(

  mcsiminfo_file = mcnew_file(mcsiminfo_name, "sim", &exists);
  if(!mcsiminfo_file)
    fprintf(stderr,
	    "Warning: could not open simulation description file '%s'\n",
	    mcsiminfo_name);
  else
  {
    /* write SIM header */
    time_t t=time(NULL);
    mcsiminfo_out("%s simulation description file for %s.\n", 
      MCCODE_NAME, mcinstrument_name);
    mcsiminfo_out("Date:    %s", ctime(&t)); /* includes \n */
    mcsiminfo_out("Program: %s\n\n", MCCODE_STRING);
    
    mcsiminfo_out("begin instrument: %s\n", mcinstrument_name);
    mcinfo_out(   "  ", mcsiminfo_file);
    mcsiminfo_out("end instrument\n");

    mcsiminfo_out("\nbegin simulation: %s\n", mcdirname);
    mcruninfo_out("  ", mcsiminfo_file);
    mcsiminfo_out("end simulation\n");

  }
  return (mcsiminfo_file);
  
  ); /* MPI_MASTER */
  
} /* mcsiminfo_init */

/*******************************************************************************
*   mcsiminfo_close:  close SIM
*******************************************************************************/
void mcsiminfo_close()
{
  MPI_MASTER(
  if(mcsiminfo_file && !mcdisable_output_files) {
#ifdef USE_NEXUS
    if (mcformat && strcasestr(mcformat, "NeXus")) {
      time_t t=time(NULL);
      nxprintf(nxhandle, "end_time", ctime(&t));
      nxprintf(nxhandle, "duration", "%li", (long)t-mcstartdate);
      NXclosegroup(nxhandle); /* NXentry */
      NXclose(&nxhandle);
    } else
#endif
      fclose(mcsiminfo_file);
    );
    mcsiminfo_file = NULL;
  }
} /* mcsiminfo_close */

/*******************************************************************************
* mcdetector_out_0D: wrapper for 0D (single value).
*   Output single detector/monitor data (p0, p1, p2).
*   Title is t, component name is c.
*******************************************************************************/
MCDETECTOR mcdetector_out_0D(char *t, double p0, double p1, double p2,
                         char *c, Coords posa)
{
  /* import and perform basic detector analysis (and handle MPI reduce) */
  MCDETECTOR detector = mcdetector_import(mcformat,
    c, (t ? t : MCCODE_STRING " data"),
    1, 1, 1,
    "I", "", "",
    "I", "", "",
    0, 0, 0, 0, 0, 0, "",
    &p0, &p1, &p2, posa); /* write Detector: line */

#ifdef USE_NEXUS
  if (strcasestr(detector.format, "NeXus"))
    return(mcdetector_out_0D_nexus(detector));
  else
#endif
    return(mcdetector_out_0D_ascii(detector));
    
} /* mcdetector_out_0D */



/*******************************************************************************
* mcdetector_out_1D: wrapper for 1D.
*   Output 1d detector data (p0, p1, p2) for n bins linearly
*   distributed across the range x1..x2 (x1 is lower limit of first
*   bin, x2 is upper limit of last bin). Title is t, axis labels are xl
*   and yl. File name is f, component name is c.
*******************************************************************************/
MCDETECTOR mcdetector_out_1D(char *t, char *xl, char *yl,
        char *xvar, double x1, double x2,
        long n,
        double *p0, double *p1, double *p2, char *f,
        char *c, Coords posa)
{
  /* import and perform basic detector analysis (and handle MPI_Reduce) */
  MCDETECTOR detector = mcdetector_import(mcformat,
    c, (t ? t : MCCODE_STRING " 1D data"),
    n, 1, 1,
    xl, yl, (n > 1 ? "Signal per bin" : " Signal"),
    xvar, "(I,I_err)", "I",
    x1, x2, 0, 0, 0, 0, f,
    p0, p1, p2, posa); /* write Detector: line */
  if (!detector.p1 || !detector.m) return(detector);

#ifdef USE_NEXUS
  if (strcasestr(detector.format, "NeXus"))
    return(mcdetector_out_1D_nexus(detector));
  else
#endif
    return(mcdetector_out_1D_ascii(detector));
  
} /* mcdetector_out_1D */

/*******************************************************************************
* mcdetector_out_2D: wrapper for 2D.
*   special case for list: master creates file first, then slaves append their blocks without header
*******************************************************************************/
MCDETECTOR mcdetector_out_2D(char *t, char *xl, char *yl,
                  double x1, double x2, double y1, double y2,
                  long m, long n,
                  double *p0, double *p1, double *p2, char *f,
                  char *c, Coords posa)
{
  char xvar[CHAR_BUF_LENGTH];
  char yvar[CHAR_BUF_LENGTH];
  
  /* create short axes labels */
  if (xl && strlen(xl)) { strncpy(xvar, xl, CHAR_BUF_LENGTH); xvar[strcspn(xvar,"\n\r ")]='\0'; }
  else strcpy(xvar, "x");
  if (yl && strlen(yl)) { strncpy(yvar, yl, CHAR_BUF_LENGTH); yvar[strcspn(yvar,"\n\r ")]='\0'; }
  else strcpy(yvar, "y");

  MCDETECTOR detector;

  /* import and perform basic detector analysis (and handle MPI_Reduce) */
  if (labs(m) == 1) {/* n>1 on Y, m==1 on X: 1D, no X axis*/
    detector = mcdetector_import(mcformat,
      c, (t ? t : MCCODE_STRING " 1D data"),
      n, 1, 1,
      yl, "", "Signal per bin",
      yvar, "(I,Ierr)", "I",
      y1, y2, x1, x2, 0, 0, f,
      p0, p1, p2, posa); /* write Detector: line */
  } else if (labs(n)==1) {/* m>1 on X, n==1 on Y: 1D, no Y axis*/
    detector = mcdetector_import(mcformat,
      c, (t ? t : MCCODE_STRING " 1D data"),
      m, 1, 1,
      xl, "", "Signal per bin",
      xvar, "(I,Ierr)", "I",
      x1, x2, y1, y2, 0, 0, f,
      p0, p1, p2, posa); /* write Detector: line */
  }else {
    detector = mcdetector_import(mcformat,
      c, (t ? t : MCCODE_STRING " 2D data"),
      m, n, 1,
      xl, yl, "Signal per bin",
      xvar, yvar, "I",
      x1, x2, y1, y2, 0, 0, f,
      p0, p1, p2, posa); /* write Detector: line */
  }

  if (!detector.p1 || !detector.m) return(detector);

#ifdef USE_NEXUS
  if (strcasestr(detector.format, "NeXus"))
    return(mcdetector_out_2D_nexus(detector));
  else
#endif
    return(mcdetector_out_2D_ascii(detector));
  
} /* mcdetector_out_2D */

/*******************************************************************************
* mcdetector_out_list: wrapper for list output (calls out_2D with mcformat+"list").
*   m=number of events, n=size of each event
*******************************************************************************/
MCDETECTOR mcdetector_out_list(char *t, char *xl, char *yl,
                  long m, long n,
                  double *p1, char *f,
                  char *c, Coords posa)
{
  char       format_new[CHAR_BUF_LENGTH];
  char      *format_org;
  MCDETECTOR detector;
  
  format_org = mcformat;
  strcpy(format_new, mcformat);
  strcat(format_new, " list");
  mcformat = format_new;

  detector = mcdetector_out_2D(t, xl, yl,
                  1,labs(m),1,labs(n),
                  m,n,
                  NULL, p1, NULL, f,
                  c, posa);
  
  mcformat = format_org;
  return(detector);
}

/*******************************************************************************
 * mcuse_dir: set data/sim storage directory and create it,
 * or exit with error if exists
 ******************************************************************************/
static void
mcuse_dir(char *dir)
{
  if (!dir || !strlen(dir)) return;
#ifdef MC_PORTABLE
  fprintf(stderr, "Error: "
          "Directory output cannot be used with portable simulation (mcuse_dir)\n");
  exit(1);
#else  /* !MC_PORTABLE */
  /* handle file://directory URL type */
  if (strncmp(dir, "file://", strlen("file://")))
    mcdirname = dir;
  else
    mcdirname = dir+strlen("file://");
  
  
  
  MPI_MASTER(
    if(mkdir(mcdirname, 0777)) {
#ifndef DANSE
      fprintf(stderr, "Error: unable to create directory '%s' (mcuse_dir)\n", dir);
      fprintf(stderr, "(Maybe the directory already exists?)\n");
#endif
#ifdef USE_MPI
    MPI_Abort(MPI_COMM_WORLD, -1);
#endif
    exit(-1);
    }
  ); /* MPI_MASTER */
  
  /* remove trailing PATHSEP (if any) */
  while (strlen(mcdirname) && mcdirname[strlen(mcdirname) - 1] == MC_PATHSEP_C)
    mcdirname[strlen(mcdirname) - 1]='\0';
#endif /* !MC_PORTABLE */
} /* mcuse_dir */

/*******************************************************************************
* mcinfo: display instrument simulation info to stdout and exit
*******************************************************************************/
static void
mcinfo(void)
{
  fprintf(stdout, "begin instrument: %s\n", mcinstrument_name);
  mcinfo_out("  ", stdout);
  fprintf(stdout, "end instrument\n");
  fprintf(stdout, "begin simulation: %s\n", mcdirname ? mcdirname : ".");
  mcruninfo_out_backend("  ", stdout,1);
  fprintf(stdout, "end simulation\n");
  exit(0); /* includes MPI_Finalize in MPI mode */
} /* mcinfo */

#endif /* ndef MCCODE_R_IO_C */

/* end of the I/O section =================================================== */







/*******************************************************************************
* mcset_ncount: set total number of rays to generate
*******************************************************************************/
void mcset_ncount(unsigned long long int count)
{
  mcncount = count;
}

/* mcget_ncount: get total number of rays to generate */
unsigned long long int mcget_ncount(void)
{
  return mcncount;
}

/* mcget_run_num: get curent number of rays in TRACE */
unsigned long long int mcget_run_num(void)
{
  return mcrun_num;
}

/* mcsetn_arg: get ncount from a string argument */
static void
mcsetn_arg(char *arg)
{
  mcset_ncount((long long int) strtod(arg, NULL));
}

/* mcsetseed: set the random generator seed from a string argument */
static void
mcsetseed(char *arg)
{
  mcseed = atol(arg);
  if(mcseed) {
    srandom(mcseed);
  } else {
    fprintf(stderr, "Error: seed must not be zero (mcsetseed)\n");
    exit(1);
  }
}

/* Following part is only embedded when not redundent with mccode-r.h ========= */

#ifndef MCCODE_H

/* SECTION: MCDISPLAY support. =============================================== */

/*******************************************************************************
* Just output MCDISPLAY keywords to be caught by an external plotter client.
*******************************************************************************/

void mcdis_magnify(char *what){
  // Do nothing here, better use interactive zoom from the tools
}

void mcdis_line(double x1, double y1, double z1,
                double x2, double y2, double z2){
  printf("MCDISPLAY: multiline(2,%g,%g,%g,%g,%g,%g)\n",
         x1,y1,z1,x2,y2,z2);
}

void mcdis_dashed_line(double x1, double y1, double z1,
		       double x2, double y2, double z2, int n){
  int i;
  const double dx = (x2-x1)/(2*n+1);
  const double dy = (y2-y1)/(2*n+1);
  const double dz = (z2-z1)/(2*n+1);

  for(i = 0; i < n+1; i++)
    mcdis_line(x1 + 2*i*dx,     y1 + 2*i*dy,     z1 + 2*i*dz,
	       x1 + (2*i+1)*dx, y1 + (2*i+1)*dy, z1 + (2*i+1)*dz);
}

void mcdis_multiline(int count, ...){
  va_list ap;
  double x,y,z;

  printf("MCDISPLAY: multiline(%d", count);
  va_start(ap, count);
  while(count--)
    {
    x = va_arg(ap, double);
    y = va_arg(ap, double);
    z = va_arg(ap, double);
    printf(",%g,%g,%g", x, y, z);
    }
  va_end(ap);
  printf(")\n");
}

void mcdis_rectangle(char* plane, double x, double y, double z,
		     double width, double height){
  /* draws a rectangle in the plane           */
  /* x is ALWAYS width and y is ALWAYS height */
  if (strcmp("xy", plane)==0) {
    mcdis_multiline(5,
		    x - width/2, y - height/2, z,
		    x + width/2, y - height/2, z,
		    x + width/2, y + height/2, z,
		    x - width/2, y + height/2, z,
		    x - width/2, y - height/2, z);
  } else if (strcmp("xz", plane)==0) {
    mcdis_multiline(5,
		    x - width/2, y, z - height/2,
		    x + width/2, y, z - height/2,
		    x + width/2, y, z + height/2,
		    x - width/2, y, z + height/2,
		    x - width/2, y, z - height/2);
  } else if (strcmp("yz", plane)==0) {
    mcdis_multiline(5,
		    x, y - height/2, z - width/2,
		    x, y - height/2, z + width/2,
		    x, y + height/2, z + width/2,
		    x, y + height/2, z - width/2,
		    x, y - height/2, z - width/2);
  } else {

    fprintf(stderr, "Error: Definition of plane %s unknown\n", plane);
    exit(1);
  }
}

/*  draws a box with center at (x, y, z) and
    width (deltax), height (deltay), length (deltaz) */
void mcdis_box(double x, double y, double z,
	       double width, double height, double length){

  mcdis_rectangle("xy", x, y, z-length/2, width, height);
  mcdis_rectangle("xy", x, y, z+length/2, width, height);
  mcdis_line(x-width/2, y-height/2, z-length/2,
	     x-width/2, y-height/2, z+length/2);
  mcdis_line(x-width/2, y+height/2, z-length/2,
	     x-width/2, y+height/2, z+length/2);
  mcdis_line(x+width/2, y-height/2, z-length/2,
	     x+width/2, y-height/2, z+length/2);
  mcdis_line(x+width/2, y+height/2, z-length/2,
	     x+width/2, y+height/2, z+length/2);
}

void mcdis_circle(char *plane, double x, double y, double z, double r){
  printf("MCDISPLAY: circle('%s',%g,%g,%g,%g)\n", plane, x, y, z, r);
}

/* Draws a circle with center (x,y,z), radius (r), and in the plane
 * with normal (nx,ny,nz)*/
void mcdis_Circle(double x, double y, double z, double r, double nx, double ny, double nz){
    int i;
    if(nx==0 && ny && nz==0){
        for (i=0;i<24; i++){
            mcdis_line(x+r*sin(i*2*M_PI/24),y,z+r*cos(i*2*M_PI/24),
                    x+r*sin((i+1)*2*M_PI/24),y,z+r*cos((i+1)*2*M_PI/24));
        }
    }else{
        double mx,my,mz;
        /*generate perpendicular vector using (nx,ny,nz) and (0,1,0)*/
        vec_prod(mx,my,mz, 0,1,0, nx,ny,nz);
        NORM(mx,my,mz);
        /*draw circle*/
        for (i=0;i<24; i++){
            double ux,uy,uz;
            double wx,wy,wz;
            rotate(ux,uy,uz, mx,my,mz, i*2*M_PI/24, nx,ny,nz);
            rotate(wx,wy,wz, mx,my,mz, (i+1)*2*M_PI/24, nx,ny,nz);
            mcdis_line(x+ux*r,y+uy*r,z+uz*r,
                    x+wx*r,y+wy*r,z+wz*r);
        }
    }
}

/* Draws a cylinder with center at (x,y,z) with extent (r,height).
 * The cylinder axis is along the vector nx,ny,nz.
 * N determines how many vertical lines are drawn.*/
void mcdis_cylinder( double x, double y, double z,
        double r, double height, int N, double nx, double ny, double nz){
    int i;
    /*no lines make little sense - so trigger the default*/
    if(N<=0) N=5;

    NORM(nx,ny,nz);
    double h_2=height/2.0;
    mcdis_Circle(x+nx*h_2,y+ny*h_2,z+nz*h_2,r,nx,ny,nz);
    mcdis_Circle(x-nx*h_2,y-ny*h_2,z-nz*h_2,r,nx,ny,nz);

    double mx,my,mz;
    /*generate perpendicular vector using (nx,ny,nz) and (0,1,0)*/
    if(nx==0 && ny && nz==0){
        mx=my=0;mz=1;
    }else{
        vec_prod(mx,my,mz, 0,1,0, nx,ny,nz);
        NORM(mx,my,mz);
    }
    /*draw circle*/
    for (i=0; i<24; i++){
        double ux,uy,uz;
        rotate(ux,uy,uz, mx,my,mz, i*2*M_PI/24, nx,ny,nz);
        mcdis_line(x+nx*h_2+ux*r, y+ny*h_2+uy*r, z+nz*h_2+uz*r,
                 x-nx*h_2+ux*r, y-ny*h_2+uy*r, z-nz*h_2+uz*r);
    }
}

/* draws a sphere with center at (x,y,z) with extent (r)
 * The sphere is drawn using N longitudes and N latitudes.*/
void mcdis_sphere(double x, double y, double z, double r, int N){
    double nx,ny,nz;
    int i;
    /*no lines make little sense - so trigger the default*/
    if(N<=0) N=5;

    nx=0;ny=0;nz=1;
    mcdis_Circle(x,y,z,r,nx,ny,nz);
    for (i=1;i<N;i++){
        rotate(nx,ny,nz, nx,ny,nz, M_PI/N, 0,1,0);
        mcdis_Circle(x,y,z,r,nx,ny,nz);
    }
    /*lastly draw a great circle perpendicular to all N circles*/
    //mcdis_Circle(x,y,z,radius,1,0,0);

    for (i=1;i<=N;i++){
        double yy=-r+ 2*r*((double)i/(N+1));
        mcdis_Circle(x,y+yy ,z,  sqrt(r*r-yy*yy) ,0,1,0);
    }
}

/* SECTION: coordinates handling ============================================ */

/*******************************************************************************
* Since we use a lot of geometric calculations using Cartesian coordinates,
* we collect some useful routines here. However, it is also permissible to
* work directly on the underlying struct coords whenever that is most
* convenient (that is, the type Coords is not abstract).
*
* Coordinates are also used to store rotation angles around x/y/z axis.
*
* Since coordinates are used much like a basic type (such as double), the
* structure itself is passed and returned, rather than a pointer.
*
* At compile-time, the values of the coordinates may be unknown (for example
* a motor position). Hence coordinates are general expressions and not simple
* numbers. For this we used the type Coords_exp which has three CExp
* fields. For runtime (or calculations possible at compile time), we use
* Coords which contains three double fields.
*******************************************************************************/

/* coords_set: Assign coordinates. */
Coords
coords_set(MCNUM x, MCNUM y, MCNUM z)
{
  Coords a;

  a.x = x;
  a.y = y;
  a.z = z;
  return a;
}

/* coords_get: get coordinates. Required when 'x','y','z' are #defined as ray pars */
Coords
coords_get(Coords a, MCNUM *x, MCNUM *y, MCNUM *z)
{
  *x = a.x;
  *y = a.y;
  *z = a.z;
  return a;
}

/* coords_add: Add two coordinates. */
Coords
coords_add(Coords a, Coords b)
{
  Coords c;

  c.x = a.x + b.x;
  c.y = a.y + b.y;
  c.z = a.z + b.z;
  if (fabs(c.z) < 1e-14) c.z=0.0;
  return c;
}

/* coords_sub: Subtract two coordinates. */
Coords
coords_sub(Coords a, Coords b)
{
  Coords c;

  c.x = a.x - b.x;
  c.y = a.y - b.y;
  c.z = a.z - b.z;
  if (fabs(c.z) < 1e-14) c.z=0.0;
  return c;
}

/* coords_neg: Negate coordinates. */
Coords
coords_neg(Coords a)
{
  Coords b;

  b.x = -a.x;
  b.y = -a.y;
  b.z = -a.z;
  return b;
}

/* coords_scale: Scale a vector. */
Coords coords_scale(Coords b, double scale) {
  Coords a;

  a.x = b.x*scale;
  a.y = b.y*scale;
  a.z = b.z*scale;
  return a;
}

/* coords_sp: Scalar product: a . b */
double coords_sp(Coords a, Coords b) {
  double value;

  value = a.x*b.x + a.y*b.y + a.z*b.z;
  return value;
}

/* coords_xp: Cross product: a = b x c. */
Coords coords_xp(Coords b, Coords c) {
  Coords a;

  a.x = b.y*c.z - c.y*b.z;
  a.y = b.z*c.x - c.z*b.x;
  a.z = b.x*c.y - c.x*b.y;
  return a;
}

/* coords_len: Gives length of coords set. */
double coords_len(Coords a) {
  return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);
}

/* coords_mirror: Mirror a in plane (through the origin) defined by normal n*/
Coords coords_mirror(Coords a, Coords n) {
  double t = scalar_prod(n.x, n.y, n.z, n.x, n.y, n.z);
  Coords b;
  if (t!=1) {
    t = sqrt(t);
    n.x /= t;
    n.y /= t;
    n.z /= t;
  }
  t=scalar_prod(a.x, a.y, a.z, n.x, n.y, n.z);
  b.x = a.x-2*t*n.x;
  b.y = a.y-2*t*n.y;
  b.z = a.z-2*t*n.z;
  return b;
}

/* coords_print: Print out vector values. */
void coords_print(Coords a) {

  fprintf(stdout, "(%f, %f, %f)\n", a.x, a.y, a.z);
  return;
}

mcstatic void coords_norm(Coords* c) {
	double temp = coords_sp(*c,*c);

	// Skip if we will end dividing by zero
	if (temp == 0) return;

	temp = sqrt(temp);

	c->x /= temp;
	c->y /= temp;
	c->z /= temp;
}

/*******************************************************************************
* The Rotation type implements a rotation transformation of a coordinate
* system in the form of a double[3][3] matrix.
*
* Contrary to the Coords type in coords.c, rotations are passed by
* reference. Functions that yield new rotations do so by writing to an
* explicit result parameter; rotations are not returned from functions. The
* reason for this is that arrays cannot by returned from functions (though
* structures can; thus an alternative would have been to wrap the
* double[3][3] array up in a struct). Such are the ways of C programming.
*
* A rotation represents the tranformation of the coordinates of a vector when
* changing between coordinate systems that are rotated with respect to each
* other. For example, suppose that coordinate system Q is rotated 45 degrees
* around the Z axis with respect to coordinate system P. Let T be the
* rotation transformation representing a 45 degree rotation around Z. Then to
* get the coordinates of a vector r in system Q, apply T to the coordinates
* of r in P. If r=(1,0,0) in P, it will be (sqrt(1/2),-sqrt(1/2),0) in
* Q. Thus we should be careful when interpreting the sign of rotation angles:
* they represent the rotation of the coordinate systems, not of the
* coordinates (which has opposite sign).
*******************************************************************************/

/*******************************************************************************
* rot_set_rotation: Get transformation for rotation first phx around x axis,
* then phy around y, then phz around z.
*******************************************************************************/
void
rot_set_rotation(Rotation t, double phx, double phy, double phz)
{
  if ((phx == 0) && (phy == 0) && (phz == 0)) {
    t[0][0] = 1.0;
    t[0][1] = 0.0;
    t[0][2] = 0.0;
    t[1][0] = 0.0;
    t[1][1] = 1.0;
    t[1][2] = 0.0;
    t[2][0] = 0.0;
    t[2][1] = 0.0;
    t[2][2] = 1.0;
  } else {
    double cx = cos(phx);
    double sx = sin(phx);
    double cy = cos(phy);
    double sy = sin(phy);
    double cz = cos(phz);
    double sz = sin(phz);

    t[0][0] = cy*cz;
    t[0][1] = sx*sy*cz + cx*sz;
    t[0][2] = sx*sz - cx*sy*cz;
    t[1][0] = -cy*sz;
    t[1][1] = cx*cz - sx*sy*sz;
    t[1][2] = sx*cz + cx*sy*sz;
    t[2][0] = sy;
    t[2][1] = -sx*cy;
    t[2][2] = cx*cy;
  }
}

/*******************************************************************************
* rot_test_identity: Test if rotation is identity
*******************************************************************************/
int
rot_test_identity(Rotation t)
{
  return (t[0][0] + t[1][1] + t[2][2] == 3);
}

/*******************************************************************************
* rot_mul: Matrix multiplication of transformations (this corresponds to
* combining transformations). After rot_mul(T1, T2, T3), doing T3 is
* equal to doing first T2, then T1.
* Note that T3 must not alias (use the same array as) T1 or T2.
*******************************************************************************/
void
rot_mul(Rotation t1, Rotation t2, Rotation t3)
{
  if (rot_test_identity(t1)) {
    rot_copy(t3, t2);
  } else if (rot_test_identity(t2)) {
    rot_copy(t3, t1);
  } else {
    int i,j;
    for(i = 0; i < 3; i++)
      for(j = 0; j < 3; j++)
	t3[i][j] = t1[i][0]*t2[0][j] + t1[i][1]*t2[1][j] + t1[i][2]*t2[2][j];
  }
}

/*******************************************************************************
* rot_copy: Copy a rotation transformation (arrays cannot be assigned in C).
*******************************************************************************/
void
rot_copy(Rotation dest, Rotation src)
{
  int i,j;
  for(i = 0; i < 3; i++)
    for(j = 0; j < 3; j++)
      dest[i][j] = src[i][j];
}

/*******************************************************************************
* rot_transpose: Matrix transposition, which is inversion for Rotation matrices
*******************************************************************************/
void
rot_transpose(Rotation src, Rotation dst)
{
  dst[0][0] = src[0][0];
  dst[0][1] = src[1][0];
  dst[0][2] = src[2][0];
  dst[1][0] = src[0][1];
  dst[1][1] = src[1][1];
  dst[1][2] = src[2][1];
  dst[2][0] = src[0][2];
  dst[2][1] = src[1][2];
  dst[2][2] = src[2][2];
}

/*******************************************************************************
* rot_apply: returns t*a
*******************************************************************************/
Coords
rot_apply(Rotation t, Coords a)
{
  Coords b;
  if (rot_test_identity(t)) {
    return a;
  } else {
    b.x = t[0][0]*a.x + t[0][1]*a.y + t[0][2]*a.z;
    b.y = t[1][0]*a.x + t[1][1]*a.y + t[1][2]*a.z;
    b.z = t[2][0]*a.x + t[2][1]*a.y + t[2][2]*a.z;
    return b;
  }
}

/**
 * Pretty-printing of rotation matrices.
 */
void rot_print(Rotation rot) {
	printf("[ %4.2f %4.2f %4.2f ]\n",
			rot[0][0], rot[0][1], rot[0][2]);
	printf("[ %4.2f %4.2f %4.2f ]\n",
			rot[1][0], rot[1][1], rot[1][2]);
	printf("[ %4.2f %4.2f %4.2f ]\n\n",
			rot[2][0], rot[2][1], rot[2][2]);
}

/**
 * Vector product: used by vec_prod (mccode-r.h). Use coords_xp for Coords.
 */
mcstatic void vec_prod_func(double *x, double *y, double *z,
		double x1, double y1, double z1,
		double x2, double y2, double z2) {
    *x = (y1)*(z2) - (y2)*(z1);
    *y = (z1)*(x2) - (z2)*(x1);
    *z = (x1)*(y2) - (x2)*(y1);
}

/**
 * Scalar product: use coords_sp for Coords.
 */
mcstatic double scalar_prod(
		double x1, double y1, double z1,
		double x2, double y2, double z2) {
	return ((x1 * x2) + (y1 * y2) + (z1 * z2));
}

/*******************************************************************************
* mccoordschange: applies rotation to (x y z) and (vx vy vz) and Spin (sx,sy,sz)
*******************************************************************************/
void
mccoordschange(Coords a, Rotation t, double *x, double *y, double *z,
               double *vx, double *vy, double *vz, double *sx, double *sy, double *sz)
{
  Coords b, c;

  b.x = *x;
  b.y = *y;
  b.z = *z;
  c = rot_apply(t, b);
  b = coords_add(c, a);
  *x = b.x;
  *y = b.y;
  *z = b.z;

  if ( (vz && vy  && vx) && (*vz != 0.0 || *vx != 0.0 || *vy != 0.0) ) mccoordschange_polarisation(t, vx, vy, vz);

  if ( (sz && sy  && sx) && (*sz != 0.0 || *sx != 0.0 || *sy != 0.0) ) mccoordschange_polarisation(t, sx, sy, sz);

}

/*******************************************************************************
* mccoordschange_polarisation: applies rotation to vector (sx sy sz)
*******************************************************************************/
void
mccoordschange_polarisation(Rotation t, double *sx, double *sy, double *sz)
{
  Coords b, c;

  b.x = *sx;
  b.y = *sy;
  b.z = *sz;
  c = rot_apply(t, b);
  *sx = c.x;
  *sy = c.y;
  *sz = c.z;
}

/* SECTION: vector math  ==================================================== */

/* normal_vec_func: Compute normal vector to (x,y,z). */
mcstatic void normal_vec_func(double *nx, double *ny, double *nz,
                double x, double y, double z)
{
  double ax = fabs(x);
  double ay = fabs(y);
  double az = fabs(z);
  double l;
  if(x == 0 && y == 0 && z == 0)
  {
    *nx = 0;
    *ny = 0;
    *nz = 0;
    return;
  }
  if(ax < ay)
  {
    if(ax < az)
    {                           /* Use X axis */
      l = sqrt(z*z + y*y);
      *nx = 0;
      *ny = z/l;
      *nz = -y/l;
      return;
    }
  }
  else
  {
    if(ay < az)
    {                           /* Use Y axis */
      l = sqrt(z*z + x*x);
      *nx = z/l;
      *ny = 0;
      *nz = -x/l;
      return;
    }
  }
  /* Use Z axis */
  l = sqrt(y*y + x*x);
  *nx = y/l;
  *ny = -x/l;
  *nz = 0;
} /* normal_vec */

/*******************************************************************************
 * solve_2nd_order: second order equation solve: A*t^2 + B*t + C = 0
 * solve_2nd_order(&t1, NULL, A,B,C)
 *   returns 0 if no solution was found, or set 't1' to the smallest positive
 *   solution.
 * solve_2nd_order(&t1, &t2, A,B,C)
 *   same as with &t2=NULL, but also returns the second solution.
 * EXAMPLE usage for intersection of a trajectory with a plane in gravitation
 * field (gx,gy,gz):
 * The neutron starts at point r=(x,y,z) with velocityv=(vx vy vz). The plane
 * has a normal vector n=(nx,ny,nz) and contains the point W=(wx,wy,wz).
 * The problem consists in solving the 2nd order equation:
 *      1/2.n.g.t^2 + n.v.t + n.(r-W) = 0
 * so that A = 0.5 n.g; B = n.v; C = n.(r-W);
 * Without acceleration, t=-n.(r-W)/n.v
 ******************************************************************************/
int solve_2nd_order(double *t1, double *t2,
                  double A,  double B,  double C)
{
  int ret=0;

  if (!t1) return 0;
  *t1 = 0;
  if (t2) *t2=0;

  if (fabs(A) < 1E-10) /* approximate to linear equation: A ~ 0 */
  {
    if (B) {  *t1 = -C/B; ret=1; if (t2) *t2=*t1; }
    /* else no intersection: A=B=0 ret=0 */
  }
  else
  {
    double D;
    D = B*B - 4*A*C;
    if (D >= 0) /* Delta > 0: two solutions */
    {
      double sD, dt1, dt2;
      sD = sqrt(D);
      dt1 = (-B + sD)/2/A;
      dt2 = (-B - sD)/2/A;
      /* we identify very small values with zero */
      if (fabs(dt1) < 1e-10) dt1=0.0;
      if (fabs(dt2) < 1e-10) dt2=0.0;

      /* now we choose the smallest positive solution */
      if      (dt1<=0.0 && dt2>0.0) ret=2; /* dt2 positive */
      else if (dt2<=0.0 && dt1>0.0) ret=1; /* dt1 positive */
      else if (dt1> 0.0 && dt2>0.0)
      {  if (dt1 < dt2) ret=1; else ret=2; } /* all positive: min(dt1,dt2) */
      /* else two solutions are negative. ret=-1 */
      if (ret==1) { *t1 = dt1;  if (t2) *t2=dt2; }
      else        { *t1 = dt2;  if (t2) *t2=dt1; }
      ret=2;  /* found 2 solutions and t1 is the positive one */
    } /* else Delta <0: no intersection. ret=0 */
  }
  return(ret);
} /* solve_2nd_order */

/*******************************************************************************
 * randvec_target_circle: Choose random direction towards target at (x,y,z)
 * with given radius.
 * If radius is zero, choose random direction in full 4PI, no target.
 ******************************************************************************/
void
randvec_target_circle(double *xo, double *yo, double *zo, double *solid_angle,
               double xi, double yi, double zi, double radius)
{
  double l2, phi, theta, nx, ny, nz, xt, yt, zt, xu, yu, zu;

  if(radius == 0.0)
  {
    /* No target, choose uniformly a direction in full 4PI solid angle. */
    theta = acos (1 - rand0max(2));
    phi = rand0max(2 * PI);
    if(solid_angle)
      *solid_angle = 4*PI;
    nx = 1;
    ny = 0;
    nz = 0;
    yi = sqrt(xi*xi+yi*yi+zi*zi);
    zi = 0;
    xi = 0;
  }
  else
  {
    double costheta0;
    l2 = xi*xi + yi*yi + zi*zi; /* sqr Distance to target. */
    costheta0 = sqrt(l2/(radius*radius+l2));
    if (radius < 0) costheta0 *= -1;
    if(solid_angle)
    {
      /* Compute solid angle of target as seen from origin. */
        *solid_angle = 2*PI*(1 - costheta0);
    }

    /* Now choose point uniformly on circle surface within angle theta0 */
    theta = acos (1 - rand0max(1 - costheta0)); /* radius on circle */
    phi = rand0max(2 * PI); /* rotation on circle at given radius */
    /* Now, to obtain the desired vector rotate (xi,yi,zi) angle theta around a
       perpendicular axis u=i x n and then angle phi around i. */
    if(xi == 0 && zi == 0)
    {
      nx = 1;
      ny = 0;
      nz = 0;
    }
    else
    {
      nx = -zi;
      nz = xi;
      ny = 0;
    }
  }

  /* [xyz]u = [xyz]i x n[xyz] (usually vertical) */
  vec_prod(xu,  yu,  zu, xi, yi, zi,        nx, ny, nz);
  /* [xyz]t = [xyz]i rotated theta around [xyz]u */
  rotate  (xt,  yt,  zt, xi, yi, zi, theta, xu, yu, zu);
  /* [xyz]o = [xyz]t rotated phi around n[xyz] */
  rotate (*xo, *yo, *zo, xt, yt, zt, phi, xi, yi, zi);
} /* randvec_target_circle */

/*******************************************************************************
 * randvec_target_rect_angular: Choose random direction towards target at
 * (xi,yi,zi) with given ANGULAR dimension height x width. height=phi_x=[0,PI],
 * width=phi_y=[0,2*PI] (radians)
 * If height or width is zero, choose random direction in full 4PI, no target.
 *******************************************************************************/
void
randvec_target_rect_angular(double *xo, double *yo, double *zo, double *solid_angle,
               double xi, double yi, double zi, double width, double height, Rotation A)
{
  double theta, phi, nx, ny, nz, xt, yt, zt, xu, yu, zu;
  Coords tmp;
  Rotation Ainverse;

  rot_transpose(A, Ainverse);

  if(height == 0.0 || width == 0.0)
  {
    randvec_target_circle(xo, yo, zo, solid_angle,
               xi, yi, zi, 0);
    return;
  }
  else
  {
    if(solid_angle)
    {
      /* Compute solid angle of target as seen from origin. */
      *solid_angle = 2*fabs(width*sin(height/2));
    }

    /* Go to global coordinate system */

    tmp = coords_set(xi, yi, zi);
    tmp = rot_apply(Ainverse, tmp);
    coords_get(tmp, &xi, &yi, &zi);

    /* Now choose point uniformly on the unit sphere segment with angle theta/phi */
    phi   = width*randpm1()/2.0;
    theta = asin(randpm1()*sin(height/2.0));
    /* Now, to obtain the desired vector rotate (xi,yi,zi) angle theta around
       n, and then phi around u. */
    if(xi == 0 && zi == 0)
    {
      nx = 1;
      ny = 0;
      nz = 0;
    }
    else
    {
      nx = -zi;
      nz = xi;
      ny = 0;
    }
  }

  /* [xyz]u = [xyz]i x n[xyz] (usually vertical) */
  vec_prod(xu,  yu,  zu, xi, yi, zi,        nx, ny, nz);
  /* [xyz]t = [xyz]i rotated theta around [xyz]u */
  rotate  (xt,  yt,  zt, xi, yi, zi, theta, nx, ny, nz);
  /* [xyz]o = [xyz]t rotated phi around n[xyz] */
  rotate (*xo, *yo, *zo, xt, yt, zt, phi, xu,  yu,  zu);

  /* Go back to local coordinate system */
  tmp = coords_set(*xo, *yo, *zo);
  tmp = rot_apply(A, tmp);
  coords_get(tmp, &*xo, &*yo, &*zo);

} /* randvec_target_rect_angular */

/*******************************************************************************
 * randvec_target_rect_real: Choose random direction towards target at (xi,yi,zi)
 * with given dimension height x width (in meters !).
 *
 * Local emission coordinate is taken into account and corrected for 'order' times.
 * (See remarks posted to mcstas-users by George Apostolopoulus <gapost@ipta.demokritos.gr>)
 *
 * If height or width is zero, choose random direction in full 4PI, no target.
 *
 * Traditionally, this routine had the name randvec_target_rect - this is now a
 * a define (see mcstas-r.h) pointing here. If you use the old rouine, you are NOT
 * taking the local emmission coordinate into account.
*******************************************************************************/

void
randvec_target_rect_real(double *xo, double *yo, double *zo, double *solid_angle,
               double xi, double yi, double zi,
               double width, double height, Rotation A,
               double lx, double ly, double lz, int order)
{
  double dx, dy, dist, dist_p, nx, ny, nz, mx, my, mz, n_norm, m_norm;
  double cos_theta;
  Coords tmp;
  Rotation Ainverse;

  rot_transpose(A, Ainverse);

  if(height == 0.0 || width == 0.0)
  {
    randvec_target_circle(xo, yo, zo, solid_angle,
               xi, yi, zi, 0);
    return;
  }
  else
  {

    /* Now choose point uniformly on rectangle within width x height */
    dx = width*randpm1()/2.0;
    dy = height*randpm1()/2.0;

    /* Determine distance to target plane*/
    dist = sqrt(xi*xi + yi*yi + zi*zi);
    /* Go to global coordinate system */

    tmp = coords_set(xi, yi, zi);
    tmp = rot_apply(Ainverse, tmp);
    coords_get(tmp, &xi, &yi, &zi);

    /* Determine vector normal to trajectory axis (z) and gravity [0 1 0] */
    vec_prod(nx, ny, nz, xi, yi, zi, 0, 1, 0);

    /* This now defines the x-axis, normalize: */
    n_norm=sqrt(nx*nx + ny*ny + nz*nz);
    nx = nx/n_norm;
    ny = ny/n_norm;
    nz = nz/n_norm;

    /* Now, determine our y-axis (vertical in many cases...) */
    vec_prod(mx, my, mz, xi, yi, zi, nx, ny, nz);
    m_norm=sqrt(mx*mx + my*my + mz*mz);
    mx = mx/m_norm;
    my = my/m_norm;
    mz = mz/m_norm;

    /* Our output, random vector can now be defined by linear combination: */

    *xo = xi + dx * nx + dy * mx;
    *yo = yi + dx * ny + dy * my;
    *zo = zi + dx * nz + dy * mz;

    /* Go back to local coordinate system */
    tmp = coords_set(*xo, *yo, *zo);
    tmp = rot_apply(A, tmp);
    coords_get(tmp, &*xo, &*yo, &*zo);

    /* Go back to local coordinate system */
    tmp = coords_set(xi, yi, zi);
    tmp = rot_apply(A, tmp);
    coords_get(tmp, &xi, &yi, &zi);

    if (solid_angle) {
      /* Calculate vector from local point to remote random point */
      lx = *xo - lx;
      ly = *yo - ly;
      lz = *zo - lz;
      dist_p = sqrt(lx*lx + ly*ly + lz*lz);

      /* Adjust the 'solid angle' */
      /* 1/r^2 to the chosen point times cos(\theta) between the normal */
      /* vector of the target rectangle and direction vector of the chosen point. */
      cos_theta = (xi * lx + yi * ly + zi * lz) / (dist * dist_p);
      *solid_angle = width * height / (dist_p * dist_p);
      int counter;
      for (counter = 0; counter < order; counter++) {
	*solid_angle = *solid_angle * cos_theta;
      }
    }
  }
} /* randvec_target_rect_real */

/* SECTION: random numbers ================================================== */

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

/*
 * This is derived from the Berkeley source:
 *        @(#)random.c        5.5 (Berkeley) 7/6/88
 * It was reworked for the GNU C Library by Roland McGrath.
 * Rewritten to use reentrant functions by Ulrich Drepper, 1995.
 */

/*******************************************************************************
* Modified for McStas from glibc 2.0.7pre1 stdlib/random.c and
* stdlib/random_r.c.
*
* This way random() is more than four times faster compared to calling
* standard glibc random() on ix86 Linux, probably due to multithread support,
* ELF shared library overhead, etc. It also makes McStas generated
* simulations more portable (more likely to behave identically across
* platforms, important for parrallel computations).
*******************************************************************************/


#define        TYPE_3                3
#define        BREAK_3                128
#define        DEG_3                31
#define        SEP_3                3

static mc_int32_t randtbl[DEG_3 + 1] =
  {
    TYPE_3,

    -1726662223, 379960547, 1735697613, 1040273694, 1313901226,
    1627687941, -179304937, -2073333483, 1780058412, -1989503057,
    -615974602, 344556628, 939512070, -1249116260, 1507946756,
    -812545463, 154635395, 1388815473, -1926676823, 525320961,
    -1009028674, 968117788, -123449607, 1284210865, 435012392,
    -2017506339, -911064859, -370259173, 1132637927, 1398500161,
    -205601318,
  };

static mc_int32_t *fptr = &randtbl[SEP_3 + 1];
static mc_int32_t *rptr = &randtbl[1];
static mc_int32_t *state = &randtbl[1];
#define rand_deg DEG_3
#define rand_sep SEP_3
static mc_int32_t *end_ptr = &randtbl[sizeof (randtbl) / sizeof (randtbl[0])];

mc_int32_t
mc_random (void)
{
  mc_int32_t result;

  *fptr += *rptr;
  /* Chucking least random bit.  */
  result = (*fptr >> 1) & 0x7fffffff;
  ++fptr;
  if (fptr >= end_ptr)
  {
    fptr = state;
    ++rptr;
  }
  else
  {
    ++rptr;
    if (rptr >= end_ptr)
      rptr = state;
  }
  return result;
}

void
mc_srandom (unsigned int x)
{
  /* We must make sure the seed is not 0.  Take arbitrarily 1 in this case.  */
  state[0] = x ? x : 1;
  {
    long int i;
    for (i = 1; i < rand_deg; ++i)
    {
      /* This does:
         state[i] = (16807 * state[i - 1]) % 2147483647;
         but avoids overflowing 31 bits.  */
      long int hi = state[i - 1] / 127773;
      long int lo = state[i - 1] % 127773;
      long int test = 16807 * lo - 2836 * hi;
      state[i] = test + (test < 0 ? 2147483647 : 0);
    }
    fptr = &state[rand_sep];
    rptr = &state[0];
    for (i = 0; i < 10 * rand_deg; ++i)
      random ();
  }
}

/* "Mersenne Twister", by Makoto Matsumoto and Takuji Nishimura. */
/* See http://www.math.keio.ac.jp/~matumoto/emt.html for original source. */


/*
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using mt_srandom(seed)
   or init_by_array(init_key, key_length).

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote
        products derived from this software without specific prior written
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   Any feedback is very welcome.
   http://www.math.keio.ac.jp/matumoto/emt.html
   email: matumoto@math.keio.ac.jp
*/

#include <stdio.h>

/* Period parameters */
#define N 624
#define M 397
#define MATRIX_A 0x9908b0dfUL   /* constant vector a */
#define UPPER_MASK 0x80000000UL /* most significant w-r bits */
#define LOWER_MASK 0x7fffffffUL /* least significant r bits */

static unsigned long mt[N]; /* the array for the state vector  */
static int mti=N+1; /* mti==N+1 means mt[N] is not initialized */

/* initializes mt[N] with a seed */
void mt_srandom(unsigned long s)
{
    mt[0]= s & 0xffffffffUL;
    for (mti=1; mti<N; mti++) {
        mt[mti] =
            (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);
        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
        /* In the previous versions, MSBs of the seed affect   */
        /* only MSBs of the array mt[].                        */
        /* 2002/01/09 modified by Makoto Matsumoto             */
        mt[mti] &= 0xffffffffUL;
        /* for >32 bit machines */
    }
}

/* initialize by an array with array-length */
/* init_key is the array for initializing keys */
/* key_length is its length */
void init_by_array(unsigned long init_key[], unsigned long key_length)
{
    int i, j, k;
    mt_srandom(19650218UL);
    i=1; j=0;
    k = (N>key_length ? N : key_length);
    for (; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))
          + init_key[j] + j; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++; j++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
        if (j>=key_length) j=0;
    }
    for (k=N-1; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL))
          - i; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
    }

    mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */
}

/* generates a random number on [0,0xffffffff]-interval */
unsigned long mt_random(void)
{
    unsigned long y;
    static unsigned long mag01[2]={0x0UL, MATRIX_A};
    /* mag01[x] = x * MATRIX_A  for x=0,1 */

    if (mti >= N) { /* generate N words at one time */
        int kk;

        if (mti == N+1)   /* if mt_srandom() has not been called, */
            mt_srandom(5489UL); /* a default initial seed is used */

        for (kk=0;kk<N-M;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        for (;kk<N-1;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];

        mti = 0;
    }

    y = mt[mti++];

    /* Tempering */
    y ^= (y >> 11);
    y ^= (y << 7) & 0x9d2c5680UL;
    y ^= (y << 15) & 0xefc60000UL;
    y ^= (y >> 18);

    return y;
}

#undef N
#undef M
#undef MATRIX_A
#undef UPPER_MASK
#undef LOWER_MASK

/* End of "Mersenne Twister". */

/* End of McCode random number routine. */

/* randnorm: generate a random number from normal law */
double
randnorm(void)
{
  static double v1, v2, s;
  static int phase = 0;
  double X, u1, u2;

  if(phase == 0)
  {
    do
    {
      u1 = rand01();
      u2 = rand01();
      v1 = 2*u1 - 1;
      v2 = 2*u2 - 1;
      s = v1*v1 + v2*v2;
    } while(s >= 1 || s == 0);

    X = v1*sqrt(-2*log(s)/s);
  }
  else
  {
    X = v2*sqrt(-2*log(s)/s);
  }

  phase = 1 - phase;
  return X;
}

/**
 * Generate a random number from -1 to 1 with triangle distribution
 */
double randtriangle(void) {
	double randnum = rand01();
	if (randnum>0.5) return(1-sqrt(2*(randnum-0.5)));
	else return(sqrt(2*randnum)-1);
}

/**
 * Random number between 0.0 and 1.0 (including?)
 */
double rand01() {
	double randnum;
	randnum = (double) random();
	randnum /= (double) MC_RAND_MAX + 1;
	return randnum;
}

/**
 * Return a random number between 1 and -1
 */
double randpm1() {
	double randnum;
	randnum = (double) random();
	randnum /= ((double) MC_RAND_MAX + 1) / 2;
	randnum -= 1;
	return randnum;
}

/**
 * Return a random number between 0 and max.
 */
double rand0max(double max) {
	double randnum;
	randnum = (double) random();
	randnum /= ((double) MC_RAND_MAX + 1) / max;
	return randnum;
}

/**
 * Return a random number between min and max.
 */
double randminmax(double min, double max) {
	return rand0max(max - min) + max;
}

/* SECTION: main and signal handlers ======================================== */

/*******************************************************************************
* mchelp: displays instrument executable help with possible options
*******************************************************************************/
static void
mchelp(char *pgmname)
{
  int i;

  fprintf(stderr, "%s (%s) instrument simulation, generated with " MCCODE_STRING " (" MCCODE_DATE ")\n", mcinstrument_name, mcinstrument_source);
  fprintf(stderr, "Usage: %s [options] [parm=value ...]\n", pgmname);
  fprintf(stderr,
"Options are:\n"
"  -s SEED   --seed=SEED      Set random seed (must be != 0)\n"
"  -n COUNT  --ncount=COUNT   Set number of " MCCODE_PARTICLE "s to simulate.\n"
"  -d DIR    --dir=DIR        Put all data files in directory DIR.\n"
"  -t        --trace          Enable trace of " MCCODE_PARTICLE "s through instrument.\n"
"  -g        --gravitation    Enable gravitation for all trajectories.\n"
"  --no-output-files          Do not write any data files.\n"
"  -h        --help           Show this help message.\n"
"  -i        --info           Detailed instrument information.\n"
"  --format=FORMAT            Output data files using FORMAT="
   FLAVOR_UPPER
#ifdef USE_NEXUS
   " NEXUS"
#endif
"\n\n"
);
#ifdef USE_MPI
  fprintf(stderr,
  "This instrument has been compiled with MPI support.\n  Use 'mpirun %s [options] [parm=value ...]'.\n", pgmname);
#endif
  if(mcnumipar > 0)
  {
    fprintf(stderr, "Instrument parameters are:\n");
    for(i = 0; i < mcnumipar; i++)
      if (mcinputtable[i].val && strlen(mcinputtable[i].val))
        fprintf(stderr, "  %-16s(%s) [default='%s']\n", mcinputtable[i].name,
        (*mcinputtypes[mcinputtable[i].type].parminfo)(mcinputtable[i].name),
        mcinputtable[i].val);
      else
        fprintf(stderr, "  %-16s(%s)\n", mcinputtable[i].name,
        (*mcinputtypes[mcinputtable[i].type].parminfo)(mcinputtable[i].name));
  }

#ifndef NOSIGNALS
  fprintf(stderr, "Known signals are: "
#ifdef SIGUSR1
  "USR1 (status) "
#endif
#ifdef SIGUSR2
  "USR2 (save) "
#endif
#ifdef SIGBREAK
  "BREAK (save) "
#endif
#ifdef SIGTERM
  "TERM (save and exit)"
#endif
  "\n");
#endif /* !NOSIGNALS */
} /* mchelp */


/* mcshowhelp: show help and exit with 0 */
static void
mcshowhelp(char *pgmname)
{
  mchelp(pgmname);
  exit(0);
}

/* mcusage: display usage when error in input arguments and exit with 1 */
static void
mcusage(char *pgmname)
{
  fprintf(stderr, "Error: incorrect command line arguments\n");
  mchelp(pgmname);
  exit(1);
}

/* mcenabletrace: enable trace/mcdisplay or error if requires recompile */
static void
mcenabletrace(void)
{
 if(mctraceenabled)
  mcdotrace = 1;
 else
 {
   fprintf(stderr,
           "Error: trace not enabled (mcenabletrace)\n"
           "Please re-run the " MCCODE_NAME " compiler "
                   "with the --trace option, or rerun the\n"
           "C compiler with the MC_TRACE_ENABLED macro defined.\n");
   exit(1);
 }
}

/*******************************************************************************
* mcreadparams: request parameters from the prompt (or use default)
*******************************************************************************/
void
mcreadparams(void)
{
  int i,j,status;
  static char buf[CHAR_BUF_LENGTH];
  char *p;
  int len;

  MPI_MASTER(printf("Instrument parameters for %s (%s)\n",
                    mcinstrument_name, mcinstrument_source));

  for(i = 0; mcinputtable[i].name != 0; i++)
  {
    do
    {
      MPI_MASTER(
                 if (mcinputtable[i].val && strlen(mcinputtable[i].val))
                   printf("Set value of instrument parameter %s (%s) [default='%s']:\n",
                          mcinputtable[i].name,
                          (*mcinputtypes[mcinputtable[i].type].parminfo)
                          (mcinputtable[i].name), mcinputtable[i].val);
                 else
                   printf("Set value of instrument parameter %s (%s):\n",
                          mcinputtable[i].name,
                          (*mcinputtypes[mcinputtable[i].type].parminfo)
                          (mcinputtable[i].name));
                 fflush(stdout);
                 );
#ifdef USE_MPI
      if(mpi_node_rank == mpi_node_root)
        {
          p = fgets(buf, CHAR_BUF_LENGTH, stdin);
          if(p == NULL)
            {
              fprintf(stderr, "Error: empty input for paramater %s (mcreadparams)\n", mcinputtable[i].name);
              exit(1);
            }
        }
      else
        p = buf;
      MPI_Bcast(buf, CHAR_BUF_LENGTH, MPI_CHAR, mpi_node_root, MPI_COMM_WORLD);
#else /* !USE_MPI */
      p = fgets(buf, CHAR_BUF_LENGTH, stdin);
      if(p == NULL)
        {
          fprintf(stderr, "Error: empty input for paramater %s (mcreadparams)\n", mcinputtable[i].name);
          exit(1);
        }
#endif /* USE_MPI */
      len = strlen(buf);
      if (!len || (len == 1 && (buf[0] == '\n' || buf[0] == '\r')))
      {
        if (mcinputtable[i].val && strlen(mcinputtable[i].val)) {
          strncpy(buf, mcinputtable[i].val, CHAR_BUF_LENGTH);  /* use default value */
          len = strlen(buf);
        }
      }
      for(j = 0; j < 2; j++)
      {
        if(len > 0 && (buf[len - 1] == '\n' || buf[len - 1] == '\r'))
        {
          len--;
          buf[len] = '\0';
        }
      }

      status = (*mcinputtypes[mcinputtable[i].type].getparm)
                   (buf, mcinputtable[i].par);
      if(!status)
      {
        (*mcinputtypes[mcinputtable[i].type].error)(mcinputtable[i].name, buf);
        if (!mcinputtable[i].val || strlen(mcinputtable[i].val)) {
          fprintf(stderr, "       Change %s default value in instrument definition.\n", mcinputtable[i].name);
          exit(1);
        }
      }
    } while(!status);
  }
} /* mcreadparams */

/*******************************************************************************
* mcparseoptions: parse command line arguments (options, parameters)
*******************************************************************************/
void
mcparseoptions(int argc, char *argv[])
{
  int i, j;
  char *p;
  int paramset = 0, *paramsetarray;
  char *usedir=NULL;

  /* Add one to mcnumipar to avoid allocating zero size memory block. */
  paramsetarray = (int*)malloc((mcnumipar + 1)*sizeof(*paramsetarray));
  if(paramsetarray == NULL)
  {
    fprintf(stderr, "Error: insufficient memory (mcparseoptions)\n");
    exit(1);
  }
  for(j = 0; j < mcnumipar; j++)
    {
      paramsetarray[j] = 0;
      if (mcinputtable[j].val != NULL && strlen(mcinputtable[j].val))
      {
        int  status;
        char buf[CHAR_BUF_LENGTH];
        strncpy(buf, mcinputtable[j].val, CHAR_BUF_LENGTH);
        status = (*mcinputtypes[mcinputtable[j].type].getparm)
                   (buf, mcinputtable[j].par);
        if(!status) fprintf(stderr, "Invalid '%s' default value %s in instrument definition (mcparseoptions)\n", mcinputtable[j].name, buf);
        else paramsetarray[j] = 1;
      } else {
        (*mcinputtypes[mcinputtable[j].type].getparm)
          (NULL, mcinputtable[j].par);
        paramsetarray[j] = 0;
      }
    }
  for(i = 1; i < argc; i++)
  {
    if(!strcmp("-s", argv[i]) && (i + 1) < argc)
      mcsetseed(argv[++i]);
    else if(!strncmp("-s", argv[i], 2))
      mcsetseed(&argv[i][2]);
    else if(!strcmp("--seed", argv[i]) && (i + 1) < argc)
      mcsetseed(argv[++i]);
    else if(!strncmp("--seed=", argv[i], 7))
      mcsetseed(&argv[i][7]);
    else if(!strcmp("-n", argv[i]) && (i + 1) < argc)
      mcsetn_arg(argv[++i]);
    else if(!strncmp("-n", argv[i], 2))
      mcsetn_arg(&argv[i][2]);
    else if(!strcmp("--ncount", argv[i]) && (i + 1) < argc)
      mcsetn_arg(argv[++i]);
    else if(!strncmp("--ncount=", argv[i], 9))
      mcsetn_arg(&argv[i][9]);
    else if(!strcmp("-d", argv[i]) && (i + 1) < argc)
      usedir=argv[++i];  /* will create directory after parsing all arguments (end of this function) */
    else if(!strncmp("-d", argv[i], 2))
      usedir=&argv[i][2];
    else if(!strcmp("--dir", argv[i]) && (i + 1) < argc)
      usedir=argv[++i];
    else if(!strncmp("--dir=", argv[i], 6))
      usedir=&argv[i][6];
    else if(!strcmp("-h", argv[i]))
      mcshowhelp(argv[0]);
    else if(!strcmp("--help", argv[i]))
      mcshowhelp(argv[0]);
    else if(!strcmp("-i", argv[i])) {
      mcformat=FLAVOR_UPPER;
      mcinfo();
    }
    else if(!strcmp("--info", argv[i]))
      mcinfo();
    else if(!strcmp("-t", argv[i]))
      mcenabletrace();
    else if(!strcmp("--trace", argv[i]))
      mcenabletrace();
    else if(!strcmp("--gravitation", argv[i]))
      mcgravitation = 1;
    else if(!strcmp("-g", argv[i]))
      mcgravitation = 1;
    else if(!strncmp("--format=", argv[i], 9)) {
      mcformat=&argv[i][9];
    }
    else if(!strcmp("--format", argv[i]) && (i + 1) < argc) {
      mcformat=argv[++i];
    }
    else if(!strcmp("--no-output-files", argv[i]))
      mcdisable_output_files = 1;
    else if(argv[i][0] != '-' && (p = strchr(argv[i], '=')) != NULL)
    {
      *p++ = '\0';

      for(j = 0; j < mcnumipar; j++)
        if(!strcmp(mcinputtable[j].name, argv[i]))
        {
          int status;
          status = (*mcinputtypes[mcinputtable[j].type].getparm)(p,
                        mcinputtable[j].par);
          if(!status || !strlen(p))
          {
            (*mcinputtypes[mcinputtable[j].type].error)
              (mcinputtable[j].name, p);
            exit(1);
          }
          paramsetarray[j] = 1;
          paramset = 1;
          break;
        }
      if(j == mcnumipar)
      {                                /* Unrecognized parameter name */
        fprintf(stderr, "Error: unrecognized parameter %s (mcparseoptions)\n", argv[i]);
        exit(1);
      }
    }
    else if(argv[i][0] == '-') {
      fprintf(stderr, "Error: unrecognized option argument %s (mcparseoptions). Ignored.\n", argv[i++]);
    }
    else {
      fprintf(stderr, "Error: unrecognized argument %s (mcparseoptions). Aborting.\n", argv[i]);
      mcusage(argv[0]);
    }
  }
  if(!paramset)
    mcreadparams();                /* Prompt for parameters if not specified. */
  else
  {
    for(j = 0; j < mcnumipar; j++)
      if(!paramsetarray[j])
      {
        fprintf(stderr, "Error: Instrument parameter %s left unset (mcparseoptions)\n",
                mcinputtable[j].name);
        exit(1);
      }
  }
  free(paramsetarray);
#ifdef USE_MPI
  if (mcdotrace) mpi_node_count=1; /* disable threading when in trace mode */
#endif
  if (usedir && strlen(usedir) && !mcdisable_output_files) mcuse_dir(usedir);
} /* mcparseoptions */

#ifndef NOSIGNALS
mcstatic char  mcsig_message[256];


/*******************************************************************************
* sighandler: signal handler that makes simulation stop, and save results
*******************************************************************************/
void sighandler(int sig)
{
  /* MOD: E. Farhi, Sep 20th 2001: give more info */
  time_t t1, t0;
#define SIG_SAVE 0
#define SIG_TERM 1
#define SIG_STAT 2
#define SIG_ABRT 3

  printf("\n# " MCCODE_STRING ": [pid %i] Signal %i detected", getpid(), sig);
#ifdef USE_MPI
  printf(" [proc %i]", mpi_node_rank);
#endif
#if defined(SIGUSR1) && defined(SIGUSR2) && defined(SIGKILL)
  if (!strcmp(mcsig_message, "sighandler") && (sig != SIGUSR1) && (sig != SIGUSR2))
  {
    printf("\n# Fatal : unrecoverable loop ! Suicide (naughty boy).\n");
    kill(0, SIGKILL); /* kill myself if error occurs within sighandler: loops */
  }
#endif
  switch (sig) {
#ifdef SIGINT
    case SIGINT : printf(" SIGINT (interrupt from terminal, Ctrl-C)"); sig = SIG_TERM; break;
#endif
#ifdef SIGILL
    case SIGILL  : printf(" SIGILL (Illegal instruction)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGFPE
    case SIGFPE  : printf(" SIGFPE (Math Error)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGSEGV
    case SIGSEGV : printf(" SIGSEGV (Mem Error)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGTERM
    case SIGTERM : printf(" SIGTERM (Termination)"); sig = SIG_TERM; break;
#endif
#ifdef SIGABRT
    case SIGABRT : printf(" SIGABRT (Abort)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGQUIT
    case SIGQUIT : printf(" SIGQUIT (Quit from terminal)"); sig = SIG_TERM; break;
#endif
#ifdef SIGTRAP
    case SIGTRAP : printf(" SIGTRAP (Trace trap)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGPIPE
    case SIGPIPE : printf(" SIGPIPE (Broken pipe)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGUSR1
    case SIGUSR1 : printf(" SIGUSR1 (Display info)"); sig = SIG_STAT; break;
#endif
#ifdef SIGUSR2
    case SIGUSR2 : printf(" SIGUSR2 (Save simulation)"); sig = SIG_SAVE; break;
#endif
#ifdef SIGHUP
    case SIGHUP  : printf(" SIGHUP (Hangup/update)"); sig = SIG_SAVE; break;
#endif
#ifdef SIGBUS
    case SIGBUS  : printf(" SIGBUS (Bus error)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGURG
    case SIGURG  : printf(" SIGURG (Urgent socket condition)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGBREAK
    case SIGBREAK: printf(" SIGBREAK (Break signal, Ctrl-Break)"); sig = SIG_SAVE; break;
#endif
    default : printf(" (look at signal list for signification)"); sig = SIG_ABRT; break;
  }
  printf("\n");
  printf("# Simulation: %s (%s) \n", mcinstrument_name, mcinstrument_source);
  printf("# Breakpoint: %s ", mcsig_message);
  if (strstr(mcsig_message, "Save") && (sig == SIG_SAVE))
    sig = SIG_STAT;
  SIG_MESSAGE("sighandler");
  if (mcget_ncount() == 0)
    printf("(0 %%)\n" );
  else
  {
    printf("%.2f %% (%10.1f/%10.1f)\n", 100.0*mcget_run_num()/mcget_ncount(), 1.0*mcget_run_num(), 1.0*mcget_ncount());
  }
  t0 = (time_t)mcstartdate;
  t1 = time(NULL);
  printf("# Date:      %s", ctime(&t1));
  printf("# Started:   %s", ctime(&t0));

  if (sig == SIG_STAT)
  {
    printf("# " MCCODE_STRING ": Resuming simulation (continue)\n");
    fflush(stdout);
    return;
  }
  else
  if (sig == SIG_SAVE)
  {
    printf("# " MCCODE_STRING ": Saving data and resume simulation (continue)\n");
    mcsave(NULL);
    fflush(stdout);
    return;
  }
  else
  if (sig == SIG_TERM)
  {
    printf("# " MCCODE_STRING ": Finishing simulation (save results and exit)\n");
    mcfinally();
    exit(0);
  }
  else
  {
    fflush(stdout);
    perror("# Last I/O Error");
    printf("# " MCCODE_STRING ": Simulation stop (abort).\n");
// This portion of the signal handling only works on UNIX
#if defined(__unix__) || defined(__APPLE__)
    signal(sig, SIG_DFL); /* force to use default sighandler now */
    kill(getpid(), sig);  /* and trigger it with the current signal */
#endif
    exit(-1);
  }
#undef SIG_SAVE
#undef SIG_TERM
#undef SIG_STAT
#undef SIG_ABRT

} /* sighandler */
#endif /* !NOSIGNALS */

/*******************************************************************************
* mccode_main: McCode main() function.
*******************************************************************************/
int mccode_main(int argc, char *argv[])
{
/*  double run_num = 0; */
  time_t  t;
#ifdef USE_MPI
  char mpi_node_name[MPI_MAX_PROCESSOR_NAME];
  int  mpi_node_name_len;
#endif /* USE_MPI */

#ifdef MAC
  argc = ccommand(&argv);
#endif

#ifdef USE_MPI
  MPI_Init(&argc,&argv);
  MPI_Comm_size(MPI_COMM_WORLD, &mpi_node_count); /* get number of nodes */
  MPI_Comm_rank(MPI_COMM_WORLD, &mpi_node_rank);
  MPI_Comm_set_name(MPI_COMM_WORLD, mcinstrument_name);
  MPI_Get_processor_name(mpi_node_name, &mpi_node_name_len);
#endif /* USE_MPI */

t = time(NULL);
mcseed = (long)t+(long)getpid();

#ifdef USE_MPI
/* *** print number of nodes *********************************************** */
  if (mpi_node_count > 1) {
    MPI_MASTER(
    printf("Simulation '%s' (%s): running on %i nodes (master is '%s', MPI version %i.%i).\n",
      mcinstrument_name, mcinstrument_source, mpi_node_count, mpi_node_name, MPI_VERSION, MPI_SUBVERSION);
    );
  }
#endif /* USE_MPI */
  
  mcstartdate = (long)t;  /* set start date before parsing options and creating sim file */

/* *** parse options ******************************************************* */
  SIG_MESSAGE("main (Start)");
  mcformat=getenv(FLAVOR_UPPER "_FORMAT") ?
           getenv(FLAVOR_UPPER "_FORMAT") : FLAVOR_UPPER;
  mcinstrument_exe = argv[0]; /* store the executable path */
  /* read simulation parameters and options */
  mcparseoptions(argc, argv); /* sets output dir and format */
  
#ifdef USE_MPI
  if (mpi_node_count > 1) {
    /* share the same seed, then adapt random seed for each node */
    MPI_Bcast(&mcseed, 1, MPI_LONG, 0, MPI_COMM_WORLD); /* root sends its seed to slaves */
    mcseed += mpi_node_rank; /* make sure we use different seeds per node */
  }
#endif
  srandom(mcseed);

/* *** install sig handler, but only once !! after parameters parsing ******* */
#ifndef NOSIGNALS
#ifdef SIGQUIT
  if (signal( SIGQUIT ,sighandler) == SIG_IGN)
    signal( SIGQUIT,SIG_IGN);   /* quit (ASCII FS) */
#endif
#ifdef SIGABRT
  if (signal( SIGABRT ,sighandler) == SIG_IGN)
    signal( SIGABRT,SIG_IGN);   /* used by abort, replace SIGIOT in the future */
#endif
#ifdef SIGTERM
  if (signal( SIGTERM ,sighandler) == SIG_IGN)
    signal( SIGTERM,SIG_IGN);   /* software termination signal from kill */
#endif
#ifdef SIGUSR1
  if (signal( SIGUSR1 ,sighandler) == SIG_IGN)
    signal( SIGUSR1,SIG_IGN);   /* display simulation status */
#endif
#ifdef SIGUSR2
  if (signal( SIGUSR2 ,sighandler) == SIG_IGN)
    signal( SIGUSR2,SIG_IGN);
#endif
#ifdef SIGHUP
  if (signal( SIGHUP ,sighandler) == SIG_IGN)
    signal( SIGHUP,SIG_IGN);
#endif
#ifdef SIGILL
  if (signal( SIGILL ,sighandler) == SIG_IGN)
    signal( SIGILL,SIG_IGN);    /* illegal instruction (not reset when caught) */
#endif
#ifdef SIGFPE
  if (signal( SIGFPE ,sighandler) == SIG_IGN)
    signal( SIGSEGV,SIG_IGN);    /* floating point exception */
#endif
#ifdef SIGBUS
  if (signal( SIGBUS ,sighandler) == SIG_IGN)
    signal( SIGSEGV,SIG_IGN);    /* bus error */
#endif
#ifdef SIGSEGV
  if (signal( SIGSEGV ,sighandler) == SIG_IGN)
    signal( SIGSEGV,SIG_IGN);   /* segmentation violation */
#endif
#endif /* !NOSIGNALS */
  mcsiminfo_init(NULL); /* open SIM */
  SIG_MESSAGE("main (Init)");
  mcinit();
#ifndef NOSIGNALS
#ifdef SIGINT
  if (signal( SIGINT ,sighandler) == SIG_IGN)
    signal( SIGINT,SIG_IGN);    /* interrupt (rubout) only after INIT */
#endif
#endif /* !NOSIGNALS */

/* ================ main particle generation/propagation loop ================ */
#if defined (USE_MPI)
  /* sliced Ncount on each MPI node */
  mcncount = mpi_node_count > 1 ?
    floor(mcncount / mpi_node_count) :
    mcncount; /* number of rays per node */
#endif

/* main particle event loop */
while(mcrun_num < mcncount || mcrun_num < mcget_ncount())
  {
#ifndef NEUTRONICS
    mcgenstate();
#endif
    /* old init: mcsetstate(0, 0, 0, 0, 0, 1, 0, sx=0, sy=1, sz=0, 1); */
    mcraytrace();
    mcrun_num++;
  }

#ifdef USE_MPI
 /* merge run_num from MPI nodes */
  if (mpi_node_count > 1) {
  double mcrun_num_double = (double)mcrun_num;
  mc_MPI_Sum(&mcrun_num_double, 1);
  mcrun_num = (unsigned long long)mcrun_num_double;
  }
#endif

/* save/finally executed by master node/thread */
  mcfinally();

#ifdef USE_MPI
  MPI_Finalize();
#endif /* USE_MPI */

  return 0;
} /* mccode_main */

#ifdef NEUTRONICS
/*Main neutronics function steers the McStas calls, initializes parameters etc */
/* Only called in case NEUTRONICS = TRUE */
void neutronics_main_(float *inx, float *iny, float *inz, float *invx, float *invy, float *invz, float *intime, float *insx, float *insy, float *insz, float *inw, float *outx, float *outy, float *outz, float *outvx, float *outvy, float *outvz, float *outtime, float *outsx, float *outsy, float *outsz, float *outwgt)
{

  extern double mcnx, mcny, mcnz, mcnvx, mcnvy, mcnvz;
  extern double mcnt, mcnsx, mcnsy, mcnsz, mcnp;

  /* External code governs iteration - McStas is iterated once per call to neutronics_main. I.e. below counter must be initiancated for each call to neutronics_main*/
  mcrun_num=0;

  time_t t;
  t = (time_t)mcstartdate;
  mcstartdate = t;  /* set start date before parsing options and creating sim file */
  mcinit();

  /* *** parse options *** */
  SIG_MESSAGE("main (Start)");
  mcformat=getenv(FLAVOR_UPPER "_FORMAT") ?
           getenv(FLAVOR_UPPER "_FORMAT") : FLAVOR_UPPER;

  /* Set neutron state based on input from neutronics code */
  mcsetstate(*inx,*iny,*inz,*invx,*invy,*invz,*intime,*insx,*insy,*insz,*inw);

  /* main neutron event loop - runs only one iteration */

  //mcstas_raytrace(&mcncount); /* prior to McStas 1.12 */

  mcallowbackprop = 1; //avoid absorbtion from negative dt
  int argc=1;
  char *argv[0];
  int dummy = mccode_main(argc, argv);

  *outx =  mcnx;
  *outy =  mcny;
  *outz =  mcnz;
  *outvx =  mcnvx;
  *outvy =  mcnvy;
  *outvz =  mcnvz;
  *outtime =  mcnt;
  *outsx =  mcnsx;
  *outsy =  mcnsy;
  *outsz =  mcnsz;
  *outwgt =  mcnp;

  return;
} /* neutronics_main */

#endif /*NEUTRONICS*/

#endif /* !MCCODE_H */
/* End of file "mccode-r.c". */
/* End of file "mccode-r.c". */

#line 4977 "./SNS_BASIS.c"

#line 1 "mcstas-r.c"
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mcstas-r.c
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McStas X.Y
* Version: $Revision$
*
* Runtime system for McStas.
* Embedded within instrument in runtime mode.
*
* Usage: Automatically embbeded in the c code whenever required.
*
* $Id$
*
*******************************************************************************/

#ifndef MCSTAS_R_H
#include "mcstas-r.h"
#endif
#ifdef DANSE
#include "mcstas-globals.h"
#endif

/*******************************************************************************
* The I/O format definitions and functions
*******************************************************************************/

/*the magnet stack*/
#ifdef MC_POL_COMPAT
void (*mcMagnetPrecession) (double, double, double, double, double, double,
    double, double*, double*, double*, double, Coords, Rotation)=NULL;
Coords   mcMagnetPos;
Rotation mcMagnetRot;
double*  mcMagnetData                = NULL;
/* mcMagneticField(x, y, z, t, Bx, By, Bz) */
int (*mcMagneticField) (double, double, double, double,
    double*, double*, double*, void *) = NULL;
#endif

#ifndef MCSTAS_H

/*******************************************************************************
* mcstore_neutron: stores neutron coodinates into global array (per component)
*******************************************************************************/
void
mcstore_neutron(MCNUM *s, int index, double x, double y, double z,
               double vx, double vy, double vz, double t,
               double sx, double sy, double sz, double p)
{
    double *dptr = &s[11*index];
    *dptr++  = x;
    *dptr++  = y ;
    *dptr++  = z ;
    *dptr++  = vx;
    *dptr++  = vy;
    *dptr++  = vz;
    *dptr++  = t ;
    *dptr++  = sx;
    *dptr++  = sy;
    *dptr++  = sz;
    *dptr    = p ;
} /* mcstore_neutron */

/*******************************************************************************
* mcrestore_neutron: restores neutron coodinates from global array
*******************************************************************************/
void
mcrestore_neutron(MCNUM *s, int index, double *x, double *y, double *z,
               double *vx, double *vy, double *vz, double *t,
               double *sx, double *sy, double *sz, double *p)
{
    double *dptr = &s[11*index];
    *x  =  *dptr++;
    *y  =  *dptr++;
    *z  =  *dptr++;
    *vx =  *dptr++;
    *vy =  *dptr++;
    *vz =  *dptr++;
    *t  =  *dptr++;
    *sx =  *dptr++;
    *sy =  *dptr++;
    *sz =  *dptr++;
    *p  =  *dptr;
} /* mcrestore_neutron */

/*******************************************************************************
* mcsetstate: transfer parameters into global McStas variables 
*******************************************************************************/
void
mcsetstate(double x, double y, double z, double vx, double vy, double vz,
           double t, double sx, double sy, double sz, double p)
{
  extern double mcnx, mcny, mcnz, mcnvx, mcnvy, mcnvz;
  extern double mcnt, mcnsx, mcnsy, mcnsz, mcnp;

  mcnx = x;
  mcny = y;
  mcnz = z;
  mcnvx = vx;
  mcnvy = vy;
  mcnvz = vz;
  mcnt = t;
  mcnsx = sx;
  mcnsy = sy;
  mcnsz = sz;
  mcnp = p;
} /* mcsetstate */

/*******************************************************************************
* mcgenstate: set default neutron parameters 
*******************************************************************************/
void
mcgenstate(void)
{
  mcsetstate(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
  /* old initialisation: mcsetstate(0, 0, 0, 0, 0, 1, 0, sx=0, sy=1, sz=0, 1); */
}

/* intersection routines ==================================================== */

/*******************************************************************************
* inside_rectangle: Check if (x,y) is inside rectangle (xwidth, yheight) 
* return 0 if outside and 1 if inside 
*******************************************************************************/
int inside_rectangle(double x, double y, double xwidth, double yheight)
{
  if (x>-xwidth/2 && x<xwidth/2 && y>-yheight/2 && y<yheight/2)
    return 1;
  else
    return 0;
}

/*******************************************************************************
 * box_intersect: compute time intersection with a box
 * returns 0 when no intersection is found
 *      or 1 in case of intersection with resulting times dt_in and dt_out
 * This function written by Stine Nyborg, 1999. 
 *******************************************************************************/
int box_intersect(double *dt_in, double *dt_out,
                  double x, double y, double z,
                  double vx, double vy, double vz,
                  double dx, double dy, double dz)
{
  double x_in, y_in, z_in, tt, t[6], a, b;
  int i, count, s;

      /* Calculate intersection time for each of the six box surface planes
       *  If the box surface plane is not hit, the result is zero.*/

  if(vx != 0)
   {
    tt = -(dx/2 + x)/vx;
    y_in = y + tt*vy;
    z_in = z + tt*vz;
    if( y_in > -dy/2 && y_in < dy/2 && z_in > -dz/2 && z_in < dz/2)
      t[0] = tt;
    else
      t[0] = 0;

    tt = (dx/2 - x)/vx;
    y_in = y + tt*vy;
    z_in = z + tt*vz;
    if( y_in > -dy/2 && y_in < dy/2 && z_in > -dz/2 && z_in < dz/2)
      t[1] = tt;
    else
      t[1] = 0;
   }
  else
    t[0] = t[1] = 0;

  if(vy != 0)
   {
    tt = -(dy/2 + y)/vy;
    x_in = x + tt*vx;
    z_in = z + tt*vz;
    if( x_in > -dx/2 && x_in < dx/2 && z_in > -dz/2 && z_in < dz/2)
      t[2] = tt;
    else
      t[2] = 0;

    tt = (dy/2 - y)/vy;
    x_in = x + tt*vx;
    z_in = z + tt*vz;
    if( x_in > -dx/2 && x_in < dx/2 && z_in > -dz/2 && z_in < dz/2)
      t[3] = tt;
    else
      t[3] = 0;
   }
  else
    t[2] = t[3] = 0;

  if(vz != 0)
   {
    tt = -(dz/2 + z)/vz;
    x_in = x + tt*vx;
    y_in = y + tt*vy;
    if( x_in > -dx/2 && x_in < dx/2 && y_in > -dy/2 && y_in < dy/2)
      t[4] = tt;
    else
      t[4] = 0;

    tt = (dz/2 - z)/vz;
    x_in = x + tt*vx;
    y_in = y + tt*vy;
    if( x_in > -dx/2 && x_in < dx/2 && y_in > -dy/2 && y_in < dy/2)
      t[5] = tt;
    else
      t[5] = 0;
   }
  else
    t[4] = t[5] = 0;

  /* The intersection is evaluated and *dt_in and *dt_out are assigned */

  a = b = s = 0;
  count = 0;

  for( i = 0; i < 6; i = i + 1 )
    if( t[i] == 0 )
      s = s+1;
    else if( count == 0 )
    {
      a = t[i];
      count = 1;
    }
    else
    {
      b = t[i];
      count = 2;
    }

  if ( a == 0 && b == 0 )
    return 0;
  else if( a < b )
  {
    *dt_in = a;
    *dt_out = b;
    return 1;
  }
  else
  {
    *dt_in = b;
    *dt_out = a;
    return 1;
  }

} /* box_intersect */

/*******************************************************************************
 * cylinder_intersect: compute intersection with a cylinder
 * returns 0 when no intersection is found
 *      or 2/4/8/16 bits depending on intersection,
 *     and resulting times t0 and t1
 * Written by: EM,NB,ABA 4.2.98 
  *******************************************************************************/
int
cylinder_intersect(double *t0, double *t1, double x, double y, double z,
                   double vx, double vy, double vz, double r, double h)
{
  double D, t_in, t_out, y_in, y_out;
  int ret=1;

  D = (2*vx*x + 2*vz*z)*(2*vx*x + 2*vz*z)
    - 4*(vx*vx + vz*vz)*(x*x + z*z - r*r);

  if (D>=0)
  {
    if (vz*vz + vx*vx) {
      t_in  = (-(2*vz*z + 2*vx*x) - sqrt(D))/(2*(vz*vz + vx*vx));
      t_out = (-(2*vz*z + 2*vx*x) + sqrt(D))/(2*(vz*vz + vx*vx));
    } else if (vy) { /* trajectory parallel to cylinder axis */
      t_in = (-h/2-y)/vy;
      t_out = (h/2-y)/vy;
      if (t_in>t_out){
        double tmp=t_in;
        t_in=t_out;t_out=tmp;
      }
    } else return 0;
    y_in = vy*t_in + y;
    y_out =vy*t_out + y;

    if ( (y_in > h/2 && y_out > h/2) || (y_in < -h/2 && y_out < -h/2) )
      return 0;
    else
    {
      if (y_in > h/2)
        { t_in = ((h/2)-y)/vy; ret += 2; }
      else if (y_in < -h/2)
        { t_in = ((-h/2)-y)/vy; ret += 4; }
      if (y_out > h/2)
        { t_out = ((h/2)-y)/vy; ret += 8; }
      else if (y_out < -h/2)
        { t_out = ((-h/2)-y)/vy; ret += 16; }
    }
    *t0 = t_in;
    *t1 = t_out;
    return ret;
  }
  else
  {
    *t0 = *t1 = 0;
    return 0;
  }
} /* cylinder_intersect */


/*******************************************************************************
 * sphere_intersect: Calculate intersection between a line and a sphere.
 * returns 0 when no intersection is found
 *      or 1 in case of intersection with resulting times t0 and t1 
 *******************************************************************************/
int
sphere_intersect(double *t0, double *t1, double x, double y, double z,
                 double vx, double vy, double vz, double r)
{
  double A, B, C, D, v;

  v = sqrt(vx*vx + vy*vy + vz*vz);
  A = v*v;
  B = 2*(x*vx + y*vy + z*vz);
  C = x*x + y*y + z*z - r*r;
  D = B*B - 4*A*C;
  if(D < 0)
    return 0;
  D = sqrt(D);
  *t0 = (-B - D) / (2*A);
  *t1 = (-B + D) / (2*A);
  return 1;
} /* sphere_intersect */

/*******************************************************************************
 * plane_intersect: Calculate intersection between a plane and a line.
 * returns 0 when no intersection is found (i.e. line is parallel to the plane)
 * returns 1 or -1 when intersection time is positive and negative respectively
 *******************************************************************************/
int
plane_intersect(double *t, double x, double y, double z,
                 double vx, double vy, double vz, double nx, double ny, double nz, double wx, double wy, double wz)
{
  double s;
  if (fabs(s=scalar_prod(nx,ny,nz,vx,vy,vz))<FLT_EPSILON) return 0;
  *t = - scalar_prod(nx,ny,nz,x-wx,y-wy,z-wz)/s;
  if (*t<0) return -1;
  else return 1;
} /* plane_intersect */

#endif /* !MCSTAS_H */
/* End of file "mcstas-r.c". */

#line 5337 "./SNS_BASIS.c"
#ifdef MC_TRACE_ENABLED
int mctraceenabled = 1;
#else
int mctraceenabled = 0;
#endif
#define MCSTAS "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../"
int mcdefaultmain = 1;
char mcinstrument_name[] = "SNS_BASIS";
char mcinstrument_source[] = "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr";
char *mcinstrument_exe=NULL; /* will be set to argv[0] in main */
int main(int argc, char *argv[]){return mccode_main(argc, argv);}
void mcinit(void);
void mcraytrace(void);
void mcsave(FILE *);
void mcfinally(void);
void mcdisplay(void);

/* Shared user declarations for all components 'ESS_moderator_short'. */
#line 101 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../obsolete/ESS_moderator_short.comp"
double Mezei_M_fct(double l, double temp)
  {
    double a=949.0/temp;
    return 2*a*a*exp(-a/(l*l))/(l*l*l*l*l);
  }

  double Mezei_F_fct(double t, double tau, int n)
  {
    return (exp(-t/tau)-exp(-n*t/tau))*n/(n-1)/tau;
  }
#line 5367 "./SNS_BASIS.c"

/* Shared user declarations for all components 'PSD_monitor'. */
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"

#ifndef ARRAYS_H
#define ARRAYS_H
typedef double* DArray1d;
DArray1d create_darr1d(int n);
void destroy_darr1d(DArray1d a);

typedef double** DArray2d;
DArray2d create_darr2d(int nx, int ny);
void destroy_darr2d(DArray2d a);

typedef double*** DArray3d;
DArray3d create_darr3d(int nx, int ny, int nz);
void destroy_darr3d(DArray3d a);
#endif
#ifndef ARRAYS_C
#define ARRAYS_C
#include <stdlib.h>

typedef double* DArray1d;
typedef double** DArray2d;
typedef double*** DArray3d;

DArray1d create_darr1d(int n){
  DArray1d arr2d;
  arr2d = calloc(n, sizeof(double));
  return arr2d;
}
void destroy_darr1d(DArray1d a){
  free(a);
}

DArray2d create_darr2d(int nx, int ny){
  DArray2d arr2d;
  arr2d = calloc(nx, sizeof(double *));

  double *p1;
  p1 = calloc(nx*ny, sizeof(double));

  int i;
  for (i=0; i<nx; i++){
    arr2d[i] = &(p1[i*ny]);
  }
  return arr2d;
}
void destroy_darr2d(DArray2d a){
  free(a[0]);
  free(a);
}

DArray3d create_darr3d(int nx, int ny, int nz){
  DArray3d arr3d;
  int i, j;

  // 1d
  arr3d = calloc(nx, sizeof(double **));

  // d2
  double **p1;
  p1 = calloc(nx*ny, sizeof(double *));

  for (i=0; i<nx; i++){
    arr3d[i] = &(p1[i*ny]);
  }

  // 3d
  double *p2;
  p2 = calloc(nx*ny*nz, sizeof(double));
  for (i=0; i<nx; i++){
    for (j=0; j<ny; j++){
      arr3d[i][j] = &(p2[(i*ny+j)*nz]);
    }
  }
  return arr3d;
}
void destroy_darr3d(DArray3d a){
  free(a[0][0]);
  free(a[0]);
  free(a);
}
#endif

#line 5453 "./SNS_BASIS.c"

/* Shared user declarations for all components 'Monitor_nD'. */
#line 216 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/monitor_nd-lib.h
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas 1.6
* Version: $Revision$
*
* This file is to be imported by the monitor_nd related components
* It handles some shared functions.
*
* Usage: within SHARE
* %include "monitor_nd-lib"
*
*******************************************************************************/

#ifndef MONITOR_ND_LIB_H

#define MONITOR_ND_LIB_H "$Revision$"
#define MONnD_COORD_NMAX  30  /* max number of variables to record */

  typedef struct MonitornD_Defines
  {
    int COORD_NONE  ;
    int COORD_X     ;
    int COORD_Y     ;
    int COORD_Z     ;
    int COORD_RADIUS; 
    int COORD_VX    ;
    int COORD_VY    ;
    int COORD_VZ    ;
    int COORD_V     ;
    int COORD_T     ;
    int COORD_P     ;
    int COORD_SX    ;
    int COORD_SY    ;
    int COORD_SZ    ;
    int COORD_KX    ;
    int COORD_KY    ;
    int COORD_KZ    ;
    int COORD_K     ;
    int COORD_ENERGY;
    int COORD_LAMBDA;
    int COORD_KXY   ;
    int COORD_KYZ   ;
    int COORD_KXZ   ;
    int COORD_VXY   ;
    int COORD_VYZ   ;
    int COORD_VXZ   ;
    int COORD_HDIV  ;
    int COORD_VDIV  ;
    int COORD_ANGLE ;
    int COORD_NCOUNT;
    int COORD_THETA ;
    int COORD_PHI   ;
    int COORD_USER1 ;
    int COORD_USER2 ;
    int COORD_USER3 ;
    int COORD_XY    ;
    int COORD_XZ    ;
    int COORD_YZ    ;
    int COORD_PIXELID;

    /* token modifiers */
    int COORD_VAR   ; /* next token should be a variable or normal option */
    int COORD_MIN   ; /* next token is a min value */
    int COORD_MAX   ; /* next token is a max value */
    int COORD_DIM   ; /* next token is a bin value */
    int COORD_FIL   ; /* next token is a filename */
    int COORD_EVNT  ; /* next token is a buffer size value */
    int COORD_3HE   ; /* next token is a 3He pressure value */
    int COORD_LOG   ; /* next variable will be in log scale */
    int COORD_ABS   ; /* next variable will be in abs scale */
    int COORD_SIGNAL; /* next variable will be the signal var */
    int COORD_AUTO  ; /* set auto limits */

    char TOKEN_DEL[32]; /* token separators */

    char SHAPE_SQUARE; /* shape of the monitor */
    char SHAPE_DISK  ;
    char SHAPE_SPHERE;
    char SHAPE_CYLIND;
    char SHAPE_BANANA; /* cylinder without top/bottom, on restricted angular area */
    char SHAPE_BOX   ;
    char SHAPE_PREVIOUS;
    char SHAPE_OFF;

  } MonitornD_Defines_type;

  typedef struct MonitornD_Variables
  {
    double area;
    double Sphere_Radius     ;
    double Cylinder_Height   ;
    char   Flag_With_Borders ;   /* 2 means xy borders too */
    char   Flag_List         ;   /* 1 store 1 buffer, 2 is list all, 3 list all+append */
    char   Flag_Multiple     ;   /* 1 when n1D, 0 for 2D */
    char   Flag_Verbose      ;
    int    Flag_Shape        ;
    char   Flag_Auto_Limits  ;   /* get limits from first Buffer */
    char   Flag_Absorb       ;   /* monitor is also a slit */
    char   Flag_per_cm2      ;   /* flux is per cm2 */
    char   Flag_log          ;   /* log10 of the flux */
    char   Flag_parallel     ;   /* set neutron state back after detection (parallel components) */
    char   Flag_Binary_List  ;
    char   Flag_capture      ;   /* lambda monitor with lambda/lambda(2200m/s = 1.7985 Angs) weightening */
    int    Flag_signal       ;   /* 0:monitor p, else monitor a mean value */
    int    Flag_mantid       ;   /* 0:normal monitor, else do mantid-event specifics */
    int    Flag_OFF          ;   /* Flag to indicate external geometry from OFF file */
    unsigned long OFF_polyidx;   /* When intersection is done externally by off_intersect, this gives the 
				    polygon number, i.e. pixel index */

    unsigned long Coord_Number      ;   /* total number of variables to monitor, plus intensity (0) */
    unsigned long Coord_NumberNoPixel;  /* same but without counting PixelID */
    unsigned long Buffer_Block      ;   /* Buffer size for list or auto limits */
    unsigned long Neutron_Counter   ;   /* event counter, simulation total counts is mcget_ncount() */
    unsigned long Buffer_Counter    ;   /* index in Buffer size (for realloc) */
    unsigned long Buffer_Size       ;
    int    Coord_Type[MONnD_COORD_NMAX];      /* type of variable */
    char   Coord_Label[MONnD_COORD_NMAX][30]; /* label of variable */
    char   Coord_Var[MONnD_COORD_NMAX][30];   /* short id of variable */
    long   Coord_Bin[MONnD_COORD_NMAX];       /* bins of variable array */
    long   Coord_BinProd[MONnD_COORD_NMAX];   /* product of bins of variable array */
    double Coord_Min[MONnD_COORD_NMAX];
    double Coord_Max[MONnD_COORD_NMAX];
    char   Monitor_Label[MONnD_COORD_NMAX*30];/* Label for monitor */
    char   Mon_File[128];                     /* output file name */

    double cx,cy,cz;
    double cvx, cvy, cvz;
    double ckx, cky, ckz;
    double csx, csy, csz;
    double cEx, cEy, cEz;
    double cs1, cs2, ct, cphi, cp;
    double He3_pressure;
    char   Flag_UsePreMonitor    ;   /* use a previously stored neutron parameter set */
    char   UserName1[128];
    char   UserName2[128];
    char   UserName3[128];
    double UserVariable1;
    double UserVariable2;
    double UserVariable3;
    char   option[CHAR_BUF_LENGTH];

    long long int Nsum;
    double psum, p2sum;
    double **Mon2D_N;
    double **Mon2D_p;
    double **Mon2D_p2;
    double *Mon2D_Buffer;
    unsigned long PixelID;

    double mxmin,mxmax,mymin,mymax,mzmin,mzmax;
    double mean_dx, mean_dy, min_x, min_y, max_x, max_y, mean_p;

    char   compcurname[128];
    Coords compcurpos;

  } MonitornD_Variables_type;

/* monitor_nd-lib function prototypes */
/* ========================================================================= */

void Monitor_nD_Init(MonitornD_Defines_type *, MonitornD_Variables_type *, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, int);
int Monitor_nD_Trace(MonitornD_Defines_type *, MonitornD_Variables_type *);
MCDETECTOR Monitor_nD_Save(MonitornD_Defines_type *, MonitornD_Variables_type *);
void Monitor_nD_Finally(MonitornD_Defines_type *, MonitornD_Variables_type *);
void Monitor_nD_McDisplay(MonitornD_Defines_type *,
 MonitornD_Variables_type *);

#define MONND_DECLARE(monname) \
  struct MonitornD_Variables *mcmonnd ## monname;
#define MONND_USER_TITLE(monname, num, title) \
  { mcmonnd ## monname = &(MC_GETPAR(monname, Vars)); \
    strcpy(mcmonnd ## monname->UserName ## num, title); }
#define MONND_USER_VALUE(monname, num, value) \
  { mcmonnd ## monname = &(MC_GETPAR(monname, Vars)); \
    mcmonnd ## monname->UserVariable ## num = (value); }

#endif

/* end of monitor_nd-lib.h */
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/monitor_nd-lib.c
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas 1.6
* Version: $Revision$
*
* This file is to be imported by the monitor_nd related components
* It handles some shared functions. Embedded within instrument in runtime mode.
*
* Usage: within SHARE
* %include "monitor_nd-lib"
*
*******************************************************************************/

#ifndef MONITOR_ND_LIB_H
#error McStas : please import this library with %include "monitor_nd-lib"
#endif

/* ========================================================================= */
/* Monitor_nD_Init: this routine is used to parse options                    */
/* ========================================================================= */

void Monitor_nD_Init(MonitornD_Defines_type *DEFS,
  MonitornD_Variables_type *Vars,
  MCNUM xwidth,
  MCNUM yheight,
  MCNUM zdepth,
  MCNUM xmin,
  MCNUM xmax,
  MCNUM ymin,
  MCNUM ymax,
  MCNUM zmin,
  MCNUM zmax,
  int offflag)
  {
    long carg = 1;
    char *option_copy, *token;
    char Flag_New_token = 1;
    char Flag_End       = 1;
    char Flag_All       = 0;
    char Flag_No        = 0;
    char Flag_abs       = 0;
    int  Flag_auto      = 0;  /* -1: all, 1: the current variable */
    int  Set_Vars_Coord_Type;
    char Set_Vars_Coord_Label[64];
    char Set_Vars_Coord_Var[64];
    char Short_Label[MONnD_COORD_NMAX][64];
    int  Set_Coord_Mode;
    long i=0, j=0;
    double lmin, lmax, XY=0;
    long t;


    t = (long)time(NULL);

/* initialize DEFS */
/* Variables to monitor */
    DEFS->COORD_NONE   =0;
    DEFS->COORD_X      =1;
    DEFS->COORD_Y      =2;
    DEFS->COORD_Z      =3;
    DEFS->COORD_RADIUS =19;
    DEFS->COORD_VX     =4;
    DEFS->COORD_VY     =5;
    DEFS->COORD_VZ     =6;
    DEFS->COORD_V      =16;
    DEFS->COORD_T      =7;
    DEFS->COORD_P      =8;
    DEFS->COORD_SX     =9;
    DEFS->COORD_SY     =10;
    DEFS->COORD_SZ     =11;
    DEFS->COORD_KX     =12;
    DEFS->COORD_KY     =13;
    DEFS->COORD_KZ     =14;
    DEFS->COORD_K      =15;
    DEFS->COORD_ENERGY =17;
    DEFS->COORD_LAMBDA =18;
    DEFS->COORD_HDIV   =20;
    DEFS->COORD_VDIV   =21;
    DEFS->COORD_ANGLE  =22;
    DEFS->COORD_NCOUNT =23;
    DEFS->COORD_THETA  =24;
    DEFS->COORD_PHI    =25;
    DEFS->COORD_USER1  =26;
    DEFS->COORD_USER2  =27;
    DEFS->COORD_USER3  =28;
    DEFS->COORD_XY     =37;
    DEFS->COORD_YZ     =31;
    DEFS->COORD_XZ     =32;
    DEFS->COORD_VXY    =30;
    DEFS->COORD_VYZ    =34;
    DEFS->COORD_VXZ    =36;
    DEFS->COORD_KXY    =29;
    DEFS->COORD_KYZ    =33;
    DEFS->COORD_KXZ    =35;
    DEFS->COORD_PIXELID=38;

/* token modifiers */
    DEFS->COORD_VAR    =0;    /* next token should be a variable or normal option */
    DEFS->COORD_MIN    =1;    /* next token is a min value */
    DEFS->COORD_MAX    =2;    /* next token is a max value */
    DEFS->COORD_DIM    =3;    /* next token is a bin value */
    DEFS->COORD_FIL    =4;    /* next token is a filename */
    DEFS->COORD_EVNT   =5;    /* next token is a buffer size value */
    DEFS->COORD_3HE    =6;    /* next token is a 3He pressure value */
    DEFS->COORD_LOG    =64;   /* next variable will be in log scale */
    DEFS->COORD_ABS    =128;  /* next variable will be in abs scale */
    DEFS->COORD_SIGNAL =256;  /* next variable will be the signal var */
    DEFS->COORD_AUTO   =512;  /* set auto limits */

    strcpy(DEFS->TOKEN_DEL, " =,;[](){}:");  /* token separators */

    DEFS->SHAPE_SQUARE =0;    /* shape of the monitor */
    DEFS->SHAPE_DISK   =1;
    DEFS->SHAPE_SPHERE =2;
    DEFS->SHAPE_CYLIND =3;
    DEFS->SHAPE_BANANA =4;
    DEFS->SHAPE_BOX    =5;
    DEFS->SHAPE_PREVIOUS=6;
    DEFS->SHAPE_OFF=7;

    Vars->Sphere_Radius     = 0;
    Vars->Cylinder_Height   = 0;
    Vars->Flag_With_Borders = 0;   /* 2 means xy borders too */
    Vars->Flag_List         = 0;   /* 1=store 1 buffer, 2=list all, 3=re-use buffer */
    Vars->Flag_Multiple     = 0;   /* 1 when n1D, 0 for 2D */
    Vars->Flag_Verbose      = 0;
    Vars->Flag_Shape        = DEFS->SHAPE_SQUARE;
    Vars->Flag_Auto_Limits  = 0;   /* get limits from first Buffer */
    Vars->Flag_Absorb       = 0;   /* monitor is also a slit */
    Vars->Flag_per_cm2      = 0;   /* flux is per cm2 */
    Vars->Flag_log          = 0;   /* log10 of the flux */
    Vars->Flag_parallel     = 0;   /* set neutron state back after detection (parallel components) */
    Vars->Flag_Binary_List  = 0;   /* save list as a binary file (smaller) */
    Vars->Coord_Number      = 0;   /* total number of variables to monitor, plus intensity (0) */
    Vars->Coord_NumberNoPixel=0;   /* same but without counting PixelID */

/* Allow to specify size of Monitor_nD buffer via a define*/
#ifndef MONND_BUFSIZ
    Vars->Buffer_Block      = 100000;     /* Buffer size for list or auto limits */
#else
	Vars->Buffer_Block      = MONND_BUFSIZ;     /* Buffer size for list or auto limits */	
#endif
    Vars->Neutron_Counter   = 0;   /* event counter, simulation total counts is mcget_ncount() */
    Vars->Buffer_Counter    = 0;   /* index in Buffer size (for realloc) */
    Vars->Buffer_Size       = 0;
    Vars->UserVariable1     = 0;
    Vars->UserVariable2     = 0;
    Vars->He3_pressure      = 0;
    Vars->Flag_capture      = 0;
    Vars->Flag_signal       = DEFS->COORD_P;
    Vars->Flag_mantid       = 0;
    Vars->Flag_OFF          = offflag;
    Vars->OFF_polyidx       = -1;
    Vars->mean_dx=Vars->mean_dy=0;
    Vars->min_x = Vars->max_x  =0;
    Vars->min_y = Vars->max_y  =0;

    Set_Vars_Coord_Type = DEFS->COORD_NONE;
    Set_Coord_Mode = DEFS->COORD_VAR;

    /* handle size parameters */
    /* normal use is with xwidth, yheight, zdepth */
    /* if xmin,xmax,ymin,ymax,zmin,zmax are non 0, use them */
    if (fabs(xmin-xmax) == 0)
      { Vars->mxmin = -fabs(xwidth)/2; Vars->mxmax = fabs(xwidth)/2; }
    else
      { if (xmin < xmax) {Vars->mxmin = xmin; Vars->mxmax = xmax;}
        else {Vars->mxmin = xmax; Vars->mxmax = xmin;}
      }
    if (fabs(ymin-ymax) == 0)
      { Vars->mymin = -fabs(yheight)/2; Vars->mymax = fabs(yheight)/2; }
    else
      { if (ymin < ymax) {Vars->mymin = ymin; Vars->mymax = ymax;}
        else {Vars->mymin = ymax; Vars->mymax = ymin;}
      }
    if (fabs(zmin-zmax) == 0)
      { Vars->mzmin = -fabs(zdepth)/2; Vars->mzmax = fabs(zdepth)/2; }
    else
      { if (zmin < zmax) {Vars->mzmin = zmin; Vars->mzmax = zmax; }
        else {Vars->mzmin = zmax; Vars->mzmax = zmin; }
      }

    if (fabs(Vars->mzmax-Vars->mzmin) == 0)
      Vars->Flag_Shape        = DEFS->SHAPE_SQUARE;
    else
      Vars->Flag_Shape        = DEFS->SHAPE_BOX;

    if (Vars->Flag_OFF) {
      Vars->Flag_Shape        = DEFS->SHAPE_OFF;
    }
    
    /* parse option string */

    option_copy = (char*)malloc(strlen(Vars->option)+1);
    if (option_copy == NULL)
    {
      fprintf(stderr,"Monitor_nD: %s cannot allocate 'options' copy (%li). Fatal.\n", Vars->compcurname, (long)strlen(Vars->option));
      exit(-1);
    }

    if (strlen(Vars->option))
    {
      Flag_End = 0;
      strcpy(option_copy, Vars->option);
    }

    if (strstr(Vars->option, "cm2") || strstr(Vars->option, "cm^2")) Vars->Flag_per_cm2 = 1;

    if (strstr(Vars->option, "binary") || strstr(Vars->option, "float"))
      Vars->Flag_Binary_List  = 1;
    if (strstr(Vars->option, "double"))
      Vars->Flag_Binary_List  = 2;

    strcpy(Vars->Coord_Label[0],"Intensity");
    strncpy(Vars->Coord_Var[0],"p",30);
    Vars->Coord_Type[0] = DEFS->COORD_P;
    Vars->Coord_Bin[0] = 1;
    Vars->Coord_Min[0] = 0;
    Vars->Coord_Max[0] = FLT_MAX;

    /* default file name is comp_name+dateID */
    sprintf(Vars->Mon_File, "%s_%li", Vars->compcurname, t);

    carg = 1;
    while((Flag_End == 0) && (carg < 128))
    {

      if (Flag_New_token) /* retain previous token or get a new one */
      {
        if (carg == 1) token=(char *)strtok(option_copy,DEFS->TOKEN_DEL);
        else token=(char *)strtok(NULL,DEFS->TOKEN_DEL);
        if (token == NULL) Flag_End=1;
      }
      Flag_New_token = 1;
      if ((token != NULL) && (strlen(token) != 0))
      {
        char iskeyword=0; /* left at 0 when variables are processed, 1 for modifiers */
        int  old_Mode;
        /* change token to lower case */
        for (i=0; i<strlen(token); i++) token[i]=tolower(token[i]);
        /* first handle option values from preceeding keyword token detected */
        old_Mode = Set_Coord_Mode;
        if (Set_Coord_Mode == DEFS->COORD_MAX)  /* max=%i */
        {
          if (!Flag_All)
            Vars->Coord_Max[Vars->Coord_Number] = atof(token);
          else
            for (i = 0; i <= Vars->Coord_Number; Vars->Coord_Max[i++] = atof(token));
          Set_Coord_Mode = DEFS->COORD_VAR; Flag_All = 0;
        }
        if (Set_Coord_Mode == DEFS->COORD_MIN)  /* min=%i */
        {
          if (!Flag_All)
            Vars->Coord_Min[Vars->Coord_Number] = atof(token);
          else
            for (i = 0; i <= Vars->Coord_Number; Vars->Coord_Min[i++] = atof(token));
          Set_Coord_Mode = DEFS->COORD_MAX;
        }
        if (Set_Coord_Mode == DEFS->COORD_DIM)  /* bins=%i */
        {
          if (!Flag_All)
            Vars->Coord_Bin[Vars->Coord_Number] = atoi(token);
          else
            for (i = 0; i <= Vars->Coord_Number; Vars->Coord_Bin[i++] = atoi(token));
          Set_Coord_Mode = DEFS->COORD_VAR; Flag_All = 0;
        }
        if (Set_Coord_Mode == DEFS->COORD_FIL)  /* file=%s */
        {
          if (!Flag_No) strncpy(Vars->Mon_File,token,128);
          else { strcpy(Vars->Mon_File,""); Vars->Coord_Number = 0; Flag_End = 1;}
          Set_Coord_Mode = DEFS->COORD_VAR;
        }
        if (Set_Coord_Mode == DEFS->COORD_EVNT) /* list=%i */
        {
          if (!strcmp(token, "all") || Flag_All) Vars->Flag_List = 2;
          else { i = (long)ceil(atof(token)); if (i) Vars->Buffer_Block = i;
            Vars->Flag_List = 1; }
          Set_Coord_Mode = DEFS->COORD_VAR; Flag_All = 0;
        }
        if (Set_Coord_Mode == DEFS->COORD_3HE)  /* pressure=%g */
        {
            Vars->He3_pressure = atof(token);
            Set_Coord_Mode = DEFS->COORD_VAR; Flag_All = 0;
        }

        /* now look for general option keywords */
        if (!strcmp(token, "borders"))  {Vars->Flag_With_Borders = 1; iskeyword=1; }
        if (!strcmp(token, "verbose"))  {Vars->Flag_Verbose      = 1; iskeyword=1; }
        if (!strcmp(token, "log"))      {Vars->Flag_log          = 1; iskeyword=1; }
        if (!strcmp(token, "abs"))      {Flag_abs                = 1; iskeyword=1; }
        if (!strcmp(token, "multiple")) {Vars->Flag_Multiple     = 1; iskeyword=1; }
        if (!strcmp(token, "list") || !strcmp(token, "events")) {
          Vars->Flag_List = 1; Set_Coord_Mode = DEFS->COORD_EVNT;  }
        if (!strcmp(token, "limits") || !strcmp(token, "min"))
          Set_Coord_Mode = DEFS->COORD_MIN;
        if (!strcmp(token, "slit") || !strcmp(token, "absorb")) {
          Vars->Flag_Absorb = 1;  iskeyword=1; }
        if (!strcmp(token, "max"))  Set_Coord_Mode = DEFS->COORD_MAX;
        if (!strcmp(token, "bins") || !strcmp(token, "dim")) Set_Coord_Mode = DEFS->COORD_DIM;
        if (!strcmp(token, "file") || !strcmp(token, "filename")) {
          Set_Coord_Mode = DEFS->COORD_FIL;
          if (Flag_No) { strcpy(Vars->Mon_File,""); Vars->Coord_Number = 0; Flag_End = 1; }
        }
        if (!strcmp(token, "unactivate")) {
          Flag_End = 1; Vars->Coord_Number = 0; iskeyword=1; }
        if (!strcmp(token, "all"))    { Flag_All = 1;  iskeyword=1; }
        if (!strcmp(token, "sphere")) { Vars->Flag_Shape = DEFS->SHAPE_SPHERE; iskeyword=1; }
        if (!strcmp(token, "cylinder")) { Vars->Flag_Shape = DEFS->SHAPE_CYLIND; iskeyword=1; }
        if (!strcmp(token, "banana")) { Vars->Flag_Shape = DEFS->SHAPE_BANANA; iskeyword=1; }
        if (!strcmp(token, "square")) { Vars->Flag_Shape = DEFS->SHAPE_SQUARE; iskeyword=1; }
        if (!strcmp(token, "disk"))   { Vars->Flag_Shape = DEFS->SHAPE_DISK; iskeyword=1; }
        if (!strcmp(token, "box"))     { Vars->Flag_Shape = DEFS->SHAPE_BOX; iskeyword=1; }
        if (!strcmp(token, "previous")) { Vars->Flag_Shape = DEFS->SHAPE_PREVIOUS; iskeyword=1; }
        if (!strcmp(token, "parallel")){ Vars->Flag_parallel = 1; iskeyword=1; }
        if (!strcmp(token, "capture")) { Vars->Flag_capture = 1; iskeyword=1; }
        if (!strcmp(token, "auto") && (Flag_auto != -1)) {
          Vars->Flag_Auto_Limits = 1;
          if (Flag_All) Flag_auto = -1;
          else          Flag_auto = 1;
          iskeyword=1; Flag_All=0; }
        if (!strcmp(token, "premonitor")) {
          Vars->Flag_UsePreMonitor = 1; iskeyword=1; }
        if (!strcmp(token, "3He_pressure") || !strcmp(token, "pressure")) {
          Vars->He3_pressure = 3; iskeyword=1; }
        if (!strcmp(token, "no") || !strcmp(token, "not")) { Flag_No = 1;  iskeyword=1; }
        if (!strcmp(token, "signal")) Set_Coord_Mode = DEFS->COORD_SIGNAL;
        if (!strcmp(token, "mantid")) { Vars->Flag_mantid = 1; iskeyword=1; }

        /* Mode has changed: this was a keyword or value  ? */
        if (Set_Coord_Mode != old_Mode) iskeyword=1;

        /* now look for variable names to monitor */
        Set_Vars_Coord_Type = DEFS->COORD_NONE; lmin = 0; lmax = 0;

        if (!strcmp(token, "x"))
          { Set_Vars_Coord_Type = DEFS->COORD_X; strcpy(Set_Vars_Coord_Label,"x [m]"); strcpy(Set_Vars_Coord_Var,"x");
          lmin = Vars->mxmin; lmax = Vars->mxmax;
          Vars->Coord_Min[Vars->Coord_Number+1] = Vars->mxmin;
          Vars->Coord_Max[Vars->Coord_Number+1] = Vars->mxmax;}
        if (!strcmp(token, "y"))
          { Set_Vars_Coord_Type = DEFS->COORD_Y; strcpy(Set_Vars_Coord_Label,"y [m]"); strcpy(Set_Vars_Coord_Var,"y");
          lmin = Vars->mymin; lmax = Vars->mymax;
          Vars->Coord_Min[Vars->Coord_Number+1] = Vars->mymin;
          Vars->Coord_Max[Vars->Coord_Number+1] = Vars->mymax;}
        if (!strcmp(token, "z"))
          { Set_Vars_Coord_Type = DEFS->COORD_Z; strcpy(Set_Vars_Coord_Label,"z [m]"); strcpy(Set_Vars_Coord_Var,"z"); lmin = Vars->mzmin; lmax = Vars->mzmax; }
        if (!strcmp(token, "k") || !strcmp(token, "wavevector"))
          { Set_Vars_Coord_Type = DEFS->COORD_K; strcpy(Set_Vars_Coord_Label,"|k| [Angs-1]"); strcpy(Set_Vars_Coord_Var,"k"); lmin = 0; lmax = 10; }
        if (!strcmp(token, "v"))
          { Set_Vars_Coord_Type = DEFS->COORD_V; strcpy(Set_Vars_Coord_Label,"Velocity [m/s]"); strcpy(Set_Vars_Coord_Var,"v"); lmin = 0; lmax = 1000000; }
        if (!strcmp(token, "t") || !strcmp(token, "time") || !strcmp(token, "tof"))
          { Set_Vars_Coord_Type = DEFS->COORD_T; strcpy(Set_Vars_Coord_Label,"TOF [s]"); strcpy(Set_Vars_Coord_Var,"t"); lmin = 0; lmax = .1; }
        if ((!strcmp(token, "p") || !strcmp(token, "i") || !strcmp(token, "intensity") || !strcmp(token, "flux")))
          { Set_Vars_Coord_Type = DEFS->COORD_P;
            strcpy(Set_Vars_Coord_Label,"Intensity");
            strncat(Set_Vars_Coord_Label, " [n/s", 30);
            if (Vars->Flag_per_cm2) strncat(Set_Vars_Coord_Label, "/cm2", 30);
            if (XY > 1 && Vars->Coord_Number)
              strncat(Set_Vars_Coord_Label, "/bin", 30);
            strncat(Set_Vars_Coord_Label, "]", 30);
            strcpy(Set_Vars_Coord_Var,"I");
            lmin = 0; lmax = FLT_MAX;
            if (Flag_auto>0) Flag_auto=0;
          }

        if (!strcmp(token, "vx"))
          { Set_Vars_Coord_Type = DEFS->COORD_VX; strcpy(Set_Vars_Coord_Label,"vx [m/s]"); strcpy(Set_Vars_Coord_Var,"vx"); lmin = -1000; lmax = 1000; }
        if (!strcmp(token, "vy"))
          { Set_Vars_Coord_Type = DEFS->COORD_VY; strcpy(Set_Vars_Coord_Label,"vy [m/s]"); strcpy(Set_Vars_Coord_Var,"vy"); lmin = -1000; lmax = 1000; }
        if (!strcmp(token, "vz"))
          { Set_Vars_Coord_Type = DEFS->COORD_VZ; strcpy(Set_Vars_Coord_Label,"vz [m/s]"); strcpy(Set_Vars_Coord_Var,"vz"); lmin = -10000; lmax = 10000; }
        if (!strcmp(token, "kx"))
          { Set_Vars_Coord_Type = DEFS->COORD_KX; strcpy(Set_Vars_Coord_Label,"kx [Angs-1]"); strcpy(Set_Vars_Coord_Var,"kx"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "ky"))
          { Set_Vars_Coord_Type = DEFS->COORD_KY; strcpy(Set_Vars_Coord_Label,"ky [Angs-1]"); strcpy(Set_Vars_Coord_Var,"ky"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "kz"))
          { Set_Vars_Coord_Type = DEFS->COORD_KZ; strcpy(Set_Vars_Coord_Label,"kz [Angs-1]"); strcpy(Set_Vars_Coord_Var,"kz"); lmin = -10; lmax = 10; }
        if (!strcmp(token, "sx"))
          { Set_Vars_Coord_Type = DEFS->COORD_SX; strcpy(Set_Vars_Coord_Label,"sx [1]"); strcpy(Set_Vars_Coord_Var,"sx"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "sy"))
          { Set_Vars_Coord_Type = DEFS->COORD_SY; strcpy(Set_Vars_Coord_Label,"sy [1]"); strcpy(Set_Vars_Coord_Var,"sy"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "sz"))
          { Set_Vars_Coord_Type = DEFS->COORD_SZ; strcpy(Set_Vars_Coord_Label,"sz [1]"); strcpy(Set_Vars_Coord_Var,"sz"); lmin = -1; lmax = 1; }

        if (!strcmp(token, "energy") || !strcmp(token, "omega") || !strcmp(token, "e"))
          { Set_Vars_Coord_Type = DEFS->COORD_ENERGY; strcpy(Set_Vars_Coord_Label,"Energy [meV]"); strcpy(Set_Vars_Coord_Var,"E"); lmin = 0; lmax = 100; }
        if (!strcmp(token, "lambda") || !strcmp(token, "wavelength") || !strcmp(token, "l"))
          { Set_Vars_Coord_Type = DEFS->COORD_LAMBDA; strcpy(Set_Vars_Coord_Label,"Wavelength [Angs]"); strcpy(Set_Vars_Coord_Var,"L"); lmin = 0; lmax = 100; }
        if (!strcmp(token, "radius") || !strcmp(token, "r"))
          { Set_Vars_Coord_Type = DEFS->COORD_RADIUS; strcpy(Set_Vars_Coord_Label,"Radius [m]"); strcpy(Set_Vars_Coord_Var,"xy"); lmin = 0; lmax = xmax; }
        if (!strcmp(token, "xy"))
          { Set_Vars_Coord_Type = DEFS->COORD_XY; strcpy(Set_Vars_Coord_Label,"Radius (xy) [m]"); strcpy(Set_Vars_Coord_Var,"xy"); lmin = 0; lmax = xmax; }
        if (!strcmp(token, "yz"))
          { Set_Vars_Coord_Type = DEFS->COORD_YZ; strcpy(Set_Vars_Coord_Label,"Radius (yz) [m]"); strcpy(Set_Vars_Coord_Var,"yz"); lmin = 0; lmax = xmax; }
        if (!strcmp(token, "xz"))
          { Set_Vars_Coord_Type = DEFS->COORD_XZ; strcpy(Set_Vars_Coord_Label,"Radius (xz) [m]"); strcpy(Set_Vars_Coord_Var,"xz"); lmin = 0; lmax = xmax; }
        if (!strcmp(token, "vxy"))
          { Set_Vars_Coord_Type = DEFS->COORD_VXY; strcpy(Set_Vars_Coord_Label,"Radial Velocity (xy) [m]"); strcpy(Set_Vars_Coord_Var,"Vxy"); lmin = 0; lmax = 2000; }
        if (!strcmp(token, "kxy"))
          { Set_Vars_Coord_Type = DEFS->COORD_KXY; strcpy(Set_Vars_Coord_Label,"Radial Wavevector (xy) [Angs-1]"); strcpy(Set_Vars_Coord_Var,"Kxy"); lmin = 0; lmax = 2; }
        if (!strcmp(token, "vyz"))
          { Set_Vars_Coord_Type = DEFS->COORD_VYZ; strcpy(Set_Vars_Coord_Label,"Radial Velocity (yz) [m]"); strcpy(Set_Vars_Coord_Var,"Vyz"); lmin = 0; lmax = 2000; }
        if (!strcmp(token, "kyz"))
          { Set_Vars_Coord_Type = DEFS->COORD_KYZ; strcpy(Set_Vars_Coord_Label,"Radial Wavevector (yz) [Angs-1]"); strcpy(Set_Vars_Coord_Var,"Kyz"); lmin = 0; lmax = 2; }
        if (!strcmp(token, "vxz"))
          { Set_Vars_Coord_Type = DEFS->COORD_VXZ; strcpy(Set_Vars_Coord_Label,"Radial Velocity (xz) [m]"); strcpy(Set_Vars_Coord_Var,"Vxz"); lmin = 0; lmax = 2000; }
        if (!strcmp(token, "kxz"))
          { Set_Vars_Coord_Type = DEFS->COORD_KXZ; strcpy(Set_Vars_Coord_Label,"Radial Wavevector (xz) [Angs-1]"); strcpy(Set_Vars_Coord_Var,"Kxz"); lmin = 0; lmax = 2; }
        if (!strcmp(token, "angle") || !strcmp(token, "a"))
          { Set_Vars_Coord_Type = DEFS->COORD_ANGLE; strcpy(Set_Vars_Coord_Label,"Angle [deg]"); strcpy(Set_Vars_Coord_Var,"A"); lmin = -50; lmax = 50; }
        if (!strcmp(token, "hdiv")|| !strcmp(token, "divergence") || !strcmp(token, "xdiv") || !strcmp(token, "hd") || !strcmp(token, "dx"))
          { Set_Vars_Coord_Type = DEFS->COORD_HDIV; strcpy(Set_Vars_Coord_Label,"Hor. Divergence [deg]"); strcpy(Set_Vars_Coord_Var,"hd"); lmin = -5; lmax = 5; }
        if (!strcmp(token, "vdiv") || !strcmp(token, "ydiv") || !strcmp(token, "vd") || !strcmp(token, "dy"))
          { Set_Vars_Coord_Type = DEFS->COORD_VDIV; strcpy(Set_Vars_Coord_Label,"Vert. Divergence [deg]"); strcpy(Set_Vars_Coord_Var,"vd"); lmin = -5; lmax = 5; }
        if (!strcmp(token, "theta") || !strcmp(token, "longitude") || !strcmp(token, "th"))
          { Set_Vars_Coord_Type = DEFS->COORD_THETA; strcpy(Set_Vars_Coord_Label,"Longitude [deg]"); strcpy(Set_Vars_Coord_Var,"th"); lmin = -180; lmax = 180; }
        if (!strcmp(token, "phi") || !strcmp(token, "lattitude") || !strcmp(token, "ph"))
          { Set_Vars_Coord_Type = DEFS->COORD_PHI; strcpy(Set_Vars_Coord_Label,"Lattitude [deg]"); strcpy(Set_Vars_Coord_Var,"ph"); lmin = -180; lmax = 180; }
        if (!strcmp(token, "ncounts") || !strcmp(token, "n") || !strcmp(token, "neutron"))
          { Set_Vars_Coord_Type = DEFS->COORD_NCOUNT; strcpy(Set_Vars_Coord_Label,"Neutron ID [1]"); strcpy(Set_Vars_Coord_Var,"n"); lmin = 0; lmax = mcget_ncount(); if (Flag_auto>0) Flag_auto=0; }
        if (!strcmp(token, "id") || !strcmp(token, "pixel"))
          { Set_Vars_Coord_Type = DEFS->COORD_PIXELID; 
            strcpy(Set_Vars_Coord_Label,"Pixel ID [1]"); 
            strcpy(Set_Vars_Coord_Var,"id"); lmin = 0; lmax = FLT_MAX; 
            if (Flag_auto>0) Flag_auto=0;
            Vars->Flag_List = 1; }
        if (!strcmp(token, "user") || !strcmp(token, "user1") || !strcmp(token, "u1"))
          { Set_Vars_Coord_Type = DEFS->COORD_USER1; strncpy(Set_Vars_Coord_Label,Vars->UserName1,30); strcpy(Set_Vars_Coord_Var,"U1"); lmin = -1e10; lmax = 1e10; }
        if (!strcmp(token, "user2") || !strcmp(token, "u2"))
          { Set_Vars_Coord_Type = DEFS->COORD_USER2; strncpy(Set_Vars_Coord_Label,Vars->UserName2,30); strcpy(Set_Vars_Coord_Var,"U2"); lmin = -1e10; lmax = 1e10; }
        if (!strcmp(token, "user3") || !strcmp(token, "u3"))
          { Set_Vars_Coord_Type = DEFS->COORD_USER3; strncpy(Set_Vars_Coord_Label,Vars->UserName3,30); strcpy(Set_Vars_Coord_Var,"U3"); lmin = -1e10; lmax = 1e10; }

        /* now stores variable keywords detected, if any */
        if (Set_Vars_Coord_Type != DEFS->COORD_NONE)
        {
          int Coord_Number = Vars->Coord_Number;
          if (Vars->Flag_log) { Set_Vars_Coord_Type |= DEFS->COORD_LOG; Vars->Flag_log = 0; }
          if (Flag_abs) { Set_Vars_Coord_Type |= DEFS->COORD_ABS; Flag_abs = 0; }
          if (Flag_auto != 0) { Set_Vars_Coord_Type |= DEFS->COORD_AUTO; 
            if (Flag_auto > 0) Flag_auto = 0; }
          if (Set_Coord_Mode == DEFS->COORD_SIGNAL)
          {
            Coord_Number = 0;
            Vars->Flag_signal = Set_Vars_Coord_Type;
          }
          else
          {
            if (Coord_Number < MONnD_COORD_NMAX)
            { Coord_Number++;
              Vars->Coord_Number = Coord_Number; 
              if (Set_Vars_Coord_Type != DEFS->COORD_PIXELID)
                Vars->Coord_NumberNoPixel++;
            }
            else if (Vars->Flag_Verbose) printf("Monitor_nD: %s reached max number of variables (%i).\n", Vars->compcurname, MONnD_COORD_NMAX);
          }
          Vars->Coord_Type[Coord_Number] = Set_Vars_Coord_Type;
          strncpy(Vars->Coord_Label[Coord_Number], Set_Vars_Coord_Label,30);
          strncpy(Vars->Coord_Var[Coord_Number], Set_Vars_Coord_Var,30);
          if (lmin > lmax) { XY = lmin; lmin=lmax; lmax = XY; }
          Vars->Coord_Min[Coord_Number] = lmin;
          Vars->Coord_Max[Coord_Number] = lmax;
          if (Set_Vars_Coord_Type == DEFS->COORD_NCOUNT || Set_Vars_Coord_Type == DEFS->COORD_PIXELID || Set_Vars_Coord_Type == DEFS->COORD_SIGNAL)
            Vars->Coord_Bin[Coord_Number] = 1;
          else
            Vars->Coord_Bin[Coord_Number] = 20;
          Set_Coord_Mode = DEFS->COORD_VAR;
          Flag_All = 0;
          Flag_No  = 0;
        } else {
          /* no variable name could be read from options */
          if (!iskeyword) {
            if (strcmp(token, "cm2") && strcmp(token, "incoming")
             && strcmp(token, "outgoing") && strcmp(token, "cm2")
             && strcmp(token, "cm^2") && strcmp(token, "float")
             && strcmp(token, "double") && strcmp(token, "binary")
             && strcmp(token, "steradian") && Vars->Flag_Verbose)
              printf("Monitor_nD: %s: unknown '%s' keyword in 'options'. Ignoring.\n", Vars->compcurname, token);
          }
        }
      carg++;
      } /* end if token */
    } /* end while carg */
    free(option_copy);
    if (carg == 128) printf("Monitor_nD: %s reached max number of tokens (%i). Skipping.\n", Vars->compcurname, 128);

    if ((Vars->Flag_Shape == DEFS->SHAPE_BOX) && (fabs(Vars->mzmax - Vars->mzmin) == 0)) Vars->Flag_Shape = DEFS->SHAPE_SQUARE;

    if (Vars->Flag_log == 1) Vars->Coord_Type[0] |= DEFS->COORD_LOG;
    if (Vars->Coord_Number == 0)
    { Vars->Flag_Auto_Limits=0; Vars->Flag_Multiple=0; Vars->Flag_List=0; }

    /* now setting Monitor Name from variable labels */
    strcpy(Vars->Monitor_Label,"");
    XY = 1; /* will contain total bin number */
    for (i = 0; i <= Vars->Coord_Number; i++)
    {
      if (Flag_auto != 0) Vars->Coord_Type[i] |= DEFS->COORD_AUTO;
      Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
      if ((Set_Vars_Coord_Type == DEFS->COORD_X)
       || (Set_Vars_Coord_Type == DEFS->COORD_Y)
       || (Set_Vars_Coord_Type == DEFS->COORD_Z))
       strcpy(Short_Label[i],"Position");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_THETA)
       || (Set_Vars_Coord_Type == DEFS->COORD_PHI)
       || (Set_Vars_Coord_Type == DEFS->COORD_ANGLE))
       strcpy(Short_Label[i],"Angle");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_XY)
       || (Set_Vars_Coord_Type == DEFS->COORD_XZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_YZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_RADIUS))
       strcpy(Short_Label[i],"Radius");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_VX)
       || (Set_Vars_Coord_Type == DEFS->COORD_VY)
       || (Set_Vars_Coord_Type == DEFS->COORD_VZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_V)
       || (Set_Vars_Coord_Type == DEFS->COORD_VXY)
       || (Set_Vars_Coord_Type == DEFS->COORD_VYZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_VXZ))
       strcpy(Short_Label[i],"Velocity");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_KX)
       || (Set_Vars_Coord_Type == DEFS->COORD_KY)
       || (Set_Vars_Coord_Type == DEFS->COORD_KZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_KXY)
       || (Set_Vars_Coord_Type == DEFS->COORD_KYZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_KXZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_K))
       strcpy(Short_Label[i],"Wavevector");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_SX)
       || (Set_Vars_Coord_Type == DEFS->COORD_SY)
       || (Set_Vars_Coord_Type == DEFS->COORD_SZ))
       strcpy(Short_Label[i],"Spin");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_HDIV)
       || (Set_Vars_Coord_Type == DEFS->COORD_VDIV))
       strcpy(Short_Label[i],"Divergence");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_ENERGY)
       strcpy(Short_Label[i],"Energy");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_LAMBDA)
       strcpy(Short_Label[i],"Wavelength");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_NCOUNT)
       strcpy(Short_Label[i],"Neutron_ID");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_PIXELID)
       strcpy(Short_Label[i],"Pixel_ID");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_T)
          strcpy(Short_Label[i],"Time_Of_Flight");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_P)
          strcpy(Short_Label[i],"Intensity");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_USER1)
          strncpy(Short_Label[i],Vars->UserName1,30);
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_USER2)
          strncpy(Short_Label[i],Vars->UserName2,30);
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_USER3)
          strncpy(Short_Label[i],Vars->UserName3,30);
      else
          strcpy(Short_Label[i],"Unknown");

      if (Vars->Coord_Type[i] & DEFS->COORD_ABS)
      { strcat(Vars->Coord_Label[i]," (abs)"); }

      if (Vars->Coord_Type[i] & DEFS->COORD_LOG)
      { strcat(Vars->Coord_Label[i]," (log)"); }

      strcat(Vars->Monitor_Label, " ");
      strcat(Vars->Monitor_Label, Short_Label[i]);
      XY *= Vars->Coord_Bin[i];

    } /* end for Short_Label */

    if ((Vars->Coord_Type[0] & (DEFS->COORD_LOG-1)) == DEFS->COORD_P) {
      strncat(Vars->Coord_Label[0], " [n/s", 30);
      if (Vars->Flag_per_cm2) strncat(Vars->Coord_Label[0], "/cm2", 30);

      if (XY > 1 && Vars->Coord_Number)
        strncat(Vars->Coord_Label[0], "/bin", 30);
      strncat(Vars->Coord_Label[0], "]", 30);
    }

    /* update label 'signal per bin' if more than 1 bin */
    if (XY > 1 && Vars->Coord_Number) {
      if (Vars->Flag_capture)
        printf("Monitor_nD: %s: Using capture flux weightening on %ld bins.\n"
               "WARNING     Use binned data with caution, and prefer monitor integral value (I,Ierr).\n", Vars->compcurname, (long)XY);
    }

    strcat(Vars->Monitor_Label, " Monitor");
    if (Vars->Flag_Shape == DEFS->SHAPE_SQUARE) strcat(Vars->Monitor_Label, " (Square)");
    if (Vars->Flag_Shape == DEFS->SHAPE_DISK)   strcat(Vars->Monitor_Label, " (Disk)");
    if (Vars->Flag_Shape == DEFS->SHAPE_SPHERE) strcat(Vars->Monitor_Label, " (Sphere)");
    if (Vars->Flag_Shape == DEFS->SHAPE_CYLIND) strcat(Vars->Monitor_Label, " (Cylinder)");
    if (Vars->Flag_Shape == DEFS->SHAPE_BANANA) strcat(Vars->Monitor_Label, " (Banana)");
    if (Vars->Flag_Shape == DEFS->SHAPE_BOX)    strcat(Vars->Monitor_Label, " (Box)");
    if (Vars->Flag_Shape == DEFS->SHAPE_PREVIOUS) strcat(Vars->Monitor_Label, " (on PREVIOUS)");
    if (Vars->Flag_Shape == DEFS->SHAPE_OFF) strcat(Vars->Monitor_Label, " (OFF geometry)");
    if ((Vars->Flag_Shape == DEFS->SHAPE_CYLIND) || (Vars->Flag_Shape == DEFS->SHAPE_BANANA) || (Vars->Flag_Shape == DEFS->SHAPE_SPHERE) || (Vars->Flag_Shape == DEFS->SHAPE_BOX))
    {
      if (strstr(Vars->option, "incoming"))
      {
        Vars->Flag_Shape = abs(Vars->Flag_Shape);
        strcat(Vars->Monitor_Label, " [in]");
      }
      else /* if strstr(Vars->option, "outgoing")) */
      {
        Vars->Flag_Shape = -abs(Vars->Flag_Shape);
        strcat(Vars->Monitor_Label, " [out]");
      }
    }
    if (Vars->Flag_UsePreMonitor == 1)
    {
        strcat(Vars->Monitor_Label, " at ");
        strncat(Vars->Monitor_Label, Vars->UserName1,30);
    }
    if (Vars->Flag_log == 1) strcat(Vars->Monitor_Label, " [log] ");

    /* now allocate memory to store variables in TRACE */

    /* Vars->Coord_Number  0   : intensity or signal
     * Vars->Coord_Number  1:n : detector variables */

    if ((Vars->Coord_NumberNoPixel != 2) && !Vars->Flag_Multiple && !Vars->Flag_List)
    { Vars->Flag_Multiple = 1; /* default is n1D */
      if (Vars->Coord_Number != Vars->Coord_NumberNoPixel) Vars->Flag_List = 1; }

    /* list and auto limits case : Vars->Flag_List or Vars->Flag_Auto_Limits
     * -> Buffer to flush and suppress after Vars->Flag_Auto_Limits
     */
    if ((Vars->Flag_Auto_Limits || Vars->Flag_List) && Vars->Coord_Number)
    { /* Dim : (Vars->Coord_Number+1)*Vars->Buffer_Block matrix (for p, dp) */
      Vars->Mon2D_Buffer = (double *)malloc((Vars->Coord_Number+1)*Vars->Buffer_Block*sizeof(double));
      if (Vars->Mon2D_Buffer == NULL)
      { printf("Monitor_nD: %s cannot allocate Vars->Mon2D_Buffer (%li). No list and auto limits.\n", Vars->compcurname, Vars->Buffer_Block*(Vars->Coord_Number+1)*sizeof(double)); Vars->Flag_List = 0; Vars->Flag_Auto_Limits = 0; }
      else
      {
        for (i=0; i < (Vars->Coord_Number+1)*Vars->Buffer_Block; Vars->Mon2D_Buffer[i++] = (double)0);
      }
      Vars->Buffer_Size = Vars->Buffer_Block;
    }

    /* 1D and n1D case : Vars->Flag_Multiple */
    if (Vars->Flag_Multiple && Vars->Coord_NumberNoPixel)
    { /* Dim : Vars->Coord_Number*Vars->Coord_Bin[i] vectors */
      Vars->Mon2D_N  = (double **)malloc((Vars->Coord_Number)*sizeof(double *));
      Vars->Mon2D_p  = (double **)malloc((Vars->Coord_Number)*sizeof(double *));
      Vars->Mon2D_p2 = (double **)malloc((Vars->Coord_Number)*sizeof(double *));
      if ((Vars->Mon2D_N == NULL) || (Vars->Mon2D_p == NULL) || (Vars->Mon2D_p2 == NULL))
      { fprintf(stderr,"Monitor_nD: %s n1D cannot allocate Vars->Mon2D_N/p/p2 (%li). Fatal.\n", Vars->compcurname, (Vars->Coord_Number)*sizeof(double *)); exit(-1); }
      for (i= 1; i <= Vars->Coord_Number; i++)
      {
        Vars->Mon2D_N[i-1]  = (double *)malloc(Vars->Coord_Bin[i]*sizeof(double));
        Vars->Mon2D_p[i-1]  = (double *)malloc(Vars->Coord_Bin[i]*sizeof(double));
        Vars->Mon2D_p2[i-1] = (double *)malloc(Vars->Coord_Bin[i]*sizeof(double));
        if ((Vars->Mon2D_N == NULL) || (Vars->Mon2D_p == NULL) || (Vars->Mon2D_p2 == NULL))
        { fprintf(stderr,"Monitor_nD: %s n1D cannot allocate %s Vars->Mon2D_N/p/p2[%li] (%li). Fatal.\n", Vars->compcurname, Vars->Coord_Var[i], i, (Vars->Coord_Bin[i])*sizeof(double *)); exit(-1); }
        else
        {
          for (j=0; j < Vars->Coord_Bin[i]; j++ )
          { Vars->Mon2D_N[i-1][j] = (double)0; Vars->Mon2D_p[i-1][j] = (double)0; Vars->Mon2D_p2[i-1][j] = (double)0; }
        }
      }
    }
    else /* 2D case : Vars->Coord_Number==2 and !Vars->Flag_Multiple and !Vars->Flag_List */
    if ((Vars->Coord_NumberNoPixel == 2) && !Vars->Flag_Multiple)
    { /* Dim : Vars->Coord_Bin[1]*Vars->Coord_Bin[2] matrix */
      Vars->Mon2D_N  = (double **)malloc((Vars->Coord_Bin[1])*sizeof(double *));
      Vars->Mon2D_p  = (double **)malloc((Vars->Coord_Bin[1])*sizeof(double *));
      Vars->Mon2D_p2 = (double **)malloc((Vars->Coord_Bin[1])*sizeof(double *));
      if ((Vars->Mon2D_N == NULL) || (Vars->Mon2D_p == NULL) || (Vars->Mon2D_p2 == NULL))
      { fprintf(stderr,"Monitor_nD: %s 2D cannot allocate %s Vars->Mon2D_N/p/p2 (%li). Fatal.\n", Vars->compcurname, Vars->Coord_Var[1], (Vars->Coord_Bin[1])*sizeof(double *)); exit(-1); }
      for (i= 0; i < Vars->Coord_Bin[1]; i++)
      {
        Vars->Mon2D_N[i]  = (double *)malloc(Vars->Coord_Bin[2]*sizeof(double));
        Vars->Mon2D_p[i]  = (double *)malloc(Vars->Coord_Bin[2]*sizeof(double));
        Vars->Mon2D_p2[i] = (double *)malloc(Vars->Coord_Bin[2]*sizeof(double));
        if ((Vars->Mon2D_N == NULL) || (Vars->Mon2D_p == NULL) || (Vars->Mon2D_p2 == NULL))
        { fprintf(stderr,"Monitor_nD: %s 2D cannot allocate %s Vars->Mon2D_N/p/p2[%li] (%li). Fatal.\n", Vars->compcurname, Vars->Coord_Var[1], i, (Vars->Coord_Bin[2])*sizeof(double *)); exit(-1); }
        else
        {
          for (j=0; j < Vars->Coord_Bin[2]; j++ )
          { Vars->Mon2D_N[i][j] = (double)0; Vars->Mon2D_p[i][j] = (double)0; Vars->Mon2D_p2[i][j] = (double)0; }
        }
      }
    }
    else {
      Vars->Mon2D_N = Vars->Mon2D_p = Vars->Mon2D_p2 = NULL;
    }
      /* no Mon2D allocated for
       * (Vars->Coord_Number != 2) && !Vars->Flag_Multiple && Vars->Flag_List */

    Vars->psum  = 0;
    Vars->p2sum = 0;
    Vars->Nsum  = 0;

    Vars->area  = fabs(Vars->mxmax - Vars->mxmin)*fabs(Vars->mymax - Vars->mymin)*1E4; /* in cm**2 for square and box shapes */
    Vars->Sphere_Radius = fabs(Vars->mxmax - Vars->mxmin)/2;
    if ((abs(Vars->Flag_Shape) == DEFS->SHAPE_DISK) || (abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE))
    {
      Vars->area = PI*Vars->Sphere_Radius*Vars->Sphere_Radius*1E4; /* disk shapes */
    }


    if (Vars->area == 0 && abs(Vars->Flag_Shape) != DEFS->SHAPE_PREVIOUS ) {
      if (abs(Vars->Flag_Shape) != DEFS->SHAPE_OFF) {  
	Vars->Coord_Number = 0;
      }
    }
    if (Vars->Coord_Number == 0 && Vars->Flag_Verbose)
      printf("Monitor_nD: %s is unactivated (0D)\n", Vars->compcurname);
    Vars->Cylinder_Height = fabs(Vars->mymax - Vars->mymin);

    if (Vars->Flag_Verbose)
    {
      printf("Monitor_nD: %s is a %s.\n", Vars->compcurname, Vars->Monitor_Label);
      printf("Monitor_nD: version %s with options=%s\n", MONITOR_ND_LIB_H, Vars->option);
    }
    
    /* compute the product of bin dimensions for PixelID */
    Vars->Coord_BinProd[0]=1;
    for (i = 1; i <= Vars->Coord_Number; i++)
      Vars->Coord_BinProd[i]=Vars->Coord_Bin[i]*Vars->Coord_BinProd[i-1];
  } /* end Monitor_nD_Init */

/* ========================================================================= */
/* Monitor_nD_Trace: this routine is used to monitor one propagating neutron */
/* return values: 0=neutron was absorbed, -1=neutron was outside bounds, 1=neutron was measured*/
/* ========================================================================= */

int Monitor_nD_Trace(MonitornD_Defines_type *DEFS, MonitornD_Variables_type *Vars)
{

  double  XY=0, pp=0;
  int     retval;
  long    i =0, j =0;
  double  Coord[MONnD_COORD_NMAX];
  long    Coord_Index[MONnD_COORD_NMAX];
  char    While_End   =0;
  long    While_Buffer=0;
  char    Set_Vars_Coord_Type = DEFS->COORD_NONE;
  
  /* the logic below depends mainly on:
       Flag_List:        1=store 1 buffer, 2=list all, 3=re-use buffer 
       Flag_Auto_Limits: 0 (no auto limits/list), 1 (store events into Buffer), 2 (re-emit store events)
   */

  /* Vars->Flag_Auto_Limits=1: buffer full, we read the Buffer, and determine min and max bounds */
  if ((Vars->Buffer_Counter >= Vars->Buffer_Block) && (Vars->Flag_Auto_Limits == 1) && (Vars->Coord_Number > 0))
  {
    /* auto limits case : get limits in Buffer for each variable */
          /* Dim : (Vars->Coord_Number+1)*Vars->Buffer_Block matrix (for p, dp) */
    if (Vars->Flag_Verbose) printf("Monitor_nD: %s getting %li Auto Limits from List (%li events) in TRACE.\n", Vars->compcurname, Vars->Coord_Number, Vars->Buffer_Counter);
    for (i = 1; i <= Vars->Coord_Number; i++)
    {
      if (Vars->Coord_Type[i] & DEFS->COORD_AUTO)
      {
        Vars->Coord_Min[i] =  FLT_MAX;
        Vars->Coord_Max[i] = -FLT_MAX;
        for (j = 0; j < Vars->Buffer_Counter; j++)
        {
          XY = Vars->Mon2D_Buffer[i+j*(Vars->Coord_Number+1)];  /* scanning variables in Buffer */
          if (XY < Vars->Coord_Min[i]) Vars->Coord_Min[i] = XY;
          if (XY > Vars->Coord_Max[i]) Vars->Coord_Max[i] = XY;
        }
        if  (Vars->Flag_Verbose)  
          printf("  %s: min=%g max=%g\n", Vars->Coord_Var[i], Vars->Coord_Min[i], Vars->Coord_Max[i]);
      }
    }
    Vars->Flag_Auto_Limits = 2;  /* pass to 2nd auto limits step (read Buffer and generate new events to store in histograms) */
  } /* end if Flag_Auto_Limits == 1 */

  /* manage realloc for 'list all' if Buffer size exceeded: flush Buffer to file */
  if ((Vars->Buffer_Counter >= Vars->Buffer_Block) && (Vars->Flag_List >= 2))
  {
    if (Vars->Buffer_Size >= 1000000 || Vars->Flag_List == 3)
    { /* save current (possibly append) and re-use Buffer */
      Monitor_nD_Save(DEFS, Vars);
      Vars->Flag_List = 3;
      Vars->Buffer_Block = Vars->Buffer_Size;
      Vars->Buffer_Counter  = 0;
      Vars->Neutron_Counter = 0;
    }
    else
    {
      Vars->Mon2D_Buffer  = (double *)realloc(Vars->Mon2D_Buffer, (Vars->Coord_Number+1)*(Vars->Neutron_Counter+Vars->Buffer_Block)*sizeof(double));
      if (Vars->Mon2D_Buffer == NULL)
            { printf("Monitor_nD: %s cannot reallocate Vars->Mon2D_Buffer[%li] (%li). Skipping.\n", Vars->compcurname, i, (Vars->Neutron_Counter+Vars->Buffer_Block)*sizeof(double)); Vars->Flag_List = 1; }
      else { Vars->Buffer_Counter = 0; Vars->Buffer_Size = Vars->Neutron_Counter+Vars->Buffer_Block; }
    }
  } /* end if Buffer realloc */

  char    outsidebounds=0;
  while (!While_End)
  { /* we generate Coord[] and Coord_index[] from Buffer (auto limits) or passing neutron */
    if ((Vars->Flag_Auto_Limits == 2) && (Vars->Coord_Number > 0))
    { /* Vars->Flag_Auto_Limits == 2: read back from Buffer (Buffer is filled or auto limits have been computed) */
      if (While_Buffer < Vars->Buffer_Block)
      {
        /* first while loop (While_Buffer) */
        /* auto limits case : scan Buffer within limits and store in Mon2D */
        Coord[0] = pp = Vars->Mon2D_Buffer[While_Buffer*(Vars->Coord_Number+1)];

        for (i = 1; i <= Vars->Coord_Number; i++)
        {
          /* scanning variables in Buffer */
          if (Vars->Coord_Bin[i] <= 1) continue;
          XY = (Vars->Coord_Max[i]-Vars->Coord_Min[i]);

          Coord[i] = Vars->Mon2D_Buffer[i+While_Buffer*(Vars->Coord_Number+1)];
          if (XY > 0) Coord_Index[i] = floor((Coord[i]-Vars->Coord_Min[i])*Vars->Coord_Bin[i]/XY);
          else        Coord_Index[i] = 0;
          if (Vars->Flag_With_Borders)
          {
            if (Coord_Index[i] < 0)                   Coord_Index[i] = 0;
            if (Coord_Index[i] >= Vars->Coord_Bin[i]) Coord_Index[i] = Vars->Coord_Bin[i] - 1;
          }
        } /* end for */
        
        /* update the PixelID, we compute it from the previous variables index */
        if (Vars->Coord_NumberNoPixel < Vars->Coord_Number) /* there is a Pixel variable */
        for (i = 1; i <= Vars->Coord_Number; i++) {
          char Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
          if (Set_Vars_Coord_Type == DEFS->COORD_PIXELID) {
            char flag_outside=0;
            Coord_Index[i] = Coord[i] = 0;
            for (j= 1; j < i; j++) {
              /* not for 1D variables with Bin=1 such as PixelID, NCOUNT, Intensity */
              if (Vars->Coord_Bin[j] == 1) continue; 
              if (0 > Coord_Index[j] || Coord_Index[j] >= Vars->Coord_Bin[j]) {
                flag_outside=1;
                Coord[i] = 0;
                break;
              }
              Coord[i] += Coord_Index[j]*Vars->Coord_BinProd[j-1];
            }
            if (!flag_outside) {
              Vars->Mon2D_Buffer[i+While_Buffer*(Vars->Coord_Number+1)] = Coord[i];
            }
          } /* end if PixelID */
        }
        While_Buffer++;
      } /* end if in Buffer */
      else /* (While_Buffer >= Vars->Buffer_Block) && (Vars->Flag_Auto_Limits == 2) */
      {
        Vars->Flag_Auto_Limits = 0;
        if (!Vars->Flag_List) /* free Buffer not needed anymore (no list to output) */
        { /* Dim : (Vars->Coord_Number+1)*Vars->Buffer_Block matrix (for p, p2) */
          free(Vars->Mon2D_Buffer); Vars->Mon2D_Buffer = NULL;
        }
        if (Vars->Flag_Verbose) printf("Monitor_nD: %s flushed %li Auto Limits from List (%li) in TRACE.\n", Vars->compcurname, Vars->Coord_Number, Vars->Buffer_Counter);
      }
    } /* if Vars->Flag_Auto_Limits == 2 */
    
    if (Vars->Flag_Auto_Limits != 2 || !Vars->Coord_Number) /* Vars->Flag_Auto_Limits == 0 (no auto limits/list) or 1 (store events into Buffer) */
    {
      /* automatically compute area and steradian solid angle when in AUTO mode */
      /* compute the steradian solid angle incoming on the monitor */
      double v;
      v=sqrt(Vars->cvx*Vars->cvx
            +Vars->cvy*Vars->cvy
            +Vars->cvz*Vars->cvz);
      if (Vars->min_x > Vars->cx) Vars->min_x = Vars->cx;
      if (Vars->max_x < Vars->cx) Vars->max_x = Vars->cx;
      if (Vars->min_y > Vars->cy) Vars->min_y = Vars->cy;
      if (Vars->max_y < Vars->cy) Vars->max_y = Vars->cy;
      Vars->mean_p  += Vars->cp;
      if (v) {
        Vars->mean_dx += Vars->cp*fabs(Vars->cvx/v);
        Vars->mean_dy += Vars->cp*fabs(Vars->cvy/v);
      }

      for (i = 0; i <= Vars->Coord_Number; i++)
      { /* handle current neutron : last while */
        XY = 0;
        Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
        /* get values for variables to monitor */
        if (Set_Vars_Coord_Type == DEFS->COORD_X) XY = Vars->cx;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_Y) XY = Vars->cy;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_Z) XY = Vars->cz;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VX) XY = Vars->cvx;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VY) XY = Vars->cvy;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VZ) XY = Vars->cvz;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KX) XY = V2K*Vars->cvx;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KY) XY = V2K*Vars->cvy;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KZ) XY = V2K*Vars->cvz;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_SX) XY = Vars->csx;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_SY) XY = Vars->csy;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_SZ) XY = Vars->csz;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_T) XY = Vars->ct;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_P) XY = Vars->cp;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_HDIV) XY = RAD2DEG*atan2(Vars->cvx,Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VDIV) XY = RAD2DEG*atan2(Vars->cvy,Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_V) XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_RADIUS)
          XY = sqrt(Vars->cx*Vars->cx+Vars->cy*Vars->cy+Vars->cz*Vars->cz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_XY)
          XY = sqrt(Vars->cx*Vars->cx+Vars->cy*Vars->cy)*(Vars->cx > 0 ? 1 : -1);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_YZ) XY = sqrt(Vars->cy*Vars->cy+Vars->cz*Vars->cz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_XZ)
          XY = sqrt(Vars->cx*Vars->cx+Vars->cz*Vars->cz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VXY) XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VXZ) XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvz*Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VYZ) XY = sqrt(Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_K) { XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);  XY *= V2K; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KXY) { XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy);  XY *= V2K; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KXZ) { XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvz*Vars->cvz);  XY *= V2K; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KYZ) { XY = sqrt(Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);  XY *= V2K; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_ENERGY) { XY = Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz;  XY *= VS2E; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_LAMBDA) { XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);  XY *= V2K; if (XY != 0) XY = 2*PI/XY; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_NCOUNT) XY = Vars->Neutron_Counter;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_ANGLE)
        {  XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy);
           if (Vars->cvz != 0)
                XY = RAD2DEG*atan2(XY,Vars->cvz)*(Vars->cx > 0 ? 1 : -1);
           else XY = 0;
        }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_THETA)  { if (Vars->cz != 0) XY = RAD2DEG*atan2(Vars->cx,Vars->cz); }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_PHI) { if (Vars->cz != 0) XY = RAD2DEG*asin(Vars->cy/Vars->cz); }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_USER1) XY = Vars->UserVariable1;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_USER2) XY = Vars->UserVariable2;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_USER3) XY = Vars->UserVariable3;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_PIXELID && !Vars->Flag_Auto_Limits) {
          /* compute the PixelID from previous coordinates 
             the PixelID is the product of Coord_Index[i] in the detector geometry 
             pixelID = sum( Coord_Index[j]*prod(Vars->Coord_Bin[1:(j-1)]) )
             
             this does not apply when we store events in the buffer as Coord_Index
             is not set. Then the pixelID will be re-computed during SAVE.
          */
          char flag_outside=0;
          for (j= 1; j < i; j++) {
            /* not for 1D variables with Bin=1 such as PixelID, NCOUNT, Intensity */
            if (Vars->Coord_Bin[j] <= 1) continue; 
            if (0 > Coord_Index[j] || Coord_Index[j] >= Vars->Coord_Bin[j]) { 
              flag_outside=1; XY=0; break;
            }
            XY += Coord_Index[j]*Vars->Coord_BinProd[j-1];
          }
	  if (Vars->Flag_mantid && Vars->Flag_OFF && Vars->OFF_polyidx >=0) XY=Vars->OFF_polyidx;
          if (!flag_outside) XY += Vars->Coord_Min[i];
        }
        
        /* handle 'abs' and 'log' keywords */
        if (Vars->Coord_Type[i] & DEFS->COORD_ABS) XY=fabs(XY);

        if (Vars->Coord_Type[i] & DEFS->COORD_LOG) /* compute log of variable if requested */
        {  if (XY > 0) XY = log(XY)/log(10);
           else        XY = -100; }

        Coord[i] = XY; Coord_Index[i] = 0;
        if (i == 0) { pp = XY; Coord_Index[i] = 0; }
        else {
        /* check bounds for variables which have no automatic limits */
          if ((!Vars->Flag_Auto_Limits || !(Vars->Coord_Type[i] & DEFS->COORD_AUTO)) && Vars->Coord_Bin[i]>1)
          { /* compute index in histograms for each variable to monitor */
            XY = (Vars->Coord_Max[i]-Vars->Coord_Min[i]);
            if (XY > 0) Coord_Index[i] = floor((Coord[i]-Vars->Coord_Min[i])*Vars->Coord_Bin[i]/XY);
            if (Vars->Flag_With_Borders)
            {
              if (Coord_Index[i] >= Vars->Coord_Bin[i]) Coord_Index[i] = Vars->Coord_Bin[i] - 1;
              if (Coord_Index[i] < 0) Coord_Index[i] = 0;
            }
            //if (0 > Coord_Index[i] || Coord_Index[i] >= Vars->Coord_Bin[i])
            //  outsidebounds=1;
          } /* else will get Index later from Buffer when Flag_Auto_Limits == 2 */
        }
        
      } /* end for i */
      While_End = 1;
    }/* end else if Vars->Flag_Auto_Limits == 2 */
    
    /* ====================================================================== */
    /* store n1d/2d neutron from Buffer (Auto_Limits == 2) or current neutron in while */
    if (Vars->Flag_Auto_Limits != 1) /* not when storing auto limits Buffer */
    {
      /* apply per cm2 */
      if (Vars->Flag_per_cm2 && Vars->area != 0)
        pp /= Vars->area;

      /* 2D case : Vars->Coord_Number==2 and !Vars->Flag_Multiple and !Vars->Flag_List */
      if ( Vars->Coord_NumberNoPixel == 2 && !Vars->Flag_Multiple)
      { /* Dim : Vars->Coord_Bin[1]*Vars->Coord_Bin[2] matrix */
        
        i = Coord_Index[1];
        j = Coord_Index[2];
        if (i >= 0 && i < Vars->Coord_Bin[1] && j >= 0 && j < Vars->Coord_Bin[2])
        {
          if (Vars->Mon2D_N) { 
            Vars->Mon2D_N[i][j]++;
            Vars->Mon2D_p[i][j] += pp;
            Vars->Mon2D_p2[i][j] += pp*pp;
          }
        } else {
          outsidebounds=1; 
        }
      } else {
        /* 1D and n1D case : Vars->Flag_Multiple */
        /* Dim : Vars->Coord_Number*Vars->Coord_Bin[i] vectors (intensity is not included) */
          
        for (i= 1; i <= Vars->Coord_Number; i++) {
          j = Coord_Index[i];
          if (j >= 0 && j < Vars->Coord_Bin[i]) {
            if  (Vars->Flag_Multiple && Vars->Mon2D_N) {
              Vars->Mon2D_N[i-1][j]++;
              Vars->Mon2D_p[i-1][j]  += pp;
              Vars->Mon2D_p2[i-1][j] += pp*pp;
            }
          } else { 
            outsidebounds=1;
            break;
          }
        }
      }
    } /* end (Vars->Flag_Auto_Limits != 1) */
    
    if (Vars->Flag_Auto_Limits != 2 && !outsidebounds) /* not when reading auto limits Buffer */
    { /* now store Coord into Buffer (no index needed) if necessary (list or auto limits) */
      if ((Vars->Buffer_Counter < Vars->Buffer_Block) && ((Vars->Flag_List) || (Vars->Flag_Auto_Limits == 1)))
      {
          
        for (i = 0; i <= Vars->Coord_Number; i++)
        {
          Vars->Mon2D_Buffer[i + Vars->Neutron_Counter*(Vars->Coord_Number+1)] = Coord[i];
        }
        Vars->Buffer_Counter++;
        if (Vars->Flag_Verbose && (Vars->Buffer_Counter >= Vars->Buffer_Block) && (Vars->Flag_List == 1)) 
          printf("Monitor_nD: %s %li neutrons stored in List.\n", Vars->compcurname, Vars->Buffer_Counter);
      }
      Vars->Neutron_Counter++;
    } /* end (Vars->Flag_Auto_Limits != 2) */
    
  } /* end while */
  Vars->Nsum++;
  Vars->psum  += pp;
  Vars->p2sum += pp*pp;

  /*determine return value: 1:neutron was in bounds and measured, -1: outside bounds, 0: outside bounds, should be absorbed.*/
  if(outsidebounds){
      if(Vars->Flag_Absorb){
          return 0;
      }else{
          return -1;
      }
  }
  return 1;
} /* end Monitor_nD_Trace */

/* ========================================================================= */
/* Monitor_nD_Save: this routine is used to save data files                  */
/* ========================================================================= */

MCDETECTOR Monitor_nD_Save(MonitornD_Defines_type *DEFS, MonitornD_Variables_type *Vars)
  {
    char   *fname;
    long    i,j;
    double *p0m = NULL;
    double *p1m = NULL;
    double *p2m = NULL;
    char    Coord_X_Label[CHAR_BUF_LENGTH];
    double  min1d, max1d;
    double  min2d, max2d;
    long    bin1d, bin2d;
    char    While_End = 0;
    long    While_Buffer = 0;
    double  XY=0, pp=0;
    double  Coord[MONnD_COORD_NMAX];
    long    Coord_Index[MONnD_COORD_NMAX];
    char    label[CHAR_BUF_LENGTH];
    double  ratio;

    MCDETECTOR detector;

    ratio = 100.0*mcget_run_num()/mcget_ncount();
    if (Vars->Flag_Verbose && Vars->Flag_per_cm2) {
      printf("Monitor_nD: %s: active flat detector area is %g [cm^2], total area is %g [cm^2]\n",
        Vars->compcurname, (Vars->max_x-Vars->min_x)
                          *(Vars->max_y-Vars->min_y)*1E4, Vars->area);
      printf("Monitor_nD: %s: beam solid angle is %g [st] (%g x %g [deg^2])\n",
        Vars->compcurname,
        2*fabs(2*atan(Vars->mean_dx/Vars->mean_p)
         *sin(2*atan(Vars->mean_dy/Vars->mean_p)/2)),
        atan(Vars->mean_dx/Vars->mean_p)*RAD2DEG,
        atan(Vars->mean_dy/Vars->mean_p)*RAD2DEG);
    }

    /* check Buffer flush when end of simulation reached */
    if ((Vars->Buffer_Counter <= Vars->Buffer_Block) && Vars->Flag_Auto_Limits && Vars->Mon2D_Buffer && Vars->Buffer_Counter)
    {
      /* Get Auto Limits */
      if (Vars->Flag_Verbose) printf("Monitor_nD: %s getting %li Auto Limits from List (%li events).\n", Vars->compcurname, Vars->Coord_Number, Vars->Buffer_Counter);

      for (i = 1; i <= Vars->Coord_Number; i++)
      {
        if ((Vars->Coord_Type[i] & DEFS->COORD_AUTO) && Vars->Coord_Bin[i] > 1)
        {
          Vars->Coord_Min[i] = FLT_MAX;
          Vars->Coord_Max[i] = -FLT_MAX;
          for (j = 0; j < Vars->Buffer_Counter; j++)
          {
            XY = Vars->Mon2D_Buffer[i+j*(Vars->Coord_Number+1)];  /* scanning variables in Buffer */
            if (XY < Vars->Coord_Min[i]) Vars->Coord_Min[i] = XY;
            if (XY > Vars->Coord_Max[i]) Vars->Coord_Max[i] = XY;
          }
          if  (Vars->Flag_Verbose)  
            printf("  %s: min=%g max=%g in %li bins\n", Vars->Coord_Var[i], Vars->Coord_Min[i], Vars->Coord_Max[i], Vars->Coord_Bin[i]);
        }
      }
      Vars->Flag_Auto_Limits = 2;  /* pass to 2nd auto limits step */
      Vars->Buffer_Block = Vars->Buffer_Counter;

      while (!While_End)
      { /* we generate Coord[] and Coord_index[] from Buffer (auto limits) */
        /* simulation ended before Buffer was filled. Limits have to be computed, and stored events must be sent into histograms */
        
        if (While_Buffer < Vars->Buffer_Block)
        {
          /* first while loops (While_Buffer) */
          Coord[0] = Vars->Mon2D_Buffer[While_Buffer*(Vars->Coord_Number+1)];

          /* auto limits case : scan Buffer within limits and store in Mon2D */
          for (i = 1; i <= Vars->Coord_Number; i++)
          {
            /* scanning variables in Buffer */
            if (Vars->Coord_Bin[i] <= 1) Coord_Index[i] = 0;
            else {
              XY = (Vars->Coord_Max[i]-Vars->Coord_Min[i]);
              Coord[i] = Vars->Mon2D_Buffer[i+While_Buffer*(Vars->Coord_Number+1)];
              if (XY > 0) Coord_Index[i] = floor((Coord[i]-Vars->Coord_Min[i])*Vars->Coord_Bin[i]/XY);
              else Coord_Index[i] = 0;
              if (Vars->Flag_With_Borders)
              {
                if (Coord_Index[i] < 0) Coord_Index[i] = 0;
                if (Coord_Index[i] >= Vars->Coord_Bin[i]) Coord_Index[i] = Vars->Coord_Bin[i] - 1;
              }
            }
          } /* end for */

          /* update the PixelID, we compute it from the previous variables index */
          for (i = 1; i <= Vars->Coord_Number; i++) {
            char Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
            if (Set_Vars_Coord_Type == DEFS->COORD_PIXELID) {
              char outsidebounds=0;
              Coord_Index[i] = Coord[i] = 0;
              for (j= 1; j < i; j++) {
                /* not for 1D variables with Bin=1 such as PixelID, NCOUNT, Intensity */
                if (Vars->Coord_Bin[j] == 1) continue; 
                if (0 > Coord_Index[j] || Coord_Index[j] >= Vars->Coord_Bin[j]) {
                  outsidebounds=1;
                  Coord[i] = 0;
                  break;
                }
                Coord[i] += Coord_Index[j]*Vars->Coord_BinProd[j-1];
              }
              if (!outsidebounds) {
                Vars->Mon2D_Buffer[i+While_Buffer*(Vars->Coord_Number+1)] = Coord[i];
              }
            } /* end if PixelID */
          }
          While_Buffer++;
        } /* end if in Buffer */
        else /* (While_Buffer >= Vars->Buffer_Block) && (Vars->Flag_Auto_Limits == 2) */
        {
          Vars->Flag_Auto_Limits = 0;
          While_End = 1;
          if (Vars->Flag_Verbose) printf("Monitor_nD: %s flushed %li Auto Limits from List (%li).\n", Vars->compcurname, Vars->Coord_Number, Vars->Buffer_Counter);
        }

        /* store n1d/2d section from Buffer */

        pp = Coord[0];
        /* apply per cm2 or per st */
        if (Vars->Flag_per_cm2 && Vars->area      != 0)
          pp /= Vars->area;
        
        /* 2D case : Vars->Coord_Number==2 and !Vars->Flag_Multiple and !Vars->Flag_List */
        if (!Vars->Flag_Multiple && Vars->Coord_NumberNoPixel == 2)
        { /* Dim : Vars->Coord_Bin[1]*Vars->Coord_Bin[2] matrix */
          i = Coord_Index[1];
          j = Coord_Index[2];
          if (i >= 0 && i < Vars->Coord_Bin[1] && j >= 0 && j < Vars->Coord_Bin[2])
          {
            if (Vars->Mon2D_N) {
              Vars->Mon2D_N[i][j]++;
              Vars->Mon2D_p[i][j] += pp;
              Vars->Mon2D_p2[i][j] += pp*pp;
            }
          } else if (Vars->Flag_Absorb) pp=0;
        }
        else
        /* 1D and n1D case : Vars->Flag_Multiple */
        { /* Dim : Vars->Coord_Number*Vars->Coord_Bin[i] vectors (intensity is not included) */
          for (i= 1; i <= Vars->Coord_Number; i++)
          {
            j = Coord_Index[i];
            if (j >= 0 && j < Vars->Coord_Bin[i])
            {
              if (Vars->Flag_Multiple && Vars->Mon2D_N) {
                Vars->Mon2D_N[i-1][j]++;
                Vars->Mon2D_p[i-1][j] += pp;
                Vars->Mon2D_p2[i-1][j] += pp*pp;
              }
            } else if (Vars->Flag_Absorb) {
              pp=0; break;
            }
          }
        } /* end store 2D/1D */
        
      } /* end while */
    } /* end Force Get Limits */

    /* write output files (sent to file as p[i*n + j] vectors) */
    if (Vars->Coord_Number == 0)
    {
      double Nsum;
      double psum, p2sum;
      Nsum = Vars->Nsum;
      psum = Vars->psum;
      p2sum= Vars->p2sum;
      if (Vars->Flag_signal != DEFS->COORD_P && Nsum > 0)
      { psum /=Nsum; p2sum /= Nsum*Nsum; }
      /* DETECTOR_OUT_0D(Vars->Monitor_Label, Vars->Nsum, Vars->psum, Vars->p2sum); */
      detector = mcdetector_out_0D(Vars->Monitor_Label, Nsum, psum, p2sum, Vars->compcurname, Vars->compcurpos);
    }
    else
    if (strlen(Vars->Mon_File) > 0)
    {
      fname = (char*)malloc(strlen(Vars->Mon_File)+10*Vars->Coord_Number);
      if (Vars->Flag_List && Vars->Mon2D_Buffer) /* List: DETECTOR_OUT_2D */
      {
       
        if (Vars->Flag_List >= 2) Vars->Buffer_Size = Vars->Neutron_Counter;
        if (Vars->Buffer_Size >= Vars->Neutron_Counter)
          Vars->Buffer_Size = Vars->Neutron_Counter;
        strcpy(fname,Vars->Mon_File);
        if (strchr(Vars->Mon_File,'.') == NULL) strcat(fname, "_list");

        strcpy(Coord_X_Label,"");
        for (i= 0; i <= Vars->Coord_Number; i++)
        {
          strcat(Coord_X_Label, Vars->Coord_Var[i]);
          strcat(Coord_X_Label, " ");
          if (strchr(Vars->Mon_File,'.') == NULL)
          { strcat(fname, "."); strcat(fname, Vars->Coord_Var[i]); }
        }
        if (Vars->Flag_Verbose) printf("Monitor_nD: %s write monitor file %s List (%lix%li).\n", Vars->compcurname, fname,bin2d,bin1d);

        /* handle the type of list output */
        strcpy(label, Vars->Monitor_Label);
        
        detector = mcdetector_out_list(
              label, "List of neutron events", Coord_X_Label,
              -Vars->Buffer_Size, Vars->Coord_Number+1,
              Vars->Mon2D_Buffer,
              fname, Vars->compcurname, Vars->compcurpos);
      }
      if (Vars->Flag_Multiple) /* n1D: DETECTOR_OUT_1D */
      {
        for (i= 0; i < Vars->Coord_Number; i++)
        {

          strcpy(fname,Vars->Mon_File);
          if (strchr(Vars->Mon_File,'.') == NULL)
          { strcat(fname, "."); strcat(fname, Vars->Coord_Var[i+1]); }
          sprintf(Coord_X_Label, "%s monitor", Vars->Coord_Label[i+1]);
          strcpy(label, Coord_X_Label);
          if (Vars->Coord_Bin[i+1] > 0) { /* 1D monitor */
            if (Vars->Flag_Verbose) printf("Monitor_nD: %s write monitor file %s 1D (%li).\n", Vars->compcurname, fname, Vars->Coord_Bin[i+1]);
            min1d = Vars->Coord_Min[i+1];
            max1d = Vars->Coord_Max[i+1];
            if (min1d == max1d) max1d = min1d+1e-6;
            p1m = (double *)malloc(Vars->Coord_Bin[i+1]*sizeof(double));
            p2m = (double *)malloc(Vars->Coord_Bin[i+1]*sizeof(double));
            if (p2m == NULL) /* use Raw Buffer line output */
            {
              if (Vars->Flag_Verbose) printf("Monitor_nD: %s cannot allocate memory for output. Using raw data.\n", Vars->compcurname);
              if (p1m != NULL) free(p1m);
              detector = mcdetector_out_1D(
              label,
              Vars->Coord_Label[i+1],
              Vars->Coord_Label[0],
              Vars->Coord_Var[i+1],
              min1d, max1d,
              Vars->Coord_Bin[i+1],
              Vars->Mon2D_N[i],Vars->Mon2D_p[i],Vars->Mon2D_p2[i],
              fname, Vars->compcurname, Vars->compcurpos);
            } /* if (p2m == NULL) */
            else
            {
              if (Vars->Flag_log != 0)
              {
                XY = FLT_MAX;
                for (j=0; j < Vars->Coord_Bin[i+1]; j++) /* search min of signal */
                  if ((XY > Vars->Mon2D_p[i][j]) && (Vars->Mon2D_p[i][j] > 0)) XY = Vars->Mon2D_p[i][j];
                if (XY <= 0) XY = -log(FLT_MAX)/log(10); else XY = log(XY)/log(10)-1;
              } /* if */

              for (j=0; j < Vars->Coord_Bin[i+1]; j++)
              {
                p1m[j] = Vars->Mon2D_p[i][j];
                p2m[j] = Vars->Mon2D_p2[i][j];
                if (Vars->Flag_signal != DEFS->COORD_P && Vars->Mon2D_N[i][j] > 0)
                { /* normalize mean signal to the number of events */
                  p1m[j] /= Vars->Mon2D_N[i][j];
                  p2m[j] /= Vars->Mon2D_N[i][j]*Vars->Mon2D_N[i][j];
                }
                if (Vars->Flag_log != 0)
                {
                  if ((p1m[j] > 0) && (p2m[j] > 0))
                  {
                    p2m[j] /= p1m[j]*p1m[j];
                    p1m[j] = log(p1m[j])/log(10);
                  }
                  else
                  {
                    p1m[j] = XY;
                    p2m[j] = 0;
                  }
                }
              } /* for */
              detector = mcdetector_out_1D(
                label,
                Vars->Coord_Label[i+1],
                Vars->Coord_Label[0],
                Vars->Coord_Var[i+1],
                min1d, max1d,
                Vars->Coord_Bin[i+1],
                Vars->Mon2D_N[i],p1m,p2m,
                fname, Vars->compcurname, Vars->compcurpos);

            } /* else */
            /* comment out 'free memory' lines to avoid loosing arrays if
               'detector' structure is used by other instrument parts
            if (p1m != NULL) free(p1m); p1m=NULL;
            if (p2m != NULL) free(p2m); p2m=NULL;
            */
          } else { /* 0d monitor */
            detector = mcdetector_out_0D(label, Vars->Mon2D_p[i][0], Vars->Mon2D_p2[i][0], Vars->Mon2D_N[i][0], Vars->compcurname, Vars->compcurpos);
          }


        } /* for */
      } /* if 1D */
      else
      if (Vars->Coord_NumberNoPixel == 2)  /* 2D: DETECTOR_OUT_2D */
      {
        strcpy(fname,Vars->Mon_File);

        p0m = (double *)malloc(Vars->Coord_Bin[1]*Vars->Coord_Bin[2]*sizeof(double));
        p1m = (double *)malloc(Vars->Coord_Bin[1]*Vars->Coord_Bin[2]*sizeof(double));
        p2m = (double *)malloc(Vars->Coord_Bin[1]*Vars->Coord_Bin[2]*sizeof(double));
        if (p2m == NULL)
        {
          if (Vars->Flag_Verbose) printf("Monitor_nD: %s cannot allocate memory for 2D array (%li). Skipping.\n", Vars->compcurname, 3*Vars->Coord_Bin[1]*Vars->Coord_Bin[2]*sizeof(double));
          /* comment out 'free memory' lines to avoid loosing arrays if
               'detector' structure is used by other instrument parts
          if (p0m != NULL) free(p0m);
          if (p1m != NULL) free(p1m);
          */
        }
        else
        {
          if (Vars->Flag_log != 0)
          {
            XY = FLT_MAX;
            for (i= 0; i < Vars->Coord_Bin[1]; i++)
              for (j= 0; j < Vars->Coord_Bin[2]; j++) /* search min of signal */
                if ((XY > Vars->Mon2D_p[i][j]) && (Vars->Mon2D_p[i][j]>0)) XY = Vars->Mon2D_p[i][j];
            if (XY <= 0) XY = -log(FLT_MAX)/log(10); else XY = log(XY)/log(10)-1;
          }
          for (i= 0; i < Vars->Coord_Bin[1]; i++)
          {
            for (j= 0; j < Vars->Coord_Bin[2]; j++)
            {
              long index;
              index = j + i*Vars->Coord_Bin[2];
              p0m[index] = Vars->Mon2D_N[i][j];
              p1m[index] = Vars->Mon2D_p[i][j];
              p2m[index] = Vars->Mon2D_p2[i][j];
              if (Vars->Flag_signal != DEFS->COORD_P && p0m[index] > 0)
              {
                  p1m[index] /= p0m[index];
                  p2m[index] /= p0m[index]*p0m[index];
              }

              if (Vars->Flag_log != 0)
              {
                if ((p1m[index] > 0) && (p2m[index] > 0))
                {
                  p2m[index] /= (p1m[index]*p1m[index]);
                  p1m[index] = log(p1m[index])/log(10);

                }
                else
                {
                  p1m[index] = XY;
                  p2m[index] = 0;
                }
              }
            }
          }
          if (strchr(Vars->Mon_File,'.') == NULL)
          { strcat(fname, "."); strcat(fname, Vars->Coord_Var[1]);
              strcat(fname, "_"); strcat(fname, Vars->Coord_Var[2]); }
          if (Vars->Flag_Verbose) printf("Monitor_nD: %s write monitor file %s 2D (%lix%li).\n", Vars->compcurname, fname, Vars->Coord_Bin[1], Vars->Coord_Bin[2]);

          min1d = Vars->Coord_Min[1];
          max1d = Vars->Coord_Max[1];
          if (min1d == max1d) max1d = min1d+1e-6;
          min2d = Vars->Coord_Min[2];
          max2d = Vars->Coord_Max[2];
          if (min2d == max2d) max2d = min2d+1e-6;
          strcpy(label, Vars->Monitor_Label);
          if (Vars->Coord_Bin[1]*Vars->Coord_Bin[2] > 1
           && Vars->Flag_signal == DEFS->COORD_P)
            strcat(label, " per bin");

          detector = mcdetector_out_2D(
            label,
            Vars->Coord_Label[1],
            Vars->Coord_Label[2],
            min1d, max1d,
            min2d, max2d,
            Vars->Coord_Bin[1],
            Vars->Coord_Bin[2],
            p0m,p1m,p2m,
            fname, Vars->compcurname, Vars->compcurpos);

          /* comment out 'free memory' lines to avoid loosing arrays if
               'detector' structure is used by other instrument parts
          if (p0m != NULL) free(p0m);
          if (p1m != NULL) free(p1m);
          if (p2m != NULL) free(p2m);
          */
        }
      }
      free(fname);
    }
    return(detector);
  } /* end Monitor_nD_Save */

/* ========================================================================= */
/* Monitor_nD_Finally: this routine is used to free memory                   */
/* ========================================================================= */

void Monitor_nD_Finally(MonitornD_Defines_type *DEFS,
  MonitornD_Variables_type *Vars)
  {
    int i;

    /* Now Free memory Mon2D.. */
    if ((Vars->Flag_Auto_Limits || Vars->Flag_List) && Vars->Coord_Number)
    { /* Dim : (Vars->Coord_Number+1)*Vars->Buffer_Block matrix (for p, dp) */
      if (Vars->Mon2D_Buffer != NULL) free(Vars->Mon2D_Buffer);
    }

    /* 1D and n1D case : Vars->Flag_Multiple */
    if (Vars->Flag_Multiple && Vars->Coord_Number)
    { /* Dim : Vars->Coord_Number*Vars->Coord_Bin[i] vectors */
      for (i= 0; i < Vars->Coord_Number; i++)
      {
        free(Vars->Mon2D_N[i]);
        free(Vars->Mon2D_p[i]);
        free(Vars->Mon2D_p2[i]);
      }
      free(Vars->Mon2D_N);
      free(Vars->Mon2D_p);
      free(Vars->Mon2D_p2);
    }


    /* 2D case : Vars->Coord_Number==2 and !Vars->Flag_Multiple and !Vars->Flag_List */
    if ((Vars->Coord_NumberNoPixel == 2) && !Vars->Flag_Multiple)
    { /* Dim : Vars->Coord_Bin[1]*Vars->Coord_Bin[2] matrix */
      for (i= 0; i < Vars->Coord_Bin[1]; i++)
      {
        free(Vars->Mon2D_N[i]);
        free(Vars->Mon2D_p[i]);
        free(Vars->Mon2D_p2[i]);
      }
      free(Vars->Mon2D_N);
      free(Vars->Mon2D_p);
      free(Vars->Mon2D_p2);
    }
  } /* end Monitor_nD_Finally */

/* ========================================================================= */
/* Monitor_nD_McDisplay: this routine is used to display component           */
/* ========================================================================= */

void Monitor_nD_McDisplay(MonitornD_Defines_type *DEFS,
  MonitornD_Variables_type *Vars)
  {
    double radius, h;
    double xmin;
    double xmax;
    double ymin;
    double ymax;
    double zmin;
    double zmax;
    int    i;
    double hdiv_min=-180, hdiv_max=180, vdiv_min=-90, vdiv_max=90;
    char   restricted = 0;

    radius = Vars->Sphere_Radius;
    h = Vars->Cylinder_Height;
    xmin = Vars->mxmin;
    xmax = Vars->mxmax;
    ymin = Vars->mymin;
    ymax = Vars->mymax;
    zmin = Vars->mzmin;
    zmax = Vars->mzmax;

    /* determine if there are angular limits set at start (no auto) in coord_types
     * cylinder/banana: look for hdiv
     * sphere: look for angle, radius (->atan2(val,radius)), hdiv, vdiv
     * this activates a 'restricted' flag, to draw a region as blades on cylinder/sphere
     */
    for (i= 0; i <= Vars->Coord_Number; i++)
    {
      int Set_Vars_Coord_Type;
      Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
      if (Set_Vars_Coord_Type == DEFS->COORD_HDIV || Set_Vars_Coord_Type == DEFS->COORD_THETA)
      { hdiv_min = Vars->Coord_Min[i]; hdiv_max = Vars->Coord_Max[i]; restricted = 1; }
      else if (Set_Vars_Coord_Type == DEFS->COORD_VDIV || Set_Vars_Coord_Type == DEFS->COORD_PHI)
      { vdiv_min = Vars->Coord_Min[i]; vdiv_max = Vars->Coord_Max[i];restricted = 1;  }
      else if (Set_Vars_Coord_Type == DEFS->COORD_ANGLE)
      { hdiv_min = vdiv_min = Vars->Coord_Min[i];
        hdiv_max = vdiv_max = Vars->Coord_Max[i];
        restricted = 1; }
      else if (Set_Vars_Coord_Type == DEFS->COORD_RADIUS)
      { double angle;
        angle = RAD2DEG*atan2(Vars->Coord_Max[i], radius);
        hdiv_min = vdiv_min = angle;
        hdiv_max = vdiv_max = angle;
        restricted = 1; }
      else if (Set_Vars_Coord_Type == DEFS->COORD_Y && abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE)
      {
        vdiv_min = atan2(ymin,radius)*RAD2DEG;
        vdiv_max = atan2(ymax,radius)*RAD2DEG;
        restricted = 1;
      }
    }
    /* full sphere */
    if ((!restricted && (abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE))
    || abs(Vars->Flag_Shape) == DEFS->SHAPE_PREVIOUS)
    {
      mcdis_magnify("");
      mcdis_circle("xy",0,0,0,radius);
      mcdis_circle("xz",0,0,0,radius);
      mcdis_circle("yz",0,0,0,radius);
    }
    /* banana/cylinder/sphere portion */
    else
    if (restricted && ((abs(Vars->Flag_Shape) == DEFS->SHAPE_CYLIND)
                    || (abs(Vars->Flag_Shape) == DEFS->SHAPE_BANANA)
                    || (abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE)))
    {
      int NH=24, NV=24;
      int ih, iv;
      double width, height;
      int issphere;
      issphere = (abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE);
      width = (hdiv_max-hdiv_min)/NH;
      if (!issphere) NV=1; /* cylinder has vertical axis */
      else height= (vdiv_max-vdiv_min)/NV;
      
      /* check width and height of elements (sphere) to make sure the nb
         of plates remains limited */
      if (width < 10  && NH > 1) { width = 10;  NH=(hdiv_max-hdiv_min)/width; width=(hdiv_max-hdiv_min)/NH; }
      if (height < 10 && NV > 1) { height = 10; NV=(vdiv_max-vdiv_min)/height; height= (vdiv_max-vdiv_min)/NV; }
      
      mcdis_magnify("xyz");
      for(ih = 0; ih < NH; ih++)
        for(iv = 0; iv < NV; iv++)
        {
          double theta0, phi0, theta1, phi1;          /* angles in spherical coordinates */
          double x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3; /* vertices at plate edges */
          phi0 = (hdiv_min+ width*ih-90)*DEG2RAD;        /* in xz plane */
          phi1 = (hdiv_min+ width*(ih+1)-90)*DEG2RAD;
          if (issphere)
          {
            theta0= (vdiv_min+height* iv + 90)   *DEG2RAD; /* in vertical plane */
            theta1= (vdiv_min+height*(iv+1) + 90)*DEG2RAD;
            if (y0 < ymin) y0=ymin; 
            if (y0 > ymax) y0=ymax;
            if (y1 < ymin) y1=ymin; 
            if (y1 > ymax) y1=ymax;
            
            y0 = -radius*cos(theta0);            /* z with Z vertical */
            y1 = -radius*cos(theta1);
            if (y0 < ymin) y0=ymin;
            if (y0 > ymax) y0=ymax;
            if (y1 < ymin) y1=ymin;
            if (y1 > ymax) y1=ymax;
          } else {
            y0 = ymin;
            y1 = ymax;
            theta0=theta1=90*DEG2RAD;
          }

          x0 = radius*sin(theta0)*cos(phi0); /* x with Z vertical */
          z0 =-radius*sin(theta0)*sin(phi0); /* y with Z vertical */
          x1 = radius*sin(theta1)*cos(phi0); 
          z1 =-radius*sin(theta1)*sin(phi0);
          x2 = radius*sin(theta1)*cos(phi1); 
          z2 =-radius*sin(theta1)*sin(phi1);
          x3 = radius*sin(theta0)*cos(phi1); 
          z3 =-radius*sin(theta0)*sin(phi1);
          y2 = y1; y3 = y0;

          mcdis_multiline(5,
            x0,y0,z0,
            x1,y1,z1,
            x2,y2,z2,
            x3,y3,z3,
            x0,y0,z0);
        }
      if (Vars->Flag_mantid) {
	/* First define the base pixel type */
	double dt, dy;
	dt = (Vars->Coord_Max[1]-Vars->Coord_Min[1])/Vars->Coord_Bin[1];
	dy = (Vars->Coord_Max[2]-Vars->Coord_Min[2])/Vars->Coord_Bin[2];
	printf("MANTID_BANANA_DET:  %g, %g, %g, %g, %g, %li, %li, %g\n", radius, 
	       Vars->Coord_Min[1],Vars->Coord_Max[1], Vars->Coord_Min[2],Vars->Coord_Max[2], Vars->Coord_Bin[1], Vars->Coord_Bin[2], Vars->Coord_Min[4]); 
      }
    }
    /* disk (circle) */
    else
    if (abs(Vars->Flag_Shape) == DEFS->SHAPE_DISK)
    {
      mcdis_magnify("");
      mcdis_circle("xy",0,0,0,radius);
    }
    /* rectangle (square) */
    else
    if (abs(Vars->Flag_Shape) == DEFS->SHAPE_SQUARE)
    {
      mcdis_magnify("xy");
      mcdis_multiline(5, (double)xmin, (double)ymin, 0.0,
             (double)xmax, (double)ymin, 0.0,
             (double)xmax, (double)ymax, 0.0,
             (double)xmin, (double)ymax, 0.0,
             (double)xmin, (double)ymin, 0.0);
      
      if (Vars->Flag_mantid) {
	/* First define the base pixel type */
	double dx, dy;
	dx = (Vars->Coord_Max[1]-Vars->Coord_Min[1])/Vars->Coord_Bin[1];
	dy = (Vars->Coord_Max[2]-Vars->Coord_Min[2])/Vars->Coord_Bin[2];
	printf("MANTID_RECTANGULAR_DET:  %g, %g, %g, %g, %li, %li, %g\n", 
	       Vars->Coord_Min[1],Vars->Coord_Max[1], Vars->Coord_Min[2],Vars->Coord_Max[2], Vars->Coord_Bin[1], Vars->Coord_Bin[2], Vars->Coord_Min[4]);
      }
    }
    /* full cylinder/banana */
    else
    if (!restricted && ((abs(Vars->Flag_Shape) == DEFS->SHAPE_CYLIND) || (abs(Vars->Flag_Shape) == DEFS->SHAPE_BANANA)))
    {
      mcdis_magnify("xyz");
      mcdis_circle("xz", 0,  h/2.0, 0, radius);
      mcdis_circle("xz", 0, -h/2.0, 0, radius);
      mcdis_line(-radius, -h/2.0, 0, -radius, +h/2.0, 0);
      mcdis_line(+radius, -h/2.0, 0, +radius, +h/2.0, 0);
      mcdis_line(0, -h/2.0, -radius, 0, +h/2.0, -radius);
      mcdis_line(0, -h/2.0, +radius, 0, +h/2.0, +radius);
    }
    else
    /* box */
    if (abs(Vars->Flag_Shape) == DEFS->SHAPE_BOX)
    {
      mcdis_magnify("xyz");
      mcdis_multiline(5, xmin, ymin, zmin,
                   xmax, ymin, zmin,
                   xmax, ymax, zmin,
                   xmin, ymax, zmin,
                   xmin, ymin, zmin);
      mcdis_multiline(5, xmin, ymin, zmax,
                   xmax, ymin, zmax,
                   xmax, ymax, zmax,
                   xmin, ymax, zmax,
                   xmin, ymin, zmax);
      mcdis_line(xmin, ymin, zmin, xmin, ymin, zmax);
      mcdis_line(xmax, ymin, zmin, xmax, ymin, zmax);
      mcdis_line(xmin, ymax, zmin, xmin, ymax, zmax);
      mcdis_line(xmax, ymax, zmin, xmax, ymax, zmax);
    }
  } /* end Monitor_nD_McDisplay */

/* end of monitor_nd-lib.c */

/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/read_table-lib.h
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas 1.6
* Version: $Revision$
*
* This file is to be imported by components that may read data from table files
* It handles some shared functions.
*
* This library may be used directly as an external library. It has no dependency
*
* Usage: within SHARE
* %include "read_table-lib"
*
*******************************************************************************/

#ifndef READ_TABLE_LIB_H
#define READ_TABLE_LIB_H "$Revision$"

#define READ_TABLE_STEPTOL  0.04 /* tolerancy for constant step approx */

#ifndef MC_PATHSEP_C
#ifdef WIN32
#define MC_PATHSEP_C '\\'
#define MC_PATHSEP_S "\\"
#else  /* !WIN32 */
#ifdef MAC
#define MC_PATHSEP_C ':'
#define MC_PATHSEP_S ":"
#else  /* !MAC */
#define MC_PATHSEP_C '/'
#define MC_PATHSEP_S "/"
#endif /* !MAC */
#endif /* !WIN32 */
#endif /* !MC_PATHSEP_C */

#ifndef MCSTAS
#ifdef WIN32
#define MCSTAS "C:\\mcstas\\lib"
#else  /* !WIN32 */
#ifdef MAC
#define MCSTAS ":mcstas:lib" /* ToDo: What to put here? */
#else  /* !MAC */
#define MCSTAS "/usr/local/lib/mcstas"
#endif /* !MAC */
#endif /* !WIN32 */
#endif /* !MCSTAS */

#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>

  typedef struct struct_table
  {
    char    filename[1024];
    long    filesize;
    char   *header;  /* text header, e.g. comments */
    double *data;    /* vector { x[0], y[0], ... x[n-1], y[n-1]... } */
    double  min_x;   /* min value of first column */
    double  max_x;   /* max value of first column */
    double  step_x;  /* minimal step value of first column */
    long    rows;    /* number of rows in matrix block */
    long    columns; /* number of columns in matrix block */

    long    begin;   /* start fseek index of block */
    long    end;     /* stop  fseek index of block */
    long    block_number;  /* block index. 0 is catenation of all */
    long    array_length;  /* number of elements in the t_Table array */
    char    monotonic;     /* true when 1st column/vector data is monotonic */
    char    constantstep;  /* true when 1st column/vector data has constant step */
    char    method[32];    /* interpolation method: nearest, linear */
  } t_Table;

/*maximum number of rows to rebin a table = 1M*/
enum { mcread_table_rebin_maxsize = 1000000 };

typedef struct t_Read_table_file_item {
    int ref_count;
    t_Table *table_ref;
} t_Read_table_file_item;

typedef enum enum_Read_table_file_actions {STORE,FIND,GC}  t_Read_table_file_actions;

/* read_table-lib function prototypes */
/* ========================================================================= */

/* 'public' functions */
long     Table_Read              (t_Table *Table, char *File, long block_number);
long     Table_Read_Offset       (t_Table *Table, char *File, long block_number,
                                  long *offset, long max_lines);
long     Table_Read_Offset_Binary(t_Table *Table, char *File, char *Type,
                                  long *Offset, long Rows, long Columns);
long     Table_Rebin(t_Table *Table); /* rebin table with regular 1st column and interpolate all columns 2:end */
long     Table_Info (t_Table Table);
double   Table_Index(t_Table Table,   long i, long j); /* get indexed value */
double   Table_Value(t_Table Table, double X, long j); /* search X in 1st column and return interpolated value in j-column */
t_Table *Table_Read_Array(char *File, long *blocks);
void     Table_Free_Array(t_Table *Table);
long     Table_Info_Array(t_Table *Table);
int      Table_SetElement(t_Table *Table, long i, long j, double value);
long     Table_Init(t_Table *Table, long rows, long columns); /* create a Table */
double   Table_Value2d(t_Table Table, double X, double Y);    /* same as Table_Index with non-integer indices and 2d interpolation */
MCDETECTOR Table_Write(t_Table Table, char*file, char*xl, char*yl, 
           double x1, double x2, double y1, double y2); /* write Table to disk */
void * Table_File_List_Handler(t_Read_table_file_actions action, void *item, void *item_modifier);
t_Table *Table_File_List_find(char *name, int block, int offset);
int Table_File_List_gc(t_Table *tab);
void *Table_File_List_store(t_Table *tab);

#define Table_ParseHeader(header, ...) \
  Table_ParseHeader_backend(header,__VA_ARGS__,NULL);

char **Table_ParseHeader_backend(char *header, ...);

/* private functions */
void Table_Free(t_Table *Table);
long Table_Read_Handle(t_Table *Table, FILE *fid, long block_number, long max_lines, char *name);
static void Table_Stat(t_Table *Table);
double Table_Interp1d(double x, double x1, double y1, double x2, double y2);
double Table_Interp1d_nearest(double x, double x1, double y1, double x2, double y2);
double Table_Interp2d(double x, double y, double x1, double y1, double x2, double y2,
double z11, double z12, double z21, double z22);

#endif

/* end of read_table-lib.h */
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/read_table-lib.c
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas CVS_090504
* Version: $Revision: 5052 $
*
* This file is to be imported by components that may read data from table files
* It handles some shared functions. Embedded within instrument in runtime mode.
*
* Usage: within SHARE
* %include "read_table-lib"
*
*******************************************************************************/

#ifndef READ_TABLE_LIB_H
#include "read_table-lib.h"
#endif


/*******************************************************************************
 * void *Table_File_List_Handler(action, item, item_modifier)
 *   ACTION: handle file entries in the read_table-lib file list. If a file is read - it is supposed to be
 *   stored in a list such that we can avoid reading the same file many times.
 *   input  action: FIND, STORE, GC. check if file exists in the list, store an item in the list, or check if it can be garbage collected.
 *   input item: depends on the action.
 *    FIND)  item is a filename, and item_modifier is the block number
 *    STORE) item is the Table to store - item_modifier is ignored
 *    GC)    item is the Table to check. If it has a ref_count >1 then this is simply decremented.
 *   return  depends on the action
 *    FIND)  return a reference to a table+ref_count item if found - NULL otherwise. I.e. NULL means the file has not been read before and must be read again.
 *    STORE) return NULL always
 *    GC)    return NULL if no garbage collection is needed, return an adress to the t_Table which should be garbage collected. 0x1 is returned if
 *           the item is not found in the list
*******************************************************************************/
void * Table_File_List_Handler(t_Read_table_file_actions action, void *item, void *item_modifier){

    /* logic here is Read_Table should include a call to FIND. If found the return value should just be used as
     * if the table had been read from disk. If not found then read the table and STORE.
     * Table_Free should include a call to GC. If this returns non-NULL then we should proceed with freeing the memory
     * associated with the table item - otherwise only decrement the reference counter since there are more references
     * that may need it.*/

    static t_Read_table_file_item read_table_file_list[1024];  
    static int read_table_file_count=0;

    t_Read_table_file_item *tr;
    switch(action){
        case FIND:
            /*interpret data item as a filename, if it is found return a pointer to the table and increment refcount.
             * if not found return the item itself*/
            tr=read_table_file_list;
            while ( tr->table_ref!=NULL ){
                int i=*((int*) item_modifier);
                int j=*( ((int*) item_modifier)+1);
                if ( !strcmp(tr->table_ref->filename,(char *) item) &&
                        tr->table_ref->block_number==i && tr->table_ref->begin==j ){
                    tr->ref_count++;
                    return (void *) tr;
                }
                tr++;
            }
            return NULL;
        case STORE:
            /*find an available slot and store references to table there*/
            tr=&(read_table_file_list[read_table_file_count++]);
            tr->table_ref = ((t_Table *) item);
            tr->ref_count++;
            return NULL;
        case GC:
            /* Should this item be garbage collected (freed) - if so scratch the entry and return the address of the item - 
             * else decrement ref_count and return NULL.
             * A non-NULL return expects the item to actually be freed afterwards.*/
            tr=read_table_file_list;
            while ( tr->table_ref!=NULL ){
                if ( tr->table_ref->data ==((t_Table *)item)->data && 
                        tr->table_ref->block_number == ((t_Table *)item)->block_number){
                    /*matching item found*/
                    if (tr->ref_count>1){
                        /*the item is found and no garbage collection needed*/
                        tr->ref_count--;
                        return NULL;
                    }else{
                        /* The item is found and the reference counter is 1.
                         * This means we should garbage collect. Move remaining list items up one slot,
                         * and return the table for garbage collection by caller*/
                        while (tr->table_ref!=NULL){
                            *tr=*(tr+1);
                            tr++;
                        }
                        read_table_file_count--;
                        return (t_Table *) item;
                    }
                }
                tr++;
            }
            /* item not found, and so should be garbage collected. This could be the case if freeing a
             * Table that has been constructed from code - not read from file. Return 0x1 to flag it for
             * collection.*/
            return (void *) 0x1 ;
    }
}

/* Access functions to the handler*/

/********************************************
 * t_Table *Table_File_List_find(char *name, int block, int offset)
 * input name: filename to search for in the file list
 * input block: data block in the file as each file may contain more than 1 data block.
 * return a ref. to a table if it is found (you may use this pointer and skip reading the file), NULL otherwise (i.e. go ahead and read the file)
*********************************************/
t_Table *Table_File_List_find(char *name, int block, int offset){
    int vars[2]={block,offset};
    t_Read_table_file_item *item = Table_File_List_Handler(FIND,name, vars);
    if (item == NULL){
        return NULL;
    }else{
        return item->table_ref;
    }
}
/********************************************
 * int Table_File_List_gc(t_Table *tab)
 * input tab: the table to check for references.
 * return 0: no garbage collection needed
 *        1: Table's data and header (at least) should be freed.
*********************************************/
int Table_File_List_gc(t_Table *tab){
    void *rval=Table_File_List_Handler(GC,tab,0);
    if (rval==NULL) return 0;
    else return 1;
}


/*****************************************************************************
 * void *Table_File_List_store(t_Table *tab)
 * input tab: pointer to table to store.
 * return None. 
*******************************************************************************/
void *Table_File_List_store(t_Table *tab){
    return Table_File_List_Handler(STORE,tab,0);
}


/*******************************************************************************
* FILE *Open_File(char *name, char *Mode, char *path)
*   ACTION: search for a file and open it. Optionally return the opened path.
*   input   name:  file name from which table should be extracted
*           mode: "r", "w", "a" or any valid fopen mode
*           path:  NULL or a pointer to at least 1024 allocated chars
*   return  initialized file handle or NULL in case of error
*******************************************************************************/

  FILE *Open_File(char *File, const char *Mode, char *Path)
  {
    char path[1024];
    FILE *hfile = NULL;
    
    if (!File || File[0]=='\0')                     return(NULL);
    if (!strcmp(File,"NULL") || !strcmp(File,"0"))  return(NULL);
    
    /* search in current or full path */
    strncpy(path, File, 1024);
    hfile = fopen(path, Mode);
    if(!hfile)
    {
      char dir[1024];

      if (!hfile && mcinstrument_source[0] != '\0' && strlen(mcinstrument_source)) /* search in instrument source location */
      {
        char *path_pos   = NULL;
        /* extract path: searches for last file separator */
        path_pos    = strrchr(mcinstrument_source, MC_PATHSEP_C);  /* last PATHSEP */
        if (path_pos) {
          long path_length = path_pos +1 - mcinstrument_source;  /* from start to path+sep */
          if (path_length) {
            strncpy(dir, mcinstrument_source, path_length);
            dir[path_length] = '\0';
            snprintf(path, 1024, "%s%c%s", dir, MC_PATHSEP_C, File);
            hfile = fopen(path, Mode);
          }
        }
      }
      if (!hfile && mcinstrument_exe[0] != '\0' && strlen(mcinstrument_exe)) /* search in PWD instrument executable location */
      {
        char *path_pos   = NULL;
        /* extract path: searches for last file separator */
        path_pos    = strrchr(mcinstrument_exe, MC_PATHSEP_C);  /* last PATHSEP */
        if (path_pos) {
          long path_length = path_pos +1 - mcinstrument_exe;  /* from start to path+sep */
          if (path_length) {
            strncpy(dir, mcinstrument_exe, path_length);
            dir[path_length] = '\0';
            snprintf(path, 1024, "%s%c%s", dir, MC_PATHSEP_C, File);
            hfile = fopen(path, Mode);
          }
        }
      }
      if (!hfile) /* search in HOME or . */
      {
        strcpy(dir, getenv("HOME") ? getenv("HOME") : ".");
        snprintf(path, 1024, "%s%c%s", dir, MC_PATHSEP_C, File);
        hfile = fopen(path, Mode);
      }
      if (!hfile) /* search in MCSTAS/data */
      {
        strcpy(dir, getenv(FLAVOR_UPPER) ? getenv(FLAVOR_UPPER) : MCSTAS);
        snprintf(path, 1024, "%s%c%s%c%s", dir, MC_PATHSEP_C, "data", MC_PATHSEP_C, File);
        hfile = fopen(path, Mode);
      }
      if (!hfile) /* search in MVCSTAS/contrib */
      {
        strcpy(dir, getenv(FLAVOR_UPPER) ? getenv(FLAVOR_UPPER) : MCSTAS);
        snprintf(path, 1024, "%s%c%s%c%s", dir, MC_PATHSEP_C, "contrib", MC_PATHSEP_C, File);
        hfile = fopen(path, Mode);
      }
      if(!hfile)
      {
        fprintf(stderr, "Error: Could not open input file '%s' (Open_File)\n", File);
        return (NULL);
      }
    }
    if (Path) strncpy(Path, path, 1024);
    return(hfile);
  } /* end Open_File */

/*******************************************************************************
* long Read_Table(t_Table *Table, char *name, int block_number)
*   ACTION: read a single Table from a text file
*   input   Table: pointer to a t_Table structure
*           name:  file name from which table should be extracted
*           block_number: if the file does contain more than one
*                 data block, then indicates which one to get (from index 1)
*                 a 0 value means append/catenate all
*   return  initialized single Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
* The routine stores any line starting with '#', '%' and ';' into the header
* File is opened, read and closed
* Other lines are interpreted as numerical data, and stored.
* Data block should be a rectangular matrix or vector.
* Data block may be rebinned with Table_Rebin (also sort in ascending order)
*******************************************************************************/
  long Table_Read(t_Table *Table, char *File, long block_number)
  { /* reads all or a single data block from 'file' and returns a Table structure  */
    return(Table_Read_Offset(Table, File, block_number, NULL, 0));
  } /* end Table_Read */

/*******************************************************************************
* long Table_Read_Offset(t_Table *Table, char *name, int block_number, long *offset
*                        long max_rows)
*   ACTION: read a single Table from a text file, starting at offset
*     Same as Table_Read(..) except:
*   input   offset:    pointer to an offset (*offset should be 0 at start)
*           max_rows: max number of data rows to read from file (0 means all)
*   return  initialized single Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
*           updated *offset position (where end of reading occured)
*******************************************************************************/
  long Table_Read_Offset(t_Table *Table, char *File,
                         long block_number, long *offset,
                         long max_rows)
  { /* reads all/a data block in 'file' and returns a Table structure  */
    FILE *hfile;
    long  nelements=0;
    long  begin=0;
    long  filesize=0;
    char  name[1024];
    char  path[1024];
    struct stat stfile;

    /*Need to be able to store the pointer*/
    if (!Table) return(-1);
    
    //if (offset && *offset) snprintf(name, 1024, "%s@%li", File, *offset);
    //else                   
    strncpy(name, File, 1024);
    if(offset && *offset){
        begin=*offset;
    }
    /* Check if the table has already been read from file.
     * If so just reuse the table, if not (this is flagged by returning NULL
     * set up a new table and read the data into it */
    t_Table *tab_p= Table_File_List_find(name,block_number,begin);
    if ( tab_p!=NULL ){
        /*table was found in the Table_File_List*/
        // printf("Reusing input file '%s' (Table_Read_Offset)\n", name);
        *Table=*tab_p;
        return Table->rows*Table->columns;
    }

    /* open the file */
    hfile = Open_File(File, "r", path);
    if (!hfile) return(-1);
    else {
      MPI_MASTER(
      printf("Opening input file '%s' (Table_Read_Offset)\n", path);
      );
    }
    
    /* read file state */
    stat(path,&stfile); filesize = stfile.st_size;
    if (offset && *offset) fseek(hfile, *offset, SEEK_SET);
    begin     = ftell(hfile);
    
    Table_Init(Table, 0, 0);

    /* read file content and set the Table */
    nelements = Table_Read_Handle(Table, hfile, block_number, max_rows, name);
    Table->begin = begin;
    Table->end   = ftell(hfile);
    Table->filesize = (filesize>0 ? filesize : 0);
    Table_Stat(Table);
    
    Table_File_List_store(Table);

    if (offset) *offset=Table->end;
    fclose(hfile);
    return(nelements);

  } /* end Table_Read_Offset */

/*******************************************************************************
* long Table_Read_Offset_Binary(t_Table *Table, char *File, char *type,
*                               long *offset, long rows, long columns)
*   ACTION: read a single Table from a binary file, starting at offset
*     Same as Table_Read_Offset(..) except that it handles binary files.
*   input   type: may be "float"/NULL or "double"
*           offset: pointer to an offset (*offset should be 0 at start)
*           rows   : number of rows (0 means read all)
*           columns: number of columns
*   return  initialized single Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
*           updated *offset position (where end of reading occured)
*******************************************************************************/
  long Table_Read_Offset_Binary(t_Table *Table, char *File, char *type,
                                long *offset, long rows, long columns)
  { /* reads all/a data block in binary 'file' and returns a Table structure  */
    long    nelements, sizeofelement;
    long    filesize;
    FILE   *hfile;
    char    path[1024];
    struct stat stfile;
    double *data;
    long    i;
    long    begin;

    if (!Table) return(-1);

    Table_Init(Table, 0, 0);
    
    /* open the file */
    hfile = Open_File(File, "r", path);
    if (!hfile) return(-1);
    else {
      MPI_MASTER(
      printf("Opening input file '%s' (Table_Read, Binary)\n", path);
      );
    }
    
    /* read file state */
    stat(File,&stfile);
    filesize = stfile.st_size;
    Table->filesize=filesize;
    
    /* read file content */
    if (type && !strcmp(type,"double")) sizeofelement = sizeof(double);
    else  sizeofelement = sizeof(float);
    if (offset && *offset) fseek(hfile, *offset, SEEK_SET);
    begin     = ftell(hfile);
    if (rows && filesize > sizeofelement*columns*rows)
      nelements = columns*rows;
    else nelements = (long)(filesize/sizeofelement);
    if (!nelements || filesize <= *offset) return(0);
    data    = (double*)malloc(nelements*sizeofelement);
    if (!data) {
      fprintf(stderr,"Error: allocating %ld elements for %s file '%s'. Too big (Table_Read_Offset_Binary).\n", nelements, type, File);
      exit(-1);
    }
    nelements = fread(data, sizeofelement, nelements, hfile);

    if (!data || !nelements)
    {
      fprintf(stderr,"Error: reading %ld elements from %s file '%s' (Table_Read_Offset_Binary)\n", nelements, type, File);
      exit(-1);
    }
    Table->begin   = begin;
    Table->end     = ftell(hfile);
    if (offset) *offset=Table->end;
    fclose(hfile);
    data = (double*)realloc(data, (double)nelements*sizeofelement);
    /* copy file data into Table */
    if (type && !strcmp(type,"double")) Table->data = data;
    else {
      float  *s;
      double *dataf;
      s     = (float*)data;
      dataf = (double*)malloc(sizeof(double)*nelements);
      for (i=0; i<nelements; i++)
        dataf[i]=s[i];
      free(data);
      Table->data = dataf;
    }
    strncpy(Table->filename, File, 1024);
    Table->rows    = nelements/columns;
    Table->columns = columns;
    Table->array_length = 1;
    Table->block_number = 1;

    Table_Stat(Table);

    return(nelements);
  } /* end Table_Read_Offset_Binary */

/*******************************************************************************
* long Table_Read_Handle(t_Table *Table, FILE *fid, int block_number, long max_rows, char *name)
*   ACTION: read a single Table from a text file handle (private)
*   input   Table:pointer to a t_Table structure
*           fid:  pointer to FILE handle
*           block_number: if the file does contain more than one
*                 data block, then indicates which one to get (from index 1)
*                 a 0 value means append/catenate all
*           max_rows: if non 0, only reads that number of lines
*   return  initialized single Table t_Table structure containing data, header, ...
*           modified Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
* The routine stores any line starting with '#', '%' and ';' into the header
* Other lines are interpreted as numerical data, and stored.
* Data block should be a rectangular matrix or vector.
* Data block may be rebined with Table_Rebin (also sort in ascending order)
*******************************************************************************/
  long Table_Read_Handle(t_Table *Table, FILE *hfile,
                         long block_number, long max_rows, char *name)
  { /* reads all/a data block from 'file' handle and returns a Table structure  */
    double *Data;
    char *Header              = NULL;
    long  malloc_size         = CHAR_BUF_LENGTH;
    long  malloc_size_h       = 4096;
    long  Rows = 0,   Columns = 0;
    long  count_in_array      = 0;
    long  count_in_header     = 0;
    long  block_Current_index = 0;
    char  flag_End_row_loop   = 0;

    if (!Table) return(-1);
    Table_Init(Table, 0, 0);
    if (name && name[0]!='\0') strncpy(Table->filename, name, 1024);

    if(!hfile) {
       fprintf(stderr, "Error: File handle is NULL (Table_Read_Handle).\n");
       return (-1);
    }
    Header = (char*)  calloc(malloc_size_h, sizeof(char));
    Data   = (double*)calloc(malloc_size,   sizeof(double));
    if ((Header == NULL) || (Data == NULL)) {
       fprintf(stderr, "Error: Could not allocate Table and Header (Table_Read_Handle).\n");
       return (-1);
    }

    int flag_In_array = 0;
    do { /* while (!flag_End_row_loop) */
      char  line[1024*CHAR_BUF_LENGTH];
      long  back_pos=0;   /* ftell start of line */

      back_pos = ftell(hfile);
      if (fgets(line, 1024*CHAR_BUF_LENGTH, hfile) != NULL) { /* analyse line */
        /* first skip blank and tabulation characters */
        int i = strspn(line, " \t");

        /* handle comments: stored in header */
        if (NULL != strchr("#%;/", line[i]))
        { /* line is a comment */
          count_in_header += strlen(line);
          if (count_in_header >= malloc_size_h) {
            /* if succeed and in array : add (and realloc if necessary) */
            malloc_size_h = count_in_header+4096;
            Header        = (char*)realloc(Header, malloc_size_h*sizeof(char));
          }
          strncat(Header, line, 4096);
          flag_In_array=0;
          /* exit line and file if passed desired block */
          if (block_number > 0 && block_number == block_Current_index) {
            flag_End_row_loop = 1;
          }

          /* Continue with next line */
          continue;
        }

        /* get the number of columns splitting line with strtok */
        char  *lexeme;
        char  flag_End_Line = 0;
        long  block_Num_Columns = 0;
        const char seps[] = " ,;\t\n\r";

        lexeme = strtok(line, seps);
        while (!flag_End_Line) {
          if ((lexeme != NULL) && (lexeme[0] != '\0')) {
            /* reading line: the token is not empty */
            double X;
            int    count=1;
            /* test if we have 'NaN','Inf' */
            if (!strncasecmp(lexeme,"NaN",3))
              X = 0;
            else if (!strncasecmp(lexeme,"Inf",3) || !strncasecmp(lexeme,"+Inf",4))
              X = FLT_MAX;
            else if (!strncasecmp(lexeme,"-Inf",4))
              X = -FLT_MAX;
            else
              count = sscanf(lexeme,"%lg",&X);
            if (count == 1) {
              /* reading line: the token is a number in the line */
              if (!flag_In_array) {
                /* reading num: not already in a block: starts a new data block */
                block_Current_index++;
                flag_In_array    = 1;
                block_Num_Columns= 0;
                if (block_number > 0) {
                  /* initialise a new data block */
                  Rows = 0;
                  count_in_array = 0;
                } /* else append */
              }
              /* reading num: all blocks or selected block */
              if (flag_In_array && (block_number == 0 ||
                  block_number == block_Current_index)) {
                /* starting block: already the desired number of rows ? */
                if (block_Num_Columns == 0 &&
                    max_rows > 0 && Rows >= max_rows) {
                  flag_End_Line      = 1;
                  flag_End_row_loop  = 1;
                  flag_In_array      = 0;
                  /* reposition to begining of line (ignore line) */
                  fseek(hfile, back_pos, SEEK_SET);
                } else { /* store into data array */
                  if (count_in_array >= malloc_size) {
                    /* realloc data buffer if necessary */
                    malloc_size = count_in_array*1.5;
                    Data = (double*) realloc(Data, malloc_size*sizeof(double));
                    if (Data == NULL) {
                      fprintf(stderr, "Error: Can not re-allocate memory %li (Table_Read_Handle).\n",
                              malloc_size*sizeof(double));
                      return (-1);
                    }
                  }
                  if (0 == block_Num_Columns) Rows++;
                  Data[count_in_array] = X;
                  count_in_array++;
                  block_Num_Columns++;
                }
              } /* reading num: end if flag_In_array */
            } /* end reading num: end if sscanf lexeme -> numerical */
            else {
              /* reading line: the token is not numerical in that line. end block */
              if (block_Current_index == block_number) {
                flag_End_Line = 1;
                flag_End_row_loop = 1;
              } else {
                flag_In_array = 0;
                flag_End_Line = 1;
              }
            }
          }
          else {
            /* no more tokens in line */
            flag_End_Line = 1;
            if (block_Num_Columns > 0) Columns = block_Num_Columns;
          }

          // parse next token
          lexeme = strtok(NULL, seps);

        } /* while (!flag_End_Line) */
      } /* end: if fgets */
      else flag_End_row_loop = 1; /* else fgets : end of file */

    } while (!flag_End_row_loop); /* end while flag_End_row_loop */

    Table->block_number = block_number;
    Table->array_length = 1;

    // shrink header to actual size (plus terminating 0-byte)
    if (count_in_header) {
      Header = (char*)realloc(Header, count_in_header*sizeof(char) + 1);
    }
    Table->header = Header;

    if (count_in_array*Rows*Columns == 0)
    {
      Table->rows         = 0;
      Table->columns      = 0;
      free(Data);
      return (0);
    }
    if (Rows * Columns != count_in_array)
    {
      fprintf(stderr, "Warning: Read_Table :%s %s Data has %li values that should be %li x %li\n",
        (Table->filename[0] != '\0' ? Table->filename : ""),
        (!block_number ? " catenated" : ""),
        count_in_array, Rows, Columns);
      Columns = count_in_array; Rows = 1;
    }
    Data     = (double*)realloc(Data, count_in_array*sizeof(double));
    Table->data         = Data;
    Table->rows         = Rows;
    Table->columns      = Columns;

    return (count_in_array);

  } /* end Table_Read_Handle */

/*******************************************************************************
* long Table_Rebin(t_Table *Table)
*   ACTION: rebin a single Table, sorting 1st column in ascending order
*   input   Table: single table containing data.
*                  The data block is reallocated in this process
*   return  updated Table with increasing, evenly spaced first column (index 0)
*           number of data elements (-1: error, 0:empty data)
*******************************************************************************/
  long Table_Rebin(t_Table *Table)
  {
    double new_step=0;
    long   i;
    /* performs linear interpolation on X axis (0-th column) */

    if (!Table) return(-1);
    if (!Table->data 
    || Table->rows*Table->columns == 0 || !Table->step_x)
      return(0);
    Table_Stat(Table); /* recompute statitstics and minimal step */
    new_step = Table->step_x; /* minimal step in 1st column */

    if (!(Table->constantstep)) /* not already evenly spaced */
    {
      long Length_Table;
      double *New_Table;

      Length_Table = ceil(fabs(Table->max_x - Table->min_x)/new_step)+1;
      /*return early if the rebinned table will become too large*/
      if (Length_Table > mcread_table_rebin_maxsize){
        fprintf(stderr,"WARNING: (Table_Rebin): Rebinning table from %s would exceed 1M rows. Skipping.\n", Table->filename); 
        return(Table->rows*Table->columns);
      }
      New_Table    = (double*)malloc(Length_Table*Table->columns*sizeof(double));

      for (i=0; i < Length_Table; i++)
      {
        long   j;
        double X;
        X = Table->min_x + i*new_step;
        New_Table[i*Table->columns] = X;
        for (j=1; j < Table->columns; j++)
          New_Table[i*Table->columns+j]
                = Table_Value(*Table, X, j);
      } /* end for i */

      Table->rows = Length_Table;
      Table->step_x = new_step;
      Table->max_x = Table->min_x + (Length_Table-1)*new_step; 
      /*max might not be the same anymore
       * Use Length_Table -1 since the first and laset rows are the limits of the defined interval.*/
      free(Table->data);
      Table->data = New_Table;
      Table->constantstep=1;
    } /* end else (!constantstep) */
    return (Table->rows*Table->columns);
  } /* end Table_Rebin */

/*******************************************************************************
* double Table_Index(t_Table Table, long i, long j)
*   ACTION: read an element [i,j] of a single Table
*   input   Table: table containing data
*           i : index of row      (0:Rows-1)
*           j : index of column   (0:Columns-1)
*   return  Value = data[i][j]
* Returns Value from the i-th row, j-th column of Table
* Tests are performed on indexes i,j to avoid errors
*******************************************************************************/

#ifndef MIN
#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
#endif

double Table_Index(t_Table Table, long i, long j)
{
  long AbsIndex;

  if (Table.rows == 1 || Table.columns == 1) {
    /* vector */
    j = MIN(MAX(0, i+j), Table.columns*Table.rows - 1);
    i = 0;
  } else {
    /* matrix */
    i = MIN(MAX(0, i), Table.rows - 1);
    j = MIN(MAX(0, j), Table.columns - 1);
  }

  /* handle vectors specifically */
  AbsIndex = i*(Table.columns)+j;

  if (Table.data != NULL)
    return (Table.data[AbsIndex]);
  else
    return 0;
} /* end Table_Index */

/*******************************************************************************
* void Table_SetElement(t_Table *Table, long i, long j, double value)
*   ACTION: set an element [i,j] of a single Table
*   input   Table: table containing data
*           i : index of row      (0:Rows-1)
*           j : index of column   (0:Columns-1)
*           value = data[i][j]
* Returns 0 in case of error
* Tests are performed on indexes i,j to avoid errors
*******************************************************************************/
int Table_SetElement(t_Table *Table, long i, long j,
                     double value)
{
  long AbsIndex;

  if (Table->rows == 1 || Table->columns == 1) {
    /* vector */
    j = MIN(MAX(0, i+j), Table->columns*Table->rows - 1); i=0;
  } else {
    /* matrix */
    i = MIN(MAX(0, i), Table->rows - 1);
    j = MIN(MAX(0, j), Table->columns - 1);
  }

  AbsIndex = i*(Table->columns)+j;
  if (Table->data != NULL) {
    Table->data[AbsIndex] = value;
    return 1;
  }

  return 0;
} /* end Table_SetElement */

/*******************************************************************************
* double Table_Value(t_Table Table, double X, long j)
*   ACTION: read column [j] of a single Table at row which 1st column is X
*   input   Table: table containing data.
*           X : data value in the first column (index 0)
*           j : index of column from which is extracted the Value (0:Columns-1)
*   return  Value = data[index for X][j] with linear interpolation
* Returns Value from the j-th column of Table corresponding to the
* X value for the 1st column (index 0)
* Tests are performed (within Table_Index) on indexes i,j to avoid errors
* NOTE: data should rather be monotonic, and evenly sampled.
*******************************************************************************/
double Table_Value(t_Table Table, double X, long j)
{
  long   Index = -1;
  double X1=0, Y1=0, X2=0, Y2=0;
  double ret=0;

  if (X > Table.max_x) return Table_Index(Table,Table.rows-1  ,j);
  if (X < Table.min_x) return Table_Index(Table,0  ,j);

  // Use constant-time lookup when possible
  if(Table.constantstep) {
    Index = (long)floor(
              (X - Table.min_x) / (Table.max_x - Table.min_x) * (Table.rows-1));
    X1 = Table_Index(Table,Index  ,0);
    X2 = Table_Index(Table,Index+1,0);
  }
  // Use binary search on large, monotonic tables
  else if(Table.monotonic && Table.rows > 100) {
    long left = Table.min_x;
    long right = Table.max_x;

    while (!((X1 <= X) && (X < X2)) && (right - left > 1)) {
      Index = (left + right) / 2;

      X1 = Table_Index(Table, Index-1, 0);
      X2 = Table_Index(Table, Index,   0);

      if (X < X1) {
        right = Index;
      } else {
        left  = Index;
      }
    }
  }

  // Fall back to linear search, if no-one else has set X1, X2 correctly
  if (!((X1 <= X) && (X < X2))) {
    /* look for index surrounding X in the table -> Index */
    for (Index=1; Index <= Table.rows-1; Index++) {
        X1 = Table_Index(Table, Index-1,0);
        X2 = Table_Index(Table, Index  ,0);
        if ((X1 <= X) && (X < X2)) break;
      } /* end for Index */
  }

  Y1 = Table_Index(Table,Index-1,j);
  Y2 = Table_Index(Table,Index  ,j);

  if (!strcmp(Table.method,"linear")) {
    ret = Table_Interp1d(X, X1,Y1, X2,Y2);
  }
  else if (!strcmp(Table.method,"nearest")) {
    ret = Table_Interp1d_nearest(X, X1,Y1, X2,Y2);
  }

  return ret;
} /* end Table_Value */

/*******************************************************************************
* double Table_Value2d(t_Table Table, double X, double Y)
*   ACTION: read element [X,Y] of a matrix Table
*   input   Table: table containing data.
*           X : row index, may be non integer
*           Y : column index, may be non integer
*   return  Value = data[index X][index Y] with bi-linear interpolation
* Returns Value for the indices [X,Y]
* Tests are performed (within Table_Index) on indexes i,j to avoid errors
* NOTE: data should rather be monotonic, and evenly sampled.
*******************************************************************************/
  double Table_Value2d(t_Table Table, double X, double Y)
  {
    long   x1,x2,y1,y2;
    double z11,z12,z21,z22;
    double ret=0;

    x1 = (long)floor(X);
    y1 = (long)floor(Y);

    if (x1 > Table.rows-1 || x1 < 0) {
      x2 = x1;
    } else {
      x2 = x1 + 1;
    }

    if (y1 > Table.columns-1 || y1 < 0) {
      y2 = y1;
    } else {
      y2 = y1 + 1;
    }

    z11 = Table_Index(Table, x1, y1);

    if (y2 != y1) z12=Table_Index(Table, x1, y2); else z12 = z11;
    if (x2 != x1) z21=Table_Index(Table, x2, y1); else z21 = z11;
    if (y2 != y1) z22=Table_Index(Table, x2, y2); else z22 = z21;

    if (!strcmp(Table.method,"linear"))
      ret = Table_Interp2d(X,Y, x1,y1,x2,y2, z11,z12,z21,z22);
    else {
      if (fabs(X-x1) < fabs(X-x2)) {
        if (fabs(Y-y1) < fabs(Y-y2)) ret = z11; else ret = z12;
      } else {
        if (fabs(Y-y1) < fabs(Y-y2)) ret = z21; else ret = z22;
      }
    }
    return ret;
  } /* end Table_Value2d */


/*******************************************************************************
* void Table_Free(t_Table *Table)
*   ACTION: free a single Table. First Call Table_File_list_gc. If this returns
*   non-zero it means there are more refernces to the table, and so the table
*   should not bee freed.
*   return: empty Table
*******************************************************************************/
  void Table_Free(t_Table *Table)
  {
    if( !Table_File_List_gc(Table) ){
       return;
    } 
    if (!Table) return;
    if (Table->data   != NULL) free(Table->data);
    if (Table->header != NULL) free(Table->header);
    Table->data   = NULL;
    Table->header = NULL;
  } /* end Table_Free */

/******************************************************************************
* void Table_Info(t_Table Table)
*    ACTION: print informations about a single Table
*******************************************************************************/
  long Table_Info(t_Table Table)
  {
    char buffer[256];
    long ret=0;

    if (!Table.block_number) strcpy(buffer, "catenated");
    else sprintf(buffer, "block %li", Table.block_number);
    printf("Table from file '%s' (%s)",
      Table.filename[0] != '\0' ? Table.filename : "", buffer);
    if ((Table.data != NULL) && (Table.rows*Table.columns))
    {
      printf(" is %li x %li ", Table.rows, Table.columns);
      if (Table.rows*Table.columns > 1)
        printf("(x=%g:%g)", Table.min_x, Table.max_x);
      else printf("(x=%g) ", Table.min_x);
      ret = Table.rows*Table.columns;
      if (Table.monotonic)    printf(", monotonic");
      if (Table.constantstep) printf(", constant step");
      printf(". interpolation: %s\n", Table.method);
    }
    else printf(" is empty.\n");

    if (Table.header && strlen(Table.header)) {
      char *header;
      int  i;
      header = malloc(80);
      if (!header) return(ret);
      for (i=0; i<80; header[i++]=0);
      strncpy(header, Table.header, 75);
      if (strlen(Table.header) > 75) {
        strcat( header, " ...");
      }
      for (i=0; i<strlen(header); i++)
        if (header[i] == '\n' || header[i] == '\r') header[i] = ';';
      printf("  '%s'\n", header);
      free(header);
    }

    return(ret);
  } /* end Table_Info */

/******************************************************************************
* long Table_Init(t_Table *Table, m, n)
*   ACTION: initialise a Table to empty m by n table
*   return: empty Table
******************************************************************************/
long Table_Init(t_Table *Table, long rows, long columns)
{
  double *data=NULL;
  long   i;

  if (!Table) return(0);

  Table->header  = NULL;
  Table->filename[0]= '\0';
  Table->filesize= 0;
  Table->min_x   = 0;
  Table->max_x   = 0;
  Table->step_x  = 0;
  Table->block_number = 0;
  Table->array_length = 0;
  Table->monotonic    = 0;
  Table->constantstep = 0;
  Table->begin   = 0;
  Table->end     = 0;
  strcpy(Table->method,"linear");

  if (rows*columns >= 1) {
    data    = (double*)malloc(rows*columns*sizeof(double));
    if (data) for (i=0; i < rows*columns; data[i++]=0);
    else {
      fprintf(stderr,"Error: allocating %ld double elements."
                     "Too big (Table_Init).\n", rows*columns);
      rows = columns = 0;
    }
  }
  Table->rows    = (rows >= 1 ? rows : 0);
  Table->columns = (columns >= 1 ? columns : 0);
  Table->data    = data;
  return(Table->rows*Table->columns);
} /* end Table_Init */

/******************************************************************************
* long Table_Write(t_Table Table, char *file, x1,x2, y1,y2)
*   ACTION: write a Table to disk (ascii).
*     when x1=x2=0 or y1=y2=0, the table default limits are used.
*   return: 0=all is fine, non-0: error
*******************************************************************************/
MCDETECTOR Table_Write(t_Table Table, char *file, char *xl, char *yl, 
  double x1, double x2, double y1, double y2)
{
  long    i =0;
  MCDETECTOR detector;

  if ((Table.data == NULL) && (Table.rows*Table.columns)) {
    detector.m = 0;
    return(detector); /* Table is empty - nothing to do */
  }
  if (!x1 && !x2) {
    x1 = Table.min_x;
    x2 = Table.max_x;
  }
  if (!y1 && !y2) {
    y1 = 1;
    y2 = Table.columns;
  }

  /* transfer content of the Table into a 2D detector */
  Coords coords = { 0, 0, 0};

  if (Table.rows == 1 || Table.columns == 1) {
    detector = mcdetector_out_1D(Table.filename,
                      xl ? xl : "", yl ? yl : "",
                      "x", x1, x2,
                      Table.rows * Table.columns,
                      NULL, Table.data, NULL,
                      file, file, coords);
  } else {
    detector = mcdetector_out_2D(Table.filename,
                      xl ? xl : "", yl ? yl : "",
                      x1, x2, y1, y2,
                      Table.rows, Table.columns,
                      NULL, Table.data, NULL,
                      file, file, coords);
  }
  return(detector);
}

/******************************************************************************
* void Table_Stat(t_Table *Table)
*   ACTION: computes min/max/mean step of 1st column for a single table (private)
*   return: updated Table
*******************************************************************************/
  static void Table_Stat(t_Table *Table)
  {
    long   i;
    double max_x, min_x;
    double row=1;
    char   monotonic=1;
    char   constantstep=1;
    double step=0;
    long n;

    if (!Table) return;
    if (!Table->rows || !Table->columns) return;
    if (Table->rows == 1) row=0; // single row
    max_x = -FLT_MAX;
    min_x =  FLT_MAX;
    n     = (row ? Table->rows : Table->columns);
    /* get min and max of first column/vector */
    for (i=0; i < n; i++)
    {
      double X;
      X = (row ? Table_Index(*Table,i  ,0)
                               : Table_Index(*Table,0, i));
      if (X < min_x) min_x = X;
      if (X > max_x) max_x = X;
    } /* for */
    
    /* test for monotonicity and constant step if the table is an XY or single vector */
    if (n > 1) {
      /* mean step */
      step = (max_x - min_x)/(n-1);
      /* now test if table is monotonic on first column, and get minimal step size */
      for (i=0; i < n-1; i++) {
        double X, diff;;
        X    = (row ? Table_Index(*Table,i  ,0)
                    : Table_Index(*Table,0,  i));
        diff = (row ? Table_Index(*Table,i+1,0)
                    : Table_Index(*Table,0,  i+1)) - X;
        if (diff && fabs(diff) < fabs(step)) step = diff;
        /* change sign ? */
        if ((max_x - min_x)*diff < 0 && monotonic)
          monotonic = 0;
      } /* end for */
      
      /* now test if steps are constant within READ_TABLE_STEPTOL */
      if(!step){
        /*means there's a disconitnuity -> not constantstep*/
        constantstep=0;
      }else if (monotonic) {
        for (i=0; i < n-1; i++) {
          double X, diff;
          X    = (row ? Table_Index(*Table,i  ,0)
              : Table_Index(*Table,0,  i));
          diff = (row ? Table_Index(*Table,i+1,0)
              : Table_Index(*Table,0,  i+1)) - X;
          if ( fabs(step)*(1+READ_TABLE_STEPTOL) < fabs(diff) ||
                fabs(diff) < fabs(step)*(1-READ_TABLE_STEPTOL) )
          { constantstep = 0; break; }
        }
      }

    }
    Table->step_x= step;
    Table->max_x = max_x;
    Table->min_x = min_x;
    Table->monotonic = monotonic;
    Table->constantstep = constantstep;
  } /* end Table_Stat */

/******************************************************************************
* t_Table *Table_Read_Array(char *File, long *blocks)
*   ACTION: read as many data blocks as available, iteratively from file
*   return: initialized t_Table array, last element is an empty Table.
*           the number of extracted blocks in non NULL pointer *blocks
*******************************************************************************/
  t_Table *Table_Read_Array(char *File, long *blocks)
  {
    t_Table *Table_Array=NULL;
    long offset=0;
    long block_number=0;
    long allocated=256;
    long nelements=1;

    /* first allocate an initial empty t_Table array */
    Table_Array = (t_Table *)malloc(allocated*sizeof(t_Table));
    if (!Table_Array) {
      fprintf(stderr, "Error: Can not allocate memory %li (Table_Read_Array).\n",
         allocated*sizeof(t_Table));
      *blocks = 0;
      return (NULL);
    }

    while (nelements > 0)
    {
      t_Table Table;

      /* if ok, set t_Table block number else exit loop */
      block_number++;
      Table.block_number = block_number;
      
      /* access file at offset and get following block. Block number is from the set offset
       * hence the hardcoded 1 - i.e. the next block counted from offset.*/
      nelements = Table_Read_Offset(&Table, File, 1, &offset,0);
      /*if the block is empty - don't store it*/
      if (nelements>0){
          /* if t_Table array is not long enough, expand and realocate */
          if (block_number >= allocated-1) {
              allocated += 256;
              Table_Array = (t_Table *)realloc(Table_Array,
                      allocated*sizeof(t_Table));
              if (!Table_Array) {
                  fprintf(stderr, "Error: Can not re-allocate memory %li (Table_Read_Array).\n",
                          allocated*sizeof(t_Table));
                  *blocks = 0;
                  return (NULL);
              }
          }
          /* store it into t_Table array */
          //snprintf(Table.filename, 1024, "%s#%li", File, block_number-1);
          Table_Array[block_number-1] = Table;
      }
      /* continues until we find an empty block */
    }
    /* send back number of extracted blocks */
    if (blocks) *blocks = block_number-1;

    /* now store total number of elements in Table array */
    for (offset=0; offset < block_number;
      Table_Array[offset++].array_length = block_number-1);

    return(Table_Array);
  } /* end Table_Read_Array */
/*******************************************************************************
* void Table_Free_Array(t_Table *Table)
*   ACTION: free a Table array
*******************************************************************************/
  void Table_Free_Array(t_Table *Table)
  {
    long index;
    if (!Table) return;
    for (index=0;index < Table[0].array_length; index++){
            Table_Free(&Table[index]);
    }
    free(Table);
  } /* end Table_Free_Array */

/******************************************************************************
* long Table_Info_Array(t_Table *Table)
*    ACTION: print informations about a Table array
*    return: number of elements in the Table array
*******************************************************************************/
  long Table_Info_Array(t_Table *Table)
  {
    long index=0;

    if (!Table) return(-1);
    while (index < Table[index].array_length
       && (Table[index].data || Table[index].header)
       && (Table[index].rows*Table[index].columns) ) {
      Table_Info(Table[index]);
      index++;
    }
    printf("This Table array contains %li elements\n", index);
    return(index);
  } /* end Table_Info_Array */

/******************************************************************************
* char **Table_ParseHeader(char *header, symbol1, symbol2, ..., NULL)
*    ACTION: search for char* symbols in header and return their value or NULL
*            the search is not case sensitive.
*            Last argument MUST be NULL
*    return: array of char* with line following each symbol, or NULL if not found
*******************************************************************************/
#ifndef MyNL_ARGMAX
#define MyNL_ARGMAX 50
#endif

char **Table_ParseHeader_backend(char *header, ...){
  va_list ap;
  char exit_flag=0;
  int counter   =0;
  char **ret    =NULL;
  if (!header || header[0]=='\0') return(NULL);

  ret = (char**)calloc(MyNL_ARGMAX, sizeof(char*));
  if (!ret) {
    printf("Table_ParseHeader: Cannot allocate %i values array for Parser (Table_ParseHeader).\n",
      MyNL_ARGMAX);
    return(NULL);
  }
  for (counter=0; counter < MyNL_ARGMAX; ret[counter++] = NULL);
  counter=0;

  va_start(ap, header);
  while(!exit_flag && counter < MyNL_ARGMAX-1)
  {
    char *arg_char=NULL;
    char *pos     =NULL;
    /* get variable argument value as a char */
    arg_char = va_arg(ap, char *);
    if (!arg_char || arg_char[0]=='\0'){
      exit_flag = 1; break;
    }
    /* search for the symbol in the header */
    pos = (char*)strcasestr(header, arg_char);
    if (pos) {
      char *eol_pos;
      eol_pos = strchr(pos+strlen(arg_char), '\n');
      if (!eol_pos)
        eol_pos = strchr(pos+strlen(arg_char), '\r');
      if (!eol_pos)
        eol_pos = pos+strlen(pos)-1;
      ret[counter] = (char*)malloc(eol_pos - pos);
      if (!ret[counter]) {
        printf("Table_ParseHeader: Cannot allocate value[%i] array for Parser searching for %s (Table_ParseHeader).\n",
          counter, arg_char);
        exit_flag = 1; break;
      }
      strncpy(ret[counter], pos+strlen(arg_char), eol_pos - pos - strlen(arg_char));
      ret[counter][eol_pos - pos - strlen(arg_char)]='\0';
    }
    counter++;
  }
  va_end(ap);
  return(ret);
} /* Table_ParseHeader */

/******************************************************************************
* double Table_Interp1d(x, x1, y1, x2, y2)
*    ACTION: interpolates linearly at x between y1=f(x1) and y2=f(x2)
*    return: y=f(x) value
*******************************************************************************/
double Table_Interp1d(double x,
  double x1, double y1,
  double x2, double y2)
{
  double slope;
  if (x2 == x1) return (y1+y2)/2;
  if (y1 == y2) return  y1;
  slope = (y2 - y1)/(x2 - x1);
  return y1+slope*(x - x1);
} /* Table_Interp1d */

/******************************************************************************
* double Table_Interp1d_nearest(x, x1, y1, x2, y2)
*    ACTION: table lookup with nearest method at x between y1=f(x1) and y2=f(x2)
*    return: y=f(x) value
*******************************************************************************/
double Table_Interp1d_nearest(double x,
  double x1, double y1,
  double x2, double y2)
{
  if (fabs(x-x1) < fabs(x-x2)) return (y1);
  else return(y2);
} /* Table_Interp1d_nearest */

/******************************************************************************
* double Table_Interp2d(x,y, x1,y1, x2,y2, z11,z12,z21,z22)
*    ACTION: interpolates bi-linearly at (x,y) between z1=f(x1,y1) and z2=f(x2,y2)
*    return: z=f(x,y) value
*    x,y |   x1   x2
*    ----------------
*     y1 |   z11  z21
*     y2 |   z12  z22
*******************************************************************************/
double Table_Interp2d(double x, double y,
  double x1, double y1,
  double x2, double y2,
  double z11, double z12, double z21, double z22)
{
  double ratio_x, ratio_y;
  if (x2 == x1) return Table_Interp1d(y, y1,z11, y2,z12);
  if (y1 == y2) return Table_Interp1d(x, x1,z11, x2,z21);

  ratio_y = (y - y1)/(y2 - y1);
  ratio_x = (x - x1)/(x2 - x1);
  return (1-ratio_x)*(1-ratio_y)*z11 + ratio_x*(1-ratio_y)*z21
    + ratio_x*ratio_y*z22         + (1-ratio_x)*ratio_y*z12;
} /* Table_Interp2d */

/* end of read_table-lib.c */

/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2008, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/interoff.h
*
* %Identification
* Written by: Reynald Arnerin
* Date:    Jun 12, 2008
* Release: 
* Version: 
*
* Object File Format intersection header for McStas. Requires the qsort function.
*
* Such files may be obtained with e.g.
*   qhull < points.xyz Qx Qv Tv o > points.off
* where points.xyz has format:
*   3
*   <nb_points>
*   <x> <y> <z>
*   ...
* The resulting file should have its first line being changed from '3' into 'OFF'.
* It can then be displayed with geomview.
* A similar, but somewhat older solution is to use 'powercrust' with e.g.
*   powercrust -i points.xyz
* which will generate a 'pc.off' file to be renamed as suited.
*
*******************************************************************************/

#ifndef INTEROFF_LIB_H
#define INTEROFF_LIB_H "$Revision$"

#ifndef EPSILON
#define EPSILON 1e-13
#endif

#define OFF_INTERSECT_MAX 100

//#include <float.h>

#define N_VERTEX_DISPLAYED    200000

typedef struct intersection {
	MCNUM time;  	  //time of the intersection
	Coords v;	      //intersection point
	Coords normal;  //normal vector of the surface intersected
	short in_out;	  //1 if the ray enters the volume, -1 otherwise
	short edge;	    //1 if the intersection is on the boundary of the polygon, and error is possible
	unsigned long index; // index of the face
} intersection;

typedef struct polygon {
  MCNUM* p;       //vertices of the polygon in adjacent order, this way : x1 | y1 | z1 | x2 | y2 | z2 ...
  int npol;       //number of vertices
  Coords normal;
} polygon;

typedef struct off_struct {
    long vtxSize;
    long polySize;
    long faceSize;
    Coords* vtxArray;
    Coords* normalArray;
    unsigned long* faceArray;
    char *filename;
    int mantidflag;
    long mantidoffset;
    intersection intersects[OFF_INTERSECT_MAX]; // After a call to off_intersect_all contains the list of intersections.
    int nextintersect;                 // 'Next' intersection (first t>0) solution after call to off_intersect_all
    int numintersect;               // Number of intersections after call to off_intersect_all
} off_struct;

/*******************************************************************************
* long off_init(  char *offfile, double xwidth, double yheight, double zdepth, off_struct* data)
* ACTION: read an OFF file, optionally center object and rescale, initialize OFF data structure
* INPUT: 'offfile' OFF file to read
*        'xwidth,yheight,zdepth' if given as non-zero, apply bounding box. 
*           Specifying only one of these will also use the same ratio on all axes
*        'notcenter' center the object to the (0,0,0) position in local frame when set to zero
* RETURN: number of polyhedra and 'data' OFF structure 
*******************************************************************************/
long off_init(  char *offfile, double xwidth, double yheight, double zdepth, 
                int notcenter, off_struct* data);

/*******************************************************************************
* int off_intersect_all(double* t0, double* t3, 
     Coords *n0, Coords *n3,
     double x, double y, double z, 
     double vx, double vy, double vz, 
     off_struct *data )
* ACTION: computes intersection of neutron trajectory with an object. 
* INPUT:  x,y,z and vx,vy,vz are the position and velocity of the neutron
*         data points to the OFF data structure
* RETURN: the number of polyhedra which trajectory intersects
*         t0 and t3 are the smallest incoming and outgoing intersection times
*         n0 and n3 are the corresponding normal vectors to the surface
*         data is the full OFF structure, including a list intersection type
*******************************************************************************/
int off_intersect_all(double* t0, double* t3, 
     Coords *n0, Coords *n3,
     double x, double y, double z, 
     double vx, double vy, double vz, 
     off_struct *data );

/*******************************************************************************
* int off_intersect(double* t0, double* t3, 
     Coords *n0, Coords *n3,
     double x, double y, double z, 
     double vx, double vy, double vz, 
     off_struct data )
* ACTION: computes intersection of neutron trajectory with an object. 
* INPUT:  x,y,z and vx,vy,vz are the position and velocity of the neutron
*         data points to the OFF data structure
* RETURN: the number of polyhedra which trajectory intersects
*         t0 and t3 are the smallest incoming and outgoing intersection times
*         n0 and n3 are the corresponding normal vectors to the surface
*******************************************************************************/
int off_intersect(double* t0, double* t3, 
     Coords *n0, Coords *n3,
     double x, double y, double z, 
     double vx, double vy, double vz, 
     off_struct data );

/*****************************************************************************
* int off_intersectx(double* l0, double* l3, 
     Coords *n0, Coords *n3,
     double x, double y, double z, 
     double kx, double ky, double kz, 
     off_struct data )
* ACTION: computes intersection of an xray trajectory with an object.
* INPUT:  x,y,z and kx,ky,kz, are spatial coordinates and wavevector of the x-ray
*         respectively. data points to the OFF data structure.
* RETURN: the number of polyhedra the trajectory intersects
*         l0 and l3 are the smallest incoming and outgoing intersection lengths
*         n0 and n3 are the corresponding normal vectors to the surface
*******************************************************************************/
int off_x_intersect(double *l0,double *l3,
     Coords *n0, Coords *n3,
     double x,  double y,  double z, 
     double kx, double ky, double kz, 
     off_struct data );

/*******************************************************************************
* void off_display(off_struct data)
* ACTION: display up to N_VERTEX_DISPLAYED points from the object
*******************************************************************************/
void off_display(off_struct);

#endif

/* end of interoff-lib.h */
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2008, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/interoff-lib.c
*
* %Identification
* Written by: Reynald Arnerin
* Date:    Jun 12, 2008
* Origin: ILL
* Release: $Revision$
* Version: McStas X.Y
*
* Object File Format intersection library for McStas. Requires the qsort function.
*
* Such files may be obtained with e.g.
*   qhull < points.xyz Qx Qv Tv o > points.off
* where points.xyz has format (it supports comments):
*   3
*   <nb_points>
*   <x> <y> <z>
*   ...
* The resulting file should have its first line being changed from '3' into 'OFF'.
* It can then be displayed with geomview.
* A similar, but somewhat older solution is to use 'powercrust' with e.g.
*   powercrust -i points.xyz
* which will generate a 'pc.off' file to be renamed as suited.
*
*******************************************************************************/

#ifndef INTEROFF_LIB_H
#include "interoff-lib.h"
#endif

double off_F(double x, double y,double z,double A,double B,double C,double D) {
  return ( A*x + B*y + C*z + D );
}

char off_sign(double a) {
  if (a<0)       return(-1);
  else if (a==0) return(0);
  else           return(1);
}

// off_normal ******************************************************************
//gives the normal vector of p
void off_normal(Coords* n, polygon p)
{
  //using Newell method
  int i=0,j=0;
  n->x=0;n->y=0;n->z=0;
  for (i = 0, j = p.npol-1; i < p.npol; j = i++)
  {
    MCNUM x1=p.p[3*i],
          y1=p.p[3*i+1],
          z1=p.p[3*i+2];
    MCNUM x2=p.p[3*j],
          y2=p.p[3*j+1],
          z2=p.p[3*j+2];
    // n is the cross product of v1*v2
    n->x += (y1 - y2) * (z1 + z2);
    n->y += (z1 - z2) * (x1 + x2);
    n->z += (x1 - x2) * (y1 + y2);
  }
} /* off_normal */

// off_pnpoly ******************************************************************
//based on http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
//return 0 if the vertex is out
//    1 if it is in
//   -1 if on the boundary
int off_pnpoly(polygon p, Coords v)
{
  int i=0, c = 0;
  MCNUM minx=FLT_MAX,maxx=-FLT_MAX,miny=FLT_MAX,maxy=-FLT_MAX,minz=FLT_MAX,maxz=-FLT_MAX;
  MCNUM rangex=0,rangey=0,rangez=0;

  int pol2dx=0,pol2dy=1;          //2d restriction of the poly
  MCNUM x=v.x,y=v.y;


  //take the most relevant 2D projection (prevent from instability)
  for (i=0; i<p.npol; ++i)
  {
    if (p.p[3*i]<minx)   minx=p.p[3*i];
    if (p.p[3*i]>maxx)   maxx=p.p[3*i];
    if (p.p[3*i+1]<miny) miny=p.p[3*i+1];
    if (p.p[3*i+1]>maxy) maxy=p.p[3*i+1];
    if (p.p[3*i+2]<minz) minz=p.p[3*i+2];
    if (p.p[3*i+2]>maxz) maxz=p.p[3*i+2];
  }
  rangex=maxx-minx;
  rangey=maxy-miny;
  rangez=maxz-minz;

  if (rangex<rangez)
  {
    if (rangex<rangey) {
      pol2dx=2;
      x=v.z;
    } else {
      pol2dy=2;
      y=v.z;
    }
  }
  else if (rangey<rangez) {
    pol2dy=2;
    y=v.z;
  }

  //trace rays and test number of intersection
  int j;
  for (i = 0, j = p.npol-1; i < p.npol; j = i++) {
    if (((((p.p[3*i+pol2dy])<=y) && (y<(p.p[3*j+pol2dy]))) ||
         (((p.p[3*j+pol2dy])<=y) && (y<(p.p[3*i+pol2dy])))) &&
        (x < ( (p.p[3*j+pol2dx] - p.p[3*i+pol2dx]) * (y - p.p[3*i+pol2dy])
             / (p.p[3*j+pol2dy] - p.p[3*i+pol2dy]) + p.p[3*i+pol2dx]) ))
      c = !c;

    if (((fabs(p.p[3*i+pol2dy]-y)<=EPSILON) || ((fabs(p.p[3*j+pol2dy]-y)<=EPSILON))) &&
        fabs(x -((p.p[3*j+pol2dx] - p.p[3*i+pol2dx]) * (y - p.p[3*i+pol2dy])
          / (p.p[3*j+pol2dy] - p.p[3*i+pol2dy]) + p.p[3*i+pol2dx])) < EPSILON)
    {
      //the point lies on the edge
      c=-1;
      break;
    }
  }

  return c;
} /* off_pnpoly */

// off_intersectPoly ***********************************************************
//gives the intersection vertex between ray [a,b) and polygon p and its parametric value on (a b)
//based on http://geometryalgorithms.com/Archive/algorithm_0105/algorithm_0105.htm
int off_intersectPoly(intersection *inter, Coords a, Coords b, polygon p)
{
  //direction vector of [a,b]
  Coords dir = {b.x-a.x, b.y-a.y, b.z-a.z};

  //the normal vector to the polygon
  Coords normale=p.normal;
  //off_normal(&normale, p); done at the init stage

  //direction vector from a to a vertex of the polygon
  Coords w0 = {a.x-p.p[0], a.y-p.p[1], a.z-p.p[2]};

  //scalar product
  MCNUM nw0  =-scalar_prod(normale.x,normale.y,normale.z,w0.x,w0.y,w0.z);
  MCNUM ndir = scalar_prod(normale.x,normale.y,normale.z,dir.x,dir.y,dir.z);
  inter->time = inter->edge = inter->in_out=0;
  inter->v = inter->normal = coords_set(0,0,1);

  if (fabs(ndir) < EPSILON)    // ray is parallel to polygon plane
  {
    if (nw0 == 0)              // ray lies in polygon plane (infinite number of solution)
      return 0;
    else return 0;             // ray disjoint from plane (no solution)
  }

  // get intersect point of ray with polygon plane
  inter->time = nw0 / ndir;            //parametric value the point on line (a,b)

  inter->v = coords_set(a.x + inter->time * dir.x,// intersect point of ray and plane
    a.y + inter->time * dir.y,
    a.z + inter->time * dir.z);

  int res=off_pnpoly(p,inter->v);

  inter->edge=(res==-1);
  if (ndir<0)
    inter->in_out=1;  //the negative dot product means we enter the surface
  else
    inter->in_out=-1;

  inter->normal=p.normal;

  return res;         //true if the intersection point lies inside the poly
} /* off_intersectPoly */


// off_getBlocksIndex **********************************************************
/*reads the indexes at the beginning of the off file as this :
line 1  OFF
line 2  nbVertex nbFaces nbEdges
*/
FILE *off_getBlocksIndex(char* filename, long* vtxSize, long* polySize )
{
  FILE* f = Open_File(filename,"r", NULL); /* from read_table-lib: FILE *Open_File(char *name, char *Mode, char *path) */
  if (!f) return (f);
  
  char line[CHAR_BUF_LENGTH];
  char *ret=0;
  *vtxSize = *polySize = 0;

  /* **************** start to read the file header */
  /* OFF file:
     'OFF' or '3'
   */

  ret=fgets(line,CHAR_BUF_LENGTH , f);// line 1 = "OFF"
  if (ret == NULL)
  {
    fprintf(stderr, "Error: Can not read 1st line in file %s (interoff/off_getBlocksIndex)\n", filename);
    exit(1);
  }
  if (strlen(line)>5)
  {
      fprintf(stderr,"Error: First line in %s is too long (=%lu). Possibly the line is not terminated by '\\n'.\n" 
              "       The first line is required to be exactly 'OFF', '3' or 'ply'.\n",filename,strlen(line));
      fclose(f);
      return(NULL);
  }

  if (strncmp(line,"OFF",3) && strncmp(line,"3",1) && strncmp(line,"ply",1))
  {
    fprintf(stderr, "Error: %s is probably not an OFF, NOFF or PLY file (interoff/off_getBlocksIndex).\n"
                    "       Requires first line to be 'OFF', '3' or 'ply'.\n",filename);
    fclose(f);
    return(NULL);
  }

  if (!strncmp(line,"OFF",3) || !strncmp(line,"3",1)) {
    do  /* OFF file: skip # comments which may be there */
    {
      ret=fgets(line,CHAR_BUF_LENGTH , f);
      if (ret == NULL)
      {
        fprintf(stderr, "Error: Can not read line in file %s (interoff/off_getBlocksIndex)\n", filename);
        exit(1);
      }
    } while (line[0]=='#');
    //line = nblines of vertex,faces and edges arrays
    sscanf(line,"%lu %lu",vtxSize,polySize);
  } else {
    do  /* PLY file: read all lines until find 'end_header'
           and locate 'element faces' and 'element vertex' */
    {
      ret=fgets(line,CHAR_BUF_LENGTH , f);
      if (ret == NULL)
      {
        fprintf(stderr, "Error: Can not read line in file %s (interoff/off_getBlocksIndex)\n", filename);
        exit(1);
      }
      if (!strncmp(line,"element face",12))
        sscanf(line,"element face %lu",polySize);
      else if (!strncmp(line,"element vertex",14))
        sscanf(line,"element vertex %lu",vtxSize);
      else if (!strncmp(line,"format binary",13))
        exit(fprintf(stderr,
          "Error: Can not read binary PLY file %s, only 'format ascii' (interoff/off_getBlocksIndex)\n%s\n",
          filename, line));
    } while (strncmp(line,"end_header",10));
  }
  
  /* The FILE is left opened ready to read 'vtxSize' vertices (vtxSize *3 numbers)
     and then polySize polygons (rows) */

  return(f);
} /* off_getBlocksIndex */

// off_init_planes *************************************************************
//gives the equations of 2 perpandicular planes of [ab]
void off_init_planes(Coords a, Coords b,
  MCNUM* A1, MCNUM* C1, MCNUM* D1, MCNUM *A2, MCNUM* B2, MCNUM* C2, MCNUM* D2)
{
  //direction vector of [a b]
  Coords dir={b.x-a.x, b.y-a.y, b.z-a.z};

  //the plane parallel to the 'y' is computed with the normal vector of the projection of [ab] on plane 'xz'
  *A1= dir.z;
  *C1=-dir.x;
  if(*A1!=0 || *C1!=0)
    *D1=-(a.x)*(*A1)-(a.z)*(*C1);
  else
  {
    //the plane does not support the vector, take the one parallel to 'z''
    *A1=1;
    //B1=dir.x=0
    *D1=-(a.x);
  }
  //the plane parallel to the 'x' is computed with the normal vector of the projection of [ab] on plane 'yz'
  *B2= dir.z;
  *C2=-dir.y;
  *A2= 0;
  if (*B2==0 && *C2==0)
  {
    //the plane does not support the vector, take the one parallel to 'z'
    *B2=1;
    //B1=dir.x=0
    *D2=-(a.y);
  }
  else {
    if (dir.z==0)
    {
      //the planes are the same, take the one parallel to 'z'
      *A2= dir.y;
      *B2=-dir.x;
      *D2=-(a.x)*(*A2)-(a.y)*(*B2);
    }
    else
      *D2=-(a.y)**B2-(a.z)**C2;
  }
} /* off_init_planes */

// off_clip_3D_mod *************************************************************
int off_clip_3D_mod(intersection* t, Coords a, Coords b,
  Coords* vtxArray, unsigned long vtxSize, unsigned long* faceArray,
  unsigned long faceSize, Coords* normalArray)
{
  MCNUM A1=0, C1=0, D1=0, A2=0, B2=0, C2=0, D2=0;      //perpendicular plane equations to [a,b]
  off_init_planes(a, b, &A1, &C1, &D1, &A2, &B2, &C2, &D2);

  int t_size=0;
  //unsigned long vtxSize=vtxTable.rows, faceSize=faceTable.columns;  //Size of the corresponding tables
  char sg[vtxSize];  //array telling if vertex is left or right of the plane
  MCNUM popol[3*CHAR_BUF_LENGTH];
  unsigned long i=0,indPoly=0;
  for (i=0; i < vtxSize; ++i)
  {
    sg[i]=off_sign(off_F(vtxArray[i].x,vtxArray[i].y,vtxArray[i].z,A1,0,C1,D1));
  }

  //exploring the polygons :
  i=indPoly=0;
  while (i<faceSize)
  {
    polygon pol;
    pol.npol  = faceArray[i];                //nb vertex of polygon
    pol.p     = popol;
    pol.normal= coords_set(0,0,1);
    unsigned long indVertP1=faceArray[++i];  //polygon's first vertex index in vtxTable
    int j=1;
    while (j<pol.npol)
    {
      //polygon's j-th vertex index in vtxTable
      if (sg[indVertP1]!=sg[faceArray[i+j]]) //if the plane intersect the polygon
        break;

      ++j;
    }

    if (j<pol.npol)          //ok, let's test with the second plane
    {
      char sg1=off_sign(off_F(vtxArray[indVertP1].x,vtxArray[indVertP1].y,vtxArray[indVertP1].z,A2,B2,C2,D2));//tells if vertex is left or right of the plane

      j=1;
      while (j<pol.npol)
      {
        //unsigned long indVertPi=faceArray[i+j];  //polyg's j-th vertex index in vtxTable
        Coords vertPi=vtxArray[faceArray[i+j]];
        if (sg1!=off_sign(off_F(vertPi.x,vertPi.y,vertPi.z,A2,B2,C2,D2)))//if the plane intersect the polygon
          break;
        ++j;
      }
      if (j<pol.npol)
      {
        if (t_size>CHAR_BUF_LENGTH)
        {
          fprintf(stderr, "Warning: number of intersection exceeded (%d) (interoff-lib/off_clip_3D_mod)\n", CHAR_BUF_LENGTH);
            return (t_size);
        }
        //both planes intersect the polygon, let's find the intersection point
        //our polygon :
        int k;
        for (k=0; k<pol.npol; ++k)
        {
          Coords vertPk=vtxArray[faceArray[i+k]];
          pol.p[3*k]  =vertPk.x;
          pol.p[3*k+1]=vertPk.y;
          pol.p[3*k+2]=vertPk.z;
        }
        pol.normal=normalArray[indPoly];
        intersection x;
        if (off_intersectPoly(&x, a, b, pol))
        {
          x.index = indPoly;
          t[t_size++]=x;
        }
      } /* if (j<pol.npol) */
    } /* if (j<pol.npol) */
    i += pol.npol;
    indPoly++;
  } /* while i<faceSize */
  return t_size;
} /* off_clip_3D_mod */


// off_compare *****************************************************************
int off_compare (void const *a, void const *b)
{
   intersection const *pa = a;
   intersection const *pb = b;

   return off_sign(pa->time - pb->time);
} /* off_compare */

// off_cleanDouble *************************************************************
//given an array of intersections throw those which appear several times
//returns 1 if there is a possibility of error
int off_cleanDouble(intersection* t, int* t_size)
{
  int i=1;
  intersection prev=t[0];
  while (i<*t_size)
  {
    int j=i;
    //for each intersection with the same time
    while (j<*t_size && fabs(prev.time-t[j].time)<EPSILON)
    {
      //if the intersection is the exact same erase it
      if (prev.in_out==t[j].in_out)
      {
        int k;
        for (k=j+1; k<*t_size; ++k)
        {
          t[k-1]=t[k];
        }
        *t_size-=1;
      }
      else
        ++j;
    }
    prev=t[i];
    ++i;

  }
  return 1;
} /* off_cleanDouble */

// off_cleanInOut **************************************************************
//given an array of intesections throw those which enter and exit in the same time
//Meaning the ray passes very close to the volume
//returns 1 if there is a possibility of error
int off_cleanInOut(intersection* t, int* t_size)
{
  int i=1;
  intersection prev=t[0];
  while (i<*t_size)
  {
    //if two intersection have the same time but one enters and the other exits erase both
    //(such intersections must be adjacent in the array : run off_cleanDouble before)
    if (fabs(prev.time-t[i].time)<EPSILON && prev.in_out!=t[i].in_out)
    {
      int j=0;
      for (j=i+1; j<*t_size; ++j)
      {
        t[j-2]=t[j];
      }
      *t_size-=2;
      prev=t[i-1];
    }
    else
    {
      prev=t[i];
      ++i;
    }
  }
  return (*t_size);
} /* off_cleanInOut */

/* PUBLIC functions ******************************************************** */

/*******************************************************************************
* long off_init(  char *offfile, double xwidth, double yheight, double zdepth, off_struct* data)
* ACTION: read an OFF file, optionally center object and rescale, initialize OFF data structure
* INPUT: 'offfile' OFF file to read
*        'xwidth,yheight,zdepth' if given as non-zero, apply bounding box.
*           Specifying only one of these will also use the same ratio on all axes
*        'notcenter' center the object to the (0,0,0) position in local frame when set to zero
* RETURN: number of polyhedra and 'data' OFF structure
*******************************************************************************/
long off_init(  char *offfile, double xwidth, double yheight, double zdepth,
                int notcenter, off_struct* data)
{
  // data to be initialized
  long    vtxSize =0, polySize=0, i=0, ret=0, faceSize=0;
  Coords* vtxArray        =NULL;
  Coords* normalArray     =NULL;
  unsigned long* faceArray=NULL;
  FILE*   f               =NULL; /* the FILE with vertices and polygons */
  double minx=FLT_MAX,maxx=-FLT_MAX,miny=FLT_MAX,maxy=-FLT_MAX,minz=FLT_MAX,maxz=-FLT_MAX;

  // get the indexes
  if (!data) return(0);
  
  MPI_MASTER(
  printf("Loading geometry file (OFF/PLY): %s\n", offfile);
  );
  
  f=off_getBlocksIndex(offfile,&vtxSize,&polySize);
  if (!f) return(0);
  
  // read vertex table = [x y z | x y z | ...] =================================
  // now we read the vertices as 'vtxSize*3' numbers and store it in vtxArray 
  MPI_MASTER(
  printf("  Number of vertices: %ld\n", vtxSize);
  );
  vtxArray   = malloc(vtxSize*sizeof(Coords));
  if (!vtxArray) return(0);
  i=0;
  while (i<vtxSize && ~feof(f))
  {
    double x,y,z;
    ret=fscanf(f, "%lg%lg%lg", &x,&y,&z);
    if (!ret) { 
      // invalid line: we skip it (probably a comment)
      char line[CHAR_BUF_LENGTH];
      fgets(line, CHAR_BUF_LENGTH, f);
      continue; 
    }
    if (ret != 3) {
      fprintf(stderr, "Error: can not read [xyz] coordinates for vertex %ld in file %s (interoff/off_init). Read %ld values.\n", 
        i, offfile, ret);
      exit(2);
    }
    vtxArray[i].x=x;
    vtxArray[i].y=y;
    vtxArray[i].z=z;

    //bounding box
    if (vtxArray[i].x<minx) minx=vtxArray[i].x;
    if (vtxArray[i].x>maxx) maxx=vtxArray[i].x;
    if (vtxArray[i].y<miny) miny=vtxArray[i].y;
    if (vtxArray[i].y>maxy) maxy=vtxArray[i].y;
    if (vtxArray[i].z<minz) minz=vtxArray[i].z;
    if (vtxArray[i].z>maxz) maxz=vtxArray[i].z;
    i++; // inquire next vertex
  }

  // resizing and repositioning params
  double centerx=0, centery=0, centerz=0;
  if (!notcenter) {
    centerx=(minx+maxx)*0.5;
    centery=(miny+maxy)*0.5;
    centerz=(minz+maxz)*0.5;
  }

  double rangex=-minx+maxx,
         rangey=-miny+maxy,
         rangez=-minz+maxz;

  double ratiox=1,ratioy=1,ratioz=1;

  if (xwidth && rangex)
  {
    ratiox=xwidth/rangex;
    ratioy=ratiox;
    ratioz=ratiox;
  }

  if (yheight && rangey)
  {
    ratioy=yheight/rangey;
    if(!xwidth)  ratiox=ratioy;
    ratioz=ratioy;
  }

  if (zdepth && rangez)
  {
    ratioz=zdepth/rangez;
    if(!xwidth)  ratiox=ratioz;
    if(!yheight) ratioy=ratioz;
  }

  rangex *= ratiox;
  rangey *= ratioy;
  rangez *= ratioz;

  //center and resize the object
  for (i=0; i<vtxSize; ++i)
  {
    vtxArray[i].x=(vtxArray[i].x-centerx)*ratiox+(!notcenter ? 0 : centerx);
    vtxArray[i].y=(vtxArray[i].y-centery)*ratioy+(!notcenter ? 0 : centery);
    vtxArray[i].z=(vtxArray[i].z-centerz)*ratioz+(!notcenter ? 0 : centerz);
  }
  
  // read face table = [nbvertex v1 v2 vn | nbvertex v1 v2 vn ...] =============
  MPI_MASTER(
  printf("  Number of polygons: %ld\n", polySize);
  );
  normalArray= malloc(polySize*sizeof(Coords));
  faceArray  = malloc(polySize*10*sizeof(unsigned long)); // we assume polygons have less than 9 vertices
  if (!normalArray || !faceArray) return(0);
  
  // fill faces
  faceSize=0;
  i=0;
  while (i<polySize && ~feof(f)) {
    int  nbVertex=0, j=0;
    // read the length of this polygon
    ret=fscanf(f, "%d", &nbVertex);
    if (!ret) { 
      // invalid line: we skip it (probably a comment)
      char line[CHAR_BUF_LENGTH];
      fgets(line, CHAR_BUF_LENGTH, f);
      continue; 
    }
    if (ret != 1) {
      fprintf(stderr, "Error: can not read polygon %ld length in file %s (interoff/off_init)\n", 
        i, offfile);
      exit(3);
    }
    if (faceSize > polySize*10) {
      fprintf(stderr, "Error: %li exceeded allocated polygon array[%li] in file %s (interoff/off_init)\n", 
        faceSize, polySize*10, offfile);
    }
    faceArray[faceSize++] = nbVertex; // length of the polygon/face
    // then read the vertex ID's
    for (j=0; j<nbVertex; j++) {
      double vtx=0;
      fscanf(f, "%lg", &vtx);
      faceArray[faceSize++] = vtx;   // add vertices index after length of polygon
    }
    i++;
  }

  // precomputes normals
  long indNormal=0;//index in polyArray
  i=0;    //index in faceArray
  while (i<faceSize)
  {
    int    nbVertex=faceArray[i];//nb of vertices of this polygon
    double vertices[3*nbVertex];
    int j;

    for (j=0; j<nbVertex; ++j)
    {
      unsigned long indVertPj=faceArray[i+j+1];
      vertices[3*j]  =vtxArray[indVertPj].x;
      vertices[3*j+1]=vtxArray[indVertPj].y;
      vertices[3*j+2]=vtxArray[indVertPj].z;
    }

    polygon p;
    p.p   =vertices;
    p.npol=nbVertex;
    off_normal(&(p.normal),p);

    normalArray[indNormal]=p.normal;

    i += nbVertex+1;
    indNormal++;

  }
  
  MPI_MASTER(
  if (ratiox!=ratioy || ratiox!=ratioz || ratioy!=ratioz)
    printf("Warning: Aspect ratio of the geometry %s was modified.\n"
           "         If you want to keep the original proportions, specifiy only one of the dimensions.\n",
           offfile);
  if ( xwidth==0 && yheight==0 && zdepth==0 ) {
    printf("Warning: Neither xwidth, yheight or zdepth are defined.\n"
	   "           The file-defined (non-scaled) geometry the OFF geometry %s will be applied!\n", 
           offfile);
  }
  printf("  Bounding box dimensions for geometry %s:\n", offfile);
  printf("    Length=%f (%.3f%%)\n", rangex, ratiox*100);
  printf("    Width= %f (%.3f%%)\n", rangey, ratioy*100);
  printf("    Depth= %f (%.3f%%)\n", rangez, ratioz*100);
  );

  data->vtxArray   = vtxArray;
  data->normalArray= normalArray;
  data->faceArray  = faceArray;
  data->vtxSize    = vtxSize;
  data->polySize   = polySize;
  data->faceSize   = faceSize;
  data->filename   = offfile;
  return(polySize);
} /* off_init */

/*******************************************************************************
* int off_intersect_all(double* t0, double* t3,
     Coords *n0, Coords *n3,
     double x, double y, double z,
     double vx, double vy, double vz,
     off_struct *data )
* ACTION: computes intersection of neutron trajectory with an object.
* INPUT:  x,y,z and vx,vy,vz are the position and velocity of the neutron
*         data points to the OFF data structure
* RETURN: the number of polyhedra which trajectory intersects
*         t0 and t3 are the smallest incoming and outgoing intersection times
*         n0 and n3 are the corresponding normal vectors to the surface
*         data is the full OFF structure, including a list intersection type
*******************************************************************************/
int off_intersect_all(double* t0, double* t3,
     Coords *n0, Coords *n3,
     double x,  double y,  double z,
     double vx, double vy, double vz,
     off_struct *data )
{
    Coords A={x, y, z};
    Coords B={x+vx, y+vy, z+vz};
    int t_size=off_clip_3D_mod(data->intersects, A, B,
      data->vtxArray, data->vtxSize, data->faceArray, data->faceSize, data->normalArray );
    qsort(data->intersects, t_size, sizeof(intersection),  off_compare);
    off_cleanDouble(data->intersects, &t_size);
    off_cleanInOut(data->intersects,  &t_size);

    /*find intersections "closest" to 0 (favouring positive ones)*/
    if(t_size>0){
      int i=0;
      if(t_size>1) {
        for (i=1; i < t_size-1; i++){
          if (data->intersects[i-1].time > 0 && data->intersects[i].time > 0)
            break;
        }
	
	data->nextintersect=i-1;
	data->numintersect=t_size;

        if (t0) *t0 = data->intersects[i-1].time;
        if (n0) *n0 = data->intersects[i-1].normal;
        if (t3) *t3 = data->intersects[i].time;
        if (n3) *n3 = data->intersects[i].normal;
      } else {
        if (t0) *t0 = data->intersects[0].time; 	 
	      if (n0) *n0 = data->intersects[0].normal;
      }
      /* should also return t[0].index and t[i].index as polygon ID */
      return t_size;
    }
    return 0;
} /* off_intersect */

/*******************************************************************************
* int off_intersect(double* t0, double* t3,
     Coords *n0, Coords *n3,
     double x, double y, double z,
     double vx, double vy, double vz,
     off_struct data )
* ACTION: computes intersection of neutron trajectory with an object.
* INPUT:  x,y,z and vx,vy,vz are the position and velocity of the neutron
*         data points to the OFF data structure
* RETURN: the number of polyhedra which trajectory intersects
*         t0 and t3 are the smallest incoming and outgoing intersection times
*         n0 and n3 are the corresponding normal vectors to the surface
*******************************************************************************/
int off_intersect(double* t0, double* t3,
     Coords *n0, Coords *n3,
     double x,  double y,  double z,
     double vx, double vy, double vz,
     off_struct data )
{
  return off_intersect_all(t0, t3, n0, n3, x, y, z, vx, vy, vz, &data );
} /* off_intersect */

/*****************************************************************************
* int off_x_intersect(double* l0, double* l3,
     Coords *n0, Coords *n3,
     double x, double y, double z,
     double kx, double ky, double kz,
     off_struct data )
* ACTION: computes intersection of an xray trajectory with an object.
* INPUT:  x,y,z and kx,ky,kz, are spatial coordinates and wavevector of the x-ray
*         respectively. data points to the OFF data structure.
* RETURN: the number of polyhedra the trajectory intersects
*         l0 and l3 are the smallest incoming and outgoing intersection lengths
*         n0 and n3 are the corresponding normal vectors to the surface
*******************************************************************************/
int off_x_intersect(double *l0,double *l3,
     Coords *n0, Coords *n3,
     double x,  double y,  double z,
     double kx, double ky, double kz,
     off_struct data )
{
  /*This function simply reformats and calls off_intersect (as for neutrons)
   *by normalizing the wavevector - this will yield the intersection lengths
   *in m*/
  double jx,jy,jz,invk;
  int n;
  invk=1/sqrt(scalar_prod(kx,ky,kz,kx,ky,kz));
  jx=kx*invk;jy=ky*invk;jz=kz*invk;
  n=off_intersect(l0,l3,n0,n3,x,y,z,jx,jy,jz,data);
  return n;
}


/*******************************************************************************
* void off_display(off_struct data)
* ACTION: display up to N_VERTEX_DISPLAYED polygons from the object
*******************************************************************************/
void off_display(off_struct data)
{
  unsigned int i;
  double ratio=(double)(N_VERTEX_DISPLAYED)/(double)data.faceSize;
  unsigned int pixel=0;
  for (i=0; i<data.faceSize-1; i++) {
    int j;
    int nbVertex = data.faceArray[i];
    double x0,y0,z0;
    x0 = data.vtxArray[data.faceArray[i+1]].x;
    y0 = data.vtxArray[data.faceArray[i+1]].y;
    z0 = data.vtxArray[data.faceArray[i+1]].z;
    double x1=x0,y1=y0,z1=z0;
    double cmx=0,cmy=0,cmz=0;
    
    int drawthis = rand01() < ratio;
    // First pass, calculate center of mass location...
    for (j=1; j<=nbVertex; j++) {
      cmx = cmx+data.vtxArray[data.faceArray[i+j]].x;
      cmy = cmy+data.vtxArray[data.faceArray[i+j]].y;
      cmz = cmz+data.vtxArray[data.faceArray[i+j]].z;
    }
    cmx /= nbVertex;
    cmy /= nbVertex;
    cmz /= nbVertex;
    
    char pixelinfo[1024];    
    sprintf(pixelinfo, "%lu,%lu,%lu,%i,%g,%g,%g,%g,%g,%g", data.mantidoffset+pixel, data.mantidoffset, data.mantidoffset+data.polySize-1, nbVertex, cmx, cmy, cmz, x1-cmx, y1-cmy, z1-cmz);
    for (j=2; j<=nbVertex; j++) {
      double x2,y2,z2;
      x2 = data.vtxArray[data.faceArray[i+j]].x;
      y2 = data.vtxArray[data.faceArray[i+j]].y;
      z2 = data.vtxArray[data.faceArray[i+j]].z;
      sprintf(pixelinfo, "%s,%g,%g,%g", pixelinfo, x2-cmx, y2-cmy, z2-cmz); 
      if (ratio > 1 || drawthis) {
	mcdis_line(x1,y1,z1,x2,y2,z2);
      }
      x1 = x2; y1 = y2; z1 = z2;
    }
    if (ratio > 1 || drawthis) {
	mcdis_line(x1,y1,z1,x0,y0,z0);
      }
    if (data.mantidflag) {
      printf("MANTID_PIXEL: %s\n", pixelinfo);
      pixel++;
    }
    i += nbVertex;
  }
} /* off_display */

/* end of interoff-lib.c */

#line 9830 "./SNS_BASIS.c"

/* Shared user declarations for all components 'Guide'. */
#line 63 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide.comp"

/*****************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2006, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/ref-lib.h
*
* %Identification
* Written by: Peter Christiansen
* Date: August, 2006
* Origin: RISOE
* Release: McStas 1.10
* Version: $Revision$
*
* Commonly used reflection functions are declared in this file which
* are used by some guide and mirror components.
*
* Depends on read_table-lib
*
* Usage: within SHARE
* %include "ref-lib"
*
****************************************************************************/


#ifndef REF_LIB_H
#define REF_LIB_H "$Revision$"

void StdReflecFunc(double, double*, double*);
void TableReflecFunc(double, t_Table*, double*);

#endif

/* end of ref-lib.h */
/****************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2006, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/ref-lib.c
*
* %Identification
* Written by: Peter Christiansen
* Date: August, 2006
* Origin: RISOE
* Release: McStas 1.10
* Version: $Revision$
*
* Commonly used reflection functions are declared in this file which
* are used by some guide and mirror components.
*
* Variable names have prefix 'mc_ref_' for 'McStas Reflection' 
* to avoid conflicts
*
* Usage: within SHARE
* %include "ref-lib"
*
****************************************************************************/

#ifndef REF_LIB_H
#include "ref-lib.h"
#endif

#ifndef READ_TABLE_LIB_H
#include "read_table-lib.h"
#include "read_table-lib.c"
#endif

/****************************************************************************
* void StdReflecFunc(double q, double *par, double *r)
* 
* The McStas standard analytic parametrization of the reflectivity.
* The parameters are:
* R0:      [1]    Low-angle reflectivity
* Qc:      [AA-1] Critical scattering vector
* alpha:   [AA]   Slope of reflectivity
* m:       [1]    m-value of material. Zero means completely absorbing.
* W:       [AA-1] Width of supermirror cut-off
*****************************************************************************/
void StdReflecFunc(double mc_pol_q, double *mc_pol_par, double *mc_pol_r) {
    double R0    = mc_pol_par[0];
    double Qc    = mc_pol_par[1];
    double alpha = mc_pol_par[2];
    double m     = mc_pol_par[3];
    double W     = mc_pol_par[4];
    double beta  = 0;
    mc_pol_q     = fabs(mc_pol_q);
    double arg;
        
    /* Simpler parametrization from Henrik Jacobsen uses these values that depend on m only.
       double m_value=m*0.9853+0.1978;
       double W=-0.0002*m_value+0.0022;
       double alpha=0.2304*m_value+5.0944;
       double beta=-7.6251*m_value+68.1137; 
       If W and alpha are set to 0, use Henrik's approach for estimating these parameters
       and apply the formulation:
       arg = R0*0.5*(1-tanh(arg))*(1-alpha*(q-Qc)+beta*(q-Qc)*(q-Qc));
    */  
    if (W==0 && alpha==0) {
      m=m*0.9853+0.1978;
      W=-0.0002*m+0.0022;
      alpha=0.2304*m+5.0944;
      beta=-7.6251*m+68.1137;
      if (m<=3) {
	alpha=m;
	beta=0;
      }
    }
    
    arg = W > 0 ? (mc_pol_q - m*Qc)/W : 11;

    if (arg > 10 || m <= 0 || Qc <=0 || R0 <= 0) {
      *mc_pol_r = 0;
      return;
    }
    
    if (m < 1) { Qc *= m; m=1; }
    
    if(mc_pol_q <= Qc) {      
      *mc_pol_r = R0;
      return;
    }
    
    
    *mc_pol_r = R0*0.5*(1 - tanh(arg))*(1 - alpha*(mc_pol_q - Qc) + beta*(mc_pol_q - Qc)*(mc_pol_q - Qc));
    
    return;
  }

/****************************************************************************
* void TableReflecFunc(double q, t_Table *par, double *r) {
* 
* Looks up the reflectivity in a table using the routines in read_table-lib.
*****************************************************************************/
void TableReflecFunc(double mc_pol_q, t_Table *mc_pol_par, double *mc_pol_r) {
    
  *mc_pol_r = Table_Value(*mc_pol_par, mc_pol_q, 1);
  if(*mc_pol_r>1)
    *mc_pol_r = 1;
  return;
}

/* end of ref-lib.c */

#line 9983 "./SNS_BASIS.c"

/* Shared user declarations for all components 'Guide_gravity'. */
#line 124 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"

#ifndef Gravity_guide_Version
#define Gravity_guide_Version "$Revision$"

#ifndef PROP_GRAV_DT
#error McStas : You need PROP_GRAV_DT (McStas >= 1.4.3) to run this component
#endif

/*
* G:       (m/s^2) Gravitation acceleration along y axis [-9.81]
* Gx:      (m/s^2) Gravitation acceleration along x axis [0]
* Gy:      (m/s^2) Gravitation acceleration along y axis [-9.81]
* Gz:      (m/s^2) Gravitation acceleration along z axis [0]
* mh:      (1)    m-value of material for left/right vert. mirrors
* mv:      (1)    m-value of material for top/bottom horz. mirrors
* mx:      (1)    m-value of material for left/right vert. mirrors
* my:      (1)    m-value of material for top/bottom horz. mirrors
*/

  typedef struct Gravity_guide_Vars
  {
    double gx;
    double gy;
    double gz;
    double nx[6], ny[6], nz[6];
    double wx[6], wy[6], wz[6];
    double A[6], norm_n2[6], norm_n[6];
    long   N_reflection[7];
    double w1c, h1c;
    double w2c, h2c;
    double M[5];
    double Alpha[5];
    double nzC[5], norm_n2xy[5], Axy[5];
    double wav_lr, wav_tb, wav_z;
    double chamfer_z, chamfer_lr, chamfer_tb;
    char   compcurname[256];
    double fc_freq, fc_phase;
    double warnings;
  } Gravity_guide_Vars_type;

  void Gravity_guide_Init(Gravity_guide_Vars_type *aVars,
    MCNUM a_w1, MCNUM a_h1, MCNUM a_w2, MCNUM a_h2, MCNUM a_l, MCNUM a_R0,
    MCNUM a_Qc, MCNUM a_alpha, MCNUM a_m, MCNUM a_W, MCNUM a_nslit, MCNUM a_d,
    MCNUM a_Gx, MCNUM a_Gy, MCNUM a_Gz,
    MCNUM a_mleft, MCNUM a_mright, MCNUM a_mtop, MCNUM a_mbottom, MCNUM a_nhslit,
    MCNUM a_wavy_lr, MCNUM a_wavy_tb, MCNUM a_wavy_z, MCNUM a_wavy,
    MCNUM a_chamfers_z, MCNUM a_chamfers_lr, MCNUM a_chamfers_tb, MCNUM a_chamfers,
    MCNUM a_nu, MCNUM a_phase, MCNUM a_aleft, MCNUM a_aright, MCNUM a_atop, MCNUM a_abottom)
  {
    int i;

    for (i=0; i<7; aVars->N_reflection[i++] = 0);
    for (i=0; i<5; aVars->M[i++] = 0);
    for (i=0; i<5; aVars->Alpha[i++] = 0);

    aVars->gx = a_Gx; /* The gravitation vector in the current component axis system */
    aVars->gy = a_Gy;
    aVars->gz = a_Gz;
    aVars->warnings=0;

    if (a_nslit <= 0 || a_nhslit <= 0) { fprintf(stderr,"%s: Fatal: no channel in this guide (nhslit or nslit=0).\n", aVars->compcurname); exit(-1); }
    if (a_d < 0) { fprintf(stderr,"%s: Fatal: subdividing walls have negative thickness in this guide (d<0).\n", aVars->compcurname); exit(-1); }
    aVars->w1c = (a_w1 - (a_nslit-1) *a_d)/(double)a_nslit;
    aVars->w2c = (a_w2 - (a_nslit-1) *a_d)/(double)a_nslit;
    aVars->h1c = (a_h1 - (a_nhslit-1)*a_d)/(double)a_nhslit;
    aVars->h2c = (a_h2 - (a_nhslit-1)*a_d)/(double)a_nhslit;

    for (i=0; i <= 4;   aVars->M[i++]=a_m);
    for (i=0; i <= 4;   aVars->Alpha[i++]=a_alpha);
    if (a_mleft   >= 0) aVars->M[1] =a_mleft  ;
    if (a_mright  >= 0) aVars->M[2] =a_mright ;
    if (a_mtop    >= 0) aVars->M[3] =a_mtop   ;
    if (a_mbottom >= 0) aVars->M[4] =a_mbottom;
    if (a_aleft   >= 0) aVars->Alpha[1] =a_aleft  ;
    if (a_aright  >= 0) aVars->Alpha[2] =a_aright ;
    if (a_atop    >= 0) aVars->Alpha[3] =a_atop   ;
    if (a_abottom >= 0) aVars->Alpha[4] =a_abottom;

    /* n: normal vectors to surfaces */
    aVars->nx[1] =  a_l; aVars->ny[1] =  0;   aVars->nz[1] =  0.5*(aVars->w2c-aVars->w1c);  /* 1:+X left       */
    aVars->nx[2] = -a_l; aVars->ny[2] =  0;   aVars->nz[2] = -aVars->nz[1];             /* 2:-X right      */
    aVars->nx[3] =  0;   aVars->ny[3] =  a_l; aVars->nz[3] =  0.5*(aVars->h2c-aVars->h1c);  /* 3:+Y top        */
    aVars->nx[4] =  0;   aVars->ny[4] = -a_l; aVars->nz[4] = -aVars->nz[3];             /* 4:-Y bottom     */
    aVars->nx[5] =  0;   aVars->ny[5] =  0;   aVars->nz[5] =  a_l;                      /* 5:+Z exit       */
    aVars->nx[0] =  0;   aVars->ny[0] =  0;   aVars->nz[0] = -a_l;                      /* 0:Z0 input      */
    /* w: a point on these surfaces */
    aVars->wx[1] = +(aVars->w1c)/2; aVars->wy[1] =  0;              aVars->wz[1] = 0;   /* 1:+X left       */
    aVars->wx[2] = -(aVars->w1c)/2; aVars->wy[2] =  0;              aVars->wz[2] = 0;   /* 2:-X right      */
    aVars->wx[3] =  0;              aVars->wy[3] = +(aVars->h1c)/2; aVars->wz[3] = 0;   /* 3:+Y top        */
    aVars->wx[4] =  0;              aVars->wy[4] = -(aVars->h1c)/2; aVars->wz[4] = 0;   /* 4:-Y bottom     */
    aVars->wx[5] =  0;              aVars->wy[5] =  0;              aVars->wz[5] = a_l; /* 5:+Z exit       */
    aVars->wx[0] =  0;              aVars->wy[0] =  0;              aVars->wz[0] = 0;   /* 0:Z0 input      */

    for (i=0; i <= 5; i++)
    {
      aVars->A[i] = scalar_prod(aVars->nx[i], aVars->ny[i], aVars->nz[i], aVars->gx, aVars->gy, aVars->gz)/2;
      aVars->norm_n2[i] = aVars->nx[i]*aVars->nx[i] + aVars->ny[i]*aVars->ny[i] + aVars->nz[i]*aVars->nz[i];
      if (aVars->norm_n2[i] <= 0)
        { fprintf(stderr,"%s: Fatal: normal vector norm %i is null/negative ! check guide dimensions.\n", aVars->compcurname, i); exit(-1); } /* should never occur */
      else
        aVars->norm_n[i] = sqrt(aVars->norm_n2[i]);
    }
    /* partial computations for l/r/t/b sides, to save computing time */
    for (i=1; i <= 4; i++)
    { /* stores nz that changes in case non box element (focus/defocus) */
      aVars->nzC[i]      =  aVars->nz[i]; /* partial xy terms */
      aVars->norm_n2xy[i]=  aVars->nx[i]*aVars->nx[i] + aVars->ny[i]*aVars->ny[i];
      aVars->Axy[i]      = (aVars->nx[i]*aVars->gx    + aVars->ny[i]*aVars->gy)/2;
    }
    /* handle waviness init */
    if (a_wavy && (!a_wavy_tb && !a_wavy_lr && !a_wavy_z))
    { aVars->wav_tb=aVars->wav_lr=aVars->wav_z=a_wavy; }
    else
    { aVars->wav_tb=a_wavy_tb; aVars->wav_lr=a_wavy_lr; aVars->wav_z=a_wavy_z; }
    aVars->wav_tb *= DEG2RAD/(sqrt(8*log(2)));   /* Convert from deg FWHM to rad Gaussian sigma */
    aVars->wav_lr *= DEG2RAD/(sqrt(8*log(2)));
    aVars->wav_z  *= DEG2RAD/(sqrt(8*log(2)));
    /* handle chamfers init */
    if (a_chamfers && (!a_chamfers_z && !a_chamfers_lr && !a_chamfers_tb))
    { aVars->chamfer_z=aVars->chamfer_lr=aVars->chamfer_tb=a_chamfers; }
    else
    {
      aVars->chamfer_z=a_chamfers_z;
      aVars->chamfer_lr=a_chamfers_lr;
      aVars->chamfer_tb=a_chamfers_tb;
    }

    aVars->fc_freq  = a_nu;
    aVars->fc_phase = a_phase;
  }

  int Gravity_guide_Trace(double *dt,
        Gravity_guide_Vars_type *aVars,
        double cx, double cy, double cz,
        double cvx, double cvy, double cvz,
        double cxnum, double cxk, double cynum, double cyk,
        double *cnx, double *cny,double *cnz)
  {
    double B, C;
    int    ret=0;
    int    side=0;
    double n1;
    double dt0, dt_min=0;
    int    i;
    double loc_num, loc_nslit;
    int    i_slope=3;

    /* look if there is a previous intersection with guide sides */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 5=+Z side: n=(0, 0, -l) ; W = (0, 0, l) (at z=l, guide exit)*/
    B = aVars->nz[5]*cvz; C = aVars->nz[5]*(cz - aVars->wz[5]);
    ret = solve_2nd_order(&dt0, NULL, aVars->A[5], B, C);
    if (ret && dt0>1e-10) { dt_min = dt0; side=5; }

    loc_num = cynum; loc_nslit = cyk;
    for (i=4; i>0; i--)
    {
      if (i == 2) { i_slope=1; loc_num = cxnum; loc_nslit = cxk; }

      if (aVars->nzC[i_slope] != 0) {
        n1 = loc_nslit - 2*(loc_num);  /* slope of l/r/u/d sides depends on the channel ! */
        loc_num++; /* use partial computations to alter nz and A */
        aVars->nz[i]= aVars->nzC[i]*n1;
        aVars->A[i] = aVars->Axy[i] + aVars->nz[i]*aVars->gz/2;
      }
      if (i < 3)
      {      B = aVars->nx[i]*cvx + aVars->nz[i]*cvz; C = aVars->nx[i]*(cx-aVars->wx[i]) + aVars->nz[i]*cz; }
      else { B = aVars->ny[i]*cvy + aVars->nz[i]*cvz; C = aVars->ny[i]*(cy-aVars->wy[i]) + aVars->nz[i]*cz; }
      ret = solve_2nd_order(&dt0, NULL, aVars->A[i], B, C);
      if (ret && dt0>1e-10 && (dt0<dt_min || !dt_min))
      { dt_min = dt0; side=i;
        if (aVars->nzC[i] != 0)
        { aVars->norm_n2[i] = aVars->norm_n2xy[i] + aVars->nz[i]*aVars->nz[i];
          aVars->norm_n[i]  = sqrt(aVars->norm_n2[i]); }
      }
     }

    *dt = dt_min;
    /* handles waviness: rotate n vector */
    if (side > 0 && side < 5 && (aVars->wav_z || aVars->wav_lr || aVars->wav_tb))
    {
      double nt_x, nt_y, nt_z;  /* transverse vector */
      double nn_x, nn_y, nn_z;  /* normal vector (tmp) */
      double phi;
      /* normal vector n_z = [ 0,0,1], n_t = n x n_z; */
      vec_prod(nt_x,nt_y,nt_z, aVars->nx[side],aVars->ny[side],aVars->nz[side], 0,0,1);
      /* rotate n with angle wavy_z around n_t -> nn */
      if (aVars->wav_z) {
        phi = aVars->wav_z;
        rotate(nn_x,nn_y,nn_z, aVars->nx[side],aVars->ny[side],aVars->nz[side], aVars->wav_z*randnorm(), nt_x,nt_y,nt_z);
      } else { nn_x=aVars->nx[side]; nn_y=aVars->ny[side]; nn_z=aVars->nz[side]; }
      /* rotate n with angle wavy_{x|y} around n_z -> nt */
      phi = (side <=2) ? aVars->wav_lr : aVars->wav_tb;
      if (phi) {
        rotate(nt_x,nt_y,nt_z, nn_x,nn_y,nn_z, phi*randnorm(), 0,0,1);
      } else { nt_x=nn_x; nt_y=nn_y; nt_z=nn_z; }
      *cnx=nt_x; *cny=nt_y; *cnz=nt_z;
    } else
    { *cnx=aVars->nx[side]; *cny=aVars->ny[side]; *cnz=aVars->nz[side]; }
    return (side);
  }



#endif
#line 10192 "./SNS_BASIS.c"

/* Shared user declarations for all components 'Guide_m'. */
#line 85 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_m.comp"

#line 10197 "./SNS_BASIS.c"

/* Shared user declarations for all components 'Isotropic_Sqw'. */
#line 295 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../samples/Isotropic_Sqw.comp"

#ifndef ISOTROPIC_SQW
#define ISOTROPIC_SQW $Revision$

/* {j d F2 DW Dd inv2d q F} + { Sq if j == -1}*/
#ifndef Crystallographica
#define Crystallographica { 4,5,7,0,0,0,0, 0,0 }
#define Fullprof          { 4,0,8,0,0,5,0, 0,0 }
#define Undefined         { 0,0,0,0,0,0,0, 0,0 }
#define Lazy              {17,6,0,0,0,0,0,13,0 }
#endif
/* special case for [q,Sq] table */
#define qSq               {-1,0,0,0,0,0,1, 0,0 }




/* For the density of states S(w) */
struct Sqw_W_struct
{
  double omega;        /* omega value for the data block */
  double cumul_proba;  /* cumulated intensity (between 0 and 1) */
};

/* For the S(q|w) probabilities */
struct Sqw_Q_struct
{
   double Q;           /* omega value for the data block */
   double cumul_proba; /* normalized cumulated probability */
};

struct Sqw_Data_struct /* contains normalized Sqw data for probabilities, coh and inc */
{
  struct Sqw_W_struct  *SW;     /* P(w)  ~ density of states */
  struct Sqw_Q_struct **SQW;    /* P(Q|w)= probability of each Q with w */

  long  *SW_lookup;
  long **QW_lookup;
  t_Table Sqw; /* S(q,w) rebin from file in range -w_max:w_max and 0:q_max, with exp(-hw/kT) weight */
  t_Table iqSq;         /* sigma(Ei) = sigma/2/Ki^2 * \int q S(q,w) dq dw up to 2*Ki_max */
  long   q_bins;
  long   w_bins;        /* length of q and w vectors/axes from file */
  double q_max, q_step; /* min=0      */
  double w_max, w_step; /* min=-w_max */
  long   lookup_length;
  char   filename[80];
  double intensity;
  double Ei_max;        /* max neutron incoming energy for Sigma=iqSq table */
  long   iqSq_length;
  char   type;
  double q_min_file;
};

struct Sqw_sample_struct { /* global parameters gathered as a structure */
  char   compname[256];

  struct Sqw_Data_struct Data_inc;
  struct Sqw_Data_struct Data_coh;

  double s_abs, s_coh, s_inc; /* material constants */
  double my_s;
  double my_a_v;
  double mat_rho;
  double mat_weight;
  double mat_density;
  double Temperature; /* temperature from the data file */
  int    shape;       /* 0:cylinder, 1:box, 2:sphere 3:any shape*/

  double sqw_threshold;       /* options to tune S(q,w) */
  double sqw_classical;
  double sqw_norm;

  double barns;               /* for powders */
  double Dd, DWfactor;

  double T2E;                 /* constants */
  char   Q_correction[256];
  double sqSE2K;

  int    maxloop;             /* flags to monitor caught warnings */
  int    minevents;
  long   neutron_removed;
  long   neutron_enter;
  long   neutron_pmult;
  long   neutron_exit;
  char   verbose_output;
  int    column_order[9];     /* column signification */
  long   lookup_length;

  double dq, dw; /* q/w transfer */
  char   type;   /* interaction type: c(coherent),             i(incoherent),
                                      V(isotropic incoherent), t(transmitted) */
  /* store information from the last event */
  double ki_x,ki_y,ki_z,kf_x,kf_y,kf_z;
  double ti, tf;
  double vi, vf;
  double ki, kf;
  double theta;

  double mean_scatt;      /* stat to show at the end */
  double mean_abs;
  double psum_scatt;
  double single_coh;
  double single_inc;
  double multi;

  double rw, rq;
};

#include <stdio.h>
#include <math.h>

/* sets a Data S(q,w) to 'NULL' */
void Sqw_Data_init(struct Sqw_Data_struct *Sqw_Data)
{
  Sqw_Data->q_bins       =0;
  Sqw_Data->w_bins       =0;
  Sqw_Data->q_max        =0;
  Sqw_Data->q_step       =1;
  Sqw_Data->w_max        =0;
  Sqw_Data->w_step       =1;
  Sqw_Data->Ei_max       = 0;
  Sqw_Data->lookup_length=100; /* length of lookup tables */
  Sqw_Data->intensity    =0;
  strcpy(Sqw_Data->filename, "");
  Sqw_Data->SW           =NULL;
  Sqw_Data->SQW          =NULL;
  Sqw_Data->SW_lookup    =NULL;
  Sqw_Data->QW_lookup    =NULL;
  Sqw_Data->iqSq_length  =100;
  Sqw_Data->type         = ' ';
  Sqw_Data->q_min_file   = 0;
}

off_struct offdata;

/* gaussian distribution to appply around Bragg peaks in a powder */
double Sqw_powder_gauss(double x, double mean, double rms) {
  return (exp(-(x-mean)*(x-mean)/(2*rms*rms))/(sqrt(2*PI)*rms));
}

/* Sqw_quantum_correction
*
* Return the 'quantum correction factor Q so that:
*
*   S(q, w) = Q(w) S*(q,w) 
*   S(q,-w) = exp(-hw/kT) S(q,w)
*   S(q, w) = exp( hw/kT) S(q,-w)
*
* with S*=classical limit and Q(w) defined below. For omega > 0, S(q,w) > S(q,-w)
*
* input:
*   w: energy      [meV]
*   T: temperature [K]
*   type: 'Schofield' or 'Boltzmann'        Q = exp(hw/kT/2)
*         'harmonic'  or 'Bader'            Q = hw/kT./(1-exp(-hw/kT))
*         'standard'  or 'Frommhold'        Q = 2./(1+exp(-hw/kT)) [recommended]
*
* References:
*  B. Hehr, http://www.lib.ncsu.edu/resolver/1840.16/7422 PhD manuscript (2010).
*  S. A. Egorov, K. F. Everitt and J. L. Skinner. J. Phys. Chem., 103, 9494 (1999).
*  P. Schofield. Phys. Rev. Lett., 4, 239 (1960).
*  J. S. Bader and B. J. Berne. J. Chem. Phys., 100, 8359 (1994).
*  T. D. Hone and G. A. Voth. J. Chem. Phys., 121, 6412 (2004).
*  L. Frommhold. Collision-induced absorption in gases, 1 st ed., Cambridge
*    Monographs on Atomic, Molecular, and Chemical Physics, Vol. 2,
*    Cambridge Univ. Press: London (1993).
        
 */
double Sqw_quantum_correction(double hw, double T, char *type) {
  double Q   = 1;
  double kT  = T/11.605;  /* [K] -> [meV = 1000*KB/e] */
  if (!hw || !T) return 1;
  if (type == NULL || !strcmp(type, "standard") 
                   || !strcmp(type, "Frommhold") || !strcmp(type, "default"))
    Q = 2/(1+exp(-hw/kT));
  if (!strcmp(type, "Schofield") || !strcmp(type, "Boltzmann"))
    Q = exp(hw/kT/2);
  if (!strcmp(type, "harmonic") || !strcmp(type, "Bader"))
    Q = hw/kT/(1-exp(-hw/kT));
    
  return Q;
}

/*****************************************************************************
* Sqw_read_PowderN: Read PowderN data files
*   Returns t_Table array or NULL in case of error
* Used in : Sqw_readfile (1)
*****************************************************************************/
t_Table *Sqw_read_PowderN(struct Sqw_sample_struct *Sqw, t_Table sqwTable)
{
  struct line_data
  {
    double F2;                  /* Value of structure factor */
    double q;                   /* Q vector */
    int j;                      /* Multiplicity */
    double DWfactor;            /* Debye-Waller factor */
    double w;                   /* Intrinsic line width */
  };
  struct line_data *list = NULL;
  double q_count=0, j_count=0, F2_count=0;
  int    mult_count  =0;
  double q_step      =FLT_MAX;
  long   size        =0;
  int    i, index;
  double q_min=0, q_max=0;
  char   flag=0;
  int    list_count=0;
  double q_step_cur;
  char   flag_qSq = 0;

  t_Table *retTable;

  flag_qSq = (Sqw->column_order[8]>0 && Sqw->column_order[6]>0);

  MPI_MASTER(
  if (Sqw->column_order[0] == 4 && Sqw->barns !=0)
    printf("Isotropic_sqw: %s: Powder file probably of type Crystallographica/Fullprof (lau)\n"
           "WARNING:       but F2 unit is set to powder_barns=1 (barns). Intensity might be 100 times too high.\n",
           Sqw->compname);
  if (Sqw->column_order[0] == 17 && Sqw->barns == 0)
    printf("Isotropic_sqw: %s: Powder file probably of type Lazy Pulver (laz)\n"
           "WARNING:       but F2 unit is set to powder_barns=0 (fm^2). Intensity might be 100 times too low.\n",
           Sqw->compname);
  );
  size = sqwTable.rows;
  MPI_MASTER(
  if (Sqw->verbose_output > 0) {
    printf("Isotropic_sqw: Converting %ld %s from %s into S(q,w) data\n",
        size, flag_qSq ? "S(q)" : "powder lines", sqwTable.filename);
  }
  );
  /* allocate line_data array */
  list = (struct line_data*)malloc(size*sizeof(struct line_data));

  for (i=0; i<size; i++)
    {
      double j=0, d=0, w=0, DWfactor=0, F2=0, Sq=-1, q=0;
      int index;

      if (Sqw->Dd >= 0)      w         = Sqw->Dd;
      if (Sqw->DWfactor > 0) DWfactor  = Sqw->DWfactor;

      /* get data from table using columns {j d F2 DW Dd inv2d q} + { Sq }*/
      /* column indexes start at 1, thus need to substract 1 */
      if (Sqw->column_order[0]>0)
        j = Table_Index(sqwTable, i, Sqw->column_order[0]-1);
      if (Sqw->column_order[1]>0)
        d = Table_Index(sqwTable, i, Sqw->column_order[1]-1);
      if (Sqw->column_order[2]>0)
        F2 = Table_Index(sqwTable, i, Sqw->column_order[2]-1);
      if (Sqw->column_order[3]>0)
        DWfactor = Table_Index(sqwTable, i, Sqw->column_order[3]-1);
      if (Sqw->column_order[4]>0)
        w = Table_Index(sqwTable, i, Sqw->column_order[4]-1);
      if (Sqw->column_order[5]>0)  {
        d = Table_Index(sqwTable, i, Sqw->column_order[5]-1); if (d) d = 1/d/2; }
      if (Sqw->column_order[6]>0)
        q = Table_Index(sqwTable, i, Sqw->column_order[6]-1);
      if (Sqw->column_order[7]>0 && !F2)
        {F2= Table_Index(sqwTable, i, Sqw->column_order[7]-1); F2 *= F2;}

      if (Sqw->column_order[8]>0)
        Sq= Table_Index(sqwTable, i, Sqw->column_order[8]-1);

      if (q > 0 && Sq >= 0) F2 = Sq;
      if (d > 0 && q <= 0)  q = 2*PI/d;

      /* assign and check values */
      j = (j > 0 ? j : 0);
      if (flag_qSq) j=1;
      DWfactor = (DWfactor > 0 ? DWfactor : 1);
      w = (w>0 ? w : 0);
      F2 = (F2 >= 0 ? F2 : 0);
      d = (q > 0 ? 2*PI/d : 0);
      if (j == 0 || d == 0 || q == 0) {
        MPI_MASTER(
        printf("Isotropic_sqw: %s: Warning: line %i has invalid definition\n"
               "         (mult=0 or q=0 or d=0)\n", Sqw->compname, i);
        );
        continue;
      }
      list[list_count].j = j;
      list[list_count].q = q;
      list[list_count].DWfactor = DWfactor;
      list[list_count].w = w;
      list[list_count].F2= F2; /* or S(q) if flag_qSq */

      if (q_max < d) q_max = q;
      if (q_min > d) q_min = q;
      if (list_count > 1) {
        q_step_cur = fabs(list[list_count].q - list[list_count-1].q);
        if (q_step_cur > 1e-5 && (!q_step || q_step_cur < q_step))
         q_step = q_step_cur;
      }

      /* adjust multiplicity if j-column + multiple d-spacing lines */
      /* if  d = previous d, increase line duplication index */
      if (!q_count)     q_count = q;
      if (!j_count)     j_count = j;
      if (!F2_count)    F2_count= F2;
      if (fabs(q_count-q) < 0.0001*fabs(q)
       && fabs(F2_count-F2) < 0.0001*fabs(F2) && j_count == j) {
       mult_count++; flag=0; }
      else flag=1;
      if (i == size-1) flag=1;
      /* else if d != previous d : just passed equivalent lines */
      if (flag) {
        if (i == size-1) list_count++;
      /*   if duplication index == previous multiplicity */
      /*      set back multiplicity of previous lines to 1 */
        if (Sqw->verbose_output > 2 && (mult_count == list[list_count-1].j
        || (mult_count == list[list_count].j && i == size-1))) {
          MPI_MASTER(
          printf("Isotropic_Sqw: %s: Setting multiplicity to 1 for lines [%i:%i]\n"
                  "         (d-spacing %g is duplicated %i times)\n",
            Sqw->compname, list_count-mult_count, list_count-1, list[list_count-1].q, mult_count);
          );
          for (index=list_count-mult_count; index<list_count; list[index++].j = 1);
          mult_count   = 1;
          q_count = q;
          j_count = j;
          F2_count= F2;
        }
        if (i == size-1) list_count--;
        flag=0;
      }
      list_count++;
    } /* end for */

  /* now builds new Table_Array to continue with Sqw_readfile */
  if (q_max == q_min || !q_step) return(NULL);
  if (!flag_qSq)
    size = 3*q_max/q_step; /* set a default of 3 q values per line */
  else size = list_count;
  /* update the value of q_step */
  q_step = q_max/size;
  MPI_MASTER(
  if (Sqw->verbose_output > 0)
    printf("Isotropic_sqw: q range [%g:%g], creating %li elements vector\n",
        q_min, q_max, size);
  );

  retTable = (t_Table*)calloc(4, sizeof(t_Table));
  if (!retTable) printf("Isotropic_Sqw: ERROR: Cannot allocate PowderN->Sqw table.\n");
  else {
    char *header;
    if (!Table_Init(&retTable[0], size, 1))
      { printf("Isotropic_Sqw: ERROR Cannot allocate q-axis [%li] from Powder lines.\n", size); return(NULL); }
    if (!Table_Init(&retTable[1], 1, 1))
      { printf("Isotropic_Sqw: ERROR Cannot allocate w-axis from Powder lines.\n"); return(NULL); }
    if (!Table_Init(&retTable[2], size, 1))
      { printf("Isotropic_Sqw: ERROR Cannot allocate Sqw [%li] from Powder lines.\n", size); return(NULL); }
    Table_Init(&retTable[3], 0,0);

    header = malloc(64); if (header)
    { retTable[0].header = header; strcpy(retTable[0].header, "q"); }
    header = malloc(64); if (header)
    { retTable[1].header = header; strcpy(retTable[1].header, "w"); }
    header = malloc(64); if (header)
    { retTable[2].header = header; strcpy(retTable[2].header, "Sqw"); }
    for (i=0; i < 4; i++) {
      retTable[i].array_length = 3;
      retTable[i].block_number = i+1;
    }
    if (!flag_qSq)
      for (i=0; i<size; i++)
        retTable[0].data[i]  = i*q_max/size;
    for (i=0; i<list_count; i++) { /* loop on each Bragg peak */
      double peak_qmin, peak_qmax,factor,q;
      if (list[i].w > 0 && !flag_qSq) {
        peak_qmin = list[i].q*(1 - list[i].w*3);
        peak_qmax = list[i].q*(1 + list[i].w*3);
      } else { /* Dirac peak, no width */
        peak_qmin = peak_qmax = list[i].q;
      }
      /* S(q) intensity is here */
      factor = list[i].j*(list[i].DWfactor ? list[i].DWfactor : 1)
               *Sqw->mat_rho*PI/2
               /(Sqw->type == 'c' ? Sqw->s_coh : Sqw->s_inc)*list[i].F2/list[i].q/list[i].q;
      if (Sqw->barns) factor *= 100;
      for (q=peak_qmin; q <= peak_qmax; q += q_step) {
        index = (long)floor(size*q/q_max);
        if (index < 0) index=0;
        else if (index >= size) index = size-1;
        if (flag_qSq) {
          retTable[2].data[index] += list[i].F2;
          retTable[0].data[index]  = list[i].q;
        } else {
          if (list[i].w <=0 || list[i].w*q < q_step) /* step function */
            retTable[2].data[index] += factor/q_step;
          else /* gaussian */
            retTable[2].data[index] += factor
                  * Sqw_powder_gauss(q, list[i].q, list[i].w*list[i].q);
        }
      }
    } /* end for i */
    Table_Stat(&retTable[0]); Table_Stat(&retTable[1]); Table_Stat(&retTable[2]);
    Sqw->sqw_norm = 0; /* F2 are normalized already */
  }

  return(retTable);
} /* Sqw_read_PowderN */

/*****************************************************************************
*  Sqw_search_SW: For a given random number 'randnum', search for the bin
*   containing  the corresponding Sqw->SW
*  Choose an energy in the projected S(w) distribution
* Used in : TRACE (1)
*****************************************************************************/
int Sqw_search_SW(struct Sqw_Data_struct Sqw, double randnum)
{
  int index_w=0;

  if (randnum <0) randnum=0;
  if (randnum >1) randnum=1;

  if (Sqw.w_bins == 1) return(0);
  /* benefit from fast lookup table if exists */
  if (Sqw.SW_lookup) {
    index_w = Sqw.SW_lookup[(long)floor(randnum*Sqw.lookup_length)]-1;
    if (index_w<0) index_w=0;
  }

  while (index_w < Sqw.w_bins && (&(Sqw.SW[index_w]) != NULL) && (randnum > Sqw.SW[index_w].cumul_proba))
      index_w++;
  if (index_w >= Sqw.w_bins) index_w = Sqw.w_bins-1;

  if (&(Sqw.SW[index_w]) == NULL)
  {
      printf("Isotropic_Sqw: Warning: No corresponding value in the SW. randnum too big.\n");
      printf("  index_w=%i ; randnum=%f ; Sqw.SW[index_w-1].cumul_proba=%f (Sqw_search_SW)\n",
            index_w, randnum, Sqw.SW[index_w-1].cumul_proba);
      return index_w-1;
  }
  else
      return (index_w);
}

/*****************************************************************************
*  Sqw_search_Q_proba_per_w: For a given random number randnum, search for
*   the bin containing the corresponding Sqw.SW in the Q probablility grid
*  Choose a momentum in the S(q|w) distribution
*  index is given by Sqw_search_SW
* Used in : TRACE (1)
*****************************************************************************/
int Sqw_search_Q_proba_per_w(struct Sqw_Data_struct Sqw, double randnum, int index_w)
{
  int index_q=0;

  if (randnum <0) randnum=0;
  if (randnum >1) randnum=1;

  /* benefit from fast lookup table if exists */
  if (Sqw.QW_lookup && Sqw.QW_lookup[index_w]) {
    index_q = Sqw.QW_lookup[index_w][(long)floor(randnum*Sqw.lookup_length)]-1;
    if (index_q<0) index_q=0;
  }

  while (index_q < Sqw.q_bins && (&(Sqw.SQW[index_w][index_q]) != NULL)
    && (randnum > Sqw.SQW[index_w][index_q].cumul_proba)) {
      index_q++;
  }
  if (index_q >= Sqw.q_bins) index_q = Sqw.q_bins-1;

  if (&(Sqw.SQW[index_w][index_q]) == NULL)
    return -1;
  else
    return (index_q);
}

/*****************************************************************************
* compute the effective total cross section \int q S(q,w) dw dq
* for incoming neutron energy 0 < Ei < 2*w_max, and
* integration range w=-w_max:Ei and q=Q0:Q1 with
*   Q0 = SE2Q*(sqrt(Ei)-sqrt(Ei-w))=|Ki-Kf|
*   Q1 = SE2Q*(sqrt(Ei)+sqrt(Ei-w))=|Ki+Kf|
* The data to use is Sqw_Data->Sqw, and the limits are Sqw_Data->w_max Sqw_Data->q_max
*   Returns the integral value
* Used in: Sqw_readfile (1)
*****************************************************************************/
double Sqw_integrate_iqSq(struct Sqw_Data_struct *Sqw_Data, double Ei)
{
  long   index_w;
  double iqSq = 0;
  /* w=Ei-Ef q=ki-kf w>0 neutron looses energy, Stokes, Ef = Ei-w > 0, Kf =|Ki-q| > 0 */
  for (index_w=0; index_w < Sqw_Data->w_bins; index_w++) {
    long   index_q;
    double w = -Sqw_Data->w_max + index_w * Sqw_Data->w_step; /* in the Sqw table */
    if (w <= Ei) {       /* integration range w=-w_max:Ei, Ef = Ei-w > 0 */
      double sq=0, Q0=0, Q1=0;
      sq = sqrt(Ei-w);  /* always real as test was true before */
      Q0 = SE2V*V2K*(sqrt(Ei)-sq);
      Q1 = SE2V*V2K*(sqrt(Ei)+sq);

      for (index_q=0; index_q < Sqw_Data->q_bins; index_q++) {
        double q=(double)index_q * Sqw_Data->q_step;
        /* add 'pixel' = q S(q,w) */
        if (Q0 <= q && q <= Q1) iqSq += q*Table_Index(Sqw_Data->Sqw, index_q, index_w);
      }
    }
  }
  /* multiply by 'pixel' size = dq dw */
  return(iqSq * Sqw_Data->q_step * Sqw_Data->w_step);
} /* Sqw_integrate_iqSq */


/*****************************************************************************
* Sqw_diagnosis: Computes Sqw_classical, moments and physical quantities
*                make consistency checks, and output some data files
*   Return: output files and information displayed
* Used in: Sqw_init (2) only by MASTER node with MPI
*****************************************************************************/
void Sqw_diagnosis(struct Sqw_sample_struct *Sqw, struct Sqw_Data_struct *Sqw_Data)
{

  t_Table  Sqw_cl;             /* the Sqw symmetric/classical version (T-> Inf) */
  t_Table  Gqw;                /* the generalized density of states as of Carpenter and Price, J Non Cryst Sol 92 (1987) 153 */
  t_Table  Sqw_moments[7];     /* M0=S(q) M1=E_r M3 w_c w_l M0_cl=S_cl(q) G(w) */
  t_Table  w_c, w_l;
  long     index_q, index_w;
  char     c[CHAR_BUF_LENGTH]; /* temporary variable */
  long     q_min_index = 0;

  char     do_coh=0, do_inc=0;
  double   q_min =0;
  double   u2    =0, S0=1;
  long     u2_count=0;

  if (!Sqw_Data || !Sqw_Data->intensity) return; /* nothing to do with empty S(q,w) */

  if (Sqw_Data->type=='c') do_coh = 1;
  if (Sqw_Data->type=='i') do_inc = 1;

  q_min = Sqw_Data->q_min_file;
  if (q_min <= 0) q_min = Sqw_Data->q_step;

  /* test if there is only one S(q,w) available */
  if (!((Sqw->Data_inc).intensity) || !((Sqw->Data_coh).intensity))
    do_coh = do_inc = 1; /* do both if only one file given */

  if (Sqw->Temperature > 0) {
    if (!Table_Init(&Sqw_cl, Sqw_Data->q_bins, Sqw_Data->w_bins)) {
      printf("Isotropic_Sqw: %s: Cannot allocate S_cl(q,w) Table (%lix%i).\n"
             "WARNING          Skipping S(q,w) diagnosis.\n",
             Sqw->compname, Sqw_Data->q_bins, 1);
      return;
    }
    sprintf(Sqw_cl.filename,
      "S(q,w)_cl from %s (dynamic structure factor, classical)",
      Sqw_Data->filename);
    Sqw_cl.block_number = 1;
    Sqw_cl.min_x        = 0;
    Sqw_cl.max_x        = Sqw_Data->q_max;
    Sqw_cl.step_x       = Sqw_Data->q_step;
  }

  /* initialize moments and 1D stuff */
  for (index_q=0; index_q < 6; index_q++) {
    if (!Table_Init(&Sqw_moments[index_q], Sqw_Data->q_bins, 1)) {
      printf("Isotropic_Sqw: %s: Cannot allocate S(q,w) moment %ld Table (%lix%i).\n"
           "WARNING          Skipping S(q,w) diagnosis.\n",
           Sqw->compname, index_q, Sqw_Data->q_bins, 1);
      Table_Free(&Sqw_cl);
      return;
    }
    Sqw_moments[index_q].block_number = 1;
    Sqw_moments[index_q].min_x  = 0;
    Sqw_moments[index_q].max_x  = Sqw_Data->q_max;
    Sqw_moments[index_q].step_x = Sqw_Data->q_step;
  }
  index_q=6;
  Table_Init(&Sqw_moments[index_q], Sqw_Data->w_bins, 1);
  Sqw_moments[index_q].block_number = 1;
  Sqw_moments[index_q].min_x  = -Sqw_Data->w_max;
  Sqw_moments[index_q].max_x  =  Sqw_Data->w_max;
  Sqw_moments[index_q].step_x =  Sqw_Data->w_step;

  /* set Table titles */
  sprintf(Sqw_moments[0].filename,
    "S(q)=M0(q) from %s [int S(q,w) dw]",
    Sqw_Data->filename);
  sprintf(Sqw_moments[1].filename,
    "M1(q) 1-st moment from %s [int w S(q,w) dw] = HBAR^2*q^2/2/m (f-sum rule, recoil, Lovesey T1 Eq 3.63 p72, Egelstaff p196)",
    Sqw_Data->filename);
  sprintf(Sqw_moments[2].filename,
    "M3(q) 3-rd moment from %s [int w^3 S(q,w) dw] = M1(q)*w_l^2(q)",
    Sqw_Data->filename);
  sprintf(Sqw_moments[3].filename,
    "w_c(q) = sqrt(M1(q)/M0(q)*2kT) collective excitation from %s (Lovesey T1 Eq 5.38 p180, p211 Eq 5.204). Gaussian half-width of the S(q,w) classical",
    Sqw_Data->filename);
  sprintf(Sqw_moments[4].filename,
    "w_l(q) = sqrt(M3(q)/M1(q)) harmonic frequency from %s (Lovesey T1 5.39 p 180)",
    Sqw_Data->filename);
  sprintf(Sqw_moments[5].filename,
    "S_cl(q)=M0_cl(q) from %s [int S_cl(q,w) dw]",
    Sqw_Data->filename);
  sprintf(Sqw_moments[6].filename,
    "G(w) generalized effective density of states from %s (Carpenter J Non Cryst Sol 92 (1987) 153)",
    Sqw_Data->filename);

  for   (index_q=0; index_q < Sqw_Data->q_bins; index_q++) {
    double q           = index_q*Sqw_Data->q_step; /* q value in Sqw_full ; q_min = 0 */
    double sq          = 0;              /* S(q) = w0 = 0-th moment */
    double w1          = 0;              /* first  moment      \int w     Sqw dw */
    double w3          = 0;              /* third  moment      \int w^3   Sqw dw */
    double sq_cl       = 0;              /* S(q) = M0 = 0-th moment classical */
    double w_c         = 0;
    double w_l         = 0;

    for (index_w=0; index_w < Sqw_Data->w_bins; index_w++) {

      double w = -Sqw_Data->w_max + index_w*Sqw_Data->w_step; /* w value in Sqw_full */
      double sqw_cl      =0;
      double sqw_full    =0;

      sqw_full = Table_Index(Sqw_Data->Sqw, index_q, index_w);

      /* Sqw moments */
      if (w && Sqw_Data->w_bins) {
        double tmp;
        tmp  = sqw_full*Sqw_Data->w_step;
        tmp *= w;   w1 += tmp;
        tmp *= w*w; w3 += tmp;
      }

      /* compute classical Sqw and S(q)_cl */
      if (Sqw->Temperature > 0) {
        double n;
        sqw_cl = sqw_full * Sqw_quantum_correction(-w,Sqw->Temperature,Sqw->Q_correction);
        if (!Table_SetElement(&Sqw_cl, index_q, index_w, sqw_cl))
          printf("Isotropic_Sqw: %s: "
                 "Error when setting Sqw_cl[%li q=%g,%li w=%g]=%g from file %s\n",
                 Sqw->compname, index_q, q, index_w, w, sqw_cl, Sqw_Data->filename);
        sq_cl += sqw_cl;
      }
      sq    += sqw_full;
    } /* for index_w */

    sq    *= Sqw_Data->w_step;         /* S(q) = \int S(q,w) dw = structure factor */
    sq_cl *= Sqw_Data->w_step;
    /* find minimal reliable q value (not interpolated) */
    if (q >= q_min && !q_min_index && sq) {
      q_min_index = index_q;
      q_min       = q;
      if (0.9 < sq)
        S0          = sq; /* minimum reliable S(q) */
      else S0 = 1;
    }
    /* compute <u^2> = <3 * ln(S(q)) / q^2> */
    if (q_min_index && q && S0 && sq) {
      u2      += 3 * log(sq/S0) /q/q;
      u2_count++;
    }

    /* store moment values (q) as M0=S(q) M1=E_r M3 w_c w_l M0_cl=S_cl(q) */
    Table_SetElement(&Sqw_moments[0],    index_q, 0, sq);
    Table_SetElement(&Sqw_moments[1],    index_q, 0, w1);
    Table_SetElement(&Sqw_moments[2],    index_q, 0, w3);
    if (w1 > 0 && sq && Sqw->Temperature > 0) {
      double w_c = sqrt(w1/sq*2*Sqw->Temperature*Sqw->T2E);  /* HBAR^2 q^2 kT /m/ S(q) */
      Table_SetElement(&Sqw_moments[3],    index_q, 0, w_c); /* collective dispersion */
    }
    if (w1 && w3*w1 > 0) {
      double w_l = sqrt(w3/w1);
      Table_SetElement(&Sqw_moments[4],    index_q, 0, w_l); /* harmonic dispersion */
    }
    if (Sqw->Temperature > 0)
      Table_SetElement(&Sqw_moments[5],    index_q, 0, sq_cl);

  } /* for index_q */



  /* display some usefull information, only once in MPI mode (MASTER) */
  if (Sqw->Temperature > 0) {
    double Da         = 1.660538921e-27;  /* [kg] unified atomic mass unit = Dalton = 1 g/mol */
  #ifndef KB
    double KB         = 1.3806503e-23;    /* [J/K] */
    /* HBAR   = 1.05457168e-34 */
  #endif
    double CELE       = 1.602176487e-19;  /* [C] Elementary charge CODATA 2006 'e' */
    double meV2Hz     = CELE/HBAR/1000/2/PI; /* 1 meV = 241.80e9 GHz */
    double gqw_sum    = 0;

    /* classical Sqw */
    sprintf(c, "%s_%s_cl.sqw", Sqw->compname, Sqw_Data->type=='c' ? "coh" : "inc");
    Table_Write(Sqw_cl, c, "Momentum [Angs-1]", "'S(q,w)*exp(hw/2kT) classical limit' Energy [meV]",
        0,Sqw_Data->q_max,-Sqw_Data->w_max,Sqw_Data->w_max);
    Table_Free(&Sqw_cl);

    if (u2_count) u2 /= u2_count;

    MPI_MASTER(
    if (do_coh || do_inc)
      printf("Isotropic_Sqw: %s: "
             "Physical constants from the S(q,w) %s for T=%g [K]. Values are estimates.\n",
             Sqw->compname, Sqw_Data->filename, Sqw->Temperature);
    if (do_coh) {
      if (Sqw->mat_weight) {
        double LAMBDA     = HBAR*2*PI/sqrt(2*PI*Sqw->mat_weight*Da*KB*Sqw->Temperature)*1e10;   /* in [Angs] */
        double z          = Sqw->mat_rho * LAMBDA*LAMBDA*LAMBDA;  /* fugacity , rho=N/V in [Angs-3]*/
        double mu         = KB*Sqw->Temperature*log(z);       /* perfect gas chemical potential */
        printf("# De Broglie wavelength     LAMBDA=%g [Angs]\n", LAMBDA);
        printf("# Fugacity                       z=%g (from Egelstaff p32 Eq 2.31)\n", z);
        printf("# Chemical potential            mu=%g [eV] (eq. perfect gas)\n", mu/CELE);
      }

      /* compute isothermal sound velocity and compressibility */
      /* get the S(q_min) value and the corresponding w_c */

      if (q_min_index > 0 && q_min && q_min < 0.6) {
        double w_c = Table_Index(Sqw_moments[3], q_min_index, 0); /* meV */
        /* HBAR = [J*s] */
        double c_T = 2*PI*w_c*meV2Hz/q_min/1e10;                  /* meV*Angs -> m/s */
        double ChiT= S0/(KB*Sqw->Temperature*Sqw->mat_rho*1e30);
        printf("# Isothermal compressibility Chi_T=%g [Pa-1] (Egelstaff  p201 Eq 10.21) at q=%g [Angs-1]\n",
          ChiT, q_min);
        printf("# Isothermal sound velocity    c_T=%g [m/s]  (Lovesey T1 p210 Eq 5.197) at q=%g [Angs-1]\n",
          c_T, q_min);

        /* Computation if C11 is rather tricky as it is obtained from w_l, which is usually quite noisy
         * This means that the obtained values are not reliable from C = rho c_l^2 (Egelstaff Eq 14.10b p284)
         * C44 = rho c_c^2 ~ C11/3
         */
        double w_l = Table_Index(Sqw_moments[4], q_min_index, 0); /* meV */
        double c_l = 2*PI*w_l*meV2Hz/q_min/1e10;                  /* meV*Angs -> m/s */
        double C11 = (Sqw->mat_weight*Da)*(Sqw->mat_rho*1e30)*c_l*c_l;
        printf("# Elastic modulus              C11=%g [GPa]  (Egelstaff Eq 14.10b p284) [rough estimate] at q=%g [Angs-1]\n",
            C11/1e9, q_min);
      }
    }
    if (do_inc) {
      /* display the mean square displacement from S(q) = exp(-<u^2>q^2/3)
           <u^2>= <3 * ln(S(q)) / q^2>
       */
      if (u2_count && u2) {
        printf("# Mean square displacement   <u^2>=%g [Angs^2] (<3 * ln(S(q)) / q^2>)\n", u2);
      }

      /* compute the mean diffusion coefficient D=w_c/q^2 */
      /* FWHM of gaussian is Gamma*RMS2FWHM, only in diffusive regime (Q < 0.2 Angs-1) */
      if (q_min_index > 0 && q_min && q_min < 0.6) {
        double w_c = Table_Index(Sqw_moments[3], q_min_index, 0);
        double D   = 2*PI*w_c*meV2Hz/q_min/q_min/1e14*RMS2FWHM/2; /* meV*Angs^2 -> mm^2/s */
        printf("# Diffusion coefficient          D=%g [mm^2/s] (Egelstaff p220)\n", D);
        if (u2_count && u2 && D)
          printf("# Jump relaxation time         tau=%g [ns] (Egelstaff Eq 11.8 p220)\n", u2*1e-2/6/D);
      }
    }
    ); /* MPI_MASTER */

    /* density of states (generalized) */
    if (!Table_Init(&Gqw, Sqw_Data->q_bins, Sqw_Data->w_bins)) {
      printf("Isotropic_Sqw: %s: Cannot allocate G(q,w) Table (%lix%i).\n"
             "WARNING          Skipping S(q,w) diagnosis.\n",
             Sqw->compname, Sqw_Data->q_bins, 1);
        return;
    }
    sprintf(Gqw.filename,
      "G(q,w) from %s (generalized density of states, Carpenter J Non Cryst Sol 92 (1987) 153)",
      Sqw_Data->filename);
    Gqw.block_number = 1;
    Gqw.min_x        = 0;
    Gqw.max_x        = Sqw_Data->q_max;
    Gqw.step_x       = Sqw_Data->q_step;

    for (index_w=0; index_w < Sqw_Data->w_bins; index_w++) {
      double w        = -Sqw_Data->w_max + index_w*Sqw_Data->w_step; /* w value in Sqw_full */
      double gw       = 0;
      for   (index_q=0; index_q < Sqw_Data->q_bins; index_q++) {
        double q        = index_q*Sqw_Data->q_step; /* q value in Sqw_full ; q_min = 0 */
        double sqw_full = Table_Index(Sqw_Data->Sqw, index_q, index_w);
        double n        = 1/(exp(w/(Sqw->Temperature*Sqw->T2E))-1); /* Bose factor */
        double DW       = q && u2 ? exp(2*u2*q*q/6) : 1;            /* Debye-Weller factor */
        double gqw      = q && n+1 ? sqw_full*DW*2*(Sqw->mat_weight*Da)*w/(n+1)/q/q : 0;
        if (!Table_SetElement(&Gqw, index_q, index_w, gqw))
          printf("Isotropic_Sqw: %s: "
                 "Error when setting Gqw[%li q=%g,%li w=%g]=%g from file %s\n",
                 Sqw->compname, index_q, q, index_w, w, gqw, Sqw_Data->filename);
        gw      += gqw;
        gqw_sum += gqw;
      }
      Table_SetElement(&Sqw_moments[6],    index_w, 0, gw);
    }

    /* normalize the density of states */
    for (index_w=0; index_w < Sqw_Data->w_bins; index_w++) {
      double gw = Table_Index(Sqw_moments[6], index_w, 0);
      Table_SetElement(&Sqw_moments[6], index_w, 0, gw / gqw_sum);
      for   (index_q=0; index_q < Sqw_Data->q_bins; index_q++) {
        double gqw = Table_Index(Gqw, index_q, index_w);
        Table_SetElement(&Gqw, index_q, index_w, gqw / gqw_sum);
      }
    }

    /* write Gqw and free memory */
    if (Sqw_Data->w_bins > 1) {
      sprintf(c, "%s_%s.gqw", Sqw->compname, Sqw_Data->type=='c' ? "coh" : "inc");
        Table_Write(Gqw, c, "Momentum [Angs-1]", "'Generalized density of states' Energy [meV]",
          0,Sqw_Data->q_max,-Sqw_Data->w_max,Sqw_Data->w_max);
      Table_Free(&Gqw);
    }
  } /* if T>0 */

  /* write all tables to disk M0=S(q) M1=E_r M3 w_c w_l M0_cl=S_cl(q) */
  if (Sqw_Data->w_bins > 1) {
    sprintf(c, "%s_%s.m1",  Sqw->compname, Sqw_Data->type=='c' ? "coh" : "inc");
    Table_Write(Sqw_moments[1], c, "Momentum [Angs-1]", "int w S(q,w) dw (recoil) q^2/2m [meV]",
      0,Sqw_Data->q_max,0,0);
    sprintf(c, "%s_%s.w_l", Sqw->compname, Sqw_Data->type=='c' ? "coh" : "inc");
    Table_Write(Sqw_moments[4], c, "Momentum [Angs-1]", "w_l(q) harmonic frequency [meV]",
      0,Sqw_Data->q_max,0,0);
    sprintf(c, "%s_%s.sqw", Sqw->compname, Sqw_Data->type=='c' ? "coh" : "inc");
    Table_Write(Sqw_Data->Sqw, c, "Momentum [Angs-1]", "'S(q,w) dynamical structure factor [meV-1]' Energy [meV]",
      0,Sqw_Data->q_max,-Sqw_Data->w_max,Sqw_Data->w_max);

    if (Sqw->Temperature > 0) {
      sprintf(c, "%s_%s.w_c",    Sqw->compname, Sqw_Data->type=='c' ? "coh" : "inc");
      Table_Write(Sqw_moments[3], c, "Momentum [Angs-1]", "w_c(q) collective excitation [meV]", 0,Sqw_Data->q_max,0,0);
      sprintf(c, "%s_%s_cl.sq",  Sqw->compname, Sqw_Data->type=='c' ? "coh" : "inc");
      Table_Write(Sqw_moments[5], c, "Momentum [Angs-1]", "int S_cl(q,w) dw",
        0,Sqw_Data->q_max,0,0);
      sprintf(c, "%s_%s.gw",  Sqw->compname, Sqw_Data->type=='c' ? "coh" : "inc");
      Table_Write(Sqw_moments[6], c, "Energy [meV]", "'Generalized effective density of states' Energy [meV]",
        -Sqw_Data->w_max,Sqw_Data->w_max,0,0);

    }
  }
  sprintf(c, "%s_%s.sq",    Sqw->compname, Sqw_Data->type=='c' ? "coh" : "inc");
  Table_Write(Sqw_moments[0], c, "Momentum [Angs-1]","S(q) = int S(q,w) dw", 0,Sqw_Data->q_max,0,0);
  sprintf(c, "%s_%s.sigma", Sqw->compname, Sqw_Data->type=='c' ? "coh" : "inc");
  Table_Write(Sqw_Data->iqSq, c, "Energy [meV]", "sigma kf/ki int q S(q,w) dw scattering cross section [barns]", 0,0,0,0);

  /* free Tables */
  for (index_q=0; index_q < 7; Table_Free(&Sqw_moments[index_q++]));

} /* Sqw_diagnosis */

/*****************************************************************************
* Sqw_readfile: Read Sqw data files
*   Returns Sqw_Data_struct or NULL in case of error
* Used in : Sqw_init (2)
*****************************************************************************/
struct Sqw_Data_struct *Sqw_readfile(
  struct Sqw_sample_struct *Sqw, char *file, struct Sqw_Data_struct *Sqw_Data)
{

  t_Table *Table_Array= NULL;
  long     nblocks    = 0;
  char     flag       = 0;

  t_Table  Sqw_full, iqSq; /* the Sqw (non symmetric) and total scattering X section */

  double   sum=0;
  double   mat_at_nb=1;
  double   iq2Sq=0;
  long    *SW_lookup=NULL;
  long   **QW_lookup=NULL;
  char   **parsing  =NULL;

  long   index_q, index_w;
  double q_min_file, q_max_file, q_step_file;
  long   q_bins_file;
  double w_min_file, w_max_file, w_step_file;
  long   w_bins_file;
  double q_max, q_step;
  long   q_bins;
  double w_max, w_step;
  long   w_bins;

  double alpha=0;

  double M1          = 0;
  double M1_cl       = 0;
  double T           = 0;
  double T_file      = 0;
  long   T_count     = 0;
  long   M1_count    = 0;
  long   M1_cl_count = 0;

  /* setup default */
  Sqw_Data_init(Sqw_Data);

  if (!file || !strlen(file) || !strcmp(file, "NULL") || !strcmp(file, "0")) return(Sqw_Data);
  /* read the Sqw file */
  Table_Array = Table_Read_Array(file, &nblocks);
  strncpy(Sqw_Data->filename, file, 80);
  if (!Table_Array) return(NULL);

  /* (1) parsing of header ================================================== */
  parsing = Table_ParseHeader(Table_Array[0].header,
    "Vc","V_0",
    "sigma_abs","sigma_a ",
    "sigma_inc","sigma_i ",
    "column_j", /* 6 */
    "column_d",
    "column_F2",
    "column_DW",
    "column_Dd",
    "column_inv2d", "column_1/2d", "column_sintheta_lambda",
    "column_q", /* 14 */
    "sigma_coh","sigma_c ",
    "Temperature",
    "column_Sq",
    "column_F ", /* 19 */
    "V_rho",
    "density",
    "weight",
    "nb_atoms","multiplicity",
    "classical",
    NULL);
  if (parsing) {
    int i;
    if (parsing[0] && !Sqw->mat_rho)      Sqw->mat_rho    =1/atof(parsing[0]);
    if (parsing[1] && !Sqw->mat_rho)      Sqw->mat_rho    =1/atof(parsing[1]);
    if (parsing[2] && !Sqw->s_abs)    Sqw->s_abs  =  atof(parsing[2]);
    if (parsing[3] && !Sqw->s_abs)    Sqw->s_abs  =  atof(parsing[3]);
    if (parsing[4] && !Sqw->s_inc)    Sqw->s_inc  =  atof(parsing[4]);
    if (parsing[5] && !Sqw->s_inc)    Sqw->s_inc  =  atof(parsing[5]);
    if (parsing[6])                   Sqw->column_order[0]=atoi(parsing[6]);
    if (parsing[7])                   Sqw->column_order[1]=atoi(parsing[7]);
    if (parsing[8])                   Sqw->column_order[2]=atoi(parsing[8]);
    if (parsing[9])                   Sqw->column_order[3]=atoi(parsing[9]);
    if (parsing[10])                  Sqw->column_order[4]=atoi(parsing[10]);
    if (parsing[11])                  Sqw->column_order[5]=atoi(parsing[11]);
    if (parsing[12])                  Sqw->column_order[5]=atoi(parsing[12]);
    if (parsing[13])                  Sqw->column_order[5]=atoi(parsing[13]);
    if (parsing[14])                  Sqw->column_order[6]=atoi(parsing[14]);
    if (parsing[15] && !Sqw->s_coh)   Sqw->s_coh=atof(parsing[15]);
    if (parsing[16] && !Sqw->s_coh)   Sqw->s_coh=atof(parsing[16]);
    if (parsing[17] && !Sqw->Temperature) Sqw->Temperature=atof(parsing[17]); /* from user or file */
    if (parsing[17] )                 T_file=atof(parsing[17]); /* from file */
    if (parsing[18])                  Sqw->column_order[8]=atoi(parsing[18]);
    if (parsing[19])                  Sqw->column_order[7]=atoi(parsing[19]);
    if (parsing[20] && !Sqw->mat_rho)     Sqw->mat_rho    =atof(parsing[20]);
    if (parsing[21] && !Sqw->mat_density) Sqw->mat_density=atof(parsing[21]);
    if (parsing[22] && !Sqw->mat_weight)  Sqw->mat_weight =atof(parsing[22]);
    if (parsing[23] )                 mat_at_nb   =atof(parsing[23]);
    if (parsing[24] )                 mat_at_nb   =atof(parsing[24]);
    if (parsing[25] )                 { /* classical is found in the header */
      char *endptr;
      double value = strtod(parsing[25], &endptr);
      if (*endptr == *parsing[25]) {
        if (Sqw->sqw_classical < 0) Sqw->sqw_classical = 1;
      } else                        Sqw->sqw_classical = value;
    }
    for (i=0; i<=25; i++) if (parsing[i]) free(parsing[i]);
    free(parsing);
  }

  /* compute the scattering unit density from material weight and density */
  /* the weight of the scattering element is the chemical formula molecular weight
   * times the nb of chemical formulae in the scattering element (nb_atoms) */
  if (!Sqw->mat_rho && Sqw->mat_density > 0 && Sqw->mat_weight > 0 && mat_at_nb > 0) {
    /* molar volume [cm^3/mol] = weight [g/mol] / density [g/cm^3] */
    /* atom density per Angs^3 = [mol/cm^3] * N_Avogadro *(1e-8)^3 */
    Sqw->mat_rho = Sqw->mat_density/(Sqw->mat_weight*mat_at_nb)/1e24*NA;
    MPI_MASTER(
    if (Sqw->verbose_output > 0)
      printf("Isotropic_Sqw: %s: Computing scattering unit density V_rho=%g [AA^-3] from density=%g [g/cm^3] weight=%g [g/mol].\n",
        Sqw->compname, Sqw->mat_rho, Sqw->mat_density, Sqw->mat_weight);
    );
  }

  /* the scattering unit cross sections are the chemical formula ones
   * times the nb of chemical formulae in the scattering element */
  if (mat_at_nb > 0) {
    Sqw->s_abs *= mat_at_nb; Sqw->s_inc *= mat_at_nb; Sqw->s_coh *= mat_at_nb;
  }

  if (nblocks) {
    if (nblocks == 1) {
      /* import Powder file */
      t_Table *newTable   = NULL;
      newTable = Sqw_read_PowderN(Sqw, Table_Array[0]);
      if (!newTable) {
        MPI_MASTER(
        printf("Isotropic_Sqw: %s: ERROR importing powder line file %s.\n"
               "               Check format definition.\n",
              Sqw->compname, file);
        );
        exit(-1);
      } else flag=0;
      Table_Free_Array(Table_Array);
      Table_Array = newTable;
    } else if (nblocks != 3) {
      MPI_MASTER(
      printf("Isotropic_Sqw: %s: ERROR "
             "File %s contains %li block%s instead of 3.\n",
              Sqw->compname, file, nblocks, (nblocks == 1 ? "" : "s"));
      );
    } else { flag=0; Sqw->barns=0; /* Sqw files do not use powder_barns */ }
  }

  /* print some info about Sqw files */
  if (flag) Sqw->verbose_output = 2;

  if (flag) {
    MPI_MASTER(
    if (nblocks) printf("ERROR          Wrong file format.\n"
      "               Disabling contribution.\n"
      "               File must contain 3 blocks for [q,w,sqw] or Powder file (1 block, laz,lau).\n");
    );
    return(Sqw_Data);
  }

  sprintf(Table_Array[0].filename, "%s#q",   file);
  sprintf(Table_Array[1].filename, "%s#w",   file);
  sprintf(Table_Array[2].filename, "%s#sqw", file);

  MPI_MASTER(
  if (nblocks && Sqw->verbose_output > 2) {
    printf("Isotropic_Sqw: %s file read, analysing...\n", file);
    Table_Info_Array(Table_Array);
  }
  );

  /* (2) compute range for full +/- w and allocate S(q,w) =================== */

  /* get the q,w extend of the table from the file */
  q_bins_file = Table_Array[0].rows*Table_Array[0].columns;
  w_bins_file = Table_Array[1].rows*Table_Array[1].columns;

  /* is there enough qw data in file to proceed ? */
  if (q_bins_file <= 1 || w_bins_file <= 0) {
    MPI_MASTER(
    printf("Isotropic_Sqw: %s: Data file %s has incomplete q or omega information (%lix%li).\n"
           "ERROR          Exiting.\n",
      Sqw->compname, file, q_bins_file, w_bins_file);
    );
    return(Sqw_Data);
  }

  q_min_file  = Table_Array[0].min_x; q_max_file = Table_Array[0].max_x;
  q_step_file = Table_Array[0].step_x ? Table_Array[0].step_x : (q_max_file - q_min_file)/(Table_Array[0].rows*Table_Array[0].columns);
  w_min_file  = Table_Array[1].min_x; w_max_file = Table_Array[1].max_x;
  w_step_file = Table_Array[1].step_x;

  /* create a regular extended q,w and Sqw tables applying the exp(-hw/kT) factor */
  q_max  = q_max_file;
  q_bins = (q_step_file ?   q_max/q_step_file : q_bins_file)+1;
  q_step = q_bins-1 > 0 ?   q_max/(q_bins-1) : 1;
  w_max  = fabs(w_max_file);
  if (fabs(w_min_file) > fabs(w_max_file)) w_max = fabs(w_min_file);
  /* w_min =-w_max */
  w_bins = (w_step_file ? (long)(2*w_max/w_step_file) : 0)+1; /* twice the initial w range */
  w_step = w_bins-1 > 0 ? 2*w_max/(w_bins-1) : 1;             /* that is +/- w_max         */

  /* create the Sqw table in full range */
  if (!Table_Init(&Sqw_full, q_bins, w_bins)) {
    printf("Isotropic_Sqw: %s: Cannot allocate Sqw_full Table (%lix%li).\n"
           "ERROR          Exiting.\n",
      Sqw->compname, q_bins, w_bins);
    return(NULL);
  }
  sprintf(Sqw_full.filename, "S(q,w) from %s (dynamic structure factor)", file);
  Sqw_full.block_number = 1;

  Sqw_Data->q_bins = q_bins; Sqw_Data->q_max = q_max; Sqw_Data->q_step= q_step;
  Sqw_Data->w_bins = w_bins; Sqw_Data->w_max = w_max; Sqw_Data->w_step= w_step;
  Sqw_Data->q_min_file = q_min_file;

  /* build an energy symmetric Sqw data set with detailed balance there-in, so
   * that we can both compute effective scattering Xsection, probability distributions
   * that is S(q) and \int q S(q).
   * We scan the new Sqw table elements with regular qw binning and search for their
   * equivalent element in the Sqw file data set. This is slower than doing the opposite.
   * We could be scanning all file elements, and fill the new table, but in the
   * process some empty spaces may appear when the initial file binning is not regular
   * in qw, leading to gaps in the new table.
   */

  /* (3) we build q and w lookup table for conversion file -> sqw_full ====== */
  MPI_MASTER(
  if (Sqw->verbose_output > 2)
    printf("Isotropic_Sqw: %s: Creating Sqw_full... (%s, %s)\n",
      Sqw->compname, file, Sqw->type=='c' ? "coh" : "inc");
  );

  double w_file2full[w_bins]; /* lookup table for fast file -> Sqw_full allocation */

  for (index_w=0; index_w < w_bins; w_file2full[index_w++]=0);

  for (index_w=0; index_w < w_bins; index_w++) {

    double w = -w_max + index_w*w_step; /* w value in Sqw_full */
    double index_w_file=0;              /* w index in Sqw file */
    char   found=0;
    for (index_w_file=0; index_w_file < w_bins_file; index_w_file++) {
      double w0=Table_Index(Table_Array[1], (long)index_w_file,  0);
      double w1=Table_Index(Table_Array[1], (long)index_w_file+1,0);
      /* test if we are in Stokes */
      if (w0 > w1) {
        double tmp=w0; w0=w1; w1=tmp;
      }
      if (w0 <= w && w < w1) {
        /* w ~ w_file exists in file, usually on w > 0 side Stokes, neutron looses energy */
        index_w_file += w1-w0 ? (w-w0)/(w1-w0) : 0; /* may correspond with a position in-betwwen two w elements */
        found=1;
        break;
      }
    }
    /* test if we are in anti-Stokes */
    if (!found)
    for (index_w_file=0; index_w_file < w_bins_file; index_w_file++) {
      double w0=Table_Index(Table_Array[1], (long)index_w_file,  0);
      double w1=Table_Index(Table_Array[1], (long)index_w_file+1,0);
      /* test if we are in anti-Stokes */
      if (w0 > w1) {
        double tmp=w0; w0=w1; w1=tmp;
      }
      if (w0 <= -w && -w < w1) {            /* w value is mirrored from the opposite side in file */
        index_w_file += w1-w0 ? (-w-w0)/(w1-w0) : 0;
        index_w_file = -index_w_file;               /* in this case, index value is set to negative */
        break;
      }
    }
    w_file2full[index_w] = index_w_file;
  }

  double q_file2full[q_bins];
  for   (index_q=0; index_q < q_bins; q_file2full[index_q++]=0);

  for (index_q=0; index_q < q_bins; index_q++) {

    double q           = index_q*q_step; /* q value in Sqw_full ; q_min = 0 */
    double index_q_file= 0;              /* q index in Sqw file */

    /* search for q value in the initial file data set */
    if      (q <= q_min_file) index_q_file=0;
    else if (q >= q_max_file) index_q_file=q_bins_file-1;
    else
    for (index_q_file=0; index_q_file < q_bins_file; index_q_file++) {
      double q0=Table_Index(Table_Array[0], (long)index_q_file,  0);
      double q1=Table_Index(Table_Array[0], (long)index_q_file+1,0);
      if (q0 <= q && q <= q1) {
        index_q_file += q1-q0 ? (q-q0)/(q1-q0) : 0; /* may correspond with a position in-betwwen two q elements */
        break;
      }
    }
    q_file2full[index_q] = index_q_file;
  }

  /* (4) now we build Sqw on full Q,W ranges, using the Q,W table lookup above -> Sqw_full */
  for (index_q=0; index_q < q_bins; index_q++) {

    double q           = index_q*q_step; /* q value in Sqw_full ; q_min = 0 */
    double index_q_file= 0;              /* q index in Sqw file */

    /* get q value in the initial file data set */
    index_q_file = q_file2full[index_q];

    /* now scan energy elements in Sqw full, and search these in file data */
    for (index_w=0; index_w < w_bins; index_w++) {
      double w = -w_max + index_w*w_step; /* w value in Sqw_full */
      double index_w_file=0;              /* w index in Sqw file */
      double sqw_file    =0;              /* Sqw(index_q, index_w) value interpolated from file */

      /* search for w value in the file data set, negative when mirrored */
      index_w_file = w_file2full[index_w];
      /* get Sqw_file element, with bi-linear interpolation from file */
      /* when the initial file does not contain the energy, the opposite element (-w) is used */
      sqw_file     = Table_Value2d(Table_Array[2], index_q_file, fabs(index_w_file));
      /* apply the minimum threshold to remove noisy background in S(q,w) */
      if (sqw_file < Sqw->sqw_threshold) sqw_file = 0;
      else if (index_w_file < 0)         sqw_file = -sqw_file; /* negative == mirrored from other side */

      if (!Table_SetElement(&Sqw_full, index_q, index_w, sqw_file))
        printf("Isotropic_Sqw: %s: "
               "Error when setting Sqw[%li q=%g,%li w=%g]=%g from file %s\n",
               Sqw->compname, index_q, q, index_w, w, fabs(sqw_file), file);
    } /* for index_w */
  } /* for index_q */

  /* free memory and store limits for new full Sqw table */
  Table_Free_Array(Table_Array);

  /* if only one S(q,w) side is given, it is symmetrised by mirroring, then M1=0 */

  /* (5) test if the Sqw_full is classical or not by computing the 1st moment (=0 for classical) */
  /* also compute temperature (quantum case) from file if not set */
  for (index_q=0; index_q < q_bins; index_q++) {

    double q           = index_q*q_step; /* q value in Sqw_full ; q_min = 0 */

    for (index_w=0; index_w < w_bins; index_w++) {
      double w        = -w_max + index_w*w_step; /* w value in Sqw_full */
      double sqw_full = Table_Index(Sqw_full, index_q, index_w);
      long   index_mw = w_bins-1-index_w;        /* opposite w index in S(q,w) */
      double sqw_opp  = Table_Index(Sqw_full, index_q, index_mw);
      double T_defined= T_file ? T_file : Sqw->Temperature; /* T better from file, else from user */

      /* the analysis must be done only on values which exist on both sides */
      /* as integrals must be symmetric, and Bose factor requires both sides as well */
      if (sqw_full > 0 && sqw_opp > 0) {
        /* compute temperature from Bose factor */
        if (sqw_opp != sqw_full) {
          T      += fabs(w/log(sqw_opp/sqw_full)/Sqw->T2E);
          T_count++;
        }
        /* we first assume Sqw is quantum. M1_cl should be 0, M1 should be recoil */
        M1      += w*sqw_full*w_step;
        M1_count++;
        /* we assume it is quantum (non symmetric) and check that its symmetrized version has M1_cl=0 */
        if (T_defined > 0) {
          sqw_opp = sqw_full * Sqw_quantum_correction(-w, T_defined,Sqw->Q_correction); /* Sqw_cl */
          M1_cl      += w*sqw_opp*w_step;
          M1_cl_count++;
        } else if (Sqw->mat_weight) {
          /* T=0 ? would compute the M1_cl = M1 - recoil energy, assuming we have a quantum S(q,w) in file */
          /* the M1(quantum) = (MNEUTRON/m)*2.0725*q^2 recoil energy */
          double Da = 1.660538921e-27; /* atomic mass unit */
          double Er = (MNEUTRON/Sqw->mat_weight/Da)*2.0725*q*q; /* recoil for one scattering unit in the cell [meV] Schober JDN16 p239 */
          M1_cl      += M1 - Er;
          M1_cl_count++;
        }
      } /* both side from file */
    } /*index_w */
  } /*index_q */

  if (T_count)     T     /= T_count;     /* mean temperature from Bose ratio */
  if (M1_count)    M1    /= M1_count;
  if (M1_cl_count) M1_cl /= M1_cl_count; /* mean energy value along q range */

  /* determine if we use a classical or quantum S(q,w) */
  if (Sqw->sqw_classical < 0) {
    if (fabs(M1) < 2*w_step) {
      Sqw->sqw_classical = 1; /* the initial Sqw from file seems to be centered, thus classical */
    } else if (fabs(M1_cl) < fabs(M1)) {
      /* M1 for classical is closer to 0 than for quantum one */
      Sqw->sqw_classical = 0; /* initial data from file seems to be quantum (non classical) */
    } else { /* M1_cl > M1 > 2*w_step */
      MPI_MASTER(
      printf("Isotropic_Sqw: %s: I do not know if S(q,w) data is classical or quantum.\n"
             "WARNING        First moment M1=%g M1_cl=%g for file %s. Defaulting to classical case.\n",
                 Sqw->compname, M1, M1_cl, file);
      );
    }
  }
  if (Sqw->sqw_classical < 0) Sqw->sqw_classical=1; /* default when quantum/classical choice is not set */
  
  /* (5b) set temperature. Temperatures defined are:
  *   T_file:           temperature read from the .sqw file
  *   T:                temperature computed from the quantum Sqw using detailed balance
  *   Sqw->Temperature: temperature defined by user, or read from file when not set
  */
 
  
  /* display some warnings about the computed temperature */
  if (T > 3000) T=0; /* unrealistic */
  if (!T_file && T) {
    MPI_MASTER(
    if (Sqw->verbose_output > 0) {
      printf(  "Isotropic_Sqw: %s: Temperature computed from S(q,w) data from %s is T=%g [K].\n",
        Sqw->compname, file, T);
    );
    }
  }
  
  if (Sqw->Temperature == 0) {
    Sqw->Temperature = T_file ? T_file : T; /* 0:  not set: we use file value, else computed */
  } else if (Sqw->Temperature ==-1) {
    Sqw->Temperature = 0;                   /* -1: no detailed balance. Display message at end of INIT */
  } else if (Sqw->Temperature ==-2) {
    Sqw->Temperature = T ? T : T_file;      /* -2: use guessed value when available */
  } /* else let value as it is (e.g. >0) */
  
  if (Sqw->verbose_output > 0 && Sqw->Temperature) {
    MPI_MASTER(
    printf(  "Isotropic_Sqw: %s: Temperature set to T=%g [K]\n", Sqw->compname, Sqw->Temperature);
    );
  }

  MPI_MASTER(
  if (Sqw->verbose_output > 0 && w_bins > 1)
    printf("Isotropic_Sqw: %s: S(q,w) data from %s (%s) assumed to be %s.\n",
      Sqw->compname, file, Sqw->type=='c' ? "coh" : "inc",
      Sqw->sqw_classical ? "classical (symmetrised in energy)" : "non-classical (includes Bose factor, non symmetric in energy)");
  );

  /* (6) apply detailed balance on Sqw_full for classical or quantum S(q,w) */
  /* compute the \int q^2 S(q) for normalisation */
  
  MPI_MASTER(
  if (Sqw->sqw_classical && Sqw->verbose_output > 0 && Sqw->Temperature > 0)
    printf("Isotropic_Sqw: %s: Applying exp(hw/2kT) factor with T=%g [K] on %s file (classical/symmetric) using '%s' quantum correction\n",
      Sqw->compname, Sqw->Temperature, file, Sqw->Q_correction);
  );
  for   (index_q=0; index_q < q_bins; index_q++) {
    double sq          = 0;
    double q           = index_q*q_step;  /* q value in Sqw_full ; q_min = 0 */
    for (index_w=0; index_w < w_bins; index_w++) {
      double w = -w_max + index_w*w_step; /* w value in Sqw_full */
      double balance   = 1;               /* detailed balance factor, default is 1 */
      double sqw_full  = Table_Index(Sqw_full, index_q, index_w);

      /* do we use a symmetric S(q,w) from real G(r,t) from e.g. MD ? */
      
      if (Sqw->sqw_classical && Sqw->Temperature > 0) /* data is symmetric, we apply Bose factor */
        /* un-symmetrize Sqw(file) * exp(hw/kT/2) on both sides */
        balance = Sqw_quantum_correction(w, Sqw->Temperature, Sqw->Q_correction);
      else if (!Sqw->sqw_classical) {  /* data is quantum (contains Bose) */
        if (sqw_full < 0) { /* quantum but mirrored/symmetric value (was missing in file) */
          if (T)
            /* prefer to use T computed from file for mirroring */
            balance *= exp(w/(T*Sqw->T2E));                /* apply Bose where missing */
          else if (Sqw->Temperature)
            balance *= exp(w/(Sqw->Temperature*Sqw->T2E)); /* apply Bose where missing */
        }
        /* test if T computed from file matches requested T, else apply correction */
        if (T && Sqw->Temperature > 0 && Sqw->Temperature != T) {
          balance *= exp(-w/(T*Sqw->T2E)/2);                /* make it a classical data set: remove computed/read T from quantum data file */
          balance *= exp( w/(Sqw->Temperature*Sqw->T2E)/2); /* then apply Bose to requested temperature */
        }
      }
      
      /* update Sqw value */
      sqw_full = fabs(sqw_full)*balance;
      Table_SetElement(&Sqw_full, index_q, index_w, sqw_full);
      /* sum up the S(q) (0-th moment) = w0 */
      sq       += sqw_full;
    } /* index_w */
    sq    *= w_step;         /* S(q)  = \int S(q,w) dw    = structure factor */
    iq2Sq += q*q*sq*q_step;  /* iq2Sq = \int q^2 S(q) dq  = used for g-sum rule (normalisation) */
    sum   += sq*q_step;      /* |S|   = \int S(q,w) dq dw = total integral value in file */
  } /* index_q */

  if (!sum) {
    MPI_MASTER(
    printf("Isotropic_Sqw: %s: No valid data in the selected (Q,w) range: sum(S)=0\n"
           "ERROR          Available Sqw data is\n",
      Sqw->compname);
    printf("                 q=[%g:%g] w=[%g:%g]\n",
           q_min_file, q_max_file,
           w_min_file, w_max_file);
    );
    Table_Free(&Sqw_full);
    return(NULL);
  }

  /* norm S(q ,w) = sum(S)*q_range/q_bins on total q,w range from file */
  sum *= (q_max_file - q_min_file)/q_bins_file;

  /* (7) renormalization of S(q,w) ========================================== */

  if      ( Sqw->sqw_norm >0) alpha=Sqw->sqw_norm;
  else if (!Sqw->sqw_norm)    alpha=1;

  if (!alpha && iq2Sq) { /* compute theoretical |S| norm */
    /* Eq (2.44) from H.E. Fischer et al, Rep. Prog. Phys., 69 (2006) 233 */
    alpha =
      (q_max*q_max*q_max/3 - (Sqw->type == 'c' ? 2*PI*PI*Sqw->mat_rho : 0))
      /iq2Sq;
  }

  if (alpha < 0) {
    MPI_MASTER(
    printf("Isotropic_Sqw: %s: normalisation factor is negative. rho=%g [Angs^-3] may be too high.\n"
           "WARNING        Disabling renormalization i.e. keeping initial S(q,w).\n",
      Sqw->compname, Sqw->mat_rho);
    );
    alpha=0;
  }

  /* apply normalization on S(q,w) */
  if (alpha && alpha != 1) {
    sum *= alpha;
    for (index_q=0; index_q < q_bins ; index_q++) {
      for (index_w=0; index_w < w_bins; index_w++)
        Table_SetElement(&Sqw_full, index_q, index_w,
          Table_Index(Sqw_full, index_q, index_w) * alpha);
    }
  }

  Sqw_Data->intensity       = sum;

  Table_Stat(&Sqw_full);
  Sqw_full.min_x        = 0;
  Sqw_full.max_x        = q_max;
  Sqw_full.step_x       = q_step;

  MPI_MASTER(
  if (Sqw->verbose_output > 0) {
    printf("Isotropic_Sqw: %s: Generated %s %scoherent Sqw\n"
           "                   q=[%g:%g Angs-1] w=[%g:%g meV] |S|=%g size=[%lix%li] sigma=%g [barns]\n",
           Sqw->compname, file, (Sqw->type == 'i' ? "in" : ""),
           q_min_file, q_max_file,
           w_min_file, w_max_file, Sqw_Data->intensity,
           q_bins, Sqw_Data->w_bins,
           (Sqw->type == 'i' ? Sqw->s_inc : Sqw->s_coh));
    if (w_max < 1e-2)
      printf("               Mainly elastic scattering.\n");
    if (Sqw->sqw_norm >0 && Sqw->sqw_norm != 1)
      printf("                   normalization factor S(q,w)*%g (user)\n", alpha);
    else if (Sqw->sqw_norm<0)
      printf("                   normalization factor S(q,w)*%g (auto) \\int q^2 S(q) dq=%g\n", alpha, iq2Sq);
  }
  );

  /* (8) Compute total cross section ======================================== */

  /* now compute the effective total cross section  (Sqw_integrate_iqSq)
        sigma(Ei) = sigma/2/Ki^2 * \int q S(q,w) dw dq
   * for each incoming neutron energy 0 < Ei < 2*w_max, and
   * integration range w=-Ei:w_max and q=Q0:Q1 with
   *   Q0 = SE2Q*(sqrt(E)-sqrt(E+w))
   *   Q1 = SE2Q*(sqrt(E)+sqrt(E+w))
   */

  Sqw_Data->lookup_length = Sqw->lookup_length;
  Sqw_Data->iqSq_length   = Sqw->lookup_length;
  /* this length should be greater when w_max=0 for e.g. elastic only */
  if (w_bins <= 1) Sqw_Data->iqSq_length = q_bins;

  if (!Table_Init(&iqSq, Sqw_Data->iqSq_length, 1)) {
    /* from 0 to 2*Ki_max */
    printf("Isotropic_Sqw: %s: Cannot allocate [int q S(q,w) dq dw] array (%li bytes).\n"
           "ERROR          Exiting.\n",
      Sqw->compname, Sqw->lookup_length*sizeof(double));
    Table_Free(&Sqw_full);
    return(NULL);
  }

  /* compute the maximum incoming energy that can be handled */
  Sqw_Data->Ei_max = 2*w_max;

  /* Checked in different ways in Powder and "proper inelastic" case */
  if (w_step==1) {
    /* Powder */
    double Ei_max_q = (q_max*K2V)*(q_max*K2V)*VS2E/2;
    if (Ei_max_q > Sqw_Data->Ei_max) Sqw_Data->Ei_max = Ei_max_q;
  } else {
    /* Proper inelastic */
    /* check if the q-range will limit the integration */
    if ((q_max*K2V)*(q_max*K2V)*VS2E/2 > Sqw_Data->Ei_max) {
      /* then scan Ei until we pass q_max */
      for (index_w=0; index_w < Sqw_Data->iqSq_length; index_w++) {
	double Ei = index_w*2*w_max/Sqw_Data->iqSq_length;
	if ( (Ei > w_max && sqrt(Ei)+sqrt(Ei-w_max) >= q_max/(SE2V*V2K))
	     || sqrt(Ei)+sqrt(Ei+w_max) >= q_max/(SE2V*V2K))
	  if (Ei < Sqw_Data->Ei_max) {
	    Sqw_Data->Ei_max = Ei;
	    break;
	  }
      }
    }
  }

  MPI_MASTER(
  if (Sqw->verbose_output >= 2)
    printf("Isotropic_Sqw: %s: Creating Sigma(Ei=0:%g [meV]) with %li entries...(%s %s)\n",
      Sqw->compname, Sqw_Data->Ei_max, Sqw_Data->iqSq_length, file, Sqw->type=='c' ? "coh" : "inc");
  );
  Sqw_Data->Sqw  = Sqw_full; /* store the S(q,w) Table (matrix) for Sqw_integrate_iqSq */

  /* this loop takes time: use MPI when available */

  for (index_w=0; index_w < Sqw_Data->iqSq_length; index_w++) {

    /* Ei = energy of incoming neutron, typically 0:w_max or 0:2*q_max */
    double Ei; /* neutron energy value in Sqw_full, up to 2*w_max */
    double Ki, Vi;
    double Sigma=0;
    Ei = index_w*Sqw_Data->Ei_max/Sqw_Data->iqSq_length;
    Vi = sqrt(Ei/VS2E);
    Ki = V2K*Vi;
    /* sigma(Ei) = sigma/2/Ki^2 * \int q S(q,w) dq dw */
    /* Eq (6) from E. Farhi et al. J. Comp. Phys. 228 (2009) 5251 */
    Sigma = Ki <= 0 ? 0 : (Sqw->type=='c' ? Sqw->s_coh : Sqw->s_inc)
                          /2/Ki/Ki * Sqw_integrate_iqSq(Sqw_Data, Ei);
    Table_SetElement(&iqSq, index_w, 0, Sigma );
  }

  sprintf(iqSq.filename, "[sigma/2Ki^2 int q S(q,w) dq dw] from %s", file);
  iqSq.min_x  = 0;
  iqSq.max_x  = Sqw_Data->Ei_max;
  iqSq.step_x = Sqw_Data->Ei_max/Sqw_Data->iqSq_length;
  iqSq.block_number = 1;

  Sqw_Data->iqSq = iqSq;     /* store the sigma(Ei) = \int q S(q,w) dq dw Table (vector) */

  /* (9) Compute P(w) probability =========================================== */

  /* set up 'density of states' */
  /* uses: Sqw_full and w axes */
  Sqw_Data->SW =
    (struct Sqw_W_struct*)calloc(w_bins, sizeof(struct Sqw_W_struct));

  if (!Sqw_Data->SW) {
    printf("Isotropic_Sqw: %s: Cannot allocate SW (%li bytes).\n"
           "ERROR          Exiting.\n",
      Sqw->compname, w_bins*sizeof(struct Sqw_W_struct));
    Table_Free(&Sqw_full);
    Table_Free(&iqSq);
    return(NULL);
  }
  sum = 0;
  for (index_w=0; index_w < w_bins ; index_w++) {
    double local_val = 0;
    double w         = -w_max + index_w * w_step;
    for (index_q=0; index_q < q_bins ; index_q++) { /* integrate on all q values */
      local_val += Table_Index(Sqw_full, index_q, index_w)*q_step*index_q*q_step; /* q*S(q,w) */
    }
    Sqw_Data->SW[index_w].omega = w;
    sum                  += local_val; /* S(w)=\int S(q,w) dq */
    /* compute cumulated probability */
    Sqw_Data->SW[index_w].cumul_proba = local_val;
    if (index_w) Sqw_Data->SW[index_w].cumul_proba += Sqw_Data->SW[index_w-1].cumul_proba;
    else         Sqw_Data->SW[index_w].cumul_proba = 0;
  }

  if (!sum) {
    MPI_MASTER(
    printf("Isotropic_Sqw: %s: Total S(q,w) intensity is NULL.\n"
           "ERROR          Exiting.\n", Sqw->compname);
    );
    Table_Free(&Sqw_full);
    Table_Free(&iqSq);
    return(NULL);
  }

  /* normalize Pw distribution to 0:1 range */
  for (index_w=0; index_w < w_bins ; index_w++) {
    Sqw_Data->SW[index_w].cumul_proba /= Sqw_Data->SW[w_bins-1].cumul_proba;
  }

  if (Sqw->verbose_output > 2) {
    MPI_MASTER(
    printf("Isotropic_Sqw: %s: Generated normalized SW[%li] in range [0:%g]\n",
      Sqw->compname, w_bins, Sqw_Data->SW[w_bins-1].cumul_proba);
    );
  }

  /* (10) Compute P(Q|w) probability ======================================== */

  /* set up Q probability table per w bin */
  /* uses:  Sqw_full */
  Sqw_Data->SQW =
    (struct Sqw_Q_struct**)calloc(w_bins, sizeof(struct Sqw_Q_struct*));

  if (!Sqw_Data->SQW) {
    printf("Isotropic_Sqw: %s: Cannot allocate P(Q|w) array (%li bytes).\n"
           "ERROR          Exiting.\n",
      Sqw->compname, w_bins*sizeof(struct Sqw_Q_struct*));
    Table_Free(&Sqw_full);
    Table_Free(&iqSq);
    return(NULL);
  }
  for (index_w=0; index_w < w_bins ; index_w++) {
    Sqw_Data->SQW[index_w]=
        (struct Sqw_Q_struct*)calloc(q_bins, sizeof(struct Sqw_Q_struct));

    if (!Sqw_Data->SQW[index_w]) {
      printf("Isotropic_Sqw: %s: Cannot allocate P(Q|w)[%li] (%li bytes).\n"
             "ERROR          Exiting.\n",
        Sqw->compname, index_w, q_bins*sizeof(struct Sqw_Q_struct));
      Table_Free(&Sqw_full);
      Table_Free(&iqSq);
      return(NULL);
    }
    /* set P(Q|W) and compute total intensity */
    for (index_q=0; index_q < q_bins ; index_q++) {
      double q  = index_q * q_step;
      Sqw_Data->SQW[index_w][index_q].Q     = q;

      /* compute cumulated probability and take into account Jacobian with additional 'q' factor */
      Sqw_Data->SQW[index_w][index_q].cumul_proba = q*Table_Index(Sqw_full, index_q, index_w); /* q*S(q,w) */
      if (index_q) Sqw_Data->SQW[index_w][index_q].cumul_proba += Sqw_Data->SQW[index_w][index_q-1].cumul_proba;
      else Sqw_Data->SQW[index_w][index_q].cumul_proba = 0;
    }
    /* normalize P(q|w) distribution to 0:1 range */
    for (index_q=0; index_q < q_bins ;
    	Sqw_Data->SQW[index_w][index_q++].cumul_proba /= Sqw_Data->SQW[index_w][q_bins-1].cumul_proba
    );

  }
  if (Sqw->verbose_output > 2) {
    MPI_MASTER(
    printf("Isotropic_Sqw: %s: Generated P(Q|w)\n",
      Sqw->compname);
    );
  }

  /* (11) generate quick lookup tables for SW and SQW ======================= */

  SW_lookup = (long*)calloc(Sqw->lookup_length, sizeof(long));

  if (!SW_lookup) {
    printf("Isotropic_Sqw: %s: Cannot allocate SW_lookup (%li bytes).\n"
           "Warning        Will be slower.\n",
      Sqw->compname, Sqw->lookup_length*sizeof(long));
  } else {
    int i;
    for (i=0; i < Sqw->lookup_length; i++) {
      double w = (double)i/(double)Sqw->lookup_length; /* a random number tabulated value */
      SW_lookup[i] = Sqw_search_SW(*Sqw_Data, w);
    }
    Sqw_Data->SW_lookup = SW_lookup;
  }
  QW_lookup = (long**)calloc(w_bins, sizeof(long*));

  if (!QW_lookup) {
    printf("Isotropic_Sqw: %s: Cannot allocate QW_lookup (%li bytes).\n"
           "Warning        Will be slower.\n",
      Sqw->compname, w_bins*sizeof(long*));
  } else {
    for (index_w=0; index_w < w_bins ; index_w++) {
      QW_lookup[index_w] =
        (long*)calloc(Sqw->lookup_length, sizeof(long));
      if (!QW_lookup[index_w]) {
        printf("Isotropic_Sqw: %s: Cannot allocate QW_lookup[%li] (%li bytes).\n"
               "Warning        Will be slower.\n",
        Sqw->compname, index_w, Sqw->lookup_length*sizeof(long));
        free(QW_lookup); Sqw_Data->QW_lookup = QW_lookup = NULL; break;
      } else {
        int i;
        for (i=0; i < Sqw->lookup_length; i++) {
          double w = (double)i/(double)Sqw->lookup_length; /* a random number tabulated value */
          QW_lookup[index_w][i] = Sqw_search_Q_proba_per_w(*Sqw_Data, w, index_w);
        }
      }
    }
    Sqw_Data->QW_lookup = QW_lookup;
  }
  if ((Sqw_Data->QW_lookup || Sqw_Data->SW_lookup) && Sqw->verbose_output > 2) {
    MPI_MASTER(
    printf("Isotropic_Sqw: %s: Generated lookup tables with %li entries\n",
      Sqw->compname, Sqw->lookup_length);
    );
  }

  return(Sqw_Data);
} /* end Sqw_readfile */

/*****************************************************************************
* Sqw_init_read: Read coherent/incoherent Sqw data files
*   Returns Sqw total intensity, or 0 (error)
* Used in : INITIALIZE (1)
*****************************************************************************/
double Sqw_init(struct Sqw_sample_struct *Sqw, char *file_coh, char *file_inc)
{
  double ret=0;

  /* read files */
  struct Sqw_Data_struct *d_inc, *d_coh;
  Sqw->type = 'i';
  d_inc = Sqw_readfile(Sqw, file_inc, &(Sqw->Data_inc));
  Sqw->type = 'c';
  d_coh = Sqw_readfile(Sqw, file_coh, &(Sqw->Data_coh));

  if (d_inc && !d_inc->intensity && Sqw->s_inc>0) {
    MPI_MASTER(
    if (Sqw->verbose_output > 0)
      printf("Isotropic_Sqw: %s: Using Isotropic elastic incoherent scattering (sigma=%g [barns])\n", Sqw->compname, Sqw->s_inc);
    );
    ret=1;
  }

  if (!d_inc || !d_coh) return(0);

  d_coh->type = 'c';
  Sqw->Data_inc.type = 'i';
  MPI_MASTER(
  if (d_coh && !d_coh->intensity && Sqw->s_coh)
    printf("Isotropic_Sqw: %s: Coherent scattering Sqw intensity is null.\n"
           "Warning        Disabling coherent scattering.\n", Sqw->compname);
  );
  if (d_inc && d_coh && d_inc->intensity && d_coh->intensity) {
    char msg[80];
    strcpy(msg, "");
    /* check dimensions/limits for Q, Energy in coh and inc Tables */
    if (d_inc->q_bins  != d_coh->q_bins)
      strcpy(msg, "Q axis size");
    if (d_inc->w_bins  != d_coh->w_bins)
      strcpy(msg, "Energy axis size");
    if (d_inc->q_max != d_coh->q_max)
      strcpy(msg, "Q axis limits");
    if (d_inc->w_max != d_coh->w_max)
      strcpy(msg, "Energy axis limits");
    MPI_MASTER(
    if (strlen(msg)) {
      printf("Isotropic_Sqw: %s: Sqw data from files %s and %s do not match\n"
             "WARNING        wrong %s\n",
             Sqw->compname, file_coh, file_inc, msg);
    }
    );
  }

  if (!ret) ret=d_inc->intensity+d_coh->intensity;
  return(ret);
} /* Sqw_init */

#endif /* definied ISOTROPIC_SQW */
#line 11895 "./SNS_BASIS.c"

/* Shared user declarations for all components 'Spherical_Backscattering_Analyser'. */
#line 46 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Spherical_Backscattering_Analyser.comp"
  double z_sphere(double xin, double yin, double rin) {
    return -(rin - sqrt(rin*rin - xin*xin - yin*yin));
  }

#line 11903 "./SNS_BASIS.c"

/* Instrument parameters. */
MCNUM mcipLam;
MCNUM mcipLambda_min;
MCNUM mcipLambda_max;
MCNUM mcipRadCurv;
MCNUM mcipomega1;
MCNUM mcipomega2;
MCNUM mcipomega3;
MCNUM mcipch1_open;
MCNUM mcipch2_open;
MCNUM mcipch3_open;
MCNUM mcipROT1;
MCNUM mcipAN_ROT;
MCNUM mcipTOTAL_LENGTH;
MCNUM mcipdROT;

#define mcNUMIPAR 14
int mcnumipar = 14;
struct mcinputtable_struct mcinputtable[mcNUMIPAR+1] = {
  "Lam", &mcipLam, instr_type_double, "6.4", 
  "Lambda_min", &mcipLambda_min, instr_type_double, "5", 
  "Lambda_max", &mcipLambda_max, instr_type_double, "7", 
  "RadCurv", &mcipRadCurv, instr_type_double, "1000", 
  "omega1", &mcipomega1, instr_type_double, "60", 
  "omega2", &mcipomega2, instr_type_double, "60", 
  "omega3", &mcipomega3, instr_type_double, "60", 
  "ch1_open", &mcipch1_open, instr_type_double, "51.4", 
  "ch2_open", &mcipch2_open, instr_type_double, "57.6", 
  "ch3_open", &mcipch3_open, instr_type_double, "171.1", 
  "ROT1", &mcipROT1, instr_type_double, "90", 
  "AN_ROT", &mcipAN_ROT, instr_type_double, "2", 
  "TOTAL_LENGTH", &mcipTOTAL_LENGTH, instr_type_double, "84", 
  "dROT", &mcipdROT, instr_type_double, "11", 
  NULL, NULL, instr_type_double, ""
};

/* User declarations from instrument definition. */
#define mccompcurname  SNS_BASIS
#define mccompcurtype  INSTRUMENT
#define mccompcurindex 0
#define mcposaSNS_BASIS coords_set(0,0,0)
#define Lam mcipLam
#define Lambda_min mcipLambda_min
#define Lambda_max mcipLambda_max
#define RadCurv mcipRadCurv
#define omega1 mcipomega1
#define omega2 mcipomega2
#define omega3 mcipomega3
#define ch1_open mcipch1_open
#define ch2_open mcipch2_open
#define ch3_open mcipch3_open
#define ROT1 mcipROT1
#define AN_ROT mcipAN_ROT
#define TOTAL_LENGTH mcipTOTAL_LENGTH
#define dROT mcipdROT
#line 82 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  double Omega1,Omega2,Omega3;
  double TOTAL_LENGTH;
  double Guide_extension; 
  double E_min; 
  double E_max;
  double SGS3;
  double End_Guide;
  double Analyser;
  double Detector1;
  double  q_si111=2.003886241;
  char myfilename_1 [128];
  char myfilename_2 [128];
  char myfilename_3 [128];
  char myfilename_4 [128];
  char myfilename_5 [128];
  char myfilename_6 [128];
  char myfilename_7 [128];
  char myfilename_8 [128];
  char myfilename_9 [128];
  char myfilename_10 [128];
  char myfilename_11 [128];
  char myfilename_12 [128];
  char myfilename_13 [128];
  char myfilename_14 [128];
  char myfilename_15 [128];
  char myfilename_16 [128];
  char myfilename_17 [128];
  char myfilename_18 [128];
  char myfilename_19 [128];
 
  // Variable to help classify hits from different analyzer crystals
  int groupNumber = 0;
  
  // Flags for absorbtion of unwanted events
  int hitSample;
  int hitAnalyzer;
  
  // Parameters to control neutron propagation and label neutrons
  int flag_analyser_scatt;
  
  // Si111 analyser specifications
  double an_x_min=-0.2325;
  double an_x_max=0.2325;
  double an_y_min=-0.49;
  double an_y_max=0.49;
  double analyser_focus_dist=1.2;
  
  // Graphite ANALYZER SECTION PARAMETERS
  const double anaRadius     = 0.9068; // m
  const double anaHeight     = 0.01; // m
  const double anaWidth      = 0.01; // m
  // We scale the mosaicity to take into account the d-spacing resolution!
  /*   const double anaMosaicH    = 2.41*0.8*60; // arc minutes  */
  /*   const double anaMosaicV    = 2.41*0.8*60; // arc minutes */
  const double anaMosaicH    = 0.8*60; // arc minutes 
  const double anaMosaicV    = 0.8*60; // arc minutes
  //  const double anad          = 3.354; // 
  const double anaQ          = 2*PI/3.354; // AA-1
  
  
  double dist_sample_detector=0.2;
  double myt,myx,myy;

#line 12024 "./SNS_BASIS.c"
#undef dROT
#undef TOTAL_LENGTH
#undef AN_ROT
#undef ROT1
#undef ch3_open
#undef ch2_open
#undef ch1_open
#undef omega3
#undef omega2
#undef omega1
#undef RadCurv
#undef Lambda_max
#undef Lambda_min
#undef Lam
#undef mcposaSNS_BASIS
#undef mccompcurindex
#undef mccompcurtype
#undef mccompcurname

/* neutron state table at each component input (local coords) */
/* [x, y, z, vx, vy, vz, t, sx, sy, sz, p] */
MCNUM mccomp_storein[11*147];
/* Components position table (absolute and relative coords) */
Coords mccomp_posa[147];
Coords mccomp_posr[147];
/* Counter for each comp to check for inactive ones */
MCNUM  mcNCounter[147];
MCNUM  mcPCounter[147];
MCNUM  mcP2Counter[147];
#define mcNUMCOMP 146 /* number of components */
/* Counter for PROP ABSORB */
MCNUM  mcAbsorbProp[147];
/* Flag true when previous component acted on the neutron (SCATTER) */
MCNUM mcScattered=0;
/* Flag true when neutron should be restored (RESTORE) */
MCNUM mcRestore=0;
/* Component group definitions (flags), equals index of scattering comp */
int mcGroupANALYZERS=0;
/* Declarations of component definition and setting parameters. */

/* Setting parameters for component 'Origin' [1]. */
char mccOrigin_profile[16384];
MCNUM mccOrigin_percent;
MCNUM mccOrigin_flag_save;
MCNUM mccOrigin_minutes;

/* Setting parameters for component 'Source' [2]. */
MCNUM mccSource_size;
MCNUM mccSource_Lmin;
MCNUM mccSource_Lmax;
MCNUM mccSource_dist;
MCNUM mccSource_focus_xw;
MCNUM mccSource_focus_yh;
MCNUM mccSource_nu;
MCNUM mccSource_T;
MCNUM mccSource_tau;
MCNUM mccSource_tau1;
MCNUM mccSource_tau2;
MCNUM mccSource_n;
MCNUM mccSource_n2;
MCNUM mccSource_chi2;
MCNUM mccSource_I0;
MCNUM mccSource_I2;
MCNUM mccSource_branch1;
MCNUM mccSource_branch2;
MCNUM mccSource_branchframe;
int mccSource_target_index;

/* Definition parameters for component 'tofSTART' [3]. */
#define mcctofSTART_nt 1000
/* Setting parameters for component 'tofSTART' [3]. */
char mcctofSTART_filename[16384];
MCNUM mcctofSTART_xmin;
MCNUM mcctofSTART_xmax;
MCNUM mcctofSTART_ymin;
MCNUM mcctofSTART_ymax;
MCNUM mcctofSTART_xwidth;
MCNUM mcctofSTART_yheight;
MCNUM mcctofSTART_tmin;
MCNUM mcctofSTART_tmax;
MCNUM mcctofSTART_dt;
MCNUM mcctofSTART_restore_neutron;
int mcctofSTART_nowritefile;

/* Definition parameters for component 'Source_Lam' [4]. */
#define mccSource_Lam_nL 1000
/* Setting parameters for component 'Source_Lam' [4]. */
char mccSource_Lam_filename[16384];
MCNUM mccSource_Lam_xmin;
MCNUM mccSource_Lam_xmax;
MCNUM mccSource_Lam_ymin;
MCNUM mccSource_Lam_ymax;
MCNUM mccSource_Lam_xwidth;
MCNUM mccSource_Lam_yheight;
MCNUM mccSource_Lam_Lmin;
MCNUM mccSource_Lam_Lmax;
MCNUM mccSource_Lam_restore_neutron;
int mccSource_Lam_nowritefile;

/* Definition parameters for component 'Source_En' [5]. */
#define mccSource_En_nE 1000
/* Setting parameters for component 'Source_En' [5]. */
char mccSource_En_filename[16384];
MCNUM mccSource_En_xmin;
MCNUM mccSource_En_xmax;
MCNUM mccSource_En_ymin;
MCNUM mccSource_En_ymax;
MCNUM mccSource_En_xwidth;
MCNUM mccSource_En_yheight;
MCNUM mccSource_En_Emin;
MCNUM mccSource_En_Emax;
MCNUM mccSource_En_restore_neutron;
int mccSource_En_nowritefile;

/* Setting parameters for component 'Gap0_start' [6]. */
int mccGap0_start_nx;
int mccGap0_start_ny;
char mccGap0_start_filename[16384];
MCNUM mccGap0_start_xmin;
MCNUM mccGap0_start_xmax;
MCNUM mccGap0_start_ymin;
MCNUM mccGap0_start_ymax;
MCNUM mccGap0_start_xwidth;
MCNUM mccGap0_start_yheight;
MCNUM mccGap0_start_restore_neutron;

/* Definition parameters for component 'Gap0_end_Lam' [7]. */
#define mccGap0_end_Lam_nL 1000
/* Setting parameters for component 'Gap0_end_Lam' [7]. */
char mccGap0_end_Lam_filename[16384];
MCNUM mccGap0_end_Lam_xmin;
MCNUM mccGap0_end_Lam_xmax;
MCNUM mccGap0_end_Lam_ymin;
MCNUM mccGap0_end_Lam_ymax;
MCNUM mccGap0_end_Lam_xwidth;
MCNUM mccGap0_end_Lam_yheight;
MCNUM mccGap0_end_Lam_Lmin;
MCNUM mccGap0_end_Lam_Lmax;
MCNUM mccGap0_end_Lam_restore_neutron;
int mccGap0_end_Lam_nowritefile;

/* Definition parameters for component 'Gap0_end_divx' [8]. */
#define mccGap0_end_divx_user1 FLT_MAX
#define mccGap0_end_divx_user2 FLT_MAX
#define mccGap0_end_divx_user3 FLT_MAX
/* Setting parameters for component 'Gap0_end_divx' [8]. */
MCNUM mccGap0_end_divx_xwidth;
MCNUM mccGap0_end_divx_yheight;
MCNUM mccGap0_end_divx_zdepth;
MCNUM mccGap0_end_divx_xmin;
MCNUM mccGap0_end_divx_xmax;
MCNUM mccGap0_end_divx_ymin;
MCNUM mccGap0_end_divx_ymax;
MCNUM mccGap0_end_divx_zmin;
MCNUM mccGap0_end_divx_zmax;
MCNUM mccGap0_end_divx_bins;
MCNUM mccGap0_end_divx_min;
MCNUM mccGap0_end_divx_max;
MCNUM mccGap0_end_divx_restore_neutron;
MCNUM mccGap0_end_divx_radius;
char mccGap0_end_divx_options[16384];
char mccGap0_end_divx_filename[16384];
char mccGap0_end_divx_geometry[16384];
char mccGap0_end_divx_username1[16384];
char mccGap0_end_divx_username2[16384];
char mccGap0_end_divx_username3[16384];
int mccGap0_end_divx_nowritefile;

/* Definition parameters for component 'Gap0_end_divy' [9]. */
#define mccGap0_end_divy_user1 FLT_MAX
#define mccGap0_end_divy_user2 FLT_MAX
#define mccGap0_end_divy_user3 FLT_MAX
/* Setting parameters for component 'Gap0_end_divy' [9]. */
MCNUM mccGap0_end_divy_xwidth;
MCNUM mccGap0_end_divy_yheight;
MCNUM mccGap0_end_divy_zdepth;
MCNUM mccGap0_end_divy_xmin;
MCNUM mccGap0_end_divy_xmax;
MCNUM mccGap0_end_divy_ymin;
MCNUM mccGap0_end_divy_ymax;
MCNUM mccGap0_end_divy_zmin;
MCNUM mccGap0_end_divy_zmax;
MCNUM mccGap0_end_divy_bins;
MCNUM mccGap0_end_divy_min;
MCNUM mccGap0_end_divy_max;
MCNUM mccGap0_end_divy_restore_neutron;
MCNUM mccGap0_end_divy_radius;
char mccGap0_end_divy_options[16384];
char mccGap0_end_divy_filename[16384];
char mccGap0_end_divy_geometry[16384];
char mccGap0_end_divy_username1[16384];
char mccGap0_end_divy_username2[16384];
char mccGap0_end_divy_username3[16384];
int mccGap0_end_divy_nowritefile;

/* Setting parameters for component 'Core_Vessel_Section' [10]. */
char mccCore_Vessel_Section_reflect[16384];
MCNUM mccCore_Vessel_Section_w1;
MCNUM mccCore_Vessel_Section_h1;
MCNUM mccCore_Vessel_Section_w2;
MCNUM mccCore_Vessel_Section_h2;
MCNUM mccCore_Vessel_Section_l;
MCNUM mccCore_Vessel_Section_R0;
MCNUM mccCore_Vessel_Section_Qc;
MCNUM mccCore_Vessel_Section_alpha;
MCNUM mccCore_Vessel_Section_m;
MCNUM mccCore_Vessel_Section_W;

/* Definition parameters for component 'Gap1_start_Lam' [12]. */
#define mccGap1_start_Lam_nL 1000
/* Setting parameters for component 'Gap1_start_Lam' [12]. */
char mccGap1_start_Lam_filename[16384];
MCNUM mccGap1_start_Lam_xmin;
MCNUM mccGap1_start_Lam_xmax;
MCNUM mccGap1_start_Lam_ymin;
MCNUM mccGap1_start_Lam_ymax;
MCNUM mccGap1_start_Lam_xwidth;
MCNUM mccGap1_start_Lam_yheight;
MCNUM mccGap1_start_Lam_Lmin;
MCNUM mccGap1_start_Lam_Lmax;
MCNUM mccGap1_start_Lam_restore_neutron;
int mccGap1_start_Lam_nowritefile;

/* Definition parameters for component 'Gap1_end_Lam' [13]. */
#define mccGap1_end_Lam_nL 1000
/* Setting parameters for component 'Gap1_end_Lam' [13]. */
char mccGap1_end_Lam_filename[16384];
MCNUM mccGap1_end_Lam_xmin;
MCNUM mccGap1_end_Lam_xmax;
MCNUM mccGap1_end_Lam_ymin;
MCNUM mccGap1_end_Lam_ymax;
MCNUM mccGap1_end_Lam_xwidth;
MCNUM mccGap1_end_Lam_yheight;
MCNUM mccGap1_end_Lam_Lmin;
MCNUM mccGap1_end_Lam_Lmax;
MCNUM mccGap1_end_Lam_restore_neutron;
int mccGap1_end_Lam_nowritefile;

/* Setting parameters for component 'Shutter_Guide_Insert' [15]. */
MCNUM mccShutter_Guide_Insert_w1;
MCNUM mccShutter_Guide_Insert_h1;
MCNUM mccShutter_Guide_Insert_w2;
MCNUM mccShutter_Guide_Insert_h2;
MCNUM mccShutter_Guide_Insert_l;
MCNUM mccShutter_Guide_Insert_R0;
MCNUM mccShutter_Guide_Insert_Qc;
MCNUM mccShutter_Guide_Insert_alpha;
MCNUM mccShutter_Guide_Insert_m;
MCNUM mccShutter_Guide_Insert_W;
MCNUM mccShutter_Guide_Insert_nslit;
MCNUM mccShutter_Guide_Insert_d;
MCNUM mccShutter_Guide_Insert_mleft;
MCNUM mccShutter_Guide_Insert_mright;
MCNUM mccShutter_Guide_Insert_mtop;
MCNUM mccShutter_Guide_Insert_mbottom;
MCNUM mccShutter_Guide_Insert_nhslit;
MCNUM mccShutter_Guide_Insert_G;
MCNUM mccShutter_Guide_Insert_aleft;
MCNUM mccShutter_Guide_Insert_aright;
MCNUM mccShutter_Guide_Insert_atop;
MCNUM mccShutter_Guide_Insert_abottom;
MCNUM mccShutter_Guide_Insert_wavy;
MCNUM mccShutter_Guide_Insert_wavy_z;
MCNUM mccShutter_Guide_Insert_wavy_tb;
MCNUM mccShutter_Guide_Insert_wavy_lr;
MCNUM mccShutter_Guide_Insert_chamfers;
MCNUM mccShutter_Guide_Insert_chamfers_z;
MCNUM mccShutter_Guide_Insert_chamfers_lr;
MCNUM mccShutter_Guide_Insert_chamfers_tb;
MCNUM mccShutter_Guide_Insert_nelements;
MCNUM mccShutter_Guide_Insert_nu;
MCNUM mccShutter_Guide_Insert_phase;
char mccShutter_Guide_Insert_reflect[16384];

/* Setting parameters for component 'Shutter_Guide_Insert_16' [16]. */
MCNUM mccShutter_Guide_Insert_16_w1;
MCNUM mccShutter_Guide_Insert_16_h1;
MCNUM mccShutter_Guide_Insert_16_w2;
MCNUM mccShutter_Guide_Insert_16_h2;
MCNUM mccShutter_Guide_Insert_16_l;
MCNUM mccShutter_Guide_Insert_16_R0;
MCNUM mccShutter_Guide_Insert_16_Qc;
MCNUM mccShutter_Guide_Insert_16_alpha;
MCNUM mccShutter_Guide_Insert_16_m;
MCNUM mccShutter_Guide_Insert_16_W;
MCNUM mccShutter_Guide_Insert_16_nslit;
MCNUM mccShutter_Guide_Insert_16_d;
MCNUM mccShutter_Guide_Insert_16_mleft;
MCNUM mccShutter_Guide_Insert_16_mright;
MCNUM mccShutter_Guide_Insert_16_mtop;
MCNUM mccShutter_Guide_Insert_16_mbottom;
MCNUM mccShutter_Guide_Insert_16_nhslit;
MCNUM mccShutter_Guide_Insert_16_G;
MCNUM mccShutter_Guide_Insert_16_aleft;
MCNUM mccShutter_Guide_Insert_16_aright;
MCNUM mccShutter_Guide_Insert_16_atop;
MCNUM mccShutter_Guide_Insert_16_abottom;
MCNUM mccShutter_Guide_Insert_16_wavy;
MCNUM mccShutter_Guide_Insert_16_wavy_z;
MCNUM mccShutter_Guide_Insert_16_wavy_tb;
MCNUM mccShutter_Guide_Insert_16_wavy_lr;
MCNUM mccShutter_Guide_Insert_16_chamfers;
MCNUM mccShutter_Guide_Insert_16_chamfers_z;
MCNUM mccShutter_Guide_Insert_16_chamfers_lr;
MCNUM mccShutter_Guide_Insert_16_chamfers_tb;
MCNUM mccShutter_Guide_Insert_16_nelements;
MCNUM mccShutter_Guide_Insert_16_nu;
MCNUM mccShutter_Guide_Insert_16_phase;
char mccShutter_Guide_Insert_16_reflect[16384];

/* Setting parameters for component 'Shutter_Guide_Insert_17' [17]. */
MCNUM mccShutter_Guide_Insert_17_w1;
MCNUM mccShutter_Guide_Insert_17_h1;
MCNUM mccShutter_Guide_Insert_17_w2;
MCNUM mccShutter_Guide_Insert_17_h2;
MCNUM mccShutter_Guide_Insert_17_l;
MCNUM mccShutter_Guide_Insert_17_R0;
MCNUM mccShutter_Guide_Insert_17_Qc;
MCNUM mccShutter_Guide_Insert_17_alpha;
MCNUM mccShutter_Guide_Insert_17_m;
MCNUM mccShutter_Guide_Insert_17_W;
MCNUM mccShutter_Guide_Insert_17_nslit;
MCNUM mccShutter_Guide_Insert_17_d;
MCNUM mccShutter_Guide_Insert_17_mleft;
MCNUM mccShutter_Guide_Insert_17_mright;
MCNUM mccShutter_Guide_Insert_17_mtop;
MCNUM mccShutter_Guide_Insert_17_mbottom;
MCNUM mccShutter_Guide_Insert_17_nhslit;
MCNUM mccShutter_Guide_Insert_17_G;
MCNUM mccShutter_Guide_Insert_17_aleft;
MCNUM mccShutter_Guide_Insert_17_aright;
MCNUM mccShutter_Guide_Insert_17_atop;
MCNUM mccShutter_Guide_Insert_17_abottom;
MCNUM mccShutter_Guide_Insert_17_wavy;
MCNUM mccShutter_Guide_Insert_17_wavy_z;
MCNUM mccShutter_Guide_Insert_17_wavy_tb;
MCNUM mccShutter_Guide_Insert_17_wavy_lr;
MCNUM mccShutter_Guide_Insert_17_chamfers;
MCNUM mccShutter_Guide_Insert_17_chamfers_z;
MCNUM mccShutter_Guide_Insert_17_chamfers_lr;
MCNUM mccShutter_Guide_Insert_17_chamfers_tb;
MCNUM mccShutter_Guide_Insert_17_nelements;
MCNUM mccShutter_Guide_Insert_17_nu;
MCNUM mccShutter_Guide_Insert_17_phase;
char mccShutter_Guide_Insert_17_reflect[16384];

/* Setting parameters for component 'Shutter_Guide_Insert_18' [18]. */
MCNUM mccShutter_Guide_Insert_18_w1;
MCNUM mccShutter_Guide_Insert_18_h1;
MCNUM mccShutter_Guide_Insert_18_w2;
MCNUM mccShutter_Guide_Insert_18_h2;
MCNUM mccShutter_Guide_Insert_18_l;
MCNUM mccShutter_Guide_Insert_18_R0;
MCNUM mccShutter_Guide_Insert_18_Qc;
MCNUM mccShutter_Guide_Insert_18_alpha;
MCNUM mccShutter_Guide_Insert_18_m;
MCNUM mccShutter_Guide_Insert_18_W;
MCNUM mccShutter_Guide_Insert_18_nslit;
MCNUM mccShutter_Guide_Insert_18_d;
MCNUM mccShutter_Guide_Insert_18_mleft;
MCNUM mccShutter_Guide_Insert_18_mright;
MCNUM mccShutter_Guide_Insert_18_mtop;
MCNUM mccShutter_Guide_Insert_18_mbottom;
MCNUM mccShutter_Guide_Insert_18_nhslit;
MCNUM mccShutter_Guide_Insert_18_G;
MCNUM mccShutter_Guide_Insert_18_aleft;
MCNUM mccShutter_Guide_Insert_18_aright;
MCNUM mccShutter_Guide_Insert_18_atop;
MCNUM mccShutter_Guide_Insert_18_abottom;
MCNUM mccShutter_Guide_Insert_18_wavy;
MCNUM mccShutter_Guide_Insert_18_wavy_z;
MCNUM mccShutter_Guide_Insert_18_wavy_tb;
MCNUM mccShutter_Guide_Insert_18_wavy_lr;
MCNUM mccShutter_Guide_Insert_18_chamfers;
MCNUM mccShutter_Guide_Insert_18_chamfers_z;
MCNUM mccShutter_Guide_Insert_18_chamfers_lr;
MCNUM mccShutter_Guide_Insert_18_chamfers_tb;
MCNUM mccShutter_Guide_Insert_18_nelements;
MCNUM mccShutter_Guide_Insert_18_nu;
MCNUM mccShutter_Guide_Insert_18_phase;
char mccShutter_Guide_Insert_18_reflect[16384];

/* Setting parameters for component 'Shutter_Guide_Insert_19' [19]. */
MCNUM mccShutter_Guide_Insert_19_w1;
MCNUM mccShutter_Guide_Insert_19_h1;
MCNUM mccShutter_Guide_Insert_19_w2;
MCNUM mccShutter_Guide_Insert_19_h2;
MCNUM mccShutter_Guide_Insert_19_l;
MCNUM mccShutter_Guide_Insert_19_R0;
MCNUM mccShutter_Guide_Insert_19_Qc;
MCNUM mccShutter_Guide_Insert_19_alpha;
MCNUM mccShutter_Guide_Insert_19_m;
MCNUM mccShutter_Guide_Insert_19_W;
MCNUM mccShutter_Guide_Insert_19_nslit;
MCNUM mccShutter_Guide_Insert_19_d;
MCNUM mccShutter_Guide_Insert_19_mleft;
MCNUM mccShutter_Guide_Insert_19_mright;
MCNUM mccShutter_Guide_Insert_19_mtop;
MCNUM mccShutter_Guide_Insert_19_mbottom;
MCNUM mccShutter_Guide_Insert_19_nhslit;
MCNUM mccShutter_Guide_Insert_19_G;
MCNUM mccShutter_Guide_Insert_19_aleft;
MCNUM mccShutter_Guide_Insert_19_aright;
MCNUM mccShutter_Guide_Insert_19_atop;
MCNUM mccShutter_Guide_Insert_19_abottom;
MCNUM mccShutter_Guide_Insert_19_wavy;
MCNUM mccShutter_Guide_Insert_19_wavy_z;
MCNUM mccShutter_Guide_Insert_19_wavy_tb;
MCNUM mccShutter_Guide_Insert_19_wavy_lr;
MCNUM mccShutter_Guide_Insert_19_chamfers;
MCNUM mccShutter_Guide_Insert_19_chamfers_z;
MCNUM mccShutter_Guide_Insert_19_chamfers_lr;
MCNUM mccShutter_Guide_Insert_19_chamfers_tb;
MCNUM mccShutter_Guide_Insert_19_nelements;
MCNUM mccShutter_Guide_Insert_19_nu;
MCNUM mccShutter_Guide_Insert_19_phase;
char mccShutter_Guide_Insert_19_reflect[16384];

/* Setting parameters for component 'Shutter_Guide_Insert_20' [20]. */
MCNUM mccShutter_Guide_Insert_20_w1;
MCNUM mccShutter_Guide_Insert_20_h1;
MCNUM mccShutter_Guide_Insert_20_w2;
MCNUM mccShutter_Guide_Insert_20_h2;
MCNUM mccShutter_Guide_Insert_20_l;
MCNUM mccShutter_Guide_Insert_20_R0;
MCNUM mccShutter_Guide_Insert_20_Qc;
MCNUM mccShutter_Guide_Insert_20_alpha;
MCNUM mccShutter_Guide_Insert_20_m;
MCNUM mccShutter_Guide_Insert_20_W;
MCNUM mccShutter_Guide_Insert_20_nslit;
MCNUM mccShutter_Guide_Insert_20_d;
MCNUM mccShutter_Guide_Insert_20_mleft;
MCNUM mccShutter_Guide_Insert_20_mright;
MCNUM mccShutter_Guide_Insert_20_mtop;
MCNUM mccShutter_Guide_Insert_20_mbottom;
MCNUM mccShutter_Guide_Insert_20_nhslit;
MCNUM mccShutter_Guide_Insert_20_G;
MCNUM mccShutter_Guide_Insert_20_aleft;
MCNUM mccShutter_Guide_Insert_20_aright;
MCNUM mccShutter_Guide_Insert_20_atop;
MCNUM mccShutter_Guide_Insert_20_abottom;
MCNUM mccShutter_Guide_Insert_20_wavy;
MCNUM mccShutter_Guide_Insert_20_wavy_z;
MCNUM mccShutter_Guide_Insert_20_wavy_tb;
MCNUM mccShutter_Guide_Insert_20_wavy_lr;
MCNUM mccShutter_Guide_Insert_20_chamfers;
MCNUM mccShutter_Guide_Insert_20_chamfers_z;
MCNUM mccShutter_Guide_Insert_20_chamfers_lr;
MCNUM mccShutter_Guide_Insert_20_chamfers_tb;
MCNUM mccShutter_Guide_Insert_20_nelements;
MCNUM mccShutter_Guide_Insert_20_nu;
MCNUM mccShutter_Guide_Insert_20_phase;
char mccShutter_Guide_Insert_20_reflect[16384];

/* Setting parameters for component 'Shutter_Guide_Insert_21' [21]. */
MCNUM mccShutter_Guide_Insert_21_w1;
MCNUM mccShutter_Guide_Insert_21_h1;
MCNUM mccShutter_Guide_Insert_21_w2;
MCNUM mccShutter_Guide_Insert_21_h2;
MCNUM mccShutter_Guide_Insert_21_l;
MCNUM mccShutter_Guide_Insert_21_R0;
MCNUM mccShutter_Guide_Insert_21_Qc;
MCNUM mccShutter_Guide_Insert_21_alpha;
MCNUM mccShutter_Guide_Insert_21_m;
MCNUM mccShutter_Guide_Insert_21_W;
MCNUM mccShutter_Guide_Insert_21_nslit;
MCNUM mccShutter_Guide_Insert_21_d;
MCNUM mccShutter_Guide_Insert_21_mleft;
MCNUM mccShutter_Guide_Insert_21_mright;
MCNUM mccShutter_Guide_Insert_21_mtop;
MCNUM mccShutter_Guide_Insert_21_mbottom;
MCNUM mccShutter_Guide_Insert_21_nhslit;
MCNUM mccShutter_Guide_Insert_21_G;
MCNUM mccShutter_Guide_Insert_21_aleft;
MCNUM mccShutter_Guide_Insert_21_aright;
MCNUM mccShutter_Guide_Insert_21_atop;
MCNUM mccShutter_Guide_Insert_21_abottom;
MCNUM mccShutter_Guide_Insert_21_wavy;
MCNUM mccShutter_Guide_Insert_21_wavy_z;
MCNUM mccShutter_Guide_Insert_21_wavy_tb;
MCNUM mccShutter_Guide_Insert_21_wavy_lr;
MCNUM mccShutter_Guide_Insert_21_chamfers;
MCNUM mccShutter_Guide_Insert_21_chamfers_z;
MCNUM mccShutter_Guide_Insert_21_chamfers_lr;
MCNUM mccShutter_Guide_Insert_21_chamfers_tb;
MCNUM mccShutter_Guide_Insert_21_nelements;
MCNUM mccShutter_Guide_Insert_21_nu;
MCNUM mccShutter_Guide_Insert_21_phase;
char mccShutter_Guide_Insert_21_reflect[16384];

/* Setting parameters for component 'Shutter_Guide_Insert_short' [22]. */
MCNUM mccShutter_Guide_Insert_short_w1;
MCNUM mccShutter_Guide_Insert_short_h1;
MCNUM mccShutter_Guide_Insert_short_w2;
MCNUM mccShutter_Guide_Insert_short_h2;
MCNUM mccShutter_Guide_Insert_short_l;
MCNUM mccShutter_Guide_Insert_short_R0;
MCNUM mccShutter_Guide_Insert_short_Qc;
MCNUM mccShutter_Guide_Insert_short_alpha;
MCNUM mccShutter_Guide_Insert_short_m;
MCNUM mccShutter_Guide_Insert_short_W;
MCNUM mccShutter_Guide_Insert_short_nslit;
MCNUM mccShutter_Guide_Insert_short_d;
MCNUM mccShutter_Guide_Insert_short_mleft;
MCNUM mccShutter_Guide_Insert_short_mright;
MCNUM mccShutter_Guide_Insert_short_mtop;
MCNUM mccShutter_Guide_Insert_short_mbottom;
MCNUM mccShutter_Guide_Insert_short_nhslit;
MCNUM mccShutter_Guide_Insert_short_G;
MCNUM mccShutter_Guide_Insert_short_aleft;
MCNUM mccShutter_Guide_Insert_short_aright;
MCNUM mccShutter_Guide_Insert_short_atop;
MCNUM mccShutter_Guide_Insert_short_abottom;
MCNUM mccShutter_Guide_Insert_short_wavy;
MCNUM mccShutter_Guide_Insert_short_wavy_z;
MCNUM mccShutter_Guide_Insert_short_wavy_tb;
MCNUM mccShutter_Guide_Insert_short_wavy_lr;
MCNUM mccShutter_Guide_Insert_short_chamfers;
MCNUM mccShutter_Guide_Insert_short_chamfers_z;
MCNUM mccShutter_Guide_Insert_short_chamfers_lr;
MCNUM mccShutter_Guide_Insert_short_chamfers_tb;
MCNUM mccShutter_Guide_Insert_short_nelements;
MCNUM mccShutter_Guide_Insert_short_nu;
MCNUM mccShutter_Guide_Insert_short_phase;
char mccShutter_Guide_Insert_short_reflect[16384];

/* Definition parameters for component 'Gap2_start_Lam' [24]. */
#define mccGap2_start_Lam_nL 1000
/* Setting parameters for component 'Gap2_start_Lam' [24]. */
char mccGap2_start_Lam_filename[16384];
MCNUM mccGap2_start_Lam_xmin;
MCNUM mccGap2_start_Lam_xmax;
MCNUM mccGap2_start_Lam_ymin;
MCNUM mccGap2_start_Lam_ymax;
MCNUM mccGap2_start_Lam_xwidth;
MCNUM mccGap2_start_Lam_yheight;
MCNUM mccGap2_start_Lam_Lmin;
MCNUM mccGap2_start_Lam_Lmax;
MCNUM mccGap2_start_Lam_restore_neutron;
int mccGap2_start_Lam_nowritefile;

/* Setting parameters for component 'Gap2_start_PSD' [25]. */
int mccGap2_start_PSD_nx;
int mccGap2_start_PSD_ny;
char mccGap2_start_PSD_filename[16384];
MCNUM mccGap2_start_PSD_xmin;
MCNUM mccGap2_start_PSD_xmax;
MCNUM mccGap2_start_PSD_ymin;
MCNUM mccGap2_start_PSD_ymax;
MCNUM mccGap2_start_PSD_xwidth;
MCNUM mccGap2_start_PSD_yheight;
MCNUM mccGap2_start_PSD_restore_neutron;

/* Definition parameters for component 'Gap2_end_Lam' [26]. */
#define mccGap2_end_Lam_nL 1000
/* Setting parameters for component 'Gap2_end_Lam' [26]. */
char mccGap2_end_Lam_filename[16384];
MCNUM mccGap2_end_Lam_xmin;
MCNUM mccGap2_end_Lam_xmax;
MCNUM mccGap2_end_Lam_ymin;
MCNUM mccGap2_end_Lam_ymax;
MCNUM mccGap2_end_Lam_xwidth;
MCNUM mccGap2_end_Lam_yheight;
MCNUM mccGap2_end_Lam_Lmin;
MCNUM mccGap2_end_Lam_Lmax;
MCNUM mccGap2_end_Lam_restore_neutron;
int mccGap2_end_Lam_nowritefile;

/* Setting parameters for component 'Gap2_end_PSD' [27]. */
int mccGap2_end_PSD_nx;
int mccGap2_end_PSD_ny;
char mccGap2_end_PSD_filename[16384];
MCNUM mccGap2_end_PSD_xmin;
MCNUM mccGap2_end_PSD_xmax;
MCNUM mccGap2_end_PSD_ymin;
MCNUM mccGap2_end_PSD_ymax;
MCNUM mccGap2_end_PSD_xwidth;
MCNUM mccGap2_end_PSD_yheight;
MCNUM mccGap2_end_PSD_restore_neutron;

/* Setting parameters for component 'Curved_Guide_Section_I' [29]. */
MCNUM mccCurved_Guide_Section_I_w1;
MCNUM mccCurved_Guide_Section_I_h1;
MCNUM mccCurved_Guide_Section_I_w2;
MCNUM mccCurved_Guide_Section_I_h2;
MCNUM mccCurved_Guide_Section_I_l;
MCNUM mccCurved_Guide_Section_I_R0;
MCNUM mccCurved_Guide_Section_I_Qc;
MCNUM mccCurved_Guide_Section_I_alpha;
MCNUM mccCurved_Guide_Section_I_m;
MCNUM mccCurved_Guide_Section_I_W;
MCNUM mccCurved_Guide_Section_I_nslit;
MCNUM mccCurved_Guide_Section_I_d;
MCNUM mccCurved_Guide_Section_I_mleft;
MCNUM mccCurved_Guide_Section_I_mright;
MCNUM mccCurved_Guide_Section_I_mtop;
MCNUM mccCurved_Guide_Section_I_mbottom;
MCNUM mccCurved_Guide_Section_I_nhslit;
MCNUM mccCurved_Guide_Section_I_G;
MCNUM mccCurved_Guide_Section_I_aleft;
MCNUM mccCurved_Guide_Section_I_aright;
MCNUM mccCurved_Guide_Section_I_atop;
MCNUM mccCurved_Guide_Section_I_abottom;
MCNUM mccCurved_Guide_Section_I_wavy;
MCNUM mccCurved_Guide_Section_I_wavy_z;
MCNUM mccCurved_Guide_Section_I_wavy_tb;
MCNUM mccCurved_Guide_Section_I_wavy_lr;
MCNUM mccCurved_Guide_Section_I_chamfers;
MCNUM mccCurved_Guide_Section_I_chamfers_z;
MCNUM mccCurved_Guide_Section_I_chamfers_lr;
MCNUM mccCurved_Guide_Section_I_chamfers_tb;
MCNUM mccCurved_Guide_Section_I_nelements;
MCNUM mccCurved_Guide_Section_I_nu;
MCNUM mccCurved_Guide_Section_I_phase;
char mccCurved_Guide_Section_I_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_I_30' [30]. */
MCNUM mccCurved_Guide_Section_I_30_w1;
MCNUM mccCurved_Guide_Section_I_30_h1;
MCNUM mccCurved_Guide_Section_I_30_w2;
MCNUM mccCurved_Guide_Section_I_30_h2;
MCNUM mccCurved_Guide_Section_I_30_l;
MCNUM mccCurved_Guide_Section_I_30_R0;
MCNUM mccCurved_Guide_Section_I_30_Qc;
MCNUM mccCurved_Guide_Section_I_30_alpha;
MCNUM mccCurved_Guide_Section_I_30_m;
MCNUM mccCurved_Guide_Section_I_30_W;
MCNUM mccCurved_Guide_Section_I_30_nslit;
MCNUM mccCurved_Guide_Section_I_30_d;
MCNUM mccCurved_Guide_Section_I_30_mleft;
MCNUM mccCurved_Guide_Section_I_30_mright;
MCNUM mccCurved_Guide_Section_I_30_mtop;
MCNUM mccCurved_Guide_Section_I_30_mbottom;
MCNUM mccCurved_Guide_Section_I_30_nhslit;
MCNUM mccCurved_Guide_Section_I_30_G;
MCNUM mccCurved_Guide_Section_I_30_aleft;
MCNUM mccCurved_Guide_Section_I_30_aright;
MCNUM mccCurved_Guide_Section_I_30_atop;
MCNUM mccCurved_Guide_Section_I_30_abottom;
MCNUM mccCurved_Guide_Section_I_30_wavy;
MCNUM mccCurved_Guide_Section_I_30_wavy_z;
MCNUM mccCurved_Guide_Section_I_30_wavy_tb;
MCNUM mccCurved_Guide_Section_I_30_wavy_lr;
MCNUM mccCurved_Guide_Section_I_30_chamfers;
MCNUM mccCurved_Guide_Section_I_30_chamfers_z;
MCNUM mccCurved_Guide_Section_I_30_chamfers_lr;
MCNUM mccCurved_Guide_Section_I_30_chamfers_tb;
MCNUM mccCurved_Guide_Section_I_30_nelements;
MCNUM mccCurved_Guide_Section_I_30_nu;
MCNUM mccCurved_Guide_Section_I_30_phase;
char mccCurved_Guide_Section_I_30_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_I_31' [31]. */
MCNUM mccCurved_Guide_Section_I_31_w1;
MCNUM mccCurved_Guide_Section_I_31_h1;
MCNUM mccCurved_Guide_Section_I_31_w2;
MCNUM mccCurved_Guide_Section_I_31_h2;
MCNUM mccCurved_Guide_Section_I_31_l;
MCNUM mccCurved_Guide_Section_I_31_R0;
MCNUM mccCurved_Guide_Section_I_31_Qc;
MCNUM mccCurved_Guide_Section_I_31_alpha;
MCNUM mccCurved_Guide_Section_I_31_m;
MCNUM mccCurved_Guide_Section_I_31_W;
MCNUM mccCurved_Guide_Section_I_31_nslit;
MCNUM mccCurved_Guide_Section_I_31_d;
MCNUM mccCurved_Guide_Section_I_31_mleft;
MCNUM mccCurved_Guide_Section_I_31_mright;
MCNUM mccCurved_Guide_Section_I_31_mtop;
MCNUM mccCurved_Guide_Section_I_31_mbottom;
MCNUM mccCurved_Guide_Section_I_31_nhslit;
MCNUM mccCurved_Guide_Section_I_31_G;
MCNUM mccCurved_Guide_Section_I_31_aleft;
MCNUM mccCurved_Guide_Section_I_31_aright;
MCNUM mccCurved_Guide_Section_I_31_atop;
MCNUM mccCurved_Guide_Section_I_31_abottom;
MCNUM mccCurved_Guide_Section_I_31_wavy;
MCNUM mccCurved_Guide_Section_I_31_wavy_z;
MCNUM mccCurved_Guide_Section_I_31_wavy_tb;
MCNUM mccCurved_Guide_Section_I_31_wavy_lr;
MCNUM mccCurved_Guide_Section_I_31_chamfers;
MCNUM mccCurved_Guide_Section_I_31_chamfers_z;
MCNUM mccCurved_Guide_Section_I_31_chamfers_lr;
MCNUM mccCurved_Guide_Section_I_31_chamfers_tb;
MCNUM mccCurved_Guide_Section_I_31_nelements;
MCNUM mccCurved_Guide_Section_I_31_nu;
MCNUM mccCurved_Guide_Section_I_31_phase;
char mccCurved_Guide_Section_I_31_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_I_32' [32]. */
MCNUM mccCurved_Guide_Section_I_32_w1;
MCNUM mccCurved_Guide_Section_I_32_h1;
MCNUM mccCurved_Guide_Section_I_32_w2;
MCNUM mccCurved_Guide_Section_I_32_h2;
MCNUM mccCurved_Guide_Section_I_32_l;
MCNUM mccCurved_Guide_Section_I_32_R0;
MCNUM mccCurved_Guide_Section_I_32_Qc;
MCNUM mccCurved_Guide_Section_I_32_alpha;
MCNUM mccCurved_Guide_Section_I_32_m;
MCNUM mccCurved_Guide_Section_I_32_W;
MCNUM mccCurved_Guide_Section_I_32_nslit;
MCNUM mccCurved_Guide_Section_I_32_d;
MCNUM mccCurved_Guide_Section_I_32_mleft;
MCNUM mccCurved_Guide_Section_I_32_mright;
MCNUM mccCurved_Guide_Section_I_32_mtop;
MCNUM mccCurved_Guide_Section_I_32_mbottom;
MCNUM mccCurved_Guide_Section_I_32_nhslit;
MCNUM mccCurved_Guide_Section_I_32_G;
MCNUM mccCurved_Guide_Section_I_32_aleft;
MCNUM mccCurved_Guide_Section_I_32_aright;
MCNUM mccCurved_Guide_Section_I_32_atop;
MCNUM mccCurved_Guide_Section_I_32_abottom;
MCNUM mccCurved_Guide_Section_I_32_wavy;
MCNUM mccCurved_Guide_Section_I_32_wavy_z;
MCNUM mccCurved_Guide_Section_I_32_wavy_tb;
MCNUM mccCurved_Guide_Section_I_32_wavy_lr;
MCNUM mccCurved_Guide_Section_I_32_chamfers;
MCNUM mccCurved_Guide_Section_I_32_chamfers_z;
MCNUM mccCurved_Guide_Section_I_32_chamfers_lr;
MCNUM mccCurved_Guide_Section_I_32_chamfers_tb;
MCNUM mccCurved_Guide_Section_I_32_nelements;
MCNUM mccCurved_Guide_Section_I_32_nu;
MCNUM mccCurved_Guide_Section_I_32_phase;
char mccCurved_Guide_Section_I_32_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_I_33' [33]. */
MCNUM mccCurved_Guide_Section_I_33_w1;
MCNUM mccCurved_Guide_Section_I_33_h1;
MCNUM mccCurved_Guide_Section_I_33_w2;
MCNUM mccCurved_Guide_Section_I_33_h2;
MCNUM mccCurved_Guide_Section_I_33_l;
MCNUM mccCurved_Guide_Section_I_33_R0;
MCNUM mccCurved_Guide_Section_I_33_Qc;
MCNUM mccCurved_Guide_Section_I_33_alpha;
MCNUM mccCurved_Guide_Section_I_33_m;
MCNUM mccCurved_Guide_Section_I_33_W;
MCNUM mccCurved_Guide_Section_I_33_nslit;
MCNUM mccCurved_Guide_Section_I_33_d;
MCNUM mccCurved_Guide_Section_I_33_mleft;
MCNUM mccCurved_Guide_Section_I_33_mright;
MCNUM mccCurved_Guide_Section_I_33_mtop;
MCNUM mccCurved_Guide_Section_I_33_mbottom;
MCNUM mccCurved_Guide_Section_I_33_nhslit;
MCNUM mccCurved_Guide_Section_I_33_G;
MCNUM mccCurved_Guide_Section_I_33_aleft;
MCNUM mccCurved_Guide_Section_I_33_aright;
MCNUM mccCurved_Guide_Section_I_33_atop;
MCNUM mccCurved_Guide_Section_I_33_abottom;
MCNUM mccCurved_Guide_Section_I_33_wavy;
MCNUM mccCurved_Guide_Section_I_33_wavy_z;
MCNUM mccCurved_Guide_Section_I_33_wavy_tb;
MCNUM mccCurved_Guide_Section_I_33_wavy_lr;
MCNUM mccCurved_Guide_Section_I_33_chamfers;
MCNUM mccCurved_Guide_Section_I_33_chamfers_z;
MCNUM mccCurved_Guide_Section_I_33_chamfers_lr;
MCNUM mccCurved_Guide_Section_I_33_chamfers_tb;
MCNUM mccCurved_Guide_Section_I_33_nelements;
MCNUM mccCurved_Guide_Section_I_33_nu;
MCNUM mccCurved_Guide_Section_I_33_phase;
char mccCurved_Guide_Section_I_33_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_I_34' [34]. */
MCNUM mccCurved_Guide_Section_I_34_w1;
MCNUM mccCurved_Guide_Section_I_34_h1;
MCNUM mccCurved_Guide_Section_I_34_w2;
MCNUM mccCurved_Guide_Section_I_34_h2;
MCNUM mccCurved_Guide_Section_I_34_l;
MCNUM mccCurved_Guide_Section_I_34_R0;
MCNUM mccCurved_Guide_Section_I_34_Qc;
MCNUM mccCurved_Guide_Section_I_34_alpha;
MCNUM mccCurved_Guide_Section_I_34_m;
MCNUM mccCurved_Guide_Section_I_34_W;
MCNUM mccCurved_Guide_Section_I_34_nslit;
MCNUM mccCurved_Guide_Section_I_34_d;
MCNUM mccCurved_Guide_Section_I_34_mleft;
MCNUM mccCurved_Guide_Section_I_34_mright;
MCNUM mccCurved_Guide_Section_I_34_mtop;
MCNUM mccCurved_Guide_Section_I_34_mbottom;
MCNUM mccCurved_Guide_Section_I_34_nhslit;
MCNUM mccCurved_Guide_Section_I_34_G;
MCNUM mccCurved_Guide_Section_I_34_aleft;
MCNUM mccCurved_Guide_Section_I_34_aright;
MCNUM mccCurved_Guide_Section_I_34_atop;
MCNUM mccCurved_Guide_Section_I_34_abottom;
MCNUM mccCurved_Guide_Section_I_34_wavy;
MCNUM mccCurved_Guide_Section_I_34_wavy_z;
MCNUM mccCurved_Guide_Section_I_34_wavy_tb;
MCNUM mccCurved_Guide_Section_I_34_wavy_lr;
MCNUM mccCurved_Guide_Section_I_34_chamfers;
MCNUM mccCurved_Guide_Section_I_34_chamfers_z;
MCNUM mccCurved_Guide_Section_I_34_chamfers_lr;
MCNUM mccCurved_Guide_Section_I_34_chamfers_tb;
MCNUM mccCurved_Guide_Section_I_34_nelements;
MCNUM mccCurved_Guide_Section_I_34_nu;
MCNUM mccCurved_Guide_Section_I_34_phase;
char mccCurved_Guide_Section_I_34_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_I_35' [35]. */
MCNUM mccCurved_Guide_Section_I_35_w1;
MCNUM mccCurved_Guide_Section_I_35_h1;
MCNUM mccCurved_Guide_Section_I_35_w2;
MCNUM mccCurved_Guide_Section_I_35_h2;
MCNUM mccCurved_Guide_Section_I_35_l;
MCNUM mccCurved_Guide_Section_I_35_R0;
MCNUM mccCurved_Guide_Section_I_35_Qc;
MCNUM mccCurved_Guide_Section_I_35_alpha;
MCNUM mccCurved_Guide_Section_I_35_m;
MCNUM mccCurved_Guide_Section_I_35_W;
MCNUM mccCurved_Guide_Section_I_35_nslit;
MCNUM mccCurved_Guide_Section_I_35_d;
MCNUM mccCurved_Guide_Section_I_35_mleft;
MCNUM mccCurved_Guide_Section_I_35_mright;
MCNUM mccCurved_Guide_Section_I_35_mtop;
MCNUM mccCurved_Guide_Section_I_35_mbottom;
MCNUM mccCurved_Guide_Section_I_35_nhslit;
MCNUM mccCurved_Guide_Section_I_35_G;
MCNUM mccCurved_Guide_Section_I_35_aleft;
MCNUM mccCurved_Guide_Section_I_35_aright;
MCNUM mccCurved_Guide_Section_I_35_atop;
MCNUM mccCurved_Guide_Section_I_35_abottom;
MCNUM mccCurved_Guide_Section_I_35_wavy;
MCNUM mccCurved_Guide_Section_I_35_wavy_z;
MCNUM mccCurved_Guide_Section_I_35_wavy_tb;
MCNUM mccCurved_Guide_Section_I_35_wavy_lr;
MCNUM mccCurved_Guide_Section_I_35_chamfers;
MCNUM mccCurved_Guide_Section_I_35_chamfers_z;
MCNUM mccCurved_Guide_Section_I_35_chamfers_lr;
MCNUM mccCurved_Guide_Section_I_35_chamfers_tb;
MCNUM mccCurved_Guide_Section_I_35_nelements;
MCNUM mccCurved_Guide_Section_I_35_nu;
MCNUM mccCurved_Guide_Section_I_35_phase;
char mccCurved_Guide_Section_I_35_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_I_36' [36]. */
MCNUM mccCurved_Guide_Section_I_36_w1;
MCNUM mccCurved_Guide_Section_I_36_h1;
MCNUM mccCurved_Guide_Section_I_36_w2;
MCNUM mccCurved_Guide_Section_I_36_h2;
MCNUM mccCurved_Guide_Section_I_36_l;
MCNUM mccCurved_Guide_Section_I_36_R0;
MCNUM mccCurved_Guide_Section_I_36_Qc;
MCNUM mccCurved_Guide_Section_I_36_alpha;
MCNUM mccCurved_Guide_Section_I_36_m;
MCNUM mccCurved_Guide_Section_I_36_W;
MCNUM mccCurved_Guide_Section_I_36_nslit;
MCNUM mccCurved_Guide_Section_I_36_d;
MCNUM mccCurved_Guide_Section_I_36_mleft;
MCNUM mccCurved_Guide_Section_I_36_mright;
MCNUM mccCurved_Guide_Section_I_36_mtop;
MCNUM mccCurved_Guide_Section_I_36_mbottom;
MCNUM mccCurved_Guide_Section_I_36_nhslit;
MCNUM mccCurved_Guide_Section_I_36_G;
MCNUM mccCurved_Guide_Section_I_36_aleft;
MCNUM mccCurved_Guide_Section_I_36_aright;
MCNUM mccCurved_Guide_Section_I_36_atop;
MCNUM mccCurved_Guide_Section_I_36_abottom;
MCNUM mccCurved_Guide_Section_I_36_wavy;
MCNUM mccCurved_Guide_Section_I_36_wavy_z;
MCNUM mccCurved_Guide_Section_I_36_wavy_tb;
MCNUM mccCurved_Guide_Section_I_36_wavy_lr;
MCNUM mccCurved_Guide_Section_I_36_chamfers;
MCNUM mccCurved_Guide_Section_I_36_chamfers_z;
MCNUM mccCurved_Guide_Section_I_36_chamfers_lr;
MCNUM mccCurved_Guide_Section_I_36_chamfers_tb;
MCNUM mccCurved_Guide_Section_I_36_nelements;
MCNUM mccCurved_Guide_Section_I_36_nu;
MCNUM mccCurved_Guide_Section_I_36_phase;
char mccCurved_Guide_Section_I_36_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_I_37' [37]. */
MCNUM mccCurved_Guide_Section_I_37_w1;
MCNUM mccCurved_Guide_Section_I_37_h1;
MCNUM mccCurved_Guide_Section_I_37_w2;
MCNUM mccCurved_Guide_Section_I_37_h2;
MCNUM mccCurved_Guide_Section_I_37_l;
MCNUM mccCurved_Guide_Section_I_37_R0;
MCNUM mccCurved_Guide_Section_I_37_Qc;
MCNUM mccCurved_Guide_Section_I_37_alpha;
MCNUM mccCurved_Guide_Section_I_37_m;
MCNUM mccCurved_Guide_Section_I_37_W;
MCNUM mccCurved_Guide_Section_I_37_nslit;
MCNUM mccCurved_Guide_Section_I_37_d;
MCNUM mccCurved_Guide_Section_I_37_mleft;
MCNUM mccCurved_Guide_Section_I_37_mright;
MCNUM mccCurved_Guide_Section_I_37_mtop;
MCNUM mccCurved_Guide_Section_I_37_mbottom;
MCNUM mccCurved_Guide_Section_I_37_nhslit;
MCNUM mccCurved_Guide_Section_I_37_G;
MCNUM mccCurved_Guide_Section_I_37_aleft;
MCNUM mccCurved_Guide_Section_I_37_aright;
MCNUM mccCurved_Guide_Section_I_37_atop;
MCNUM mccCurved_Guide_Section_I_37_abottom;
MCNUM mccCurved_Guide_Section_I_37_wavy;
MCNUM mccCurved_Guide_Section_I_37_wavy_z;
MCNUM mccCurved_Guide_Section_I_37_wavy_tb;
MCNUM mccCurved_Guide_Section_I_37_wavy_lr;
MCNUM mccCurved_Guide_Section_I_37_chamfers;
MCNUM mccCurved_Guide_Section_I_37_chamfers_z;
MCNUM mccCurved_Guide_Section_I_37_chamfers_lr;
MCNUM mccCurved_Guide_Section_I_37_chamfers_tb;
MCNUM mccCurved_Guide_Section_I_37_nelements;
MCNUM mccCurved_Guide_Section_I_37_nu;
MCNUM mccCurved_Guide_Section_I_37_phase;
char mccCurved_Guide_Section_I_37_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_I_38' [38]. */
MCNUM mccCurved_Guide_Section_I_38_w1;
MCNUM mccCurved_Guide_Section_I_38_h1;
MCNUM mccCurved_Guide_Section_I_38_w2;
MCNUM mccCurved_Guide_Section_I_38_h2;
MCNUM mccCurved_Guide_Section_I_38_l;
MCNUM mccCurved_Guide_Section_I_38_R0;
MCNUM mccCurved_Guide_Section_I_38_Qc;
MCNUM mccCurved_Guide_Section_I_38_alpha;
MCNUM mccCurved_Guide_Section_I_38_m;
MCNUM mccCurved_Guide_Section_I_38_W;
MCNUM mccCurved_Guide_Section_I_38_nslit;
MCNUM mccCurved_Guide_Section_I_38_d;
MCNUM mccCurved_Guide_Section_I_38_mleft;
MCNUM mccCurved_Guide_Section_I_38_mright;
MCNUM mccCurved_Guide_Section_I_38_mtop;
MCNUM mccCurved_Guide_Section_I_38_mbottom;
MCNUM mccCurved_Guide_Section_I_38_nhslit;
MCNUM mccCurved_Guide_Section_I_38_G;
MCNUM mccCurved_Guide_Section_I_38_aleft;
MCNUM mccCurved_Guide_Section_I_38_aright;
MCNUM mccCurved_Guide_Section_I_38_atop;
MCNUM mccCurved_Guide_Section_I_38_abottom;
MCNUM mccCurved_Guide_Section_I_38_wavy;
MCNUM mccCurved_Guide_Section_I_38_wavy_z;
MCNUM mccCurved_Guide_Section_I_38_wavy_tb;
MCNUM mccCurved_Guide_Section_I_38_wavy_lr;
MCNUM mccCurved_Guide_Section_I_38_chamfers;
MCNUM mccCurved_Guide_Section_I_38_chamfers_z;
MCNUM mccCurved_Guide_Section_I_38_chamfers_lr;
MCNUM mccCurved_Guide_Section_I_38_chamfers_tb;
MCNUM mccCurved_Guide_Section_I_38_nelements;
MCNUM mccCurved_Guide_Section_I_38_nu;
MCNUM mccCurved_Guide_Section_I_38_phase;
char mccCurved_Guide_Section_I_38_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_I_short' [39]. */
MCNUM mccCurved_Guide_Section_I_short_w1;
MCNUM mccCurved_Guide_Section_I_short_h1;
MCNUM mccCurved_Guide_Section_I_short_w2;
MCNUM mccCurved_Guide_Section_I_short_h2;
MCNUM mccCurved_Guide_Section_I_short_l;
MCNUM mccCurved_Guide_Section_I_short_R0;
MCNUM mccCurved_Guide_Section_I_short_Qc;
MCNUM mccCurved_Guide_Section_I_short_alpha;
MCNUM mccCurved_Guide_Section_I_short_m;
MCNUM mccCurved_Guide_Section_I_short_W;
MCNUM mccCurved_Guide_Section_I_short_nslit;
MCNUM mccCurved_Guide_Section_I_short_d;
MCNUM mccCurved_Guide_Section_I_short_mleft;
MCNUM mccCurved_Guide_Section_I_short_mright;
MCNUM mccCurved_Guide_Section_I_short_mtop;
MCNUM mccCurved_Guide_Section_I_short_mbottom;
MCNUM mccCurved_Guide_Section_I_short_nhslit;
MCNUM mccCurved_Guide_Section_I_short_G;
MCNUM mccCurved_Guide_Section_I_short_aleft;
MCNUM mccCurved_Guide_Section_I_short_aright;
MCNUM mccCurved_Guide_Section_I_short_atop;
MCNUM mccCurved_Guide_Section_I_short_abottom;
MCNUM mccCurved_Guide_Section_I_short_wavy;
MCNUM mccCurved_Guide_Section_I_short_wavy_z;
MCNUM mccCurved_Guide_Section_I_short_wavy_tb;
MCNUM mccCurved_Guide_Section_I_short_wavy_lr;
MCNUM mccCurved_Guide_Section_I_short_chamfers;
MCNUM mccCurved_Guide_Section_I_short_chamfers_z;
MCNUM mccCurved_Guide_Section_I_short_chamfers_lr;
MCNUM mccCurved_Guide_Section_I_short_chamfers_tb;
MCNUM mccCurved_Guide_Section_I_short_nelements;
MCNUM mccCurved_Guide_Section_I_short_nu;
MCNUM mccCurved_Guide_Section_I_short_phase;
char mccCurved_Guide_Section_I_short_reflect[16384];

/* Definition parameters for component 'Gap3_start_Lam' [41]. */
#define mccGap3_start_Lam_nL 1000
/* Setting parameters for component 'Gap3_start_Lam' [41]. */
char mccGap3_start_Lam_filename[16384];
MCNUM mccGap3_start_Lam_xmin;
MCNUM mccGap3_start_Lam_xmax;
MCNUM mccGap3_start_Lam_ymin;
MCNUM mccGap3_start_Lam_ymax;
MCNUM mccGap3_start_Lam_xwidth;
MCNUM mccGap3_start_Lam_yheight;
MCNUM mccGap3_start_Lam_Lmin;
MCNUM mccGap3_start_Lam_Lmax;
MCNUM mccGap3_start_Lam_restore_neutron;
int mccGap3_start_Lam_nowritefile;

/* Setting parameters for component 'CGS1_end' [42]. */
int mccCGS1_end_nx;
int mccCGS1_end_ny;
char mccCGS1_end_filename[16384];
MCNUM mccCGS1_end_xmin;
MCNUM mccCGS1_end_xmax;
MCNUM mccCGS1_end_ymin;
MCNUM mccCGS1_end_ymax;
MCNUM mccCGS1_end_xwidth;
MCNUM mccCGS1_end_yheight;
MCNUM mccCGS1_end_restore_neutron;

/* Definition parameters for component 'before_Chopper1_ToF' [43]. */
#define mccbefore_Chopper1_ToF_nt 10000
/* Setting parameters for component 'before_Chopper1_ToF' [43]. */
char mccbefore_Chopper1_ToF_filename[16384];
MCNUM mccbefore_Chopper1_ToF_xmin;
MCNUM mccbefore_Chopper1_ToF_xmax;
MCNUM mccbefore_Chopper1_ToF_ymin;
MCNUM mccbefore_Chopper1_ToF_ymax;
MCNUM mccbefore_Chopper1_ToF_xwidth;
MCNUM mccbefore_Chopper1_ToF_yheight;
MCNUM mccbefore_Chopper1_ToF_tmin;
MCNUM mccbefore_Chopper1_ToF_tmax;
MCNUM mccbefore_Chopper1_ToF_dt;
MCNUM mccbefore_Chopper1_ToF_restore_neutron;
int mccbefore_Chopper1_ToF_nowritefile;

/* Definition parameters for component 'before_Chopper1_ToF_Z' [44]. */
#define mccbefore_Chopper1_ToF_Z_nt 10000
/* Setting parameters for component 'before_Chopper1_ToF_Z' [44]. */
char mccbefore_Chopper1_ToF_Z_filename[16384];
MCNUM mccbefore_Chopper1_ToF_Z_xmin;
MCNUM mccbefore_Chopper1_ToF_Z_xmax;
MCNUM mccbefore_Chopper1_ToF_Z_ymin;
MCNUM mccbefore_Chopper1_ToF_Z_ymax;
MCNUM mccbefore_Chopper1_ToF_Z_xwidth;
MCNUM mccbefore_Chopper1_ToF_Z_yheight;
MCNUM mccbefore_Chopper1_ToF_Z_tmin;
MCNUM mccbefore_Chopper1_ToF_Z_tmax;
MCNUM mccbefore_Chopper1_ToF_Z_dt;
MCNUM mccbefore_Chopper1_ToF_Z_restore_neutron;
int mccbefore_Chopper1_ToF_Z_nowritefile;

/* Setting parameters for component 'Chopper1' [45]. */
MCNUM mccChopper1_theta_0;
MCNUM mccChopper1_radius;
MCNUM mccChopper1_yheight;
MCNUM mccChopper1_nu;
MCNUM mccChopper1_nslit;
MCNUM mccChopper1_jitter;
MCNUM mccChopper1_delay;
MCNUM mccChopper1_isfirst;
MCNUM mccChopper1_n_pulse;
MCNUM mccChopper1_abs_out;
MCNUM mccChopper1_phase;
MCNUM mccChopper1_xwidth;
MCNUM mccChopper1_verbose;

/* Definition parameters for component 'Chopper1_ToF' [46]. */
#define mccChopper1_ToF_nt 10000
/* Setting parameters for component 'Chopper1_ToF' [46]. */
char mccChopper1_ToF_filename[16384];
MCNUM mccChopper1_ToF_xmin;
MCNUM mccChopper1_ToF_xmax;
MCNUM mccChopper1_ToF_ymin;
MCNUM mccChopper1_ToF_ymax;
MCNUM mccChopper1_ToF_xwidth;
MCNUM mccChopper1_ToF_yheight;
MCNUM mccChopper1_ToF_tmin;
MCNUM mccChopper1_ToF_tmax;
MCNUM mccChopper1_ToF_dt;
MCNUM mccChopper1_ToF_restore_neutron;
int mccChopper1_ToF_nowritefile;

/* Definition parameters for component 'Chopper1_ToF_Z' [47]. */
#define mccChopper1_ToF_Z_nt 10000
/* Setting parameters for component 'Chopper1_ToF_Z' [47]. */
char mccChopper1_ToF_Z_filename[16384];
MCNUM mccChopper1_ToF_Z_xmin;
MCNUM mccChopper1_ToF_Z_xmax;
MCNUM mccChopper1_ToF_Z_ymin;
MCNUM mccChopper1_ToF_Z_ymax;
MCNUM mccChopper1_ToF_Z_xwidth;
MCNUM mccChopper1_ToF_Z_yheight;
MCNUM mccChopper1_ToF_Z_tmin;
MCNUM mccChopper1_ToF_Z_tmax;
MCNUM mccChopper1_ToF_Z_dt;
MCNUM mccChopper1_ToF_Z_restore_neutron;
int mccChopper1_ToF_Z_nowritefile;

/* Definition parameters for component 'Gap3_end_Lam' [48]. */
#define mccGap3_end_Lam_nL 1000
/* Setting parameters for component 'Gap3_end_Lam' [48]. */
char mccGap3_end_Lam_filename[16384];
MCNUM mccGap3_end_Lam_xmin;
MCNUM mccGap3_end_Lam_xmax;
MCNUM mccGap3_end_Lam_ymin;
MCNUM mccGap3_end_Lam_ymax;
MCNUM mccGap3_end_Lam_xwidth;
MCNUM mccGap3_end_Lam_yheight;
MCNUM mccGap3_end_Lam_Lmin;
MCNUM mccGap3_end_Lam_Lmax;
MCNUM mccGap3_end_Lam_restore_neutron;
int mccGap3_end_Lam_nowritefile;

/* Setting parameters for component 'Gap3_end_PSD' [49]. */
int mccGap3_end_PSD_nx;
int mccGap3_end_PSD_ny;
char mccGap3_end_PSD_filename[16384];
MCNUM mccGap3_end_PSD_xmin;
MCNUM mccGap3_end_PSD_xmax;
MCNUM mccGap3_end_PSD_ymin;
MCNUM mccGap3_end_PSD_ymax;
MCNUM mccGap3_end_PSD_xwidth;
MCNUM mccGap3_end_PSD_yheight;
MCNUM mccGap3_end_PSD_restore_neutron;

/* Setting parameters for component 'Curved_Guide_Section_II' [51]. */
MCNUM mccCurved_Guide_Section_II_w1;
MCNUM mccCurved_Guide_Section_II_h1;
MCNUM mccCurved_Guide_Section_II_w2;
MCNUM mccCurved_Guide_Section_II_h2;
MCNUM mccCurved_Guide_Section_II_l;
MCNUM mccCurved_Guide_Section_II_R0;
MCNUM mccCurved_Guide_Section_II_Qc;
MCNUM mccCurved_Guide_Section_II_alpha;
MCNUM mccCurved_Guide_Section_II_m;
MCNUM mccCurved_Guide_Section_II_W;
MCNUM mccCurved_Guide_Section_II_nslit;
MCNUM mccCurved_Guide_Section_II_d;
MCNUM mccCurved_Guide_Section_II_mleft;
MCNUM mccCurved_Guide_Section_II_mright;
MCNUM mccCurved_Guide_Section_II_mtop;
MCNUM mccCurved_Guide_Section_II_mbottom;
MCNUM mccCurved_Guide_Section_II_nhslit;
MCNUM mccCurved_Guide_Section_II_G;
MCNUM mccCurved_Guide_Section_II_aleft;
MCNUM mccCurved_Guide_Section_II_aright;
MCNUM mccCurved_Guide_Section_II_atop;
MCNUM mccCurved_Guide_Section_II_abottom;
MCNUM mccCurved_Guide_Section_II_wavy;
MCNUM mccCurved_Guide_Section_II_wavy_z;
MCNUM mccCurved_Guide_Section_II_wavy_tb;
MCNUM mccCurved_Guide_Section_II_wavy_lr;
MCNUM mccCurved_Guide_Section_II_chamfers;
MCNUM mccCurved_Guide_Section_II_chamfers_z;
MCNUM mccCurved_Guide_Section_II_chamfers_lr;
MCNUM mccCurved_Guide_Section_II_chamfers_tb;
MCNUM mccCurved_Guide_Section_II_nelements;
MCNUM mccCurved_Guide_Section_II_nu;
MCNUM mccCurved_Guide_Section_II_phase;
char mccCurved_Guide_Section_II_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_II_52' [52]. */
MCNUM mccCurved_Guide_Section_II_52_w1;
MCNUM mccCurved_Guide_Section_II_52_h1;
MCNUM mccCurved_Guide_Section_II_52_w2;
MCNUM mccCurved_Guide_Section_II_52_h2;
MCNUM mccCurved_Guide_Section_II_52_l;
MCNUM mccCurved_Guide_Section_II_52_R0;
MCNUM mccCurved_Guide_Section_II_52_Qc;
MCNUM mccCurved_Guide_Section_II_52_alpha;
MCNUM mccCurved_Guide_Section_II_52_m;
MCNUM mccCurved_Guide_Section_II_52_W;
MCNUM mccCurved_Guide_Section_II_52_nslit;
MCNUM mccCurved_Guide_Section_II_52_d;
MCNUM mccCurved_Guide_Section_II_52_mleft;
MCNUM mccCurved_Guide_Section_II_52_mright;
MCNUM mccCurved_Guide_Section_II_52_mtop;
MCNUM mccCurved_Guide_Section_II_52_mbottom;
MCNUM mccCurved_Guide_Section_II_52_nhslit;
MCNUM mccCurved_Guide_Section_II_52_G;
MCNUM mccCurved_Guide_Section_II_52_aleft;
MCNUM mccCurved_Guide_Section_II_52_aright;
MCNUM mccCurved_Guide_Section_II_52_atop;
MCNUM mccCurved_Guide_Section_II_52_abottom;
MCNUM mccCurved_Guide_Section_II_52_wavy;
MCNUM mccCurved_Guide_Section_II_52_wavy_z;
MCNUM mccCurved_Guide_Section_II_52_wavy_tb;
MCNUM mccCurved_Guide_Section_II_52_wavy_lr;
MCNUM mccCurved_Guide_Section_II_52_chamfers;
MCNUM mccCurved_Guide_Section_II_52_chamfers_z;
MCNUM mccCurved_Guide_Section_II_52_chamfers_lr;
MCNUM mccCurved_Guide_Section_II_52_chamfers_tb;
MCNUM mccCurved_Guide_Section_II_52_nelements;
MCNUM mccCurved_Guide_Section_II_52_nu;
MCNUM mccCurved_Guide_Section_II_52_phase;
char mccCurved_Guide_Section_II_52_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_II_53' [53]. */
MCNUM mccCurved_Guide_Section_II_53_w1;
MCNUM mccCurved_Guide_Section_II_53_h1;
MCNUM mccCurved_Guide_Section_II_53_w2;
MCNUM mccCurved_Guide_Section_II_53_h2;
MCNUM mccCurved_Guide_Section_II_53_l;
MCNUM mccCurved_Guide_Section_II_53_R0;
MCNUM mccCurved_Guide_Section_II_53_Qc;
MCNUM mccCurved_Guide_Section_II_53_alpha;
MCNUM mccCurved_Guide_Section_II_53_m;
MCNUM mccCurved_Guide_Section_II_53_W;
MCNUM mccCurved_Guide_Section_II_53_nslit;
MCNUM mccCurved_Guide_Section_II_53_d;
MCNUM mccCurved_Guide_Section_II_53_mleft;
MCNUM mccCurved_Guide_Section_II_53_mright;
MCNUM mccCurved_Guide_Section_II_53_mtop;
MCNUM mccCurved_Guide_Section_II_53_mbottom;
MCNUM mccCurved_Guide_Section_II_53_nhslit;
MCNUM mccCurved_Guide_Section_II_53_G;
MCNUM mccCurved_Guide_Section_II_53_aleft;
MCNUM mccCurved_Guide_Section_II_53_aright;
MCNUM mccCurved_Guide_Section_II_53_atop;
MCNUM mccCurved_Guide_Section_II_53_abottom;
MCNUM mccCurved_Guide_Section_II_53_wavy;
MCNUM mccCurved_Guide_Section_II_53_wavy_z;
MCNUM mccCurved_Guide_Section_II_53_wavy_tb;
MCNUM mccCurved_Guide_Section_II_53_wavy_lr;
MCNUM mccCurved_Guide_Section_II_53_chamfers;
MCNUM mccCurved_Guide_Section_II_53_chamfers_z;
MCNUM mccCurved_Guide_Section_II_53_chamfers_lr;
MCNUM mccCurved_Guide_Section_II_53_chamfers_tb;
MCNUM mccCurved_Guide_Section_II_53_nelements;
MCNUM mccCurved_Guide_Section_II_53_nu;
MCNUM mccCurved_Guide_Section_II_53_phase;
char mccCurved_Guide_Section_II_53_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_II_54' [54]. */
MCNUM mccCurved_Guide_Section_II_54_w1;
MCNUM mccCurved_Guide_Section_II_54_h1;
MCNUM mccCurved_Guide_Section_II_54_w2;
MCNUM mccCurved_Guide_Section_II_54_h2;
MCNUM mccCurved_Guide_Section_II_54_l;
MCNUM mccCurved_Guide_Section_II_54_R0;
MCNUM mccCurved_Guide_Section_II_54_Qc;
MCNUM mccCurved_Guide_Section_II_54_alpha;
MCNUM mccCurved_Guide_Section_II_54_m;
MCNUM mccCurved_Guide_Section_II_54_W;
MCNUM mccCurved_Guide_Section_II_54_nslit;
MCNUM mccCurved_Guide_Section_II_54_d;
MCNUM mccCurved_Guide_Section_II_54_mleft;
MCNUM mccCurved_Guide_Section_II_54_mright;
MCNUM mccCurved_Guide_Section_II_54_mtop;
MCNUM mccCurved_Guide_Section_II_54_mbottom;
MCNUM mccCurved_Guide_Section_II_54_nhslit;
MCNUM mccCurved_Guide_Section_II_54_G;
MCNUM mccCurved_Guide_Section_II_54_aleft;
MCNUM mccCurved_Guide_Section_II_54_aright;
MCNUM mccCurved_Guide_Section_II_54_atop;
MCNUM mccCurved_Guide_Section_II_54_abottom;
MCNUM mccCurved_Guide_Section_II_54_wavy;
MCNUM mccCurved_Guide_Section_II_54_wavy_z;
MCNUM mccCurved_Guide_Section_II_54_wavy_tb;
MCNUM mccCurved_Guide_Section_II_54_wavy_lr;
MCNUM mccCurved_Guide_Section_II_54_chamfers;
MCNUM mccCurved_Guide_Section_II_54_chamfers_z;
MCNUM mccCurved_Guide_Section_II_54_chamfers_lr;
MCNUM mccCurved_Guide_Section_II_54_chamfers_tb;
MCNUM mccCurved_Guide_Section_II_54_nelements;
MCNUM mccCurved_Guide_Section_II_54_nu;
MCNUM mccCurved_Guide_Section_II_54_phase;
char mccCurved_Guide_Section_II_54_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_II_55' [55]. */
MCNUM mccCurved_Guide_Section_II_55_w1;
MCNUM mccCurved_Guide_Section_II_55_h1;
MCNUM mccCurved_Guide_Section_II_55_w2;
MCNUM mccCurved_Guide_Section_II_55_h2;
MCNUM mccCurved_Guide_Section_II_55_l;
MCNUM mccCurved_Guide_Section_II_55_R0;
MCNUM mccCurved_Guide_Section_II_55_Qc;
MCNUM mccCurved_Guide_Section_II_55_alpha;
MCNUM mccCurved_Guide_Section_II_55_m;
MCNUM mccCurved_Guide_Section_II_55_W;
MCNUM mccCurved_Guide_Section_II_55_nslit;
MCNUM mccCurved_Guide_Section_II_55_d;
MCNUM mccCurved_Guide_Section_II_55_mleft;
MCNUM mccCurved_Guide_Section_II_55_mright;
MCNUM mccCurved_Guide_Section_II_55_mtop;
MCNUM mccCurved_Guide_Section_II_55_mbottom;
MCNUM mccCurved_Guide_Section_II_55_nhslit;
MCNUM mccCurved_Guide_Section_II_55_G;
MCNUM mccCurved_Guide_Section_II_55_aleft;
MCNUM mccCurved_Guide_Section_II_55_aright;
MCNUM mccCurved_Guide_Section_II_55_atop;
MCNUM mccCurved_Guide_Section_II_55_abottom;
MCNUM mccCurved_Guide_Section_II_55_wavy;
MCNUM mccCurved_Guide_Section_II_55_wavy_z;
MCNUM mccCurved_Guide_Section_II_55_wavy_tb;
MCNUM mccCurved_Guide_Section_II_55_wavy_lr;
MCNUM mccCurved_Guide_Section_II_55_chamfers;
MCNUM mccCurved_Guide_Section_II_55_chamfers_z;
MCNUM mccCurved_Guide_Section_II_55_chamfers_lr;
MCNUM mccCurved_Guide_Section_II_55_chamfers_tb;
MCNUM mccCurved_Guide_Section_II_55_nelements;
MCNUM mccCurved_Guide_Section_II_55_nu;
MCNUM mccCurved_Guide_Section_II_55_phase;
char mccCurved_Guide_Section_II_55_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_II_56' [56]. */
MCNUM mccCurved_Guide_Section_II_56_w1;
MCNUM mccCurved_Guide_Section_II_56_h1;
MCNUM mccCurved_Guide_Section_II_56_w2;
MCNUM mccCurved_Guide_Section_II_56_h2;
MCNUM mccCurved_Guide_Section_II_56_l;
MCNUM mccCurved_Guide_Section_II_56_R0;
MCNUM mccCurved_Guide_Section_II_56_Qc;
MCNUM mccCurved_Guide_Section_II_56_alpha;
MCNUM mccCurved_Guide_Section_II_56_m;
MCNUM mccCurved_Guide_Section_II_56_W;
MCNUM mccCurved_Guide_Section_II_56_nslit;
MCNUM mccCurved_Guide_Section_II_56_d;
MCNUM mccCurved_Guide_Section_II_56_mleft;
MCNUM mccCurved_Guide_Section_II_56_mright;
MCNUM mccCurved_Guide_Section_II_56_mtop;
MCNUM mccCurved_Guide_Section_II_56_mbottom;
MCNUM mccCurved_Guide_Section_II_56_nhslit;
MCNUM mccCurved_Guide_Section_II_56_G;
MCNUM mccCurved_Guide_Section_II_56_aleft;
MCNUM mccCurved_Guide_Section_II_56_aright;
MCNUM mccCurved_Guide_Section_II_56_atop;
MCNUM mccCurved_Guide_Section_II_56_abottom;
MCNUM mccCurved_Guide_Section_II_56_wavy;
MCNUM mccCurved_Guide_Section_II_56_wavy_z;
MCNUM mccCurved_Guide_Section_II_56_wavy_tb;
MCNUM mccCurved_Guide_Section_II_56_wavy_lr;
MCNUM mccCurved_Guide_Section_II_56_chamfers;
MCNUM mccCurved_Guide_Section_II_56_chamfers_z;
MCNUM mccCurved_Guide_Section_II_56_chamfers_lr;
MCNUM mccCurved_Guide_Section_II_56_chamfers_tb;
MCNUM mccCurved_Guide_Section_II_56_nelements;
MCNUM mccCurved_Guide_Section_II_56_nu;
MCNUM mccCurved_Guide_Section_II_56_phase;
char mccCurved_Guide_Section_II_56_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_II_57' [57]. */
MCNUM mccCurved_Guide_Section_II_57_w1;
MCNUM mccCurved_Guide_Section_II_57_h1;
MCNUM mccCurved_Guide_Section_II_57_w2;
MCNUM mccCurved_Guide_Section_II_57_h2;
MCNUM mccCurved_Guide_Section_II_57_l;
MCNUM mccCurved_Guide_Section_II_57_R0;
MCNUM mccCurved_Guide_Section_II_57_Qc;
MCNUM mccCurved_Guide_Section_II_57_alpha;
MCNUM mccCurved_Guide_Section_II_57_m;
MCNUM mccCurved_Guide_Section_II_57_W;
MCNUM mccCurved_Guide_Section_II_57_nslit;
MCNUM mccCurved_Guide_Section_II_57_d;
MCNUM mccCurved_Guide_Section_II_57_mleft;
MCNUM mccCurved_Guide_Section_II_57_mright;
MCNUM mccCurved_Guide_Section_II_57_mtop;
MCNUM mccCurved_Guide_Section_II_57_mbottom;
MCNUM mccCurved_Guide_Section_II_57_nhslit;
MCNUM mccCurved_Guide_Section_II_57_G;
MCNUM mccCurved_Guide_Section_II_57_aleft;
MCNUM mccCurved_Guide_Section_II_57_aright;
MCNUM mccCurved_Guide_Section_II_57_atop;
MCNUM mccCurved_Guide_Section_II_57_abottom;
MCNUM mccCurved_Guide_Section_II_57_wavy;
MCNUM mccCurved_Guide_Section_II_57_wavy_z;
MCNUM mccCurved_Guide_Section_II_57_wavy_tb;
MCNUM mccCurved_Guide_Section_II_57_wavy_lr;
MCNUM mccCurved_Guide_Section_II_57_chamfers;
MCNUM mccCurved_Guide_Section_II_57_chamfers_z;
MCNUM mccCurved_Guide_Section_II_57_chamfers_lr;
MCNUM mccCurved_Guide_Section_II_57_chamfers_tb;
MCNUM mccCurved_Guide_Section_II_57_nelements;
MCNUM mccCurved_Guide_Section_II_57_nu;
MCNUM mccCurved_Guide_Section_II_57_phase;
char mccCurved_Guide_Section_II_57_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_II_last' [58]. */
MCNUM mccCurved_Guide_Section_II_last_w1;
MCNUM mccCurved_Guide_Section_II_last_h1;
MCNUM mccCurved_Guide_Section_II_last_w2;
MCNUM mccCurved_Guide_Section_II_last_h2;
MCNUM mccCurved_Guide_Section_II_last_l;
MCNUM mccCurved_Guide_Section_II_last_R0;
MCNUM mccCurved_Guide_Section_II_last_Qc;
MCNUM mccCurved_Guide_Section_II_last_alpha;
MCNUM mccCurved_Guide_Section_II_last_m;
MCNUM mccCurved_Guide_Section_II_last_W;
MCNUM mccCurved_Guide_Section_II_last_nslit;
MCNUM mccCurved_Guide_Section_II_last_d;
MCNUM mccCurved_Guide_Section_II_last_mleft;
MCNUM mccCurved_Guide_Section_II_last_mright;
MCNUM mccCurved_Guide_Section_II_last_mtop;
MCNUM mccCurved_Guide_Section_II_last_mbottom;
MCNUM mccCurved_Guide_Section_II_last_nhslit;
MCNUM mccCurved_Guide_Section_II_last_G;
MCNUM mccCurved_Guide_Section_II_last_aleft;
MCNUM mccCurved_Guide_Section_II_last_aright;
MCNUM mccCurved_Guide_Section_II_last_atop;
MCNUM mccCurved_Guide_Section_II_last_abottom;
MCNUM mccCurved_Guide_Section_II_last_wavy;
MCNUM mccCurved_Guide_Section_II_last_wavy_z;
MCNUM mccCurved_Guide_Section_II_last_wavy_tb;
MCNUM mccCurved_Guide_Section_II_last_wavy_lr;
MCNUM mccCurved_Guide_Section_II_last_chamfers;
MCNUM mccCurved_Guide_Section_II_last_chamfers_z;
MCNUM mccCurved_Guide_Section_II_last_chamfers_lr;
MCNUM mccCurved_Guide_Section_II_last_chamfers_tb;
MCNUM mccCurved_Guide_Section_II_last_nelements;
MCNUM mccCurved_Guide_Section_II_last_nu;
MCNUM mccCurved_Guide_Section_II_last_phase;
char mccCurved_Guide_Section_II_last_reflect[16384];

/* Definition parameters for component 'Gap4_start_Lam' [60]. */
#define mccGap4_start_Lam_nL 1000
/* Setting parameters for component 'Gap4_start_Lam' [60]. */
char mccGap4_start_Lam_filename[16384];
MCNUM mccGap4_start_Lam_xmin;
MCNUM mccGap4_start_Lam_xmax;
MCNUM mccGap4_start_Lam_ymin;
MCNUM mccGap4_start_Lam_ymax;
MCNUM mccGap4_start_Lam_xwidth;
MCNUM mccGap4_start_Lam_yheight;
MCNUM mccGap4_start_Lam_Lmin;
MCNUM mccGap4_start_Lam_Lmax;
MCNUM mccGap4_start_Lam_restore_neutron;
int mccGap4_start_Lam_nowritefile;

/* Setting parameters for component 'Gap4_start_PSD' [61]. */
int mccGap4_start_PSD_nx;
int mccGap4_start_PSD_ny;
char mccGap4_start_PSD_filename[16384];
MCNUM mccGap4_start_PSD_xmin;
MCNUM mccGap4_start_PSD_xmax;
MCNUM mccGap4_start_PSD_ymin;
MCNUM mccGap4_start_PSD_ymax;
MCNUM mccGap4_start_PSD_xwidth;
MCNUM mccGap4_start_PSD_yheight;
MCNUM mccGap4_start_PSD_restore_neutron;

/* Definition parameters for component 'before_Chopper2_ToF' [62]. */
#define mccbefore_Chopper2_ToF_nt 1000
/* Setting parameters for component 'before_Chopper2_ToF' [62]. */
char mccbefore_Chopper2_ToF_filename[16384];
MCNUM mccbefore_Chopper2_ToF_xmin;
MCNUM mccbefore_Chopper2_ToF_xmax;
MCNUM mccbefore_Chopper2_ToF_ymin;
MCNUM mccbefore_Chopper2_ToF_ymax;
MCNUM mccbefore_Chopper2_ToF_xwidth;
MCNUM mccbefore_Chopper2_ToF_yheight;
MCNUM mccbefore_Chopper2_ToF_tmin;
MCNUM mccbefore_Chopper2_ToF_tmax;
MCNUM mccbefore_Chopper2_ToF_dt;
MCNUM mccbefore_Chopper2_ToF_restore_neutron;
int mccbefore_Chopper2_ToF_nowritefile;

/* Definition parameters for component 'before_Chopper2_ToF_Z' [63]. */
#define mccbefore_Chopper2_ToF_Z_nt 1000
/* Setting parameters for component 'before_Chopper2_ToF_Z' [63]. */
char mccbefore_Chopper2_ToF_Z_filename[16384];
MCNUM mccbefore_Chopper2_ToF_Z_xmin;
MCNUM mccbefore_Chopper2_ToF_Z_xmax;
MCNUM mccbefore_Chopper2_ToF_Z_ymin;
MCNUM mccbefore_Chopper2_ToF_Z_ymax;
MCNUM mccbefore_Chopper2_ToF_Z_xwidth;
MCNUM mccbefore_Chopper2_ToF_Z_yheight;
MCNUM mccbefore_Chopper2_ToF_Z_tmin;
MCNUM mccbefore_Chopper2_ToF_Z_tmax;
MCNUM mccbefore_Chopper2_ToF_Z_dt;
MCNUM mccbefore_Chopper2_ToF_Z_restore_neutron;
int mccbefore_Chopper2_ToF_Z_nowritefile;

/* Setting parameters for component 'Chopper2' [64]. */
MCNUM mccChopper2_theta_0;
MCNUM mccChopper2_radius;
MCNUM mccChopper2_yheight;
MCNUM mccChopper2_nu;
MCNUM mccChopper2_nslit;
MCNUM mccChopper2_jitter;
MCNUM mccChopper2_delay;
MCNUM mccChopper2_isfirst;
MCNUM mccChopper2_n_pulse;
MCNUM mccChopper2_abs_out;
MCNUM mccChopper2_phase;
MCNUM mccChopper2_xwidth;
MCNUM mccChopper2_verbose;

/* Definition parameters for component 'Chopper2_ToF' [65]. */
#define mccChopper2_ToF_nt 1000
/* Setting parameters for component 'Chopper2_ToF' [65]. */
char mccChopper2_ToF_filename[16384];
MCNUM mccChopper2_ToF_xmin;
MCNUM mccChopper2_ToF_xmax;
MCNUM mccChopper2_ToF_ymin;
MCNUM mccChopper2_ToF_ymax;
MCNUM mccChopper2_ToF_xwidth;
MCNUM mccChopper2_ToF_yheight;
MCNUM mccChopper2_ToF_tmin;
MCNUM mccChopper2_ToF_tmax;
MCNUM mccChopper2_ToF_dt;
MCNUM mccChopper2_ToF_restore_neutron;
int mccChopper2_ToF_nowritefile;

/* Definition parameters for component 'Chopper2_ToF_Z' [66]. */
#define mccChopper2_ToF_Z_nt 1000
/* Setting parameters for component 'Chopper2_ToF_Z' [66]. */
char mccChopper2_ToF_Z_filename[16384];
MCNUM mccChopper2_ToF_Z_xmin;
MCNUM mccChopper2_ToF_Z_xmax;
MCNUM mccChopper2_ToF_Z_ymin;
MCNUM mccChopper2_ToF_Z_ymax;
MCNUM mccChopper2_ToF_Z_xwidth;
MCNUM mccChopper2_ToF_Z_yheight;
MCNUM mccChopper2_ToF_Z_tmin;
MCNUM mccChopper2_ToF_Z_tmax;
MCNUM mccChopper2_ToF_Z_dt;
MCNUM mccChopper2_ToF_Z_restore_neutron;
int mccChopper2_ToF_Z_nowritefile;

/* Definition parameters for component 'Gap4_end_Lam' [67]. */
#define mccGap4_end_Lam_nL 1000
/* Setting parameters for component 'Gap4_end_Lam' [67]. */
char mccGap4_end_Lam_filename[16384];
MCNUM mccGap4_end_Lam_xmin;
MCNUM mccGap4_end_Lam_xmax;
MCNUM mccGap4_end_Lam_ymin;
MCNUM mccGap4_end_Lam_ymax;
MCNUM mccGap4_end_Lam_xwidth;
MCNUM mccGap4_end_Lam_yheight;
MCNUM mccGap4_end_Lam_Lmin;
MCNUM mccGap4_end_Lam_Lmax;
MCNUM mccGap4_end_Lam_restore_neutron;
int mccGap4_end_Lam_nowritefile;

/* Setting parameters for component 'Gap4_end_PSD' [68]. */
int mccGap4_end_PSD_nx;
int mccGap4_end_PSD_ny;
char mccGap4_end_PSD_filename[16384];
MCNUM mccGap4_end_PSD_xmin;
MCNUM mccGap4_end_PSD_xmax;
MCNUM mccGap4_end_PSD_ymin;
MCNUM mccGap4_end_PSD_ymax;
MCNUM mccGap4_end_PSD_xwidth;
MCNUM mccGap4_end_PSD_yheight;
MCNUM mccGap4_end_PSD_restore_neutron;

/* Setting parameters for component 'Curved_Guide_Section_III' [70]. */
MCNUM mccCurved_Guide_Section_III_w1;
MCNUM mccCurved_Guide_Section_III_h1;
MCNUM mccCurved_Guide_Section_III_w2;
MCNUM mccCurved_Guide_Section_III_h2;
MCNUM mccCurved_Guide_Section_III_l;
MCNUM mccCurved_Guide_Section_III_R0;
MCNUM mccCurved_Guide_Section_III_Qc;
MCNUM mccCurved_Guide_Section_III_alpha;
MCNUM mccCurved_Guide_Section_III_m;
MCNUM mccCurved_Guide_Section_III_W;
MCNUM mccCurved_Guide_Section_III_nslit;
MCNUM mccCurved_Guide_Section_III_d;
MCNUM mccCurved_Guide_Section_III_mleft;
MCNUM mccCurved_Guide_Section_III_mright;
MCNUM mccCurved_Guide_Section_III_mtop;
MCNUM mccCurved_Guide_Section_III_mbottom;
MCNUM mccCurved_Guide_Section_III_nhslit;
MCNUM mccCurved_Guide_Section_III_G;
MCNUM mccCurved_Guide_Section_III_aleft;
MCNUM mccCurved_Guide_Section_III_aright;
MCNUM mccCurved_Guide_Section_III_atop;
MCNUM mccCurved_Guide_Section_III_abottom;
MCNUM mccCurved_Guide_Section_III_wavy;
MCNUM mccCurved_Guide_Section_III_wavy_z;
MCNUM mccCurved_Guide_Section_III_wavy_tb;
MCNUM mccCurved_Guide_Section_III_wavy_lr;
MCNUM mccCurved_Guide_Section_III_chamfers;
MCNUM mccCurved_Guide_Section_III_chamfers_z;
MCNUM mccCurved_Guide_Section_III_chamfers_lr;
MCNUM mccCurved_Guide_Section_III_chamfers_tb;
MCNUM mccCurved_Guide_Section_III_nelements;
MCNUM mccCurved_Guide_Section_III_nu;
MCNUM mccCurved_Guide_Section_III_phase;
char mccCurved_Guide_Section_III_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_III_71' [71]. */
MCNUM mccCurved_Guide_Section_III_71_w1;
MCNUM mccCurved_Guide_Section_III_71_h1;
MCNUM mccCurved_Guide_Section_III_71_w2;
MCNUM mccCurved_Guide_Section_III_71_h2;
MCNUM mccCurved_Guide_Section_III_71_l;
MCNUM mccCurved_Guide_Section_III_71_R0;
MCNUM mccCurved_Guide_Section_III_71_Qc;
MCNUM mccCurved_Guide_Section_III_71_alpha;
MCNUM mccCurved_Guide_Section_III_71_m;
MCNUM mccCurved_Guide_Section_III_71_W;
MCNUM mccCurved_Guide_Section_III_71_nslit;
MCNUM mccCurved_Guide_Section_III_71_d;
MCNUM mccCurved_Guide_Section_III_71_mleft;
MCNUM mccCurved_Guide_Section_III_71_mright;
MCNUM mccCurved_Guide_Section_III_71_mtop;
MCNUM mccCurved_Guide_Section_III_71_mbottom;
MCNUM mccCurved_Guide_Section_III_71_nhslit;
MCNUM mccCurved_Guide_Section_III_71_G;
MCNUM mccCurved_Guide_Section_III_71_aleft;
MCNUM mccCurved_Guide_Section_III_71_aright;
MCNUM mccCurved_Guide_Section_III_71_atop;
MCNUM mccCurved_Guide_Section_III_71_abottom;
MCNUM mccCurved_Guide_Section_III_71_wavy;
MCNUM mccCurved_Guide_Section_III_71_wavy_z;
MCNUM mccCurved_Guide_Section_III_71_wavy_tb;
MCNUM mccCurved_Guide_Section_III_71_wavy_lr;
MCNUM mccCurved_Guide_Section_III_71_chamfers;
MCNUM mccCurved_Guide_Section_III_71_chamfers_z;
MCNUM mccCurved_Guide_Section_III_71_chamfers_lr;
MCNUM mccCurved_Guide_Section_III_71_chamfers_tb;
MCNUM mccCurved_Guide_Section_III_71_nelements;
MCNUM mccCurved_Guide_Section_III_71_nu;
MCNUM mccCurved_Guide_Section_III_71_phase;
char mccCurved_Guide_Section_III_71_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_III_72' [72]. */
MCNUM mccCurved_Guide_Section_III_72_w1;
MCNUM mccCurved_Guide_Section_III_72_h1;
MCNUM mccCurved_Guide_Section_III_72_w2;
MCNUM mccCurved_Guide_Section_III_72_h2;
MCNUM mccCurved_Guide_Section_III_72_l;
MCNUM mccCurved_Guide_Section_III_72_R0;
MCNUM mccCurved_Guide_Section_III_72_Qc;
MCNUM mccCurved_Guide_Section_III_72_alpha;
MCNUM mccCurved_Guide_Section_III_72_m;
MCNUM mccCurved_Guide_Section_III_72_W;
MCNUM mccCurved_Guide_Section_III_72_nslit;
MCNUM mccCurved_Guide_Section_III_72_d;
MCNUM mccCurved_Guide_Section_III_72_mleft;
MCNUM mccCurved_Guide_Section_III_72_mright;
MCNUM mccCurved_Guide_Section_III_72_mtop;
MCNUM mccCurved_Guide_Section_III_72_mbottom;
MCNUM mccCurved_Guide_Section_III_72_nhslit;
MCNUM mccCurved_Guide_Section_III_72_G;
MCNUM mccCurved_Guide_Section_III_72_aleft;
MCNUM mccCurved_Guide_Section_III_72_aright;
MCNUM mccCurved_Guide_Section_III_72_atop;
MCNUM mccCurved_Guide_Section_III_72_abottom;
MCNUM mccCurved_Guide_Section_III_72_wavy;
MCNUM mccCurved_Guide_Section_III_72_wavy_z;
MCNUM mccCurved_Guide_Section_III_72_wavy_tb;
MCNUM mccCurved_Guide_Section_III_72_wavy_lr;
MCNUM mccCurved_Guide_Section_III_72_chamfers;
MCNUM mccCurved_Guide_Section_III_72_chamfers_z;
MCNUM mccCurved_Guide_Section_III_72_chamfers_lr;
MCNUM mccCurved_Guide_Section_III_72_chamfers_tb;
MCNUM mccCurved_Guide_Section_III_72_nelements;
MCNUM mccCurved_Guide_Section_III_72_nu;
MCNUM mccCurved_Guide_Section_III_72_phase;
char mccCurved_Guide_Section_III_72_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_III_73' [73]. */
MCNUM mccCurved_Guide_Section_III_73_w1;
MCNUM mccCurved_Guide_Section_III_73_h1;
MCNUM mccCurved_Guide_Section_III_73_w2;
MCNUM mccCurved_Guide_Section_III_73_h2;
MCNUM mccCurved_Guide_Section_III_73_l;
MCNUM mccCurved_Guide_Section_III_73_R0;
MCNUM mccCurved_Guide_Section_III_73_Qc;
MCNUM mccCurved_Guide_Section_III_73_alpha;
MCNUM mccCurved_Guide_Section_III_73_m;
MCNUM mccCurved_Guide_Section_III_73_W;
MCNUM mccCurved_Guide_Section_III_73_nslit;
MCNUM mccCurved_Guide_Section_III_73_d;
MCNUM mccCurved_Guide_Section_III_73_mleft;
MCNUM mccCurved_Guide_Section_III_73_mright;
MCNUM mccCurved_Guide_Section_III_73_mtop;
MCNUM mccCurved_Guide_Section_III_73_mbottom;
MCNUM mccCurved_Guide_Section_III_73_nhslit;
MCNUM mccCurved_Guide_Section_III_73_G;
MCNUM mccCurved_Guide_Section_III_73_aleft;
MCNUM mccCurved_Guide_Section_III_73_aright;
MCNUM mccCurved_Guide_Section_III_73_atop;
MCNUM mccCurved_Guide_Section_III_73_abottom;
MCNUM mccCurved_Guide_Section_III_73_wavy;
MCNUM mccCurved_Guide_Section_III_73_wavy_z;
MCNUM mccCurved_Guide_Section_III_73_wavy_tb;
MCNUM mccCurved_Guide_Section_III_73_wavy_lr;
MCNUM mccCurved_Guide_Section_III_73_chamfers;
MCNUM mccCurved_Guide_Section_III_73_chamfers_z;
MCNUM mccCurved_Guide_Section_III_73_chamfers_lr;
MCNUM mccCurved_Guide_Section_III_73_chamfers_tb;
MCNUM mccCurved_Guide_Section_III_73_nelements;
MCNUM mccCurved_Guide_Section_III_73_nu;
MCNUM mccCurved_Guide_Section_III_73_phase;
char mccCurved_Guide_Section_III_73_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_III_74' [74]. */
MCNUM mccCurved_Guide_Section_III_74_w1;
MCNUM mccCurved_Guide_Section_III_74_h1;
MCNUM mccCurved_Guide_Section_III_74_w2;
MCNUM mccCurved_Guide_Section_III_74_h2;
MCNUM mccCurved_Guide_Section_III_74_l;
MCNUM mccCurved_Guide_Section_III_74_R0;
MCNUM mccCurved_Guide_Section_III_74_Qc;
MCNUM mccCurved_Guide_Section_III_74_alpha;
MCNUM mccCurved_Guide_Section_III_74_m;
MCNUM mccCurved_Guide_Section_III_74_W;
MCNUM mccCurved_Guide_Section_III_74_nslit;
MCNUM mccCurved_Guide_Section_III_74_d;
MCNUM mccCurved_Guide_Section_III_74_mleft;
MCNUM mccCurved_Guide_Section_III_74_mright;
MCNUM mccCurved_Guide_Section_III_74_mtop;
MCNUM mccCurved_Guide_Section_III_74_mbottom;
MCNUM mccCurved_Guide_Section_III_74_nhslit;
MCNUM mccCurved_Guide_Section_III_74_G;
MCNUM mccCurved_Guide_Section_III_74_aleft;
MCNUM mccCurved_Guide_Section_III_74_aright;
MCNUM mccCurved_Guide_Section_III_74_atop;
MCNUM mccCurved_Guide_Section_III_74_abottom;
MCNUM mccCurved_Guide_Section_III_74_wavy;
MCNUM mccCurved_Guide_Section_III_74_wavy_z;
MCNUM mccCurved_Guide_Section_III_74_wavy_tb;
MCNUM mccCurved_Guide_Section_III_74_wavy_lr;
MCNUM mccCurved_Guide_Section_III_74_chamfers;
MCNUM mccCurved_Guide_Section_III_74_chamfers_z;
MCNUM mccCurved_Guide_Section_III_74_chamfers_lr;
MCNUM mccCurved_Guide_Section_III_74_chamfers_tb;
MCNUM mccCurved_Guide_Section_III_74_nelements;
MCNUM mccCurved_Guide_Section_III_74_nu;
MCNUM mccCurved_Guide_Section_III_74_phase;
char mccCurved_Guide_Section_III_74_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_III_75' [75]. */
MCNUM mccCurved_Guide_Section_III_75_w1;
MCNUM mccCurved_Guide_Section_III_75_h1;
MCNUM mccCurved_Guide_Section_III_75_w2;
MCNUM mccCurved_Guide_Section_III_75_h2;
MCNUM mccCurved_Guide_Section_III_75_l;
MCNUM mccCurved_Guide_Section_III_75_R0;
MCNUM mccCurved_Guide_Section_III_75_Qc;
MCNUM mccCurved_Guide_Section_III_75_alpha;
MCNUM mccCurved_Guide_Section_III_75_m;
MCNUM mccCurved_Guide_Section_III_75_W;
MCNUM mccCurved_Guide_Section_III_75_nslit;
MCNUM mccCurved_Guide_Section_III_75_d;
MCNUM mccCurved_Guide_Section_III_75_mleft;
MCNUM mccCurved_Guide_Section_III_75_mright;
MCNUM mccCurved_Guide_Section_III_75_mtop;
MCNUM mccCurved_Guide_Section_III_75_mbottom;
MCNUM mccCurved_Guide_Section_III_75_nhslit;
MCNUM mccCurved_Guide_Section_III_75_G;
MCNUM mccCurved_Guide_Section_III_75_aleft;
MCNUM mccCurved_Guide_Section_III_75_aright;
MCNUM mccCurved_Guide_Section_III_75_atop;
MCNUM mccCurved_Guide_Section_III_75_abottom;
MCNUM mccCurved_Guide_Section_III_75_wavy;
MCNUM mccCurved_Guide_Section_III_75_wavy_z;
MCNUM mccCurved_Guide_Section_III_75_wavy_tb;
MCNUM mccCurved_Guide_Section_III_75_wavy_lr;
MCNUM mccCurved_Guide_Section_III_75_chamfers;
MCNUM mccCurved_Guide_Section_III_75_chamfers_z;
MCNUM mccCurved_Guide_Section_III_75_chamfers_lr;
MCNUM mccCurved_Guide_Section_III_75_chamfers_tb;
MCNUM mccCurved_Guide_Section_III_75_nelements;
MCNUM mccCurved_Guide_Section_III_75_nu;
MCNUM mccCurved_Guide_Section_III_75_phase;
char mccCurved_Guide_Section_III_75_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_III_76' [76]. */
MCNUM mccCurved_Guide_Section_III_76_w1;
MCNUM mccCurved_Guide_Section_III_76_h1;
MCNUM mccCurved_Guide_Section_III_76_w2;
MCNUM mccCurved_Guide_Section_III_76_h2;
MCNUM mccCurved_Guide_Section_III_76_l;
MCNUM mccCurved_Guide_Section_III_76_R0;
MCNUM mccCurved_Guide_Section_III_76_Qc;
MCNUM mccCurved_Guide_Section_III_76_alpha;
MCNUM mccCurved_Guide_Section_III_76_m;
MCNUM mccCurved_Guide_Section_III_76_W;
MCNUM mccCurved_Guide_Section_III_76_nslit;
MCNUM mccCurved_Guide_Section_III_76_d;
MCNUM mccCurved_Guide_Section_III_76_mleft;
MCNUM mccCurved_Guide_Section_III_76_mright;
MCNUM mccCurved_Guide_Section_III_76_mtop;
MCNUM mccCurved_Guide_Section_III_76_mbottom;
MCNUM mccCurved_Guide_Section_III_76_nhslit;
MCNUM mccCurved_Guide_Section_III_76_G;
MCNUM mccCurved_Guide_Section_III_76_aleft;
MCNUM mccCurved_Guide_Section_III_76_aright;
MCNUM mccCurved_Guide_Section_III_76_atop;
MCNUM mccCurved_Guide_Section_III_76_abottom;
MCNUM mccCurved_Guide_Section_III_76_wavy;
MCNUM mccCurved_Guide_Section_III_76_wavy_z;
MCNUM mccCurved_Guide_Section_III_76_wavy_tb;
MCNUM mccCurved_Guide_Section_III_76_wavy_lr;
MCNUM mccCurved_Guide_Section_III_76_chamfers;
MCNUM mccCurved_Guide_Section_III_76_chamfers_z;
MCNUM mccCurved_Guide_Section_III_76_chamfers_lr;
MCNUM mccCurved_Guide_Section_III_76_chamfers_tb;
MCNUM mccCurved_Guide_Section_III_76_nelements;
MCNUM mccCurved_Guide_Section_III_76_nu;
MCNUM mccCurved_Guide_Section_III_76_phase;
char mccCurved_Guide_Section_III_76_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_III_77' [77]. */
MCNUM mccCurved_Guide_Section_III_77_w1;
MCNUM mccCurved_Guide_Section_III_77_h1;
MCNUM mccCurved_Guide_Section_III_77_w2;
MCNUM mccCurved_Guide_Section_III_77_h2;
MCNUM mccCurved_Guide_Section_III_77_l;
MCNUM mccCurved_Guide_Section_III_77_R0;
MCNUM mccCurved_Guide_Section_III_77_Qc;
MCNUM mccCurved_Guide_Section_III_77_alpha;
MCNUM mccCurved_Guide_Section_III_77_m;
MCNUM mccCurved_Guide_Section_III_77_W;
MCNUM mccCurved_Guide_Section_III_77_nslit;
MCNUM mccCurved_Guide_Section_III_77_d;
MCNUM mccCurved_Guide_Section_III_77_mleft;
MCNUM mccCurved_Guide_Section_III_77_mright;
MCNUM mccCurved_Guide_Section_III_77_mtop;
MCNUM mccCurved_Guide_Section_III_77_mbottom;
MCNUM mccCurved_Guide_Section_III_77_nhslit;
MCNUM mccCurved_Guide_Section_III_77_G;
MCNUM mccCurved_Guide_Section_III_77_aleft;
MCNUM mccCurved_Guide_Section_III_77_aright;
MCNUM mccCurved_Guide_Section_III_77_atop;
MCNUM mccCurved_Guide_Section_III_77_abottom;
MCNUM mccCurved_Guide_Section_III_77_wavy;
MCNUM mccCurved_Guide_Section_III_77_wavy_z;
MCNUM mccCurved_Guide_Section_III_77_wavy_tb;
MCNUM mccCurved_Guide_Section_III_77_wavy_lr;
MCNUM mccCurved_Guide_Section_III_77_chamfers;
MCNUM mccCurved_Guide_Section_III_77_chamfers_z;
MCNUM mccCurved_Guide_Section_III_77_chamfers_lr;
MCNUM mccCurved_Guide_Section_III_77_chamfers_tb;
MCNUM mccCurved_Guide_Section_III_77_nelements;
MCNUM mccCurved_Guide_Section_III_77_nu;
MCNUM mccCurved_Guide_Section_III_77_phase;
char mccCurved_Guide_Section_III_77_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_III_78' [78]. */
MCNUM mccCurved_Guide_Section_III_78_w1;
MCNUM mccCurved_Guide_Section_III_78_h1;
MCNUM mccCurved_Guide_Section_III_78_w2;
MCNUM mccCurved_Guide_Section_III_78_h2;
MCNUM mccCurved_Guide_Section_III_78_l;
MCNUM mccCurved_Guide_Section_III_78_R0;
MCNUM mccCurved_Guide_Section_III_78_Qc;
MCNUM mccCurved_Guide_Section_III_78_alpha;
MCNUM mccCurved_Guide_Section_III_78_m;
MCNUM mccCurved_Guide_Section_III_78_W;
MCNUM mccCurved_Guide_Section_III_78_nslit;
MCNUM mccCurved_Guide_Section_III_78_d;
MCNUM mccCurved_Guide_Section_III_78_mleft;
MCNUM mccCurved_Guide_Section_III_78_mright;
MCNUM mccCurved_Guide_Section_III_78_mtop;
MCNUM mccCurved_Guide_Section_III_78_mbottom;
MCNUM mccCurved_Guide_Section_III_78_nhslit;
MCNUM mccCurved_Guide_Section_III_78_G;
MCNUM mccCurved_Guide_Section_III_78_aleft;
MCNUM mccCurved_Guide_Section_III_78_aright;
MCNUM mccCurved_Guide_Section_III_78_atop;
MCNUM mccCurved_Guide_Section_III_78_abottom;
MCNUM mccCurved_Guide_Section_III_78_wavy;
MCNUM mccCurved_Guide_Section_III_78_wavy_z;
MCNUM mccCurved_Guide_Section_III_78_wavy_tb;
MCNUM mccCurved_Guide_Section_III_78_wavy_lr;
MCNUM mccCurved_Guide_Section_III_78_chamfers;
MCNUM mccCurved_Guide_Section_III_78_chamfers_z;
MCNUM mccCurved_Guide_Section_III_78_chamfers_lr;
MCNUM mccCurved_Guide_Section_III_78_chamfers_tb;
MCNUM mccCurved_Guide_Section_III_78_nelements;
MCNUM mccCurved_Guide_Section_III_78_nu;
MCNUM mccCurved_Guide_Section_III_78_phase;
char mccCurved_Guide_Section_III_78_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_III_79' [79]. */
MCNUM mccCurved_Guide_Section_III_79_w1;
MCNUM mccCurved_Guide_Section_III_79_h1;
MCNUM mccCurved_Guide_Section_III_79_w2;
MCNUM mccCurved_Guide_Section_III_79_h2;
MCNUM mccCurved_Guide_Section_III_79_l;
MCNUM mccCurved_Guide_Section_III_79_R0;
MCNUM mccCurved_Guide_Section_III_79_Qc;
MCNUM mccCurved_Guide_Section_III_79_alpha;
MCNUM mccCurved_Guide_Section_III_79_m;
MCNUM mccCurved_Guide_Section_III_79_W;
MCNUM mccCurved_Guide_Section_III_79_nslit;
MCNUM mccCurved_Guide_Section_III_79_d;
MCNUM mccCurved_Guide_Section_III_79_mleft;
MCNUM mccCurved_Guide_Section_III_79_mright;
MCNUM mccCurved_Guide_Section_III_79_mtop;
MCNUM mccCurved_Guide_Section_III_79_mbottom;
MCNUM mccCurved_Guide_Section_III_79_nhslit;
MCNUM mccCurved_Guide_Section_III_79_G;
MCNUM mccCurved_Guide_Section_III_79_aleft;
MCNUM mccCurved_Guide_Section_III_79_aright;
MCNUM mccCurved_Guide_Section_III_79_atop;
MCNUM mccCurved_Guide_Section_III_79_abottom;
MCNUM mccCurved_Guide_Section_III_79_wavy;
MCNUM mccCurved_Guide_Section_III_79_wavy_z;
MCNUM mccCurved_Guide_Section_III_79_wavy_tb;
MCNUM mccCurved_Guide_Section_III_79_wavy_lr;
MCNUM mccCurved_Guide_Section_III_79_chamfers;
MCNUM mccCurved_Guide_Section_III_79_chamfers_z;
MCNUM mccCurved_Guide_Section_III_79_chamfers_lr;
MCNUM mccCurved_Guide_Section_III_79_chamfers_tb;
MCNUM mccCurved_Guide_Section_III_79_nelements;
MCNUM mccCurved_Guide_Section_III_79_nu;
MCNUM mccCurved_Guide_Section_III_79_phase;
char mccCurved_Guide_Section_III_79_reflect[16384];

/* Setting parameters for component 'Curved_Guide_Section_III_short' [80]. */
MCNUM mccCurved_Guide_Section_III_short_w1;
MCNUM mccCurved_Guide_Section_III_short_h1;
MCNUM mccCurved_Guide_Section_III_short_w2;
MCNUM mccCurved_Guide_Section_III_short_h2;
MCNUM mccCurved_Guide_Section_III_short_l;
MCNUM mccCurved_Guide_Section_III_short_R0;
MCNUM mccCurved_Guide_Section_III_short_Qc;
MCNUM mccCurved_Guide_Section_III_short_alpha;
MCNUM mccCurved_Guide_Section_III_short_m;
MCNUM mccCurved_Guide_Section_III_short_W;
MCNUM mccCurved_Guide_Section_III_short_nslit;
MCNUM mccCurved_Guide_Section_III_short_d;
MCNUM mccCurved_Guide_Section_III_short_mleft;
MCNUM mccCurved_Guide_Section_III_short_mright;
MCNUM mccCurved_Guide_Section_III_short_mtop;
MCNUM mccCurved_Guide_Section_III_short_mbottom;
MCNUM mccCurved_Guide_Section_III_short_nhslit;
MCNUM mccCurved_Guide_Section_III_short_G;
MCNUM mccCurved_Guide_Section_III_short_aleft;
MCNUM mccCurved_Guide_Section_III_short_aright;
MCNUM mccCurved_Guide_Section_III_short_atop;
MCNUM mccCurved_Guide_Section_III_short_abottom;
MCNUM mccCurved_Guide_Section_III_short_wavy;
MCNUM mccCurved_Guide_Section_III_short_wavy_z;
MCNUM mccCurved_Guide_Section_III_short_wavy_tb;
MCNUM mccCurved_Guide_Section_III_short_wavy_lr;
MCNUM mccCurved_Guide_Section_III_short_chamfers;
MCNUM mccCurved_Guide_Section_III_short_chamfers_z;
MCNUM mccCurved_Guide_Section_III_short_chamfers_lr;
MCNUM mccCurved_Guide_Section_III_short_chamfers_tb;
MCNUM mccCurved_Guide_Section_III_short_nelements;
MCNUM mccCurved_Guide_Section_III_short_nu;
MCNUM mccCurved_Guide_Section_III_short_phase;
char mccCurved_Guide_Section_III_short_reflect[16384];

/* Definition parameters for component 'CGS3_end_ToF' [81]. */
#define mccCGS3_end_ToF_nt 1000
/* Setting parameters for component 'CGS3_end_ToF' [81]. */
char mccCGS3_end_ToF_filename[16384];
MCNUM mccCGS3_end_ToF_xmin;
MCNUM mccCGS3_end_ToF_xmax;
MCNUM mccCGS3_end_ToF_ymin;
MCNUM mccCGS3_end_ToF_ymax;
MCNUM mccCGS3_end_ToF_xwidth;
MCNUM mccCGS3_end_ToF_yheight;
MCNUM mccCGS3_end_ToF_tmin;
MCNUM mccCGS3_end_ToF_tmax;
MCNUM mccCGS3_end_ToF_dt;
MCNUM mccCGS3_end_ToF_restore_neutron;
int mccCGS3_end_ToF_nowritefile;

/* Definition parameters for component 'CGS3_end_ToF_Z' [82]. */
#define mccCGS3_end_ToF_Z_nt 1000
/* Setting parameters for component 'CGS3_end_ToF_Z' [82]. */
char mccCGS3_end_ToF_Z_filename[16384];
MCNUM mccCGS3_end_ToF_Z_xmin;
MCNUM mccCGS3_end_ToF_Z_xmax;
MCNUM mccCGS3_end_ToF_Z_ymin;
MCNUM mccCGS3_end_ToF_Z_ymax;
MCNUM mccCGS3_end_ToF_Z_xwidth;
MCNUM mccCGS3_end_ToF_Z_yheight;
MCNUM mccCGS3_end_ToF_Z_tmin;
MCNUM mccCGS3_end_ToF_Z_tmax;
MCNUM mccCGS3_end_ToF_Z_dt;
MCNUM mccCGS3_end_ToF_Z_restore_neutron;
int mccCGS3_end_ToF_Z_nowritefile;

/* Definition parameters for component 'CGS3_end_Lam' [83]. */
#define mccCGS3_end_Lam_nL 1000
/* Setting parameters for component 'CGS3_end_Lam' [83]. */
char mccCGS3_end_Lam_filename[16384];
MCNUM mccCGS3_end_Lam_xmin;
MCNUM mccCGS3_end_Lam_xmax;
MCNUM mccCGS3_end_Lam_ymin;
MCNUM mccCGS3_end_Lam_ymax;
MCNUM mccCGS3_end_Lam_xwidth;
MCNUM mccCGS3_end_Lam_yheight;
MCNUM mccCGS3_end_Lam_Lmin;
MCNUM mccCGS3_end_Lam_Lmax;
MCNUM mccCGS3_end_Lam_restore_neutron;
int mccCGS3_end_Lam_nowritefile;

/* Setting parameters for component 'Straight_Guide_Section_I' [84]. */
char mccStraight_Guide_Section_I_reflect[16384];
MCNUM mccStraight_Guide_Section_I_w1;
MCNUM mccStraight_Guide_Section_I_h1;
MCNUM mccStraight_Guide_Section_I_w2;
MCNUM mccStraight_Guide_Section_I_h2;
MCNUM mccStraight_Guide_Section_I_l;
MCNUM mccStraight_Guide_Section_I_R0;
MCNUM mccStraight_Guide_Section_I_Qc;
MCNUM mccStraight_Guide_Section_I_alpha;
MCNUM mccStraight_Guide_Section_I_m;
MCNUM mccStraight_Guide_Section_I_W;

/* Definition parameters for component 'Gap5_start_ToF' [86]. */
#define mccGap5_start_ToF_nt 1000
/* Setting parameters for component 'Gap5_start_ToF' [86]. */
char mccGap5_start_ToF_filename[16384];
MCNUM mccGap5_start_ToF_xmin;
MCNUM mccGap5_start_ToF_xmax;
MCNUM mccGap5_start_ToF_ymin;
MCNUM mccGap5_start_ToF_ymax;
MCNUM mccGap5_start_ToF_xwidth;
MCNUM mccGap5_start_ToF_yheight;
MCNUM mccGap5_start_ToF_tmin;
MCNUM mccGap5_start_ToF_tmax;
MCNUM mccGap5_start_ToF_dt;
MCNUM mccGap5_start_ToF_restore_neutron;
int mccGap5_start_ToF_nowritefile;

/* Definition parameters for component 'Gap5_start_ToF_Z' [87]. */
#define mccGap5_start_ToF_Z_nt 1000
/* Setting parameters for component 'Gap5_start_ToF_Z' [87]. */
char mccGap5_start_ToF_Z_filename[16384];
MCNUM mccGap5_start_ToF_Z_xmin;
MCNUM mccGap5_start_ToF_Z_xmax;
MCNUM mccGap5_start_ToF_Z_ymin;
MCNUM mccGap5_start_ToF_Z_ymax;
MCNUM mccGap5_start_ToF_Z_xwidth;
MCNUM mccGap5_start_ToF_Z_yheight;
MCNUM mccGap5_start_ToF_Z_tmin;
MCNUM mccGap5_start_ToF_Z_tmax;
MCNUM mccGap5_start_ToF_Z_dt;
MCNUM mccGap5_start_ToF_Z_restore_neutron;
int mccGap5_start_ToF_Z_nowritefile;

/* Definition parameters for component 'Gap5_start_Lam' [88]. */
#define mccGap5_start_Lam_nL 1000
/* Setting parameters for component 'Gap5_start_Lam' [88]. */
char mccGap5_start_Lam_filename[16384];
MCNUM mccGap5_start_Lam_xmin;
MCNUM mccGap5_start_Lam_xmax;
MCNUM mccGap5_start_Lam_ymin;
MCNUM mccGap5_start_Lam_ymax;
MCNUM mccGap5_start_Lam_xwidth;
MCNUM mccGap5_start_Lam_yheight;
MCNUM mccGap5_start_Lam_Lmin;
MCNUM mccGap5_start_Lam_Lmax;
MCNUM mccGap5_start_Lam_restore_neutron;
int mccGap5_start_Lam_nowritefile;

/* Setting parameters for component 'Gap5_start_PSD' [89]. */
int mccGap5_start_PSD_nx;
int mccGap5_start_PSD_ny;
char mccGap5_start_PSD_filename[16384];
MCNUM mccGap5_start_PSD_xmin;
MCNUM mccGap5_start_PSD_xmax;
MCNUM mccGap5_start_PSD_ymin;
MCNUM mccGap5_start_PSD_ymax;
MCNUM mccGap5_start_PSD_xwidth;
MCNUM mccGap5_start_PSD_yheight;
MCNUM mccGap5_start_PSD_restore_neutron;

/* Setting parameters for component 'Chopper3' [90]. */
MCNUM mccChopper3_theta_0;
MCNUM mccChopper3_radius;
MCNUM mccChopper3_yheight;
MCNUM mccChopper3_nu;
MCNUM mccChopper3_nslit;
MCNUM mccChopper3_jitter;
MCNUM mccChopper3_delay;
MCNUM mccChopper3_isfirst;
MCNUM mccChopper3_n_pulse;
MCNUM mccChopper3_abs_out;
MCNUM mccChopper3_phase;
MCNUM mccChopper3_xwidth;
MCNUM mccChopper3_verbose;

/* Definition parameters for component 'Chopper3_ToF' [91]. */
#define mccChopper3_ToF_nt 1000
/* Setting parameters for component 'Chopper3_ToF' [91]. */
char mccChopper3_ToF_filename[16384];
MCNUM mccChopper3_ToF_xmin;
MCNUM mccChopper3_ToF_xmax;
MCNUM mccChopper3_ToF_ymin;
MCNUM mccChopper3_ToF_ymax;
MCNUM mccChopper3_ToF_xwidth;
MCNUM mccChopper3_ToF_yheight;
MCNUM mccChopper3_ToF_tmin;
MCNUM mccChopper3_ToF_tmax;
MCNUM mccChopper3_ToF_dt;
MCNUM mccChopper3_ToF_restore_neutron;
int mccChopper3_ToF_nowritefile;

/* Definition parameters for component 'Chopper3_ToF_Z' [92]. */
#define mccChopper3_ToF_Z_nt 1000
/* Setting parameters for component 'Chopper3_ToF_Z' [92]. */
char mccChopper3_ToF_Z_filename[16384];
MCNUM mccChopper3_ToF_Z_xmin;
MCNUM mccChopper3_ToF_Z_xmax;
MCNUM mccChopper3_ToF_Z_ymin;
MCNUM mccChopper3_ToF_Z_ymax;
MCNUM mccChopper3_ToF_Z_xwidth;
MCNUM mccChopper3_ToF_Z_yheight;
MCNUM mccChopper3_ToF_Z_tmin;
MCNUM mccChopper3_ToF_Z_tmax;
MCNUM mccChopper3_ToF_Z_dt;
MCNUM mccChopper3_ToF_Z_restore_neutron;
int mccChopper3_ToF_Z_nowritefile;

/* Definition parameters for component 'Gap5_end_Lam' [93]. */
#define mccGap5_end_Lam_nL 1000
/* Setting parameters for component 'Gap5_end_Lam' [93]. */
char mccGap5_end_Lam_filename[16384];
MCNUM mccGap5_end_Lam_xmin;
MCNUM mccGap5_end_Lam_xmax;
MCNUM mccGap5_end_Lam_ymin;
MCNUM mccGap5_end_Lam_ymax;
MCNUM mccGap5_end_Lam_xwidth;
MCNUM mccGap5_end_Lam_yheight;
MCNUM mccGap5_end_Lam_Lmin;
MCNUM mccGap5_end_Lam_Lmax;
MCNUM mccGap5_end_Lam_restore_neutron;
int mccGap5_end_Lam_nowritefile;

/* Setting parameters for component 'Gap5_end_PSD' [94]. */
int mccGap5_end_PSD_nx;
int mccGap5_end_PSD_ny;
char mccGap5_end_PSD_filename[16384];
MCNUM mccGap5_end_PSD_xmin;
MCNUM mccGap5_end_PSD_xmax;
MCNUM mccGap5_end_PSD_ymin;
MCNUM mccGap5_end_PSD_ymax;
MCNUM mccGap5_end_PSD_xwidth;
MCNUM mccGap5_end_PSD_yheight;
MCNUM mccGap5_end_PSD_restore_neutron;

/* Setting parameters for component 'Straight_Guide_Section_II' [96]. */
char mccStraight_Guide_Section_II_reflect[16384];
MCNUM mccStraight_Guide_Section_II_w1;
MCNUM mccStraight_Guide_Section_II_h1;
MCNUM mccStraight_Guide_Section_II_w2;
MCNUM mccStraight_Guide_Section_II_h2;
MCNUM mccStraight_Guide_Section_II_l;
MCNUM mccStraight_Guide_Section_II_R0;
MCNUM mccStraight_Guide_Section_II_Qc;
MCNUM mccStraight_Guide_Section_II_alpha;
MCNUM mccStraight_Guide_Section_II_m;
MCNUM mccStraight_Guide_Section_II_W;

/* Definition parameters for component 'SGS2_end_Lam' [97]. */
#define mccSGS2_end_Lam_nL 1000
/* Setting parameters for component 'SGS2_end_Lam' [97]. */
char mccSGS2_end_Lam_filename[16384];
MCNUM mccSGS2_end_Lam_xmin;
MCNUM mccSGS2_end_Lam_xmax;
MCNUM mccSGS2_end_Lam_ymin;
MCNUM mccSGS2_end_Lam_ymax;
MCNUM mccSGS2_end_Lam_xwidth;
MCNUM mccSGS2_end_Lam_yheight;
MCNUM mccSGS2_end_Lam_Lmin;
MCNUM mccSGS2_end_Lam_Lmax;
MCNUM mccSGS2_end_Lam_restore_neutron;
int mccSGS2_end_Lam_nowritefile;

/* Setting parameters for component 'SGS2_end_PSD' [98]. */
int mccSGS2_end_PSD_nx;
int mccSGS2_end_PSD_ny;
char mccSGS2_end_PSD_filename[16384];
MCNUM mccSGS2_end_PSD_xmin;
MCNUM mccSGS2_end_PSD_xmax;
MCNUM mccSGS2_end_PSD_ymin;
MCNUM mccSGS2_end_PSD_ymax;
MCNUM mccSGS2_end_PSD_xwidth;
MCNUM mccSGS2_end_PSD_yheight;
MCNUM mccSGS2_end_PSD_restore_neutron;

/* Setting parameters for component 'Straight_Guide_Section_III' [99]. */
char mccStraight_Guide_Section_III_reflect[16384];
MCNUM mccStraight_Guide_Section_III_w1;
MCNUM mccStraight_Guide_Section_III_h1;
MCNUM mccStraight_Guide_Section_III_w2;
MCNUM mccStraight_Guide_Section_III_h2;
MCNUM mccStraight_Guide_Section_III_l;
MCNUM mccStraight_Guide_Section_III_R0;
MCNUM mccStraight_Guide_Section_III_Qc;
MCNUM mccStraight_Guide_Section_III_alpha;
MCNUM mccStraight_Guide_Section_III_m;
MCNUM mccStraight_Guide_Section_III_W;

/* Definition parameters for component 'SG3_end_ToF' [100]. */
#define mccSG3_end_ToF_nt 1000
/* Setting parameters for component 'SG3_end_ToF' [100]. */
char mccSG3_end_ToF_filename[16384];
MCNUM mccSG3_end_ToF_xmin;
MCNUM mccSG3_end_ToF_xmax;
MCNUM mccSG3_end_ToF_ymin;
MCNUM mccSG3_end_ToF_ymax;
MCNUM mccSG3_end_ToF_xwidth;
MCNUM mccSG3_end_ToF_yheight;
MCNUM mccSG3_end_ToF_tmin;
MCNUM mccSG3_end_ToF_tmax;
MCNUM mccSG3_end_ToF_dt;
MCNUM mccSG3_end_ToF_restore_neutron;
int mccSG3_end_ToF_nowritefile;

/* Definition parameters for component 'SG3_end_ToF_Z' [101]. */
#define mccSG3_end_ToF_Z_nt 1000
/* Setting parameters for component 'SG3_end_ToF_Z' [101]. */
char mccSG3_end_ToF_Z_filename[16384];
MCNUM mccSG3_end_ToF_Z_xmin;
MCNUM mccSG3_end_ToF_Z_xmax;
MCNUM mccSG3_end_ToF_Z_ymin;
MCNUM mccSG3_end_ToF_Z_ymax;
MCNUM mccSG3_end_ToF_Z_xwidth;
MCNUM mccSG3_end_ToF_Z_yheight;
MCNUM mccSG3_end_ToF_Z_tmin;
MCNUM mccSG3_end_ToF_Z_tmax;
MCNUM mccSG3_end_ToF_Z_dt;
MCNUM mccSG3_end_ToF_Z_restore_neutron;
int mccSG3_end_ToF_Z_nowritefile;

/* Definition parameters for component 'SG3_end_Lam' [102]. */
#define mccSG3_end_Lam_nL 1000
/* Setting parameters for component 'SG3_end_Lam' [102]. */
char mccSG3_end_Lam_filename[16384];
MCNUM mccSG3_end_Lam_xmin;
MCNUM mccSG3_end_Lam_xmax;
MCNUM mccSG3_end_Lam_ymin;
MCNUM mccSG3_end_Lam_ymax;
MCNUM mccSG3_end_Lam_xwidth;
MCNUM mccSG3_end_Lam_yheight;
MCNUM mccSG3_end_Lam_Lmin;
MCNUM mccSG3_end_Lam_Lmax;
MCNUM mccSG3_end_Lam_restore_neutron;
int mccSG3_end_Lam_nowritefile;

/* Setting parameters for component 'SG3_end_PSD' [103]. */
int mccSG3_end_PSD_nx;
int mccSG3_end_PSD_ny;
char mccSG3_end_PSD_filename[16384];
MCNUM mccSG3_end_PSD_xmin;
MCNUM mccSG3_end_PSD_xmax;
MCNUM mccSG3_end_PSD_ymin;
MCNUM mccSG3_end_PSD_ymax;
MCNUM mccSG3_end_PSD_xwidth;
MCNUM mccSG3_end_PSD_yheight;
MCNUM mccSG3_end_PSD_restore_neutron;

/* Definition parameters for component 'Funnel_1' [104]. */
#define mccFunnel_1_reflect 0 /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'Funnel_1' [104]. */
MCNUM mccFunnel_1_w1;
MCNUM mccFunnel_1_h1;
MCNUM mccFunnel_1_w2;
MCNUM mccFunnel_1_h2;
MCNUM mccFunnel_1_l;
MCNUM mccFunnel_1_R0_left;
MCNUM mccFunnel_1_R0_right;
MCNUM mccFunnel_1_R0_top;
MCNUM mccFunnel_1_R0_bottom;
MCNUM mccFunnel_1_Qc_left;
MCNUM mccFunnel_1_Qc_right;
MCNUM mccFunnel_1_Qc_top;
MCNUM mccFunnel_1_Qc_bottom;
MCNUM mccFunnel_1_alpha_left;
MCNUM mccFunnel_1_alpha_right;
MCNUM mccFunnel_1_alpha_top;
MCNUM mccFunnel_1_alpha_bottom;
MCNUM mccFunnel_1_m_left;
MCNUM mccFunnel_1_m_right;
MCNUM mccFunnel_1_m_top;
MCNUM mccFunnel_1_m_bottom;
MCNUM mccFunnel_1_W_left;
MCNUM mccFunnel_1_W_right;
MCNUM mccFunnel_1_W_top;
MCNUM mccFunnel_1_W_bottom;

/* Setting parameters for component 'PSD_post_funnel1' [105]. */
int mccPSD_post_funnel1_nx;
int mccPSD_post_funnel1_ny;
char mccPSD_post_funnel1_filename[16384];
MCNUM mccPSD_post_funnel1_xmin;
MCNUM mccPSD_post_funnel1_xmax;
MCNUM mccPSD_post_funnel1_ymin;
MCNUM mccPSD_post_funnel1_ymax;
MCNUM mccPSD_post_funnel1_xwidth;
MCNUM mccPSD_post_funnel1_yheight;
MCNUM mccPSD_post_funnel1_restore_neutron;

/* Definition parameters for component 'Funnel_2' [106]. */
#define mccFunnel_2_reflect 0 /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'Funnel_2' [106]. */
MCNUM mccFunnel_2_w1;
MCNUM mccFunnel_2_h1;
MCNUM mccFunnel_2_w2;
MCNUM mccFunnel_2_h2;
MCNUM mccFunnel_2_l;
MCNUM mccFunnel_2_R0_left;
MCNUM mccFunnel_2_R0_right;
MCNUM mccFunnel_2_R0_top;
MCNUM mccFunnel_2_R0_bottom;
MCNUM mccFunnel_2_Qc_left;
MCNUM mccFunnel_2_Qc_right;
MCNUM mccFunnel_2_Qc_top;
MCNUM mccFunnel_2_Qc_bottom;
MCNUM mccFunnel_2_alpha_left;
MCNUM mccFunnel_2_alpha_right;
MCNUM mccFunnel_2_alpha_top;
MCNUM mccFunnel_2_alpha_bottom;
MCNUM mccFunnel_2_m_left;
MCNUM mccFunnel_2_m_right;
MCNUM mccFunnel_2_m_top;
MCNUM mccFunnel_2_m_bottom;
MCNUM mccFunnel_2_W_left;
MCNUM mccFunnel_2_W_right;
MCNUM mccFunnel_2_W_top;
MCNUM mccFunnel_2_W_bottom;

/* Setting parameters for component 'PSD_post_funnel2' [107]. */
int mccPSD_post_funnel2_nx;
int mccPSD_post_funnel2_ny;
char mccPSD_post_funnel2_filename[16384];
MCNUM mccPSD_post_funnel2_xmin;
MCNUM mccPSD_post_funnel2_xmax;
MCNUM mccPSD_post_funnel2_ymin;
MCNUM mccPSD_post_funnel2_ymax;
MCNUM mccPSD_post_funnel2_xwidth;
MCNUM mccPSD_post_funnel2_yheight;
MCNUM mccPSD_post_funnel2_restore_neutron;

/* Definition parameters for component 'Funnel_3' [108]. */
#define mccFunnel_3_reflect 0 /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'Funnel_3' [108]. */
MCNUM mccFunnel_3_w1;
MCNUM mccFunnel_3_h1;
MCNUM mccFunnel_3_w2;
MCNUM mccFunnel_3_h2;
MCNUM mccFunnel_3_l;
MCNUM mccFunnel_3_R0_left;
MCNUM mccFunnel_3_R0_right;
MCNUM mccFunnel_3_R0_top;
MCNUM mccFunnel_3_R0_bottom;
MCNUM mccFunnel_3_Qc_left;
MCNUM mccFunnel_3_Qc_right;
MCNUM mccFunnel_3_Qc_top;
MCNUM mccFunnel_3_Qc_bottom;
MCNUM mccFunnel_3_alpha_left;
MCNUM mccFunnel_3_alpha_right;
MCNUM mccFunnel_3_alpha_top;
MCNUM mccFunnel_3_alpha_bottom;
MCNUM mccFunnel_3_m_left;
MCNUM mccFunnel_3_m_right;
MCNUM mccFunnel_3_m_top;
MCNUM mccFunnel_3_m_bottom;
MCNUM mccFunnel_3_W_left;
MCNUM mccFunnel_3_W_right;
MCNUM mccFunnel_3_W_top;
MCNUM mccFunnel_3_W_bottom;

/* Setting parameters for component 'PSD_post_funnel3' [109]. */
int mccPSD_post_funnel3_nx;
int mccPSD_post_funnel3_ny;
char mccPSD_post_funnel3_filename[16384];
MCNUM mccPSD_post_funnel3_xmin;
MCNUM mccPSD_post_funnel3_xmax;
MCNUM mccPSD_post_funnel3_ymin;
MCNUM mccPSD_post_funnel3_ymax;
MCNUM mccPSD_post_funnel3_xwidth;
MCNUM mccPSD_post_funnel3_yheight;
MCNUM mccPSD_post_funnel3_restore_neutron;

/* Definition parameters for component 'Funnel_4' [110]. */
#define mccFunnel_4_reflect 0 /* declared as a string. May produce warnings at compile */
/* Setting parameters for component 'Funnel_4' [110]. */
MCNUM mccFunnel_4_w1;
MCNUM mccFunnel_4_h1;
MCNUM mccFunnel_4_w2;
MCNUM mccFunnel_4_h2;
MCNUM mccFunnel_4_l;
MCNUM mccFunnel_4_R0_left;
MCNUM mccFunnel_4_R0_right;
MCNUM mccFunnel_4_R0_top;
MCNUM mccFunnel_4_R0_bottom;
MCNUM mccFunnel_4_Qc_left;
MCNUM mccFunnel_4_Qc_right;
MCNUM mccFunnel_4_Qc_top;
MCNUM mccFunnel_4_Qc_bottom;
MCNUM mccFunnel_4_alpha_left;
MCNUM mccFunnel_4_alpha_right;
MCNUM mccFunnel_4_alpha_top;
MCNUM mccFunnel_4_alpha_bottom;
MCNUM mccFunnel_4_m_left;
MCNUM mccFunnel_4_m_right;
MCNUM mccFunnel_4_m_top;
MCNUM mccFunnel_4_m_bottom;
MCNUM mccFunnel_4_W_left;
MCNUM mccFunnel_4_W_right;
MCNUM mccFunnel_4_W_top;
MCNUM mccFunnel_4_W_bottom;

/* Setting parameters for component 'PSD_post_funnel4' [111]. */
int mccPSD_post_funnel4_nx;
int mccPSD_post_funnel4_ny;
char mccPSD_post_funnel4_filename[16384];
MCNUM mccPSD_post_funnel4_xmin;
MCNUM mccPSD_post_funnel4_xmax;
MCNUM mccPSD_post_funnel4_ymin;
MCNUM mccPSD_post_funnel4_ymax;
MCNUM mccPSD_post_funnel4_xwidth;
MCNUM mccPSD_post_funnel4_yheight;
MCNUM mccPSD_post_funnel4_restore_neutron;

/* Definition parameters for component 'Guide_End_ToF' [112]. */
#define mccGuide_End_ToF_nt 10000
/* Setting parameters for component 'Guide_End_ToF' [112]. */
char mccGuide_End_ToF_filename[16384];
MCNUM mccGuide_End_ToF_xmin;
MCNUM mccGuide_End_ToF_xmax;
MCNUM mccGuide_End_ToF_ymin;
MCNUM mccGuide_End_ToF_ymax;
MCNUM mccGuide_End_ToF_xwidth;
MCNUM mccGuide_End_ToF_yheight;
MCNUM mccGuide_End_ToF_tmin;
MCNUM mccGuide_End_ToF_tmax;
MCNUM mccGuide_End_ToF_dt;
MCNUM mccGuide_End_ToF_restore_neutron;
int mccGuide_End_ToF_nowritefile;

/* Definition parameters for component 'Guide_End_ToF_Z' [113]. */
#define mccGuide_End_ToF_Z_nt 200
/* Setting parameters for component 'Guide_End_ToF_Z' [113]. */
char mccGuide_End_ToF_Z_filename[16384];
MCNUM mccGuide_End_ToF_Z_xmin;
MCNUM mccGuide_End_ToF_Z_xmax;
MCNUM mccGuide_End_ToF_Z_ymin;
MCNUM mccGuide_End_ToF_Z_ymax;
MCNUM mccGuide_End_ToF_Z_xwidth;
MCNUM mccGuide_End_ToF_Z_yheight;
MCNUM mccGuide_End_ToF_Z_tmin;
MCNUM mccGuide_End_ToF_Z_tmax;
MCNUM mccGuide_End_ToF_Z_dt;
MCNUM mccGuide_End_ToF_Z_restore_neutron;
int mccGuide_End_ToF_Z_nowritefile;

/* Definition parameters for component 'Guide_end_Lam' [114]. */
#define mccGuide_end_Lam_nL 1000
/* Setting parameters for component 'Guide_end_Lam' [114]. */
char mccGuide_end_Lam_filename[16384];
MCNUM mccGuide_end_Lam_xmin;
MCNUM mccGuide_end_Lam_xmax;
MCNUM mccGuide_end_Lam_ymin;
MCNUM mccGuide_end_Lam_ymax;
MCNUM mccGuide_end_Lam_xwidth;
MCNUM mccGuide_end_Lam_yheight;
MCNUM mccGuide_end_Lam_Lmin;
MCNUM mccGuide_end_Lam_Lmax;
MCNUM mccGuide_end_Lam_restore_neutron;
int mccGuide_end_Lam_nowritefile;

/* Definition parameters for component 'Guide_end_divx' [115]. */
#define mccGuide_end_divx_user1 FLT_MAX
#define mccGuide_end_divx_user2 FLT_MAX
#define mccGuide_end_divx_user3 FLT_MAX
/* Setting parameters for component 'Guide_end_divx' [115]. */
MCNUM mccGuide_end_divx_xwidth;
MCNUM mccGuide_end_divx_yheight;
MCNUM mccGuide_end_divx_zdepth;
MCNUM mccGuide_end_divx_xmin;
MCNUM mccGuide_end_divx_xmax;
MCNUM mccGuide_end_divx_ymin;
MCNUM mccGuide_end_divx_ymax;
MCNUM mccGuide_end_divx_zmin;
MCNUM mccGuide_end_divx_zmax;
MCNUM mccGuide_end_divx_bins;
MCNUM mccGuide_end_divx_min;
MCNUM mccGuide_end_divx_max;
MCNUM mccGuide_end_divx_restore_neutron;
MCNUM mccGuide_end_divx_radius;
char mccGuide_end_divx_options[16384];
char mccGuide_end_divx_filename[16384];
char mccGuide_end_divx_geometry[16384];
char mccGuide_end_divx_username1[16384];
char mccGuide_end_divx_username2[16384];
char mccGuide_end_divx_username3[16384];
int mccGuide_end_divx_nowritefile;

/* Definition parameters for component 'Guide_end_divy' [116]. */
#define mccGuide_end_divy_user1 FLT_MAX
#define mccGuide_end_divy_user2 FLT_MAX
#define mccGuide_end_divy_user3 FLT_MAX
/* Setting parameters for component 'Guide_end_divy' [116]. */
MCNUM mccGuide_end_divy_xwidth;
MCNUM mccGuide_end_divy_yheight;
MCNUM mccGuide_end_divy_zdepth;
MCNUM mccGuide_end_divy_xmin;
MCNUM mccGuide_end_divy_xmax;
MCNUM mccGuide_end_divy_ymin;
MCNUM mccGuide_end_divy_ymax;
MCNUM mccGuide_end_divy_zmin;
MCNUM mccGuide_end_divy_zmax;
MCNUM mccGuide_end_divy_bins;
MCNUM mccGuide_end_divy_min;
MCNUM mccGuide_end_divy_max;
MCNUM mccGuide_end_divy_restore_neutron;
MCNUM mccGuide_end_divy_radius;
char mccGuide_end_divy_options[16384];
char mccGuide_end_divy_filename[16384];
char mccGuide_end_divy_geometry[16384];
char mccGuide_end_divy_username1[16384];
char mccGuide_end_divy_username2[16384];
char mccGuide_end_divy_username3[16384];
int mccGuide_end_divy_nowritefile;

/* Setting parameters for component 'Guide_end_PSD' [117]. */
int mccGuide_end_PSD_nx;
int mccGuide_end_PSD_ny;
char mccGuide_end_PSD_filename[16384];
MCNUM mccGuide_end_PSD_xmin;
MCNUM mccGuide_end_PSD_xmax;
MCNUM mccGuide_end_PSD_ymin;
MCNUM mccGuide_end_PSD_ymax;
MCNUM mccGuide_end_PSD_xwidth;
MCNUM mccGuide_end_PSD_yheight;
MCNUM mccGuide_end_PSD_restore_neutron;

/* Setting parameters for component 'SamplePos' [119]. */
int mccSamplePos_nx;
int mccSamplePos_ny;
char mccSamplePos_filename[16384];
MCNUM mccSamplePos_xmin;
MCNUM mccSamplePos_xmax;
MCNUM mccSamplePos_ymin;
MCNUM mccSamplePos_ymax;
MCNUM mccSamplePos_xwidth;
MCNUM mccSamplePos_yheight;
MCNUM mccSamplePos_restore_neutron;

/* Definition parameters for component 'Sample' [120]. */
#define mccSample_powder_format Undefined
/* Setting parameters for component 'Sample' [120]. */
char mccSample_Sqw_coh[16384];
char mccSample_Sqw_inc[16384];
char mccSample_geometry[16384];
MCNUM mccSample_radius;
MCNUM mccSample_thickness;
MCNUM mccSample_xwidth;
MCNUM mccSample_yheight;
MCNUM mccSample_zdepth;
MCNUM mccSample_threshold;
int mccSample_order;
MCNUM mccSample_T;
MCNUM mccSample_verbose;
MCNUM mccSample_d_phi;
int mccSample_concentric;
MCNUM mccSample_rho;
MCNUM mccSample_sigma_abs;
MCNUM mccSample_sigma_coh;
MCNUM mccSample_sigma_inc;
MCNUM mccSample_classical;
MCNUM mccSample_powder_Dd;
MCNUM mccSample_powder_DW;
MCNUM mccSample_powder_Vc;
MCNUM mccSample_density;
MCNUM mccSample_weight;
MCNUM mccSample_p_interact;
MCNUM mccSample_norm;
MCNUM mccSample_powder_barns;
char mccSample_quantum_correction[16384];

/* Definition parameters for component 'An1_ToF' [124]. */
#define mccAn1_ToF_nt 10000
/* Setting parameters for component 'An1_ToF' [124]. */
char mccAn1_ToF_filename[16384];
MCNUM mccAn1_ToF_xmin;
MCNUM mccAn1_ToF_xmax;
MCNUM mccAn1_ToF_ymin;
MCNUM mccAn1_ToF_ymax;
MCNUM mccAn1_ToF_xwidth;
MCNUM mccAn1_ToF_yheight;
MCNUM mccAn1_ToF_tmin;
MCNUM mccAn1_ToF_tmax;
MCNUM mccAn1_ToF_dt;
MCNUM mccAn1_ToF_restore_neutron;
int mccAn1_ToF_nowritefile;

/* Definition parameters for component 'An1_ToF_variable_range' [125]. */
#define mccAn1_ToF_variable_range_nt 200
/* Setting parameters for component 'An1_ToF_variable_range' [125]. */
char mccAn1_ToF_variable_range_filename[16384];
MCNUM mccAn1_ToF_variable_range_xmin;
MCNUM mccAn1_ToF_variable_range_xmax;
MCNUM mccAn1_ToF_variable_range_ymin;
MCNUM mccAn1_ToF_variable_range_ymax;
MCNUM mccAn1_ToF_variable_range_xwidth;
MCNUM mccAn1_ToF_variable_range_yheight;
MCNUM mccAn1_ToF_variable_range_tmin;
MCNUM mccAn1_ToF_variable_range_tmax;
MCNUM mccAn1_ToF_variable_range_dt;
MCNUM mccAn1_ToF_variable_range_restore_neutron;
int mccAn1_ToF_variable_range_nowritefile;

/* Definition parameters for component 'An1_Lam' [126]. */
#define mccAn1_Lam_nL 1000
/* Setting parameters for component 'An1_Lam' [126]. */
char mccAn1_Lam_filename[16384];
MCNUM mccAn1_Lam_xmin;
MCNUM mccAn1_Lam_xmax;
MCNUM mccAn1_Lam_ymin;
MCNUM mccAn1_Lam_ymax;
MCNUM mccAn1_Lam_xwidth;
MCNUM mccAn1_Lam_yheight;
MCNUM mccAn1_Lam_Lmin;
MCNUM mccAn1_Lam_Lmax;
MCNUM mccAn1_Lam_restore_neutron;
int mccAn1_Lam_nowritefile;

/* Definition parameters for component 'An1_Lam_variable_range' [127]. */
#define mccAn1_Lam_variable_range_nL 200
/* Setting parameters for component 'An1_Lam_variable_range' [127]. */
char mccAn1_Lam_variable_range_filename[16384];
MCNUM mccAn1_Lam_variable_range_xmin;
MCNUM mccAn1_Lam_variable_range_xmax;
MCNUM mccAn1_Lam_variable_range_ymin;
MCNUM mccAn1_Lam_variable_range_ymax;
MCNUM mccAn1_Lam_variable_range_xwidth;
MCNUM mccAn1_Lam_variable_range_yheight;
MCNUM mccAn1_Lam_variable_range_Lmin;
MCNUM mccAn1_Lam_variable_range_Lmax;
MCNUM mccAn1_Lam_variable_range_restore_neutron;
int mccAn1_Lam_variable_range_nowritefile;

/* Definition parameters for component 'An1_E' [128]. */
#define mccAn1_E_nE 1000
/* Setting parameters for component 'An1_E' [128]. */
char mccAn1_E_filename[16384];
MCNUM mccAn1_E_xmin;
MCNUM mccAn1_E_xmax;
MCNUM mccAn1_E_ymin;
MCNUM mccAn1_E_ymax;
MCNUM mccAn1_E_xwidth;
MCNUM mccAn1_E_yheight;
MCNUM mccAn1_E_Emin;
MCNUM mccAn1_E_Emax;
MCNUM mccAn1_E_restore_neutron;
int mccAn1_E_nowritefile;

/* Definition parameters for component 'An1_E_variable_range' [129]. */
#define mccAn1_E_variable_range_nE 1000
/* Setting parameters for component 'An1_E_variable_range' [129]. */
char mccAn1_E_variable_range_filename[16384];
MCNUM mccAn1_E_variable_range_xmin;
MCNUM mccAn1_E_variable_range_xmax;
MCNUM mccAn1_E_variable_range_ymin;
MCNUM mccAn1_E_variable_range_ymax;
MCNUM mccAn1_E_variable_range_xwidth;
MCNUM mccAn1_E_variable_range_yheight;
MCNUM mccAn1_E_variable_range_Emin;
MCNUM mccAn1_E_variable_range_Emax;
MCNUM mccAn1_E_variable_range_restore_neutron;
int mccAn1_E_variable_range_nowritefile;

/* Setting parameters for component 'An1' [133]. */
MCNUM mccAn1_xmin;
MCNUM mccAn1_xmax;
MCNUM mccAn1_ymin;
MCNUM mccAn1_ymax;
MCNUM mccAn1_mosaic;
MCNUM mccAn1_dspread;
MCNUM mccAn1_Q;
MCNUM mccAn1_DM;
MCNUM mccAn1_radius;
MCNUM mccAn1_f_doppler;
MCNUM mccAn1_A_doppler;
MCNUM mccAn1_R0;
MCNUM mccAn1_debug;

/* Setting parameters for component 'An2' [134]. */
MCNUM mccAn2_xmin;
MCNUM mccAn2_xmax;
MCNUM mccAn2_ymin;
MCNUM mccAn2_ymax;
MCNUM mccAn2_mosaic;
MCNUM mccAn2_dspread;
MCNUM mccAn2_Q;
MCNUM mccAn2_DM;
MCNUM mccAn2_radius;
MCNUM mccAn2_f_doppler;
MCNUM mccAn2_A_doppler;
MCNUM mccAn2_R0;
MCNUM mccAn2_debug;

/* Setting parameters for component 'An3' [135]. */
MCNUM mccAn3_xmin;
MCNUM mccAn3_xmax;
MCNUM mccAn3_ymin;
MCNUM mccAn3_ymax;
MCNUM mccAn3_mosaic;
MCNUM mccAn3_dspread;
MCNUM mccAn3_Q;
MCNUM mccAn3_DM;
MCNUM mccAn3_radius;
MCNUM mccAn3_f_doppler;
MCNUM mccAn3_A_doppler;
MCNUM mccAn3_R0;
MCNUM mccAn3_debug;

/* Definition parameters for component 'Det1_E' [137]. */
#define mccDet1_E_nE 200
/* Setting parameters for component 'Det1_E' [137]. */
char mccDet1_E_filename[16384];
MCNUM mccDet1_E_xmin;
MCNUM mccDet1_E_xmax;
MCNUM mccDet1_E_ymin;
MCNUM mccDet1_E_ymax;
MCNUM mccDet1_E_xwidth;
MCNUM mccDet1_E_yheight;
MCNUM mccDet1_E_Emin;
MCNUM mccDet1_E_Emax;
MCNUM mccDet1_E_restore_neutron;
int mccDet1_E_nowritefile;

/* Definition parameters for component 'Det1_E_variable_range' [138]. */
#define mccDet1_E_variable_range_nE 200
/* Setting parameters for component 'Det1_E_variable_range' [138]. */
char mccDet1_E_variable_range_filename[16384];
MCNUM mccDet1_E_variable_range_xmin;
MCNUM mccDet1_E_variable_range_xmax;
MCNUM mccDet1_E_variable_range_ymin;
MCNUM mccDet1_E_variable_range_ymax;
MCNUM mccDet1_E_variable_range_xwidth;
MCNUM mccDet1_E_variable_range_yheight;
MCNUM mccDet1_E_variable_range_Emin;
MCNUM mccDet1_E_variable_range_Emax;
MCNUM mccDet1_E_variable_range_restore_neutron;
int mccDet1_E_variable_range_nowritefile;

/* Definition parameters for component 'Det1_Lam' [139]. */
#define mccDet1_Lam_nL 1000
/* Setting parameters for component 'Det1_Lam' [139]. */
char mccDet1_Lam_filename[16384];
MCNUM mccDet1_Lam_xmin;
MCNUM mccDet1_Lam_xmax;
MCNUM mccDet1_Lam_ymin;
MCNUM mccDet1_Lam_ymax;
MCNUM mccDet1_Lam_xwidth;
MCNUM mccDet1_Lam_yheight;
MCNUM mccDet1_Lam_Lmin;
MCNUM mccDet1_Lam_Lmax;
MCNUM mccDet1_Lam_restore_neutron;
int mccDet1_Lam_nowritefile;

/* Definition parameters for component 'Det1_Lam_variable_range' [140]. */
#define mccDet1_Lam_variable_range_nL 1000
/* Setting parameters for component 'Det1_Lam_variable_range' [140]. */
char mccDet1_Lam_variable_range_filename[16384];
MCNUM mccDet1_Lam_variable_range_xmin;
MCNUM mccDet1_Lam_variable_range_xmax;
MCNUM mccDet1_Lam_variable_range_ymin;
MCNUM mccDet1_Lam_variable_range_ymax;
MCNUM mccDet1_Lam_variable_range_xwidth;
MCNUM mccDet1_Lam_variable_range_yheight;
MCNUM mccDet1_Lam_variable_range_Lmin;
MCNUM mccDet1_Lam_variable_range_Lmax;
MCNUM mccDet1_Lam_variable_range_restore_neutron;
int mccDet1_Lam_variable_range_nowritefile;

/* Definition parameters for component 'Det1_ToF' [141]. */
#define mccDet1_ToF_nt 10000
/* Setting parameters for component 'Det1_ToF' [141]. */
char mccDet1_ToF_filename[16384];
MCNUM mccDet1_ToF_xmin;
MCNUM mccDet1_ToF_xmax;
MCNUM mccDet1_ToF_ymin;
MCNUM mccDet1_ToF_ymax;
MCNUM mccDet1_ToF_xwidth;
MCNUM mccDet1_ToF_yheight;
MCNUM mccDet1_ToF_tmin;
MCNUM mccDet1_ToF_tmax;
MCNUM mccDet1_ToF_dt;
MCNUM mccDet1_ToF_restore_neutron;
int mccDet1_ToF_nowritefile;

/* Definition parameters for component 'Det1_ToF_variable_range' [142]. */
#define mccDet1_ToF_variable_range_nt 500
/* Setting parameters for component 'Det1_ToF_variable_range' [142]. */
char mccDet1_ToF_variable_range_filename[16384];
MCNUM mccDet1_ToF_variable_range_xmin;
MCNUM mccDet1_ToF_variable_range_xmax;
MCNUM mccDet1_ToF_variable_range_ymin;
MCNUM mccDet1_ToF_variable_range_ymax;
MCNUM mccDet1_ToF_variable_range_xwidth;
MCNUM mccDet1_ToF_variable_range_yheight;
MCNUM mccDet1_ToF_variable_range_tmin;
MCNUM mccDet1_ToF_variable_range_tmax;
MCNUM mccDet1_ToF_variable_range_dt;
MCNUM mccDet1_ToF_variable_range_restore_neutron;
int mccDet1_ToF_variable_range_nowritefile;

/* Definition parameters for component 'Det1_ToF_variable_range_lessnL' [143]. */
#define mccDet1_ToF_variable_range_lessnL_nt 500
/* Setting parameters for component 'Det1_ToF_variable_range_lessnL' [143]. */
char mccDet1_ToF_variable_range_lessnL_filename[16384];
MCNUM mccDet1_ToF_variable_range_lessnL_xmin;
MCNUM mccDet1_ToF_variable_range_lessnL_xmax;
MCNUM mccDet1_ToF_variable_range_lessnL_ymin;
MCNUM mccDet1_ToF_variable_range_lessnL_ymax;
MCNUM mccDet1_ToF_variable_range_lessnL_xwidth;
MCNUM mccDet1_ToF_variable_range_lessnL_yheight;
MCNUM mccDet1_ToF_variable_range_lessnL_tmin;
MCNUM mccDet1_ToF_variable_range_lessnL_tmax;
MCNUM mccDet1_ToF_variable_range_lessnL_dt;
MCNUM mccDet1_ToF_variable_range_lessnL_restore_neutron;
int mccDet1_ToF_variable_range_lessnL_nowritefile;

/* Definition parameters for component 'PSDcyl' [144]. */
#define mccPSDcyl_user1 FLT_MAX
#define mccPSDcyl_user2 FLT_MAX
#define mccPSDcyl_user3 FLT_MAX
/* Setting parameters for component 'PSDcyl' [144]. */
MCNUM mccPSDcyl_xwidth;
MCNUM mccPSDcyl_yheight;
MCNUM mccPSDcyl_zdepth;
MCNUM mccPSDcyl_xmin;
MCNUM mccPSDcyl_xmax;
MCNUM mccPSDcyl_ymin;
MCNUM mccPSDcyl_ymax;
MCNUM mccPSDcyl_zmin;
MCNUM mccPSDcyl_zmax;
MCNUM mccPSDcyl_bins;
MCNUM mccPSDcyl_min;
MCNUM mccPSDcyl_max;
MCNUM mccPSDcyl_restore_neutron;
MCNUM mccPSDcyl_radius;
char mccPSDcyl_options[16384];
char mccPSDcyl_filename[16384];
char mccPSDcyl_geometry[16384];
char mccPSDcyl_username1[16384];
char mccPSDcyl_username2[16384];
char mccPSDcyl_username3[16384];
int mccPSDcyl_nowritefile;

/* Definition parameters for component 'TOFcyl' [145]. */
#define mccTOFcyl_user1 FLT_MAX
#define mccTOFcyl_user2 FLT_MAX
#define mccTOFcyl_user3 FLT_MAX
/* Setting parameters for component 'TOFcyl' [145]. */
MCNUM mccTOFcyl_xwidth;
MCNUM mccTOFcyl_yheight;
MCNUM mccTOFcyl_zdepth;
MCNUM mccTOFcyl_xmin;
MCNUM mccTOFcyl_xmax;
MCNUM mccTOFcyl_ymin;
MCNUM mccTOFcyl_ymax;
MCNUM mccTOFcyl_zmin;
MCNUM mccTOFcyl_zmax;
MCNUM mccTOFcyl_bins;
MCNUM mccTOFcyl_min;
MCNUM mccTOFcyl_max;
MCNUM mccTOFcyl_restore_neutron;
MCNUM mccTOFcyl_radius;
char mccTOFcyl_options[16384];
char mccTOFcyl_filename[16384];
char mccTOFcyl_geometry[16384];
char mccTOFcyl_username1[16384];
char mccTOFcyl_username2[16384];
char mccTOFcyl_username3[16384];
int mccTOFcyl_nowritefile;

/* User component declarations. */

/* User declarations for component 'Origin' [1]. */
#define mccompcurname  Origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccOrigin_IntermediateCnts
#define StartTime mccOrigin_StartTime
#define EndTime mccOrigin_EndTime
#define CurrentTime mccOrigin_CurrentTime
#define profile mccOrigin_profile
#define percent mccOrigin_percent
#define flag_save mccOrigin_flag_save
#define minutes mccOrigin_minutes
#line 44 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../misc/Progress_bar.comp"
#ifndef PROGRESS_BAR
#define PROGRESS_BAR
#else
#error Only one Progress_bar component may be used in an instrument definition.
#endif

double IntermediateCnts;
time_t StartTime;
time_t EndTime;
time_t CurrentTime;
#line 14901 "./SNS_BASIS.c"
#undef minutes
#undef flag_save
#undef percent
#undef profile
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Source' [2]. */
#define mccompcurname  Source
#define mccompcurtype  ESS_moderator_short
#define mccompcurindex 2
#define l_range mccSource_l_range
#define w_mult mccSource_w_mult
#define size mccSource_size
#define Lmin mccSource_Lmin
#define Lmax mccSource_Lmax
#define dist mccSource_dist
#define focus_xw mccSource_focus_xw
#define focus_yh mccSource_focus_yh
#define nu mccSource_nu
#define T mccSource_T
#define tau mccSource_tau
#define tau1 mccSource_tau1
#define tau2 mccSource_tau2
#define n mccSource_n
#define n2 mccSource_n2
#define chi2 mccSource_chi2
#define I0 mccSource_I0
#define I2 mccSource_I2
#define branch1 mccSource_branch1
#define branch2 mccSource_branch2
#define branchframe mccSource_branchframe
#define target_index mccSource_target_index
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../obsolete/ESS_moderator_short.comp"
  double l_range, w_mult, Delta_t;
#line 14942 "./SNS_BASIS.c"
#undef target_index
#undef branchframe
#undef branch2
#undef branch1
#undef I2
#undef I0
#undef chi2
#undef n2
#undef n
#undef tau2
#undef tau1
#undef tau
#undef T
#undef nu
#undef focus_yh
#undef focus_xw
#undef dist
#undef Lmax
#undef Lmin
#undef size
#undef w_mult
#undef l_range
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'tofSTART' [3]. */
#define mccompcurname  tofSTART
#define mccompcurtype  TOF_monitor
#define mccompcurindex 3
#define nt mcctofSTART_nt
#define TOF_N mcctofSTART_TOF_N
#define TOF_p mcctofSTART_TOF_p
#define TOF_p2 mcctofSTART_TOF_p2
#define t_min mcctofSTART_t_min
#define t_max mcctofSTART_t_max
#define delta_t mcctofSTART_delta_t
#define filename mcctofSTART_filename
#define xmin mcctofSTART_xmin
#define xmax mcctofSTART_xmax
#define ymin mcctofSTART_ymin
#define ymax mcctofSTART_ymax
#define xwidth mcctofSTART_xwidth
#define yheight mcctofSTART_yheight
#define tmin mcctofSTART_tmin
#define tmax mcctofSTART_tmax
#define dt mcctofSTART_dt
#define restore_neutron mcctofSTART_restore_neutron
#define nowritefile mcctofSTART_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 14997 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Source_Lam' [4]. */
#define mccompcurname  Source_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 4
#define nL mccSource_Lam_nL
#define L_N mccSource_Lam_L_N
#define L_p mccSource_Lam_L_p
#define L_p2 mccSource_Lam_L_p2
#define filename mccSource_Lam_filename
#define xmin mccSource_Lam_xmin
#define xmax mccSource_Lam_xmax
#define ymin mccSource_Lam_ymin
#define ymax mccSource_Lam_ymax
#define xwidth mccSource_Lam_xwidth
#define yheight mccSource_Lam_yheight
#define Lmin mccSource_Lam_Lmin
#define Lmax mccSource_Lam_Lmax
#define restore_neutron mccSource_Lam_restore_neutron
#define nowritefile mccSource_Lam_nowritefile
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 15043 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Source_En' [5]. */
#define mccompcurname  Source_En
#define mccompcurtype  E_monitor
#define mccompcurindex 5
#define nE mccSource_En_nE
#define E_N mccSource_En_E_N
#define E_p mccSource_En_E_p
#define E_p2 mccSource_En_E_p2
#define S_p mccSource_En_S_p
#define S_pE mccSource_En_S_pE
#define S_pE2 mccSource_En_S_pE2
#define filename mccSource_En_filename
#define xmin mccSource_En_xmin
#define xmax mccSource_En_xmax
#define ymin mccSource_En_ymin
#define ymax mccSource_En_ymax
#define xwidth mccSource_En_xwidth
#define yheight mccSource_En_yheight
#define Emin mccSource_En_Emin
#define Emax mccSource_En_Emax
#define restore_neutron mccSource_En_restore_neutron
#define nowritefile mccSource_En_nowritefile
#line 60 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
double E_N[nE];
double E_p[nE], E_p2[nE];
double S_p, S_pE, S_pE2;
#line 15089 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap0_start' [6]. */
#define mccompcurname  Gap0_start
#define mccompcurtype  PSD_monitor
#define mccompcurindex 6
#define PSD_N mccGap0_start_PSD_N
#define PSD_p mccGap0_start_PSD_p
#define PSD_p2 mccGap0_start_PSD_p2
#define nx mccGap0_start_nx
#define ny mccGap0_start_ny
#define filename mccGap0_start_filename
#define xmin mccGap0_start_xmin
#define xmax mccGap0_start_xmax
#define ymin mccGap0_start_ymin
#define ymax mccGap0_start_ymax
#define xwidth mccGap0_start_xwidth
#define yheight mccGap0_start_yheight
#define restore_neutron mccGap0_start_restore_neutron
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
  DArray2d PSD_N;
  DArray2d PSD_p;
  DArray2d PSD_p2;
#line 15133 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap0_end_Lam' [7]. */
#define mccompcurname  Gap0_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 7
#define nL mccGap0_end_Lam_nL
#define L_N mccGap0_end_Lam_L_N
#define L_p mccGap0_end_Lam_L_p
#define L_p2 mccGap0_end_Lam_L_p2
#define filename mccGap0_end_Lam_filename
#define xmin mccGap0_end_Lam_xmin
#define xmax mccGap0_end_Lam_xmax
#define ymin mccGap0_end_Lam_ymin
#define ymax mccGap0_end_Lam_ymax
#define xwidth mccGap0_end_Lam_xwidth
#define yheight mccGap0_end_Lam_yheight
#define Lmin mccGap0_end_Lam_Lmin
#define Lmax mccGap0_end_Lam_Lmax
#define restore_neutron mccGap0_end_Lam_restore_neutron
#define nowritefile mccGap0_end_Lam_nowritefile
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 15173 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap0_end_divx' [8]. */
#define mccompcurname  Gap0_end_divx
#define mccompcurtype  Monitor_nD
#define mccompcurindex 8
#define user1 mccGap0_end_divx_user1
#define user2 mccGap0_end_divx_user2
#define user3 mccGap0_end_divx_user3
#define DEFS mccGap0_end_divx_DEFS
#define Vars mccGap0_end_divx_Vars
#define detector mccGap0_end_divx_detector
#define offdata mccGap0_end_divx_offdata
#define xwidth mccGap0_end_divx_xwidth
#define yheight mccGap0_end_divx_yheight
#define zdepth mccGap0_end_divx_zdepth
#define xmin mccGap0_end_divx_xmin
#define xmax mccGap0_end_divx_xmax
#define ymin mccGap0_end_divx_ymin
#define ymax mccGap0_end_divx_ymax
#define zmin mccGap0_end_divx_zmin
#define zmax mccGap0_end_divx_zmax
#define bins mccGap0_end_divx_bins
#define min mccGap0_end_divx_min
#define max mccGap0_end_divx_max
#define restore_neutron mccGap0_end_divx_restore_neutron
#define radius mccGap0_end_divx_radius
#define options mccGap0_end_divx_options
#define filename mccGap0_end_divx_filename
#define geometry mccGap0_end_divx_geometry
#define username1 mccGap0_end_divx_username1
#define username2 mccGap0_end_divx_username2
#define username3 mccGap0_end_divx_username3
#define nowritefile mccGap0_end_divx_nowritefile
#line 223 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
  MonitornD_Defines_type DEFS;
  MonitornD_Variables_type Vars;
  MCDETECTOR detector;
  off_struct offdata;
#line 15230 "./SNS_BASIS.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap0_end_divy' [9]. */
#define mccompcurname  Gap0_end_divy
#define mccompcurtype  Monitor_nD
#define mccompcurindex 9
#define user1 mccGap0_end_divy_user1
#define user2 mccGap0_end_divy_user2
#define user3 mccGap0_end_divy_user3
#define DEFS mccGap0_end_divy_DEFS
#define Vars mccGap0_end_divy_Vars
#define detector mccGap0_end_divy_detector
#define offdata mccGap0_end_divy_offdata
#define xwidth mccGap0_end_divy_xwidth
#define yheight mccGap0_end_divy_yheight
#define zdepth mccGap0_end_divy_zdepth
#define xmin mccGap0_end_divy_xmin
#define xmax mccGap0_end_divy_xmax
#define ymin mccGap0_end_divy_ymin
#define ymax mccGap0_end_divy_ymax
#define zmin mccGap0_end_divy_zmin
#define zmax mccGap0_end_divy_zmax
#define bins mccGap0_end_divy_bins
#define min mccGap0_end_divy_min
#define max mccGap0_end_divy_max
#define restore_neutron mccGap0_end_divy_restore_neutron
#define radius mccGap0_end_divy_radius
#define options mccGap0_end_divy_options
#define filename mccGap0_end_divy_filename
#define geometry mccGap0_end_divy_geometry
#define username1 mccGap0_end_divy_username1
#define username2 mccGap0_end_divy_username2
#define username3 mccGap0_end_divy_username3
#define nowritefile mccGap0_end_divy_nowritefile
#line 223 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
  MonitornD_Defines_type DEFS;
  MonitornD_Variables_type Vars;
  MCDETECTOR detector;
  off_struct offdata;
#line 15300 "./SNS_BASIS.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Core_Vessel_Section' [10]. */
#define mccompcurname  Core_Vessel_Section
#define mccompcurtype  Guide
#define mccompcurindex 10
#define pTable mccCore_Vessel_Section_pTable
#define reflect mccCore_Vessel_Section_reflect
#define w1 mccCore_Vessel_Section_w1
#define h1 mccCore_Vessel_Section_h1
#define w2 mccCore_Vessel_Section_w2
#define h2 mccCore_Vessel_Section_h2
#define l mccCore_Vessel_Section_l
#define R0 mccCore_Vessel_Section_R0
#define Qc mccCore_Vessel_Section_Qc
#define alpha mccCore_Vessel_Section_alpha
#define m mccCore_Vessel_Section_m
#define W mccCore_Vessel_Section_W
#line 70 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide.comp"
t_Table pTable;
#line 15351 "./SNS_BASIS.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap1_start' [11]. */
#define mccompcurname  Gap1_start
#define mccompcurtype  Arm
#define mccompcurindex 11
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap1_start_Lam' [12]. */
#define mccompcurname  Gap1_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 12
#define nL mccGap1_start_Lam_nL
#define L_N mccGap1_start_Lam_L_N
#define L_p mccGap1_start_Lam_L_p
#define L_p2 mccGap1_start_Lam_L_p2
#define filename mccGap1_start_Lam_filename
#define xmin mccGap1_start_Lam_xmin
#define xmax mccGap1_start_Lam_xmax
#define ymin mccGap1_start_Lam_ymin
#define ymax mccGap1_start_Lam_ymax
#define xwidth mccGap1_start_Lam_xwidth
#define yheight mccGap1_start_Lam_yheight
#define Lmin mccGap1_start_Lam_Lmin
#define Lmax mccGap1_start_Lam_Lmax
#define restore_neutron mccGap1_start_Lam_restore_neutron
#define nowritefile mccGap1_start_Lam_nowritefile
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 15398 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap1_end_Lam' [13]. */
#define mccompcurname  Gap1_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 13
#define nL mccGap1_end_Lam_nL
#define L_N mccGap1_end_Lam_L_N
#define L_p mccGap1_end_Lam_L_p
#define L_p2 mccGap1_end_Lam_L_p2
#define filename mccGap1_end_Lam_filename
#define xmin mccGap1_end_Lam_xmin
#define xmax mccGap1_end_Lam_xmax
#define ymin mccGap1_end_Lam_ymin
#define ymax mccGap1_end_Lam_ymax
#define xwidth mccGap1_end_Lam_xwidth
#define yheight mccGap1_end_Lam_yheight
#define Lmin mccGap1_end_Lam_Lmin
#define Lmax mccGap1_end_Lam_Lmax
#define restore_neutron mccGap1_end_Lam_restore_neutron
#define nowritefile mccGap1_end_Lam_nowritefile
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 15440 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap1_end' [14]. */
#define mccompcurname  Gap1_end
#define mccompcurtype  Arm
#define mccompcurindex 14
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Shutter_Guide_Insert' [15]. */
#define mccompcurname  Shutter_Guide_Insert
#define mccompcurtype  Guide_gravity
#define mccompcurindex 15
#define GVars mccShutter_Guide_Insert_GVars
#define pTable mccShutter_Guide_Insert_pTable
#define w1 mccShutter_Guide_Insert_w1
#define h1 mccShutter_Guide_Insert_h1
#define w2 mccShutter_Guide_Insert_w2
#define h2 mccShutter_Guide_Insert_h2
#define l mccShutter_Guide_Insert_l
#define R0 mccShutter_Guide_Insert_R0
#define Qc mccShutter_Guide_Insert_Qc
#define alpha mccShutter_Guide_Insert_alpha
#define m mccShutter_Guide_Insert_m
#define W mccShutter_Guide_Insert_W
#define nslit mccShutter_Guide_Insert_nslit
#define d mccShutter_Guide_Insert_d
#define mleft mccShutter_Guide_Insert_mleft
#define mright mccShutter_Guide_Insert_mright
#define mtop mccShutter_Guide_Insert_mtop
#define mbottom mccShutter_Guide_Insert_mbottom
#define nhslit mccShutter_Guide_Insert_nhslit
#define G mccShutter_Guide_Insert_G
#define aleft mccShutter_Guide_Insert_aleft
#define aright mccShutter_Guide_Insert_aright
#define atop mccShutter_Guide_Insert_atop
#define abottom mccShutter_Guide_Insert_abottom
#define wavy mccShutter_Guide_Insert_wavy
#define wavy_z mccShutter_Guide_Insert_wavy_z
#define wavy_tb mccShutter_Guide_Insert_wavy_tb
#define wavy_lr mccShutter_Guide_Insert_wavy_lr
#define chamfers mccShutter_Guide_Insert_chamfers
#define chamfers_z mccShutter_Guide_Insert_chamfers_z
#define chamfers_lr mccShutter_Guide_Insert_chamfers_lr
#define chamfers_tb mccShutter_Guide_Insert_chamfers_tb
#define nelements mccShutter_Guide_Insert_nelements
#define nu mccShutter_Guide_Insert_nu
#define phase mccShutter_Guide_Insert_phase
#define reflect mccShutter_Guide_Insert_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15511 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Shutter_Guide_Insert_16' [16]. */
#define mccompcurname  Shutter_Guide_Insert_16
#define mccompcurtype  Guide_gravity
#define mccompcurindex 16
#define GVars mccShutter_Guide_Insert_16_GVars
#define pTable mccShutter_Guide_Insert_16_pTable
#define w1 mccShutter_Guide_Insert_16_w1
#define h1 mccShutter_Guide_Insert_16_h1
#define w2 mccShutter_Guide_Insert_16_w2
#define h2 mccShutter_Guide_Insert_16_h2
#define l mccShutter_Guide_Insert_16_l
#define R0 mccShutter_Guide_Insert_16_R0
#define Qc mccShutter_Guide_Insert_16_Qc
#define alpha mccShutter_Guide_Insert_16_alpha
#define m mccShutter_Guide_Insert_16_m
#define W mccShutter_Guide_Insert_16_W
#define nslit mccShutter_Guide_Insert_16_nslit
#define d mccShutter_Guide_Insert_16_d
#define mleft mccShutter_Guide_Insert_16_mleft
#define mright mccShutter_Guide_Insert_16_mright
#define mtop mccShutter_Guide_Insert_16_mtop
#define mbottom mccShutter_Guide_Insert_16_mbottom
#define nhslit mccShutter_Guide_Insert_16_nhslit
#define G mccShutter_Guide_Insert_16_G
#define aleft mccShutter_Guide_Insert_16_aleft
#define aright mccShutter_Guide_Insert_16_aright
#define atop mccShutter_Guide_Insert_16_atop
#define abottom mccShutter_Guide_Insert_16_abottom
#define wavy mccShutter_Guide_Insert_16_wavy
#define wavy_z mccShutter_Guide_Insert_16_wavy_z
#define wavy_tb mccShutter_Guide_Insert_16_wavy_tb
#define wavy_lr mccShutter_Guide_Insert_16_wavy_lr
#define chamfers mccShutter_Guide_Insert_16_chamfers
#define chamfers_z mccShutter_Guide_Insert_16_chamfers_z
#define chamfers_lr mccShutter_Guide_Insert_16_chamfers_lr
#define chamfers_tb mccShutter_Guide_Insert_16_chamfers_tb
#define nelements mccShutter_Guide_Insert_16_nelements
#define nu mccShutter_Guide_Insert_16_nu
#define phase mccShutter_Guide_Insert_16_phase
#define reflect mccShutter_Guide_Insert_16_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15595 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Shutter_Guide_Insert_17' [17]. */
#define mccompcurname  Shutter_Guide_Insert_17
#define mccompcurtype  Guide_gravity
#define mccompcurindex 17
#define GVars mccShutter_Guide_Insert_17_GVars
#define pTable mccShutter_Guide_Insert_17_pTable
#define w1 mccShutter_Guide_Insert_17_w1
#define h1 mccShutter_Guide_Insert_17_h1
#define w2 mccShutter_Guide_Insert_17_w2
#define h2 mccShutter_Guide_Insert_17_h2
#define l mccShutter_Guide_Insert_17_l
#define R0 mccShutter_Guide_Insert_17_R0
#define Qc mccShutter_Guide_Insert_17_Qc
#define alpha mccShutter_Guide_Insert_17_alpha
#define m mccShutter_Guide_Insert_17_m
#define W mccShutter_Guide_Insert_17_W
#define nslit mccShutter_Guide_Insert_17_nslit
#define d mccShutter_Guide_Insert_17_d
#define mleft mccShutter_Guide_Insert_17_mleft
#define mright mccShutter_Guide_Insert_17_mright
#define mtop mccShutter_Guide_Insert_17_mtop
#define mbottom mccShutter_Guide_Insert_17_mbottom
#define nhslit mccShutter_Guide_Insert_17_nhslit
#define G mccShutter_Guide_Insert_17_G
#define aleft mccShutter_Guide_Insert_17_aleft
#define aright mccShutter_Guide_Insert_17_aright
#define atop mccShutter_Guide_Insert_17_atop
#define abottom mccShutter_Guide_Insert_17_abottom
#define wavy mccShutter_Guide_Insert_17_wavy
#define wavy_z mccShutter_Guide_Insert_17_wavy_z
#define wavy_tb mccShutter_Guide_Insert_17_wavy_tb
#define wavy_lr mccShutter_Guide_Insert_17_wavy_lr
#define chamfers mccShutter_Guide_Insert_17_chamfers
#define chamfers_z mccShutter_Guide_Insert_17_chamfers_z
#define chamfers_lr mccShutter_Guide_Insert_17_chamfers_lr
#define chamfers_tb mccShutter_Guide_Insert_17_chamfers_tb
#define nelements mccShutter_Guide_Insert_17_nelements
#define nu mccShutter_Guide_Insert_17_nu
#define phase mccShutter_Guide_Insert_17_phase
#define reflect mccShutter_Guide_Insert_17_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15679 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Shutter_Guide_Insert_18' [18]. */
#define mccompcurname  Shutter_Guide_Insert_18
#define mccompcurtype  Guide_gravity
#define mccompcurindex 18
#define GVars mccShutter_Guide_Insert_18_GVars
#define pTable mccShutter_Guide_Insert_18_pTable
#define w1 mccShutter_Guide_Insert_18_w1
#define h1 mccShutter_Guide_Insert_18_h1
#define w2 mccShutter_Guide_Insert_18_w2
#define h2 mccShutter_Guide_Insert_18_h2
#define l mccShutter_Guide_Insert_18_l
#define R0 mccShutter_Guide_Insert_18_R0
#define Qc mccShutter_Guide_Insert_18_Qc
#define alpha mccShutter_Guide_Insert_18_alpha
#define m mccShutter_Guide_Insert_18_m
#define W mccShutter_Guide_Insert_18_W
#define nslit mccShutter_Guide_Insert_18_nslit
#define d mccShutter_Guide_Insert_18_d
#define mleft mccShutter_Guide_Insert_18_mleft
#define mright mccShutter_Guide_Insert_18_mright
#define mtop mccShutter_Guide_Insert_18_mtop
#define mbottom mccShutter_Guide_Insert_18_mbottom
#define nhslit mccShutter_Guide_Insert_18_nhslit
#define G mccShutter_Guide_Insert_18_G
#define aleft mccShutter_Guide_Insert_18_aleft
#define aright mccShutter_Guide_Insert_18_aright
#define atop mccShutter_Guide_Insert_18_atop
#define abottom mccShutter_Guide_Insert_18_abottom
#define wavy mccShutter_Guide_Insert_18_wavy
#define wavy_z mccShutter_Guide_Insert_18_wavy_z
#define wavy_tb mccShutter_Guide_Insert_18_wavy_tb
#define wavy_lr mccShutter_Guide_Insert_18_wavy_lr
#define chamfers mccShutter_Guide_Insert_18_chamfers
#define chamfers_z mccShutter_Guide_Insert_18_chamfers_z
#define chamfers_lr mccShutter_Guide_Insert_18_chamfers_lr
#define chamfers_tb mccShutter_Guide_Insert_18_chamfers_tb
#define nelements mccShutter_Guide_Insert_18_nelements
#define nu mccShutter_Guide_Insert_18_nu
#define phase mccShutter_Guide_Insert_18_phase
#define reflect mccShutter_Guide_Insert_18_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15763 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Shutter_Guide_Insert_19' [19]. */
#define mccompcurname  Shutter_Guide_Insert_19
#define mccompcurtype  Guide_gravity
#define mccompcurindex 19
#define GVars mccShutter_Guide_Insert_19_GVars
#define pTable mccShutter_Guide_Insert_19_pTable
#define w1 mccShutter_Guide_Insert_19_w1
#define h1 mccShutter_Guide_Insert_19_h1
#define w2 mccShutter_Guide_Insert_19_w2
#define h2 mccShutter_Guide_Insert_19_h2
#define l mccShutter_Guide_Insert_19_l
#define R0 mccShutter_Guide_Insert_19_R0
#define Qc mccShutter_Guide_Insert_19_Qc
#define alpha mccShutter_Guide_Insert_19_alpha
#define m mccShutter_Guide_Insert_19_m
#define W mccShutter_Guide_Insert_19_W
#define nslit mccShutter_Guide_Insert_19_nslit
#define d mccShutter_Guide_Insert_19_d
#define mleft mccShutter_Guide_Insert_19_mleft
#define mright mccShutter_Guide_Insert_19_mright
#define mtop mccShutter_Guide_Insert_19_mtop
#define mbottom mccShutter_Guide_Insert_19_mbottom
#define nhslit mccShutter_Guide_Insert_19_nhslit
#define G mccShutter_Guide_Insert_19_G
#define aleft mccShutter_Guide_Insert_19_aleft
#define aright mccShutter_Guide_Insert_19_aright
#define atop mccShutter_Guide_Insert_19_atop
#define abottom mccShutter_Guide_Insert_19_abottom
#define wavy mccShutter_Guide_Insert_19_wavy
#define wavy_z mccShutter_Guide_Insert_19_wavy_z
#define wavy_tb mccShutter_Guide_Insert_19_wavy_tb
#define wavy_lr mccShutter_Guide_Insert_19_wavy_lr
#define chamfers mccShutter_Guide_Insert_19_chamfers
#define chamfers_z mccShutter_Guide_Insert_19_chamfers_z
#define chamfers_lr mccShutter_Guide_Insert_19_chamfers_lr
#define chamfers_tb mccShutter_Guide_Insert_19_chamfers_tb
#define nelements mccShutter_Guide_Insert_19_nelements
#define nu mccShutter_Guide_Insert_19_nu
#define phase mccShutter_Guide_Insert_19_phase
#define reflect mccShutter_Guide_Insert_19_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15847 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Shutter_Guide_Insert_20' [20]. */
#define mccompcurname  Shutter_Guide_Insert_20
#define mccompcurtype  Guide_gravity
#define mccompcurindex 20
#define GVars mccShutter_Guide_Insert_20_GVars
#define pTable mccShutter_Guide_Insert_20_pTable
#define w1 mccShutter_Guide_Insert_20_w1
#define h1 mccShutter_Guide_Insert_20_h1
#define w2 mccShutter_Guide_Insert_20_w2
#define h2 mccShutter_Guide_Insert_20_h2
#define l mccShutter_Guide_Insert_20_l
#define R0 mccShutter_Guide_Insert_20_R0
#define Qc mccShutter_Guide_Insert_20_Qc
#define alpha mccShutter_Guide_Insert_20_alpha
#define m mccShutter_Guide_Insert_20_m
#define W mccShutter_Guide_Insert_20_W
#define nslit mccShutter_Guide_Insert_20_nslit
#define d mccShutter_Guide_Insert_20_d
#define mleft mccShutter_Guide_Insert_20_mleft
#define mright mccShutter_Guide_Insert_20_mright
#define mtop mccShutter_Guide_Insert_20_mtop
#define mbottom mccShutter_Guide_Insert_20_mbottom
#define nhslit mccShutter_Guide_Insert_20_nhslit
#define G mccShutter_Guide_Insert_20_G
#define aleft mccShutter_Guide_Insert_20_aleft
#define aright mccShutter_Guide_Insert_20_aright
#define atop mccShutter_Guide_Insert_20_atop
#define abottom mccShutter_Guide_Insert_20_abottom
#define wavy mccShutter_Guide_Insert_20_wavy
#define wavy_z mccShutter_Guide_Insert_20_wavy_z
#define wavy_tb mccShutter_Guide_Insert_20_wavy_tb
#define wavy_lr mccShutter_Guide_Insert_20_wavy_lr
#define chamfers mccShutter_Guide_Insert_20_chamfers
#define chamfers_z mccShutter_Guide_Insert_20_chamfers_z
#define chamfers_lr mccShutter_Guide_Insert_20_chamfers_lr
#define chamfers_tb mccShutter_Guide_Insert_20_chamfers_tb
#define nelements mccShutter_Guide_Insert_20_nelements
#define nu mccShutter_Guide_Insert_20_nu
#define phase mccShutter_Guide_Insert_20_phase
#define reflect mccShutter_Guide_Insert_20_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15931 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Shutter_Guide_Insert_21' [21]. */
#define mccompcurname  Shutter_Guide_Insert_21
#define mccompcurtype  Guide_gravity
#define mccompcurindex 21
#define GVars mccShutter_Guide_Insert_21_GVars
#define pTable mccShutter_Guide_Insert_21_pTable
#define w1 mccShutter_Guide_Insert_21_w1
#define h1 mccShutter_Guide_Insert_21_h1
#define w2 mccShutter_Guide_Insert_21_w2
#define h2 mccShutter_Guide_Insert_21_h2
#define l mccShutter_Guide_Insert_21_l
#define R0 mccShutter_Guide_Insert_21_R0
#define Qc mccShutter_Guide_Insert_21_Qc
#define alpha mccShutter_Guide_Insert_21_alpha
#define m mccShutter_Guide_Insert_21_m
#define W mccShutter_Guide_Insert_21_W
#define nslit mccShutter_Guide_Insert_21_nslit
#define d mccShutter_Guide_Insert_21_d
#define mleft mccShutter_Guide_Insert_21_mleft
#define mright mccShutter_Guide_Insert_21_mright
#define mtop mccShutter_Guide_Insert_21_mtop
#define mbottom mccShutter_Guide_Insert_21_mbottom
#define nhslit mccShutter_Guide_Insert_21_nhslit
#define G mccShutter_Guide_Insert_21_G
#define aleft mccShutter_Guide_Insert_21_aleft
#define aright mccShutter_Guide_Insert_21_aright
#define atop mccShutter_Guide_Insert_21_atop
#define abottom mccShutter_Guide_Insert_21_abottom
#define wavy mccShutter_Guide_Insert_21_wavy
#define wavy_z mccShutter_Guide_Insert_21_wavy_z
#define wavy_tb mccShutter_Guide_Insert_21_wavy_tb
#define wavy_lr mccShutter_Guide_Insert_21_wavy_lr
#define chamfers mccShutter_Guide_Insert_21_chamfers
#define chamfers_z mccShutter_Guide_Insert_21_chamfers_z
#define chamfers_lr mccShutter_Guide_Insert_21_chamfers_lr
#define chamfers_tb mccShutter_Guide_Insert_21_chamfers_tb
#define nelements mccShutter_Guide_Insert_21_nelements
#define nu mccShutter_Guide_Insert_21_nu
#define phase mccShutter_Guide_Insert_21_phase
#define reflect mccShutter_Guide_Insert_21_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16015 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Shutter_Guide_Insert_short' [22]. */
#define mccompcurname  Shutter_Guide_Insert_short
#define mccompcurtype  Guide_gravity
#define mccompcurindex 22
#define GVars mccShutter_Guide_Insert_short_GVars
#define pTable mccShutter_Guide_Insert_short_pTable
#define w1 mccShutter_Guide_Insert_short_w1
#define h1 mccShutter_Guide_Insert_short_h1
#define w2 mccShutter_Guide_Insert_short_w2
#define h2 mccShutter_Guide_Insert_short_h2
#define l mccShutter_Guide_Insert_short_l
#define R0 mccShutter_Guide_Insert_short_R0
#define Qc mccShutter_Guide_Insert_short_Qc
#define alpha mccShutter_Guide_Insert_short_alpha
#define m mccShutter_Guide_Insert_short_m
#define W mccShutter_Guide_Insert_short_W
#define nslit mccShutter_Guide_Insert_short_nslit
#define d mccShutter_Guide_Insert_short_d
#define mleft mccShutter_Guide_Insert_short_mleft
#define mright mccShutter_Guide_Insert_short_mright
#define mtop mccShutter_Guide_Insert_short_mtop
#define mbottom mccShutter_Guide_Insert_short_mbottom
#define nhslit mccShutter_Guide_Insert_short_nhslit
#define G mccShutter_Guide_Insert_short_G
#define aleft mccShutter_Guide_Insert_short_aleft
#define aright mccShutter_Guide_Insert_short_aright
#define atop mccShutter_Guide_Insert_short_atop
#define abottom mccShutter_Guide_Insert_short_abottom
#define wavy mccShutter_Guide_Insert_short_wavy
#define wavy_z mccShutter_Guide_Insert_short_wavy_z
#define wavy_tb mccShutter_Guide_Insert_short_wavy_tb
#define wavy_lr mccShutter_Guide_Insert_short_wavy_lr
#define chamfers mccShutter_Guide_Insert_short_chamfers
#define chamfers_z mccShutter_Guide_Insert_short_chamfers_z
#define chamfers_lr mccShutter_Guide_Insert_short_chamfers_lr
#define chamfers_tb mccShutter_Guide_Insert_short_chamfers_tb
#define nelements mccShutter_Guide_Insert_short_nelements
#define nu mccShutter_Guide_Insert_short_nu
#define phase mccShutter_Guide_Insert_short_phase
#define reflect mccShutter_Guide_Insert_short_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16099 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap2_start' [23]. */
#define mccompcurname  Gap2_start
#define mccompcurtype  Arm
#define mccompcurindex 23
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap2_start_Lam' [24]. */
#define mccompcurname  Gap2_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 24
#define nL mccGap2_start_Lam_nL
#define L_N mccGap2_start_Lam_L_N
#define L_p mccGap2_start_Lam_L_p
#define L_p2 mccGap2_start_Lam_L_p2
#define filename mccGap2_start_Lam_filename
#define xmin mccGap2_start_Lam_xmin
#define xmax mccGap2_start_Lam_xmax
#define ymin mccGap2_start_Lam_ymin
#define ymax mccGap2_start_Lam_ymax
#define xwidth mccGap2_start_Lam_xwidth
#define yheight mccGap2_start_Lam_yheight
#define Lmin mccGap2_start_Lam_Lmin
#define Lmax mccGap2_start_Lam_Lmax
#define restore_neutron mccGap2_start_Lam_restore_neutron
#define nowritefile mccGap2_start_Lam_nowritefile
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 16170 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap2_start_PSD' [25]. */
#define mccompcurname  Gap2_start_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 25
#define PSD_N mccGap2_start_PSD_PSD_N
#define PSD_p mccGap2_start_PSD_PSD_p
#define PSD_p2 mccGap2_start_PSD_PSD_p2
#define nx mccGap2_start_PSD_nx
#define ny mccGap2_start_PSD_ny
#define filename mccGap2_start_PSD_filename
#define xmin mccGap2_start_PSD_xmin
#define xmax mccGap2_start_PSD_xmax
#define ymin mccGap2_start_PSD_ymin
#define ymax mccGap2_start_PSD_ymax
#define xwidth mccGap2_start_PSD_xwidth
#define yheight mccGap2_start_PSD_yheight
#define restore_neutron mccGap2_start_PSD_restore_neutron
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
  DArray2d PSD_N;
  DArray2d PSD_p;
  DArray2d PSD_p2;
#line 16211 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap2_end_Lam' [26]. */
#define mccompcurname  Gap2_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 26
#define nL mccGap2_end_Lam_nL
#define L_N mccGap2_end_Lam_L_N
#define L_p mccGap2_end_Lam_L_p
#define L_p2 mccGap2_end_Lam_L_p2
#define filename mccGap2_end_Lam_filename
#define xmin mccGap2_end_Lam_xmin
#define xmax mccGap2_end_Lam_xmax
#define ymin mccGap2_end_Lam_ymin
#define ymax mccGap2_end_Lam_ymax
#define xwidth mccGap2_end_Lam_xwidth
#define yheight mccGap2_end_Lam_yheight
#define Lmin mccGap2_end_Lam_Lmin
#define Lmax mccGap2_end_Lam_Lmax
#define restore_neutron mccGap2_end_Lam_restore_neutron
#define nowritefile mccGap2_end_Lam_nowritefile
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 16251 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap2_end_PSD' [27]. */
#define mccompcurname  Gap2_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 27
#define PSD_N mccGap2_end_PSD_PSD_N
#define PSD_p mccGap2_end_PSD_PSD_p
#define PSD_p2 mccGap2_end_PSD_PSD_p2
#define nx mccGap2_end_PSD_nx
#define ny mccGap2_end_PSD_ny
#define filename mccGap2_end_PSD_filename
#define xmin mccGap2_end_PSD_xmin
#define xmax mccGap2_end_PSD_xmax
#define ymin mccGap2_end_PSD_ymin
#define ymax mccGap2_end_PSD_ymax
#define xwidth mccGap2_end_PSD_xwidth
#define yheight mccGap2_end_PSD_yheight
#define restore_neutron mccGap2_end_PSD_restore_neutron
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
  DArray2d PSD_N;
  DArray2d PSD_p;
  DArray2d PSD_p2;
#line 16292 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap2_end' [28]. */
#define mccompcurname  Gap2_end
#define mccompcurtype  Arm
#define mccompcurindex 28
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_I' [29]. */
#define mccompcurname  Curved_Guide_Section_I
#define mccompcurtype  Guide_gravity
#define mccompcurindex 29
#define GVars mccCurved_Guide_Section_I_GVars
#define pTable mccCurved_Guide_Section_I_pTable
#define w1 mccCurved_Guide_Section_I_w1
#define h1 mccCurved_Guide_Section_I_h1
#define w2 mccCurved_Guide_Section_I_w2
#define h2 mccCurved_Guide_Section_I_h2
#define l mccCurved_Guide_Section_I_l
#define R0 mccCurved_Guide_Section_I_R0
#define Qc mccCurved_Guide_Section_I_Qc
#define alpha mccCurved_Guide_Section_I_alpha
#define m mccCurved_Guide_Section_I_m
#define W mccCurved_Guide_Section_I_W
#define nslit mccCurved_Guide_Section_I_nslit
#define d mccCurved_Guide_Section_I_d
#define mleft mccCurved_Guide_Section_I_mleft
#define mright mccCurved_Guide_Section_I_mright
#define mtop mccCurved_Guide_Section_I_mtop
#define mbottom mccCurved_Guide_Section_I_mbottom
#define nhslit mccCurved_Guide_Section_I_nhslit
#define G mccCurved_Guide_Section_I_G
#define aleft mccCurved_Guide_Section_I_aleft
#define aright mccCurved_Guide_Section_I_aright
#define atop mccCurved_Guide_Section_I_atop
#define abottom mccCurved_Guide_Section_I_abottom
#define wavy mccCurved_Guide_Section_I_wavy
#define wavy_z mccCurved_Guide_Section_I_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_wavy_lr
#define chamfers mccCurved_Guide_Section_I_chamfers
#define chamfers_z mccCurved_Guide_Section_I_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_chamfers_tb
#define nelements mccCurved_Guide_Section_I_nelements
#define nu mccCurved_Guide_Section_I_nu
#define phase mccCurved_Guide_Section_I_phase
#define reflect mccCurved_Guide_Section_I_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16361 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_I_30' [30]. */
#define mccompcurname  Curved_Guide_Section_I_30
#define mccompcurtype  Guide_gravity
#define mccompcurindex 30
#define GVars mccCurved_Guide_Section_I_30_GVars
#define pTable mccCurved_Guide_Section_I_30_pTable
#define w1 mccCurved_Guide_Section_I_30_w1
#define h1 mccCurved_Guide_Section_I_30_h1
#define w2 mccCurved_Guide_Section_I_30_w2
#define h2 mccCurved_Guide_Section_I_30_h2
#define l mccCurved_Guide_Section_I_30_l
#define R0 mccCurved_Guide_Section_I_30_R0
#define Qc mccCurved_Guide_Section_I_30_Qc
#define alpha mccCurved_Guide_Section_I_30_alpha
#define m mccCurved_Guide_Section_I_30_m
#define W mccCurved_Guide_Section_I_30_W
#define nslit mccCurved_Guide_Section_I_30_nslit
#define d mccCurved_Guide_Section_I_30_d
#define mleft mccCurved_Guide_Section_I_30_mleft
#define mright mccCurved_Guide_Section_I_30_mright
#define mtop mccCurved_Guide_Section_I_30_mtop
#define mbottom mccCurved_Guide_Section_I_30_mbottom
#define nhslit mccCurved_Guide_Section_I_30_nhslit
#define G mccCurved_Guide_Section_I_30_G
#define aleft mccCurved_Guide_Section_I_30_aleft
#define aright mccCurved_Guide_Section_I_30_aright
#define atop mccCurved_Guide_Section_I_30_atop
#define abottom mccCurved_Guide_Section_I_30_abottom
#define wavy mccCurved_Guide_Section_I_30_wavy
#define wavy_z mccCurved_Guide_Section_I_30_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_30_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_30_wavy_lr
#define chamfers mccCurved_Guide_Section_I_30_chamfers
#define chamfers_z mccCurved_Guide_Section_I_30_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_30_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_30_chamfers_tb
#define nelements mccCurved_Guide_Section_I_30_nelements
#define nu mccCurved_Guide_Section_I_30_nu
#define phase mccCurved_Guide_Section_I_30_phase
#define reflect mccCurved_Guide_Section_I_30_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16445 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_I_31' [31]. */
#define mccompcurname  Curved_Guide_Section_I_31
#define mccompcurtype  Guide_gravity
#define mccompcurindex 31
#define GVars mccCurved_Guide_Section_I_31_GVars
#define pTable mccCurved_Guide_Section_I_31_pTable
#define w1 mccCurved_Guide_Section_I_31_w1
#define h1 mccCurved_Guide_Section_I_31_h1
#define w2 mccCurved_Guide_Section_I_31_w2
#define h2 mccCurved_Guide_Section_I_31_h2
#define l mccCurved_Guide_Section_I_31_l
#define R0 mccCurved_Guide_Section_I_31_R0
#define Qc mccCurved_Guide_Section_I_31_Qc
#define alpha mccCurved_Guide_Section_I_31_alpha
#define m mccCurved_Guide_Section_I_31_m
#define W mccCurved_Guide_Section_I_31_W
#define nslit mccCurved_Guide_Section_I_31_nslit
#define d mccCurved_Guide_Section_I_31_d
#define mleft mccCurved_Guide_Section_I_31_mleft
#define mright mccCurved_Guide_Section_I_31_mright
#define mtop mccCurved_Guide_Section_I_31_mtop
#define mbottom mccCurved_Guide_Section_I_31_mbottom
#define nhslit mccCurved_Guide_Section_I_31_nhslit
#define G mccCurved_Guide_Section_I_31_G
#define aleft mccCurved_Guide_Section_I_31_aleft
#define aright mccCurved_Guide_Section_I_31_aright
#define atop mccCurved_Guide_Section_I_31_atop
#define abottom mccCurved_Guide_Section_I_31_abottom
#define wavy mccCurved_Guide_Section_I_31_wavy
#define wavy_z mccCurved_Guide_Section_I_31_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_31_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_31_wavy_lr
#define chamfers mccCurved_Guide_Section_I_31_chamfers
#define chamfers_z mccCurved_Guide_Section_I_31_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_31_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_31_chamfers_tb
#define nelements mccCurved_Guide_Section_I_31_nelements
#define nu mccCurved_Guide_Section_I_31_nu
#define phase mccCurved_Guide_Section_I_31_phase
#define reflect mccCurved_Guide_Section_I_31_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16529 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_I_32' [32]. */
#define mccompcurname  Curved_Guide_Section_I_32
#define mccompcurtype  Guide_gravity
#define mccompcurindex 32
#define GVars mccCurved_Guide_Section_I_32_GVars
#define pTable mccCurved_Guide_Section_I_32_pTable
#define w1 mccCurved_Guide_Section_I_32_w1
#define h1 mccCurved_Guide_Section_I_32_h1
#define w2 mccCurved_Guide_Section_I_32_w2
#define h2 mccCurved_Guide_Section_I_32_h2
#define l mccCurved_Guide_Section_I_32_l
#define R0 mccCurved_Guide_Section_I_32_R0
#define Qc mccCurved_Guide_Section_I_32_Qc
#define alpha mccCurved_Guide_Section_I_32_alpha
#define m mccCurved_Guide_Section_I_32_m
#define W mccCurved_Guide_Section_I_32_W
#define nslit mccCurved_Guide_Section_I_32_nslit
#define d mccCurved_Guide_Section_I_32_d
#define mleft mccCurved_Guide_Section_I_32_mleft
#define mright mccCurved_Guide_Section_I_32_mright
#define mtop mccCurved_Guide_Section_I_32_mtop
#define mbottom mccCurved_Guide_Section_I_32_mbottom
#define nhslit mccCurved_Guide_Section_I_32_nhslit
#define G mccCurved_Guide_Section_I_32_G
#define aleft mccCurved_Guide_Section_I_32_aleft
#define aright mccCurved_Guide_Section_I_32_aright
#define atop mccCurved_Guide_Section_I_32_atop
#define abottom mccCurved_Guide_Section_I_32_abottom
#define wavy mccCurved_Guide_Section_I_32_wavy
#define wavy_z mccCurved_Guide_Section_I_32_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_32_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_32_wavy_lr
#define chamfers mccCurved_Guide_Section_I_32_chamfers
#define chamfers_z mccCurved_Guide_Section_I_32_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_32_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_32_chamfers_tb
#define nelements mccCurved_Guide_Section_I_32_nelements
#define nu mccCurved_Guide_Section_I_32_nu
#define phase mccCurved_Guide_Section_I_32_phase
#define reflect mccCurved_Guide_Section_I_32_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16613 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_I_33' [33]. */
#define mccompcurname  Curved_Guide_Section_I_33
#define mccompcurtype  Guide_gravity
#define mccompcurindex 33
#define GVars mccCurved_Guide_Section_I_33_GVars
#define pTable mccCurved_Guide_Section_I_33_pTable
#define w1 mccCurved_Guide_Section_I_33_w1
#define h1 mccCurved_Guide_Section_I_33_h1
#define w2 mccCurved_Guide_Section_I_33_w2
#define h2 mccCurved_Guide_Section_I_33_h2
#define l mccCurved_Guide_Section_I_33_l
#define R0 mccCurved_Guide_Section_I_33_R0
#define Qc mccCurved_Guide_Section_I_33_Qc
#define alpha mccCurved_Guide_Section_I_33_alpha
#define m mccCurved_Guide_Section_I_33_m
#define W mccCurved_Guide_Section_I_33_W
#define nslit mccCurved_Guide_Section_I_33_nslit
#define d mccCurved_Guide_Section_I_33_d
#define mleft mccCurved_Guide_Section_I_33_mleft
#define mright mccCurved_Guide_Section_I_33_mright
#define mtop mccCurved_Guide_Section_I_33_mtop
#define mbottom mccCurved_Guide_Section_I_33_mbottom
#define nhslit mccCurved_Guide_Section_I_33_nhslit
#define G mccCurved_Guide_Section_I_33_G
#define aleft mccCurved_Guide_Section_I_33_aleft
#define aright mccCurved_Guide_Section_I_33_aright
#define atop mccCurved_Guide_Section_I_33_atop
#define abottom mccCurved_Guide_Section_I_33_abottom
#define wavy mccCurved_Guide_Section_I_33_wavy
#define wavy_z mccCurved_Guide_Section_I_33_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_33_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_33_wavy_lr
#define chamfers mccCurved_Guide_Section_I_33_chamfers
#define chamfers_z mccCurved_Guide_Section_I_33_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_33_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_33_chamfers_tb
#define nelements mccCurved_Guide_Section_I_33_nelements
#define nu mccCurved_Guide_Section_I_33_nu
#define phase mccCurved_Guide_Section_I_33_phase
#define reflect mccCurved_Guide_Section_I_33_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16697 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_I_34' [34]. */
#define mccompcurname  Curved_Guide_Section_I_34
#define mccompcurtype  Guide_gravity
#define mccompcurindex 34
#define GVars mccCurved_Guide_Section_I_34_GVars
#define pTable mccCurved_Guide_Section_I_34_pTable
#define w1 mccCurved_Guide_Section_I_34_w1
#define h1 mccCurved_Guide_Section_I_34_h1
#define w2 mccCurved_Guide_Section_I_34_w2
#define h2 mccCurved_Guide_Section_I_34_h2
#define l mccCurved_Guide_Section_I_34_l
#define R0 mccCurved_Guide_Section_I_34_R0
#define Qc mccCurved_Guide_Section_I_34_Qc
#define alpha mccCurved_Guide_Section_I_34_alpha
#define m mccCurved_Guide_Section_I_34_m
#define W mccCurved_Guide_Section_I_34_W
#define nslit mccCurved_Guide_Section_I_34_nslit
#define d mccCurved_Guide_Section_I_34_d
#define mleft mccCurved_Guide_Section_I_34_mleft
#define mright mccCurved_Guide_Section_I_34_mright
#define mtop mccCurved_Guide_Section_I_34_mtop
#define mbottom mccCurved_Guide_Section_I_34_mbottom
#define nhslit mccCurved_Guide_Section_I_34_nhslit
#define G mccCurved_Guide_Section_I_34_G
#define aleft mccCurved_Guide_Section_I_34_aleft
#define aright mccCurved_Guide_Section_I_34_aright
#define atop mccCurved_Guide_Section_I_34_atop
#define abottom mccCurved_Guide_Section_I_34_abottom
#define wavy mccCurved_Guide_Section_I_34_wavy
#define wavy_z mccCurved_Guide_Section_I_34_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_34_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_34_wavy_lr
#define chamfers mccCurved_Guide_Section_I_34_chamfers
#define chamfers_z mccCurved_Guide_Section_I_34_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_34_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_34_chamfers_tb
#define nelements mccCurved_Guide_Section_I_34_nelements
#define nu mccCurved_Guide_Section_I_34_nu
#define phase mccCurved_Guide_Section_I_34_phase
#define reflect mccCurved_Guide_Section_I_34_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16781 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_I_35' [35]. */
#define mccompcurname  Curved_Guide_Section_I_35
#define mccompcurtype  Guide_gravity
#define mccompcurindex 35
#define GVars mccCurved_Guide_Section_I_35_GVars
#define pTable mccCurved_Guide_Section_I_35_pTable
#define w1 mccCurved_Guide_Section_I_35_w1
#define h1 mccCurved_Guide_Section_I_35_h1
#define w2 mccCurved_Guide_Section_I_35_w2
#define h2 mccCurved_Guide_Section_I_35_h2
#define l mccCurved_Guide_Section_I_35_l
#define R0 mccCurved_Guide_Section_I_35_R0
#define Qc mccCurved_Guide_Section_I_35_Qc
#define alpha mccCurved_Guide_Section_I_35_alpha
#define m mccCurved_Guide_Section_I_35_m
#define W mccCurved_Guide_Section_I_35_W
#define nslit mccCurved_Guide_Section_I_35_nslit
#define d mccCurved_Guide_Section_I_35_d
#define mleft mccCurved_Guide_Section_I_35_mleft
#define mright mccCurved_Guide_Section_I_35_mright
#define mtop mccCurved_Guide_Section_I_35_mtop
#define mbottom mccCurved_Guide_Section_I_35_mbottom
#define nhslit mccCurved_Guide_Section_I_35_nhslit
#define G mccCurved_Guide_Section_I_35_G
#define aleft mccCurved_Guide_Section_I_35_aleft
#define aright mccCurved_Guide_Section_I_35_aright
#define atop mccCurved_Guide_Section_I_35_atop
#define abottom mccCurved_Guide_Section_I_35_abottom
#define wavy mccCurved_Guide_Section_I_35_wavy
#define wavy_z mccCurved_Guide_Section_I_35_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_35_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_35_wavy_lr
#define chamfers mccCurved_Guide_Section_I_35_chamfers
#define chamfers_z mccCurved_Guide_Section_I_35_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_35_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_35_chamfers_tb
#define nelements mccCurved_Guide_Section_I_35_nelements
#define nu mccCurved_Guide_Section_I_35_nu
#define phase mccCurved_Guide_Section_I_35_phase
#define reflect mccCurved_Guide_Section_I_35_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16865 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_I_36' [36]. */
#define mccompcurname  Curved_Guide_Section_I_36
#define mccompcurtype  Guide_gravity
#define mccompcurindex 36
#define GVars mccCurved_Guide_Section_I_36_GVars
#define pTable mccCurved_Guide_Section_I_36_pTable
#define w1 mccCurved_Guide_Section_I_36_w1
#define h1 mccCurved_Guide_Section_I_36_h1
#define w2 mccCurved_Guide_Section_I_36_w2
#define h2 mccCurved_Guide_Section_I_36_h2
#define l mccCurved_Guide_Section_I_36_l
#define R0 mccCurved_Guide_Section_I_36_R0
#define Qc mccCurved_Guide_Section_I_36_Qc
#define alpha mccCurved_Guide_Section_I_36_alpha
#define m mccCurved_Guide_Section_I_36_m
#define W mccCurved_Guide_Section_I_36_W
#define nslit mccCurved_Guide_Section_I_36_nslit
#define d mccCurved_Guide_Section_I_36_d
#define mleft mccCurved_Guide_Section_I_36_mleft
#define mright mccCurved_Guide_Section_I_36_mright
#define mtop mccCurved_Guide_Section_I_36_mtop
#define mbottom mccCurved_Guide_Section_I_36_mbottom
#define nhslit mccCurved_Guide_Section_I_36_nhslit
#define G mccCurved_Guide_Section_I_36_G
#define aleft mccCurved_Guide_Section_I_36_aleft
#define aright mccCurved_Guide_Section_I_36_aright
#define atop mccCurved_Guide_Section_I_36_atop
#define abottom mccCurved_Guide_Section_I_36_abottom
#define wavy mccCurved_Guide_Section_I_36_wavy
#define wavy_z mccCurved_Guide_Section_I_36_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_36_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_36_wavy_lr
#define chamfers mccCurved_Guide_Section_I_36_chamfers
#define chamfers_z mccCurved_Guide_Section_I_36_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_36_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_36_chamfers_tb
#define nelements mccCurved_Guide_Section_I_36_nelements
#define nu mccCurved_Guide_Section_I_36_nu
#define phase mccCurved_Guide_Section_I_36_phase
#define reflect mccCurved_Guide_Section_I_36_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16949 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_I_37' [37]. */
#define mccompcurname  Curved_Guide_Section_I_37
#define mccompcurtype  Guide_gravity
#define mccompcurindex 37
#define GVars mccCurved_Guide_Section_I_37_GVars
#define pTable mccCurved_Guide_Section_I_37_pTable
#define w1 mccCurved_Guide_Section_I_37_w1
#define h1 mccCurved_Guide_Section_I_37_h1
#define w2 mccCurved_Guide_Section_I_37_w2
#define h2 mccCurved_Guide_Section_I_37_h2
#define l mccCurved_Guide_Section_I_37_l
#define R0 mccCurved_Guide_Section_I_37_R0
#define Qc mccCurved_Guide_Section_I_37_Qc
#define alpha mccCurved_Guide_Section_I_37_alpha
#define m mccCurved_Guide_Section_I_37_m
#define W mccCurved_Guide_Section_I_37_W
#define nslit mccCurved_Guide_Section_I_37_nslit
#define d mccCurved_Guide_Section_I_37_d
#define mleft mccCurved_Guide_Section_I_37_mleft
#define mright mccCurved_Guide_Section_I_37_mright
#define mtop mccCurved_Guide_Section_I_37_mtop
#define mbottom mccCurved_Guide_Section_I_37_mbottom
#define nhslit mccCurved_Guide_Section_I_37_nhslit
#define G mccCurved_Guide_Section_I_37_G
#define aleft mccCurved_Guide_Section_I_37_aleft
#define aright mccCurved_Guide_Section_I_37_aright
#define atop mccCurved_Guide_Section_I_37_atop
#define abottom mccCurved_Guide_Section_I_37_abottom
#define wavy mccCurved_Guide_Section_I_37_wavy
#define wavy_z mccCurved_Guide_Section_I_37_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_37_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_37_wavy_lr
#define chamfers mccCurved_Guide_Section_I_37_chamfers
#define chamfers_z mccCurved_Guide_Section_I_37_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_37_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_37_chamfers_tb
#define nelements mccCurved_Guide_Section_I_37_nelements
#define nu mccCurved_Guide_Section_I_37_nu
#define phase mccCurved_Guide_Section_I_37_phase
#define reflect mccCurved_Guide_Section_I_37_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17033 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_I_38' [38]. */
#define mccompcurname  Curved_Guide_Section_I_38
#define mccompcurtype  Guide_gravity
#define mccompcurindex 38
#define GVars mccCurved_Guide_Section_I_38_GVars
#define pTable mccCurved_Guide_Section_I_38_pTable
#define w1 mccCurved_Guide_Section_I_38_w1
#define h1 mccCurved_Guide_Section_I_38_h1
#define w2 mccCurved_Guide_Section_I_38_w2
#define h2 mccCurved_Guide_Section_I_38_h2
#define l mccCurved_Guide_Section_I_38_l
#define R0 mccCurved_Guide_Section_I_38_R0
#define Qc mccCurved_Guide_Section_I_38_Qc
#define alpha mccCurved_Guide_Section_I_38_alpha
#define m mccCurved_Guide_Section_I_38_m
#define W mccCurved_Guide_Section_I_38_W
#define nslit mccCurved_Guide_Section_I_38_nslit
#define d mccCurved_Guide_Section_I_38_d
#define mleft mccCurved_Guide_Section_I_38_mleft
#define mright mccCurved_Guide_Section_I_38_mright
#define mtop mccCurved_Guide_Section_I_38_mtop
#define mbottom mccCurved_Guide_Section_I_38_mbottom
#define nhslit mccCurved_Guide_Section_I_38_nhslit
#define G mccCurved_Guide_Section_I_38_G
#define aleft mccCurved_Guide_Section_I_38_aleft
#define aright mccCurved_Guide_Section_I_38_aright
#define atop mccCurved_Guide_Section_I_38_atop
#define abottom mccCurved_Guide_Section_I_38_abottom
#define wavy mccCurved_Guide_Section_I_38_wavy
#define wavy_z mccCurved_Guide_Section_I_38_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_38_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_38_wavy_lr
#define chamfers mccCurved_Guide_Section_I_38_chamfers
#define chamfers_z mccCurved_Guide_Section_I_38_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_38_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_38_chamfers_tb
#define nelements mccCurved_Guide_Section_I_38_nelements
#define nu mccCurved_Guide_Section_I_38_nu
#define phase mccCurved_Guide_Section_I_38_phase
#define reflect mccCurved_Guide_Section_I_38_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17117 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_I_short' [39]. */
#define mccompcurname  Curved_Guide_Section_I_short
#define mccompcurtype  Guide_gravity
#define mccompcurindex 39
#define GVars mccCurved_Guide_Section_I_short_GVars
#define pTable mccCurved_Guide_Section_I_short_pTable
#define w1 mccCurved_Guide_Section_I_short_w1
#define h1 mccCurved_Guide_Section_I_short_h1
#define w2 mccCurved_Guide_Section_I_short_w2
#define h2 mccCurved_Guide_Section_I_short_h2
#define l mccCurved_Guide_Section_I_short_l
#define R0 mccCurved_Guide_Section_I_short_R0
#define Qc mccCurved_Guide_Section_I_short_Qc
#define alpha mccCurved_Guide_Section_I_short_alpha
#define m mccCurved_Guide_Section_I_short_m
#define W mccCurved_Guide_Section_I_short_W
#define nslit mccCurved_Guide_Section_I_short_nslit
#define d mccCurved_Guide_Section_I_short_d
#define mleft mccCurved_Guide_Section_I_short_mleft
#define mright mccCurved_Guide_Section_I_short_mright
#define mtop mccCurved_Guide_Section_I_short_mtop
#define mbottom mccCurved_Guide_Section_I_short_mbottom
#define nhslit mccCurved_Guide_Section_I_short_nhslit
#define G mccCurved_Guide_Section_I_short_G
#define aleft mccCurved_Guide_Section_I_short_aleft
#define aright mccCurved_Guide_Section_I_short_aright
#define atop mccCurved_Guide_Section_I_short_atop
#define abottom mccCurved_Guide_Section_I_short_abottom
#define wavy mccCurved_Guide_Section_I_short_wavy
#define wavy_z mccCurved_Guide_Section_I_short_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_short_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_short_wavy_lr
#define chamfers mccCurved_Guide_Section_I_short_chamfers
#define chamfers_z mccCurved_Guide_Section_I_short_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_short_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_short_chamfers_tb
#define nelements mccCurved_Guide_Section_I_short_nelements
#define nu mccCurved_Guide_Section_I_short_nu
#define phase mccCurved_Guide_Section_I_short_phase
#define reflect mccCurved_Guide_Section_I_short_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17201 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap3_start' [40]. */
#define mccompcurname  Gap3_start
#define mccompcurtype  Arm
#define mccompcurindex 40
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap3_start_Lam' [41]. */
#define mccompcurname  Gap3_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 41
#define nL mccGap3_start_Lam_nL
#define L_N mccGap3_start_Lam_L_N
#define L_p mccGap3_start_Lam_L_p
#define L_p2 mccGap3_start_Lam_L_p2
#define filename mccGap3_start_Lam_filename
#define xmin mccGap3_start_Lam_xmin
#define xmax mccGap3_start_Lam_xmax
#define ymin mccGap3_start_Lam_ymin
#define ymax mccGap3_start_Lam_ymax
#define xwidth mccGap3_start_Lam_xwidth
#define yheight mccGap3_start_Lam_yheight
#define Lmin mccGap3_start_Lam_Lmin
#define Lmax mccGap3_start_Lam_Lmax
#define restore_neutron mccGap3_start_Lam_restore_neutron
#define nowritefile mccGap3_start_Lam_nowritefile
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 17272 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'CGS1_end' [42]. */
#define mccompcurname  CGS1_end
#define mccompcurtype  PSD_monitor
#define mccompcurindex 42
#define PSD_N mccCGS1_end_PSD_N
#define PSD_p mccCGS1_end_PSD_p
#define PSD_p2 mccCGS1_end_PSD_p2
#define nx mccCGS1_end_nx
#define ny mccCGS1_end_ny
#define filename mccCGS1_end_filename
#define xmin mccCGS1_end_xmin
#define xmax mccCGS1_end_xmax
#define ymin mccCGS1_end_ymin
#define ymax mccCGS1_end_ymax
#define xwidth mccCGS1_end_xwidth
#define yheight mccCGS1_end_yheight
#define restore_neutron mccCGS1_end_restore_neutron
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
  DArray2d PSD_N;
  DArray2d PSD_p;
  DArray2d PSD_p2;
#line 17313 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'before_Chopper1_ToF' [43]. */
#define mccompcurname  before_Chopper1_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 43
#define nt mccbefore_Chopper1_ToF_nt
#define TOF_N mccbefore_Chopper1_ToF_TOF_N
#define TOF_p mccbefore_Chopper1_ToF_TOF_p
#define TOF_p2 mccbefore_Chopper1_ToF_TOF_p2
#define t_min mccbefore_Chopper1_ToF_t_min
#define t_max mccbefore_Chopper1_ToF_t_max
#define delta_t mccbefore_Chopper1_ToF_delta_t
#define filename mccbefore_Chopper1_ToF_filename
#define xmin mccbefore_Chopper1_ToF_xmin
#define xmax mccbefore_Chopper1_ToF_xmax
#define ymin mccbefore_Chopper1_ToF_ymin
#define ymax mccbefore_Chopper1_ToF_ymax
#define xwidth mccbefore_Chopper1_ToF_xwidth
#define yheight mccbefore_Chopper1_ToF_yheight
#define tmin mccbefore_Chopper1_ToF_tmin
#define tmax mccbefore_Chopper1_ToF_tmax
#define dt mccbefore_Chopper1_ToF_dt
#define restore_neutron mccbefore_Chopper1_ToF_restore_neutron
#define nowritefile mccbefore_Chopper1_ToF_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 17359 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'before_Chopper1_ToF_Z' [44]. */
#define mccompcurname  before_Chopper1_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 44
#define nt mccbefore_Chopper1_ToF_Z_nt
#define TOF_N mccbefore_Chopper1_ToF_Z_TOF_N
#define TOF_p mccbefore_Chopper1_ToF_Z_TOF_p
#define TOF_p2 mccbefore_Chopper1_ToF_Z_TOF_p2
#define t_min mccbefore_Chopper1_ToF_Z_t_min
#define t_max mccbefore_Chopper1_ToF_Z_t_max
#define delta_t mccbefore_Chopper1_ToF_Z_delta_t
#define filename mccbefore_Chopper1_ToF_Z_filename
#define xmin mccbefore_Chopper1_ToF_Z_xmin
#define xmax mccbefore_Chopper1_ToF_Z_xmax
#define ymin mccbefore_Chopper1_ToF_Z_ymin
#define ymax mccbefore_Chopper1_ToF_Z_ymax
#define xwidth mccbefore_Chopper1_ToF_Z_xwidth
#define yheight mccbefore_Chopper1_ToF_Z_yheight
#define tmin mccbefore_Chopper1_ToF_Z_tmin
#define tmax mccbefore_Chopper1_ToF_Z_tmax
#define dt mccbefore_Chopper1_ToF_Z_dt
#define restore_neutron mccbefore_Chopper1_ToF_Z_restore_neutron
#define nowritefile mccbefore_Chopper1_ToF_Z_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 17411 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Chopper1' [45]. */
#define mccompcurname  Chopper1
#define mccompcurtype  DiskChopper
#define mccompcurindex 45
#define Tg mccChopper1_Tg
#define To mccChopper1_To
#define delta_y mccChopper1_delta_y
#define height mccChopper1_height
#define omega mccChopper1_omega
#define theta_0 mccChopper1_theta_0
#define radius mccChopper1_radius
#define yheight mccChopper1_yheight
#define nu mccChopper1_nu
#define nslit mccChopper1_nslit
#define jitter mccChopper1_jitter
#define delay mccChopper1_delay
#define isfirst mccChopper1_isfirst
#define n_pulse mccChopper1_n_pulse
#define abs_out mccChopper1_abs_out
#define phase mccChopper1_phase
#define xwidth mccChopper1_xwidth
#define verbose mccChopper1_verbose
#line 66 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/DiskChopper.comp"
double Tg,To,delta_y,height,omega;
#line 17459 "./SNS_BASIS.c"
#undef verbose
#undef xwidth
#undef phase
#undef abs_out
#undef n_pulse
#undef isfirst
#undef delay
#undef jitter
#undef nslit
#undef nu
#undef yheight
#undef radius
#undef theta_0
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Chopper1_ToF' [46]. */
#define mccompcurname  Chopper1_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 46
#define nt mccChopper1_ToF_nt
#define TOF_N mccChopper1_ToF_TOF_N
#define TOF_p mccChopper1_ToF_TOF_p
#define TOF_p2 mccChopper1_ToF_TOF_p2
#define t_min mccChopper1_ToF_t_min
#define t_max mccChopper1_ToF_t_max
#define delta_t mccChopper1_ToF_delta_t
#define filename mccChopper1_ToF_filename
#define xmin mccChopper1_ToF_xmin
#define xmax mccChopper1_ToF_xmax
#define ymin mccChopper1_ToF_ymin
#define ymax mccChopper1_ToF_ymax
#define xwidth mccChopper1_ToF_xwidth
#define yheight mccChopper1_ToF_yheight
#define tmin mccChopper1_ToF_tmin
#define tmax mccChopper1_ToF_tmax
#define dt mccChopper1_ToF_dt
#define restore_neutron mccChopper1_ToF_restore_neutron
#define nowritefile mccChopper1_ToF_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 17510 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Chopper1_ToF_Z' [47]. */
#define mccompcurname  Chopper1_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 47
#define nt mccChopper1_ToF_Z_nt
#define TOF_N mccChopper1_ToF_Z_TOF_N
#define TOF_p mccChopper1_ToF_Z_TOF_p
#define TOF_p2 mccChopper1_ToF_Z_TOF_p2
#define t_min mccChopper1_ToF_Z_t_min
#define t_max mccChopper1_ToF_Z_t_max
#define delta_t mccChopper1_ToF_Z_delta_t
#define filename mccChopper1_ToF_Z_filename
#define xmin mccChopper1_ToF_Z_xmin
#define xmax mccChopper1_ToF_Z_xmax
#define ymin mccChopper1_ToF_Z_ymin
#define ymax mccChopper1_ToF_Z_ymax
#define xwidth mccChopper1_ToF_Z_xwidth
#define yheight mccChopper1_ToF_Z_yheight
#define tmin mccChopper1_ToF_Z_tmin
#define tmax mccChopper1_ToF_Z_tmax
#define dt mccChopper1_ToF_Z_dt
#define restore_neutron mccChopper1_ToF_Z_restore_neutron
#define nowritefile mccChopper1_ToF_Z_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 17562 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap3_end_Lam' [48]. */
#define mccompcurname  Gap3_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 48
#define nL mccGap3_end_Lam_nL
#define L_N mccGap3_end_Lam_L_N
#define L_p mccGap3_end_Lam_L_p
#define L_p2 mccGap3_end_Lam_L_p2
#define filename mccGap3_end_Lam_filename
#define xmin mccGap3_end_Lam_xmin
#define xmax mccGap3_end_Lam_xmax
#define ymin mccGap3_end_Lam_ymin
#define ymax mccGap3_end_Lam_ymax
#define xwidth mccGap3_end_Lam_xwidth
#define yheight mccGap3_end_Lam_yheight
#define Lmin mccGap3_end_Lam_Lmin
#define Lmax mccGap3_end_Lam_Lmax
#define restore_neutron mccGap3_end_Lam_restore_neutron
#define nowritefile mccGap3_end_Lam_nowritefile
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 17608 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap3_end_PSD' [49]. */
#define mccompcurname  Gap3_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 49
#define PSD_N mccGap3_end_PSD_PSD_N
#define PSD_p mccGap3_end_PSD_PSD_p
#define PSD_p2 mccGap3_end_PSD_PSD_p2
#define nx mccGap3_end_PSD_nx
#define ny mccGap3_end_PSD_ny
#define filename mccGap3_end_PSD_filename
#define xmin mccGap3_end_PSD_xmin
#define xmax mccGap3_end_PSD_xmax
#define ymin mccGap3_end_PSD_ymin
#define ymax mccGap3_end_PSD_ymax
#define xwidth mccGap3_end_PSD_xwidth
#define yheight mccGap3_end_PSD_yheight
#define restore_neutron mccGap3_end_PSD_restore_neutron
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
  DArray2d PSD_N;
  DArray2d PSD_p;
  DArray2d PSD_p2;
#line 17649 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap3_end' [50]. */
#define mccompcurname  Gap3_end
#define mccompcurtype  Arm
#define mccompcurindex 50
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_II' [51]. */
#define mccompcurname  Curved_Guide_Section_II
#define mccompcurtype  Guide_gravity
#define mccompcurindex 51
#define GVars mccCurved_Guide_Section_II_GVars
#define pTable mccCurved_Guide_Section_II_pTable
#define w1 mccCurved_Guide_Section_II_w1
#define h1 mccCurved_Guide_Section_II_h1
#define w2 mccCurved_Guide_Section_II_w2
#define h2 mccCurved_Guide_Section_II_h2
#define l mccCurved_Guide_Section_II_l
#define R0 mccCurved_Guide_Section_II_R0
#define Qc mccCurved_Guide_Section_II_Qc
#define alpha mccCurved_Guide_Section_II_alpha
#define m mccCurved_Guide_Section_II_m
#define W mccCurved_Guide_Section_II_W
#define nslit mccCurved_Guide_Section_II_nslit
#define d mccCurved_Guide_Section_II_d
#define mleft mccCurved_Guide_Section_II_mleft
#define mright mccCurved_Guide_Section_II_mright
#define mtop mccCurved_Guide_Section_II_mtop
#define mbottom mccCurved_Guide_Section_II_mbottom
#define nhslit mccCurved_Guide_Section_II_nhslit
#define G mccCurved_Guide_Section_II_G
#define aleft mccCurved_Guide_Section_II_aleft
#define aright mccCurved_Guide_Section_II_aright
#define atop mccCurved_Guide_Section_II_atop
#define abottom mccCurved_Guide_Section_II_abottom
#define wavy mccCurved_Guide_Section_II_wavy
#define wavy_z mccCurved_Guide_Section_II_wavy_z
#define wavy_tb mccCurved_Guide_Section_II_wavy_tb
#define wavy_lr mccCurved_Guide_Section_II_wavy_lr
#define chamfers mccCurved_Guide_Section_II_chamfers
#define chamfers_z mccCurved_Guide_Section_II_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_II_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_II_chamfers_tb
#define nelements mccCurved_Guide_Section_II_nelements
#define nu mccCurved_Guide_Section_II_nu
#define phase mccCurved_Guide_Section_II_phase
#define reflect mccCurved_Guide_Section_II_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17718 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_II_52' [52]. */
#define mccompcurname  Curved_Guide_Section_II_52
#define mccompcurtype  Guide_gravity
#define mccompcurindex 52
#define GVars mccCurved_Guide_Section_II_52_GVars
#define pTable mccCurved_Guide_Section_II_52_pTable
#define w1 mccCurved_Guide_Section_II_52_w1
#define h1 mccCurved_Guide_Section_II_52_h1
#define w2 mccCurved_Guide_Section_II_52_w2
#define h2 mccCurved_Guide_Section_II_52_h2
#define l mccCurved_Guide_Section_II_52_l
#define R0 mccCurved_Guide_Section_II_52_R0
#define Qc mccCurved_Guide_Section_II_52_Qc
#define alpha mccCurved_Guide_Section_II_52_alpha
#define m mccCurved_Guide_Section_II_52_m
#define W mccCurved_Guide_Section_II_52_W
#define nslit mccCurved_Guide_Section_II_52_nslit
#define d mccCurved_Guide_Section_II_52_d
#define mleft mccCurved_Guide_Section_II_52_mleft
#define mright mccCurved_Guide_Section_II_52_mright
#define mtop mccCurved_Guide_Section_II_52_mtop
#define mbottom mccCurved_Guide_Section_II_52_mbottom
#define nhslit mccCurved_Guide_Section_II_52_nhslit
#define G mccCurved_Guide_Section_II_52_G
#define aleft mccCurved_Guide_Section_II_52_aleft
#define aright mccCurved_Guide_Section_II_52_aright
#define atop mccCurved_Guide_Section_II_52_atop
#define abottom mccCurved_Guide_Section_II_52_abottom
#define wavy mccCurved_Guide_Section_II_52_wavy
#define wavy_z mccCurved_Guide_Section_II_52_wavy_z
#define wavy_tb mccCurved_Guide_Section_II_52_wavy_tb
#define wavy_lr mccCurved_Guide_Section_II_52_wavy_lr
#define chamfers mccCurved_Guide_Section_II_52_chamfers
#define chamfers_z mccCurved_Guide_Section_II_52_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_II_52_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_II_52_chamfers_tb
#define nelements mccCurved_Guide_Section_II_52_nelements
#define nu mccCurved_Guide_Section_II_52_nu
#define phase mccCurved_Guide_Section_II_52_phase
#define reflect mccCurved_Guide_Section_II_52_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17802 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_II_53' [53]. */
#define mccompcurname  Curved_Guide_Section_II_53
#define mccompcurtype  Guide_gravity
#define mccompcurindex 53
#define GVars mccCurved_Guide_Section_II_53_GVars
#define pTable mccCurved_Guide_Section_II_53_pTable
#define w1 mccCurved_Guide_Section_II_53_w1
#define h1 mccCurved_Guide_Section_II_53_h1
#define w2 mccCurved_Guide_Section_II_53_w2
#define h2 mccCurved_Guide_Section_II_53_h2
#define l mccCurved_Guide_Section_II_53_l
#define R0 mccCurved_Guide_Section_II_53_R0
#define Qc mccCurved_Guide_Section_II_53_Qc
#define alpha mccCurved_Guide_Section_II_53_alpha
#define m mccCurved_Guide_Section_II_53_m
#define W mccCurved_Guide_Section_II_53_W
#define nslit mccCurved_Guide_Section_II_53_nslit
#define d mccCurved_Guide_Section_II_53_d
#define mleft mccCurved_Guide_Section_II_53_mleft
#define mright mccCurved_Guide_Section_II_53_mright
#define mtop mccCurved_Guide_Section_II_53_mtop
#define mbottom mccCurved_Guide_Section_II_53_mbottom
#define nhslit mccCurved_Guide_Section_II_53_nhslit
#define G mccCurved_Guide_Section_II_53_G
#define aleft mccCurved_Guide_Section_II_53_aleft
#define aright mccCurved_Guide_Section_II_53_aright
#define atop mccCurved_Guide_Section_II_53_atop
#define abottom mccCurved_Guide_Section_II_53_abottom
#define wavy mccCurved_Guide_Section_II_53_wavy
#define wavy_z mccCurved_Guide_Section_II_53_wavy_z
#define wavy_tb mccCurved_Guide_Section_II_53_wavy_tb
#define wavy_lr mccCurved_Guide_Section_II_53_wavy_lr
#define chamfers mccCurved_Guide_Section_II_53_chamfers
#define chamfers_z mccCurved_Guide_Section_II_53_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_II_53_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_II_53_chamfers_tb
#define nelements mccCurved_Guide_Section_II_53_nelements
#define nu mccCurved_Guide_Section_II_53_nu
#define phase mccCurved_Guide_Section_II_53_phase
#define reflect mccCurved_Guide_Section_II_53_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17886 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_II_54' [54]. */
#define mccompcurname  Curved_Guide_Section_II_54
#define mccompcurtype  Guide_gravity
#define mccompcurindex 54
#define GVars mccCurved_Guide_Section_II_54_GVars
#define pTable mccCurved_Guide_Section_II_54_pTable
#define w1 mccCurved_Guide_Section_II_54_w1
#define h1 mccCurved_Guide_Section_II_54_h1
#define w2 mccCurved_Guide_Section_II_54_w2
#define h2 mccCurved_Guide_Section_II_54_h2
#define l mccCurved_Guide_Section_II_54_l
#define R0 mccCurved_Guide_Section_II_54_R0
#define Qc mccCurved_Guide_Section_II_54_Qc
#define alpha mccCurved_Guide_Section_II_54_alpha
#define m mccCurved_Guide_Section_II_54_m
#define W mccCurved_Guide_Section_II_54_W
#define nslit mccCurved_Guide_Section_II_54_nslit
#define d mccCurved_Guide_Section_II_54_d
#define mleft mccCurved_Guide_Section_II_54_mleft
#define mright mccCurved_Guide_Section_II_54_mright
#define mtop mccCurved_Guide_Section_II_54_mtop
#define mbottom mccCurved_Guide_Section_II_54_mbottom
#define nhslit mccCurved_Guide_Section_II_54_nhslit
#define G mccCurved_Guide_Section_II_54_G
#define aleft mccCurved_Guide_Section_II_54_aleft
#define aright mccCurved_Guide_Section_II_54_aright
#define atop mccCurved_Guide_Section_II_54_atop
#define abottom mccCurved_Guide_Section_II_54_abottom
#define wavy mccCurved_Guide_Section_II_54_wavy
#define wavy_z mccCurved_Guide_Section_II_54_wavy_z
#define wavy_tb mccCurved_Guide_Section_II_54_wavy_tb
#define wavy_lr mccCurved_Guide_Section_II_54_wavy_lr
#define chamfers mccCurved_Guide_Section_II_54_chamfers
#define chamfers_z mccCurved_Guide_Section_II_54_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_II_54_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_II_54_chamfers_tb
#define nelements mccCurved_Guide_Section_II_54_nelements
#define nu mccCurved_Guide_Section_II_54_nu
#define phase mccCurved_Guide_Section_II_54_phase
#define reflect mccCurved_Guide_Section_II_54_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17970 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_II_55' [55]. */
#define mccompcurname  Curved_Guide_Section_II_55
#define mccompcurtype  Guide_gravity
#define mccompcurindex 55
#define GVars mccCurved_Guide_Section_II_55_GVars
#define pTable mccCurved_Guide_Section_II_55_pTable
#define w1 mccCurved_Guide_Section_II_55_w1
#define h1 mccCurved_Guide_Section_II_55_h1
#define w2 mccCurved_Guide_Section_II_55_w2
#define h2 mccCurved_Guide_Section_II_55_h2
#define l mccCurved_Guide_Section_II_55_l
#define R0 mccCurved_Guide_Section_II_55_R0
#define Qc mccCurved_Guide_Section_II_55_Qc
#define alpha mccCurved_Guide_Section_II_55_alpha
#define m mccCurved_Guide_Section_II_55_m
#define W mccCurved_Guide_Section_II_55_W
#define nslit mccCurved_Guide_Section_II_55_nslit
#define d mccCurved_Guide_Section_II_55_d
#define mleft mccCurved_Guide_Section_II_55_mleft
#define mright mccCurved_Guide_Section_II_55_mright
#define mtop mccCurved_Guide_Section_II_55_mtop
#define mbottom mccCurved_Guide_Section_II_55_mbottom
#define nhslit mccCurved_Guide_Section_II_55_nhslit
#define G mccCurved_Guide_Section_II_55_G
#define aleft mccCurved_Guide_Section_II_55_aleft
#define aright mccCurved_Guide_Section_II_55_aright
#define atop mccCurved_Guide_Section_II_55_atop
#define abottom mccCurved_Guide_Section_II_55_abottom
#define wavy mccCurved_Guide_Section_II_55_wavy
#define wavy_z mccCurved_Guide_Section_II_55_wavy_z
#define wavy_tb mccCurved_Guide_Section_II_55_wavy_tb
#define wavy_lr mccCurved_Guide_Section_II_55_wavy_lr
#define chamfers mccCurved_Guide_Section_II_55_chamfers
#define chamfers_z mccCurved_Guide_Section_II_55_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_II_55_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_II_55_chamfers_tb
#define nelements mccCurved_Guide_Section_II_55_nelements
#define nu mccCurved_Guide_Section_II_55_nu
#define phase mccCurved_Guide_Section_II_55_phase
#define reflect mccCurved_Guide_Section_II_55_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 18054 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_II_56' [56]. */
#define mccompcurname  Curved_Guide_Section_II_56
#define mccompcurtype  Guide_gravity
#define mccompcurindex 56
#define GVars mccCurved_Guide_Section_II_56_GVars
#define pTable mccCurved_Guide_Section_II_56_pTable
#define w1 mccCurved_Guide_Section_II_56_w1
#define h1 mccCurved_Guide_Section_II_56_h1
#define w2 mccCurved_Guide_Section_II_56_w2
#define h2 mccCurved_Guide_Section_II_56_h2
#define l mccCurved_Guide_Section_II_56_l
#define R0 mccCurved_Guide_Section_II_56_R0
#define Qc mccCurved_Guide_Section_II_56_Qc
#define alpha mccCurved_Guide_Section_II_56_alpha
#define m mccCurved_Guide_Section_II_56_m
#define W mccCurved_Guide_Section_II_56_W
#define nslit mccCurved_Guide_Section_II_56_nslit
#define d mccCurved_Guide_Section_II_56_d
#define mleft mccCurved_Guide_Section_II_56_mleft
#define mright mccCurved_Guide_Section_II_56_mright
#define mtop mccCurved_Guide_Section_II_56_mtop
#define mbottom mccCurved_Guide_Section_II_56_mbottom
#define nhslit mccCurved_Guide_Section_II_56_nhslit
#define G mccCurved_Guide_Section_II_56_G
#define aleft mccCurved_Guide_Section_II_56_aleft
#define aright mccCurved_Guide_Section_II_56_aright
#define atop mccCurved_Guide_Section_II_56_atop
#define abottom mccCurved_Guide_Section_II_56_abottom
#define wavy mccCurved_Guide_Section_II_56_wavy
#define wavy_z mccCurved_Guide_Section_II_56_wavy_z
#define wavy_tb mccCurved_Guide_Section_II_56_wavy_tb
#define wavy_lr mccCurved_Guide_Section_II_56_wavy_lr
#define chamfers mccCurved_Guide_Section_II_56_chamfers
#define chamfers_z mccCurved_Guide_Section_II_56_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_II_56_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_II_56_chamfers_tb
#define nelements mccCurved_Guide_Section_II_56_nelements
#define nu mccCurved_Guide_Section_II_56_nu
#define phase mccCurved_Guide_Section_II_56_phase
#define reflect mccCurved_Guide_Section_II_56_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 18138 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_II_57' [57]. */
#define mccompcurname  Curved_Guide_Section_II_57
#define mccompcurtype  Guide_gravity
#define mccompcurindex 57
#define GVars mccCurved_Guide_Section_II_57_GVars
#define pTable mccCurved_Guide_Section_II_57_pTable
#define w1 mccCurved_Guide_Section_II_57_w1
#define h1 mccCurved_Guide_Section_II_57_h1
#define w2 mccCurved_Guide_Section_II_57_w2
#define h2 mccCurved_Guide_Section_II_57_h2
#define l mccCurved_Guide_Section_II_57_l
#define R0 mccCurved_Guide_Section_II_57_R0
#define Qc mccCurved_Guide_Section_II_57_Qc
#define alpha mccCurved_Guide_Section_II_57_alpha
#define m mccCurved_Guide_Section_II_57_m
#define W mccCurved_Guide_Section_II_57_W
#define nslit mccCurved_Guide_Section_II_57_nslit
#define d mccCurved_Guide_Section_II_57_d
#define mleft mccCurved_Guide_Section_II_57_mleft
#define mright mccCurved_Guide_Section_II_57_mright
#define mtop mccCurved_Guide_Section_II_57_mtop
#define mbottom mccCurved_Guide_Section_II_57_mbottom
#define nhslit mccCurved_Guide_Section_II_57_nhslit
#define G mccCurved_Guide_Section_II_57_G
#define aleft mccCurved_Guide_Section_II_57_aleft
#define aright mccCurved_Guide_Section_II_57_aright
#define atop mccCurved_Guide_Section_II_57_atop
#define abottom mccCurved_Guide_Section_II_57_abottom
#define wavy mccCurved_Guide_Section_II_57_wavy
#define wavy_z mccCurved_Guide_Section_II_57_wavy_z
#define wavy_tb mccCurved_Guide_Section_II_57_wavy_tb
#define wavy_lr mccCurved_Guide_Section_II_57_wavy_lr
#define chamfers mccCurved_Guide_Section_II_57_chamfers
#define chamfers_z mccCurved_Guide_Section_II_57_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_II_57_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_II_57_chamfers_tb
#define nelements mccCurved_Guide_Section_II_57_nelements
#define nu mccCurved_Guide_Section_II_57_nu
#define phase mccCurved_Guide_Section_II_57_phase
#define reflect mccCurved_Guide_Section_II_57_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 18222 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_II_last' [58]. */
#define mccompcurname  Curved_Guide_Section_II_last
#define mccompcurtype  Guide_gravity
#define mccompcurindex 58
#define GVars mccCurved_Guide_Section_II_last_GVars
#define pTable mccCurved_Guide_Section_II_last_pTable
#define w1 mccCurved_Guide_Section_II_last_w1
#define h1 mccCurved_Guide_Section_II_last_h1
#define w2 mccCurved_Guide_Section_II_last_w2
#define h2 mccCurved_Guide_Section_II_last_h2
#define l mccCurved_Guide_Section_II_last_l
#define R0 mccCurved_Guide_Section_II_last_R0
#define Qc mccCurved_Guide_Section_II_last_Qc
#define alpha mccCurved_Guide_Section_II_last_alpha
#define m mccCurved_Guide_Section_II_last_m
#define W mccCurved_Guide_Section_II_last_W
#define nslit mccCurved_Guide_Section_II_last_nslit
#define d mccCurved_Guide_Section_II_last_d
#define mleft mccCurved_Guide_Section_II_last_mleft
#define mright mccCurved_Guide_Section_II_last_mright
#define mtop mccCurved_Guide_Section_II_last_mtop
#define mbottom mccCurved_Guide_Section_II_last_mbottom
#define nhslit mccCurved_Guide_Section_II_last_nhslit
#define G mccCurved_Guide_Section_II_last_G
#define aleft mccCurved_Guide_Section_II_last_aleft
#define aright mccCurved_Guide_Section_II_last_aright
#define atop mccCurved_Guide_Section_II_last_atop
#define abottom mccCurved_Guide_Section_II_last_abottom
#define wavy mccCurved_Guide_Section_II_last_wavy
#define wavy_z mccCurved_Guide_Section_II_last_wavy_z
#define wavy_tb mccCurved_Guide_Section_II_last_wavy_tb
#define wavy_lr mccCurved_Guide_Section_II_last_wavy_lr
#define chamfers mccCurved_Guide_Section_II_last_chamfers
#define chamfers_z mccCurved_Guide_Section_II_last_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_II_last_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_II_last_chamfers_tb
#define nelements mccCurved_Guide_Section_II_last_nelements
#define nu mccCurved_Guide_Section_II_last_nu
#define phase mccCurved_Guide_Section_II_last_phase
#define reflect mccCurved_Guide_Section_II_last_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 18306 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap4_start' [59]. */
#define mccompcurname  Gap4_start
#define mccompcurtype  Arm
#define mccompcurindex 59
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap4_start_Lam' [60]. */
#define mccompcurname  Gap4_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 60
#define nL mccGap4_start_Lam_nL
#define L_N mccGap4_start_Lam_L_N
#define L_p mccGap4_start_Lam_L_p
#define L_p2 mccGap4_start_Lam_L_p2
#define filename mccGap4_start_Lam_filename
#define xmin mccGap4_start_Lam_xmin
#define xmax mccGap4_start_Lam_xmax
#define ymin mccGap4_start_Lam_ymin
#define ymax mccGap4_start_Lam_ymax
#define xwidth mccGap4_start_Lam_xwidth
#define yheight mccGap4_start_Lam_yheight
#define Lmin mccGap4_start_Lam_Lmin
#define Lmax mccGap4_start_Lam_Lmax
#define restore_neutron mccGap4_start_Lam_restore_neutron
#define nowritefile mccGap4_start_Lam_nowritefile
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 18377 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap4_start_PSD' [61]. */
#define mccompcurname  Gap4_start_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 61
#define PSD_N mccGap4_start_PSD_PSD_N
#define PSD_p mccGap4_start_PSD_PSD_p
#define PSD_p2 mccGap4_start_PSD_PSD_p2
#define nx mccGap4_start_PSD_nx
#define ny mccGap4_start_PSD_ny
#define filename mccGap4_start_PSD_filename
#define xmin mccGap4_start_PSD_xmin
#define xmax mccGap4_start_PSD_xmax
#define ymin mccGap4_start_PSD_ymin
#define ymax mccGap4_start_PSD_ymax
#define xwidth mccGap4_start_PSD_xwidth
#define yheight mccGap4_start_PSD_yheight
#define restore_neutron mccGap4_start_PSD_restore_neutron
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
  DArray2d PSD_N;
  DArray2d PSD_p;
  DArray2d PSD_p2;
#line 18418 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'before_Chopper2_ToF' [62]. */
#define mccompcurname  before_Chopper2_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 62
#define nt mccbefore_Chopper2_ToF_nt
#define TOF_N mccbefore_Chopper2_ToF_TOF_N
#define TOF_p mccbefore_Chopper2_ToF_TOF_p
#define TOF_p2 mccbefore_Chopper2_ToF_TOF_p2
#define t_min mccbefore_Chopper2_ToF_t_min
#define t_max mccbefore_Chopper2_ToF_t_max
#define delta_t mccbefore_Chopper2_ToF_delta_t
#define filename mccbefore_Chopper2_ToF_filename
#define xmin mccbefore_Chopper2_ToF_xmin
#define xmax mccbefore_Chopper2_ToF_xmax
#define ymin mccbefore_Chopper2_ToF_ymin
#define ymax mccbefore_Chopper2_ToF_ymax
#define xwidth mccbefore_Chopper2_ToF_xwidth
#define yheight mccbefore_Chopper2_ToF_yheight
#define tmin mccbefore_Chopper2_ToF_tmin
#define tmax mccbefore_Chopper2_ToF_tmax
#define dt mccbefore_Chopper2_ToF_dt
#define restore_neutron mccbefore_Chopper2_ToF_restore_neutron
#define nowritefile mccbefore_Chopper2_ToF_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 18464 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'before_Chopper2_ToF_Z' [63]. */
#define mccompcurname  before_Chopper2_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 63
#define nt mccbefore_Chopper2_ToF_Z_nt
#define TOF_N mccbefore_Chopper2_ToF_Z_TOF_N
#define TOF_p mccbefore_Chopper2_ToF_Z_TOF_p
#define TOF_p2 mccbefore_Chopper2_ToF_Z_TOF_p2
#define t_min mccbefore_Chopper2_ToF_Z_t_min
#define t_max mccbefore_Chopper2_ToF_Z_t_max
#define delta_t mccbefore_Chopper2_ToF_Z_delta_t
#define filename mccbefore_Chopper2_ToF_Z_filename
#define xmin mccbefore_Chopper2_ToF_Z_xmin
#define xmax mccbefore_Chopper2_ToF_Z_xmax
#define ymin mccbefore_Chopper2_ToF_Z_ymin
#define ymax mccbefore_Chopper2_ToF_Z_ymax
#define xwidth mccbefore_Chopper2_ToF_Z_xwidth
#define yheight mccbefore_Chopper2_ToF_Z_yheight
#define tmin mccbefore_Chopper2_ToF_Z_tmin
#define tmax mccbefore_Chopper2_ToF_Z_tmax
#define dt mccbefore_Chopper2_ToF_Z_dt
#define restore_neutron mccbefore_Chopper2_ToF_Z_restore_neutron
#define nowritefile mccbefore_Chopper2_ToF_Z_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 18516 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Chopper2' [64]. */
#define mccompcurname  Chopper2
#define mccompcurtype  DiskChopper
#define mccompcurindex 64
#define Tg mccChopper2_Tg
#define To mccChopper2_To
#define delta_y mccChopper2_delta_y
#define height mccChopper2_height
#define omega mccChopper2_omega
#define theta_0 mccChopper2_theta_0
#define radius mccChopper2_radius
#define yheight mccChopper2_yheight
#define nu mccChopper2_nu
#define nslit mccChopper2_nslit
#define jitter mccChopper2_jitter
#define delay mccChopper2_delay
#define isfirst mccChopper2_isfirst
#define n_pulse mccChopper2_n_pulse
#define abs_out mccChopper2_abs_out
#define phase mccChopper2_phase
#define xwidth mccChopper2_xwidth
#define verbose mccChopper2_verbose
#line 66 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/DiskChopper.comp"
double Tg,To,delta_y,height,omega;
#line 18564 "./SNS_BASIS.c"
#undef verbose
#undef xwidth
#undef phase
#undef abs_out
#undef n_pulse
#undef isfirst
#undef delay
#undef jitter
#undef nslit
#undef nu
#undef yheight
#undef radius
#undef theta_0
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Chopper2_ToF' [65]. */
#define mccompcurname  Chopper2_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 65
#define nt mccChopper2_ToF_nt
#define TOF_N mccChopper2_ToF_TOF_N
#define TOF_p mccChopper2_ToF_TOF_p
#define TOF_p2 mccChopper2_ToF_TOF_p2
#define t_min mccChopper2_ToF_t_min
#define t_max mccChopper2_ToF_t_max
#define delta_t mccChopper2_ToF_delta_t
#define filename mccChopper2_ToF_filename
#define xmin mccChopper2_ToF_xmin
#define xmax mccChopper2_ToF_xmax
#define ymin mccChopper2_ToF_ymin
#define ymax mccChopper2_ToF_ymax
#define xwidth mccChopper2_ToF_xwidth
#define yheight mccChopper2_ToF_yheight
#define tmin mccChopper2_ToF_tmin
#define tmax mccChopper2_ToF_tmax
#define dt mccChopper2_ToF_dt
#define restore_neutron mccChopper2_ToF_restore_neutron
#define nowritefile mccChopper2_ToF_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 18615 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Chopper2_ToF_Z' [66]. */
#define mccompcurname  Chopper2_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 66
#define nt mccChopper2_ToF_Z_nt
#define TOF_N mccChopper2_ToF_Z_TOF_N
#define TOF_p mccChopper2_ToF_Z_TOF_p
#define TOF_p2 mccChopper2_ToF_Z_TOF_p2
#define t_min mccChopper2_ToF_Z_t_min
#define t_max mccChopper2_ToF_Z_t_max
#define delta_t mccChopper2_ToF_Z_delta_t
#define filename mccChopper2_ToF_Z_filename
#define xmin mccChopper2_ToF_Z_xmin
#define xmax mccChopper2_ToF_Z_xmax
#define ymin mccChopper2_ToF_Z_ymin
#define ymax mccChopper2_ToF_Z_ymax
#define xwidth mccChopper2_ToF_Z_xwidth
#define yheight mccChopper2_ToF_Z_yheight
#define tmin mccChopper2_ToF_Z_tmin
#define tmax mccChopper2_ToF_Z_tmax
#define dt mccChopper2_ToF_Z_dt
#define restore_neutron mccChopper2_ToF_Z_restore_neutron
#define nowritefile mccChopper2_ToF_Z_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 18667 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap4_end_Lam' [67]. */
#define mccompcurname  Gap4_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 67
#define nL mccGap4_end_Lam_nL
#define L_N mccGap4_end_Lam_L_N
#define L_p mccGap4_end_Lam_L_p
#define L_p2 mccGap4_end_Lam_L_p2
#define filename mccGap4_end_Lam_filename
#define xmin mccGap4_end_Lam_xmin
#define xmax mccGap4_end_Lam_xmax
#define ymin mccGap4_end_Lam_ymin
#define ymax mccGap4_end_Lam_ymax
#define xwidth mccGap4_end_Lam_xwidth
#define yheight mccGap4_end_Lam_yheight
#define Lmin mccGap4_end_Lam_Lmin
#define Lmax mccGap4_end_Lam_Lmax
#define restore_neutron mccGap4_end_Lam_restore_neutron
#define nowritefile mccGap4_end_Lam_nowritefile
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 18713 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap4_end_PSD' [68]. */
#define mccompcurname  Gap4_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 68
#define PSD_N mccGap4_end_PSD_PSD_N
#define PSD_p mccGap4_end_PSD_PSD_p
#define PSD_p2 mccGap4_end_PSD_PSD_p2
#define nx mccGap4_end_PSD_nx
#define ny mccGap4_end_PSD_ny
#define filename mccGap4_end_PSD_filename
#define xmin mccGap4_end_PSD_xmin
#define xmax mccGap4_end_PSD_xmax
#define ymin mccGap4_end_PSD_ymin
#define ymax mccGap4_end_PSD_ymax
#define xwidth mccGap4_end_PSD_xwidth
#define yheight mccGap4_end_PSD_yheight
#define restore_neutron mccGap4_end_PSD_restore_neutron
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
  DArray2d PSD_N;
  DArray2d PSD_p;
  DArray2d PSD_p2;
#line 18754 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap4_end' [69]. */
#define mccompcurname  Gap4_end
#define mccompcurtype  Arm
#define mccompcurindex 69
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_III' [70]. */
#define mccompcurname  Curved_Guide_Section_III
#define mccompcurtype  Guide_gravity
#define mccompcurindex 70
#define GVars mccCurved_Guide_Section_III_GVars
#define pTable mccCurved_Guide_Section_III_pTable
#define w1 mccCurved_Guide_Section_III_w1
#define h1 mccCurved_Guide_Section_III_h1
#define w2 mccCurved_Guide_Section_III_w2
#define h2 mccCurved_Guide_Section_III_h2
#define l mccCurved_Guide_Section_III_l
#define R0 mccCurved_Guide_Section_III_R0
#define Qc mccCurved_Guide_Section_III_Qc
#define alpha mccCurved_Guide_Section_III_alpha
#define m mccCurved_Guide_Section_III_m
#define W mccCurved_Guide_Section_III_W
#define nslit mccCurved_Guide_Section_III_nslit
#define d mccCurved_Guide_Section_III_d
#define mleft mccCurved_Guide_Section_III_mleft
#define mright mccCurved_Guide_Section_III_mright
#define mtop mccCurved_Guide_Section_III_mtop
#define mbottom mccCurved_Guide_Section_III_mbottom
#define nhslit mccCurved_Guide_Section_III_nhslit
#define G mccCurved_Guide_Section_III_G
#define aleft mccCurved_Guide_Section_III_aleft
#define aright mccCurved_Guide_Section_III_aright
#define atop mccCurved_Guide_Section_III_atop
#define abottom mccCurved_Guide_Section_III_abottom
#define wavy mccCurved_Guide_Section_III_wavy
#define wavy_z mccCurved_Guide_Section_III_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_wavy_lr
#define chamfers mccCurved_Guide_Section_III_chamfers
#define chamfers_z mccCurved_Guide_Section_III_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_chamfers_tb
#define nelements mccCurved_Guide_Section_III_nelements
#define nu mccCurved_Guide_Section_III_nu
#define phase mccCurved_Guide_Section_III_phase
#define reflect mccCurved_Guide_Section_III_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 18823 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_III_71' [71]. */
#define mccompcurname  Curved_Guide_Section_III_71
#define mccompcurtype  Guide_gravity
#define mccompcurindex 71
#define GVars mccCurved_Guide_Section_III_71_GVars
#define pTable mccCurved_Guide_Section_III_71_pTable
#define w1 mccCurved_Guide_Section_III_71_w1
#define h1 mccCurved_Guide_Section_III_71_h1
#define w2 mccCurved_Guide_Section_III_71_w2
#define h2 mccCurved_Guide_Section_III_71_h2
#define l mccCurved_Guide_Section_III_71_l
#define R0 mccCurved_Guide_Section_III_71_R0
#define Qc mccCurved_Guide_Section_III_71_Qc
#define alpha mccCurved_Guide_Section_III_71_alpha
#define m mccCurved_Guide_Section_III_71_m
#define W mccCurved_Guide_Section_III_71_W
#define nslit mccCurved_Guide_Section_III_71_nslit
#define d mccCurved_Guide_Section_III_71_d
#define mleft mccCurved_Guide_Section_III_71_mleft
#define mright mccCurved_Guide_Section_III_71_mright
#define mtop mccCurved_Guide_Section_III_71_mtop
#define mbottom mccCurved_Guide_Section_III_71_mbottom
#define nhslit mccCurved_Guide_Section_III_71_nhslit
#define G mccCurved_Guide_Section_III_71_G
#define aleft mccCurved_Guide_Section_III_71_aleft
#define aright mccCurved_Guide_Section_III_71_aright
#define atop mccCurved_Guide_Section_III_71_atop
#define abottom mccCurved_Guide_Section_III_71_abottom
#define wavy mccCurved_Guide_Section_III_71_wavy
#define wavy_z mccCurved_Guide_Section_III_71_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_71_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_71_wavy_lr
#define chamfers mccCurved_Guide_Section_III_71_chamfers
#define chamfers_z mccCurved_Guide_Section_III_71_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_71_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_71_chamfers_tb
#define nelements mccCurved_Guide_Section_III_71_nelements
#define nu mccCurved_Guide_Section_III_71_nu
#define phase mccCurved_Guide_Section_III_71_phase
#define reflect mccCurved_Guide_Section_III_71_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 18907 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_III_72' [72]. */
#define mccompcurname  Curved_Guide_Section_III_72
#define mccompcurtype  Guide_gravity
#define mccompcurindex 72
#define GVars mccCurved_Guide_Section_III_72_GVars
#define pTable mccCurved_Guide_Section_III_72_pTable
#define w1 mccCurved_Guide_Section_III_72_w1
#define h1 mccCurved_Guide_Section_III_72_h1
#define w2 mccCurved_Guide_Section_III_72_w2
#define h2 mccCurved_Guide_Section_III_72_h2
#define l mccCurved_Guide_Section_III_72_l
#define R0 mccCurved_Guide_Section_III_72_R0
#define Qc mccCurved_Guide_Section_III_72_Qc
#define alpha mccCurved_Guide_Section_III_72_alpha
#define m mccCurved_Guide_Section_III_72_m
#define W mccCurved_Guide_Section_III_72_W
#define nslit mccCurved_Guide_Section_III_72_nslit
#define d mccCurved_Guide_Section_III_72_d
#define mleft mccCurved_Guide_Section_III_72_mleft
#define mright mccCurved_Guide_Section_III_72_mright
#define mtop mccCurved_Guide_Section_III_72_mtop
#define mbottom mccCurved_Guide_Section_III_72_mbottom
#define nhslit mccCurved_Guide_Section_III_72_nhslit
#define G mccCurved_Guide_Section_III_72_G
#define aleft mccCurved_Guide_Section_III_72_aleft
#define aright mccCurved_Guide_Section_III_72_aright
#define atop mccCurved_Guide_Section_III_72_atop
#define abottom mccCurved_Guide_Section_III_72_abottom
#define wavy mccCurved_Guide_Section_III_72_wavy
#define wavy_z mccCurved_Guide_Section_III_72_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_72_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_72_wavy_lr
#define chamfers mccCurved_Guide_Section_III_72_chamfers
#define chamfers_z mccCurved_Guide_Section_III_72_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_72_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_72_chamfers_tb
#define nelements mccCurved_Guide_Section_III_72_nelements
#define nu mccCurved_Guide_Section_III_72_nu
#define phase mccCurved_Guide_Section_III_72_phase
#define reflect mccCurved_Guide_Section_III_72_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 18991 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_III_73' [73]. */
#define mccompcurname  Curved_Guide_Section_III_73
#define mccompcurtype  Guide_gravity
#define mccompcurindex 73
#define GVars mccCurved_Guide_Section_III_73_GVars
#define pTable mccCurved_Guide_Section_III_73_pTable
#define w1 mccCurved_Guide_Section_III_73_w1
#define h1 mccCurved_Guide_Section_III_73_h1
#define w2 mccCurved_Guide_Section_III_73_w2
#define h2 mccCurved_Guide_Section_III_73_h2
#define l mccCurved_Guide_Section_III_73_l
#define R0 mccCurved_Guide_Section_III_73_R0
#define Qc mccCurved_Guide_Section_III_73_Qc
#define alpha mccCurved_Guide_Section_III_73_alpha
#define m mccCurved_Guide_Section_III_73_m
#define W mccCurved_Guide_Section_III_73_W
#define nslit mccCurved_Guide_Section_III_73_nslit
#define d mccCurved_Guide_Section_III_73_d
#define mleft mccCurved_Guide_Section_III_73_mleft
#define mright mccCurved_Guide_Section_III_73_mright
#define mtop mccCurved_Guide_Section_III_73_mtop
#define mbottom mccCurved_Guide_Section_III_73_mbottom
#define nhslit mccCurved_Guide_Section_III_73_nhslit
#define G mccCurved_Guide_Section_III_73_G
#define aleft mccCurved_Guide_Section_III_73_aleft
#define aright mccCurved_Guide_Section_III_73_aright
#define atop mccCurved_Guide_Section_III_73_atop
#define abottom mccCurved_Guide_Section_III_73_abottom
#define wavy mccCurved_Guide_Section_III_73_wavy
#define wavy_z mccCurved_Guide_Section_III_73_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_73_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_73_wavy_lr
#define chamfers mccCurved_Guide_Section_III_73_chamfers
#define chamfers_z mccCurved_Guide_Section_III_73_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_73_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_73_chamfers_tb
#define nelements mccCurved_Guide_Section_III_73_nelements
#define nu mccCurved_Guide_Section_III_73_nu
#define phase mccCurved_Guide_Section_III_73_phase
#define reflect mccCurved_Guide_Section_III_73_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 19075 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_III_74' [74]. */
#define mccompcurname  Curved_Guide_Section_III_74
#define mccompcurtype  Guide_gravity
#define mccompcurindex 74
#define GVars mccCurved_Guide_Section_III_74_GVars
#define pTable mccCurved_Guide_Section_III_74_pTable
#define w1 mccCurved_Guide_Section_III_74_w1
#define h1 mccCurved_Guide_Section_III_74_h1
#define w2 mccCurved_Guide_Section_III_74_w2
#define h2 mccCurved_Guide_Section_III_74_h2
#define l mccCurved_Guide_Section_III_74_l
#define R0 mccCurved_Guide_Section_III_74_R0
#define Qc mccCurved_Guide_Section_III_74_Qc
#define alpha mccCurved_Guide_Section_III_74_alpha
#define m mccCurved_Guide_Section_III_74_m
#define W mccCurved_Guide_Section_III_74_W
#define nslit mccCurved_Guide_Section_III_74_nslit
#define d mccCurved_Guide_Section_III_74_d
#define mleft mccCurved_Guide_Section_III_74_mleft
#define mright mccCurved_Guide_Section_III_74_mright
#define mtop mccCurved_Guide_Section_III_74_mtop
#define mbottom mccCurved_Guide_Section_III_74_mbottom
#define nhslit mccCurved_Guide_Section_III_74_nhslit
#define G mccCurved_Guide_Section_III_74_G
#define aleft mccCurved_Guide_Section_III_74_aleft
#define aright mccCurved_Guide_Section_III_74_aright
#define atop mccCurved_Guide_Section_III_74_atop
#define abottom mccCurved_Guide_Section_III_74_abottom
#define wavy mccCurved_Guide_Section_III_74_wavy
#define wavy_z mccCurved_Guide_Section_III_74_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_74_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_74_wavy_lr
#define chamfers mccCurved_Guide_Section_III_74_chamfers
#define chamfers_z mccCurved_Guide_Section_III_74_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_74_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_74_chamfers_tb
#define nelements mccCurved_Guide_Section_III_74_nelements
#define nu mccCurved_Guide_Section_III_74_nu
#define phase mccCurved_Guide_Section_III_74_phase
#define reflect mccCurved_Guide_Section_III_74_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 19159 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_III_75' [75]. */
#define mccompcurname  Curved_Guide_Section_III_75
#define mccompcurtype  Guide_gravity
#define mccompcurindex 75
#define GVars mccCurved_Guide_Section_III_75_GVars
#define pTable mccCurved_Guide_Section_III_75_pTable
#define w1 mccCurved_Guide_Section_III_75_w1
#define h1 mccCurved_Guide_Section_III_75_h1
#define w2 mccCurved_Guide_Section_III_75_w2
#define h2 mccCurved_Guide_Section_III_75_h2
#define l mccCurved_Guide_Section_III_75_l
#define R0 mccCurved_Guide_Section_III_75_R0
#define Qc mccCurved_Guide_Section_III_75_Qc
#define alpha mccCurved_Guide_Section_III_75_alpha
#define m mccCurved_Guide_Section_III_75_m
#define W mccCurved_Guide_Section_III_75_W
#define nslit mccCurved_Guide_Section_III_75_nslit
#define d mccCurved_Guide_Section_III_75_d
#define mleft mccCurved_Guide_Section_III_75_mleft
#define mright mccCurved_Guide_Section_III_75_mright
#define mtop mccCurved_Guide_Section_III_75_mtop
#define mbottom mccCurved_Guide_Section_III_75_mbottom
#define nhslit mccCurved_Guide_Section_III_75_nhslit
#define G mccCurved_Guide_Section_III_75_G
#define aleft mccCurved_Guide_Section_III_75_aleft
#define aright mccCurved_Guide_Section_III_75_aright
#define atop mccCurved_Guide_Section_III_75_atop
#define abottom mccCurved_Guide_Section_III_75_abottom
#define wavy mccCurved_Guide_Section_III_75_wavy
#define wavy_z mccCurved_Guide_Section_III_75_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_75_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_75_wavy_lr
#define chamfers mccCurved_Guide_Section_III_75_chamfers
#define chamfers_z mccCurved_Guide_Section_III_75_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_75_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_75_chamfers_tb
#define nelements mccCurved_Guide_Section_III_75_nelements
#define nu mccCurved_Guide_Section_III_75_nu
#define phase mccCurved_Guide_Section_III_75_phase
#define reflect mccCurved_Guide_Section_III_75_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 19243 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_III_76' [76]. */
#define mccompcurname  Curved_Guide_Section_III_76
#define mccompcurtype  Guide_gravity
#define mccompcurindex 76
#define GVars mccCurved_Guide_Section_III_76_GVars
#define pTable mccCurved_Guide_Section_III_76_pTable
#define w1 mccCurved_Guide_Section_III_76_w1
#define h1 mccCurved_Guide_Section_III_76_h1
#define w2 mccCurved_Guide_Section_III_76_w2
#define h2 mccCurved_Guide_Section_III_76_h2
#define l mccCurved_Guide_Section_III_76_l
#define R0 mccCurved_Guide_Section_III_76_R0
#define Qc mccCurved_Guide_Section_III_76_Qc
#define alpha mccCurved_Guide_Section_III_76_alpha
#define m mccCurved_Guide_Section_III_76_m
#define W mccCurved_Guide_Section_III_76_W
#define nslit mccCurved_Guide_Section_III_76_nslit
#define d mccCurved_Guide_Section_III_76_d
#define mleft mccCurved_Guide_Section_III_76_mleft
#define mright mccCurved_Guide_Section_III_76_mright
#define mtop mccCurved_Guide_Section_III_76_mtop
#define mbottom mccCurved_Guide_Section_III_76_mbottom
#define nhslit mccCurved_Guide_Section_III_76_nhslit
#define G mccCurved_Guide_Section_III_76_G
#define aleft mccCurved_Guide_Section_III_76_aleft
#define aright mccCurved_Guide_Section_III_76_aright
#define atop mccCurved_Guide_Section_III_76_atop
#define abottom mccCurved_Guide_Section_III_76_abottom
#define wavy mccCurved_Guide_Section_III_76_wavy
#define wavy_z mccCurved_Guide_Section_III_76_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_76_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_76_wavy_lr
#define chamfers mccCurved_Guide_Section_III_76_chamfers
#define chamfers_z mccCurved_Guide_Section_III_76_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_76_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_76_chamfers_tb
#define nelements mccCurved_Guide_Section_III_76_nelements
#define nu mccCurved_Guide_Section_III_76_nu
#define phase mccCurved_Guide_Section_III_76_phase
#define reflect mccCurved_Guide_Section_III_76_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 19327 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_III_77' [77]. */
#define mccompcurname  Curved_Guide_Section_III_77
#define mccompcurtype  Guide_gravity
#define mccompcurindex 77
#define GVars mccCurved_Guide_Section_III_77_GVars
#define pTable mccCurved_Guide_Section_III_77_pTable
#define w1 mccCurved_Guide_Section_III_77_w1
#define h1 mccCurved_Guide_Section_III_77_h1
#define w2 mccCurved_Guide_Section_III_77_w2
#define h2 mccCurved_Guide_Section_III_77_h2
#define l mccCurved_Guide_Section_III_77_l
#define R0 mccCurved_Guide_Section_III_77_R0
#define Qc mccCurved_Guide_Section_III_77_Qc
#define alpha mccCurved_Guide_Section_III_77_alpha
#define m mccCurved_Guide_Section_III_77_m
#define W mccCurved_Guide_Section_III_77_W
#define nslit mccCurved_Guide_Section_III_77_nslit
#define d mccCurved_Guide_Section_III_77_d
#define mleft mccCurved_Guide_Section_III_77_mleft
#define mright mccCurved_Guide_Section_III_77_mright
#define mtop mccCurved_Guide_Section_III_77_mtop
#define mbottom mccCurved_Guide_Section_III_77_mbottom
#define nhslit mccCurved_Guide_Section_III_77_nhslit
#define G mccCurved_Guide_Section_III_77_G
#define aleft mccCurved_Guide_Section_III_77_aleft
#define aright mccCurved_Guide_Section_III_77_aright
#define atop mccCurved_Guide_Section_III_77_atop
#define abottom mccCurved_Guide_Section_III_77_abottom
#define wavy mccCurved_Guide_Section_III_77_wavy
#define wavy_z mccCurved_Guide_Section_III_77_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_77_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_77_wavy_lr
#define chamfers mccCurved_Guide_Section_III_77_chamfers
#define chamfers_z mccCurved_Guide_Section_III_77_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_77_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_77_chamfers_tb
#define nelements mccCurved_Guide_Section_III_77_nelements
#define nu mccCurved_Guide_Section_III_77_nu
#define phase mccCurved_Guide_Section_III_77_phase
#define reflect mccCurved_Guide_Section_III_77_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 19411 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_III_78' [78]. */
#define mccompcurname  Curved_Guide_Section_III_78
#define mccompcurtype  Guide_gravity
#define mccompcurindex 78
#define GVars mccCurved_Guide_Section_III_78_GVars
#define pTable mccCurved_Guide_Section_III_78_pTable
#define w1 mccCurved_Guide_Section_III_78_w1
#define h1 mccCurved_Guide_Section_III_78_h1
#define w2 mccCurved_Guide_Section_III_78_w2
#define h2 mccCurved_Guide_Section_III_78_h2
#define l mccCurved_Guide_Section_III_78_l
#define R0 mccCurved_Guide_Section_III_78_R0
#define Qc mccCurved_Guide_Section_III_78_Qc
#define alpha mccCurved_Guide_Section_III_78_alpha
#define m mccCurved_Guide_Section_III_78_m
#define W mccCurved_Guide_Section_III_78_W
#define nslit mccCurved_Guide_Section_III_78_nslit
#define d mccCurved_Guide_Section_III_78_d
#define mleft mccCurved_Guide_Section_III_78_mleft
#define mright mccCurved_Guide_Section_III_78_mright
#define mtop mccCurved_Guide_Section_III_78_mtop
#define mbottom mccCurved_Guide_Section_III_78_mbottom
#define nhslit mccCurved_Guide_Section_III_78_nhslit
#define G mccCurved_Guide_Section_III_78_G
#define aleft mccCurved_Guide_Section_III_78_aleft
#define aright mccCurved_Guide_Section_III_78_aright
#define atop mccCurved_Guide_Section_III_78_atop
#define abottom mccCurved_Guide_Section_III_78_abottom
#define wavy mccCurved_Guide_Section_III_78_wavy
#define wavy_z mccCurved_Guide_Section_III_78_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_78_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_78_wavy_lr
#define chamfers mccCurved_Guide_Section_III_78_chamfers
#define chamfers_z mccCurved_Guide_Section_III_78_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_78_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_78_chamfers_tb
#define nelements mccCurved_Guide_Section_III_78_nelements
#define nu mccCurved_Guide_Section_III_78_nu
#define phase mccCurved_Guide_Section_III_78_phase
#define reflect mccCurved_Guide_Section_III_78_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 19495 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_III_79' [79]. */
#define mccompcurname  Curved_Guide_Section_III_79
#define mccompcurtype  Guide_gravity
#define mccompcurindex 79
#define GVars mccCurved_Guide_Section_III_79_GVars
#define pTable mccCurved_Guide_Section_III_79_pTable
#define w1 mccCurved_Guide_Section_III_79_w1
#define h1 mccCurved_Guide_Section_III_79_h1
#define w2 mccCurved_Guide_Section_III_79_w2
#define h2 mccCurved_Guide_Section_III_79_h2
#define l mccCurved_Guide_Section_III_79_l
#define R0 mccCurved_Guide_Section_III_79_R0
#define Qc mccCurved_Guide_Section_III_79_Qc
#define alpha mccCurved_Guide_Section_III_79_alpha
#define m mccCurved_Guide_Section_III_79_m
#define W mccCurved_Guide_Section_III_79_W
#define nslit mccCurved_Guide_Section_III_79_nslit
#define d mccCurved_Guide_Section_III_79_d
#define mleft mccCurved_Guide_Section_III_79_mleft
#define mright mccCurved_Guide_Section_III_79_mright
#define mtop mccCurved_Guide_Section_III_79_mtop
#define mbottom mccCurved_Guide_Section_III_79_mbottom
#define nhslit mccCurved_Guide_Section_III_79_nhslit
#define G mccCurved_Guide_Section_III_79_G
#define aleft mccCurved_Guide_Section_III_79_aleft
#define aright mccCurved_Guide_Section_III_79_aright
#define atop mccCurved_Guide_Section_III_79_atop
#define abottom mccCurved_Guide_Section_III_79_abottom
#define wavy mccCurved_Guide_Section_III_79_wavy
#define wavy_z mccCurved_Guide_Section_III_79_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_79_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_79_wavy_lr
#define chamfers mccCurved_Guide_Section_III_79_chamfers
#define chamfers_z mccCurved_Guide_Section_III_79_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_79_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_79_chamfers_tb
#define nelements mccCurved_Guide_Section_III_79_nelements
#define nu mccCurved_Guide_Section_III_79_nu
#define phase mccCurved_Guide_Section_III_79_phase
#define reflect mccCurved_Guide_Section_III_79_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 19579 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Curved_Guide_Section_III_short' [80]. */
#define mccompcurname  Curved_Guide_Section_III_short
#define mccompcurtype  Guide_gravity
#define mccompcurindex 80
#define GVars mccCurved_Guide_Section_III_short_GVars
#define pTable mccCurved_Guide_Section_III_short_pTable
#define w1 mccCurved_Guide_Section_III_short_w1
#define h1 mccCurved_Guide_Section_III_short_h1
#define w2 mccCurved_Guide_Section_III_short_w2
#define h2 mccCurved_Guide_Section_III_short_h2
#define l mccCurved_Guide_Section_III_short_l
#define R0 mccCurved_Guide_Section_III_short_R0
#define Qc mccCurved_Guide_Section_III_short_Qc
#define alpha mccCurved_Guide_Section_III_short_alpha
#define m mccCurved_Guide_Section_III_short_m
#define W mccCurved_Guide_Section_III_short_W
#define nslit mccCurved_Guide_Section_III_short_nslit
#define d mccCurved_Guide_Section_III_short_d
#define mleft mccCurved_Guide_Section_III_short_mleft
#define mright mccCurved_Guide_Section_III_short_mright
#define mtop mccCurved_Guide_Section_III_short_mtop
#define mbottom mccCurved_Guide_Section_III_short_mbottom
#define nhslit mccCurved_Guide_Section_III_short_nhslit
#define G mccCurved_Guide_Section_III_short_G
#define aleft mccCurved_Guide_Section_III_short_aleft
#define aright mccCurved_Guide_Section_III_short_aright
#define atop mccCurved_Guide_Section_III_short_atop
#define abottom mccCurved_Guide_Section_III_short_abottom
#define wavy mccCurved_Guide_Section_III_short_wavy
#define wavy_z mccCurved_Guide_Section_III_short_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_short_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_short_wavy_lr
#define chamfers mccCurved_Guide_Section_III_short_chamfers
#define chamfers_z mccCurved_Guide_Section_III_short_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_short_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_short_chamfers_tb
#define nelements mccCurved_Guide_Section_III_short_nelements
#define nu mccCurved_Guide_Section_III_short_nu
#define phase mccCurved_Guide_Section_III_short_phase
#define reflect mccCurved_Guide_Section_III_short_reflect
#line 335 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 19663 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'CGS3_end_ToF' [81]. */
#define mccompcurname  CGS3_end_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 81
#define nt mccCGS3_end_ToF_nt
#define TOF_N mccCGS3_end_ToF_TOF_N
#define TOF_p mccCGS3_end_ToF_TOF_p
#define TOF_p2 mccCGS3_end_ToF_TOF_p2
#define t_min mccCGS3_end_ToF_t_min
#define t_max mccCGS3_end_ToF_t_max
#define delta_t mccCGS3_end_ToF_delta_t
#define filename mccCGS3_end_ToF_filename
#define xmin mccCGS3_end_ToF_xmin
#define xmax mccCGS3_end_ToF_xmax
#define ymin mccCGS3_end_ToF_ymin
#define ymax mccCGS3_end_ToF_ymax
#define xwidth mccCGS3_end_ToF_xwidth
#define yheight mccCGS3_end_ToF_yheight
#define tmin mccCGS3_end_ToF_tmin
#define tmax mccCGS3_end_ToF_tmax
#define dt mccCGS3_end_ToF_dt
#define restore_neutron mccCGS3_end_ToF_restore_neutron
#define nowritefile mccCGS3_end_ToF_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 19732 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'CGS3_end_ToF_Z' [82]. */
#define mccompcurname  CGS3_end_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 82
#define nt mccCGS3_end_ToF_Z_nt
#define TOF_N mccCGS3_end_ToF_Z_TOF_N
#define TOF_p mccCGS3_end_ToF_Z_TOF_p
#define TOF_p2 mccCGS3_end_ToF_Z_TOF_p2
#define t_min mccCGS3_end_ToF_Z_t_min
#define t_max mccCGS3_end_ToF_Z_t_max
#define delta_t mccCGS3_end_ToF_Z_delta_t
#define filename mccCGS3_end_ToF_Z_filename
#define xmin mccCGS3_end_ToF_Z_xmin
#define xmax mccCGS3_end_ToF_Z_xmax
#define ymin mccCGS3_end_ToF_Z_ymin
#define ymax mccCGS3_end_ToF_Z_ymax
#define xwidth mccCGS3_end_ToF_Z_xwidth
#define yheight mccCGS3_end_ToF_Z_yheight
#define tmin mccCGS3_end_ToF_Z_tmin
#define tmax mccCGS3_end_ToF_Z_tmax
#define dt mccCGS3_end_ToF_Z_dt
#define restore_neutron mccCGS3_end_ToF_Z_restore_neutron
#define nowritefile mccCGS3_end_ToF_Z_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 19784 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'CGS3_end_Lam' [83]. */
#define mccompcurname  CGS3_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 83
#define nL mccCGS3_end_Lam_nL
#define L_N mccCGS3_end_Lam_L_N
#define L_p mccCGS3_end_Lam_L_p
#define L_p2 mccCGS3_end_Lam_L_p2
#define filename mccCGS3_end_Lam_filename
#define xmin mccCGS3_end_Lam_xmin
#define xmax mccCGS3_end_Lam_xmax
#define ymin mccCGS3_end_Lam_ymin
#define ymax mccCGS3_end_Lam_ymax
#define xwidth mccCGS3_end_Lam_xwidth
#define yheight mccCGS3_end_Lam_yheight
#define Lmin mccCGS3_end_Lam_Lmin
#define Lmax mccCGS3_end_Lam_Lmax
#define restore_neutron mccCGS3_end_Lam_restore_neutron
#define nowritefile mccCGS3_end_Lam_nowritefile
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 19830 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Straight_Guide_Section_I' [84]. */
#define mccompcurname  Straight_Guide_Section_I
#define mccompcurtype  Guide
#define mccompcurindex 84
#define pTable mccStraight_Guide_Section_I_pTable
#define reflect mccStraight_Guide_Section_I_reflect
#define w1 mccStraight_Guide_Section_I_w1
#define h1 mccStraight_Guide_Section_I_h1
#define w2 mccStraight_Guide_Section_I_w2
#define h2 mccStraight_Guide_Section_I_h2
#define l mccStraight_Guide_Section_I_l
#define R0 mccStraight_Guide_Section_I_R0
#define Qc mccStraight_Guide_Section_I_Qc
#define alpha mccStraight_Guide_Section_I_alpha
#define m mccStraight_Guide_Section_I_m
#define W mccStraight_Guide_Section_I_W
#line 70 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide.comp"
t_Table pTable;
#line 19868 "./SNS_BASIS.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap5_start' [85]. */
#define mccompcurname  Gap5_start
#define mccompcurtype  Arm
#define mccompcurindex 85
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap5_start_ToF' [86]. */
#define mccompcurname  Gap5_start_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 86
#define nt mccGap5_start_ToF_nt
#define TOF_N mccGap5_start_ToF_TOF_N
#define TOF_p mccGap5_start_ToF_TOF_p
#define TOF_p2 mccGap5_start_ToF_TOF_p2
#define t_min mccGap5_start_ToF_t_min
#define t_max mccGap5_start_ToF_t_max
#define delta_t mccGap5_start_ToF_delta_t
#define filename mccGap5_start_ToF_filename
#define xmin mccGap5_start_ToF_xmin
#define xmax mccGap5_start_ToF_xmax
#define ymin mccGap5_start_ToF_ymin
#define ymax mccGap5_start_ToF_ymax
#define xwidth mccGap5_start_ToF_xwidth
#define yheight mccGap5_start_ToF_yheight
#define tmin mccGap5_start_ToF_tmin
#define tmax mccGap5_start_ToF_tmax
#define dt mccGap5_start_ToF_dt
#define restore_neutron mccGap5_start_ToF_restore_neutron
#define nowritefile mccGap5_start_ToF_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 19921 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap5_start_ToF_Z' [87]. */
#define mccompcurname  Gap5_start_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 87
#define nt mccGap5_start_ToF_Z_nt
#define TOF_N mccGap5_start_ToF_Z_TOF_N
#define TOF_p mccGap5_start_ToF_Z_TOF_p
#define TOF_p2 mccGap5_start_ToF_Z_TOF_p2
#define t_min mccGap5_start_ToF_Z_t_min
#define t_max mccGap5_start_ToF_Z_t_max
#define delta_t mccGap5_start_ToF_Z_delta_t
#define filename mccGap5_start_ToF_Z_filename
#define xmin mccGap5_start_ToF_Z_xmin
#define xmax mccGap5_start_ToF_Z_xmax
#define ymin mccGap5_start_ToF_Z_ymin
#define ymax mccGap5_start_ToF_Z_ymax
#define xwidth mccGap5_start_ToF_Z_xwidth
#define yheight mccGap5_start_ToF_Z_yheight
#define tmin mccGap5_start_ToF_Z_tmin
#define tmax mccGap5_start_ToF_Z_tmax
#define dt mccGap5_start_ToF_Z_dt
#define restore_neutron mccGap5_start_ToF_Z_restore_neutron
#define nowritefile mccGap5_start_ToF_Z_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 19973 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap5_start_Lam' [88]. */
#define mccompcurname  Gap5_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 88
#define nL mccGap5_start_Lam_nL
#define L_N mccGap5_start_Lam_L_N
#define L_p mccGap5_start_Lam_L_p
#define L_p2 mccGap5_start_Lam_L_p2
#define filename mccGap5_start_Lam_filename
#define xmin mccGap5_start_Lam_xmin
#define xmax mccGap5_start_Lam_xmax
#define ymin mccGap5_start_Lam_ymin
#define ymax mccGap5_start_Lam_ymax
#define xwidth mccGap5_start_Lam_xwidth
#define yheight mccGap5_start_Lam_yheight
#define Lmin mccGap5_start_Lam_Lmin
#define Lmax mccGap5_start_Lam_Lmax
#define restore_neutron mccGap5_start_Lam_restore_neutron
#define nowritefile mccGap5_start_Lam_nowritefile
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 20019 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap5_start_PSD' [89]. */
#define mccompcurname  Gap5_start_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 89
#define PSD_N mccGap5_start_PSD_PSD_N
#define PSD_p mccGap5_start_PSD_PSD_p
#define PSD_p2 mccGap5_start_PSD_PSD_p2
#define nx mccGap5_start_PSD_nx
#define ny mccGap5_start_PSD_ny
#define filename mccGap5_start_PSD_filename
#define xmin mccGap5_start_PSD_xmin
#define xmax mccGap5_start_PSD_xmax
#define ymin mccGap5_start_PSD_ymin
#define ymax mccGap5_start_PSD_ymax
#define xwidth mccGap5_start_PSD_xwidth
#define yheight mccGap5_start_PSD_yheight
#define restore_neutron mccGap5_start_PSD_restore_neutron
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
  DArray2d PSD_N;
  DArray2d PSD_p;
  DArray2d PSD_p2;
#line 20060 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Chopper3' [90]. */
#define mccompcurname  Chopper3
#define mccompcurtype  DiskChopper
#define mccompcurindex 90
#define Tg mccChopper3_Tg
#define To mccChopper3_To
#define delta_y mccChopper3_delta_y
#define height mccChopper3_height
#define omega mccChopper3_omega
#define theta_0 mccChopper3_theta_0
#define radius mccChopper3_radius
#define yheight mccChopper3_yheight
#define nu mccChopper3_nu
#define nslit mccChopper3_nslit
#define jitter mccChopper3_jitter
#define delay mccChopper3_delay
#define isfirst mccChopper3_isfirst
#define n_pulse mccChopper3_n_pulse
#define abs_out mccChopper3_abs_out
#define phase mccChopper3_phase
#define xwidth mccChopper3_xwidth
#define verbose mccChopper3_verbose
#line 66 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/DiskChopper.comp"
double Tg,To,delta_y,height,omega;
#line 20102 "./SNS_BASIS.c"
#undef verbose
#undef xwidth
#undef phase
#undef abs_out
#undef n_pulse
#undef isfirst
#undef delay
#undef jitter
#undef nslit
#undef nu
#undef yheight
#undef radius
#undef theta_0
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Chopper3_ToF' [91]. */
#define mccompcurname  Chopper3_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 91
#define nt mccChopper3_ToF_nt
#define TOF_N mccChopper3_ToF_TOF_N
#define TOF_p mccChopper3_ToF_TOF_p
#define TOF_p2 mccChopper3_ToF_TOF_p2
#define t_min mccChopper3_ToF_t_min
#define t_max mccChopper3_ToF_t_max
#define delta_t mccChopper3_ToF_delta_t
#define filename mccChopper3_ToF_filename
#define xmin mccChopper3_ToF_xmin
#define xmax mccChopper3_ToF_xmax
#define ymin mccChopper3_ToF_ymin
#define ymax mccChopper3_ToF_ymax
#define xwidth mccChopper3_ToF_xwidth
#define yheight mccChopper3_ToF_yheight
#define tmin mccChopper3_ToF_tmin
#define tmax mccChopper3_ToF_tmax
#define dt mccChopper3_ToF_dt
#define restore_neutron mccChopper3_ToF_restore_neutron
#define nowritefile mccChopper3_ToF_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 20153 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Chopper3_ToF_Z' [92]. */
#define mccompcurname  Chopper3_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 92
#define nt mccChopper3_ToF_Z_nt
#define TOF_N mccChopper3_ToF_Z_TOF_N
#define TOF_p mccChopper3_ToF_Z_TOF_p
#define TOF_p2 mccChopper3_ToF_Z_TOF_p2
#define t_min mccChopper3_ToF_Z_t_min
#define t_max mccChopper3_ToF_Z_t_max
#define delta_t mccChopper3_ToF_Z_delta_t
#define filename mccChopper3_ToF_Z_filename
#define xmin mccChopper3_ToF_Z_xmin
#define xmax mccChopper3_ToF_Z_xmax
#define ymin mccChopper3_ToF_Z_ymin
#define ymax mccChopper3_ToF_Z_ymax
#define xwidth mccChopper3_ToF_Z_xwidth
#define yheight mccChopper3_ToF_Z_yheight
#define tmin mccChopper3_ToF_Z_tmin
#define tmax mccChopper3_ToF_Z_tmax
#define dt mccChopper3_ToF_Z_dt
#define restore_neutron mccChopper3_ToF_Z_restore_neutron
#define nowritefile mccChopper3_ToF_Z_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 20205 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap5_end_Lam' [93]. */
#define mccompcurname  Gap5_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 93
#define nL mccGap5_end_Lam_nL
#define L_N mccGap5_end_Lam_L_N
#define L_p mccGap5_end_Lam_L_p
#define L_p2 mccGap5_end_Lam_L_p2
#define filename mccGap5_end_Lam_filename
#define xmin mccGap5_end_Lam_xmin
#define xmax mccGap5_end_Lam_xmax
#define ymin mccGap5_end_Lam_ymin
#define ymax mccGap5_end_Lam_ymax
#define xwidth mccGap5_end_Lam_xwidth
#define yheight mccGap5_end_Lam_yheight
#define Lmin mccGap5_end_Lam_Lmin
#define Lmax mccGap5_end_Lam_Lmax
#define restore_neutron mccGap5_end_Lam_restore_neutron
#define nowritefile mccGap5_end_Lam_nowritefile
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 20251 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap5_end_PSD' [94]. */
#define mccompcurname  Gap5_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 94
#define PSD_N mccGap5_end_PSD_PSD_N
#define PSD_p mccGap5_end_PSD_PSD_p
#define PSD_p2 mccGap5_end_PSD_PSD_p2
#define nx mccGap5_end_PSD_nx
#define ny mccGap5_end_PSD_ny
#define filename mccGap5_end_PSD_filename
#define xmin mccGap5_end_PSD_xmin
#define xmax mccGap5_end_PSD_xmax
#define ymin mccGap5_end_PSD_ymin
#define ymax mccGap5_end_PSD_ymax
#define xwidth mccGap5_end_PSD_xwidth
#define yheight mccGap5_end_PSD_yheight
#define restore_neutron mccGap5_end_PSD_restore_neutron
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
  DArray2d PSD_N;
  DArray2d PSD_p;
  DArray2d PSD_p2;
#line 20292 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Gap5_end' [95]. */
#define mccompcurname  Gap5_end
#define mccompcurtype  Arm
#define mccompcurindex 95
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Straight_Guide_Section_II' [96]. */
#define mccompcurname  Straight_Guide_Section_II
#define mccompcurtype  Guide
#define mccompcurindex 96
#define pTable mccStraight_Guide_Section_II_pTable
#define reflect mccStraight_Guide_Section_II_reflect
#define w1 mccStraight_Guide_Section_II_w1
#define h1 mccStraight_Guide_Section_II_h1
#define w2 mccStraight_Guide_Section_II_w2
#define h2 mccStraight_Guide_Section_II_h2
#define l mccStraight_Guide_Section_II_l
#define R0 mccStraight_Guide_Section_II_R0
#define Qc mccStraight_Guide_Section_II_Qc
#define alpha mccStraight_Guide_Section_II_alpha
#define m mccStraight_Guide_Section_II_m
#define W mccStraight_Guide_Section_II_W
#line 70 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide.comp"
t_Table pTable;
#line 20336 "./SNS_BASIS.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'SGS2_end_Lam' [97]. */
#define mccompcurname  SGS2_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 97
#define nL mccSGS2_end_Lam_nL
#define L_N mccSGS2_end_Lam_L_N
#define L_p mccSGS2_end_Lam_L_p
#define L_p2 mccSGS2_end_Lam_L_p2
#define filename mccSGS2_end_Lam_filename
#define xmin mccSGS2_end_Lam_xmin
#define xmax mccSGS2_end_Lam_xmax
#define ymin mccSGS2_end_Lam_ymin
#define ymax mccSGS2_end_Lam_ymax
#define xwidth mccSGS2_end_Lam_xwidth
#define yheight mccSGS2_end_Lam_yheight
#define Lmin mccSGS2_end_Lam_Lmin
#define Lmax mccSGS2_end_Lam_Lmax
#define restore_neutron mccSGS2_end_Lam_restore_neutron
#define nowritefile mccSGS2_end_Lam_nowritefile
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 20375 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'SGS2_end_PSD' [98]. */
#define mccompcurname  SGS2_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 98
#define PSD_N mccSGS2_end_PSD_PSD_N
#define PSD_p mccSGS2_end_PSD_PSD_p
#define PSD_p2 mccSGS2_end_PSD_PSD_p2
#define nx mccSGS2_end_PSD_nx
#define ny mccSGS2_end_PSD_ny
#define filename mccSGS2_end_PSD_filename
#define xmin mccSGS2_end_PSD_xmin
#define xmax mccSGS2_end_PSD_xmax
#define ymin mccSGS2_end_PSD_ymin
#define ymax mccSGS2_end_PSD_ymax
#define xwidth mccSGS2_end_PSD_xwidth
#define yheight mccSGS2_end_PSD_yheight
#define restore_neutron mccSGS2_end_PSD_restore_neutron
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
  DArray2d PSD_N;
  DArray2d PSD_p;
  DArray2d PSD_p2;
#line 20416 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Straight_Guide_Section_III' [99]. */
#define mccompcurname  Straight_Guide_Section_III
#define mccompcurtype  Guide
#define mccompcurindex 99
#define pTable mccStraight_Guide_Section_III_pTable
#define reflect mccStraight_Guide_Section_III_reflect
#define w1 mccStraight_Guide_Section_III_w1
#define h1 mccStraight_Guide_Section_III_h1
#define w2 mccStraight_Guide_Section_III_w2
#define h2 mccStraight_Guide_Section_III_h2
#define l mccStraight_Guide_Section_III_l
#define R0 mccStraight_Guide_Section_III_R0
#define Qc mccStraight_Guide_Section_III_Qc
#define alpha mccStraight_Guide_Section_III_alpha
#define m mccStraight_Guide_Section_III_m
#define W mccStraight_Guide_Section_III_W
#line 70 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide.comp"
t_Table pTable;
#line 20452 "./SNS_BASIS.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'SG3_end_ToF' [100]. */
#define mccompcurname  SG3_end_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 100
#define nt mccSG3_end_ToF_nt
#define TOF_N mccSG3_end_ToF_TOF_N
#define TOF_p mccSG3_end_ToF_TOF_p
#define TOF_p2 mccSG3_end_ToF_TOF_p2
#define t_min mccSG3_end_ToF_t_min
#define t_max mccSG3_end_ToF_t_max
#define delta_t mccSG3_end_ToF_delta_t
#define filename mccSG3_end_ToF_filename
#define xmin mccSG3_end_ToF_xmin
#define xmax mccSG3_end_ToF_xmax
#define ymin mccSG3_end_ToF_ymin
#define ymax mccSG3_end_ToF_ymax
#define xwidth mccSG3_end_ToF_xwidth
#define yheight mccSG3_end_ToF_yheight
#define tmin mccSG3_end_ToF_tmin
#define tmax mccSG3_end_ToF_tmax
#define dt mccSG3_end_ToF_dt
#define restore_neutron mccSG3_end_ToF_restore_neutron
#define nowritefile mccSG3_end_ToF_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 20497 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'SG3_end_ToF_Z' [101]. */
#define mccompcurname  SG3_end_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 101
#define nt mccSG3_end_ToF_Z_nt
#define TOF_N mccSG3_end_ToF_Z_TOF_N
#define TOF_p mccSG3_end_ToF_Z_TOF_p
#define TOF_p2 mccSG3_end_ToF_Z_TOF_p2
#define t_min mccSG3_end_ToF_Z_t_min
#define t_max mccSG3_end_ToF_Z_t_max
#define delta_t mccSG3_end_ToF_Z_delta_t
#define filename mccSG3_end_ToF_Z_filename
#define xmin mccSG3_end_ToF_Z_xmin
#define xmax mccSG3_end_ToF_Z_xmax
#define ymin mccSG3_end_ToF_Z_ymin
#define ymax mccSG3_end_ToF_Z_ymax
#define xwidth mccSG3_end_ToF_Z_xwidth
#define yheight mccSG3_end_ToF_Z_yheight
#define tmin mccSG3_end_ToF_Z_tmin
#define tmax mccSG3_end_ToF_Z_tmax
#define dt mccSG3_end_ToF_Z_dt
#define restore_neutron mccSG3_end_ToF_Z_restore_neutron
#define nowritefile mccSG3_end_ToF_Z_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 20549 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'SG3_end_Lam' [102]. */
#define mccompcurname  SG3_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 102
#define nL mccSG3_end_Lam_nL
#define L_N mccSG3_end_Lam_L_N
#define L_p mccSG3_end_Lam_L_p
#define L_p2 mccSG3_end_Lam_L_p2
#define filename mccSG3_end_Lam_filename
#define xmin mccSG3_end_Lam_xmin
#define xmax mccSG3_end_Lam_xmax
#define ymin mccSG3_end_Lam_ymin
#define ymax mccSG3_end_Lam_ymax
#define xwidth mccSG3_end_Lam_xwidth
#define yheight mccSG3_end_Lam_yheight
#define Lmin mccSG3_end_Lam_Lmin
#define Lmax mccSG3_end_Lam_Lmax
#define restore_neutron mccSG3_end_Lam_restore_neutron
#define nowritefile mccSG3_end_Lam_nowritefile
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 20595 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'SG3_end_PSD' [103]. */
#define mccompcurname  SG3_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 103
#define PSD_N mccSG3_end_PSD_PSD_N
#define PSD_p mccSG3_end_PSD_PSD_p
#define PSD_p2 mccSG3_end_PSD_PSD_p2
#define nx mccSG3_end_PSD_nx
#define ny mccSG3_end_PSD_ny
#define filename mccSG3_end_PSD_filename
#define xmin mccSG3_end_PSD_xmin
#define xmax mccSG3_end_PSD_xmax
#define ymin mccSG3_end_PSD_ymin
#define ymax mccSG3_end_PSD_ymax
#define xwidth mccSG3_end_PSD_xwidth
#define yheight mccSG3_end_PSD_yheight
#define restore_neutron mccSG3_end_PSD_restore_neutron
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
  DArray2d PSD_N;
  DArray2d PSD_p;
  DArray2d PSD_p2;
#line 20636 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Funnel_1' [104]. */
#define mccompcurname  Funnel_1
#define mccompcurtype  Guide_m
#define mccompcurindex 104
#define reflect mccFunnel_1_reflect
#define pTable mccFunnel_1_pTable
#define m mccFunnel_1_m
#define alpha mccFunnel_1_alpha
#define Qc mccFunnel_1_Qc
#define R0 mccFunnel_1_R0
#define W mccFunnel_1_W
#define w1 mccFunnel_1_w1
#define h1 mccFunnel_1_h1
#define w2 mccFunnel_1_w2
#define h2 mccFunnel_1_h2
#define l mccFunnel_1_l
#define R0_left mccFunnel_1_R0_left
#define R0_right mccFunnel_1_R0_right
#define R0_top mccFunnel_1_R0_top
#define R0_bottom mccFunnel_1_R0_bottom
#define Qc_left mccFunnel_1_Qc_left
#define Qc_right mccFunnel_1_Qc_right
#define Qc_top mccFunnel_1_Qc_top
#define Qc_bottom mccFunnel_1_Qc_bottom
#define alpha_left mccFunnel_1_alpha_left
#define alpha_right mccFunnel_1_alpha_right
#define alpha_top mccFunnel_1_alpha_top
#define alpha_bottom mccFunnel_1_alpha_bottom
#define m_left mccFunnel_1_m_left
#define m_right mccFunnel_1_m_right
#define m_top mccFunnel_1_m_top
#define m_bottom mccFunnel_1_m_bottom
#define W_left mccFunnel_1_W_left
#define W_right mccFunnel_1_W_right
#define W_top mccFunnel_1_W_top
#define W_bottom mccFunnel_1_W_bottom
#line 91 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_m.comp"
  t_Table pTable;
  double m,alpha,Qc,R0,W;
#line 20693 "./SNS_BASIS.c"
#undef W_bottom
#undef W_top
#undef W_right
#undef W_left
#undef m_bottom
#undef m_top
#undef m_right
#undef m_left
#undef alpha_bottom
#undef alpha_top
#undef alpha_right
#undef alpha_left
#undef Qc_bottom
#undef Qc_top
#undef Qc_right
#undef Qc_left
#undef R0_bottom
#undef R0_top
#undef R0_right
#undef R0_left
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef W
#undef R0
#undef Qc
#undef alpha
#undef m
#undef pTable
#undef reflect
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PSD_post_funnel1' [105]. */
#define mccompcurname  PSD_post_funnel1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 105
#define PSD_N mccPSD_post_funnel1_PSD_N
#define PSD_p mccPSD_post_funnel1_PSD_p
#define PSD_p2 mccPSD_post_funnel1_PSD_p2
#define nx mccPSD_post_funnel1_nx
#define ny mccPSD_post_funnel1_ny
#define filename mccPSD_post_funnel1_filename
#define xmin mccPSD_post_funnel1_xmin
#define xmax mccPSD_post_funnel1_xmax
#define ymin mccPSD_post_funnel1_ymin
#define ymax mccPSD_post_funnel1_ymax
#define xwidth mccPSD_post_funnel1_xwidth
#define yheight mccPSD_post_funnel1_yheight
#define restore_neutron mccPSD_post_funnel1_restore_neutron
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
  DArray2d PSD_N;
  DArray2d PSD_p;
  DArray2d PSD_p2;
#line 20751 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Funnel_2' [106]. */
#define mccompcurname  Funnel_2
#define mccompcurtype  Guide_m
#define mccompcurindex 106
#define reflect mccFunnel_2_reflect
#define pTable mccFunnel_2_pTable
#define m mccFunnel_2_m
#define alpha mccFunnel_2_alpha
#define Qc mccFunnel_2_Qc
#define R0 mccFunnel_2_R0
#define W mccFunnel_2_W
#define w1 mccFunnel_2_w1
#define h1 mccFunnel_2_h1
#define w2 mccFunnel_2_w2
#define h2 mccFunnel_2_h2
#define l mccFunnel_2_l
#define R0_left mccFunnel_2_R0_left
#define R0_right mccFunnel_2_R0_right
#define R0_top mccFunnel_2_R0_top
#define R0_bottom mccFunnel_2_R0_bottom
#define Qc_left mccFunnel_2_Qc_left
#define Qc_right mccFunnel_2_Qc_right
#define Qc_top mccFunnel_2_Qc_top
#define Qc_bottom mccFunnel_2_Qc_bottom
#define alpha_left mccFunnel_2_alpha_left
#define alpha_right mccFunnel_2_alpha_right
#define alpha_top mccFunnel_2_alpha_top
#define alpha_bottom mccFunnel_2_alpha_bottom
#define m_left mccFunnel_2_m_left
#define m_right mccFunnel_2_m_right
#define m_top mccFunnel_2_m_top
#define m_bottom mccFunnel_2_m_bottom
#define W_left mccFunnel_2_W_left
#define W_right mccFunnel_2_W_right
#define W_top mccFunnel_2_W_top
#define W_bottom mccFunnel_2_W_bottom
#line 91 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_m.comp"
  t_Table pTable;
  double m,alpha,Qc,R0,W;
#line 20808 "./SNS_BASIS.c"
#undef W_bottom
#undef W_top
#undef W_right
#undef W_left
#undef m_bottom
#undef m_top
#undef m_right
#undef m_left
#undef alpha_bottom
#undef alpha_top
#undef alpha_right
#undef alpha_left
#undef Qc_bottom
#undef Qc_top
#undef Qc_right
#undef Qc_left
#undef R0_bottom
#undef R0_top
#undef R0_right
#undef R0_left
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef W
#undef R0
#undef Qc
#undef alpha
#undef m
#undef pTable
#undef reflect
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PSD_post_funnel2' [107]. */
#define mccompcurname  PSD_post_funnel2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 107
#define PSD_N mccPSD_post_funnel2_PSD_N
#define PSD_p mccPSD_post_funnel2_PSD_p
#define PSD_p2 mccPSD_post_funnel2_PSD_p2
#define nx mccPSD_post_funnel2_nx
#define ny mccPSD_post_funnel2_ny
#define filename mccPSD_post_funnel2_filename
#define xmin mccPSD_post_funnel2_xmin
#define xmax mccPSD_post_funnel2_xmax
#define ymin mccPSD_post_funnel2_ymin
#define ymax mccPSD_post_funnel2_ymax
#define xwidth mccPSD_post_funnel2_xwidth
#define yheight mccPSD_post_funnel2_yheight
#define restore_neutron mccPSD_post_funnel2_restore_neutron
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
  DArray2d PSD_N;
  DArray2d PSD_p;
  DArray2d PSD_p2;
#line 20866 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Funnel_3' [108]. */
#define mccompcurname  Funnel_3
#define mccompcurtype  Guide_m
#define mccompcurindex 108
#define reflect mccFunnel_3_reflect
#define pTable mccFunnel_3_pTable
#define m mccFunnel_3_m
#define alpha mccFunnel_3_alpha
#define Qc mccFunnel_3_Qc
#define R0 mccFunnel_3_R0
#define W mccFunnel_3_W
#define w1 mccFunnel_3_w1
#define h1 mccFunnel_3_h1
#define w2 mccFunnel_3_w2
#define h2 mccFunnel_3_h2
#define l mccFunnel_3_l
#define R0_left mccFunnel_3_R0_left
#define R0_right mccFunnel_3_R0_right
#define R0_top mccFunnel_3_R0_top
#define R0_bottom mccFunnel_3_R0_bottom
#define Qc_left mccFunnel_3_Qc_left
#define Qc_right mccFunnel_3_Qc_right
#define Qc_top mccFunnel_3_Qc_top
#define Qc_bottom mccFunnel_3_Qc_bottom
#define alpha_left mccFunnel_3_alpha_left
#define alpha_right mccFunnel_3_alpha_right
#define alpha_top mccFunnel_3_alpha_top
#define alpha_bottom mccFunnel_3_alpha_bottom
#define m_left mccFunnel_3_m_left
#define m_right mccFunnel_3_m_right
#define m_top mccFunnel_3_m_top
#define m_bottom mccFunnel_3_m_bottom
#define W_left mccFunnel_3_W_left
#define W_right mccFunnel_3_W_right
#define W_top mccFunnel_3_W_top
#define W_bottom mccFunnel_3_W_bottom
#line 91 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_m.comp"
  t_Table pTable;
  double m,alpha,Qc,R0,W;
#line 20923 "./SNS_BASIS.c"
#undef W_bottom
#undef W_top
#undef W_right
#undef W_left
#undef m_bottom
#undef m_top
#undef m_right
#undef m_left
#undef alpha_bottom
#undef alpha_top
#undef alpha_right
#undef alpha_left
#undef Qc_bottom
#undef Qc_top
#undef Qc_right
#undef Qc_left
#undef R0_bottom
#undef R0_top
#undef R0_right
#undef R0_left
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef W
#undef R0
#undef Qc
#undef alpha
#undef m
#undef pTable
#undef reflect
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PSD_post_funnel3' [109]. */
#define mccompcurname  PSD_post_funnel3
#define mccompcurtype  PSD_monitor
#define mccompcurindex 109
#define PSD_N mccPSD_post_funnel3_PSD_N
#define PSD_p mccPSD_post_funnel3_PSD_p
#define PSD_p2 mccPSD_post_funnel3_PSD_p2
#define nx mccPSD_post_funnel3_nx
#define ny mccPSD_post_funnel3_ny
#define filename mccPSD_post_funnel3_filename
#define xmin mccPSD_post_funnel3_xmin
#define xmax mccPSD_post_funnel3_xmax
#define ymin mccPSD_post_funnel3_ymin
#define ymax mccPSD_post_funnel3_ymax
#define xwidth mccPSD_post_funnel3_xwidth
#define yheight mccPSD_post_funnel3_yheight
#define restore_neutron mccPSD_post_funnel3_restore_neutron
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
  DArray2d PSD_N;
  DArray2d PSD_p;
  DArray2d PSD_p2;
#line 20981 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Funnel_4' [110]. */
#define mccompcurname  Funnel_4
#define mccompcurtype  Guide_m
#define mccompcurindex 110
#define reflect mccFunnel_4_reflect
#define pTable mccFunnel_4_pTable
#define m mccFunnel_4_m
#define alpha mccFunnel_4_alpha
#define Qc mccFunnel_4_Qc
#define R0 mccFunnel_4_R0
#define W mccFunnel_4_W
#define w1 mccFunnel_4_w1
#define h1 mccFunnel_4_h1
#define w2 mccFunnel_4_w2
#define h2 mccFunnel_4_h2
#define l mccFunnel_4_l
#define R0_left mccFunnel_4_R0_left
#define R0_right mccFunnel_4_R0_right
#define R0_top mccFunnel_4_R0_top
#define R0_bottom mccFunnel_4_R0_bottom
#define Qc_left mccFunnel_4_Qc_left
#define Qc_right mccFunnel_4_Qc_right
#define Qc_top mccFunnel_4_Qc_top
#define Qc_bottom mccFunnel_4_Qc_bottom
#define alpha_left mccFunnel_4_alpha_left
#define alpha_right mccFunnel_4_alpha_right
#define alpha_top mccFunnel_4_alpha_top
#define alpha_bottom mccFunnel_4_alpha_bottom
#define m_left mccFunnel_4_m_left
#define m_right mccFunnel_4_m_right
#define m_top mccFunnel_4_m_top
#define m_bottom mccFunnel_4_m_bottom
#define W_left mccFunnel_4_W_left
#define W_right mccFunnel_4_W_right
#define W_top mccFunnel_4_W_top
#define W_bottom mccFunnel_4_W_bottom
#line 91 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_m.comp"
  t_Table pTable;
  double m,alpha,Qc,R0,W;
#line 21038 "./SNS_BASIS.c"
#undef W_bottom
#undef W_top
#undef W_right
#undef W_left
#undef m_bottom
#undef m_top
#undef m_right
#undef m_left
#undef alpha_bottom
#undef alpha_top
#undef alpha_right
#undef alpha_left
#undef Qc_bottom
#undef Qc_top
#undef Qc_right
#undef Qc_left
#undef R0_bottom
#undef R0_top
#undef R0_right
#undef R0_left
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef W
#undef R0
#undef Qc
#undef alpha
#undef m
#undef pTable
#undef reflect
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PSD_post_funnel4' [111]. */
#define mccompcurname  PSD_post_funnel4
#define mccompcurtype  PSD_monitor
#define mccompcurindex 111
#define PSD_N mccPSD_post_funnel4_PSD_N
#define PSD_p mccPSD_post_funnel4_PSD_p
#define PSD_p2 mccPSD_post_funnel4_PSD_p2
#define nx mccPSD_post_funnel4_nx
#define ny mccPSD_post_funnel4_ny
#define filename mccPSD_post_funnel4_filename
#define xmin mccPSD_post_funnel4_xmin
#define xmax mccPSD_post_funnel4_xmax
#define ymin mccPSD_post_funnel4_ymin
#define ymax mccPSD_post_funnel4_ymax
#define xwidth mccPSD_post_funnel4_xwidth
#define yheight mccPSD_post_funnel4_yheight
#define restore_neutron mccPSD_post_funnel4_restore_neutron
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
  DArray2d PSD_N;
  DArray2d PSD_p;
  DArray2d PSD_p2;
#line 21096 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Guide_End_ToF' [112]. */
#define mccompcurname  Guide_End_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 112
#define nt mccGuide_End_ToF_nt
#define TOF_N mccGuide_End_ToF_TOF_N
#define TOF_p mccGuide_End_ToF_TOF_p
#define TOF_p2 mccGuide_End_ToF_TOF_p2
#define t_min mccGuide_End_ToF_t_min
#define t_max mccGuide_End_ToF_t_max
#define delta_t mccGuide_End_ToF_delta_t
#define filename mccGuide_End_ToF_filename
#define xmin mccGuide_End_ToF_xmin
#define xmax mccGuide_End_ToF_xmax
#define ymin mccGuide_End_ToF_ymin
#define ymax mccGuide_End_ToF_ymax
#define xwidth mccGuide_End_ToF_xwidth
#define yheight mccGuide_End_ToF_yheight
#define tmin mccGuide_End_ToF_tmin
#define tmax mccGuide_End_ToF_tmax
#define dt mccGuide_End_ToF_dt
#define restore_neutron mccGuide_End_ToF_restore_neutron
#define nowritefile mccGuide_End_ToF_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 21142 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Guide_End_ToF_Z' [113]. */
#define mccompcurname  Guide_End_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 113
#define nt mccGuide_End_ToF_Z_nt
#define TOF_N mccGuide_End_ToF_Z_TOF_N
#define TOF_p mccGuide_End_ToF_Z_TOF_p
#define TOF_p2 mccGuide_End_ToF_Z_TOF_p2
#define t_min mccGuide_End_ToF_Z_t_min
#define t_max mccGuide_End_ToF_Z_t_max
#define delta_t mccGuide_End_ToF_Z_delta_t
#define filename mccGuide_End_ToF_Z_filename
#define xmin mccGuide_End_ToF_Z_xmin
#define xmax mccGuide_End_ToF_Z_xmax
#define ymin mccGuide_End_ToF_Z_ymin
#define ymax mccGuide_End_ToF_Z_ymax
#define xwidth mccGuide_End_ToF_Z_xwidth
#define yheight mccGuide_End_ToF_Z_yheight
#define tmin mccGuide_End_ToF_Z_tmin
#define tmax mccGuide_End_ToF_Z_tmax
#define dt mccGuide_End_ToF_Z_dt
#define restore_neutron mccGuide_End_ToF_Z_restore_neutron
#define nowritefile mccGuide_End_ToF_Z_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 21194 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Guide_end_Lam' [114]. */
#define mccompcurname  Guide_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 114
#define nL mccGuide_end_Lam_nL
#define L_N mccGuide_end_Lam_L_N
#define L_p mccGuide_end_Lam_L_p
#define L_p2 mccGuide_end_Lam_L_p2
#define filename mccGuide_end_Lam_filename
#define xmin mccGuide_end_Lam_xmin
#define xmax mccGuide_end_Lam_xmax
#define ymin mccGuide_end_Lam_ymin
#define ymax mccGuide_end_Lam_ymax
#define xwidth mccGuide_end_Lam_xwidth
#define yheight mccGuide_end_Lam_yheight
#define Lmin mccGuide_end_Lam_Lmin
#define Lmax mccGuide_end_Lam_Lmax
#define restore_neutron mccGuide_end_Lam_restore_neutron
#define nowritefile mccGuide_end_Lam_nowritefile
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 21240 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Guide_end_divx' [115]. */
#define mccompcurname  Guide_end_divx
#define mccompcurtype  Monitor_nD
#define mccompcurindex 115
#define user1 mccGuide_end_divx_user1
#define user2 mccGuide_end_divx_user2
#define user3 mccGuide_end_divx_user3
#define DEFS mccGuide_end_divx_DEFS
#define Vars mccGuide_end_divx_Vars
#define detector mccGuide_end_divx_detector
#define offdata mccGuide_end_divx_offdata
#define xwidth mccGuide_end_divx_xwidth
#define yheight mccGuide_end_divx_yheight
#define zdepth mccGuide_end_divx_zdepth
#define xmin mccGuide_end_divx_xmin
#define xmax mccGuide_end_divx_xmax
#define ymin mccGuide_end_divx_ymin
#define ymax mccGuide_end_divx_ymax
#define zmin mccGuide_end_divx_zmin
#define zmax mccGuide_end_divx_zmax
#define bins mccGuide_end_divx_bins
#define min mccGuide_end_divx_min
#define max mccGuide_end_divx_max
#define restore_neutron mccGuide_end_divx_restore_neutron
#define radius mccGuide_end_divx_radius
#define options mccGuide_end_divx_options
#define filename mccGuide_end_divx_filename
#define geometry mccGuide_end_divx_geometry
#define username1 mccGuide_end_divx_username1
#define username2 mccGuide_end_divx_username2
#define username3 mccGuide_end_divx_username3
#define nowritefile mccGuide_end_divx_nowritefile
#line 223 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
  MonitornD_Defines_type DEFS;
  MonitornD_Variables_type Vars;
  MCDETECTOR detector;
  off_struct offdata;
#line 21297 "./SNS_BASIS.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Guide_end_divy' [116]. */
#define mccompcurname  Guide_end_divy
#define mccompcurtype  Monitor_nD
#define mccompcurindex 116
#define user1 mccGuide_end_divy_user1
#define user2 mccGuide_end_divy_user2
#define user3 mccGuide_end_divy_user3
#define DEFS mccGuide_end_divy_DEFS
#define Vars mccGuide_end_divy_Vars
#define detector mccGuide_end_divy_detector
#define offdata mccGuide_end_divy_offdata
#define xwidth mccGuide_end_divy_xwidth
#define yheight mccGuide_end_divy_yheight
#define zdepth mccGuide_end_divy_zdepth
#define xmin mccGuide_end_divy_xmin
#define xmax mccGuide_end_divy_xmax
#define ymin mccGuide_end_divy_ymin
#define ymax mccGuide_end_divy_ymax
#define zmin mccGuide_end_divy_zmin
#define zmax mccGuide_end_divy_zmax
#define bins mccGuide_end_divy_bins
#define min mccGuide_end_divy_min
#define max mccGuide_end_divy_max
#define restore_neutron mccGuide_end_divy_restore_neutron
#define radius mccGuide_end_divy_radius
#define options mccGuide_end_divy_options
#define filename mccGuide_end_divy_filename
#define geometry mccGuide_end_divy_geometry
#define username1 mccGuide_end_divy_username1
#define username2 mccGuide_end_divy_username2
#define username3 mccGuide_end_divy_username3
#define nowritefile mccGuide_end_divy_nowritefile
#line 223 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
  MonitornD_Defines_type DEFS;
  MonitornD_Variables_type Vars;
  MCDETECTOR detector;
  off_struct offdata;
#line 21367 "./SNS_BASIS.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Guide_end_PSD' [117]. */
#define mccompcurname  Guide_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 117
#define PSD_N mccGuide_end_PSD_PSD_N
#define PSD_p mccGuide_end_PSD_PSD_p
#define PSD_p2 mccGuide_end_PSD_PSD_p2
#define nx mccGuide_end_PSD_nx
#define ny mccGuide_end_PSD_ny
#define filename mccGuide_end_PSD_filename
#define xmin mccGuide_end_PSD_xmin
#define xmax mccGuide_end_PSD_xmax
#define ymin mccGuide_end_PSD_ymin
#define ymax mccGuide_end_PSD_ymax
#define xwidth mccGuide_end_PSD_xwidth
#define yheight mccGuide_end_PSD_yheight
#define restore_neutron mccGuide_end_PSD_restore_neutron
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
  DArray2d PSD_N;
  DArray2d PSD_p;
  DArray2d PSD_p2;
#line 21421 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Sample_split' [118]. */
#define mccompcurname  Sample_split
#define mccompcurtype  Arm
#define mccompcurindex 118
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'SamplePos' [119]. */
#define mccompcurname  SamplePos
#define mccompcurtype  PSD_monitor
#define mccompcurindex 119
#define PSD_N mccSamplePos_PSD_N
#define PSD_p mccSamplePos_PSD_p
#define PSD_p2 mccSamplePos_PSD_p2
#define nx mccSamplePos_nx
#define ny mccSamplePos_ny
#define filename mccSamplePos_filename
#define xmin mccSamplePos_xmin
#define xmax mccSamplePos_xmax
#define ymin mccSamplePos_ymin
#define ymax mccSamplePos_ymax
#define xwidth mccSamplePos_xwidth
#define yheight mccSamplePos_yheight
#define restore_neutron mccSamplePos_restore_neutron
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
  DArray2d PSD_N;
  DArray2d PSD_p;
  DArray2d PSD_p2;
#line 21468 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Sample' [120]. */
#define mccompcurname  Sample
#define mccompcurtype  Isotropic_Sqw
#define mccompcurindex 120
#define powder_format mccSample_powder_format
#define VarSqw mccSample_VarSqw
#define columns mccSample_columns
#define offdata mccSample_offdata
#define Sqw_coh mccSample_Sqw_coh
#define Sqw_inc mccSample_Sqw_inc
#define geometry mccSample_geometry
#define radius mccSample_radius
#define thickness mccSample_thickness
#define xwidth mccSample_xwidth
#define yheight mccSample_yheight
#define zdepth mccSample_zdepth
#define threshold mccSample_threshold
#define order mccSample_order
#define T mccSample_T
#define verbose mccSample_verbose
#define d_phi mccSample_d_phi
#define concentric mccSample_concentric
#define rho mccSample_rho
#define sigma_abs mccSample_sigma_abs
#define sigma_coh mccSample_sigma_coh
#define sigma_inc mccSample_sigma_inc
#define classical mccSample_classical
#define powder_Dd mccSample_powder_Dd
#define powder_DW mccSample_powder_DW
#define powder_Vc mccSample_powder_Vc
#define density mccSample_density
#define weight mccSample_weight
#define p_interact mccSample_p_interact
#define norm mccSample_norm
#define powder_barns mccSample_powder_barns
#define quantum_correction mccSample_quantum_correction
#line 1999 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../samples/Isotropic_Sqw.comp"
  struct Sqw_sample_struct VarSqw;
  int *columns;
  off_struct offdata;
#line 21526 "./SNS_BASIS.c"
#undef quantum_correction
#undef powder_barns
#undef norm
#undef p_interact
#undef weight
#undef density
#undef powder_Vc
#undef powder_DW
#undef powder_Dd
#undef classical
#undef sigma_inc
#undef sigma_coh
#undef sigma_abs
#undef rho
#undef concentric
#undef d_phi
#undef verbose
#undef T
#undef order
#undef threshold
#undef zdepth
#undef yheight
#undef xwidth
#undef thickness
#undef radius
#undef geometry
#undef Sqw_inc
#undef Sqw_coh
#undef offdata
#undef columns
#undef VarSqw
#undef powder_format
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'An1_rot_axis' [121]. */
#define mccompcurname  An1_rot_axis
#define mccompcurtype  Arm
#define mccompcurindex 121
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'An2_rot_axis' [122]. */
#define mccompcurname  An2_rot_axis
#define mccompcurtype  Arm
#define mccompcurindex 122
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'An3_rot_axis' [123]. */
#define mccompcurname  An3_rot_axis
#define mccompcurtype  Arm
#define mccompcurindex 123
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'An1_ToF' [124]. */
#define mccompcurname  An1_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 124
#define nt mccAn1_ToF_nt
#define TOF_N mccAn1_ToF_TOF_N
#define TOF_p mccAn1_ToF_TOF_p
#define TOF_p2 mccAn1_ToF_TOF_p2
#define t_min mccAn1_ToF_t_min
#define t_max mccAn1_ToF_t_max
#define delta_t mccAn1_ToF_delta_t
#define filename mccAn1_ToF_filename
#define xmin mccAn1_ToF_xmin
#define xmax mccAn1_ToF_xmax
#define ymin mccAn1_ToF_ymin
#define ymax mccAn1_ToF_ymax
#define xwidth mccAn1_ToF_xwidth
#define yheight mccAn1_ToF_yheight
#define tmin mccAn1_ToF_tmin
#define tmax mccAn1_ToF_tmax
#define dt mccAn1_ToF_dt
#define restore_neutron mccAn1_ToF_restore_neutron
#define nowritefile mccAn1_ToF_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 21615 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'An1_ToF_variable_range' [125]. */
#define mccompcurname  An1_ToF_variable_range
#define mccompcurtype  TOF_monitor
#define mccompcurindex 125
#define nt mccAn1_ToF_variable_range_nt
#define TOF_N mccAn1_ToF_variable_range_TOF_N
#define TOF_p mccAn1_ToF_variable_range_TOF_p
#define TOF_p2 mccAn1_ToF_variable_range_TOF_p2
#define t_min mccAn1_ToF_variable_range_t_min
#define t_max mccAn1_ToF_variable_range_t_max
#define delta_t mccAn1_ToF_variable_range_delta_t
#define filename mccAn1_ToF_variable_range_filename
#define xmin mccAn1_ToF_variable_range_xmin
#define xmax mccAn1_ToF_variable_range_xmax
#define ymin mccAn1_ToF_variable_range_ymin
#define ymax mccAn1_ToF_variable_range_ymax
#define xwidth mccAn1_ToF_variable_range_xwidth
#define yheight mccAn1_ToF_variable_range_yheight
#define tmin mccAn1_ToF_variable_range_tmin
#define tmax mccAn1_ToF_variable_range_tmax
#define dt mccAn1_ToF_variable_range_dt
#define restore_neutron mccAn1_ToF_variable_range_restore_neutron
#define nowritefile mccAn1_ToF_variable_range_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 21667 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'An1_Lam' [126]. */
#define mccompcurname  An1_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 126
#define nL mccAn1_Lam_nL
#define L_N mccAn1_Lam_L_N
#define L_p mccAn1_Lam_L_p
#define L_p2 mccAn1_Lam_L_p2
#define filename mccAn1_Lam_filename
#define xmin mccAn1_Lam_xmin
#define xmax mccAn1_Lam_xmax
#define ymin mccAn1_Lam_ymin
#define ymax mccAn1_Lam_ymax
#define xwidth mccAn1_Lam_xwidth
#define yheight mccAn1_Lam_yheight
#define Lmin mccAn1_Lam_Lmin
#define Lmax mccAn1_Lam_Lmax
#define restore_neutron mccAn1_Lam_restore_neutron
#define nowritefile mccAn1_Lam_nowritefile
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 21713 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'An1_Lam_variable_range' [127]. */
#define mccompcurname  An1_Lam_variable_range
#define mccompcurtype  L_monitor
#define mccompcurindex 127
#define nL mccAn1_Lam_variable_range_nL
#define L_N mccAn1_Lam_variable_range_L_N
#define L_p mccAn1_Lam_variable_range_L_p
#define L_p2 mccAn1_Lam_variable_range_L_p2
#define filename mccAn1_Lam_variable_range_filename
#define xmin mccAn1_Lam_variable_range_xmin
#define xmax mccAn1_Lam_variable_range_xmax
#define ymin mccAn1_Lam_variable_range_ymin
#define ymax mccAn1_Lam_variable_range_ymax
#define xwidth mccAn1_Lam_variable_range_xwidth
#define yheight mccAn1_Lam_variable_range_yheight
#define Lmin mccAn1_Lam_variable_range_Lmin
#define Lmax mccAn1_Lam_variable_range_Lmax
#define restore_neutron mccAn1_Lam_variable_range_restore_neutron
#define nowritefile mccAn1_Lam_variable_range_nowritefile
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 21755 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'An1_E' [128]. */
#define mccompcurname  An1_E
#define mccompcurtype  E_monitor
#define mccompcurindex 128
#define nE mccAn1_E_nE
#define E_N mccAn1_E_E_N
#define E_p mccAn1_E_E_p
#define E_p2 mccAn1_E_E_p2
#define S_p mccAn1_E_S_p
#define S_pE mccAn1_E_S_pE
#define S_pE2 mccAn1_E_S_pE2
#define filename mccAn1_E_filename
#define xmin mccAn1_E_xmin
#define xmax mccAn1_E_xmax
#define ymin mccAn1_E_ymin
#define ymax mccAn1_E_ymax
#define xwidth mccAn1_E_xwidth
#define yheight mccAn1_E_yheight
#define Emin mccAn1_E_Emin
#define Emax mccAn1_E_Emax
#define restore_neutron mccAn1_E_restore_neutron
#define nowritefile mccAn1_E_nowritefile
#line 60 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
double E_N[nE];
double E_p[nE], E_p2[nE];
double S_p, S_pE, S_pE2;
#line 21801 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'An1_E_variable_range' [129]. */
#define mccompcurname  An1_E_variable_range
#define mccompcurtype  E_monitor
#define mccompcurindex 129
#define nE mccAn1_E_variable_range_nE
#define E_N mccAn1_E_variable_range_E_N
#define E_p mccAn1_E_variable_range_E_p
#define E_p2 mccAn1_E_variable_range_E_p2
#define S_p mccAn1_E_variable_range_S_p
#define S_pE mccAn1_E_variable_range_S_pE
#define S_pE2 mccAn1_E_variable_range_S_pE2
#define filename mccAn1_E_variable_range_filename
#define xmin mccAn1_E_variable_range_xmin
#define xmax mccAn1_E_variable_range_xmax
#define ymin mccAn1_E_variable_range_ymin
#define ymax mccAn1_E_variable_range_ymax
#define xwidth mccAn1_E_variable_range_xwidth
#define yheight mccAn1_E_variable_range_yheight
#define Emin mccAn1_E_variable_range_Emin
#define Emax mccAn1_E_variable_range_Emax
#define restore_neutron mccAn1_E_variable_range_restore_neutron
#define nowritefile mccAn1_E_variable_range_nowritefile
#line 60 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
double E_N[nE];
double E_p[nE], E_p2[nE];
double S_p, S_pE, S_pE2;
#line 21850 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'An1_rot_axis2' [130]. */
#define mccompcurname  An1_rot_axis2
#define mccompcurtype  Arm
#define mccompcurindex 130
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'An2_rot_axis2' [131]. */
#define mccompcurname  An2_rot_axis2
#define mccompcurtype  Arm
#define mccompcurindex 131
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'An3_rot_axis2' [132]. */
#define mccompcurname  An3_rot_axis2
#define mccompcurtype  Arm
#define mccompcurindex 132
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'An1' [133]. */
#define mccompcurname  An1
#define mccompcurtype  Spherical_Backscattering_Analyser
#define mccompcurindex 133
#define d_rms mccAn1_d_rms
#define mos_rms mccAn1_mos_rms
#define mono_Q mccAn1_mono_Q
#define xmin mccAn1_xmin
#define xmax mccAn1_xmax
#define ymin mccAn1_ymin
#define ymax mccAn1_ymax
#define mosaic mccAn1_mosaic
#define dspread mccAn1_dspread
#define Q mccAn1_Q
#define DM mccAn1_DM
#define radius mccAn1_radius
#define f_doppler mccAn1_f_doppler
#define A_doppler mccAn1_A_doppler
#define R0 mccAn1_R0
#define debug mccAn1_debug
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Spherical_Backscattering_Analyser.comp"
  double d_rms, mos_rms, mono_Q;
#line 21919 "./SNS_BASIS.c"
#undef debug
#undef R0
#undef A_doppler
#undef f_doppler
#undef radius
#undef DM
#undef Q
#undef dspread
#undef mosaic
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mono_Q
#undef mos_rms
#undef d_rms
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'An2' [134]. */
#define mccompcurname  An2
#define mccompcurtype  Spherical_Backscattering_Analyser
#define mccompcurindex 134
#define d_rms mccAn2_d_rms
#define mos_rms mccAn2_mos_rms
#define mono_Q mccAn2_mono_Q
#define xmin mccAn2_xmin
#define xmax mccAn2_xmax
#define ymin mccAn2_ymin
#define ymax mccAn2_ymax
#define mosaic mccAn2_mosaic
#define dspread mccAn2_dspread
#define Q mccAn2_Q
#define DM mccAn2_DM
#define radius mccAn2_radius
#define f_doppler mccAn2_f_doppler
#define A_doppler mccAn2_A_doppler
#define R0 mccAn2_R0
#define debug mccAn2_debug
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Spherical_Backscattering_Analyser.comp"
  double d_rms, mos_rms, mono_Q;
#line 21962 "./SNS_BASIS.c"
#undef debug
#undef R0
#undef A_doppler
#undef f_doppler
#undef radius
#undef DM
#undef Q
#undef dspread
#undef mosaic
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mono_Q
#undef mos_rms
#undef d_rms
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'An3' [135]. */
#define mccompcurname  An3
#define mccompcurtype  Spherical_Backscattering_Analyser
#define mccompcurindex 135
#define d_rms mccAn3_d_rms
#define mos_rms mccAn3_mos_rms
#define mono_Q mccAn3_mono_Q
#define xmin mccAn3_xmin
#define xmax mccAn3_xmax
#define ymin mccAn3_ymin
#define ymax mccAn3_ymax
#define mosaic mccAn3_mosaic
#define dspread mccAn3_dspread
#define Q mccAn3_Q
#define DM mccAn3_DM
#define radius mccAn3_radius
#define f_doppler mccAn3_f_doppler
#define A_doppler mccAn3_A_doppler
#define R0 mccAn3_R0
#define debug mccAn3_debug
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Spherical_Backscattering_Analyser.comp"
  double d_rms, mos_rms, mono_Q;
#line 22005 "./SNS_BASIS.c"
#undef debug
#undef R0
#undef A_doppler
#undef f_doppler
#undef radius
#undef DM
#undef Q
#undef dspread
#undef mosaic
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mono_Q
#undef mos_rms
#undef d_rms
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'ArmForDet1' [136]. */
#define mccompcurname  ArmForDet1
#define mccompcurtype  Arm
#define mccompcurindex 136
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Det1_E' [137]. */
#define mccompcurname  Det1_E
#define mccompcurtype  E_monitor
#define mccompcurindex 137
#define nE mccDet1_E_nE
#define E_N mccDet1_E_E_N
#define E_p mccDet1_E_E_p
#define E_p2 mccDet1_E_E_p2
#define S_p mccDet1_E_S_p
#define S_pE mccDet1_E_S_pE
#define S_pE2 mccDet1_E_S_pE2
#define filename mccDet1_E_filename
#define xmin mccDet1_E_xmin
#define xmax mccDet1_E_xmax
#define ymin mccDet1_E_ymin
#define ymax mccDet1_E_ymax
#define xwidth mccDet1_E_xwidth
#define yheight mccDet1_E_yheight
#define Emin mccDet1_E_Emin
#define Emax mccDet1_E_Emax
#define restore_neutron mccDet1_E_restore_neutron
#define nowritefile mccDet1_E_nowritefile
#line 60 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
double E_N[nE];
double E_p[nE], E_p2[nE];
double S_p, S_pE, S_pE2;
#line 22060 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Det1_E_variable_range' [138]. */
#define mccompcurname  Det1_E_variable_range
#define mccompcurtype  E_monitor
#define mccompcurindex 138
#define nE mccDet1_E_variable_range_nE
#define E_N mccDet1_E_variable_range_E_N
#define E_p mccDet1_E_variable_range_E_p
#define E_p2 mccDet1_E_variable_range_E_p2
#define S_p mccDet1_E_variable_range_S_p
#define S_pE mccDet1_E_variable_range_S_pE
#define S_pE2 mccDet1_E_variable_range_S_pE2
#define filename mccDet1_E_variable_range_filename
#define xmin mccDet1_E_variable_range_xmin
#define xmax mccDet1_E_variable_range_xmax
#define ymin mccDet1_E_variable_range_ymin
#define ymax mccDet1_E_variable_range_ymax
#define xwidth mccDet1_E_variable_range_xwidth
#define yheight mccDet1_E_variable_range_yheight
#define Emin mccDet1_E_variable_range_Emin
#define Emax mccDet1_E_variable_range_Emax
#define restore_neutron mccDet1_E_variable_range_restore_neutron
#define nowritefile mccDet1_E_variable_range_nowritefile
#line 60 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
double E_N[nE];
double E_p[nE], E_p2[nE];
double S_p, S_pE, S_pE2;
#line 22109 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Det1_Lam' [139]. */
#define mccompcurname  Det1_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 139
#define nL mccDet1_Lam_nL
#define L_N mccDet1_Lam_L_N
#define L_p mccDet1_Lam_L_p
#define L_p2 mccDet1_Lam_L_p2
#define filename mccDet1_Lam_filename
#define xmin mccDet1_Lam_xmin
#define xmax mccDet1_Lam_xmax
#define ymin mccDet1_Lam_ymin
#define ymax mccDet1_Lam_ymax
#define xwidth mccDet1_Lam_xwidth
#define yheight mccDet1_Lam_yheight
#define Lmin mccDet1_Lam_Lmin
#define Lmax mccDet1_Lam_Lmax
#define restore_neutron mccDet1_Lam_restore_neutron
#define nowritefile mccDet1_Lam_nowritefile
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 22154 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Det1_Lam_variable_range' [140]. */
#define mccompcurname  Det1_Lam_variable_range
#define mccompcurtype  L_monitor
#define mccompcurindex 140
#define nL mccDet1_Lam_variable_range_nL
#define L_N mccDet1_Lam_variable_range_L_N
#define L_p mccDet1_Lam_variable_range_L_p
#define L_p2 mccDet1_Lam_variable_range_L_p2
#define filename mccDet1_Lam_variable_range_filename
#define xmin mccDet1_Lam_variable_range_xmin
#define xmax mccDet1_Lam_variable_range_xmax
#define ymin mccDet1_Lam_variable_range_ymin
#define ymax mccDet1_Lam_variable_range_ymax
#define xwidth mccDet1_Lam_variable_range_xwidth
#define yheight mccDet1_Lam_variable_range_yheight
#define Lmin mccDet1_Lam_variable_range_Lmin
#define Lmax mccDet1_Lam_variable_range_Lmax
#define restore_neutron mccDet1_Lam_variable_range_restore_neutron
#define nowritefile mccDet1_Lam_variable_range_nowritefile
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
double L_N[nL];
double L_p[nL], L_p2[nL];
#line 22196 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Det1_ToF' [141]. */
#define mccompcurname  Det1_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 141
#define nt mccDet1_ToF_nt
#define TOF_N mccDet1_ToF_TOF_N
#define TOF_p mccDet1_ToF_TOF_p
#define TOF_p2 mccDet1_ToF_TOF_p2
#define t_min mccDet1_ToF_t_min
#define t_max mccDet1_ToF_t_max
#define delta_t mccDet1_ToF_delta_t
#define filename mccDet1_ToF_filename
#define xmin mccDet1_ToF_xmin
#define xmax mccDet1_ToF_xmax
#define ymin mccDet1_ToF_ymin
#define ymax mccDet1_ToF_ymax
#define xwidth mccDet1_ToF_xwidth
#define yheight mccDet1_ToF_yheight
#define tmin mccDet1_ToF_tmin
#define tmax mccDet1_ToF_tmax
#define dt mccDet1_ToF_dt
#define restore_neutron mccDet1_ToF_restore_neutron
#define nowritefile mccDet1_ToF_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 22244 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Det1_ToF_variable_range' [142]. */
#define mccompcurname  Det1_ToF_variable_range
#define mccompcurtype  TOF_monitor
#define mccompcurindex 142
#define nt mccDet1_ToF_variable_range_nt
#define TOF_N mccDet1_ToF_variable_range_TOF_N
#define TOF_p mccDet1_ToF_variable_range_TOF_p
#define TOF_p2 mccDet1_ToF_variable_range_TOF_p2
#define t_min mccDet1_ToF_variable_range_t_min
#define t_max mccDet1_ToF_variable_range_t_max
#define delta_t mccDet1_ToF_variable_range_delta_t
#define filename mccDet1_ToF_variable_range_filename
#define xmin mccDet1_ToF_variable_range_xmin
#define xmax mccDet1_ToF_variable_range_xmax
#define ymin mccDet1_ToF_variable_range_ymin
#define ymax mccDet1_ToF_variable_range_ymax
#define xwidth mccDet1_ToF_variable_range_xwidth
#define yheight mccDet1_ToF_variable_range_yheight
#define tmin mccDet1_ToF_variable_range_tmin
#define tmax mccDet1_ToF_variable_range_tmax
#define dt mccDet1_ToF_variable_range_dt
#define restore_neutron mccDet1_ToF_variable_range_restore_neutron
#define nowritefile mccDet1_ToF_variable_range_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 22296 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Det1_ToF_variable_range_lessnL' [143]. */
#define mccompcurname  Det1_ToF_variable_range_lessnL
#define mccompcurtype  TOF_monitor
#define mccompcurindex 143
#define nt mccDet1_ToF_variable_range_lessnL_nt
#define TOF_N mccDet1_ToF_variable_range_lessnL_TOF_N
#define TOF_p mccDet1_ToF_variable_range_lessnL_TOF_p
#define TOF_p2 mccDet1_ToF_variable_range_lessnL_TOF_p2
#define t_min mccDet1_ToF_variable_range_lessnL_t_min
#define t_max mccDet1_ToF_variable_range_lessnL_t_max
#define delta_t mccDet1_ToF_variable_range_lessnL_delta_t
#define filename mccDet1_ToF_variable_range_lessnL_filename
#define xmin mccDet1_ToF_variable_range_lessnL_xmin
#define xmax mccDet1_ToF_variable_range_lessnL_xmax
#define ymin mccDet1_ToF_variable_range_lessnL_ymin
#define ymax mccDet1_ToF_variable_range_lessnL_ymax
#define xwidth mccDet1_ToF_variable_range_lessnL_xwidth
#define yheight mccDet1_ToF_variable_range_lessnL_yheight
#define tmin mccDet1_ToF_variable_range_lessnL_tmin
#define tmax mccDet1_ToF_variable_range_lessnL_tmax
#define dt mccDet1_ToF_variable_range_lessnL_dt
#define restore_neutron mccDet1_ToF_variable_range_lessnL_restore_neutron
#define nowritefile mccDet1_ToF_variable_range_lessnL_nowritefile
#line 54 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
double TOF_N[nt];
double TOF_p[nt];
double TOF_p2[nt];
double t_min, t_max, delta_t;
#line 22348 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PSDcyl' [144]. */
#define mccompcurname  PSDcyl
#define mccompcurtype  Monitor_nD
#define mccompcurindex 144
#define user1 mccPSDcyl_user1
#define user2 mccPSDcyl_user2
#define user3 mccPSDcyl_user3
#define DEFS mccPSDcyl_DEFS
#define Vars mccPSDcyl_Vars
#define detector mccPSDcyl_detector
#define offdata mccPSDcyl_offdata
#define xwidth mccPSDcyl_xwidth
#define yheight mccPSDcyl_yheight
#define zdepth mccPSDcyl_zdepth
#define xmin mccPSDcyl_xmin
#define xmax mccPSDcyl_xmax
#define ymin mccPSDcyl_ymin
#define ymax mccPSDcyl_ymax
#define zmin mccPSDcyl_zmin
#define zmax mccPSDcyl_zmax
#define bins mccPSDcyl_bins
#define min mccPSDcyl_min
#define max mccPSDcyl_max
#define restore_neutron mccPSDcyl_restore_neutron
#define radius mccPSDcyl_radius
#define options mccPSDcyl_options
#define filename mccPSDcyl_filename
#define geometry mccPSDcyl_geometry
#define username1 mccPSDcyl_username1
#define username2 mccPSDcyl_username2
#define username3 mccPSDcyl_username3
#define nowritefile mccPSDcyl_nowritefile
#line 223 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
  MonitornD_Defines_type DEFS;
  MonitornD_Variables_type Vars;
  MCDETECTOR detector;
  off_struct offdata;
#line 22409 "./SNS_BASIS.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'TOFcyl' [145]. */
#define mccompcurname  TOFcyl
#define mccompcurtype  Monitor_nD
#define mccompcurindex 145
#define user1 mccTOFcyl_user1
#define user2 mccTOFcyl_user2
#define user3 mccTOFcyl_user3
#define DEFS mccTOFcyl_DEFS
#define Vars mccTOFcyl_Vars
#define detector mccTOFcyl_detector
#define offdata mccTOFcyl_offdata
#define xwidth mccTOFcyl_xwidth
#define yheight mccTOFcyl_yheight
#define zdepth mccTOFcyl_zdepth
#define xmin mccTOFcyl_xmin
#define xmax mccTOFcyl_xmax
#define ymin mccTOFcyl_ymin
#define ymax mccTOFcyl_ymax
#define zmin mccTOFcyl_zmin
#define zmax mccTOFcyl_zmax
#define bins mccTOFcyl_bins
#define min mccTOFcyl_min
#define max mccTOFcyl_max
#define restore_neutron mccTOFcyl_restore_neutron
#define radius mccTOFcyl_radius
#define options mccTOFcyl_options
#define filename mccTOFcyl_filename
#define geometry mccTOFcyl_geometry
#define username1 mccTOFcyl_username1
#define username2 mccTOFcyl_username2
#define username3 mccTOFcyl_username3
#define nowritefile mccTOFcyl_nowritefile
#line 223 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
  MonitornD_Defines_type DEFS;
  MonitornD_Variables_type Vars;
  MCDETECTOR detector;
  off_struct offdata;
#line 22479 "./SNS_BASIS.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

Coords mcposaOrigin, mcposrOrigin;
Rotation mcrotaOrigin, mcrotrOrigin;
Coords mcposaSource, mcposrSource;
Rotation mcrotaSource, mcrotrSource;
Coords mcposatofSTART, mcposrtofSTART;
Rotation mcrotatofSTART, mcrotrtofSTART;
Coords mcposaSource_Lam, mcposrSource_Lam;
Rotation mcrotaSource_Lam, mcrotrSource_Lam;
Coords mcposaSource_En, mcposrSource_En;
Rotation mcrotaSource_En, mcrotrSource_En;
Coords mcposaGap0_start, mcposrGap0_start;
Rotation mcrotaGap0_start, mcrotrGap0_start;
Coords mcposaGap0_end_Lam, mcposrGap0_end_Lam;
Rotation mcrotaGap0_end_Lam, mcrotrGap0_end_Lam;
Coords mcposaGap0_end_divx, mcposrGap0_end_divx;
Rotation mcrotaGap0_end_divx, mcrotrGap0_end_divx;
Coords mcposaGap0_end_divy, mcposrGap0_end_divy;
Rotation mcrotaGap0_end_divy, mcrotrGap0_end_divy;
Coords mcposaCore_Vessel_Section, mcposrCore_Vessel_Section;
Rotation mcrotaCore_Vessel_Section, mcrotrCore_Vessel_Section;
Coords mcposaGap1_start, mcposrGap1_start;
Rotation mcrotaGap1_start, mcrotrGap1_start;
Coords mcposaGap1_start_Lam, mcposrGap1_start_Lam;
Rotation mcrotaGap1_start_Lam, mcrotrGap1_start_Lam;
Coords mcposaGap1_end_Lam, mcposrGap1_end_Lam;
Rotation mcrotaGap1_end_Lam, mcrotrGap1_end_Lam;
Coords mcposaGap1_end, mcposrGap1_end;
Rotation mcrotaGap1_end, mcrotrGap1_end;
Coords mcposaShutter_Guide_Insert, mcposrShutter_Guide_Insert;
Rotation mcrotaShutter_Guide_Insert, mcrotrShutter_Guide_Insert;
Coords mcposaShutter_Guide_Insert_16, mcposrShutter_Guide_Insert_16;
Rotation mcrotaShutter_Guide_Insert_16, mcrotrShutter_Guide_Insert_16;
Coords mcposaShutter_Guide_Insert_17, mcposrShutter_Guide_Insert_17;
Rotation mcrotaShutter_Guide_Insert_17, mcrotrShutter_Guide_Insert_17;
Coords mcposaShutter_Guide_Insert_18, mcposrShutter_Guide_Insert_18;
Rotation mcrotaShutter_Guide_Insert_18, mcrotrShutter_Guide_Insert_18;
Coords mcposaShutter_Guide_Insert_19, mcposrShutter_Guide_Insert_19;
Rotation mcrotaShutter_Guide_Insert_19, mcrotrShutter_Guide_Insert_19;
Coords mcposaShutter_Guide_Insert_20, mcposrShutter_Guide_Insert_20;
Rotation mcrotaShutter_Guide_Insert_20, mcrotrShutter_Guide_Insert_20;
Coords mcposaShutter_Guide_Insert_21, mcposrShutter_Guide_Insert_21;
Rotation mcrotaShutter_Guide_Insert_21, mcrotrShutter_Guide_Insert_21;
Coords mcposaShutter_Guide_Insert_short, mcposrShutter_Guide_Insert_short;
Rotation mcrotaShutter_Guide_Insert_short, mcrotrShutter_Guide_Insert_short;
Coords mcposaGap2_start, mcposrGap2_start;
Rotation mcrotaGap2_start, mcrotrGap2_start;
Coords mcposaGap2_start_Lam, mcposrGap2_start_Lam;
Rotation mcrotaGap2_start_Lam, mcrotrGap2_start_Lam;
Coords mcposaGap2_start_PSD, mcposrGap2_start_PSD;
Rotation mcrotaGap2_start_PSD, mcrotrGap2_start_PSD;
Coords mcposaGap2_end_Lam, mcposrGap2_end_Lam;
Rotation mcrotaGap2_end_Lam, mcrotrGap2_end_Lam;
Coords mcposaGap2_end_PSD, mcposrGap2_end_PSD;
Rotation mcrotaGap2_end_PSD, mcrotrGap2_end_PSD;
Coords mcposaGap2_end, mcposrGap2_end;
Rotation mcrotaGap2_end, mcrotrGap2_end;
Coords mcposaCurved_Guide_Section_I, mcposrCurved_Guide_Section_I;
Rotation mcrotaCurved_Guide_Section_I, mcrotrCurved_Guide_Section_I;
Coords mcposaCurved_Guide_Section_I_30, mcposrCurved_Guide_Section_I_30;
Rotation mcrotaCurved_Guide_Section_I_30, mcrotrCurved_Guide_Section_I_30;
Coords mcposaCurved_Guide_Section_I_31, mcposrCurved_Guide_Section_I_31;
Rotation mcrotaCurved_Guide_Section_I_31, mcrotrCurved_Guide_Section_I_31;
Coords mcposaCurved_Guide_Section_I_32, mcposrCurved_Guide_Section_I_32;
Rotation mcrotaCurved_Guide_Section_I_32, mcrotrCurved_Guide_Section_I_32;
Coords mcposaCurved_Guide_Section_I_33, mcposrCurved_Guide_Section_I_33;
Rotation mcrotaCurved_Guide_Section_I_33, mcrotrCurved_Guide_Section_I_33;
Coords mcposaCurved_Guide_Section_I_34, mcposrCurved_Guide_Section_I_34;
Rotation mcrotaCurved_Guide_Section_I_34, mcrotrCurved_Guide_Section_I_34;
Coords mcposaCurved_Guide_Section_I_35, mcposrCurved_Guide_Section_I_35;
Rotation mcrotaCurved_Guide_Section_I_35, mcrotrCurved_Guide_Section_I_35;
Coords mcposaCurved_Guide_Section_I_36, mcposrCurved_Guide_Section_I_36;
Rotation mcrotaCurved_Guide_Section_I_36, mcrotrCurved_Guide_Section_I_36;
Coords mcposaCurved_Guide_Section_I_37, mcposrCurved_Guide_Section_I_37;
Rotation mcrotaCurved_Guide_Section_I_37, mcrotrCurved_Guide_Section_I_37;
Coords mcposaCurved_Guide_Section_I_38, mcposrCurved_Guide_Section_I_38;
Rotation mcrotaCurved_Guide_Section_I_38, mcrotrCurved_Guide_Section_I_38;
Coords mcposaCurved_Guide_Section_I_short, mcposrCurved_Guide_Section_I_short;
Rotation mcrotaCurved_Guide_Section_I_short, mcrotrCurved_Guide_Section_I_short;
Coords mcposaGap3_start, mcposrGap3_start;
Rotation mcrotaGap3_start, mcrotrGap3_start;
Coords mcposaGap3_start_Lam, mcposrGap3_start_Lam;
Rotation mcrotaGap3_start_Lam, mcrotrGap3_start_Lam;
Coords mcposaCGS1_end, mcposrCGS1_end;
Rotation mcrotaCGS1_end, mcrotrCGS1_end;
Coords mcposabefore_Chopper1_ToF, mcposrbefore_Chopper1_ToF;
Rotation mcrotabefore_Chopper1_ToF, mcrotrbefore_Chopper1_ToF;
Coords mcposabefore_Chopper1_ToF_Z, mcposrbefore_Chopper1_ToF_Z;
Rotation mcrotabefore_Chopper1_ToF_Z, mcrotrbefore_Chopper1_ToF_Z;
Coords mcposaChopper1, mcposrChopper1;
Rotation mcrotaChopper1, mcrotrChopper1;
Coords mcposaChopper1_ToF, mcposrChopper1_ToF;
Rotation mcrotaChopper1_ToF, mcrotrChopper1_ToF;
Coords mcposaChopper1_ToF_Z, mcposrChopper1_ToF_Z;
Rotation mcrotaChopper1_ToF_Z, mcrotrChopper1_ToF_Z;
Coords mcposaGap3_end_Lam, mcposrGap3_end_Lam;
Rotation mcrotaGap3_end_Lam, mcrotrGap3_end_Lam;
Coords mcposaGap3_end_PSD, mcposrGap3_end_PSD;
Rotation mcrotaGap3_end_PSD, mcrotrGap3_end_PSD;
Coords mcposaGap3_end, mcposrGap3_end;
Rotation mcrotaGap3_end, mcrotrGap3_end;
Coords mcposaCurved_Guide_Section_II, mcposrCurved_Guide_Section_II;
Rotation mcrotaCurved_Guide_Section_II, mcrotrCurved_Guide_Section_II;
Coords mcposaCurved_Guide_Section_II_52, mcposrCurved_Guide_Section_II_52;
Rotation mcrotaCurved_Guide_Section_II_52, mcrotrCurved_Guide_Section_II_52;
Coords mcposaCurved_Guide_Section_II_53, mcposrCurved_Guide_Section_II_53;
Rotation mcrotaCurved_Guide_Section_II_53, mcrotrCurved_Guide_Section_II_53;
Coords mcposaCurved_Guide_Section_II_54, mcposrCurved_Guide_Section_II_54;
Rotation mcrotaCurved_Guide_Section_II_54, mcrotrCurved_Guide_Section_II_54;
Coords mcposaCurved_Guide_Section_II_55, mcposrCurved_Guide_Section_II_55;
Rotation mcrotaCurved_Guide_Section_II_55, mcrotrCurved_Guide_Section_II_55;
Coords mcposaCurved_Guide_Section_II_56, mcposrCurved_Guide_Section_II_56;
Rotation mcrotaCurved_Guide_Section_II_56, mcrotrCurved_Guide_Section_II_56;
Coords mcposaCurved_Guide_Section_II_57, mcposrCurved_Guide_Section_II_57;
Rotation mcrotaCurved_Guide_Section_II_57, mcrotrCurved_Guide_Section_II_57;
Coords mcposaCurved_Guide_Section_II_last, mcposrCurved_Guide_Section_II_last;
Rotation mcrotaCurved_Guide_Section_II_last, mcrotrCurved_Guide_Section_II_last;
Coords mcposaGap4_start, mcposrGap4_start;
Rotation mcrotaGap4_start, mcrotrGap4_start;
Coords mcposaGap4_start_Lam, mcposrGap4_start_Lam;
Rotation mcrotaGap4_start_Lam, mcrotrGap4_start_Lam;
Coords mcposaGap4_start_PSD, mcposrGap4_start_PSD;
Rotation mcrotaGap4_start_PSD, mcrotrGap4_start_PSD;
Coords mcposabefore_Chopper2_ToF, mcposrbefore_Chopper2_ToF;
Rotation mcrotabefore_Chopper2_ToF, mcrotrbefore_Chopper2_ToF;
Coords mcposabefore_Chopper2_ToF_Z, mcposrbefore_Chopper2_ToF_Z;
Rotation mcrotabefore_Chopper2_ToF_Z, mcrotrbefore_Chopper2_ToF_Z;
Coords mcposaChopper2, mcposrChopper2;
Rotation mcrotaChopper2, mcrotrChopper2;
Coords mcposaChopper2_ToF, mcposrChopper2_ToF;
Rotation mcrotaChopper2_ToF, mcrotrChopper2_ToF;
Coords mcposaChopper2_ToF_Z, mcposrChopper2_ToF_Z;
Rotation mcrotaChopper2_ToF_Z, mcrotrChopper2_ToF_Z;
Coords mcposaGap4_end_Lam, mcposrGap4_end_Lam;
Rotation mcrotaGap4_end_Lam, mcrotrGap4_end_Lam;
Coords mcposaGap4_end_PSD, mcposrGap4_end_PSD;
Rotation mcrotaGap4_end_PSD, mcrotrGap4_end_PSD;
Coords mcposaGap4_end, mcposrGap4_end;
Rotation mcrotaGap4_end, mcrotrGap4_end;
Coords mcposaCurved_Guide_Section_III, mcposrCurved_Guide_Section_III;
Rotation mcrotaCurved_Guide_Section_III, mcrotrCurved_Guide_Section_III;
Coords mcposaCurved_Guide_Section_III_71, mcposrCurved_Guide_Section_III_71;
Rotation mcrotaCurved_Guide_Section_III_71, mcrotrCurved_Guide_Section_III_71;
Coords mcposaCurved_Guide_Section_III_72, mcposrCurved_Guide_Section_III_72;
Rotation mcrotaCurved_Guide_Section_III_72, mcrotrCurved_Guide_Section_III_72;
Coords mcposaCurved_Guide_Section_III_73, mcposrCurved_Guide_Section_III_73;
Rotation mcrotaCurved_Guide_Section_III_73, mcrotrCurved_Guide_Section_III_73;
Coords mcposaCurved_Guide_Section_III_74, mcposrCurved_Guide_Section_III_74;
Rotation mcrotaCurved_Guide_Section_III_74, mcrotrCurved_Guide_Section_III_74;
Coords mcposaCurved_Guide_Section_III_75, mcposrCurved_Guide_Section_III_75;
Rotation mcrotaCurved_Guide_Section_III_75, mcrotrCurved_Guide_Section_III_75;
Coords mcposaCurved_Guide_Section_III_76, mcposrCurved_Guide_Section_III_76;
Rotation mcrotaCurved_Guide_Section_III_76, mcrotrCurved_Guide_Section_III_76;
Coords mcposaCurved_Guide_Section_III_77, mcposrCurved_Guide_Section_III_77;
Rotation mcrotaCurved_Guide_Section_III_77, mcrotrCurved_Guide_Section_III_77;
Coords mcposaCurved_Guide_Section_III_78, mcposrCurved_Guide_Section_III_78;
Rotation mcrotaCurved_Guide_Section_III_78, mcrotrCurved_Guide_Section_III_78;
Coords mcposaCurved_Guide_Section_III_79, mcposrCurved_Guide_Section_III_79;
Rotation mcrotaCurved_Guide_Section_III_79, mcrotrCurved_Guide_Section_III_79;
Coords mcposaCurved_Guide_Section_III_short, mcposrCurved_Guide_Section_III_short;
Rotation mcrotaCurved_Guide_Section_III_short, mcrotrCurved_Guide_Section_III_short;
Coords mcposaCGS3_end_ToF, mcposrCGS3_end_ToF;
Rotation mcrotaCGS3_end_ToF, mcrotrCGS3_end_ToF;
Coords mcposaCGS3_end_ToF_Z, mcposrCGS3_end_ToF_Z;
Rotation mcrotaCGS3_end_ToF_Z, mcrotrCGS3_end_ToF_Z;
Coords mcposaCGS3_end_Lam, mcposrCGS3_end_Lam;
Rotation mcrotaCGS3_end_Lam, mcrotrCGS3_end_Lam;
Coords mcposaStraight_Guide_Section_I, mcposrStraight_Guide_Section_I;
Rotation mcrotaStraight_Guide_Section_I, mcrotrStraight_Guide_Section_I;
Coords mcposaGap5_start, mcposrGap5_start;
Rotation mcrotaGap5_start, mcrotrGap5_start;
Coords mcposaGap5_start_ToF, mcposrGap5_start_ToF;
Rotation mcrotaGap5_start_ToF, mcrotrGap5_start_ToF;
Coords mcposaGap5_start_ToF_Z, mcposrGap5_start_ToF_Z;
Rotation mcrotaGap5_start_ToF_Z, mcrotrGap5_start_ToF_Z;
Coords mcposaGap5_start_Lam, mcposrGap5_start_Lam;
Rotation mcrotaGap5_start_Lam, mcrotrGap5_start_Lam;
Coords mcposaGap5_start_PSD, mcposrGap5_start_PSD;
Rotation mcrotaGap5_start_PSD, mcrotrGap5_start_PSD;
Coords mcposaChopper3, mcposrChopper3;
Rotation mcrotaChopper3, mcrotrChopper3;
Coords mcposaChopper3_ToF, mcposrChopper3_ToF;
Rotation mcrotaChopper3_ToF, mcrotrChopper3_ToF;
Coords mcposaChopper3_ToF_Z, mcposrChopper3_ToF_Z;
Rotation mcrotaChopper3_ToF_Z, mcrotrChopper3_ToF_Z;
Coords mcposaGap5_end_Lam, mcposrGap5_end_Lam;
Rotation mcrotaGap5_end_Lam, mcrotrGap5_end_Lam;
Coords mcposaGap5_end_PSD, mcposrGap5_end_PSD;
Rotation mcrotaGap5_end_PSD, mcrotrGap5_end_PSD;
Coords mcposaGap5_end, mcposrGap5_end;
Rotation mcrotaGap5_end, mcrotrGap5_end;
Coords mcposaStraight_Guide_Section_II, mcposrStraight_Guide_Section_II;
Rotation mcrotaStraight_Guide_Section_II, mcrotrStraight_Guide_Section_II;
Coords mcposaSGS2_end_Lam, mcposrSGS2_end_Lam;
Rotation mcrotaSGS2_end_Lam, mcrotrSGS2_end_Lam;
Coords mcposaSGS2_end_PSD, mcposrSGS2_end_PSD;
Rotation mcrotaSGS2_end_PSD, mcrotrSGS2_end_PSD;
Coords mcposaStraight_Guide_Section_III, mcposrStraight_Guide_Section_III;
Rotation mcrotaStraight_Guide_Section_III, mcrotrStraight_Guide_Section_III;
Coords mcposaSG3_end_ToF, mcposrSG3_end_ToF;
Rotation mcrotaSG3_end_ToF, mcrotrSG3_end_ToF;
Coords mcposaSG3_end_ToF_Z, mcposrSG3_end_ToF_Z;
Rotation mcrotaSG3_end_ToF_Z, mcrotrSG3_end_ToF_Z;
Coords mcposaSG3_end_Lam, mcposrSG3_end_Lam;
Rotation mcrotaSG3_end_Lam, mcrotrSG3_end_Lam;
Coords mcposaSG3_end_PSD, mcposrSG3_end_PSD;
Rotation mcrotaSG3_end_PSD, mcrotrSG3_end_PSD;
Coords mcposaFunnel_1, mcposrFunnel_1;
Rotation mcrotaFunnel_1, mcrotrFunnel_1;
Coords mcposaPSD_post_funnel1, mcposrPSD_post_funnel1;
Rotation mcrotaPSD_post_funnel1, mcrotrPSD_post_funnel1;
Coords mcposaFunnel_2, mcposrFunnel_2;
Rotation mcrotaFunnel_2, mcrotrFunnel_2;
Coords mcposaPSD_post_funnel2, mcposrPSD_post_funnel2;
Rotation mcrotaPSD_post_funnel2, mcrotrPSD_post_funnel2;
Coords mcposaFunnel_3, mcposrFunnel_3;
Rotation mcrotaFunnel_3, mcrotrFunnel_3;
Coords mcposaPSD_post_funnel3, mcposrPSD_post_funnel3;
Rotation mcrotaPSD_post_funnel3, mcrotrPSD_post_funnel3;
Coords mcposaFunnel_4, mcposrFunnel_4;
Rotation mcrotaFunnel_4, mcrotrFunnel_4;
Coords mcposaPSD_post_funnel4, mcposrPSD_post_funnel4;
Rotation mcrotaPSD_post_funnel4, mcrotrPSD_post_funnel4;
Coords mcposaGuide_End_ToF, mcposrGuide_End_ToF;
Rotation mcrotaGuide_End_ToF, mcrotrGuide_End_ToF;
Coords mcposaGuide_End_ToF_Z, mcposrGuide_End_ToF_Z;
Rotation mcrotaGuide_End_ToF_Z, mcrotrGuide_End_ToF_Z;
Coords mcposaGuide_end_Lam, mcposrGuide_end_Lam;
Rotation mcrotaGuide_end_Lam, mcrotrGuide_end_Lam;
Coords mcposaGuide_end_divx, mcposrGuide_end_divx;
Rotation mcrotaGuide_end_divx, mcrotrGuide_end_divx;
Coords mcposaGuide_end_divy, mcposrGuide_end_divy;
Rotation mcrotaGuide_end_divy, mcrotrGuide_end_divy;
Coords mcposaGuide_end_PSD, mcposrGuide_end_PSD;
Rotation mcrotaGuide_end_PSD, mcrotrGuide_end_PSD;
Coords mcposaSample_split, mcposrSample_split;
Rotation mcrotaSample_split, mcrotrSample_split;
Coords mcposaSamplePos, mcposrSamplePos;
Rotation mcrotaSamplePos, mcrotrSamplePos;
Coords mcposaSample, mcposrSample;
Rotation mcrotaSample, mcrotrSample;
Coords mcposaAn1_rot_axis, mcposrAn1_rot_axis;
Rotation mcrotaAn1_rot_axis, mcrotrAn1_rot_axis;
Coords mcposaAn2_rot_axis, mcposrAn2_rot_axis;
Rotation mcrotaAn2_rot_axis, mcrotrAn2_rot_axis;
Coords mcposaAn3_rot_axis, mcposrAn3_rot_axis;
Rotation mcrotaAn3_rot_axis, mcrotrAn3_rot_axis;
Coords mcposaAn1_ToF, mcposrAn1_ToF;
Rotation mcrotaAn1_ToF, mcrotrAn1_ToF;
Coords mcposaAn1_ToF_variable_range, mcposrAn1_ToF_variable_range;
Rotation mcrotaAn1_ToF_variable_range, mcrotrAn1_ToF_variable_range;
Coords mcposaAn1_Lam, mcposrAn1_Lam;
Rotation mcrotaAn1_Lam, mcrotrAn1_Lam;
Coords mcposaAn1_Lam_variable_range, mcposrAn1_Lam_variable_range;
Rotation mcrotaAn1_Lam_variable_range, mcrotrAn1_Lam_variable_range;
Coords mcposaAn1_E, mcposrAn1_E;
Rotation mcrotaAn1_E, mcrotrAn1_E;
Coords mcposaAn1_E_variable_range, mcposrAn1_E_variable_range;
Rotation mcrotaAn1_E_variable_range, mcrotrAn1_E_variable_range;
Coords mcposaAn1_rot_axis2, mcposrAn1_rot_axis2;
Rotation mcrotaAn1_rot_axis2, mcrotrAn1_rot_axis2;
Coords mcposaAn2_rot_axis2, mcposrAn2_rot_axis2;
Rotation mcrotaAn2_rot_axis2, mcrotrAn2_rot_axis2;
Coords mcposaAn3_rot_axis2, mcposrAn3_rot_axis2;
Rotation mcrotaAn3_rot_axis2, mcrotrAn3_rot_axis2;
Coords mcposaAn1, mcposrAn1;
Rotation mcrotaAn1, mcrotrAn1;
Coords mcposaAn2, mcposrAn2;
Rotation mcrotaAn2, mcrotrAn2;
Coords mcposaAn3, mcposrAn3;
Rotation mcrotaAn3, mcrotrAn3;
Coords mcposaArmForDet1, mcposrArmForDet1;
Rotation mcrotaArmForDet1, mcrotrArmForDet1;
Coords mcposaDet1_E, mcposrDet1_E;
Rotation mcrotaDet1_E, mcrotrDet1_E;
Coords mcposaDet1_E_variable_range, mcposrDet1_E_variable_range;
Rotation mcrotaDet1_E_variable_range, mcrotrDet1_E_variable_range;
Coords mcposaDet1_Lam, mcposrDet1_Lam;
Rotation mcrotaDet1_Lam, mcrotrDet1_Lam;
Coords mcposaDet1_Lam_variable_range, mcposrDet1_Lam_variable_range;
Rotation mcrotaDet1_Lam_variable_range, mcrotrDet1_Lam_variable_range;
Coords mcposaDet1_ToF, mcposrDet1_ToF;
Rotation mcrotaDet1_ToF, mcrotrDet1_ToF;
Coords mcposaDet1_ToF_variable_range, mcposrDet1_ToF_variable_range;
Rotation mcrotaDet1_ToF_variable_range, mcrotrDet1_ToF_variable_range;
Coords mcposaDet1_ToF_variable_range_lessnL, mcposrDet1_ToF_variable_range_lessnL;
Rotation mcrotaDet1_ToF_variable_range_lessnL, mcrotrDet1_ToF_variable_range_lessnL;
Coords mcposaPSDcyl, mcposrPSDcyl;
Rotation mcrotaPSDcyl, mcrotrPSDcyl;
Coords mcposaTOFcyl, mcposrTOFcyl;
Rotation mcrotaTOFcyl, mcrotrTOFcyl;

MCNUM mcnx, mcny, mcnz, mcnvx, mcnvy, mcnvz, mcnt, mcnsx, mcnsy, mcnsz, mcnp;

/* end declare */

void mcinit(void) {
#define mccompcurname  SNS_BASIS
#define mccompcurtype  INSTRUMENT
#define mccompcurindex 0
#define mcposaSNS_BASIS coords_set(0,0,0)
#define Lam mcipLam
#define Lambda_min mcipLambda_min
#define Lambda_max mcipLambda_max
#define RadCurv mcipRadCurv
#define omega1 mcipomega1
#define omega2 mcipomega2
#define omega3 mcipomega3
#define ch1_open mcipch1_open
#define ch2_open mcipch2_open
#define ch3_open mcipch3_open
#define ROT1 mcipROT1
#define AN_ROT mcipAN_ROT
#define TOTAL_LENGTH mcipTOTAL_LENGTH
#define dROT mcipdROT
#line 154 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
{
 // Omega1=2*PI*omega1/60;
 // Omega2=2*PI*omega2/60;
 // Omega3=2*PI*omega3/60;
 Omega1=omega1;
 Omega2=omega2;
 Omega3=omega3;
  
  Guide_extension = TOTAL_LENGTH - 84.0 ;
  SGS3 = 75.7305 + Guide_extension;
  End_Guide = SGS3 + 8.0003;
  Analyser = End_Guide + 2.7798;
  Detector1 = Analyser - 2.2202;
  sprintf(myfilename_1, "TOF_monitor_%g_just_before_Funnel", SGS3);
  sprintf(myfilename_2, "Lam_monitor_%g_just_before_Funnel", SGS3);
  sprintf(myfilename_3, "PSD_monitor_%g_just_before_Funnel", SGS3);
  sprintf(myfilename_4, "TOF_monitor_%g_atEndof_Guide", End_Guide);
  sprintf(myfilename_5, "Lam_monitor_%g_atEndof_Guide", End_Guide);
  sprintf(myfilename_6, "PSD_monitor_%g_atEndof_Guide", End_Guide);
  sprintf(myfilename_7, "TOF_monitor_%g_just_before_analyzer", Analyser);
  sprintf(myfilename_8, "TOF_monitor_%g_just_before_analyzer_zoom", Analyser);   
  sprintf(myfilename_9, "Lam_monitor_%g_just_before_analyzer", Analyser);
  sprintf(myfilename_10, "Lam_monitor_%g_just_before_analyzer_zoom", Analyser);
  sprintf(myfilename_11, "Energy_monitor_%g_just_before_analyzer", Analyser);
  sprintf(myfilename_12, "Energy_monitor_%g_just_before_analyzer_zoom", Analyser);
  sprintf(myfilename_13, "E_monitor_Det1_%g_close_to_sample", Detector1);
  sprintf(myfilename_14, "E_monitor_Det1_%g_close_to_sample_zoom", Detector1);
  sprintf(myfilename_15, "Lam_monitor_%g_close_to_sample", Detector1);
  sprintf(myfilename_16, "Lam_monitor_%g_close_to_sample_zoom", Detector1);
  sprintf(myfilename_17, "TOF_monitor_%g_close_to_sample", Detector1);
  sprintf(myfilename_18, "TOF_monitor_%g_close_to_sample_zoom", Detector1);
  sprintf(myfilename_19, "TOF_monitor_%g_close_to_sample_zoom_less_chan", Detector1);

  E_min=81.82/(Lambda_max*Lambda_max);
  E_max=81.82/(Lambda_min*Lambda_min);

  printf("Energies as calculated by the instrument: %g - %g\n",E_min,E_max);

}
#line 22866 "./SNS_BASIS.c"
#undef dROT
#undef TOTAL_LENGTH
#undef AN_ROT
#undef ROT1
#undef ch3_open
#undef ch2_open
#undef ch1_open
#undef omega3
#undef omega2
#undef omega1
#undef RadCurv
#undef Lambda_max
#undef Lambda_min
#undef Lam
#undef mcposaSNS_BASIS
#undef mccompcurindex
#undef mccompcurtype
#undef mccompcurname
  /* Computation of coordinate transformations. */
  {
    Coords mctc1, mctc2, mcLastComp;
    Rotation mctr1;
    double mcAccumulatedILength = 0;
    /* Initialize "last" component origin as (0,0,0) */
    mcLastComp = coords_set(0,0,0);

    mcDEBUG_INSTR()
  /* Component initializations. */
    /* Component Origin. */
  /* Setting parameters for component Origin. */
  SIG_MESSAGE("Origin (Init:SetPar)");
#line 39 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccOrigin_profile, "NULL" ? "NULL" : "", 16384); else mccOrigin_profile[0]='\0';
#line 39 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccOrigin_percent = 10;
#line 39 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccOrigin_flag_save = 0;
#line 39 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccOrigin_minutes = 0;
#line 22906 "./SNS_BASIS.c"

  SIG_MESSAGE("Origin (Init:Place/Rotate)");
  rot_set_rotation(mcrotaOrigin,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 22913 "./SNS_BASIS.c"
  rot_copy(mcrotrOrigin, mcrotaOrigin);
  mcposaOrigin = coords_set(
#line 206 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 206 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 206 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0);
#line 22922 "./SNS_BASIS.c"
  mctc1 = coords_neg(mcposaOrigin);
  mcposrOrigin = rot_apply(mcrotaOrigin, mctc1);
  mcDEBUG_COMPONENT("Origin", mcposaOrigin, mcrotaOrigin)
  mccomp_posa[1] = mcposaOrigin;
  mccomp_posr[1] = mcposrOrigin;
  mcNCounter[1]  = mcPCounter[1] = mcP2Counter[1] = 0;
  mcAbsorbProp[1]= 0;
    /* Component Source. */
  /* Setting parameters for component Source. */
  SIG_MESSAGE("Source (Init:SetPar)");
#line 212 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_size = 0.11;
#line 213 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_Lmin = mcipLambda_min;
#line 213 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_Lmax = mcipLambda_max;
#line 213 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_dist = 1.204;
#line 213 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_focus_xw = 0.1;
#line 213 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_focus_yh = 0.12;
#line 213 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_nu = 60;
#line 213 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_T = 50;
#line 213 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_tau = 49e-6;
#line 213 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_tau1 = 0;
#line 213 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_tau2 = 7e-6;
#line 213 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_n = 5;
#line 213 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_n2 = 5;
#line 213 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_chi2 = 0.9;
#line 213 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_I0 = 5.4e10;
#line 213 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_I2 = 9.2e10;
#line 213 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_branch1 = 0;
#line 213 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_branch2 = 0.5;
#line 213 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_branchframe = 1;
#line 95 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_target_index = + 1;
#line 22973 "./SNS_BASIS.c"

  SIG_MESSAGE("Source (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 22980 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaOrigin, mcrotaSource);
  rot_transpose(mcrotaOrigin, mctr1);
  rot_mul(mcrotaSource, mctr1, mcrotrSource);
  mctc1 = coords_set(
#line 214 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 214 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 214 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0);
#line 22991 "./SNS_BASIS.c"
  rot_transpose(mcrotaOrigin, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaSource = coords_add(mcposaOrigin, mctc2);
  mctc1 = coords_sub(mcposaOrigin, mcposaSource);
  mcposrSource = rot_apply(mcrotaSource, mctc1);
  mcDEBUG_COMPONENT("Source", mcposaSource, mcrotaSource)
  mccomp_posa[2] = mcposaSource;
  mccomp_posr[2] = mcposrSource;
  mcNCounter[2]  = mcPCounter[2] = mcP2Counter[2] = 0;
  mcAbsorbProp[2]= 0;
    /* Component tofSTART. */
  /* Setting parameters for component tofSTART. */
  SIG_MESSAGE("tofSTART (Init:SetPar)");
#line 224 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("TOF_monitor_0,000m_from_Source") strncpy(mcctofSTART_filename, "TOF_monitor_0,000m_from_Source" ? "TOF_monitor_0,000m_from_Source" : "", 16384); else mcctofSTART_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mcctofSTART_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mcctofSTART_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mcctofSTART_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mcctofSTART_ymax = 0.05;
#line 224 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mcctofSTART_xwidth = 0.2;
#line 224 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mcctofSTART_yheight = 0.2;
#line 224 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mcctofSTART_tmin = 100;
#line 224 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mcctofSTART_tmax = 700;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mcctofSTART_dt = 1.0;
#line 224 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mcctofSTART_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mcctofSTART_nowritefile = 0;
#line 23029 "./SNS_BASIS.c"

  SIG_MESSAGE("tofSTART (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23036 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaSource, mcrotatofSTART);
  rot_transpose(mcrotaSource, mctr1);
  rot_mul(mcrotatofSTART, mctr1, mcrotrtofSTART);
  mctc1 = coords_set(
#line 225 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 225 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 225 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.11);
#line 23047 "./SNS_BASIS.c"
  rot_transpose(mcrotaSource, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposatofSTART = coords_add(mcposaSource, mctc2);
  mctc1 = coords_sub(mcposaSource, mcposatofSTART);
  mcposrtofSTART = rot_apply(mcrotatofSTART, mctc1);
  mcDEBUG_COMPONENT("tofSTART", mcposatofSTART, mcrotatofSTART)
  mccomp_posa[3] = mcposatofSTART;
  mccomp_posr[3] = mcposrtofSTART;
  mcNCounter[3]  = mcPCounter[3] = mcP2Counter[3] = 0;
  mcAbsorbProp[3]= 0;
    /* Component Source_Lam. */
  /* Setting parameters for component Source_Lam. */
  SIG_MESSAGE("Source_Lam (Init:SetPar)");
#line 229 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("Lam_monitor_0,0001m_after_Source") strncpy(mccSource_Lam_filename, "Lam_monitor_0,0001m_after_Source" ? "Lam_monitor_0,0001m_after_Source" : "", 16384); else mccSource_Lam_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_Lam_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_Lam_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_Lam_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_Lam_ymax = 0.05;
#line 229 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_Lam_xwidth = 0.4;
#line 230 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_Lam_yheight = 0.4;
#line 230 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_Lam_Lmin = 0.5;
#line 230 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_Lam_Lmax = 30;
#line 229 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_Lam_restore_neutron = 1;
#line 51 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_Lam_nowritefile = 0;
#line 23083 "./SNS_BASIS.c"

  SIG_MESSAGE("Source_Lam (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23090 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaSource, mcrotaSource_Lam);
  rot_transpose(mcrotatofSTART, mctr1);
  rot_mul(mcrotaSource_Lam, mctr1, mcrotrSource_Lam);
  mctc1 = coords_set(
#line 231 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 231 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 231 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.11 + 1e-4);
#line 23101 "./SNS_BASIS.c"
  rot_transpose(mcrotaSource, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaSource_Lam = coords_add(mcposaSource, mctc2);
  mctc1 = coords_sub(mcposatofSTART, mcposaSource_Lam);
  mcposrSource_Lam = rot_apply(mcrotaSource_Lam, mctc1);
  mcDEBUG_COMPONENT("Source_Lam", mcposaSource_Lam, mcrotaSource_Lam)
  mccomp_posa[4] = mcposaSource_Lam;
  mccomp_posr[4] = mcposrSource_Lam;
  mcNCounter[4]  = mcPCounter[4] = mcP2Counter[4] = 0;
  mcAbsorbProp[4]= 0;
    /* Component Source_En. */
  /* Setting parameters for component Source_En. */
  SIG_MESSAGE("Source_En (Init:SetPar)");
#line 234 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("E_monitor_0,0001m_after_Source") strncpy(mccSource_En_filename, "E_monitor_0,0001m_after_Source" ? "E_monitor_0,0001m_after_Source" : "", 16384); else mccSource_En_filename[0]='\0';
#line 53 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_En_xmin = -0.05;
#line 53 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_En_xmax = 0.05;
#line 53 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_En_ymin = -0.05;
#line 53 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_En_ymax = 0.05;
#line 234 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_En_xwidth = 0.4;
#line 235 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_En_yheight = 0.4;
#line 235 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_En_Emin = E_min * 0.5;
#line 235 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_En_Emax = E_max * 2;
#line 234 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_En_restore_neutron = 1;
#line 54 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSource_En_nowritefile = 0;
#line 23137 "./SNS_BASIS.c"

  SIG_MESSAGE("Source_En (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23144 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaSource, mcrotaSource_En);
  rot_transpose(mcrotaSource_Lam, mctr1);
  rot_mul(mcrotaSource_En, mctr1, mcrotrSource_En);
  mctc1 = coords_set(
#line 236 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 236 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 236 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.11 + 2e-4);
#line 23155 "./SNS_BASIS.c"
  rot_transpose(mcrotaSource, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaSource_En = coords_add(mcposaSource, mctc2);
  mctc1 = coords_sub(mcposaSource_Lam, mcposaSource_En);
  mcposrSource_En = rot_apply(mcrotaSource_En, mctc1);
  mcDEBUG_COMPONENT("Source_En", mcposaSource_En, mcrotaSource_En)
  mccomp_posa[5] = mcposaSource_En;
  mccomp_posr[5] = mcposrSource_En;
  mcNCounter[5]  = mcPCounter[5] = mcP2Counter[5] = 0;
  mcAbsorbProp[5]= 0;
    /* Component Gap0_start. */
  /* Setting parameters for component Gap0_start. */
  SIG_MESSAGE("Gap0_start (Init:SetPar)");
#line 239 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_start_nx = 100;
#line 239 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_start_ny = 100;
#line 239 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("PSD_monitor_0,0003m_after_Source") strncpy(mccGap0_start_filename, "PSD_monitor_0,0003m_after_Source" ? "PSD_monitor_0,0003m_after_Source" : "", 16384); else mccGap0_start_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_start_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_start_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_start_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_start_ymax = 0.05;
#line 240 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_start_xwidth = 0.4;
#line 240 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_start_yheight = 0.4;
#line 240 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_start_restore_neutron = 1;
#line 23189 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap0_start (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23196 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaSource, mcrotaGap0_start);
  rot_transpose(mcrotaSource_En, mctr1);
  rot_mul(mcrotaGap0_start, mctr1, mcrotrGap0_start);
  mctc1 = coords_set(
#line 241 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 241 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 241 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.11 + 3e-4);
#line 23207 "./SNS_BASIS.c"
  rot_transpose(mcrotaSource, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap0_start = coords_add(mcposaSource, mctc2);
  mctc1 = coords_sub(mcposaSource_En, mcposaGap0_start);
  mcposrGap0_start = rot_apply(mcrotaGap0_start, mctc1);
  mcDEBUG_COMPONENT("Gap0_start", mcposaGap0_start, mcrotaGap0_start)
  mccomp_posa[6] = mcposaGap0_start;
  mccomp_posr[6] = mcposrGap0_start;
  mcNCounter[6]  = mcPCounter[6] = mcP2Counter[6] = 0;
  mcAbsorbProp[6]= 0;
    /* Component Gap0_end_Lam. */
  /* Setting parameters for component Gap0_end_Lam. */
  SIG_MESSAGE("Gap0_end_Lam (Init:SetPar)");
#line 244 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("Lam_monitor_1.2031m_after_Source") strncpy(mccGap0_end_Lam_filename, "Lam_monitor_1.2031m_after_Source" ? "Lam_monitor_1.2031m_after_Source" : "", 16384); else mccGap0_end_Lam_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_Lam_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_Lam_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_Lam_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_Lam_ymax = 0.05;
#line 244 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_Lam_xwidth = 0.4;
#line 245 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_Lam_yheight = 0.4;
#line 245 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_Lam_Lmin = mcipLambda_min;
#line 245 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_Lam_Lmax = mcipLambda_max;
#line 244 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_Lam_restore_neutron = 1;
#line 51 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_Lam_nowritefile = 0;
#line 23243 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap0_end_Lam (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23250 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaSource, mcrotaGap0_end_Lam);
  rot_transpose(mcrotaGap0_start, mctr1);
  rot_mul(mcrotaGap0_end_Lam, mctr1, mcrotrGap0_end_Lam);
  mctc1 = coords_set(
#line 246 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 246 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 246 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.11 + 1.203 + 1e-4);
#line 23261 "./SNS_BASIS.c"
  rot_transpose(mcrotaSource, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap0_end_Lam = coords_add(mcposaSource, mctc2);
  mctc1 = coords_sub(mcposaGap0_start, mcposaGap0_end_Lam);
  mcposrGap0_end_Lam = rot_apply(mcrotaGap0_end_Lam, mctc1);
  mcDEBUG_COMPONENT("Gap0_end_Lam", mcposaGap0_end_Lam, mcrotaGap0_end_Lam)
  mccomp_posa[7] = mcposaGap0_end_Lam;
  mccomp_posr[7] = mcposrGap0_end_Lam;
  mcNCounter[7]  = mcPCounter[7] = mcP2Counter[7] = 0;
  mcAbsorbProp[7]= 0;
    /* Component Gap0_end_divx. */
  /* Setting parameters for component Gap0_end_divx. */
  SIG_MESSAGE("Gap0_end_divx (Init:SetPar)");
#line 248 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divx_xwidth = 0.10;
#line 248 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divx_yheight = 0.12;
#line 203 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divx_zdepth = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divx_xmin = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divx_xmax = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divx_ymin = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divx_ymax = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divx_zmin = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divx_zmax = 0;
#line 205 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divx_bins = 0;
#line 205 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divx_min = -1e40;
#line 205 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divx_max = 1e40;
#line 248 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divx_restore_neutron = 1;
#line 205 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divx_radius = 0;
#line 248 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("dx, auto,Gap0_end_Divx") strncpy(mccGap0_end_divx_options, "dx, auto,Gap0_end_Divx" ? "dx, auto,Gap0_end_Divx" : "", 16384); else mccGap0_end_divx_options[0]='\0';
#line 206 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccGap0_end_divx_filename, "NULL" ? "NULL" : "", 16384); else mccGap0_end_divx_filename[0]='\0';
#line 206 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccGap0_end_divx_geometry, "NULL" ? "NULL" : "", 16384); else mccGap0_end_divx_geometry[0]='\0';
#line 207 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccGap0_end_divx_username1, "NULL" ? "NULL" : "", 16384); else mccGap0_end_divx_username1[0]='\0';
#line 207 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccGap0_end_divx_username2, "NULL" ? "NULL" : "", 16384); else mccGap0_end_divx_username2[0]='\0';
#line 207 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccGap0_end_divx_username3, "NULL" ? "NULL" : "", 16384); else mccGap0_end_divx_username3[0]='\0';
#line 208 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divx_nowritefile = 0;
#line 23317 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap0_end_divx (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23324 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaSource, mcrotaGap0_end_divx);
  rot_transpose(mcrotaGap0_end_Lam, mctr1);
  rot_mul(mcrotaGap0_end_divx, mctr1, mcrotrGap0_end_divx);
  mctc1 = coords_set(
#line 249 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 249 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 249 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.11 + 1.203 + 2e-4);
#line 23335 "./SNS_BASIS.c"
  rot_transpose(mcrotaSource, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap0_end_divx = coords_add(mcposaSource, mctc2);
  mctc1 = coords_sub(mcposaGap0_end_Lam, mcposaGap0_end_divx);
  mcposrGap0_end_divx = rot_apply(mcrotaGap0_end_divx, mctc1);
  mcDEBUG_COMPONENT("Gap0_end_divx", mcposaGap0_end_divx, mcrotaGap0_end_divx)
  mccomp_posa[8] = mcposaGap0_end_divx;
  mccomp_posr[8] = mcposrGap0_end_divx;
  mcNCounter[8]  = mcPCounter[8] = mcP2Counter[8] = 0;
  mcAbsorbProp[8]= 0;
    /* Component Gap0_end_divy. */
  /* Setting parameters for component Gap0_end_divy. */
  SIG_MESSAGE("Gap0_end_divy (Init:SetPar)");
#line 252 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divy_xwidth = 0.10;
#line 252 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divy_yheight = 0.12;
#line 203 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divy_zdepth = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divy_xmin = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divy_xmax = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divy_ymin = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divy_ymax = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divy_zmin = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divy_zmax = 0;
#line 205 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divy_bins = 0;
#line 205 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divy_min = -1e40;
#line 205 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divy_max = 1e40;
#line 252 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divy_restore_neutron = 1;
#line 205 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divy_radius = 0;
#line 252 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("dy, auto,Divy_Gap0_end_Divy") strncpy(mccGap0_end_divy_options, "dy, auto,Divy_Gap0_end_Divy" ? "dy, auto,Divy_Gap0_end_Divy" : "", 16384); else mccGap0_end_divy_options[0]='\0';
#line 206 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccGap0_end_divy_filename, "NULL" ? "NULL" : "", 16384); else mccGap0_end_divy_filename[0]='\0';
#line 206 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccGap0_end_divy_geometry, "NULL" ? "NULL" : "", 16384); else mccGap0_end_divy_geometry[0]='\0';
#line 207 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccGap0_end_divy_username1, "NULL" ? "NULL" : "", 16384); else mccGap0_end_divy_username1[0]='\0';
#line 207 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccGap0_end_divy_username2, "NULL" ? "NULL" : "", 16384); else mccGap0_end_divy_username2[0]='\0';
#line 207 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccGap0_end_divy_username3, "NULL" ? "NULL" : "", 16384); else mccGap0_end_divy_username3[0]='\0';
#line 208 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap0_end_divy_nowritefile = 0;
#line 23391 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap0_end_divy (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23398 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaSource, mcrotaGap0_end_divy);
  rot_transpose(mcrotaGap0_end_divx, mctr1);
  rot_mul(mcrotaGap0_end_divy, mctr1, mcrotrGap0_end_divy);
  mctc1 = coords_set(
#line 253 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 253 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 253 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.11 + 1.203 + 3e-4);
#line 23409 "./SNS_BASIS.c"
  rot_transpose(mcrotaSource, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap0_end_divy = coords_add(mcposaSource, mctc2);
  mctc1 = coords_sub(mcposaGap0_end_divx, mcposaGap0_end_divy);
  mcposrGap0_end_divy = rot_apply(mcrotaGap0_end_divy, mctc1);
  mcDEBUG_COMPONENT("Gap0_end_divy", mcposaGap0_end_divy, mcrotaGap0_end_divy)
  mccomp_posa[9] = mcposaGap0_end_divy;
  mccomp_posr[9] = mcposrGap0_end_divy;
  mcNCounter[9]  = mcPCounter[9] = mcP2Counter[9] = 0;
  mcAbsorbProp[9]= 0;
    /* Component Core_Vessel_Section. */
  /* Setting parameters for component Core_Vessel_Section. */
  SIG_MESSAGE("Core_Vessel_Section (Init:SetPar)");
#line 58 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(0) strncpy(mccCore_Vessel_Section_reflect, 0 ? 0 : "", 16384); else mccCore_Vessel_Section_reflect[0]='\0';
#line 260 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCore_Vessel_Section_w1 = 0.10;
#line 260 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCore_Vessel_Section_h1 = 0.12;
#line 260 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCore_Vessel_Section_w2 = 0.10;
#line 260 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCore_Vessel_Section_h2 = 0.12;
#line 260 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCore_Vessel_Section_l = 1.05;
#line 58 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCore_Vessel_Section_R0 = 0.99;
#line 58 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCore_Vessel_Section_Qc = 0.0219;
#line 58 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCore_Vessel_Section_alpha = 6.07;
#line 260 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCore_Vessel_Section_m = 1;
#line 58 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCore_Vessel_Section_W = 0.003;
#line 23445 "./SNS_BASIS.c"

  SIG_MESSAGE("Core_Vessel_Section (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23452 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaSource, mcrotaCore_Vessel_Section);
  rot_transpose(mcrotaGap0_end_divy, mctr1);
  rot_mul(mcrotaCore_Vessel_Section, mctr1, mcrotrCore_Vessel_Section);
  mctc1 = coords_set(
#line 261 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 261 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 261 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1.204);
#line 23463 "./SNS_BASIS.c"
  rot_transpose(mcrotaSource, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCore_Vessel_Section = coords_add(mcposaSource, mctc2);
  mctc1 = coords_sub(mcposaGap0_end_divy, mcposaCore_Vessel_Section);
  mcposrCore_Vessel_Section = rot_apply(mcrotaCore_Vessel_Section, mctc1);
  mcDEBUG_COMPONENT("Core_Vessel_Section", mcposaCore_Vessel_Section, mcrotaCore_Vessel_Section)
  mccomp_posa[10] = mcposaCore_Vessel_Section;
  mccomp_posr[10] = mcposrCore_Vessel_Section;
  mcNCounter[10]  = mcPCounter[10] = mcP2Counter[10] = 0;
  mcAbsorbProp[10]= 0;
    /* Component Gap1_start. */
  /* Setting parameters for component Gap1_start. */
  SIG_MESSAGE("Gap1_start (Init:SetPar)");

  SIG_MESSAGE("Gap1_start (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23483 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCore_Vessel_Section, mcrotaGap1_start);
  rot_transpose(mcrotaCore_Vessel_Section, mctr1);
  rot_mul(mcrotaGap1_start, mctr1, mcrotrGap1_start);
  mctc1 = coords_set(
#line 267 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 267 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 267 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1.05);
#line 23494 "./SNS_BASIS.c"
  rot_transpose(mcrotaCore_Vessel_Section, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap1_start = coords_add(mcposaCore_Vessel_Section, mctc2);
  mctc1 = coords_sub(mcposaCore_Vessel_Section, mcposaGap1_start);
  mcposrGap1_start = rot_apply(mcrotaGap1_start, mctc1);
  mcDEBUG_COMPONENT("Gap1_start", mcposaGap1_start, mcrotaGap1_start)
  mccomp_posa[11] = mcposaGap1_start;
  mccomp_posr[11] = mcposrGap1_start;
  mcNCounter[11]  = mcPCounter[11] = mcP2Counter[11] = 0;
  mcAbsorbProp[11]= 0;
    /* Component Gap1_start_Lam. */
  /* Setting parameters for component Gap1_start_Lam. */
  SIG_MESSAGE("Gap1_start_Lam (Init:SetPar)");
#line 270 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("Lam_monitor_2.2541m_atEndof_CVS") strncpy(mccGap1_start_Lam_filename, "Lam_monitor_2.2541m_atEndof_CVS" ? "Lam_monitor_2.2541m_atEndof_CVS" : "", 16384); else mccGap1_start_Lam_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap1_start_Lam_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap1_start_Lam_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap1_start_Lam_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap1_start_Lam_ymax = 0.05;
#line 270 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap1_start_Lam_xwidth = 0.4;
#line 271 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap1_start_Lam_yheight = 0.4;
#line 271 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap1_start_Lam_Lmin = 0.1;
#line 271 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap1_start_Lam_Lmax = 12.4;
#line 270 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap1_start_Lam_restore_neutron = 1;
#line 51 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap1_start_Lam_nowritefile = 0;
#line 23530 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap1_start_Lam (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23537 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap1_start, mcrotaGap1_start_Lam);
  rot_transpose(mcrotaGap1_start, mctr1);
  rot_mul(mcrotaGap1_start_Lam, mctr1, mcrotrGap1_start_Lam);
  mctc1 = coords_set(
#line 272 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 272 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 272 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 23548 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap1_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap1_start_Lam = coords_add(mcposaGap1_start, mctc2);
  mctc1 = coords_sub(mcposaGap1_start, mcposaGap1_start_Lam);
  mcposrGap1_start_Lam = rot_apply(mcrotaGap1_start_Lam, mctc1);
  mcDEBUG_COMPONENT("Gap1_start_Lam", mcposaGap1_start_Lam, mcrotaGap1_start_Lam)
  mccomp_posa[12] = mcposaGap1_start_Lam;
  mccomp_posr[12] = mcposrGap1_start_Lam;
  mcNCounter[12]  = mcPCounter[12] = mcP2Counter[12] = 0;
  mcAbsorbProp[12]= 0;
    /* Component Gap1_end_Lam. */
  /* Setting parameters for component Gap1_end_Lam. */
  SIG_MESSAGE("Gap1_end_Lam (Init:SetPar)");
#line 280 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("Lam_monitor_2.295m_between_CVS_and_SGI") strncpy(mccGap1_end_Lam_filename, "Lam_monitor_2.295m_between_CVS_and_SGI" ? "Lam_monitor_2.295m_between_CVS_and_SGI" : "", 16384); else mccGap1_end_Lam_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap1_end_Lam_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap1_end_Lam_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap1_end_Lam_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap1_end_Lam_ymax = 0.05;
#line 280 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap1_end_Lam_xwidth = 0.4;
#line 281 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap1_end_Lam_yheight = 0.4;
#line 281 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap1_end_Lam_Lmin = 0.1;
#line 281 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap1_end_Lam_Lmax = 12.4;
#line 280 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap1_end_Lam_restore_neutron = 1;
#line 51 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap1_end_Lam_nowritefile = 0;
#line 23584 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap1_end_Lam (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23591 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap1_start, mcrotaGap1_end_Lam);
  rot_transpose(mcrotaGap1_start_Lam, mctr1);
  rot_mul(mcrotaGap1_end_Lam, mctr1, mcrotrGap1_end_Lam);
  mctc1 = coords_set(
#line 282 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 282 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 282 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.041);
#line 23602 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap1_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap1_end_Lam = coords_add(mcposaGap1_start, mctc2);
  mctc1 = coords_sub(mcposaGap1_start_Lam, mcposaGap1_end_Lam);
  mcposrGap1_end_Lam = rot_apply(mcrotaGap1_end_Lam, mctc1);
  mcDEBUG_COMPONENT("Gap1_end_Lam", mcposaGap1_end_Lam, mcrotaGap1_end_Lam)
  mccomp_posa[13] = mcposaGap1_end_Lam;
  mccomp_posr[13] = mcposrGap1_end_Lam;
  mcNCounter[13]  = mcPCounter[13] = mcP2Counter[13] = 0;
  mcAbsorbProp[13]= 0;
    /* Component Gap1_end. */
  /* Setting parameters for component Gap1_end. */
  SIG_MESSAGE("Gap1_end (Init:SetPar)");

  SIG_MESSAGE("Gap1_end (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23622 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap1_start, mcrotaGap1_end);
  rot_transpose(mcrotaGap1_end_Lam, mctr1);
  rot_mul(mcrotaGap1_end, mctr1, mcrotrGap1_end);
  mctc1 = coords_set(
#line 291 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 291 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 291 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.043);
#line 23633 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap1_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap1_end = coords_add(mcposaGap1_start, mctc2);
  mctc1 = coords_sub(mcposaGap1_end_Lam, mcposaGap1_end);
  mcposrGap1_end = rot_apply(mcrotaGap1_end, mctc1);
  mcDEBUG_COMPONENT("Gap1_end", mcposaGap1_end, mcrotaGap1_end)
  mccomp_posa[14] = mcposaGap1_end;
  mccomp_posr[14] = mcposrGap1_end;
  mcNCounter[14]  = mcPCounter[14] = mcP2Counter[14] = 0;
  mcAbsorbProp[14]= 0;
    /* Component Shutter_Guide_Insert. */
  /* Setting parameters for component Shutter_Guide_Insert. */
  SIG_MESSAGE("Shutter_Guide_Insert (Init:SetPar)");
#line 296 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_w1 = 0.10;
#line 296 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_h2 = 0;
#line 296 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_l = 0.25;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_d = 0.0005;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_mleft = 1.0;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_mright = 2.5;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_mtop = 1.5;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccShutter_Guide_Insert_reflect, "NULL" ? "NULL" : "", 16384); else mccShutter_Guide_Insert_reflect[0]='\0';
#line 23715 "./SNS_BASIS.c"

  SIG_MESSAGE("Shutter_Guide_Insert (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23722 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap1_start, mcrotaShutter_Guide_Insert);
  rot_transpose(mcrotaGap1_end, mctr1);
  rot_mul(mcrotaShutter_Guide_Insert, mctr1, mcrotrShutter_Guide_Insert);
  mctc1 = coords_set(
#line 298 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 298 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 298 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.043);
#line 23733 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap1_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaShutter_Guide_Insert = coords_add(mcposaGap1_start, mctc2);
  mctc1 = coords_sub(mcposaGap1_end, mcposaShutter_Guide_Insert);
  mcposrShutter_Guide_Insert = rot_apply(mcrotaShutter_Guide_Insert, mctc1);
  mcDEBUG_COMPONENT("Shutter_Guide_Insert", mcposaShutter_Guide_Insert, mcrotaShutter_Guide_Insert)
  mccomp_posa[15] = mcposaShutter_Guide_Insert;
  mccomp_posr[15] = mcposrShutter_Guide_Insert;
  mcNCounter[15]  = mcPCounter[15] = mcP2Counter[15] = 0;
  mcAbsorbProp[15]= 0;
    /* Component Shutter_Guide_Insert_16. */
  /* Setting parameters for component Shutter_Guide_Insert_16. */
  SIG_MESSAGE("Shutter_Guide_Insert_16 (Init:SetPar)");
#line 296 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_w1 = 0.10;
#line 296 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_h2 = 0;
#line 296 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_l = 0.25;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_d = 0.0005;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_mleft = 1.0;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_mright = 2.5;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_mtop = 1.5;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_16_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccShutter_Guide_Insert_16_reflect, "NULL" ? "NULL" : "", 16384); else mccShutter_Guide_Insert_16_reflect[0]='\0';
#line 23815 "./SNS_BASIS.c"

  SIG_MESSAGE("Shutter_Guide_Insert_16 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 302 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 302 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.25 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 302 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 23825 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaShutter_Guide_Insert, mcrotaShutter_Guide_Insert_16);
  rot_transpose(mcrotaShutter_Guide_Insert, mctr1);
  rot_mul(mcrotaShutter_Guide_Insert_16, mctr1, mcrotrShutter_Guide_Insert_16);
  mctc1 = coords_set(
#line 301 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 301 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 301 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.25 + 1e-4);
#line 23836 "./SNS_BASIS.c"
  rot_transpose(mcrotaShutter_Guide_Insert, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaShutter_Guide_Insert_16 = coords_add(mcposaShutter_Guide_Insert, mctc2);
  mctc1 = coords_sub(mcposaShutter_Guide_Insert, mcposaShutter_Guide_Insert_16);
  mcposrShutter_Guide_Insert_16 = rot_apply(mcrotaShutter_Guide_Insert_16, mctc1);
  mcDEBUG_COMPONENT("Shutter_Guide_Insert_16", mcposaShutter_Guide_Insert_16, mcrotaShutter_Guide_Insert_16)
  mccomp_posa[16] = mcposaShutter_Guide_Insert_16;
  mccomp_posr[16] = mcposrShutter_Guide_Insert_16;
  mcNCounter[16]  = mcPCounter[16] = mcP2Counter[16] = 0;
  mcAbsorbProp[16]= 0;
    /* Component Shutter_Guide_Insert_17. */
  /* Setting parameters for component Shutter_Guide_Insert_17. */
  SIG_MESSAGE("Shutter_Guide_Insert_17 (Init:SetPar)");
#line 296 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_w1 = 0.10;
#line 296 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_h2 = 0;
#line 296 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_l = 0.25;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_d = 0.0005;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_mleft = 1.0;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_mright = 2.5;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_mtop = 1.5;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_17_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccShutter_Guide_Insert_17_reflect, "NULL" ? "NULL" : "", 16384); else mccShutter_Guide_Insert_17_reflect[0]='\0';
#line 23918 "./SNS_BASIS.c"

  SIG_MESSAGE("Shutter_Guide_Insert_17 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 306 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 306 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.25 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 306 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 23928 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaShutter_Guide_Insert_16, mcrotaShutter_Guide_Insert_17);
  rot_transpose(mcrotaShutter_Guide_Insert_16, mctr1);
  rot_mul(mcrotaShutter_Guide_Insert_17, mctr1, mcrotrShutter_Guide_Insert_17);
  mctc1 = coords_set(
#line 305 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 305 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 305 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.25 + 1e-4);
#line 23939 "./SNS_BASIS.c"
  rot_transpose(mcrotaShutter_Guide_Insert_16, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaShutter_Guide_Insert_17 = coords_add(mcposaShutter_Guide_Insert_16, mctc2);
  mctc1 = coords_sub(mcposaShutter_Guide_Insert_16, mcposaShutter_Guide_Insert_17);
  mcposrShutter_Guide_Insert_17 = rot_apply(mcrotaShutter_Guide_Insert_17, mctc1);
  mcDEBUG_COMPONENT("Shutter_Guide_Insert_17", mcposaShutter_Guide_Insert_17, mcrotaShutter_Guide_Insert_17)
  mccomp_posa[17] = mcposaShutter_Guide_Insert_17;
  mccomp_posr[17] = mcposrShutter_Guide_Insert_17;
  mcNCounter[17]  = mcPCounter[17] = mcP2Counter[17] = 0;
  mcAbsorbProp[17]= 0;
    /* Component Shutter_Guide_Insert_18. */
  /* Setting parameters for component Shutter_Guide_Insert_18. */
  SIG_MESSAGE("Shutter_Guide_Insert_18 (Init:SetPar)");
#line 296 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_w1 = 0.10;
#line 296 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_h2 = 0;
#line 296 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_l = 0.25;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_d = 0.0005;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_mleft = 1.0;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_mright = 2.5;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_mtop = 1.5;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_18_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccShutter_Guide_Insert_18_reflect, "NULL" ? "NULL" : "", 16384); else mccShutter_Guide_Insert_18_reflect[0]='\0';
#line 24021 "./SNS_BASIS.c"

  SIG_MESSAGE("Shutter_Guide_Insert_18 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 310 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 310 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.25 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 310 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 24031 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaShutter_Guide_Insert_17, mcrotaShutter_Guide_Insert_18);
  rot_transpose(mcrotaShutter_Guide_Insert_17, mctr1);
  rot_mul(mcrotaShutter_Guide_Insert_18, mctr1, mcrotrShutter_Guide_Insert_18);
  mctc1 = coords_set(
#line 309 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 309 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 309 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.25 + 1e-4);
#line 24042 "./SNS_BASIS.c"
  rot_transpose(mcrotaShutter_Guide_Insert_17, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaShutter_Guide_Insert_18 = coords_add(mcposaShutter_Guide_Insert_17, mctc2);
  mctc1 = coords_sub(mcposaShutter_Guide_Insert_17, mcposaShutter_Guide_Insert_18);
  mcposrShutter_Guide_Insert_18 = rot_apply(mcrotaShutter_Guide_Insert_18, mctc1);
  mcDEBUG_COMPONENT("Shutter_Guide_Insert_18", mcposaShutter_Guide_Insert_18, mcrotaShutter_Guide_Insert_18)
  mccomp_posa[18] = mcposaShutter_Guide_Insert_18;
  mccomp_posr[18] = mcposrShutter_Guide_Insert_18;
  mcNCounter[18]  = mcPCounter[18] = mcP2Counter[18] = 0;
  mcAbsorbProp[18]= 0;
    /* Component Shutter_Guide_Insert_19. */
  /* Setting parameters for component Shutter_Guide_Insert_19. */
  SIG_MESSAGE("Shutter_Guide_Insert_19 (Init:SetPar)");
#line 296 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_w1 = 0.10;
#line 296 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_h2 = 0;
#line 296 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_l = 0.25;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_d = 0.0005;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_mleft = 1.0;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_mright = 2.5;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_mtop = 1.5;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_19_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccShutter_Guide_Insert_19_reflect, "NULL" ? "NULL" : "", 16384); else mccShutter_Guide_Insert_19_reflect[0]='\0';
#line 24124 "./SNS_BASIS.c"

  SIG_MESSAGE("Shutter_Guide_Insert_19 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 314 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 314 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.25 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 314 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 24134 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaShutter_Guide_Insert_18, mcrotaShutter_Guide_Insert_19);
  rot_transpose(mcrotaShutter_Guide_Insert_18, mctr1);
  rot_mul(mcrotaShutter_Guide_Insert_19, mctr1, mcrotrShutter_Guide_Insert_19);
  mctc1 = coords_set(
#line 313 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 313 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 313 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.25 + 1e-4);
#line 24145 "./SNS_BASIS.c"
  rot_transpose(mcrotaShutter_Guide_Insert_18, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaShutter_Guide_Insert_19 = coords_add(mcposaShutter_Guide_Insert_18, mctc2);
  mctc1 = coords_sub(mcposaShutter_Guide_Insert_18, mcposaShutter_Guide_Insert_19);
  mcposrShutter_Guide_Insert_19 = rot_apply(mcrotaShutter_Guide_Insert_19, mctc1);
  mcDEBUG_COMPONENT("Shutter_Guide_Insert_19", mcposaShutter_Guide_Insert_19, mcrotaShutter_Guide_Insert_19)
  mccomp_posa[19] = mcposaShutter_Guide_Insert_19;
  mccomp_posr[19] = mcposrShutter_Guide_Insert_19;
  mcNCounter[19]  = mcPCounter[19] = mcP2Counter[19] = 0;
  mcAbsorbProp[19]= 0;
    /* Component Shutter_Guide_Insert_20. */
  /* Setting parameters for component Shutter_Guide_Insert_20. */
  SIG_MESSAGE("Shutter_Guide_Insert_20 (Init:SetPar)");
#line 296 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_w1 = 0.10;
#line 296 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_h2 = 0;
#line 296 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_l = 0.25;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_d = 0.0005;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_mleft = 1.0;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_mright = 2.5;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_mtop = 1.5;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_20_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccShutter_Guide_Insert_20_reflect, "NULL" ? "NULL" : "", 16384); else mccShutter_Guide_Insert_20_reflect[0]='\0';
#line 24227 "./SNS_BASIS.c"

  SIG_MESSAGE("Shutter_Guide_Insert_20 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 318 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 318 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.25 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 318 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 24237 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaShutter_Guide_Insert_19, mcrotaShutter_Guide_Insert_20);
  rot_transpose(mcrotaShutter_Guide_Insert_19, mctr1);
  rot_mul(mcrotaShutter_Guide_Insert_20, mctr1, mcrotrShutter_Guide_Insert_20);
  mctc1 = coords_set(
#line 317 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 317 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 317 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.25 + 1e-4);
#line 24248 "./SNS_BASIS.c"
  rot_transpose(mcrotaShutter_Guide_Insert_19, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaShutter_Guide_Insert_20 = coords_add(mcposaShutter_Guide_Insert_19, mctc2);
  mctc1 = coords_sub(mcposaShutter_Guide_Insert_19, mcposaShutter_Guide_Insert_20);
  mcposrShutter_Guide_Insert_20 = rot_apply(mcrotaShutter_Guide_Insert_20, mctc1);
  mcDEBUG_COMPONENT("Shutter_Guide_Insert_20", mcposaShutter_Guide_Insert_20, mcrotaShutter_Guide_Insert_20)
  mccomp_posa[20] = mcposaShutter_Guide_Insert_20;
  mccomp_posr[20] = mcposrShutter_Guide_Insert_20;
  mcNCounter[20]  = mcPCounter[20] = mcP2Counter[20] = 0;
  mcAbsorbProp[20]= 0;
    /* Component Shutter_Guide_Insert_21. */
  /* Setting parameters for component Shutter_Guide_Insert_21. */
  SIG_MESSAGE("Shutter_Guide_Insert_21 (Init:SetPar)");
#line 296 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_w1 = 0.10;
#line 296 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_h2 = 0;
#line 296 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_l = 0.25;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_d = 0.0005;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_mleft = 1.0;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_mright = 2.5;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_mtop = 1.5;
#line 297 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_21_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccShutter_Guide_Insert_21_reflect, "NULL" ? "NULL" : "", 16384); else mccShutter_Guide_Insert_21_reflect[0]='\0';
#line 24330 "./SNS_BASIS.c"

  SIG_MESSAGE("Shutter_Guide_Insert_21 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 322 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 322 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.25 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 322 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 24340 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaShutter_Guide_Insert_20, mcrotaShutter_Guide_Insert_21);
  rot_transpose(mcrotaShutter_Guide_Insert_20, mctr1);
  rot_mul(mcrotaShutter_Guide_Insert_21, mctr1, mcrotrShutter_Guide_Insert_21);
  mctc1 = coords_set(
#line 321 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 321 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 321 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.25 + 1e-4);
#line 24351 "./SNS_BASIS.c"
  rot_transpose(mcrotaShutter_Guide_Insert_20, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaShutter_Guide_Insert_21 = coords_add(mcposaShutter_Guide_Insert_20, mctc2);
  mctc1 = coords_sub(mcposaShutter_Guide_Insert_20, mcposaShutter_Guide_Insert_21);
  mcposrShutter_Guide_Insert_21 = rot_apply(mcrotaShutter_Guide_Insert_21, mctc1);
  mcDEBUG_COMPONENT("Shutter_Guide_Insert_21", mcposaShutter_Guide_Insert_21, mcrotaShutter_Guide_Insert_21)
  mccomp_posa[21] = mcposaShutter_Guide_Insert_21;
  mccomp_posr[21] = mcposrShutter_Guide_Insert_21;
  mcNCounter[21]  = mcPCounter[21] = mcP2Counter[21] = 0;
  mcAbsorbProp[21]= 0;
    /* Component Shutter_Guide_Insert_short. */
  /* Setting parameters for component Shutter_Guide_Insert_short. */
  SIG_MESSAGE("Shutter_Guide_Insert_short (Init:SetPar)");
#line 324 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_w1 = 0.10;
#line 324 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_h2 = 0;
#line 324 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_l = 0.095;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_d = 0.0005;
#line 325 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_mleft = 1.0;
#line 325 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_mright = 2.5;
#line 325 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_mtop = 1.5;
#line 325 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccShutter_Guide_Insert_short_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccShutter_Guide_Insert_short_reflect, "NULL" ? "NULL" : "", 16384); else mccShutter_Guide_Insert_short_reflect[0]='\0';
#line 24433 "./SNS_BASIS.c"

  SIG_MESSAGE("Shutter_Guide_Insert_short (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 327 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 327 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.095 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 327 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 24443 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaShutter_Guide_Insert_21, mcrotaShutter_Guide_Insert_short);
  rot_transpose(mcrotaShutter_Guide_Insert_21, mctr1);
  rot_mul(mcrotaShutter_Guide_Insert_short, mctr1, mcrotrShutter_Guide_Insert_short);
  mctc1 = coords_set(
#line 326 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 326 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 326 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.25 + 1e-4);
#line 24454 "./SNS_BASIS.c"
  rot_transpose(mcrotaShutter_Guide_Insert_21, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaShutter_Guide_Insert_short = coords_add(mcposaShutter_Guide_Insert_21, mctc2);
  mctc1 = coords_sub(mcposaShutter_Guide_Insert_21, mcposaShutter_Guide_Insert_short);
  mcposrShutter_Guide_Insert_short = rot_apply(mcrotaShutter_Guide_Insert_short, mctc1);
  mcDEBUG_COMPONENT("Shutter_Guide_Insert_short", mcposaShutter_Guide_Insert_short, mcrotaShutter_Guide_Insert_short)
  mccomp_posa[22] = mcposaShutter_Guide_Insert_short;
  mccomp_posr[22] = mcposrShutter_Guide_Insert_short;
  mcNCounter[22]  = mcPCounter[22] = mcP2Counter[22] = 0;
  mcAbsorbProp[22]= 0;
    /* Component Gap2_start. */
  /* Setting parameters for component Gap2_start. */
  SIG_MESSAGE("Gap2_start (Init:SetPar)");

  SIG_MESSAGE("Gap2_start (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24474 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaShutter_Guide_Insert_short, mcrotaGap2_start);
  rot_transpose(mcrotaShutter_Guide_Insert_short, mctr1);
  rot_mul(mcrotaGap2_start, mctr1, mcrotrGap2_start);
  mctc1 = coords_set(
#line 333 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 333 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 333 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.095 + 3e-04);
#line 24485 "./SNS_BASIS.c"
  rot_transpose(mcrotaShutter_Guide_Insert_short, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap2_start = coords_add(mcposaShutter_Guide_Insert_short, mctc2);
  mctc1 = coords_sub(mcposaShutter_Guide_Insert_short, mcposaGap2_start);
  mcposrGap2_start = rot_apply(mcrotaGap2_start, mctc1);
  mcDEBUG_COMPONENT("Gap2_start", mcposaGap2_start, mcrotaGap2_start)
  mccomp_posa[23] = mcposaGap2_start;
  mccomp_posr[23] = mcposrGap2_start;
  mcNCounter[23]  = mcPCounter[23] = mcP2Counter[23] = 0;
  mcAbsorbProp[23]= 0;
    /* Component Gap2_start_Lam. */
  /* Setting parameters for component Gap2_start_Lam. */
  SIG_MESSAGE("Gap2_start_Lam (Init:SetPar)");
#line 337 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("Lam_monitor_4,1431m_atEndof_SGI") strncpy(mccGap2_start_Lam_filename, "Lam_monitor_4,1431m_atEndof_SGI" ? "Lam_monitor_4,1431m_atEndof_SGI" : "", 16384); else mccGap2_start_Lam_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_start_Lam_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_start_Lam_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_start_Lam_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_start_Lam_ymax = 0.05;
#line 337 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_start_Lam_xwidth = 0.4;
#line 338 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_start_Lam_yheight = 0.4;
#line 338 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_start_Lam_Lmin = 0.1;
#line 338 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_start_Lam_Lmax = 12.4;
#line 337 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_start_Lam_restore_neutron = 1;
#line 51 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_start_Lam_nowritefile = 0;
#line 24521 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap2_start_Lam (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24528 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap2_start, mcrotaGap2_start_Lam);
  rot_transpose(mcrotaGap2_start, mctr1);
  rot_mul(mcrotaGap2_start_Lam, mctr1, mcrotrGap2_start_Lam);
  mctc1 = coords_set(
#line 339 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 339 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 339 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 24539 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap2_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap2_start_Lam = coords_add(mcposaGap2_start, mctc2);
  mctc1 = coords_sub(mcposaGap2_start, mcposaGap2_start_Lam);
  mcposrGap2_start_Lam = rot_apply(mcrotaGap2_start_Lam, mctc1);
  mcDEBUG_COMPONENT("Gap2_start_Lam", mcposaGap2_start_Lam, mcrotaGap2_start_Lam)
  mccomp_posa[24] = mcposaGap2_start_Lam;
  mccomp_posr[24] = mcposrGap2_start_Lam;
  mcNCounter[24]  = mcPCounter[24] = mcP2Counter[24] = 0;
  mcAbsorbProp[24]= 0;
    /* Component Gap2_start_PSD. */
  /* Setting parameters for component Gap2_start_PSD. */
  SIG_MESSAGE("Gap2_start_PSD (Init:SetPar)");
#line 342 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_start_PSD_nx = 100;
#line 342 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_start_PSD_ny = 100;
#line 342 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("PSD_monitor_4,1432m_atEndof_SGI") strncpy(mccGap2_start_PSD_filename, "PSD_monitor_4,1432m_atEndof_SGI" ? "PSD_monitor_4,1432m_atEndof_SGI" : "", 16384); else mccGap2_start_PSD_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_start_PSD_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_start_PSD_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_start_PSD_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_start_PSD_ymax = 0.05;
#line 343 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_start_PSD_xwidth = 0.10;
#line 343 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_start_PSD_yheight = 0.12;
#line 343 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_start_PSD_restore_neutron = 1;
#line 24573 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap2_start_PSD (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24580 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap2_start_Lam, mcrotaGap2_start_PSD);
  rot_transpose(mcrotaGap2_start_Lam, mctr1);
  rot_mul(mcrotaGap2_start_PSD, mctr1, mcrotrGap2_start_PSD);
  mctc1 = coords_set(
#line 344 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 344 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 344 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 24591 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap2_start_Lam, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap2_start_PSD = coords_add(mcposaGap2_start_Lam, mctc2);
  mctc1 = coords_sub(mcposaGap2_start_Lam, mcposaGap2_start_PSD);
  mcposrGap2_start_PSD = rot_apply(mcrotaGap2_start_PSD, mctc1);
  mcDEBUG_COMPONENT("Gap2_start_PSD", mcposaGap2_start_PSD, mcrotaGap2_start_PSD)
  mccomp_posa[25] = mcposaGap2_start_PSD;
  mccomp_posr[25] = mcposrGap2_start_PSD;
  mcNCounter[25]  = mcPCounter[25] = mcP2Counter[25] = 0;
  mcAbsorbProp[25]= 0;
    /* Component Gap2_end_Lam. */
  /* Setting parameters for component Gap2_end_Lam. */
  SIG_MESSAGE("Gap2_end_Lam (Init:SetPar)");
#line 348 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("Lam_monitor_4,195m_between_SGI_and_CGS1") strncpy(mccGap2_end_Lam_filename, "Lam_monitor_4,195m_between_SGI_and_CGS1" ? "Lam_monitor_4,195m_between_SGI_and_CGS1" : "", 16384); else mccGap2_end_Lam_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_end_Lam_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_end_Lam_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_end_Lam_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_end_Lam_ymax = 0.05;
#line 348 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_end_Lam_xwidth = 0.4;
#line 349 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_end_Lam_yheight = 0.4;
#line 349 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_end_Lam_Lmin = 0.1;
#line 349 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_end_Lam_Lmax = 40.0;
#line 348 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_end_Lam_restore_neutron = 1;
#line 51 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_end_Lam_nowritefile = 0;
#line 24627 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap2_end_Lam (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 351 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 351 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.052 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 351 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 24637 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap2_start, mcrotaGap2_end_Lam);
  rot_transpose(mcrotaGap2_start_PSD, mctr1);
  rot_mul(mcrotaGap2_end_Lam, mctr1, mcrotrGap2_end_Lam);
  mctc1 = coords_set(
#line 350 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 350 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 350 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.052);
#line 24648 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap2_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap2_end_Lam = coords_add(mcposaGap2_start, mctc2);
  mctc1 = coords_sub(mcposaGap2_start_PSD, mcposaGap2_end_Lam);
  mcposrGap2_end_Lam = rot_apply(mcrotaGap2_end_Lam, mctc1);
  mcDEBUG_COMPONENT("Gap2_end_Lam", mcposaGap2_end_Lam, mcrotaGap2_end_Lam)
  mccomp_posa[26] = mcposaGap2_end_Lam;
  mccomp_posr[26] = mcposrGap2_end_Lam;
  mcNCounter[26]  = mcPCounter[26] = mcP2Counter[26] = 0;
  mcAbsorbProp[26]= 0;
    /* Component Gap2_end_PSD. */
  /* Setting parameters for component Gap2_end_PSD. */
  SIG_MESSAGE("Gap2_end_PSD (Init:SetPar)");
#line 354 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_end_PSD_nx = 100;
#line 354 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_end_PSD_ny = 100;
#line 354 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("PSD_monitor_4,196m_between_SGI_and_CGS1") strncpy(mccGap2_end_PSD_filename, "PSD_monitor_4,196m_between_SGI_and_CGS1" ? "PSD_monitor_4,196m_between_SGI_and_CGS1" : "", 16384); else mccGap2_end_PSD_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_end_PSD_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_end_PSD_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_end_PSD_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_end_PSD_ymax = 0.05;
#line 355 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_end_PSD_xwidth = 0.10;
#line 355 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_end_PSD_yheight = 0.12;
#line 355 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap2_end_PSD_restore_neutron = 1;
#line 24682 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap2_end_PSD (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 357 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 357 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.053 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 357 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 24692 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap2_start, mcrotaGap2_end_PSD);
  rot_transpose(mcrotaGap2_end_Lam, mctr1);
  rot_mul(mcrotaGap2_end_PSD, mctr1, mcrotrGap2_end_PSD);
  mctc1 = coords_set(
#line 356 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 356 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 356 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.053);
#line 24703 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap2_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap2_end_PSD = coords_add(mcposaGap2_start, mctc2);
  mctc1 = coords_sub(mcposaGap2_end_Lam, mcposaGap2_end_PSD);
  mcposrGap2_end_PSD = rot_apply(mcrotaGap2_end_PSD, mctc1);
  mcDEBUG_COMPONENT("Gap2_end_PSD", mcposaGap2_end_PSD, mcrotaGap2_end_PSD)
  mccomp_posa[27] = mcposaGap2_end_PSD;
  mccomp_posr[27] = mcposrGap2_end_PSD;
  mcNCounter[27]  = mcPCounter[27] = mcP2Counter[27] = 0;
  mcAbsorbProp[27]= 0;
    /* Component Gap2_end. */
  /* Setting parameters for component Gap2_end. */
  SIG_MESSAGE("Gap2_end (Init:SetPar)");

  SIG_MESSAGE("Gap2_end (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 362 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 362 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.054 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 362 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 24726 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap2_start, mcrotaGap2_end);
  rot_transpose(mcrotaGap2_end_PSD, mctr1);
  rot_mul(mcrotaGap2_end, mctr1, mcrotrGap2_end);
  mctc1 = coords_set(
#line 361 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 361 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 361 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.054);
#line 24737 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap2_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap2_end = coords_add(mcposaGap2_start, mctc2);
  mctc1 = coords_sub(mcposaGap2_end_PSD, mcposaGap2_end);
  mcposrGap2_end = rot_apply(mcrotaGap2_end, mctc1);
  mcDEBUG_COMPONENT("Gap2_end", mcposaGap2_end, mcrotaGap2_end)
  mccomp_posa[28] = mcposaGap2_end;
  mccomp_posr[28] = mcposrGap2_end;
  mcNCounter[28]  = mcPCounter[28] = mcP2Counter[28] = 0;
  mcAbsorbProp[28]= 0;
    /* Component Curved_Guide_Section_I. */
  /* Setting parameters for component Curved_Guide_Section_I. */
  SIG_MESSAGE("Curved_Guide_Section_I (Init:SetPar)");
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_w1 = 0.10;
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_h2 = 0;
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_l = 0.25;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_d = 0.0005;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_mleft = 1.0;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_mright = 2.5;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_mtop = 1.5;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_I_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_I_reflect[0]='\0';
#line 24819 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_I (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24826 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap2_end, mcrotaCurved_Guide_Section_I);
  rot_transpose(mcrotaGap2_end, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_I, mctr1, mcrotrCurved_Guide_Section_I);
  mctc1 = coords_set(
#line 369 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 369 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 369 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0);
#line 24837 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap2_end, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_I = coords_add(mcposaGap2_end, mctc2);
  mctc1 = coords_sub(mcposaGap2_end, mcposaCurved_Guide_Section_I);
  mcposrCurved_Guide_Section_I = rot_apply(mcrotaCurved_Guide_Section_I, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_I", mcposaCurved_Guide_Section_I, mcrotaCurved_Guide_Section_I)
  mccomp_posa[29] = mcposaCurved_Guide_Section_I;
  mccomp_posr[29] = mcposrCurved_Guide_Section_I;
  mcNCounter[29]  = mcPCounter[29] = mcP2Counter[29] = 0;
  mcAbsorbProp[29]= 0;
    /* Component Curved_Guide_Section_I_30. */
  /* Setting parameters for component Curved_Guide_Section_I_30. */
  SIG_MESSAGE("Curved_Guide_Section_I_30 (Init:SetPar)");
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_w1 = 0.10;
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_h2 = 0;
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_l = 0.25;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_d = 0.0005;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_mleft = 1.0;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_mright = 2.5;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_mtop = 1.5;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_30_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_I_30_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_I_30_reflect[0]='\0';
#line 24919 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_I_30 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 373 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 373 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.25 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 373 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 24929 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_I, mcrotaCurved_Guide_Section_I_30);
  rot_transpose(mcrotaCurved_Guide_Section_I, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_I_30, mctr1, mcrotrCurved_Guide_Section_I_30);
  mctc1 = coords_set(
#line 372 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 372 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 372 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.25 + 1e-4);
#line 24940 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_I, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_I_30 = coords_add(mcposaCurved_Guide_Section_I, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_I, mcposaCurved_Guide_Section_I_30);
  mcposrCurved_Guide_Section_I_30 = rot_apply(mcrotaCurved_Guide_Section_I_30, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_I_30", mcposaCurved_Guide_Section_I_30, mcrotaCurved_Guide_Section_I_30)
  mccomp_posa[30] = mcposaCurved_Guide_Section_I_30;
  mccomp_posr[30] = mcposrCurved_Guide_Section_I_30;
  mcNCounter[30]  = mcPCounter[30] = mcP2Counter[30] = 0;
  mcAbsorbProp[30]= 0;
    /* Component Curved_Guide_Section_I_31. */
  /* Setting parameters for component Curved_Guide_Section_I_31. */
  SIG_MESSAGE("Curved_Guide_Section_I_31 (Init:SetPar)");
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_w1 = 0.10;
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_h2 = 0;
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_l = 0.25;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_d = 0.0005;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_mleft = 1.0;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_mright = 2.5;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_mtop = 1.5;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_31_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_I_31_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_I_31_reflect[0]='\0';
#line 25022 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_I_31 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 377 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 377 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.25 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 377 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 25032 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_I_30, mcrotaCurved_Guide_Section_I_31);
  rot_transpose(mcrotaCurved_Guide_Section_I_30, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_I_31, mctr1, mcrotrCurved_Guide_Section_I_31);
  mctc1 = coords_set(
#line 376 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 376 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 376 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.25 + 1e-4);
#line 25043 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_I_30, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_I_31 = coords_add(mcposaCurved_Guide_Section_I_30, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_I_30, mcposaCurved_Guide_Section_I_31);
  mcposrCurved_Guide_Section_I_31 = rot_apply(mcrotaCurved_Guide_Section_I_31, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_I_31", mcposaCurved_Guide_Section_I_31, mcrotaCurved_Guide_Section_I_31)
  mccomp_posa[31] = mcposaCurved_Guide_Section_I_31;
  mccomp_posr[31] = mcposrCurved_Guide_Section_I_31;
  mcNCounter[31]  = mcPCounter[31] = mcP2Counter[31] = 0;
  mcAbsorbProp[31]= 0;
    /* Component Curved_Guide_Section_I_32. */
  /* Setting parameters for component Curved_Guide_Section_I_32. */
  SIG_MESSAGE("Curved_Guide_Section_I_32 (Init:SetPar)");
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_w1 = 0.10;
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_h2 = 0;
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_l = 0.25;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_d = 0.0005;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_mleft = 1.0;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_mright = 2.5;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_mtop = 1.5;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_32_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_I_32_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_I_32_reflect[0]='\0';
#line 25125 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_I_32 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 381 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 381 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.25 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 381 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 25135 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_I_31, mcrotaCurved_Guide_Section_I_32);
  rot_transpose(mcrotaCurved_Guide_Section_I_31, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_I_32, mctr1, mcrotrCurved_Guide_Section_I_32);
  mctc1 = coords_set(
#line 380 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 380 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 380 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.25 + 1e-4);
#line 25146 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_I_31, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_I_32 = coords_add(mcposaCurved_Guide_Section_I_31, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_I_31, mcposaCurved_Guide_Section_I_32);
  mcposrCurved_Guide_Section_I_32 = rot_apply(mcrotaCurved_Guide_Section_I_32, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_I_32", mcposaCurved_Guide_Section_I_32, mcrotaCurved_Guide_Section_I_32)
  mccomp_posa[32] = mcposaCurved_Guide_Section_I_32;
  mccomp_posr[32] = mcposrCurved_Guide_Section_I_32;
  mcNCounter[32]  = mcPCounter[32] = mcP2Counter[32] = 0;
  mcAbsorbProp[32]= 0;
    /* Component Curved_Guide_Section_I_33. */
  /* Setting parameters for component Curved_Guide_Section_I_33. */
  SIG_MESSAGE("Curved_Guide_Section_I_33 (Init:SetPar)");
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_w1 = 0.10;
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_h2 = 0;
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_l = 0.25;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_d = 0.0005;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_mleft = 1.0;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_mright = 2.5;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_mtop = 1.5;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_33_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_I_33_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_I_33_reflect[0]='\0';
#line 25228 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_I_33 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 385 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 385 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.25 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 385 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 25238 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_I_32, mcrotaCurved_Guide_Section_I_33);
  rot_transpose(mcrotaCurved_Guide_Section_I_32, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_I_33, mctr1, mcrotrCurved_Guide_Section_I_33);
  mctc1 = coords_set(
#line 384 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 384 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 384 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.25 + 1e-4);
#line 25249 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_I_32, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_I_33 = coords_add(mcposaCurved_Guide_Section_I_32, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_I_32, mcposaCurved_Guide_Section_I_33);
  mcposrCurved_Guide_Section_I_33 = rot_apply(mcrotaCurved_Guide_Section_I_33, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_I_33", mcposaCurved_Guide_Section_I_33, mcrotaCurved_Guide_Section_I_33)
  mccomp_posa[33] = mcposaCurved_Guide_Section_I_33;
  mccomp_posr[33] = mcposrCurved_Guide_Section_I_33;
  mcNCounter[33]  = mcPCounter[33] = mcP2Counter[33] = 0;
  mcAbsorbProp[33]= 0;
    /* Component Curved_Guide_Section_I_34. */
  /* Setting parameters for component Curved_Guide_Section_I_34. */
  SIG_MESSAGE("Curved_Guide_Section_I_34 (Init:SetPar)");
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_w1 = 0.10;
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_h2 = 0;
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_l = 0.25;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_d = 0.0005;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_mleft = 1.0;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_mright = 2.5;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_mtop = 1.5;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_34_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_I_34_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_I_34_reflect[0]='\0';
#line 25331 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_I_34 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 389 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 389 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.25 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 389 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 25341 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_I_33, mcrotaCurved_Guide_Section_I_34);
  rot_transpose(mcrotaCurved_Guide_Section_I_33, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_I_34, mctr1, mcrotrCurved_Guide_Section_I_34);
  mctc1 = coords_set(
#line 388 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 388 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 388 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.25 + 1e-4);
#line 25352 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_I_33, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_I_34 = coords_add(mcposaCurved_Guide_Section_I_33, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_I_33, mcposaCurved_Guide_Section_I_34);
  mcposrCurved_Guide_Section_I_34 = rot_apply(mcrotaCurved_Guide_Section_I_34, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_I_34", mcposaCurved_Guide_Section_I_34, mcrotaCurved_Guide_Section_I_34)
  mccomp_posa[34] = mcposaCurved_Guide_Section_I_34;
  mccomp_posr[34] = mcposrCurved_Guide_Section_I_34;
  mcNCounter[34]  = mcPCounter[34] = mcP2Counter[34] = 0;
  mcAbsorbProp[34]= 0;
    /* Component Curved_Guide_Section_I_35. */
  /* Setting parameters for component Curved_Guide_Section_I_35. */
  SIG_MESSAGE("Curved_Guide_Section_I_35 (Init:SetPar)");
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_w1 = 0.10;
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_h2 = 0;
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_l = 0.25;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_d = 0.0005;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_mleft = 1.0;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_mright = 2.5;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_mtop = 1.5;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_35_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_I_35_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_I_35_reflect[0]='\0';
#line 25434 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_I_35 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 393 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 393 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.25 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 393 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 25444 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_I_34, mcrotaCurved_Guide_Section_I_35);
  rot_transpose(mcrotaCurved_Guide_Section_I_34, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_I_35, mctr1, mcrotrCurved_Guide_Section_I_35);
  mctc1 = coords_set(
#line 392 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 392 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 392 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.25 + 1e-4);
#line 25455 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_I_34, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_I_35 = coords_add(mcposaCurved_Guide_Section_I_34, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_I_34, mcposaCurved_Guide_Section_I_35);
  mcposrCurved_Guide_Section_I_35 = rot_apply(mcrotaCurved_Guide_Section_I_35, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_I_35", mcposaCurved_Guide_Section_I_35, mcrotaCurved_Guide_Section_I_35)
  mccomp_posa[35] = mcposaCurved_Guide_Section_I_35;
  mccomp_posr[35] = mcposrCurved_Guide_Section_I_35;
  mcNCounter[35]  = mcPCounter[35] = mcP2Counter[35] = 0;
  mcAbsorbProp[35]= 0;
    /* Component Curved_Guide_Section_I_36. */
  /* Setting parameters for component Curved_Guide_Section_I_36. */
  SIG_MESSAGE("Curved_Guide_Section_I_36 (Init:SetPar)");
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_w1 = 0.10;
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_h2 = 0;
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_l = 0.25;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_d = 0.0005;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_mleft = 1.0;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_mright = 2.5;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_mtop = 1.5;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_36_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_I_36_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_I_36_reflect[0]='\0';
#line 25537 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_I_36 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 397 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 397 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.25 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 397 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 25547 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_I_35, mcrotaCurved_Guide_Section_I_36);
  rot_transpose(mcrotaCurved_Guide_Section_I_35, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_I_36, mctr1, mcrotrCurved_Guide_Section_I_36);
  mctc1 = coords_set(
#line 396 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 396 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 396 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.25 + 1e-4);
#line 25558 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_I_35, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_I_36 = coords_add(mcposaCurved_Guide_Section_I_35, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_I_35, mcposaCurved_Guide_Section_I_36);
  mcposrCurved_Guide_Section_I_36 = rot_apply(mcrotaCurved_Guide_Section_I_36, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_I_36", mcposaCurved_Guide_Section_I_36, mcrotaCurved_Guide_Section_I_36)
  mccomp_posa[36] = mcposaCurved_Guide_Section_I_36;
  mccomp_posr[36] = mcposrCurved_Guide_Section_I_36;
  mcNCounter[36]  = mcPCounter[36] = mcP2Counter[36] = 0;
  mcAbsorbProp[36]= 0;
    /* Component Curved_Guide_Section_I_37. */
  /* Setting parameters for component Curved_Guide_Section_I_37. */
  SIG_MESSAGE("Curved_Guide_Section_I_37 (Init:SetPar)");
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_w1 = 0.10;
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_h2 = 0;
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_l = 0.25;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_d = 0.0005;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_mleft = 1.0;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_mright = 2.5;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_mtop = 1.5;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_37_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_I_37_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_I_37_reflect[0]='\0';
#line 25640 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_I_37 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 401 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 401 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.25 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 401 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 25650 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_I_36, mcrotaCurved_Guide_Section_I_37);
  rot_transpose(mcrotaCurved_Guide_Section_I_36, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_I_37, mctr1, mcrotrCurved_Guide_Section_I_37);
  mctc1 = coords_set(
#line 400 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 400 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 400 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.25 + 1e-4);
#line 25661 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_I_36, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_I_37 = coords_add(mcposaCurved_Guide_Section_I_36, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_I_36, mcposaCurved_Guide_Section_I_37);
  mcposrCurved_Guide_Section_I_37 = rot_apply(mcrotaCurved_Guide_Section_I_37, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_I_37", mcposaCurved_Guide_Section_I_37, mcrotaCurved_Guide_Section_I_37)
  mccomp_posa[37] = mcposaCurved_Guide_Section_I_37;
  mccomp_posr[37] = mcposrCurved_Guide_Section_I_37;
  mcNCounter[37]  = mcPCounter[37] = mcP2Counter[37] = 0;
  mcAbsorbProp[37]= 0;
    /* Component Curved_Guide_Section_I_38. */
  /* Setting parameters for component Curved_Guide_Section_I_38. */
  SIG_MESSAGE("Curved_Guide_Section_I_38 (Init:SetPar)");
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_w1 = 0.10;
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_h2 = 0;
#line 367 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_l = 0.25;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_d = 0.0005;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_mleft = 1.0;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_mright = 2.5;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_mtop = 1.5;
#line 368 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_38_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_I_38_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_I_38_reflect[0]='\0';
#line 25743 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_I_38 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 405 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 405 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.25 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 405 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 25753 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_I_37, mcrotaCurved_Guide_Section_I_38);
  rot_transpose(mcrotaCurved_Guide_Section_I_37, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_I_38, mctr1, mcrotrCurved_Guide_Section_I_38);
  mctc1 = coords_set(
#line 404 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 404 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 404 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.25 + 1e-4);
#line 25764 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_I_37, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_I_38 = coords_add(mcposaCurved_Guide_Section_I_37, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_I_37, mcposaCurved_Guide_Section_I_38);
  mcposrCurved_Guide_Section_I_38 = rot_apply(mcrotaCurved_Guide_Section_I_38, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_I_38", mcposaCurved_Guide_Section_I_38, mcrotaCurved_Guide_Section_I_38)
  mccomp_posa[38] = mcposaCurved_Guide_Section_I_38;
  mccomp_posr[38] = mcposrCurved_Guide_Section_I_38;
  mcNCounter[38]  = mcPCounter[38] = mcP2Counter[38] = 0;
  mcAbsorbProp[38]= 0;
    /* Component Curved_Guide_Section_I_short. */
  /* Setting parameters for component Curved_Guide_Section_I_short. */
  SIG_MESSAGE("Curved_Guide_Section_I_short (Init:SetPar)");
#line 407 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_w1 = 0.10;
#line 407 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_h2 = 0;
#line 407 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_l = 0.245;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_d = 0.0005;
#line 408 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_mleft = 1.0;
#line 408 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_mright = 2.5;
#line 408 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_mtop = 1.5;
#line 408 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_I_short_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_I_short_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_I_short_reflect[0]='\0';
#line 25846 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_I_short (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 410 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 410 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.245 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 410 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 25856 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_I_38, mcrotaCurved_Guide_Section_I_short);
  rot_transpose(mcrotaCurved_Guide_Section_I_38, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_I_short, mctr1, mcrotrCurved_Guide_Section_I_short);
  mctc1 = coords_set(
#line 409 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 409 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 409 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.25 + 1e-4);
#line 25867 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_I_38, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_I_short = coords_add(mcposaCurved_Guide_Section_I_38, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_I_38, mcposaCurved_Guide_Section_I_short);
  mcposrCurved_Guide_Section_I_short = rot_apply(mcrotaCurved_Guide_Section_I_short, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_I_short", mcposaCurved_Guide_Section_I_short, mcrotaCurved_Guide_Section_I_short)
  mccomp_posa[39] = mcposaCurved_Guide_Section_I_short;
  mccomp_posr[39] = mcposrCurved_Guide_Section_I_short;
  mcNCounter[39]  = mcPCounter[39] = mcP2Counter[39] = 0;
  mcAbsorbProp[39]= 0;
    /* Component Gap3_start. */
  /* Setting parameters for component Gap3_start. */
  SIG_MESSAGE("Gap3_start (Init:SetPar)");

  SIG_MESSAGE("Gap3_start (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25887 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_I_short, mcrotaGap3_start);
  rot_transpose(mcrotaCurved_Guide_Section_I_short, mctr1);
  rot_mul(mcrotaGap3_start, mctr1, mcrotrGap3_start);
  mctc1 = coords_set(
#line 416 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 416 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 416 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.245 + 1e-4);
#line 25898 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_I_short, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap3_start = coords_add(mcposaCurved_Guide_Section_I_short, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_I_short, mcposaGap3_start);
  mcposrGap3_start = rot_apply(mcrotaGap3_start, mctc1);
  mcDEBUG_COMPONENT("Gap3_start", mcposaGap3_start, mcrotaGap3_start)
  mccomp_posa[40] = mcposaGap3_start;
  mccomp_posr[40] = mcposrGap3_start;
  mcNCounter[40]  = mcPCounter[40] = mcP2Counter[40] = 0;
  mcAbsorbProp[40]= 0;
    /* Component Gap3_start_Lam. */
  /* Setting parameters for component Gap3_start_Lam. */
  SIG_MESSAGE("Gap3_start_Lam (Init:SetPar)");
#line 419 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("Lam_monitor_6,9432m_just_before_Ch1") strncpy(mccGap3_start_Lam_filename, "Lam_monitor_6,9432m_just_before_Ch1" ? "Lam_monitor_6,9432m_just_before_Ch1" : "", 16384); else mccGap3_start_Lam_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_start_Lam_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_start_Lam_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_start_Lam_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_start_Lam_ymax = 0.05;
#line 419 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_start_Lam_xwidth = 0.4;
#line 420 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_start_Lam_yheight = 0.4;
#line 420 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_start_Lam_Lmin = 2.0;
#line 420 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_start_Lam_Lmax = 10.0;
#line 419 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_start_Lam_restore_neutron = 1;
#line 51 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_start_Lam_nowritefile = 0;
#line 25934 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap3_start_Lam (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25941 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap3_start, mcrotaGap3_start_Lam);
  rot_transpose(mcrotaGap3_start, mctr1);
  rot_mul(mcrotaGap3_start_Lam, mctr1, mcrotrGap3_start_Lam);
  mctc1 = coords_set(
#line 421 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 421 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 421 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 25952 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap3_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap3_start_Lam = coords_add(mcposaGap3_start, mctc2);
  mctc1 = coords_sub(mcposaGap3_start, mcposaGap3_start_Lam);
  mcposrGap3_start_Lam = rot_apply(mcrotaGap3_start_Lam, mctc1);
  mcDEBUG_COMPONENT("Gap3_start_Lam", mcposaGap3_start_Lam, mcrotaGap3_start_Lam)
  mccomp_posa[41] = mcposaGap3_start_Lam;
  mccomp_posr[41] = mcposrGap3_start_Lam;
  mcNCounter[41]  = mcPCounter[41] = mcP2Counter[41] = 0;
  mcAbsorbProp[41]= 0;
    /* Component CGS1_end. */
  /* Setting parameters for component CGS1_end. */
  SIG_MESSAGE("CGS1_end (Init:SetPar)");
#line 424 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS1_end_nx = 100;
#line 424 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS1_end_ny = 100;
#line 424 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("PSD_monitor_6,9433m_just_before_Ch1") strncpy(mccCGS1_end_filename, "PSD_monitor_6,9433m_just_before_Ch1" ? "PSD_monitor_6,9433m_just_before_Ch1" : "", 16384); else mccCGS1_end_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS1_end_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS1_end_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS1_end_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS1_end_ymax = 0.05;
#line 425 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS1_end_xwidth = 0.10;
#line 425 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS1_end_yheight = 0.12;
#line 425 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS1_end_restore_neutron = 1;
#line 25986 "./SNS_BASIS.c"

  SIG_MESSAGE("CGS1_end (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25993 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap3_start_Lam, mcrotaCGS1_end);
  rot_transpose(mcrotaGap3_start_Lam, mctr1);
  rot_mul(mcrotaCGS1_end, mctr1, mcrotrCGS1_end);
  mctc1 = coords_set(
#line 426 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 426 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 426 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 26004 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap3_start_Lam, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCGS1_end = coords_add(mcposaGap3_start_Lam, mctc2);
  mctc1 = coords_sub(mcposaGap3_start_Lam, mcposaCGS1_end);
  mcposrCGS1_end = rot_apply(mcrotaCGS1_end, mctc1);
  mcDEBUG_COMPONENT("CGS1_end", mcposaCGS1_end, mcrotaCGS1_end)
  mccomp_posa[42] = mcposaCGS1_end;
  mccomp_posr[42] = mcposrCGS1_end;
  mcNCounter[42]  = mcPCounter[42] = mcP2Counter[42] = 0;
  mcAbsorbProp[42]= 0;
    /* Component before_Chopper1_ToF. */
  /* Setting parameters for component before_Chopper1_ToF. */
  SIG_MESSAGE("before_Chopper1_ToF (Init:SetPar)");
#line 429 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("TOF_monitor_6,9434m_just_before_Ch1") strncpy(mccbefore_Chopper1_ToF_filename, "TOF_monitor_6,9434m_just_before_Ch1" ? "TOF_monitor_6,9434m_just_before_Ch1" : "", 16384); else mccbefore_Chopper1_ToF_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_ymax = 0.05;
#line 429 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_xwidth = 0.4;
#line 430 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_yheight = 0.4;
#line 430 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_tmin = 0;
#line 430 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_tmax = 155500;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_dt = 1.0;
#line 429 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_nowritefile = 0;
#line 26042 "./SNS_BASIS.c"

  SIG_MESSAGE("before_Chopper1_ToF (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26049 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCGS1_end, mcrotabefore_Chopper1_ToF);
  rot_transpose(mcrotaCGS1_end, mctr1);
  rot_mul(mcrotabefore_Chopper1_ToF, mctr1, mcrotrbefore_Chopper1_ToF);
  mctc1 = coords_set(
#line 431 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 431 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 431 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 26060 "./SNS_BASIS.c"
  rot_transpose(mcrotaCGS1_end, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposabefore_Chopper1_ToF = coords_add(mcposaCGS1_end, mctc2);
  mctc1 = coords_sub(mcposaCGS1_end, mcposabefore_Chopper1_ToF);
  mcposrbefore_Chopper1_ToF = rot_apply(mcrotabefore_Chopper1_ToF, mctc1);
  mcDEBUG_COMPONENT("before_Chopper1_ToF", mcposabefore_Chopper1_ToF, mcrotabefore_Chopper1_ToF)
  mccomp_posa[43] = mcposabefore_Chopper1_ToF;
  mccomp_posr[43] = mcposrbefore_Chopper1_ToF;
  mcNCounter[43]  = mcPCounter[43] = mcP2Counter[43] = 0;
  mcAbsorbProp[43]= 0;
    /* Component before_Chopper1_ToF_Z. */
  /* Setting parameters for component before_Chopper1_ToF_Z. */
  SIG_MESSAGE("before_Chopper1_ToF_Z (Init:SetPar)");
#line 434 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("TOF_monitor_6,9434m_just_before_Ch1_Z") strncpy(mccbefore_Chopper1_ToF_Z_filename, "TOF_monitor_6,9434m_just_before_Ch1_Z" ? "TOF_monitor_6,9434m_just_before_Ch1_Z" : "", 16384); else mccbefore_Chopper1_ToF_Z_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_Z_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_Z_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_Z_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_Z_ymax = 0.05;
#line 434 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_Z_xwidth = 0.4;
#line 435 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_Z_yheight = 0.4;
#line 435 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_Z_tmin = 1.05e4;
#line 435 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_Z_tmax = 1.2e4;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_Z_dt = 1.0;
#line 434 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_Z_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper1_ToF_Z_nowritefile = 0;
#line 26098 "./SNS_BASIS.c"

  SIG_MESSAGE("before_Chopper1_ToF_Z (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26105 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotabefore_Chopper1_ToF, mcrotabefore_Chopper1_ToF_Z);
  rot_transpose(mcrotabefore_Chopper1_ToF, mctr1);
  rot_mul(mcrotabefore_Chopper1_ToF_Z, mctr1, mcrotrbefore_Chopper1_ToF_Z);
  mctc1 = coords_set(
#line 436 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 436 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 436 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 26116 "./SNS_BASIS.c"
  rot_transpose(mcrotabefore_Chopper1_ToF, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposabefore_Chopper1_ToF_Z = coords_add(mcposabefore_Chopper1_ToF, mctc2);
  mctc1 = coords_sub(mcposabefore_Chopper1_ToF, mcposabefore_Chopper1_ToF_Z);
  mcposrbefore_Chopper1_ToF_Z = rot_apply(mcrotabefore_Chopper1_ToF_Z, mctc1);
  mcDEBUG_COMPONENT("before_Chopper1_ToF_Z", mcposabefore_Chopper1_ToF_Z, mcrotabefore_Chopper1_ToF_Z)
  mccomp_posa[44] = mcposabefore_Chopper1_ToF_Z;
  mccomp_posr[44] = mcposrbefore_Chopper1_ToF_Z;
  mcNCounter[44]  = mcPCounter[44] = mcP2Counter[44] = 0;
  mcAbsorbProp[44]= 0;
    /* Component Chopper1. */
  /* Setting parameters for component Chopper1. */
  SIG_MESSAGE("Chopper1 (Init:SetPar)");
#line 441 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_theta_0 = mcipch1_open;
#line 441 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_radius = 0.254;
#line 441 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_yheight = 0.128;
#line 441 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_nu = Omega1;
#line 441 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_nslit = 1;
#line 59 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_jitter = 0;
#line 441 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_delay = 252.78 * 6.98319 * mcipLam * 1e-6;
#line 59 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_isfirst = 0;
#line 59 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_n_pulse = 1;
#line 59 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_abs_out = 1;
#line 59 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_phase = 0;
#line 59 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_xwidth = 0;
#line 59 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_verbose = 0;
#line 26156 "./SNS_BASIS.c"

  SIG_MESSAGE("Chopper1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 443 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 443 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.04 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 443 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 26166 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap3_start, mcrotaChopper1);
  rot_transpose(mcrotabefore_Chopper1_ToF_Z, mctr1);
  rot_mul(mcrotaChopper1, mctr1, mcrotrChopper1);
  mctc1 = coords_set(
#line 442 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 442 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 442 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.04);
#line 26177 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap3_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaChopper1 = coords_add(mcposaGap3_start, mctc2);
  mctc1 = coords_sub(mcposabefore_Chopper1_ToF_Z, mcposaChopper1);
  mcposrChopper1 = rot_apply(mcrotaChopper1, mctc1);
  mcDEBUG_COMPONENT("Chopper1", mcposaChopper1, mcrotaChopper1)
  mccomp_posa[45] = mcposaChopper1;
  mccomp_posr[45] = mcposrChopper1;
  mcNCounter[45]  = mcPCounter[45] = mcP2Counter[45] = 0;
  mcAbsorbProp[45]= 0;
    /* Component Chopper1_ToF. */
  /* Setting parameters for component Chopper1_ToF. */
  SIG_MESSAGE("Chopper1_ToF (Init:SetPar)");
#line 447 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("TOF_monitor_6,9832m_just_after_Ch1") strncpy(mccChopper1_ToF_filename, "TOF_monitor_6,9832m_just_after_Ch1" ? "TOF_monitor_6,9832m_just_after_Ch1" : "", 16384); else mccChopper1_ToF_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_ymax = 0.05;
#line 447 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_xwidth = 0.4;
#line 448 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_yheight = 0.4;
#line 448 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_tmin = 0;
#line 448 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_tmax = 155500;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_dt = 1.0;
#line 447 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_nowritefile = 0;
#line 26215 "./SNS_BASIS.c"

  SIG_MESSAGE("Chopper1_ToF (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26222 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaChopper1, mcrotaChopper1_ToF);
  rot_transpose(mcrotaChopper1, mctr1);
  rot_mul(mcrotaChopper1_ToF, mctr1, mcrotrChopper1_ToF);
  mctc1 = coords_set(
#line 449 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 449 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 449 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 26233 "./SNS_BASIS.c"
  rot_transpose(mcrotaChopper1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaChopper1_ToF = coords_add(mcposaChopper1, mctc2);
  mctc1 = coords_sub(mcposaChopper1, mcposaChopper1_ToF);
  mcposrChopper1_ToF = rot_apply(mcrotaChopper1_ToF, mctc1);
  mcDEBUG_COMPONENT("Chopper1_ToF", mcposaChopper1_ToF, mcrotaChopper1_ToF)
  mccomp_posa[46] = mcposaChopper1_ToF;
  mccomp_posr[46] = mcposrChopper1_ToF;
  mcNCounter[46]  = mcPCounter[46] = mcP2Counter[46] = 0;
  mcAbsorbProp[46]= 0;
    /* Component Chopper1_ToF_Z. */
  /* Setting parameters for component Chopper1_ToF_Z. */
  SIG_MESSAGE("Chopper1_ToF_Z (Init:SetPar)");
#line 452 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("TOF_monitor_6,9832m_just_after_Ch1_Z") strncpy(mccChopper1_ToF_Z_filename, "TOF_monitor_6,9832m_just_after_Ch1_Z" ? "TOF_monitor_6,9832m_just_after_Ch1_Z" : "", 16384); else mccChopper1_ToF_Z_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_Z_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_Z_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_Z_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_Z_ymax = 0.05;
#line 452 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_Z_xwidth = 0.4;
#line 453 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_Z_yheight = 0.4;
#line 453 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_Z_tmin = 1.05e4;
#line 453 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_Z_tmax = 1.2e4;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_Z_dt = 1.0;
#line 452 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_Z_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper1_ToF_Z_nowritefile = 0;
#line 26271 "./SNS_BASIS.c"

  SIG_MESSAGE("Chopper1_ToF_Z (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26278 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaChopper1, mcrotaChopper1_ToF_Z);
  rot_transpose(mcrotaChopper1_ToF, mctr1);
  rot_mul(mcrotaChopper1_ToF_Z, mctr1, mcrotrChopper1_ToF_Z);
  mctc1 = coords_set(
#line 454 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 454 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 454 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2e-4);
#line 26289 "./SNS_BASIS.c"
  rot_transpose(mcrotaChopper1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaChopper1_ToF_Z = coords_add(mcposaChopper1, mctc2);
  mctc1 = coords_sub(mcposaChopper1_ToF, mcposaChopper1_ToF_Z);
  mcposrChopper1_ToF_Z = rot_apply(mcrotaChopper1_ToF_Z, mctc1);
  mcDEBUG_COMPONENT("Chopper1_ToF_Z", mcposaChopper1_ToF_Z, mcrotaChopper1_ToF_Z)
  mccomp_posa[47] = mcposaChopper1_ToF_Z;
  mccomp_posr[47] = mcposrChopper1_ToF_Z;
  mcNCounter[47]  = mcPCounter[47] = mcP2Counter[47] = 0;
  mcAbsorbProp[47]= 0;
    /* Component Gap3_end_Lam. */
  /* Setting parameters for component Gap3_end_Lam. */
  SIG_MESSAGE("Gap3_end_Lam (Init:SetPar)");
#line 461 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("Lam_monitor_7.0221m_just_after_Ch1") strncpy(mccGap3_end_Lam_filename, "Lam_monitor_7.0221m_just_after_Ch1" ? "Lam_monitor_7.0221m_just_after_Ch1" : "", 16384); else mccGap3_end_Lam_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_end_Lam_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_end_Lam_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_end_Lam_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_end_Lam_ymax = 0.05;
#line 461 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_end_Lam_xwidth = 0.4;
#line 462 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_end_Lam_yheight = 0.4;
#line 462 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_end_Lam_Lmin = 2.0;
#line 462 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_end_Lam_Lmax = 10.0;
#line 461 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_end_Lam_restore_neutron = 1;
#line 51 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_end_Lam_nowritefile = 0;
#line 26325 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap3_end_Lam (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 464 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 464 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.079 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 464 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 26335 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap3_start, mcrotaGap3_end_Lam);
  rot_transpose(mcrotaChopper1_ToF_Z, mctr1);
  rot_mul(mcrotaGap3_end_Lam, mctr1, mcrotrGap3_end_Lam);
  mctc1 = coords_set(
#line 463 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 463 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 463 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.079);
#line 26346 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap3_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap3_end_Lam = coords_add(mcposaGap3_start, mctc2);
  mctc1 = coords_sub(mcposaChopper1_ToF_Z, mcposaGap3_end_Lam);
  mcposrGap3_end_Lam = rot_apply(mcrotaGap3_end_Lam, mctc1);
  mcDEBUG_COMPONENT("Gap3_end_Lam", mcposaGap3_end_Lam, mcrotaGap3_end_Lam)
  mccomp_posa[48] = mcposaGap3_end_Lam;
  mccomp_posr[48] = mcposrGap3_end_Lam;
  mcNCounter[48]  = mcPCounter[48] = mcP2Counter[48] = 0;
  mcAbsorbProp[48]= 0;
    /* Component Gap3_end_PSD. */
  /* Setting parameters for component Gap3_end_PSD. */
  SIG_MESSAGE("Gap3_end_PSD (Init:SetPar)");
#line 468 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_end_PSD_nx = 100;
#line 468 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_end_PSD_ny = 100;
#line 468 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("PSD_monitor_7.0223m_just_after_Ch1") strncpy(mccGap3_end_PSD_filename, "PSD_monitor_7.0223m_just_after_Ch1" ? "PSD_monitor_7.0223m_just_after_Ch1" : "", 16384); else mccGap3_end_PSD_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_end_PSD_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_end_PSD_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_end_PSD_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_end_PSD_ymax = 0.05;
#line 469 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_end_PSD_xwidth = 0.10;
#line 469 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_end_PSD_yheight = 0.12;
#line 469 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap3_end_PSD_restore_neutron = 1;
#line 26380 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap3_end_PSD (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 471 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 471 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.079 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 471 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 26390 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap3_start, mcrotaGap3_end_PSD);
  rot_transpose(mcrotaGap3_end_Lam, mctr1);
  rot_mul(mcrotaGap3_end_PSD, mctr1, mcrotrGap3_end_PSD);
  mctc1 = coords_set(
#line 470 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 470 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 470 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.079 + 2e-4);
#line 26401 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap3_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap3_end_PSD = coords_add(mcposaGap3_start, mctc2);
  mctc1 = coords_sub(mcposaGap3_end_Lam, mcposaGap3_end_PSD);
  mcposrGap3_end_PSD = rot_apply(mcrotaGap3_end_PSD, mctc1);
  mcDEBUG_COMPONENT("Gap3_end_PSD", mcposaGap3_end_PSD, mcrotaGap3_end_PSD)
  mccomp_posa[49] = mcposaGap3_end_PSD;
  mccomp_posr[49] = mcposrGap3_end_PSD;
  mcNCounter[49]  = mcPCounter[49] = mcP2Counter[49] = 0;
  mcAbsorbProp[49]= 0;
    /* Component Gap3_end. */
  /* Setting parameters for component Gap3_end. */
  SIG_MESSAGE("Gap3_end (Init:SetPar)");

  SIG_MESSAGE("Gap3_end (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 476 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 476 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.08 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 476 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 26424 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap3_start, mcrotaGap3_end);
  rot_transpose(mcrotaGap3_end_PSD, mctr1);
  rot_mul(mcrotaGap3_end, mctr1, mcrotrGap3_end);
  mctc1 = coords_set(
#line 475 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 475 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 475 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.08);
#line 26435 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap3_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap3_end = coords_add(mcposaGap3_start, mctc2);
  mctc1 = coords_sub(mcposaGap3_end_PSD, mcposaGap3_end);
  mcposrGap3_end = rot_apply(mcrotaGap3_end, mctc1);
  mcDEBUG_COMPONENT("Gap3_end", mcposaGap3_end, mcrotaGap3_end)
  mccomp_posa[50] = mcposaGap3_end;
  mccomp_posr[50] = mcposrGap3_end;
  mcNCounter[50]  = mcPCounter[50] = mcP2Counter[50] = 0;
  mcAbsorbProp[50]= 0;
    /* Component Curved_Guide_Section_II. */
  /* Setting parameters for component Curved_Guide_Section_II. */
  SIG_MESSAGE("Curved_Guide_Section_II (Init:SetPar)");
#line 481 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_w1 = 0.10;
#line 481 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_h2 = 0;
#line 481 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_l = 0.275;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_d = 0.0005;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_mleft = 1.0;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_mright = 2.5;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_mtop = 1.5;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_II_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_II_reflect[0]='\0';
#line 26517 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_II (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26524 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap3_end, mcrotaCurved_Guide_Section_II);
  rot_transpose(mcrotaGap3_end, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_II, mctr1, mcrotrCurved_Guide_Section_II);
  mctc1 = coords_set(
#line 483 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 483 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 483 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0);
#line 26535 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap3_end, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_II = coords_add(mcposaGap3_end, mctc2);
  mctc1 = coords_sub(mcposaGap3_end, mcposaCurved_Guide_Section_II);
  mcposrCurved_Guide_Section_II = rot_apply(mcrotaCurved_Guide_Section_II, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_II", mcposaCurved_Guide_Section_II, mcrotaCurved_Guide_Section_II)
  mccomp_posa[51] = mcposaCurved_Guide_Section_II;
  mccomp_posr[51] = mcposrCurved_Guide_Section_II;
  mcNCounter[51]  = mcPCounter[51] = mcP2Counter[51] = 0;
  mcAbsorbProp[51]= 0;
    /* Component Curved_Guide_Section_II_52. */
  /* Setting parameters for component Curved_Guide_Section_II_52. */
  SIG_MESSAGE("Curved_Guide_Section_II_52 (Init:SetPar)");
#line 481 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_w1 = 0.10;
#line 481 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_h2 = 0;
#line 481 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_l = 0.275;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_d = 0.0005;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_mleft = 1.0;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_mright = 2.5;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_mtop = 1.5;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_52_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_II_52_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_II_52_reflect[0]='\0';
#line 26617 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_II_52 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 487 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 487 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.275 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 487 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 26627 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_II, mcrotaCurved_Guide_Section_II_52);
  rot_transpose(mcrotaCurved_Guide_Section_II, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_II_52, mctr1, mcrotrCurved_Guide_Section_II_52);
  mctc1 = coords_set(
#line 486 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 486 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 486 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.275 + 1e-4);
#line 26638 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_II, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_II_52 = coords_add(mcposaCurved_Guide_Section_II, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_II, mcposaCurved_Guide_Section_II_52);
  mcposrCurved_Guide_Section_II_52 = rot_apply(mcrotaCurved_Guide_Section_II_52, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_II_52", mcposaCurved_Guide_Section_II_52, mcrotaCurved_Guide_Section_II_52)
  mccomp_posa[52] = mcposaCurved_Guide_Section_II_52;
  mccomp_posr[52] = mcposrCurved_Guide_Section_II_52;
  mcNCounter[52]  = mcPCounter[52] = mcP2Counter[52] = 0;
  mcAbsorbProp[52]= 0;
    /* Component Curved_Guide_Section_II_53. */
  /* Setting parameters for component Curved_Guide_Section_II_53. */
  SIG_MESSAGE("Curved_Guide_Section_II_53 (Init:SetPar)");
#line 481 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_w1 = 0.10;
#line 481 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_h2 = 0;
#line 481 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_l = 0.275;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_d = 0.0005;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_mleft = 1.0;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_mright = 2.5;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_mtop = 1.5;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_53_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_II_53_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_II_53_reflect[0]='\0';
#line 26720 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_II_53 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 491 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 491 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.275 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 491 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 26730 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_II_52, mcrotaCurved_Guide_Section_II_53);
  rot_transpose(mcrotaCurved_Guide_Section_II_52, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_II_53, mctr1, mcrotrCurved_Guide_Section_II_53);
  mctc1 = coords_set(
#line 490 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 490 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 490 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.275 + 1e-4);
#line 26741 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_II_52, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_II_53 = coords_add(mcposaCurved_Guide_Section_II_52, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_II_52, mcposaCurved_Guide_Section_II_53);
  mcposrCurved_Guide_Section_II_53 = rot_apply(mcrotaCurved_Guide_Section_II_53, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_II_53", mcposaCurved_Guide_Section_II_53, mcrotaCurved_Guide_Section_II_53)
  mccomp_posa[53] = mcposaCurved_Guide_Section_II_53;
  mccomp_posr[53] = mcposrCurved_Guide_Section_II_53;
  mcNCounter[53]  = mcPCounter[53] = mcP2Counter[53] = 0;
  mcAbsorbProp[53]= 0;
    /* Component Curved_Guide_Section_II_54. */
  /* Setting parameters for component Curved_Guide_Section_II_54. */
  SIG_MESSAGE("Curved_Guide_Section_II_54 (Init:SetPar)");
#line 481 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_w1 = 0.10;
#line 481 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_h2 = 0;
#line 481 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_l = 0.275;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_d = 0.0005;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_mleft = 1.0;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_mright = 2.5;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_mtop = 1.5;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_54_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_II_54_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_II_54_reflect[0]='\0';
#line 26823 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_II_54 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 495 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 495 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.275 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 495 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 26833 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_II_53, mcrotaCurved_Guide_Section_II_54);
  rot_transpose(mcrotaCurved_Guide_Section_II_53, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_II_54, mctr1, mcrotrCurved_Guide_Section_II_54);
  mctc1 = coords_set(
#line 494 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 494 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 494 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.275 + 1e-4);
#line 26844 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_II_53, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_II_54 = coords_add(mcposaCurved_Guide_Section_II_53, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_II_53, mcposaCurved_Guide_Section_II_54);
  mcposrCurved_Guide_Section_II_54 = rot_apply(mcrotaCurved_Guide_Section_II_54, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_II_54", mcposaCurved_Guide_Section_II_54, mcrotaCurved_Guide_Section_II_54)
  mccomp_posa[54] = mcposaCurved_Guide_Section_II_54;
  mccomp_posr[54] = mcposrCurved_Guide_Section_II_54;
  mcNCounter[54]  = mcPCounter[54] = mcP2Counter[54] = 0;
  mcAbsorbProp[54]= 0;
    /* Component Curved_Guide_Section_II_55. */
  /* Setting parameters for component Curved_Guide_Section_II_55. */
  SIG_MESSAGE("Curved_Guide_Section_II_55 (Init:SetPar)");
#line 481 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_w1 = 0.10;
#line 481 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_h2 = 0;
#line 481 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_l = 0.275;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_d = 0.0005;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_mleft = 1.0;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_mright = 2.5;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_mtop = 1.5;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_55_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_II_55_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_II_55_reflect[0]='\0';
#line 26926 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_II_55 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 499 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 499 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.275 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 499 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 26936 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_II_54, mcrotaCurved_Guide_Section_II_55);
  rot_transpose(mcrotaCurved_Guide_Section_II_54, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_II_55, mctr1, mcrotrCurved_Guide_Section_II_55);
  mctc1 = coords_set(
#line 498 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 498 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 498 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.275 + 1e-4);
#line 26947 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_II_54, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_II_55 = coords_add(mcposaCurved_Guide_Section_II_54, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_II_54, mcposaCurved_Guide_Section_II_55);
  mcposrCurved_Guide_Section_II_55 = rot_apply(mcrotaCurved_Guide_Section_II_55, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_II_55", mcposaCurved_Guide_Section_II_55, mcrotaCurved_Guide_Section_II_55)
  mccomp_posa[55] = mcposaCurved_Guide_Section_II_55;
  mccomp_posr[55] = mcposrCurved_Guide_Section_II_55;
  mcNCounter[55]  = mcPCounter[55] = mcP2Counter[55] = 0;
  mcAbsorbProp[55]= 0;
    /* Component Curved_Guide_Section_II_56. */
  /* Setting parameters for component Curved_Guide_Section_II_56. */
  SIG_MESSAGE("Curved_Guide_Section_II_56 (Init:SetPar)");
#line 481 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_w1 = 0.10;
#line 481 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_h2 = 0;
#line 481 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_l = 0.275;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_d = 0.0005;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_mleft = 1.0;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_mright = 2.5;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_mtop = 1.5;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_56_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_II_56_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_II_56_reflect[0]='\0';
#line 27029 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_II_56 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 503 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 503 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.275 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 503 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 27039 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_II_55, mcrotaCurved_Guide_Section_II_56);
  rot_transpose(mcrotaCurved_Guide_Section_II_55, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_II_56, mctr1, mcrotrCurved_Guide_Section_II_56);
  mctc1 = coords_set(
#line 502 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 502 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 502 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.275 + 1e-4);
#line 27050 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_II_55, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_II_56 = coords_add(mcposaCurved_Guide_Section_II_55, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_II_55, mcposaCurved_Guide_Section_II_56);
  mcposrCurved_Guide_Section_II_56 = rot_apply(mcrotaCurved_Guide_Section_II_56, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_II_56", mcposaCurved_Guide_Section_II_56, mcrotaCurved_Guide_Section_II_56)
  mccomp_posa[56] = mcposaCurved_Guide_Section_II_56;
  mccomp_posr[56] = mcposrCurved_Guide_Section_II_56;
  mcNCounter[56]  = mcPCounter[56] = mcP2Counter[56] = 0;
  mcAbsorbProp[56]= 0;
    /* Component Curved_Guide_Section_II_57. */
  /* Setting parameters for component Curved_Guide_Section_II_57. */
  SIG_MESSAGE("Curved_Guide_Section_II_57 (Init:SetPar)");
#line 481 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_w1 = 0.10;
#line 481 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_h2 = 0;
#line 481 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_l = 0.275;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_d = 0.0005;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_mleft = 1.0;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_mright = 2.5;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_mtop = 1.5;
#line 482 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_57_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_II_57_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_II_57_reflect[0]='\0';
#line 27132 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_II_57 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 507 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 507 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.275 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 507 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 27142 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_II_56, mcrotaCurved_Guide_Section_II_57);
  rot_transpose(mcrotaCurved_Guide_Section_II_56, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_II_57, mctr1, mcrotrCurved_Guide_Section_II_57);
  mctc1 = coords_set(
#line 506 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 506 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 506 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.275 + 1e-4);
#line 27153 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_II_56, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_II_57 = coords_add(mcposaCurved_Guide_Section_II_56, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_II_56, mcposaCurved_Guide_Section_II_57);
  mcposrCurved_Guide_Section_II_57 = rot_apply(mcrotaCurved_Guide_Section_II_57, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_II_57", mcposaCurved_Guide_Section_II_57, mcrotaCurved_Guide_Section_II_57)
  mccomp_posa[57] = mcposaCurved_Guide_Section_II_57;
  mccomp_posr[57] = mcposrCurved_Guide_Section_II_57;
  mcNCounter[57]  = mcPCounter[57] = mcP2Counter[57] = 0;
  mcAbsorbProp[57]= 0;
    /* Component Curved_Guide_Section_II_last. */
  /* Setting parameters for component Curved_Guide_Section_II_last. */
  SIG_MESSAGE("Curved_Guide_Section_II_last (Init:SetPar)");
#line 509 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_w1 = 0.10;
#line 509 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_h2 = 0;
#line 509 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_l = 0.275;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_d = 0.0005;
#line 510 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_mleft = 1.0;
#line 510 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_mright = 2.5;
#line 510 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_mtop = 1.5;
#line 510 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_II_last_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_II_last_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_II_last_reflect[0]='\0';
#line 27235 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_II_last (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 512 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 512 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.275 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 512 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 27245 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_II_57, mcrotaCurved_Guide_Section_II_last);
  rot_transpose(mcrotaCurved_Guide_Section_II_57, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_II_last, mctr1, mcrotrCurved_Guide_Section_II_last);
  mctc1 = coords_set(
#line 511 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 511 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 511 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.275 + 1e-4);
#line 27256 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_II_57, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_II_last = coords_add(mcposaCurved_Guide_Section_II_57, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_II_57, mcposaCurved_Guide_Section_II_last);
  mcposrCurved_Guide_Section_II_last = rot_apply(mcrotaCurved_Guide_Section_II_last, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_II_last", mcposaCurved_Guide_Section_II_last, mcrotaCurved_Guide_Section_II_last)
  mccomp_posa[58] = mcposaCurved_Guide_Section_II_last;
  mccomp_posr[58] = mcposrCurved_Guide_Section_II_last;
  mcNCounter[58]  = mcPCounter[58] = mcP2Counter[58] = 0;
  mcAbsorbProp[58]= 0;
    /* Component Gap4_start. */
  /* Setting parameters for component Gap4_start. */
  SIG_MESSAGE("Gap4_start (Init:SetPar)");

  SIG_MESSAGE("Gap4_start (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27276 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_II_last, mcrotaGap4_start);
  rot_transpose(mcrotaCurved_Guide_Section_II_last, mctr1);
  rot_mul(mcrotaGap4_start, mctr1, mcrotrGap4_start);
  mctc1 = coords_set(
#line 518 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 518 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 518 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.275);
#line 27287 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_II_last, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap4_start = coords_add(mcposaCurved_Guide_Section_II_last, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_II_last, mcposaGap4_start);
  mcposrGap4_start = rot_apply(mcrotaGap4_start, mctc1);
  mcDEBUG_COMPONENT("Gap4_start", mcposaGap4_start, mcrotaGap4_start)
  mccomp_posa[59] = mcposaGap4_start;
  mccomp_posr[59] = mcposrGap4_start;
  mcNCounter[59]  = mcPCounter[59] = mcP2Counter[59] = 0;
  mcAbsorbProp[59]= 0;
    /* Component Gap4_start_Lam. */
  /* Setting parameters for component Gap4_start_Lam. */
  SIG_MESSAGE("Gap4_start_Lam (Init:SetPar)");
#line 521 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("Lam_monitor_9,2239m_just_before_Ch2") strncpy(mccGap4_start_Lam_filename, "Lam_monitor_9,2239m_just_before_Ch2" ? "Lam_monitor_9,2239m_just_before_Ch2" : "", 16384); else mccGap4_start_Lam_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_start_Lam_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_start_Lam_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_start_Lam_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_start_Lam_ymax = 0.05;
#line 521 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_start_Lam_xwidth = 0.4;
#line 522 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_start_Lam_yheight = 0.4;
#line 522 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_start_Lam_Lmin = 2.0;
#line 522 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_start_Lam_Lmax = 10.0;
#line 521 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_start_Lam_restore_neutron = 1;
#line 51 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_start_Lam_nowritefile = 0;
#line 27323 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap4_start_Lam (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27330 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap4_start, mcrotaGap4_start_Lam);
  rot_transpose(mcrotaGap4_start, mctr1);
  rot_mul(mcrotaGap4_start_Lam, mctr1, mcrotrGap4_start_Lam);
  mctc1 = coords_set(
#line 523 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 523 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 523 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 27341 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap4_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap4_start_Lam = coords_add(mcposaGap4_start, mctc2);
  mctc1 = coords_sub(mcposaGap4_start, mcposaGap4_start_Lam);
  mcposrGap4_start_Lam = rot_apply(mcrotaGap4_start_Lam, mctc1);
  mcDEBUG_COMPONENT("Gap4_start_Lam", mcposaGap4_start_Lam, mcrotaGap4_start_Lam)
  mccomp_posa[60] = mcposaGap4_start_Lam;
  mccomp_posr[60] = mcposrGap4_start_Lam;
  mcNCounter[60]  = mcPCounter[60] = mcP2Counter[60] = 0;
  mcAbsorbProp[60]= 0;
    /* Component Gap4_start_PSD. */
  /* Setting parameters for component Gap4_start_PSD. */
  SIG_MESSAGE("Gap4_start_PSD (Init:SetPar)");
#line 526 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_start_PSD_nx = 100;
#line 526 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_start_PSD_ny = 100;
#line 526 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("PSD_monitor_9,2241m_just_before_Ch2") strncpy(mccGap4_start_PSD_filename, "PSD_monitor_9,2241m_just_before_Ch2" ? "PSD_monitor_9,2241m_just_before_Ch2" : "", 16384); else mccGap4_start_PSD_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_start_PSD_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_start_PSD_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_start_PSD_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_start_PSD_ymax = 0.05;
#line 527 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_start_PSD_xwidth = 0.10;
#line 527 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_start_PSD_yheight = 0.12;
#line 527 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_start_PSD_restore_neutron = 1;
#line 27375 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap4_start_PSD (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27382 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap4_start_Lam, mcrotaGap4_start_PSD);
  rot_transpose(mcrotaGap4_start_Lam, mctr1);
  rot_mul(mcrotaGap4_start_PSD, mctr1, mcrotrGap4_start_PSD);
  mctc1 = coords_set(
#line 528 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 528 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 528 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2e-4);
#line 27393 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap4_start_Lam, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap4_start_PSD = coords_add(mcposaGap4_start_Lam, mctc2);
  mctc1 = coords_sub(mcposaGap4_start_Lam, mcposaGap4_start_PSD);
  mcposrGap4_start_PSD = rot_apply(mcrotaGap4_start_PSD, mctc1);
  mcDEBUG_COMPONENT("Gap4_start_PSD", mcposaGap4_start_PSD, mcrotaGap4_start_PSD)
  mccomp_posa[61] = mcposaGap4_start_PSD;
  mccomp_posr[61] = mcposrGap4_start_PSD;
  mcNCounter[61]  = mcPCounter[61] = mcP2Counter[61] = 0;
  mcAbsorbProp[61]= 0;
    /* Component before_Chopper2_ToF. */
  /* Setting parameters for component before_Chopper2_ToF. */
  SIG_MESSAGE("before_Chopper2_ToF (Init:SetPar)");
#line 531 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("TOF_monitor_9,2243m_just_before_Ch2") strncpy(mccbefore_Chopper2_ToF_filename, "TOF_monitor_9,2243m_just_before_Ch2" ? "TOF_monitor_9,2243m_just_before_Ch2" : "", 16384); else mccbefore_Chopper2_ToF_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_ymax = 0.05;
#line 531 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_xwidth = 0.4;
#line 532 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_yheight = 0.4;
#line 532 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_tmin = -2000;
#line 532 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_tmax = 40000;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_dt = 1.0;
#line 531 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_nowritefile = 0;
#line 27431 "./SNS_BASIS.c"

  SIG_MESSAGE("before_Chopper2_ToF (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27438 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap4_start_PSD, mcrotabefore_Chopper2_ToF);
  rot_transpose(mcrotaGap4_start_PSD, mctr1);
  rot_mul(mcrotabefore_Chopper2_ToF, mctr1, mcrotrbefore_Chopper2_ToF);
  mctc1 = coords_set(
#line 533 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 533 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 533 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2e-4);
#line 27449 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap4_start_PSD, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposabefore_Chopper2_ToF = coords_add(mcposaGap4_start_PSD, mctc2);
  mctc1 = coords_sub(mcposaGap4_start_PSD, mcposabefore_Chopper2_ToF);
  mcposrbefore_Chopper2_ToF = rot_apply(mcrotabefore_Chopper2_ToF, mctc1);
  mcDEBUG_COMPONENT("before_Chopper2_ToF", mcposabefore_Chopper2_ToF, mcrotabefore_Chopper2_ToF)
  mccomp_posa[62] = mcposabefore_Chopper2_ToF;
  mccomp_posr[62] = mcposrbefore_Chopper2_ToF;
  mcNCounter[62]  = mcPCounter[62] = mcP2Counter[62] = 0;
  mcAbsorbProp[62]= 0;
    /* Component before_Chopper2_ToF_Z. */
  /* Setting parameters for component before_Chopper2_ToF_Z. */
  SIG_MESSAGE("before_Chopper2_ToF_Z (Init:SetPar)");
#line 536 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("TOF_monitor_9,2243m_just_before_Ch2_Z") strncpy(mccbefore_Chopper2_ToF_Z_filename, "TOF_monitor_9,2243m_just_before_Ch2_Z" ? "TOF_monitor_9,2243m_just_before_Ch2_Z" : "", 16384); else mccbefore_Chopper2_ToF_Z_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_Z_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_Z_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_Z_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_Z_ymax = 0.05;
#line 536 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_Z_xwidth = 0.4;
#line 537 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_Z_yheight = 0.4;
#line 537 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_Z_tmin = 1.4e4;
#line 537 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_Z_tmax = 1.6e4;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_Z_dt = 1.0;
#line 536 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_Z_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccbefore_Chopper2_ToF_Z_nowritefile = 0;
#line 27487 "./SNS_BASIS.c"

  SIG_MESSAGE("before_Chopper2_ToF_Z (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27494 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotabefore_Chopper2_ToF, mcrotabefore_Chopper2_ToF_Z);
  rot_transpose(mcrotabefore_Chopper2_ToF, mctr1);
  rot_mul(mcrotabefore_Chopper2_ToF_Z, mctr1, mcrotrbefore_Chopper2_ToF_Z);
  mctc1 = coords_set(
#line 538 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 538 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 538 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2e-4);
#line 27505 "./SNS_BASIS.c"
  rot_transpose(mcrotabefore_Chopper2_ToF, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposabefore_Chopper2_ToF_Z = coords_add(mcposabefore_Chopper2_ToF, mctc2);
  mctc1 = coords_sub(mcposabefore_Chopper2_ToF, mcposabefore_Chopper2_ToF_Z);
  mcposrbefore_Chopper2_ToF_Z = rot_apply(mcrotabefore_Chopper2_ToF_Z, mctc1);
  mcDEBUG_COMPONENT("before_Chopper2_ToF_Z", mcposabefore_Chopper2_ToF_Z, mcrotabefore_Chopper2_ToF_Z)
  mccomp_posa[63] = mcposabefore_Chopper2_ToF_Z;
  mccomp_posr[63] = mcposrbefore_Chopper2_ToF_Z;
  mcNCounter[63]  = mcPCounter[63] = mcP2Counter[63] = 0;
  mcAbsorbProp[63]= 0;
    /* Component Chopper2. */
  /* Setting parameters for component Chopper2. */
  SIG_MESSAGE("Chopper2 (Init:SetPar)");
#line 543 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_theta_0 = mcipch2_open;
#line 543 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_radius = 0.254;
#line 543 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_yheight = 0.128;
#line 543 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_nu = Omega2;
#line 543 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_nslit = 1;
#line 59 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_jitter = 0;
#line 543 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_delay = 252.78 * 9.26376 * mcipLam * 1e-6;
#line 59 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_isfirst = 0;
#line 59 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_n_pulse = 1;
#line 59 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_abs_out = 1;
#line 59 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_phase = 0;
#line 59 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_xwidth = 0;
#line 59 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_verbose = 0;
#line 27545 "./SNS_BASIS.c"

  SIG_MESSAGE("Chopper2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 545 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 545 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.04 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 545 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 27555 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap4_start, mcrotaChopper2);
  rot_transpose(mcrotabefore_Chopper2_ToF_Z, mctr1);
  rot_mul(mcrotaChopper2, mctr1, mcrotrChopper2);
  mctc1 = coords_set(
#line 544 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 544 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 544 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.04);
#line 27566 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap4_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaChopper2 = coords_add(mcposaGap4_start, mctc2);
  mctc1 = coords_sub(mcposabefore_Chopper2_ToF_Z, mcposaChopper2);
  mcposrChopper2 = rot_apply(mcrotaChopper2, mctc1);
  mcDEBUG_COMPONENT("Chopper2", mcposaChopper2, mcrotaChopper2)
  mccomp_posa[64] = mcposaChopper2;
  mccomp_posr[64] = mcposrChopper2;
  mcNCounter[64]  = mcPCounter[64] = mcP2Counter[64] = 0;
  mcAbsorbProp[64]= 0;
    /* Component Chopper2_ToF. */
  /* Setting parameters for component Chopper2_ToF. */
  SIG_MESSAGE("Chopper2_ToF (Init:SetPar)");
#line 548 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("TOF_monitor_9,2639m_just_after_Ch2") strncpy(mccChopper2_ToF_filename, "TOF_monitor_9,2639m_just_after_Ch2" ? "TOF_monitor_9,2639m_just_after_Ch2" : "", 16384); else mccChopper2_ToF_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_ymax = 0.05;
#line 548 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_xwidth = 0.4;
#line 549 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_yheight = 0.4;
#line 549 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_tmin = -2000;
#line 549 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_tmax = 40000;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_dt = 1.0;
#line 548 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_nowritefile = 0;
#line 27604 "./SNS_BASIS.c"

  SIG_MESSAGE("Chopper2_ToF (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27611 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaChopper2, mcrotaChopper2_ToF);
  rot_transpose(mcrotaChopper2, mctr1);
  rot_mul(mcrotaChopper2_ToF, mctr1, mcrotrChopper2_ToF);
  mctc1 = coords_set(
#line 550 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 550 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 550 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 27622 "./SNS_BASIS.c"
  rot_transpose(mcrotaChopper2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaChopper2_ToF = coords_add(mcposaChopper2, mctc2);
  mctc1 = coords_sub(mcposaChopper2, mcposaChopper2_ToF);
  mcposrChopper2_ToF = rot_apply(mcrotaChopper2_ToF, mctc1);
  mcDEBUG_COMPONENT("Chopper2_ToF", mcposaChopper2_ToF, mcrotaChopper2_ToF)
  mccomp_posa[65] = mcposaChopper2_ToF;
  mccomp_posr[65] = mcposrChopper2_ToF;
  mcNCounter[65]  = mcPCounter[65] = mcP2Counter[65] = 0;
  mcAbsorbProp[65]= 0;
    /* Component Chopper2_ToF_Z. */
  /* Setting parameters for component Chopper2_ToF_Z. */
  SIG_MESSAGE("Chopper2_ToF_Z (Init:SetPar)");
#line 553 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("TOF_monitor_9,2639m_just_after_Ch2_Z") strncpy(mccChopper2_ToF_Z_filename, "TOF_monitor_9,2639m_just_after_Ch2_Z" ? "TOF_monitor_9,2639m_just_after_Ch2_Z" : "", 16384); else mccChopper2_ToF_Z_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_Z_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_Z_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_Z_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_Z_ymax = 0.05;
#line 553 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_Z_xwidth = 0.4;
#line 554 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_Z_yheight = 0.4;
#line 554 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_Z_tmin = 1.4e4;
#line 554 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_Z_tmax = 1.6e4;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_Z_dt = 1.0;
#line 553 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_Z_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper2_ToF_Z_nowritefile = 0;
#line 27660 "./SNS_BASIS.c"

  SIG_MESSAGE("Chopper2_ToF_Z (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27667 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaChopper2, mcrotaChopper2_ToF_Z);
  rot_transpose(mcrotaChopper2_ToF, mctr1);
  rot_mul(mcrotaChopper2_ToF_Z, mctr1, mcrotrChopper2_ToF_Z);
  mctc1 = coords_set(
#line 555 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 555 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 555 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2e-4);
#line 27678 "./SNS_BASIS.c"
  rot_transpose(mcrotaChopper2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaChopper2_ToF_Z = coords_add(mcposaChopper2, mctc2);
  mctc1 = coords_sub(mcposaChopper2_ToF, mcposaChopper2_ToF_Z);
  mcposrChopper2_ToF_Z = rot_apply(mcrotaChopper2_ToF_Z, mctc1);
  mcDEBUG_COMPONENT("Chopper2_ToF_Z", mcposaChopper2_ToF_Z, mcrotaChopper2_ToF_Z)
  mccomp_posa[66] = mcposaChopper2_ToF_Z;
  mccomp_posr[66] = mcposrChopper2_ToF_Z;
  mcNCounter[66]  = mcPCounter[66] = mcP2Counter[66] = 0;
  mcAbsorbProp[66]= 0;
    /* Component Gap4_end_Lam. */
  /* Setting parameters for component Gap4_end_Lam. */
  SIG_MESSAGE("Gap4_end_Lam (Init:SetPar)");
#line 561 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("Lam_monitor_9,2737m_just_after_Ch2") strncpy(mccGap4_end_Lam_filename, "Lam_monitor_9,2737m_just_after_Ch2" ? "Lam_monitor_9,2737m_just_after_Ch2" : "", 16384); else mccGap4_end_Lam_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_end_Lam_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_end_Lam_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_end_Lam_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_end_Lam_ymax = 0.05;
#line 561 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_end_Lam_xwidth = 0.4;
#line 562 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_end_Lam_yheight = 0.4;
#line 562 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_end_Lam_Lmin = 2.0;
#line 562 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_end_Lam_Lmax = 10.0;
#line 561 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_end_Lam_restore_neutron = 1;
#line 51 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_end_Lam_nowritefile = 0;
#line 27714 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap4_end_Lam (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 564 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 564 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.05 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 564 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 27724 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap4_start, mcrotaGap4_end_Lam);
  rot_transpose(mcrotaChopper2_ToF_Z, mctr1);
  rot_mul(mcrotaGap4_end_Lam, mctr1, mcrotrGap4_end_Lam);
  mctc1 = coords_set(
#line 563 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 563 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 563 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.05 -1e-4);
#line 27735 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap4_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap4_end_Lam = coords_add(mcposaGap4_start, mctc2);
  mctc1 = coords_sub(mcposaChopper2_ToF_Z, mcposaGap4_end_Lam);
  mcposrGap4_end_Lam = rot_apply(mcrotaGap4_end_Lam, mctc1);
  mcDEBUG_COMPONENT("Gap4_end_Lam", mcposaGap4_end_Lam, mcrotaGap4_end_Lam)
  mccomp_posa[67] = mcposaGap4_end_Lam;
  mccomp_posr[67] = mcposrGap4_end_Lam;
  mcNCounter[67]  = mcPCounter[67] = mcP2Counter[67] = 0;
  mcAbsorbProp[67]= 0;
    /* Component Gap4_end_PSD. */
  /* Setting parameters for component Gap4_end_PSD. */
  SIG_MESSAGE("Gap4_end_PSD (Init:SetPar)");
#line 568 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_end_PSD_nx = 100;
#line 568 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_end_PSD_ny = 100;
#line 568 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("PSD_monitor_9,2738m_just_after_Ch2") strncpy(mccGap4_end_PSD_filename, "PSD_monitor_9,2738m_just_after_Ch2" ? "PSD_monitor_9,2738m_just_after_Ch2" : "", 16384); else mccGap4_end_PSD_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_end_PSD_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_end_PSD_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_end_PSD_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_end_PSD_ymax = 0.05;
#line 569 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_end_PSD_xwidth = 0.10;
#line 569 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_end_PSD_yheight = 0.12;
#line 569 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap4_end_PSD_restore_neutron = 1;
#line 27769 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap4_end_PSD (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 571 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 571 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.05 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 571 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 27779 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap4_start, mcrotaGap4_end_PSD);
  rot_transpose(mcrotaGap4_end_Lam, mctr1);
  rot_mul(mcrotaGap4_end_PSD, mctr1, mcrotrGap4_end_PSD);
  mctc1 = coords_set(
#line 570 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 570 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 570 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.05);
#line 27790 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap4_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap4_end_PSD = coords_add(mcposaGap4_start, mctc2);
  mctc1 = coords_sub(mcposaGap4_end_Lam, mcposaGap4_end_PSD);
  mcposrGap4_end_PSD = rot_apply(mcrotaGap4_end_PSD, mctc1);
  mcDEBUG_COMPONENT("Gap4_end_PSD", mcposaGap4_end_PSD, mcrotaGap4_end_PSD)
  mccomp_posa[68] = mcposaGap4_end_PSD;
  mccomp_posr[68] = mcposrGap4_end_PSD;
  mcNCounter[68]  = mcPCounter[68] = mcP2Counter[68] = 0;
  mcAbsorbProp[68]= 0;
    /* Component Gap4_end. */
  /* Setting parameters for component Gap4_end. */
  SIG_MESSAGE("Gap4_end (Init:SetPar)");

  SIG_MESSAGE("Gap4_end (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 576 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 576 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 0.05 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 576 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 27813 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap4_start, mcrotaGap4_end);
  rot_transpose(mcrotaGap4_end_PSD, mctr1);
  rot_mul(mcrotaGap4_end, mctr1, mcrotrGap4_end);
  mctc1 = coords_set(
#line 575 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 575 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 575 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.05 + 1e-4);
#line 27824 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap4_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap4_end = coords_add(mcposaGap4_start, mctc2);
  mctc1 = coords_sub(mcposaGap4_end_PSD, mcposaGap4_end);
  mcposrGap4_end = rot_apply(mcrotaGap4_end, mctc1);
  mcDEBUG_COMPONENT("Gap4_end", mcposaGap4_end, mcrotaGap4_end)
  mccomp_posa[69] = mcposaGap4_end;
  mccomp_posr[69] = mcposrGap4_end;
  mcNCounter[69]  = mcPCounter[69] = mcP2Counter[69] = 0;
  mcAbsorbProp[69]= 0;
    /* Component Curved_Guide_Section_III. */
  /* Setting parameters for component Curved_Guide_Section_III. */
  SIG_MESSAGE("Curved_Guide_Section_III (Init:SetPar)");
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_w1 = 0.10;
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_h2 = 0;
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_l = 2.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_d = 0.0005;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_mleft = 1.0;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_mright = 2.5;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_mtop = 1.5;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_III_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_III_reflect[0]='\0';
#line 27906 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_III (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27913 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap4_end, mcrotaCurved_Guide_Section_III);
  rot_transpose(mcrotaGap4_end, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_III, mctr1, mcrotrCurved_Guide_Section_III);
  mctc1 = coords_set(
#line 584 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 584 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 584 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0);
#line 27924 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap4_end, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_III = coords_add(mcposaGap4_end, mctc2);
  mctc1 = coords_sub(mcposaGap4_end, mcposaCurved_Guide_Section_III);
  mcposrCurved_Guide_Section_III = rot_apply(mcrotaCurved_Guide_Section_III, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_III", mcposaCurved_Guide_Section_III, mcrotaCurved_Guide_Section_III)
  mccomp_posa[70] = mcposaCurved_Guide_Section_III;
  mccomp_posr[70] = mcposrCurved_Guide_Section_III;
  mcNCounter[70]  = mcPCounter[70] = mcP2Counter[70] = 0;
  mcAbsorbProp[70]= 0;
    /* Component Curved_Guide_Section_III_71. */
  /* Setting parameters for component Curved_Guide_Section_III_71. */
  SIG_MESSAGE("Curved_Guide_Section_III_71 (Init:SetPar)");
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_w1 = 0.10;
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_h2 = 0;
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_l = 2.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_d = 0.0005;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_mleft = 1.0;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_mright = 2.5;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_mtop = 1.5;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_71_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_III_71_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_III_71_reflect[0]='\0';
#line 28006 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_III_71 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 588 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 588 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 2.0 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 588 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 28016 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_III, mcrotaCurved_Guide_Section_III_71);
  rot_transpose(mcrotaCurved_Guide_Section_III, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_III_71, mctr1, mcrotrCurved_Guide_Section_III_71);
  mctc1 = coords_set(
#line 587 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 587 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 587 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.0 + 1e-4);
#line 28027 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_III, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_III_71 = coords_add(mcposaCurved_Guide_Section_III, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_III, mcposaCurved_Guide_Section_III_71);
  mcposrCurved_Guide_Section_III_71 = rot_apply(mcrotaCurved_Guide_Section_III_71, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_III_71", mcposaCurved_Guide_Section_III_71, mcrotaCurved_Guide_Section_III_71)
  mccomp_posa[71] = mcposaCurved_Guide_Section_III_71;
  mccomp_posr[71] = mcposrCurved_Guide_Section_III_71;
  mcNCounter[71]  = mcPCounter[71] = mcP2Counter[71] = 0;
  mcAbsorbProp[71]= 0;
    /* Component Curved_Guide_Section_III_72. */
  /* Setting parameters for component Curved_Guide_Section_III_72. */
  SIG_MESSAGE("Curved_Guide_Section_III_72 (Init:SetPar)");
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_w1 = 0.10;
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_h2 = 0;
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_l = 2.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_d = 0.0005;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_mleft = 1.0;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_mright = 2.5;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_mtop = 1.5;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_72_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_III_72_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_III_72_reflect[0]='\0';
#line 28109 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_III_72 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 592 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 592 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 2.0 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 592 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 28119 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_III_71, mcrotaCurved_Guide_Section_III_72);
  rot_transpose(mcrotaCurved_Guide_Section_III_71, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_III_72, mctr1, mcrotrCurved_Guide_Section_III_72);
  mctc1 = coords_set(
#line 591 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 591 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 591 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.0 + 1e-4);
#line 28130 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_III_71, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_III_72 = coords_add(mcposaCurved_Guide_Section_III_71, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_III_71, mcposaCurved_Guide_Section_III_72);
  mcposrCurved_Guide_Section_III_72 = rot_apply(mcrotaCurved_Guide_Section_III_72, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_III_72", mcposaCurved_Guide_Section_III_72, mcrotaCurved_Guide_Section_III_72)
  mccomp_posa[72] = mcposaCurved_Guide_Section_III_72;
  mccomp_posr[72] = mcposrCurved_Guide_Section_III_72;
  mcNCounter[72]  = mcPCounter[72] = mcP2Counter[72] = 0;
  mcAbsorbProp[72]= 0;
    /* Component Curved_Guide_Section_III_73. */
  /* Setting parameters for component Curved_Guide_Section_III_73. */
  SIG_MESSAGE("Curved_Guide_Section_III_73 (Init:SetPar)");
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_w1 = 0.10;
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_h2 = 0;
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_l = 2.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_d = 0.0005;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_mleft = 1.0;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_mright = 2.5;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_mtop = 1.5;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_73_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_III_73_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_III_73_reflect[0]='\0';
#line 28212 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_III_73 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 596 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 596 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 2.0 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 596 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 28222 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_III_72, mcrotaCurved_Guide_Section_III_73);
  rot_transpose(mcrotaCurved_Guide_Section_III_72, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_III_73, mctr1, mcrotrCurved_Guide_Section_III_73);
  mctc1 = coords_set(
#line 595 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 595 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 595 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.0 + 1e-4);
#line 28233 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_III_72, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_III_73 = coords_add(mcposaCurved_Guide_Section_III_72, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_III_72, mcposaCurved_Guide_Section_III_73);
  mcposrCurved_Guide_Section_III_73 = rot_apply(mcrotaCurved_Guide_Section_III_73, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_III_73", mcposaCurved_Guide_Section_III_73, mcrotaCurved_Guide_Section_III_73)
  mccomp_posa[73] = mcposaCurved_Guide_Section_III_73;
  mccomp_posr[73] = mcposrCurved_Guide_Section_III_73;
  mcNCounter[73]  = mcPCounter[73] = mcP2Counter[73] = 0;
  mcAbsorbProp[73]= 0;
    /* Component Curved_Guide_Section_III_74. */
  /* Setting parameters for component Curved_Guide_Section_III_74. */
  SIG_MESSAGE("Curved_Guide_Section_III_74 (Init:SetPar)");
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_w1 = 0.10;
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_h2 = 0;
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_l = 2.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_d = 0.0005;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_mleft = 1.0;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_mright = 2.5;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_mtop = 1.5;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_74_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_III_74_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_III_74_reflect[0]='\0';
#line 28315 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_III_74 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 600 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 600 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 2.0 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 600 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 28325 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_III_73, mcrotaCurved_Guide_Section_III_74);
  rot_transpose(mcrotaCurved_Guide_Section_III_73, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_III_74, mctr1, mcrotrCurved_Guide_Section_III_74);
  mctc1 = coords_set(
#line 599 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 599 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 599 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.0 + 1e-4);
#line 28336 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_III_73, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_III_74 = coords_add(mcposaCurved_Guide_Section_III_73, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_III_73, mcposaCurved_Guide_Section_III_74);
  mcposrCurved_Guide_Section_III_74 = rot_apply(mcrotaCurved_Guide_Section_III_74, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_III_74", mcposaCurved_Guide_Section_III_74, mcrotaCurved_Guide_Section_III_74)
  mccomp_posa[74] = mcposaCurved_Guide_Section_III_74;
  mccomp_posr[74] = mcposrCurved_Guide_Section_III_74;
  mcNCounter[74]  = mcPCounter[74] = mcP2Counter[74] = 0;
  mcAbsorbProp[74]= 0;
    /* Component Curved_Guide_Section_III_75. */
  /* Setting parameters for component Curved_Guide_Section_III_75. */
  SIG_MESSAGE("Curved_Guide_Section_III_75 (Init:SetPar)");
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_w1 = 0.10;
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_h2 = 0;
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_l = 2.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_d = 0.0005;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_mleft = 1.0;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_mright = 2.5;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_mtop = 1.5;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_75_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_III_75_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_III_75_reflect[0]='\0';
#line 28418 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_III_75 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 604 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 604 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 2.0 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 604 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 28428 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_III_74, mcrotaCurved_Guide_Section_III_75);
  rot_transpose(mcrotaCurved_Guide_Section_III_74, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_III_75, mctr1, mcrotrCurved_Guide_Section_III_75);
  mctc1 = coords_set(
#line 603 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 603 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 603 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.0 + 1e-4);
#line 28439 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_III_74, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_III_75 = coords_add(mcposaCurved_Guide_Section_III_74, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_III_74, mcposaCurved_Guide_Section_III_75);
  mcposrCurved_Guide_Section_III_75 = rot_apply(mcrotaCurved_Guide_Section_III_75, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_III_75", mcposaCurved_Guide_Section_III_75, mcrotaCurved_Guide_Section_III_75)
  mccomp_posa[75] = mcposaCurved_Guide_Section_III_75;
  mccomp_posr[75] = mcposrCurved_Guide_Section_III_75;
  mcNCounter[75]  = mcPCounter[75] = mcP2Counter[75] = 0;
  mcAbsorbProp[75]= 0;
    /* Component Curved_Guide_Section_III_76. */
  /* Setting parameters for component Curved_Guide_Section_III_76. */
  SIG_MESSAGE("Curved_Guide_Section_III_76 (Init:SetPar)");
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_w1 = 0.10;
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_h2 = 0;
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_l = 2.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_d = 0.0005;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_mleft = 1.0;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_mright = 2.5;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_mtop = 1.5;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_76_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_III_76_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_III_76_reflect[0]='\0';
#line 28521 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_III_76 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 608 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 608 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 2.0 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 608 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 28531 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_III_75, mcrotaCurved_Guide_Section_III_76);
  rot_transpose(mcrotaCurved_Guide_Section_III_75, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_III_76, mctr1, mcrotrCurved_Guide_Section_III_76);
  mctc1 = coords_set(
#line 607 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 607 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 607 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.0 + 1e-4);
#line 28542 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_III_75, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_III_76 = coords_add(mcposaCurved_Guide_Section_III_75, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_III_75, mcposaCurved_Guide_Section_III_76);
  mcposrCurved_Guide_Section_III_76 = rot_apply(mcrotaCurved_Guide_Section_III_76, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_III_76", mcposaCurved_Guide_Section_III_76, mcrotaCurved_Guide_Section_III_76)
  mccomp_posa[76] = mcposaCurved_Guide_Section_III_76;
  mccomp_posr[76] = mcposrCurved_Guide_Section_III_76;
  mcNCounter[76]  = mcPCounter[76] = mcP2Counter[76] = 0;
  mcAbsorbProp[76]= 0;
    /* Component Curved_Guide_Section_III_77. */
  /* Setting parameters for component Curved_Guide_Section_III_77. */
  SIG_MESSAGE("Curved_Guide_Section_III_77 (Init:SetPar)");
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_w1 = 0.10;
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_h2 = 0;
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_l = 2.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_d = 0.0005;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_mleft = 1.0;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_mright = 2.5;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_mtop = 1.5;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_77_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_III_77_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_III_77_reflect[0]='\0';
#line 28624 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_III_77 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 612 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 612 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 2.0 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 612 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 28634 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_III_76, mcrotaCurved_Guide_Section_III_77);
  rot_transpose(mcrotaCurved_Guide_Section_III_76, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_III_77, mctr1, mcrotrCurved_Guide_Section_III_77);
  mctc1 = coords_set(
#line 611 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 611 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 611 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.0 + 1e-4);
#line 28645 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_III_76, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_III_77 = coords_add(mcposaCurved_Guide_Section_III_76, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_III_76, mcposaCurved_Guide_Section_III_77);
  mcposrCurved_Guide_Section_III_77 = rot_apply(mcrotaCurved_Guide_Section_III_77, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_III_77", mcposaCurved_Guide_Section_III_77, mcrotaCurved_Guide_Section_III_77)
  mccomp_posa[77] = mcposaCurved_Guide_Section_III_77;
  mccomp_posr[77] = mcposrCurved_Guide_Section_III_77;
  mcNCounter[77]  = mcPCounter[77] = mcP2Counter[77] = 0;
  mcAbsorbProp[77]= 0;
    /* Component Curved_Guide_Section_III_78. */
  /* Setting parameters for component Curved_Guide_Section_III_78. */
  SIG_MESSAGE("Curved_Guide_Section_III_78 (Init:SetPar)");
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_w1 = 0.10;
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_h2 = 0;
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_l = 2.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_d = 0.0005;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_mleft = 1.0;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_mright = 2.5;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_mtop = 1.5;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_78_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_III_78_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_III_78_reflect[0]='\0';
#line 28727 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_III_78 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 616 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 616 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 2.0 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 616 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 28737 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_III_77, mcrotaCurved_Guide_Section_III_78);
  rot_transpose(mcrotaCurved_Guide_Section_III_77, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_III_78, mctr1, mcrotrCurved_Guide_Section_III_78);
  mctc1 = coords_set(
#line 615 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 615 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 615 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.0 + 1e-4);
#line 28748 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_III_77, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_III_78 = coords_add(mcposaCurved_Guide_Section_III_77, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_III_77, mcposaCurved_Guide_Section_III_78);
  mcposrCurved_Guide_Section_III_78 = rot_apply(mcrotaCurved_Guide_Section_III_78, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_III_78", mcposaCurved_Guide_Section_III_78, mcrotaCurved_Guide_Section_III_78)
  mccomp_posa[78] = mcposaCurved_Guide_Section_III_78;
  mccomp_posr[78] = mcposrCurved_Guide_Section_III_78;
  mcNCounter[78]  = mcPCounter[78] = mcP2Counter[78] = 0;
  mcAbsorbProp[78]= 0;
    /* Component Curved_Guide_Section_III_79. */
  /* Setting parameters for component Curved_Guide_Section_III_79. */
  SIG_MESSAGE("Curved_Guide_Section_III_79 (Init:SetPar)");
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_w1 = 0.10;
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_h2 = 0;
#line 582 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_l = 2.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_d = 0.0005;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_mleft = 1.0;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_mright = 2.5;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_mtop = 1.5;
#line 583 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_79_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_III_79_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_III_79_reflect[0]='\0';
#line 28830 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_III_79 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 620 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 620 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 2.0 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 620 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 28840 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_III_78, mcrotaCurved_Guide_Section_III_79);
  rot_transpose(mcrotaCurved_Guide_Section_III_78, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_III_79, mctr1, mcrotrCurved_Guide_Section_III_79);
  mctc1 = coords_set(
#line 619 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 619 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 619 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.0 + 1e-4);
#line 28851 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_III_78, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_III_79 = coords_add(mcposaCurved_Guide_Section_III_78, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_III_78, mcposaCurved_Guide_Section_III_79);
  mcposrCurved_Guide_Section_III_79 = rot_apply(mcrotaCurved_Guide_Section_III_79, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_III_79", mcposaCurved_Guide_Section_III_79, mcrotaCurved_Guide_Section_III_79)
  mccomp_posa[79] = mcposaCurved_Guide_Section_III_79;
  mccomp_posr[79] = mcposrCurved_Guide_Section_III_79;
  mcNCounter[79]  = mcPCounter[79] = mcP2Counter[79] = 0;
  mcAbsorbProp[79]= 0;
    /* Component Curved_Guide_Section_III_short. */
  /* Setting parameters for component Curved_Guide_Section_III_short. */
  SIG_MESSAGE("Curved_Guide_Section_III_short (Init:SetPar)");
#line 622 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_w1 = 0.10;
#line 622 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_h1 = 0.12;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_w2 = 0;
#line 113 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_h2 = 0;
#line 622 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_l = 1.73;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_R0 = 0.995;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_Qc = 0.0218;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_alpha = 4.38;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_m = 1.0;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_W = 0.003;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_nslit = 1;
#line 114 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_d = 0.0005;
#line 623 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_mleft = 1.0;
#line 623 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_mright = 2.5;
#line 623 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_mtop = 1.5;
#line 623 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_mbottom = 1.5;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_nhslit = 1;
#line 115 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_G = 0;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_aleft = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_aright = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_atop = -1;
#line 116 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_abottom = -1;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_wavy = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_wavy_z = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_wavy_tb = 0;
#line 117 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_wavy_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_chamfers = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_chamfers_z = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_chamfers_lr = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_chamfers_tb = 0;
#line 118 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_nelements = 1;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_nu = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCurved_Guide_Section_III_short_phase = 0;
#line 119 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccCurved_Guide_Section_III_short_reflect, "NULL" ? "NULL" : "", 16384); else mccCurved_Guide_Section_III_short_reflect[0]='\0';
#line 28933 "./SNS_BASIS.c"

  SIG_MESSAGE("Curved_Guide_Section_III_short (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 625 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 625 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (( 1.73 / mcipRadCurv ) * RAD2DEG)*DEG2RAD,
#line 625 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 28943 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_III_79, mcrotaCurved_Guide_Section_III_short);
  rot_transpose(mcrotaCurved_Guide_Section_III_79, mctr1);
  rot_mul(mcrotaCurved_Guide_Section_III_short, mctr1, mcrotrCurved_Guide_Section_III_short);
  mctc1 = coords_set(
#line 624 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 624 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 624 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.0 + 1e-4);
#line 28954 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_III_79, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurved_Guide_Section_III_short = coords_add(mcposaCurved_Guide_Section_III_79, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_III_79, mcposaCurved_Guide_Section_III_short);
  mcposrCurved_Guide_Section_III_short = rot_apply(mcrotaCurved_Guide_Section_III_short, mctc1);
  mcDEBUG_COMPONENT("Curved_Guide_Section_III_short", mcposaCurved_Guide_Section_III_short, mcrotaCurved_Guide_Section_III_short)
  mccomp_posa[80] = mcposaCurved_Guide_Section_III_short;
  mccomp_posr[80] = mcposrCurved_Guide_Section_III_short;
  mcNCounter[80]  = mcPCounter[80] = mcP2Counter[80] = 0;
  mcAbsorbProp[80]= 0;
    /* Component CGS3_end_ToF. */
  /* Setting parameters for component CGS3_end_ToF. */
  SIG_MESSAGE("CGS3_end_ToF (Init:SetPar)");
#line 629 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("TOF_monitor_31,0050m_atEndof_CGS3") strncpy(mccCGS3_end_ToF_filename, "TOF_monitor_31,0050m_atEndof_CGS3" ? "TOF_monitor_31,0050m_atEndof_CGS3" : "", 16384); else mccCGS3_end_ToF_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_ymax = 0.05;
#line 629 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_xwidth = 0.4;
#line 630 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_yheight = 0.4;
#line 630 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_tmin = 0;
#line 630 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_tmax = 155000;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_dt = 1.0;
#line 629 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_nowritefile = 0;
#line 28992 "./SNS_BASIS.c"

  SIG_MESSAGE("CGS3_end_ToF (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28999 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_III_short, mcrotaCGS3_end_ToF);
  rot_transpose(mcrotaCurved_Guide_Section_III_short, mctr1);
  rot_mul(mcrotaCGS3_end_ToF, mctr1, mcrotrCGS3_end_ToF);
  mctc1 = coords_set(
#line 631 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 631 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 631 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1.73 + 1e-4);
#line 29010 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_III_short, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCGS3_end_ToF = coords_add(mcposaCurved_Guide_Section_III_short, mctc2);
  mctc1 = coords_sub(mcposaCurved_Guide_Section_III_short, mcposaCGS3_end_ToF);
  mcposrCGS3_end_ToF = rot_apply(mcrotaCGS3_end_ToF, mctc1);
  mcDEBUG_COMPONENT("CGS3_end_ToF", mcposaCGS3_end_ToF, mcrotaCGS3_end_ToF)
  mccomp_posa[81] = mcposaCGS3_end_ToF;
  mccomp_posr[81] = mcposrCGS3_end_ToF;
  mcNCounter[81]  = mcPCounter[81] = mcP2Counter[81] = 0;
  mcAbsorbProp[81]= 0;
    /* Component CGS3_end_ToF_Z. */
  /* Setting parameters for component CGS3_end_ToF_Z. */
  SIG_MESSAGE("CGS3_end_ToF_Z (Init:SetPar)");
#line 634 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("TOF_monitor_31,0050m_atEndof_CGS3_Z") strncpy(mccCGS3_end_ToF_Z_filename, "TOF_monitor_31,0050m_atEndof_CGS3_Z" ? "TOF_monitor_31,0050m_atEndof_CGS3_Z" : "", 16384); else mccCGS3_end_ToF_Z_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_Z_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_Z_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_Z_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_Z_ymax = 0.05;
#line 634 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_Z_xwidth = 0.4;
#line 635 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_Z_yheight = 0.4;
#line 635 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_Z_tmin = 4.8e4;
#line 635 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_Z_tmax = 5.2e4;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_Z_dt = 1.0;
#line 634 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_Z_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_ToF_Z_nowritefile = 0;
#line 29048 "./SNS_BASIS.c"

  SIG_MESSAGE("CGS3_end_ToF_Z (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29055 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCGS3_end_ToF, mcrotaCGS3_end_ToF_Z);
  rot_transpose(mcrotaCGS3_end_ToF, mctr1);
  rot_mul(mcrotaCGS3_end_ToF_Z, mctr1, mcrotrCGS3_end_ToF_Z);
  mctc1 = coords_set(
#line 636 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 636 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 636 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1.73 + 1e-4);
#line 29066 "./SNS_BASIS.c"
  rot_transpose(mcrotaCGS3_end_ToF, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCGS3_end_ToF_Z = coords_add(mcposaCGS3_end_ToF, mctc2);
  mctc1 = coords_sub(mcposaCGS3_end_ToF, mcposaCGS3_end_ToF_Z);
  mcposrCGS3_end_ToF_Z = rot_apply(mcrotaCGS3_end_ToF_Z, mctc1);
  mcDEBUG_COMPONENT("CGS3_end_ToF_Z", mcposaCGS3_end_ToF_Z, mcrotaCGS3_end_ToF_Z)
  mccomp_posa[82] = mcposaCGS3_end_ToF_Z;
  mccomp_posr[82] = mcposrCGS3_end_ToF_Z;
  mcNCounter[82]  = mcPCounter[82] = mcP2Counter[82] = 0;
  mcAbsorbProp[82]= 0;
    /* Component CGS3_end_Lam. */
  /* Setting parameters for component CGS3_end_Lam. */
  SIG_MESSAGE("CGS3_end_Lam (Init:SetPar)");
#line 640 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("Lam_monitor_31,0051m_atEndof_CGS3") strncpy(mccCGS3_end_Lam_filename, "Lam_monitor_31,0051m_atEndof_CGS3" ? "Lam_monitor_31,0051m_atEndof_CGS3" : "", 16384); else mccCGS3_end_Lam_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_Lam_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_Lam_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_Lam_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_Lam_ymax = 0.05;
#line 640 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_Lam_xwidth = 0.4;
#line 641 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_Lam_yheight = 0.4;
#line 641 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_Lam_Lmin = 0.1;
#line 641 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_Lam_Lmax = 12.4;
#line 640 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_Lam_restore_neutron = 1;
#line 51 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccCGS3_end_Lam_nowritefile = 0;
#line 29102 "./SNS_BASIS.c"

  SIG_MESSAGE("CGS3_end_Lam (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29109 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCGS3_end_ToF_Z, mcrotaCGS3_end_Lam);
  rot_transpose(mcrotaCGS3_end_ToF_Z, mctr1);
  rot_mul(mcrotaCGS3_end_Lam, mctr1, mcrotrCGS3_end_Lam);
  mctc1 = coords_set(
#line 642 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 642 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 642 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 29120 "./SNS_BASIS.c"
  rot_transpose(mcrotaCGS3_end_ToF_Z, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCGS3_end_Lam = coords_add(mcposaCGS3_end_ToF_Z, mctc2);
  mctc1 = coords_sub(mcposaCGS3_end_ToF_Z, mcposaCGS3_end_Lam);
  mcposrCGS3_end_Lam = rot_apply(mcrotaCGS3_end_Lam, mctc1);
  mcDEBUG_COMPONENT("CGS3_end_Lam", mcposaCGS3_end_Lam, mcrotaCGS3_end_Lam)
  mccomp_posa[83] = mcposaCGS3_end_Lam;
  mccomp_posr[83] = mcposrCGS3_end_Lam;
  mcNCounter[83]  = mcPCounter[83] = mcP2Counter[83] = 0;
  mcAbsorbProp[83]= 0;
    /* Component Straight_Guide_Section_I. */
  /* Setting parameters for component Straight_Guide_Section_I. */
  SIG_MESSAGE("Straight_Guide_Section_I (Init:SetPar)");
#line 58 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(0) strncpy(mccStraight_Guide_Section_I_reflect, 0 ? 0 : "", 16384); else mccStraight_Guide_Section_I_reflect[0]='\0';
#line 649 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_I_w1 = 0.10;
#line 649 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_I_h1 = 0.12;
#line 649 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_I_w2 = 0.10;
#line 649 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_I_h2 = 0.12;
#line 649 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_I_l = 18.97;
#line 58 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_I_R0 = 0.99;
#line 58 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_I_Qc = 0.0219;
#line 58 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_I_alpha = 6.07;
#line 650 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_I_m = 1.5;
#line 58 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_I_W = 0.003;
#line 29156 "./SNS_BASIS.c"

  SIG_MESSAGE("Straight_Guide_Section_I (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29163 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaCurved_Guide_Section_III_short, mcrotaStraight_Guide_Section_I);
  rot_transpose(mcrotaCGS3_end_Lam, mctr1);
  rot_mul(mcrotaStraight_Guide_Section_I, mctr1, mcrotrStraight_Guide_Section_I);
  mctc1 = coords_set(
#line 651 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 651 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 651 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1.731 + 2e-4);
#line 29174 "./SNS_BASIS.c"
  rot_transpose(mcrotaCurved_Guide_Section_III_short, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaStraight_Guide_Section_I = coords_add(mcposaCurved_Guide_Section_III_short, mctc2);
  mctc1 = coords_sub(mcposaCGS3_end_Lam, mcposaStraight_Guide_Section_I);
  mcposrStraight_Guide_Section_I = rot_apply(mcrotaStraight_Guide_Section_I, mctc1);
  mcDEBUG_COMPONENT("Straight_Guide_Section_I", mcposaStraight_Guide_Section_I, mcrotaStraight_Guide_Section_I)
  mccomp_posa[84] = mcposaStraight_Guide_Section_I;
  mccomp_posr[84] = mcposrStraight_Guide_Section_I;
  mcNCounter[84]  = mcPCounter[84] = mcP2Counter[84] = 0;
  mcAbsorbProp[84]= 0;
    /* Component Gap5_start. */
  /* Setting parameters for component Gap5_start. */
  SIG_MESSAGE("Gap5_start (Init:SetPar)");

  SIG_MESSAGE("Gap5_start (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29194 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaStraight_Guide_Section_I, mcrotaGap5_start);
  rot_transpose(mcrotaStraight_Guide_Section_I, mctr1);
  rot_mul(mcrotaGap5_start, mctr1, mcrotrGap5_start);
  mctc1 = coords_set(
#line 657 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 657 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 657 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    18.97 + 1e-4);
#line 29205 "./SNS_BASIS.c"
  rot_transpose(mcrotaStraight_Guide_Section_I, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap5_start = coords_add(mcposaStraight_Guide_Section_I, mctc2);
  mctc1 = coords_sub(mcposaStraight_Guide_Section_I, mcposaGap5_start);
  mcposrGap5_start = rot_apply(mcrotaGap5_start, mctc1);
  mcDEBUG_COMPONENT("Gap5_start", mcposaGap5_start, mcrotaGap5_start)
  mccomp_posa[85] = mcposaGap5_start;
  mccomp_posr[85] = mcposrGap5_start;
  mcNCounter[85]  = mcPCounter[85] = mcP2Counter[85] = 0;
  mcAbsorbProp[85]= 0;
    /* Component Gap5_start_ToF. */
  /* Setting parameters for component Gap5_start_ToF. */
  SIG_MESSAGE("Gap5_start_ToF (Init:SetPar)");
#line 661 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("TOF_monitor_49,9763m_just_before_Ch3") strncpy(mccGap5_start_ToF_filename, "TOF_monitor_49,9763m_just_before_Ch3" ? "TOF_monitor_49,9763m_just_before_Ch3" : "", 16384); else mccGap5_start_ToF_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_ymax = 0.05;
#line 661 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_xwidth = 0.4;
#line 662 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_yheight = 0.4;
#line 662 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_tmin = 0;
#line 662 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_tmax = 155000;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_dt = 1.0;
#line 661 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_nowritefile = 0;
#line 29243 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap5_start_ToF (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29250 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap5_start, mcrotaGap5_start_ToF);
  rot_transpose(mcrotaGap5_start, mctr1);
  rot_mul(mcrotaGap5_start_ToF, mctr1, mcrotrGap5_start_ToF);
  mctc1 = coords_set(
#line 663 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 663 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 663 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 29261 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap5_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap5_start_ToF = coords_add(mcposaGap5_start, mctc2);
  mctc1 = coords_sub(mcposaGap5_start, mcposaGap5_start_ToF);
  mcposrGap5_start_ToF = rot_apply(mcrotaGap5_start_ToF, mctc1);
  mcDEBUG_COMPONENT("Gap5_start_ToF", mcposaGap5_start_ToF, mcrotaGap5_start_ToF)
  mccomp_posa[86] = mcposaGap5_start_ToF;
  mccomp_posr[86] = mcposrGap5_start_ToF;
  mcNCounter[86]  = mcPCounter[86] = mcP2Counter[86] = 0;
  mcAbsorbProp[86]= 0;
    /* Component Gap5_start_ToF_Z. */
  /* Setting parameters for component Gap5_start_ToF_Z. */
  SIG_MESSAGE("Gap5_start_ToF_Z (Init:SetPar)");
#line 666 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("TOF_monitor_49,9763m_just_before_Ch3_Z") strncpy(mccGap5_start_ToF_Z_filename, "TOF_monitor_49,9763m_just_before_Ch3_Z" ? "TOF_monitor_49,9763m_just_before_Ch3_Z" : "", 16384); else mccGap5_start_ToF_Z_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_Z_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_Z_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_Z_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_Z_ymax = 0.05;
#line 666 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_Z_xwidth = 0.4;
#line 667 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_Z_yheight = 0.4;
#line 667 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_Z_tmin = 7.8e4;
#line 667 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_Z_tmax = 8.2e4;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_Z_dt = 1.0;
#line 666 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_Z_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_ToF_Z_nowritefile = 0;
#line 29299 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap5_start_ToF_Z (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29306 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap5_start_ToF, mcrotaGap5_start_ToF_Z);
  rot_transpose(mcrotaGap5_start_ToF, mctr1);
  rot_mul(mcrotaGap5_start_ToF_Z, mctr1, mcrotrGap5_start_ToF_Z);
  mctc1 = coords_set(
#line 668 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 668 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 668 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 29317 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap5_start_ToF, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap5_start_ToF_Z = coords_add(mcposaGap5_start_ToF, mctc2);
  mctc1 = coords_sub(mcposaGap5_start_ToF, mcposaGap5_start_ToF_Z);
  mcposrGap5_start_ToF_Z = rot_apply(mcrotaGap5_start_ToF_Z, mctc1);
  mcDEBUG_COMPONENT("Gap5_start_ToF_Z", mcposaGap5_start_ToF_Z, mcrotaGap5_start_ToF_Z)
  mccomp_posa[87] = mcposaGap5_start_ToF_Z;
  mccomp_posr[87] = mcposrGap5_start_ToF_Z;
  mcNCounter[87]  = mcPCounter[87] = mcP2Counter[87] = 0;
  mcAbsorbProp[87]= 0;
    /* Component Gap5_start_Lam. */
  /* Setting parameters for component Gap5_start_Lam. */
  SIG_MESSAGE("Gap5_start_Lam (Init:SetPar)");
#line 672 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("Lam_monitor_49,9764m_just_before_Ch3") strncpy(mccGap5_start_Lam_filename, "Lam_monitor_49,9764m_just_before_Ch3" ? "Lam_monitor_49,9764m_just_before_Ch3" : "", 16384); else mccGap5_start_Lam_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_Lam_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_Lam_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_Lam_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_Lam_ymax = 0.05;
#line 672 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_Lam_xwidth = 0.4;
#line 673 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_Lam_yheight = 0.4;
#line 673 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_Lam_Lmin = 2.0;
#line 673 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_Lam_Lmax = 10.0;
#line 672 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_Lam_restore_neutron = 1;
#line 51 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_Lam_nowritefile = 0;
#line 29353 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap5_start_Lam (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29360 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaStraight_Guide_Section_I, mcrotaGap5_start_Lam);
  rot_transpose(mcrotaGap5_start_ToF_Z, mctr1);
  rot_mul(mcrotaGap5_start_Lam, mctr1, mcrotrGap5_start_Lam);
  mctc1 = coords_set(
#line 674 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 674 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 674 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    18.97 + 1e-4);
#line 29371 "./SNS_BASIS.c"
  rot_transpose(mcrotaStraight_Guide_Section_I, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap5_start_Lam = coords_add(mcposaStraight_Guide_Section_I, mctc2);
  mctc1 = coords_sub(mcposaGap5_start_ToF_Z, mcposaGap5_start_Lam);
  mcposrGap5_start_Lam = rot_apply(mcrotaGap5_start_Lam, mctc1);
  mcDEBUG_COMPONENT("Gap5_start_Lam", mcposaGap5_start_Lam, mcrotaGap5_start_Lam)
  mccomp_posa[88] = mcposaGap5_start_Lam;
  mccomp_posr[88] = mcposrGap5_start_Lam;
  mcNCounter[88]  = mcPCounter[88] = mcP2Counter[88] = 0;
  mcAbsorbProp[88]= 0;
    /* Component Gap5_start_PSD. */
  /* Setting parameters for component Gap5_start_PSD. */
  SIG_MESSAGE("Gap5_start_PSD (Init:SetPar)");
#line 677 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_PSD_nx = 100;
#line 677 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_PSD_ny = 100;
#line 677 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("PSD_monitor_49,9765m_just_before_Ch3") strncpy(mccGap5_start_PSD_filename, "PSD_monitor_49,9765m_just_before_Ch3" ? "PSD_monitor_49,9765m_just_before_Ch3" : "", 16384); else mccGap5_start_PSD_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_PSD_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_PSD_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_PSD_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_PSD_ymax = 0.05;
#line 678 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_PSD_xwidth = 0.10;
#line 678 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_PSD_yheight = 0.12;
#line 678 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_start_PSD_restore_neutron = 1;
#line 29405 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap5_start_PSD (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29412 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap5_start_Lam, mcrotaGap5_start_PSD);
  rot_transpose(mcrotaGap5_start_Lam, mctr1);
  rot_mul(mcrotaGap5_start_PSD, mctr1, mcrotrGap5_start_PSD);
  mctc1 = coords_set(
#line 679 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 679 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 679 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 29423 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap5_start_Lam, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap5_start_PSD = coords_add(mcposaGap5_start_Lam, mctc2);
  mctc1 = coords_sub(mcposaGap5_start_Lam, mcposaGap5_start_PSD);
  mcposrGap5_start_PSD = rot_apply(mcrotaGap5_start_PSD, mctc1);
  mcDEBUG_COMPONENT("Gap5_start_PSD", mcposaGap5_start_PSD, mcrotaGap5_start_PSD)
  mccomp_posa[89] = mcposaGap5_start_PSD;
  mccomp_posr[89] = mcposrGap5_start_PSD;
  mcNCounter[89]  = mcPCounter[89] = mcP2Counter[89] = 0;
  mcAbsorbProp[89]= 0;
    /* Component Chopper3. */
  /* Setting parameters for component Chopper3. */
  SIG_MESSAGE("Chopper3 (Init:SetPar)");
#line 685 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_theta_0 = mcipch3_open;
#line 685 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_radius = 0.254;
#line 685 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_yheight = 0.128;
#line 685 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_nu = Omega3;
#line 685 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_nslit = 1;
#line 59 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_jitter = 0;
#line 685 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_delay = 252.78 * 49.996 * mcipLam * 1e-6;
#line 59 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_isfirst = 0;
#line 59 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_n_pulse = 1;
#line 59 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_abs_out = 1;
#line 59 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_phase = 0;
#line 59 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_xwidth = 0;
#line 59 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_verbose = 0;
#line 29463 "./SNS_BASIS.c"

  SIG_MESSAGE("Chopper3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29470 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap5_start, mcrotaChopper3);
  rot_transpose(mcrotaGap5_start_PSD, mctr1);
  rot_mul(mcrotaChopper3, mctr1, mcrotrChopper3);
  mctc1 = coords_set(
#line 686 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 686 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 686 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.025);
#line 29481 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap5_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaChopper3 = coords_add(mcposaGap5_start, mctc2);
  mctc1 = coords_sub(mcposaGap5_start_PSD, mcposaChopper3);
  mcposrChopper3 = rot_apply(mcrotaChopper3, mctc1);
  mcDEBUG_COMPONENT("Chopper3", mcposaChopper3, mcrotaChopper3)
  mccomp_posa[90] = mcposaChopper3;
  mccomp_posr[90] = mcposrChopper3;
  mcNCounter[90]  = mcPCounter[90] = mcP2Counter[90] = 0;
  mcAbsorbProp[90]= 0;
    /* Component Chopper3_ToF. */
  /* Setting parameters for component Chopper3_ToF. */
  SIG_MESSAGE("Chopper3_ToF (Init:SetPar)");
#line 690 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("TOF_monitor_50,0013m_just_after_Ch3") strncpy(mccChopper3_ToF_filename, "TOF_monitor_50,0013m_just_after_Ch3" ? "TOF_monitor_50,0013m_just_after_Ch3" : "", 16384); else mccChopper3_ToF_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_ymax = 0.05;
#line 690 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_xwidth = 0.4;
#line 691 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_yheight = 0.4;
#line 691 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_tmin = 0;
#line 691 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_tmax = 155000;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_dt = 1.0;
#line 690 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_nowritefile = 0;
#line 29519 "./SNS_BASIS.c"

  SIG_MESSAGE("Chopper3_ToF (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29526 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap5_start, mcrotaChopper3_ToF);
  rot_transpose(mcrotaChopper3, mctr1);
  rot_mul(mcrotaChopper3_ToF, mctr1, mcrotrChopper3_ToF);
  mctc1 = coords_set(
#line 692 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 692 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 692 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.025 + 1e-4);
#line 29537 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap5_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaChopper3_ToF = coords_add(mcposaGap5_start, mctc2);
  mctc1 = coords_sub(mcposaChopper3, mcposaChopper3_ToF);
  mcposrChopper3_ToF = rot_apply(mcrotaChopper3_ToF, mctc1);
  mcDEBUG_COMPONENT("Chopper3_ToF", mcposaChopper3_ToF, mcrotaChopper3_ToF)
  mccomp_posa[91] = mcposaChopper3_ToF;
  mccomp_posr[91] = mcposrChopper3_ToF;
  mcNCounter[91]  = mcPCounter[91] = mcP2Counter[91] = 0;
  mcAbsorbProp[91]= 0;
    /* Component Chopper3_ToF_Z. */
  /* Setting parameters for component Chopper3_ToF_Z. */
  SIG_MESSAGE("Chopper3_ToF_Z (Init:SetPar)");
#line 695 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("TOF_monitor_50,0013m_just_after_Ch3_Z") strncpy(mccChopper3_ToF_Z_filename, "TOF_monitor_50,0013m_just_after_Ch3_Z" ? "TOF_monitor_50,0013m_just_after_Ch3_Z" : "", 16384); else mccChopper3_ToF_Z_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_Z_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_Z_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_Z_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_Z_ymax = 0.05;
#line 695 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_Z_xwidth = 0.4;
#line 696 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_Z_yheight = 0.4;
#line 696 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_Z_tmin = 7.8e4;
#line 696 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_Z_tmax = 8.2e4;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_Z_dt = 1.0;
#line 695 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_Z_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccChopper3_ToF_Z_nowritefile = 0;
#line 29575 "./SNS_BASIS.c"

  SIG_MESSAGE("Chopper3_ToF_Z (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29582 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap5_start, mcrotaChopper3_ToF_Z);
  rot_transpose(mcrotaChopper3_ToF, mctr1);
  rot_mul(mcrotaChopper3_ToF_Z, mctr1, mcrotrChopper3_ToF_Z);
  mctc1 = coords_set(
#line 697 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 697 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 697 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.025 + 2e-4);
#line 29593 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap5_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaChopper3_ToF_Z = coords_add(mcposaGap5_start, mctc2);
  mctc1 = coords_sub(mcposaChopper3_ToF, mcposaChopper3_ToF_Z);
  mcposrChopper3_ToF_Z = rot_apply(mcrotaChopper3_ToF_Z, mctc1);
  mcDEBUG_COMPONENT("Chopper3_ToF_Z", mcposaChopper3_ToF_Z, mcrotaChopper3_ToF_Z)
  mccomp_posa[92] = mcposaChopper3_ToF_Z;
  mccomp_posr[92] = mcposrChopper3_ToF_Z;
  mcNCounter[92]  = mcPCounter[92] = mcP2Counter[92] = 0;
  mcAbsorbProp[92]= 0;
    /* Component Gap5_end_Lam. */
  /* Setting parameters for component Gap5_end_Lam. */
  SIG_MESSAGE("Gap5_end_Lam (Init:SetPar)");
#line 704 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("Lam_monitor_50,0562m_just_after_Ch3") strncpy(mccGap5_end_Lam_filename, "Lam_monitor_50,0562m_just_after_Ch3" ? "Lam_monitor_50,0562m_just_after_Ch3" : "", 16384); else mccGap5_end_Lam_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_end_Lam_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_end_Lam_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_end_Lam_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_end_Lam_ymax = 0.05;
#line 704 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_end_Lam_xwidth = 0.4;
#line 705 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_end_Lam_yheight = 0.4;
#line 705 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_end_Lam_Lmin = 0.1;
#line 705 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_end_Lam_Lmax = 40.0;
#line 704 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_end_Lam_restore_neutron = 1;
#line 51 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_end_Lam_nowritefile = 0;
#line 29629 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap5_end_Lam (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29636 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap5_start, mcrotaGap5_end_Lam);
  rot_transpose(mcrotaChopper3_ToF_Z, mctr1);
  rot_mul(mcrotaGap5_end_Lam, mctr1, mcrotrGap5_end_Lam);
  mctc1 = coords_set(
#line 706 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 706 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 706 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.08);
#line 29647 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap5_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap5_end_Lam = coords_add(mcposaGap5_start, mctc2);
  mctc1 = coords_sub(mcposaChopper3_ToF_Z, mcposaGap5_end_Lam);
  mcposrGap5_end_Lam = rot_apply(mcrotaGap5_end_Lam, mctc1);
  mcDEBUG_COMPONENT("Gap5_end_Lam", mcposaGap5_end_Lam, mcrotaGap5_end_Lam)
  mccomp_posa[93] = mcposaGap5_end_Lam;
  mccomp_posr[93] = mcposrGap5_end_Lam;
  mcNCounter[93]  = mcPCounter[93] = mcP2Counter[93] = 0;
  mcAbsorbProp[93]= 0;
    /* Component Gap5_end_PSD. */
  /* Setting parameters for component Gap5_end_PSD. */
  SIG_MESSAGE("Gap5_end_PSD (Init:SetPar)");
#line 710 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_end_PSD_nx = 100;
#line 710 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_end_PSD_ny = 100;
#line 710 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("PSD_monitor_50,0563m_just_after_Ch3") strncpy(mccGap5_end_PSD_filename, "PSD_monitor_50,0563m_just_after_Ch3" ? "PSD_monitor_50,0563m_just_after_Ch3" : "", 16384); else mccGap5_end_PSD_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_end_PSD_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_end_PSD_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_end_PSD_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_end_PSD_ymax = 0.05;
#line 711 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_end_PSD_xwidth = 0.10;
#line 711 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_end_PSD_yheight = 0.12;
#line 711 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGap5_end_PSD_restore_neutron = 1;
#line 29681 "./SNS_BASIS.c"

  SIG_MESSAGE("Gap5_end_PSD (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29688 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap5_start, mcrotaGap5_end_PSD);
  rot_transpose(mcrotaGap5_end_Lam, mctr1);
  rot_mul(mcrotaGap5_end_PSD, mctr1, mcrotrGap5_end_PSD);
  mctc1 = coords_set(
#line 712 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 712 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 712 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.08 + 1e-4);
#line 29699 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap5_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap5_end_PSD = coords_add(mcposaGap5_start, mctc2);
  mctc1 = coords_sub(mcposaGap5_end_Lam, mcposaGap5_end_PSD);
  mcposrGap5_end_PSD = rot_apply(mcrotaGap5_end_PSD, mctc1);
  mcDEBUG_COMPONENT("Gap5_end_PSD", mcposaGap5_end_PSD, mcrotaGap5_end_PSD)
  mccomp_posa[94] = mcposaGap5_end_PSD;
  mccomp_posr[94] = mcposrGap5_end_PSD;
  mcNCounter[94]  = mcPCounter[94] = mcP2Counter[94] = 0;
  mcAbsorbProp[94]= 0;
    /* Component Gap5_end. */
  /* Setting parameters for component Gap5_end. */
  SIG_MESSAGE("Gap5_end (Init:SetPar)");

  SIG_MESSAGE("Gap5_end (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29719 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap5_start, mcrotaGap5_end);
  rot_transpose(mcrotaGap5_end_PSD, mctr1);
  rot_mul(mcrotaGap5_end, mctr1, mcrotrGap5_end);
  mctc1 = coords_set(
#line 716 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 716 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 716 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.08 + 2e-4);
#line 29730 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap5_start, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGap5_end = coords_add(mcposaGap5_start, mctc2);
  mctc1 = coords_sub(mcposaGap5_end_PSD, mcposaGap5_end);
  mcposrGap5_end = rot_apply(mcrotaGap5_end, mctc1);
  mcDEBUG_COMPONENT("Gap5_end", mcposaGap5_end, mcrotaGap5_end)
  mccomp_posa[95] = mcposaGap5_end;
  mccomp_posr[95] = mcposrGap5_end;
  mcNCounter[95]  = mcPCounter[95] = mcP2Counter[95] = 0;
  mcAbsorbProp[95]= 0;
    /* Component Straight_Guide_Section_II. */
  /* Setting parameters for component Straight_Guide_Section_II. */
  SIG_MESSAGE("Straight_Guide_Section_II (Init:SetPar)");
#line 58 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(0) strncpy(mccStraight_Guide_Section_II_reflect, 0 ? 0 : "", 16384); else mccStraight_Guide_Section_II_reflect[0]='\0';
#line 721 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_II_w1 = 0.10;
#line 721 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_II_h1 = 0.12;
#line 721 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_II_w2 = 0.10;
#line 721 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_II_h2 = 0.12;
#line 721 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_II_l = 25.674;
#line 58 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_II_R0 = 0.99;
#line 58 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_II_Qc = 0.0219;
#line 58 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_II_alpha = 6.07;
#line 722 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_II_m = 1.5;
#line 58 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_II_W = 0.003;
#line 29766 "./SNS_BASIS.c"

  SIG_MESSAGE("Straight_Guide_Section_II (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29773 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGap5_end, mcrotaStraight_Guide_Section_II);
  rot_transpose(mcrotaGap5_end, mctr1);
  rot_mul(mcrotaStraight_Guide_Section_II, mctr1, mcrotrStraight_Guide_Section_II);
  mctc1 = coords_set(
#line 723 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 723 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 723 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0);
#line 29784 "./SNS_BASIS.c"
  rot_transpose(mcrotaGap5_end, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaStraight_Guide_Section_II = coords_add(mcposaGap5_end, mctc2);
  mctc1 = coords_sub(mcposaGap5_end, mcposaStraight_Guide_Section_II);
  mcposrStraight_Guide_Section_II = rot_apply(mcrotaStraight_Guide_Section_II, mctc1);
  mcDEBUG_COMPONENT("Straight_Guide_Section_II", mcposaStraight_Guide_Section_II, mcrotaStraight_Guide_Section_II)
  mccomp_posa[96] = mcposaStraight_Guide_Section_II;
  mccomp_posr[96] = mcposrStraight_Guide_Section_II;
  mcNCounter[96]  = mcPCounter[96] = mcP2Counter[96] = 0;
  mcAbsorbProp[96]= 0;
    /* Component SGS2_end_Lam. */
  /* Setting parameters for component SGS2_end_Lam. */
  SIG_MESSAGE("SGS2_end_Lam (Init:SetPar)");
#line 726 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("Lam_monitor_75,7305m_atEndof_SGS2") strncpy(mccSGS2_end_Lam_filename, "Lam_monitor_75,7305m_atEndof_SGS2" ? "Lam_monitor_75,7305m_atEndof_SGS2" : "", 16384); else mccSGS2_end_Lam_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSGS2_end_Lam_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSGS2_end_Lam_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSGS2_end_Lam_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSGS2_end_Lam_ymax = 0.05;
#line 726 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSGS2_end_Lam_xwidth = 0.4;
#line 727 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSGS2_end_Lam_yheight = 0.4;
#line 727 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSGS2_end_Lam_Lmin = 0.1;
#line 727 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSGS2_end_Lam_Lmax = 40.0;
#line 726 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSGS2_end_Lam_restore_neutron = 1;
#line 51 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSGS2_end_Lam_nowritefile = 0;
#line 29820 "./SNS_BASIS.c"

  SIG_MESSAGE("SGS2_end_Lam (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29827 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaStraight_Guide_Section_II, mcrotaSGS2_end_Lam);
  rot_transpose(mcrotaStraight_Guide_Section_II, mctr1);
  rot_mul(mcrotaSGS2_end_Lam, mctr1, mcrotrSGS2_end_Lam);
  mctc1 = coords_set(
#line 728 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 728 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 728 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    25.674 + 1e-4);
#line 29838 "./SNS_BASIS.c"
  rot_transpose(mcrotaStraight_Guide_Section_II, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaSGS2_end_Lam = coords_add(mcposaStraight_Guide_Section_II, mctc2);
  mctc1 = coords_sub(mcposaStraight_Guide_Section_II, mcposaSGS2_end_Lam);
  mcposrSGS2_end_Lam = rot_apply(mcrotaSGS2_end_Lam, mctc1);
  mcDEBUG_COMPONENT("SGS2_end_Lam", mcposaSGS2_end_Lam, mcrotaSGS2_end_Lam)
  mccomp_posa[97] = mcposaSGS2_end_Lam;
  mccomp_posr[97] = mcposrSGS2_end_Lam;
  mcNCounter[97]  = mcPCounter[97] = mcP2Counter[97] = 0;
  mcAbsorbProp[97]= 0;
    /* Component SGS2_end_PSD. */
  /* Setting parameters for component SGS2_end_PSD. */
  SIG_MESSAGE("SGS2_end_PSD (Init:SetPar)");
#line 731 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSGS2_end_PSD_nx = 100;
#line 731 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSGS2_end_PSD_ny = 100;
#line 731 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("PSD_monitor_75,7305m_atEndof_SGS2") strncpy(mccSGS2_end_PSD_filename, "PSD_monitor_75,7305m_atEndof_SGS2" ? "PSD_monitor_75,7305m_atEndof_SGS2" : "", 16384); else mccSGS2_end_PSD_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSGS2_end_PSD_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSGS2_end_PSD_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSGS2_end_PSD_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSGS2_end_PSD_ymax = 0.05;
#line 732 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSGS2_end_PSD_xwidth = 0.10;
#line 732 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSGS2_end_PSD_yheight = 0.12;
#line 732 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSGS2_end_PSD_restore_neutron = 1;
#line 29872 "./SNS_BASIS.c"

  SIG_MESSAGE("SGS2_end_PSD (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29879 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaSGS2_end_Lam, mcrotaSGS2_end_PSD);
  rot_transpose(mcrotaSGS2_end_Lam, mctr1);
  rot_mul(mcrotaSGS2_end_PSD, mctr1, mcrotrSGS2_end_PSD);
  mctc1 = coords_set(
#line 733 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 733 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 733 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 29890 "./SNS_BASIS.c"
  rot_transpose(mcrotaSGS2_end_Lam, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaSGS2_end_PSD = coords_add(mcposaSGS2_end_Lam, mctc2);
  mctc1 = coords_sub(mcposaSGS2_end_Lam, mcposaSGS2_end_PSD);
  mcposrSGS2_end_PSD = rot_apply(mcrotaSGS2_end_PSD, mctc1);
  mcDEBUG_COMPONENT("SGS2_end_PSD", mcposaSGS2_end_PSD, mcrotaSGS2_end_PSD)
  mccomp_posa[98] = mcposaSGS2_end_PSD;
  mccomp_posr[98] = mcposrSGS2_end_PSD;
  mcNCounter[98]  = mcPCounter[98] = mcP2Counter[98] = 0;
  mcAbsorbProp[98]= 0;
    /* Component Straight_Guide_Section_III. */
  /* Setting parameters for component Straight_Guide_Section_III. */
  SIG_MESSAGE("Straight_Guide_Section_III (Init:SetPar)");
#line 58 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(0) strncpy(mccStraight_Guide_Section_III_reflect, 0 ? 0 : "", 16384); else mccStraight_Guide_Section_III_reflect[0]='\0';
#line 739 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_III_w1 = 0.10;
#line 739 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_III_h1 = 0.12;
#line 739 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_III_w2 = 0.10;
#line 739 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_III_h2 = 0.12;
#line 739 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_III_l = Guide_extension;
#line 58 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_III_R0 = 0.99;
#line 58 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_III_Qc = 0.0219;
#line 58 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_III_alpha = 6.07;
#line 740 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_III_m = 1.5;
#line 58 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccStraight_Guide_Section_III_W = 0.003;
#line 29926 "./SNS_BASIS.c"

  SIG_MESSAGE("Straight_Guide_Section_III (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29933 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaStraight_Guide_Section_II, mcrotaStraight_Guide_Section_III);
  rot_transpose(mcrotaSGS2_end_PSD, mctr1);
  rot_mul(mcrotaStraight_Guide_Section_III, mctr1, mcrotrStraight_Guide_Section_III);
  mctc1 = coords_set(
#line 741 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 741 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 741 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    25.674 + 2e-4);
#line 29944 "./SNS_BASIS.c"
  rot_transpose(mcrotaStraight_Guide_Section_II, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaStraight_Guide_Section_III = coords_add(mcposaStraight_Guide_Section_II, mctc2);
  mctc1 = coords_sub(mcposaSGS2_end_PSD, mcposaStraight_Guide_Section_III);
  mcposrStraight_Guide_Section_III = rot_apply(mcrotaStraight_Guide_Section_III, mctc1);
  mcDEBUG_COMPONENT("Straight_Guide_Section_III", mcposaStraight_Guide_Section_III, mcrotaStraight_Guide_Section_III)
  mccomp_posa[99] = mcposaStraight_Guide_Section_III;
  mccomp_posr[99] = mcposrStraight_Guide_Section_III;
  mcNCounter[99]  = mcPCounter[99] = mcP2Counter[99] = 0;
  mcAbsorbProp[99]= 0;
    /* Component SG3_end_ToF. */
  /* Setting parameters for component SG3_end_ToF. */
  SIG_MESSAGE("SG3_end_ToF (Init:SetPar)");
#line 745 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(myfilename_1) strncpy(mccSG3_end_ToF_filename, myfilename_1 ? myfilename_1 : "", 16384); else mccSG3_end_ToF_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_ymax = 0.05;
#line 745 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_xwidth = 0.4;
#line 746 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_yheight = 0.4;
#line 746 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_tmin = 0;
#line 746 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_tmax = 555000;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_dt = 1.0;
#line 745 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_nowritefile = 0;
#line 29982 "./SNS_BASIS.c"

  SIG_MESSAGE("SG3_end_ToF (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29989 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaStraight_Guide_Section_III, mcrotaSG3_end_ToF);
  rot_transpose(mcrotaStraight_Guide_Section_III, mctr1);
  rot_mul(mcrotaSG3_end_ToF, mctr1, mcrotrSG3_end_ToF);
  mctc1 = coords_set(
#line 747 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 747 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 747 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    Guide_extension + 1e-4);
#line 30000 "./SNS_BASIS.c"
  rot_transpose(mcrotaStraight_Guide_Section_III, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaSG3_end_ToF = coords_add(mcposaStraight_Guide_Section_III, mctc2);
  mctc1 = coords_sub(mcposaStraight_Guide_Section_III, mcposaSG3_end_ToF);
  mcposrSG3_end_ToF = rot_apply(mcrotaSG3_end_ToF, mctc1);
  mcDEBUG_COMPONENT("SG3_end_ToF", mcposaSG3_end_ToF, mcrotaSG3_end_ToF)
  mccomp_posa[100] = mcposaSG3_end_ToF;
  mccomp_posr[100] = mcposrSG3_end_ToF;
  mcNCounter[100]  = mcPCounter[100] = mcP2Counter[100] = 0;
  mcAbsorbProp[100]= 0;
    /* Component SG3_end_ToF_Z. */
  /* Setting parameters for component SG3_end_ToF_Z. */
  SIG_MESSAGE("SG3_end_ToF_Z (Init:SetPar)");
#line 750 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("SG3_end_ToF_Zoom") strncpy(mccSG3_end_ToF_Z_filename, "SG3_end_ToF_Zoom" ? "SG3_end_ToF_Zoom" : "", 16384); else mccSG3_end_ToF_Z_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_Z_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_Z_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_Z_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_Z_ymax = 0.05;
#line 750 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_Z_xwidth = 0.4;
#line 751 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_Z_yheight = 0.4;
#line 751 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_Z_tmin = 0;
#line 751 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_Z_tmax = 555000;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_Z_dt = 1.0;
#line 750 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_Z_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_ToF_Z_nowritefile = 0;
#line 30038 "./SNS_BASIS.c"

  SIG_MESSAGE("SG3_end_ToF_Z (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 30045 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaStraight_Guide_Section_III, mcrotaSG3_end_ToF_Z);
  rot_transpose(mcrotaSG3_end_ToF, mctr1);
  rot_mul(mcrotaSG3_end_ToF_Z, mctr1, mcrotrSG3_end_ToF_Z);
  mctc1 = coords_set(
#line 752 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 752 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 752 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    Guide_extension + 2e-4);
#line 30056 "./SNS_BASIS.c"
  rot_transpose(mcrotaStraight_Guide_Section_III, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaSG3_end_ToF_Z = coords_add(mcposaStraight_Guide_Section_III, mctc2);
  mctc1 = coords_sub(mcposaSG3_end_ToF, mcposaSG3_end_ToF_Z);
  mcposrSG3_end_ToF_Z = rot_apply(mcrotaSG3_end_ToF_Z, mctc1);
  mcDEBUG_COMPONENT("SG3_end_ToF_Z", mcposaSG3_end_ToF_Z, mcrotaSG3_end_ToF_Z)
  mccomp_posa[101] = mcposaSG3_end_ToF_Z;
  mccomp_posr[101] = mcposrSG3_end_ToF_Z;
  mcNCounter[101]  = mcPCounter[101] = mcP2Counter[101] = 0;
  mcAbsorbProp[101]= 0;
    /* Component SG3_end_Lam. */
  /* Setting parameters for component SG3_end_Lam. */
  SIG_MESSAGE("SG3_end_Lam (Init:SetPar)");
#line 756 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(myfilename_2) strncpy(mccSG3_end_Lam_filename, myfilename_2 ? myfilename_2 : "", 16384); else mccSG3_end_Lam_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_Lam_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_Lam_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_Lam_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_Lam_ymax = 0.05;
#line 756 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_Lam_xwidth = 0.4;
#line 757 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_Lam_yheight = 0.4;
#line 757 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_Lam_Lmin = 2.0;
#line 757 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_Lam_Lmax = 10.0;
#line 756 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_Lam_restore_neutron = 1;
#line 51 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_Lam_nowritefile = 0;
#line 30092 "./SNS_BASIS.c"

  SIG_MESSAGE("SG3_end_Lam (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 30099 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaSG3_end_ToF_Z, mcrotaSG3_end_Lam);
  rot_transpose(mcrotaSG3_end_ToF_Z, mctr1);
  rot_mul(mcrotaSG3_end_Lam, mctr1, mcrotrSG3_end_Lam);
  mctc1 = coords_set(
#line 758 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 758 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 758 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 30110 "./SNS_BASIS.c"
  rot_transpose(mcrotaSG3_end_ToF_Z, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaSG3_end_Lam = coords_add(mcposaSG3_end_ToF_Z, mctc2);
  mctc1 = coords_sub(mcposaSG3_end_ToF_Z, mcposaSG3_end_Lam);
  mcposrSG3_end_Lam = rot_apply(mcrotaSG3_end_Lam, mctc1);
  mcDEBUG_COMPONENT("SG3_end_Lam", mcposaSG3_end_Lam, mcrotaSG3_end_Lam)
  mccomp_posa[102] = mcposaSG3_end_Lam;
  mccomp_posr[102] = mcposrSG3_end_Lam;
  mcNCounter[102]  = mcPCounter[102] = mcP2Counter[102] = 0;
  mcAbsorbProp[102]= 0;
    /* Component SG3_end_PSD. */
  /* Setting parameters for component SG3_end_PSD. */
  SIG_MESSAGE("SG3_end_PSD (Init:SetPar)");
#line 761 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_PSD_nx = 100;
#line 761 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_PSD_ny = 100;
#line 761 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(myfilename_3) strncpy(mccSG3_end_PSD_filename, myfilename_3 ? myfilename_3 : "", 16384); else mccSG3_end_PSD_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_PSD_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_PSD_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_PSD_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_PSD_ymax = 0.05;
#line 762 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_PSD_xwidth = 0.10;
#line 762 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_PSD_yheight = 0.12;
#line 762 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSG3_end_PSD_restore_neutron = 1;
#line 30144 "./SNS_BASIS.c"

  SIG_MESSAGE("SG3_end_PSD (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 30151 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaSG3_end_Lam, mcrotaSG3_end_PSD);
  rot_transpose(mcrotaSG3_end_Lam, mctr1);
  rot_mul(mcrotaSG3_end_PSD, mctr1, mcrotrSG3_end_PSD);
  mctc1 = coords_set(
#line 763 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 763 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 763 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 30162 "./SNS_BASIS.c"
  rot_transpose(mcrotaSG3_end_Lam, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaSG3_end_PSD = coords_add(mcposaSG3_end_Lam, mctc2);
  mctc1 = coords_sub(mcposaSG3_end_Lam, mcposaSG3_end_PSD);
  mcposrSG3_end_PSD = rot_apply(mcrotaSG3_end_PSD, mctc1);
  mcDEBUG_COMPONENT("SG3_end_PSD", mcposaSG3_end_PSD, mcrotaSG3_end_PSD)
  mccomp_posa[103] = mcposaSG3_end_PSD;
  mccomp_posr[103] = mcposrSG3_end_PSD;
  mcNCounter[103]  = mcPCounter[103] = mcP2Counter[103] = 0;
  mcAbsorbProp[103]= 0;
    /* Component Funnel_1. */
  /* Setting parameters for component Funnel_1. */
  SIG_MESSAGE("Funnel_1 (Init:SetPar)");
#line 771 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_w1 = 0.1;
#line 771 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_h1 = 0.12;
#line 771 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_w2 = 0.1;
#line 771 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_h2 = 0.1036;
#line 771 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_l = 1.5;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_R0_left = 0.99;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_R0_right = 0.99;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_R0_top = 0.99;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_R0_bottom = 0.99;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_Qc_left = 0.0219;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_Qc_right = 0.0219;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_Qc_top = 0.0219;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_Qc_bottom = 0.0219;
#line 771 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_alpha_left = 1.904;
#line 771 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_alpha_right = 1.904;
#line 771 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_alpha_top = 2.222;
#line 771 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_alpha_bottom = 2.222;
#line 771 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_m_left = 1.5;
#line 771 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_m_right = 1.5;
#line 771 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_m_top = 2.5;
#line 771 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_m_bottom = 2.5;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_W_left = 0.003;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_W_right = 0.003;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_W_top = 0.003;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_1_W_bottom = 0.003;
#line 30226 "./SNS_BASIS.c"

  SIG_MESSAGE("Funnel_1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 30233 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaStraight_Guide_Section_III, mcrotaFunnel_1);
  rot_transpose(mcrotaSG3_end_PSD, mctr1);
  rot_mul(mcrotaFunnel_1, mctr1, mcrotrFunnel_1);
  mctc1 = coords_set(
#line 772 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 772 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 772 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    Guide_extension + 3e-4);
#line 30244 "./SNS_BASIS.c"
  rot_transpose(mcrotaStraight_Guide_Section_III, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaFunnel_1 = coords_add(mcposaStraight_Guide_Section_III, mctc2);
  mctc1 = coords_sub(mcposaSG3_end_PSD, mcposaFunnel_1);
  mcposrFunnel_1 = rot_apply(mcrotaFunnel_1, mctc1);
  mcDEBUG_COMPONENT("Funnel_1", mcposaFunnel_1, mcrotaFunnel_1)
  mccomp_posa[104] = mcposaFunnel_1;
  mccomp_posr[104] = mcposrFunnel_1;
  mcNCounter[104]  = mcPCounter[104] = mcP2Counter[104] = 0;
  mcAbsorbProp[104]= 0;
    /* Component PSD_post_funnel1. */
  /* Setting parameters for component PSD_post_funnel1. */
  SIG_MESSAGE("PSD_post_funnel1 (Init:SetPar)");
#line 779 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel1_nx = 100;
#line 779 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel1_ny = 100;
#line 779 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("PSD_post_funnel1") strncpy(mccPSD_post_funnel1_filename, "PSD_post_funnel1" ? "PSD_post_funnel1" : "", 16384); else mccPSD_post_funnel1_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel1_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel1_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel1_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel1_ymax = 0.05;
#line 780 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel1_xwidth = 0.12;
#line 780 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel1_yheight = 0.12;
#line 780 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel1_restore_neutron = 1;
#line 30278 "./SNS_BASIS.c"

  SIG_MESSAGE("PSD_post_funnel1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 30285 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaFunnel_1, mcrotaPSD_post_funnel1);
  rot_transpose(mcrotaFunnel_1, mctr1);
  rot_mul(mcrotaPSD_post_funnel1, mctr1, mcrotrPSD_post_funnel1);
  mctc1 = coords_set(
#line 781 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 781 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 781 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1.5 + 1e-4);
#line 30296 "./SNS_BASIS.c"
  rot_transpose(mcrotaFunnel_1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPSD_post_funnel1 = coords_add(mcposaFunnel_1, mctc2);
  mctc1 = coords_sub(mcposaFunnel_1, mcposaPSD_post_funnel1);
  mcposrPSD_post_funnel1 = rot_apply(mcrotaPSD_post_funnel1, mctc1);
  mcDEBUG_COMPONENT("PSD_post_funnel1", mcposaPSD_post_funnel1, mcrotaPSD_post_funnel1)
  mccomp_posa[105] = mcposaPSD_post_funnel1;
  mccomp_posr[105] = mcposrPSD_post_funnel1;
  mcNCounter[105]  = mcPCounter[105] = mcP2Counter[105] = 0;
  mcAbsorbProp[105]= 0;
    /* Component Funnel_2. */
  /* Setting parameters for component Funnel_2. */
  SIG_MESSAGE("Funnel_2 (Init:SetPar)");
#line 785 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_w1 = 0.1;
#line 785 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_h1 = 0.1036;
#line 785 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_w2 = 0.074;
#line 785 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_h2 = 0.0762;
#line 785 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_l = 2.5;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_R0_left = 0.99;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_R0_right = 0.99;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_R0_top = 0.99;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_R0_bottom = 0.99;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_Qc_left = 0.0219;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_Qc_right = 0.0219;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_Qc_top = 0.0219;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_Qc_bottom = 0.0219;
#line 785 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_alpha_left = 2.222;
#line 785 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_alpha_right = 2.222;
#line 785 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_alpha_top = 2.222;
#line 785 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_alpha_bottom = 2.222;
#line 785 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_m_left = 2.5;
#line 785 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_m_right = 2.5;
#line 785 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_m_top = 2.5;
#line 785 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_m_bottom = 2.5;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_W_left = 0.003;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_W_right = 0.003;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_W_top = 0.003;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_2_W_bottom = 0.003;
#line 30360 "./SNS_BASIS.c"

  SIG_MESSAGE("Funnel_2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 30367 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaFunnel_1, mcrotaFunnel_2);
  rot_transpose(mcrotaPSD_post_funnel1, mctr1);
  rot_mul(mcrotaFunnel_2, mctr1, mcrotrFunnel_2);
  mctc1 = coords_set(
#line 786 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 786 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 786 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1.5 + 2e-4);
#line 30378 "./SNS_BASIS.c"
  rot_transpose(mcrotaFunnel_1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaFunnel_2 = coords_add(mcposaFunnel_1, mctc2);
  mctc1 = coords_sub(mcposaPSD_post_funnel1, mcposaFunnel_2);
  mcposrFunnel_2 = rot_apply(mcrotaFunnel_2, mctc1);
  mcDEBUG_COMPONENT("Funnel_2", mcposaFunnel_2, mcrotaFunnel_2)
  mccomp_posa[106] = mcposaFunnel_2;
  mccomp_posr[106] = mcposrFunnel_2;
  mcNCounter[106]  = mcPCounter[106] = mcP2Counter[106] = 0;
  mcAbsorbProp[106]= 0;
    /* Component PSD_post_funnel2. */
  /* Setting parameters for component PSD_post_funnel2. */
  SIG_MESSAGE("PSD_post_funnel2 (Init:SetPar)");
#line 793 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel2_nx = 100;
#line 793 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel2_ny = 100;
#line 793 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("PSD_post_funnel2") strncpy(mccPSD_post_funnel2_filename, "PSD_post_funnel2" ? "PSD_post_funnel2" : "", 16384); else mccPSD_post_funnel2_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel2_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel2_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel2_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel2_ymax = 0.05;
#line 794 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel2_xwidth = 0.10;
#line 794 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel2_yheight = 0.12;
#line 794 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel2_restore_neutron = 1;
#line 30412 "./SNS_BASIS.c"

  SIG_MESSAGE("PSD_post_funnel2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 30419 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaFunnel_2, mcrotaPSD_post_funnel2);
  rot_transpose(mcrotaFunnel_2, mctr1);
  rot_mul(mcrotaPSD_post_funnel2, mctr1, mcrotrPSD_post_funnel2);
  mctc1 = coords_set(
#line 795 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 795 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 795 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.5 + 1e-4);
#line 30430 "./SNS_BASIS.c"
  rot_transpose(mcrotaFunnel_2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPSD_post_funnel2 = coords_add(mcposaFunnel_2, mctc2);
  mctc1 = coords_sub(mcposaFunnel_2, mcposaPSD_post_funnel2);
  mcposrPSD_post_funnel2 = rot_apply(mcrotaPSD_post_funnel2, mctc1);
  mcDEBUG_COMPONENT("PSD_post_funnel2", mcposaPSD_post_funnel2, mcrotaPSD_post_funnel2)
  mccomp_posa[107] = mcposaPSD_post_funnel2;
  mccomp_posr[107] = mcposrPSD_post_funnel2;
  mcNCounter[107]  = mcPCounter[107] = mcP2Counter[107] = 0;
  mcAbsorbProp[107]= 0;
    /* Component Funnel_3. */
  /* Setting parameters for component Funnel_3. */
  SIG_MESSAGE("Funnel_3 (Init:SetPar)");
#line 798 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_w1 = 0.0740;
#line 798 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_h1 = 0.0762;
#line 798 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_w2 = 0.0663;
#line 798 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_h2 = 0.068;
#line 798 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_l = 0.75;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_R0_left = 0.99;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_R0_right = 0.99;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_R0_top = 0.99;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_R0_bottom = 0.99;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_Qc_left = 0.0219;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_Qc_right = 0.0219;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_Qc_top = 0.0219;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_Qc_bottom = 0.0219;
#line 798 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_alpha_left = 2.222;
#line 798 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_alpha_right = 2.222;
#line 798 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_alpha_top = 3.846;
#line 798 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_alpha_bottom = 3.846;
#line 798 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_m_left = 2.5;
#line 798 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_m_right = 2.5;
#line 798 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_m_top = 3.6;
#line 798 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_m_bottom = 3.6;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_W_left = 0.003;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_W_right = 0.003;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_W_top = 0.003;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_3_W_bottom = 0.003;
#line 30494 "./SNS_BASIS.c"

  SIG_MESSAGE("Funnel_3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 30501 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaFunnel_2, mcrotaFunnel_3);
  rot_transpose(mcrotaPSD_post_funnel2, mctr1);
  rot_mul(mcrotaFunnel_3, mctr1, mcrotrFunnel_3);
  mctc1 = coords_set(
#line 799 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 799 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 799 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.5 + 2e-4);
#line 30512 "./SNS_BASIS.c"
  rot_transpose(mcrotaFunnel_2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaFunnel_3 = coords_add(mcposaFunnel_2, mctc2);
  mctc1 = coords_sub(mcposaPSD_post_funnel2, mcposaFunnel_3);
  mcposrFunnel_3 = rot_apply(mcrotaFunnel_3, mctc1);
  mcDEBUG_COMPONENT("Funnel_3", mcposaFunnel_3, mcrotaFunnel_3)
  mccomp_posa[108] = mcposaFunnel_3;
  mccomp_posr[108] = mcposrFunnel_3;
  mcNCounter[108]  = mcPCounter[108] = mcP2Counter[108] = 0;
  mcAbsorbProp[108]= 0;
    /* Component PSD_post_funnel3. */
  /* Setting parameters for component PSD_post_funnel3. */
  SIG_MESSAGE("PSD_post_funnel3 (Init:SetPar)");
#line 806 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel3_nx = 100;
#line 806 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel3_ny = 100;
#line 806 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("PSD_post_funnel3") strncpy(mccPSD_post_funnel3_filename, "PSD_post_funnel3" ? "PSD_post_funnel3" : "", 16384); else mccPSD_post_funnel3_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel3_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel3_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel3_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel3_ymax = 0.05;
#line 807 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel3_xwidth = 0.10;
#line 807 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel3_yheight = 0.12;
#line 807 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel3_restore_neutron = 1;
#line 30546 "./SNS_BASIS.c"

  SIG_MESSAGE("PSD_post_funnel3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 30553 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaFunnel_3, mcrotaPSD_post_funnel3);
  rot_transpose(mcrotaFunnel_3, mctr1);
  rot_mul(mcrotaPSD_post_funnel3, mctr1, mcrotrPSD_post_funnel3);
  mctc1 = coords_set(
#line 808 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 808 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 808 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.75 + 1e-4);
#line 30564 "./SNS_BASIS.c"
  rot_transpose(mcrotaFunnel_3, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPSD_post_funnel3 = coords_add(mcposaFunnel_3, mctc2);
  mctc1 = coords_sub(mcposaFunnel_3, mcposaPSD_post_funnel3);
  mcposrPSD_post_funnel3 = rot_apply(mcrotaPSD_post_funnel3, mctc1);
  mcDEBUG_COMPONENT("PSD_post_funnel3", mcposaPSD_post_funnel3, mcrotaPSD_post_funnel3)
  mccomp_posa[109] = mcposaPSD_post_funnel3;
  mccomp_posr[109] = mcposrPSD_post_funnel3;
  mcNCounter[109]  = mcPCounter[109] = mcP2Counter[109] = 0;
  mcAbsorbProp[109]= 0;
    /* Component Funnel_4. */
  /* Setting parameters for component Funnel_4. */
  SIG_MESSAGE("Funnel_4 (Init:SetPar)");
#line 811 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_w1 = 0.0663;
#line 811 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_h1 = 0.0680;
#line 811 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_w2 = 0.0325;
#line 811 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_h2 = 0.0325;
#line 811 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_l = 3.25;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_R0_left = 0.99;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_R0_right = 0.99;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_R0_top = 0.99;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_R0_bottom = 0.99;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_Qc_left = 0.0219;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_Qc_right = 0.0219;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_Qc_top = 0.0219;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_Qc_bottom = 0.0219;
#line 811 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_alpha_left = 3.846;
#line 811 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_alpha_right = 3.846;
#line 811 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_alpha_top = 3.846;
#line 811 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_alpha_bottom = 3.846;
#line 811 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_m_left = 3.6;
#line 811 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_m_right = 3.6;
#line 811 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_m_top = 3.6;
#line 811 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_m_bottom = 3.6;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_W_left = 0.003;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_W_right = 0.003;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_W_top = 0.003;
#line 79 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccFunnel_4_W_bottom = 0.003;
#line 30628 "./SNS_BASIS.c"

  SIG_MESSAGE("Funnel_4 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 30635 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaFunnel_3, mcrotaFunnel_4);
  rot_transpose(mcrotaPSD_post_funnel3, mctr1);
  rot_mul(mcrotaFunnel_4, mctr1, mcrotrFunnel_4);
  mctc1 = coords_set(
#line 812 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 812 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 812 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.75 + 2e-4);
#line 30646 "./SNS_BASIS.c"
  rot_transpose(mcrotaFunnel_3, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaFunnel_4 = coords_add(mcposaFunnel_3, mctc2);
  mctc1 = coords_sub(mcposaPSD_post_funnel3, mcposaFunnel_4);
  mcposrFunnel_4 = rot_apply(mcrotaFunnel_4, mctc1);
  mcDEBUG_COMPONENT("Funnel_4", mcposaFunnel_4, mcrotaFunnel_4)
  mccomp_posa[110] = mcposaFunnel_4;
  mccomp_posr[110] = mcposrFunnel_4;
  mcNCounter[110]  = mcPCounter[110] = mcP2Counter[110] = 0;
  mcAbsorbProp[110]= 0;
    /* Component PSD_post_funnel4. */
  /* Setting parameters for component PSD_post_funnel4. */
  SIG_MESSAGE("PSD_post_funnel4 (Init:SetPar)");
#line 819 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel4_nx = 100;
#line 819 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel4_ny = 100;
#line 819 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("PSD_post_funnel4") strncpy(mccPSD_post_funnel4_filename, "PSD_post_funnel4" ? "PSD_post_funnel4" : "", 16384); else mccPSD_post_funnel4_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel4_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel4_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel4_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel4_ymax = 0.05;
#line 820 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel4_xwidth = 0.10;
#line 820 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel4_yheight = 0.12;
#line 820 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSD_post_funnel4_restore_neutron = 1;
#line 30680 "./SNS_BASIS.c"

  SIG_MESSAGE("PSD_post_funnel4 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 30687 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaFunnel_4, mcrotaPSD_post_funnel4);
  rot_transpose(mcrotaFunnel_4, mctr1);
  rot_mul(mcrotaPSD_post_funnel4, mctr1, mcrotrPSD_post_funnel4);
  mctc1 = coords_set(
#line 821 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 821 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 821 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    3.25 + 1e-4);
#line 30698 "./SNS_BASIS.c"
  rot_transpose(mcrotaFunnel_4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPSD_post_funnel4 = coords_add(mcposaFunnel_4, mctc2);
  mctc1 = coords_sub(mcposaFunnel_4, mcposaPSD_post_funnel4);
  mcposrPSD_post_funnel4 = rot_apply(mcrotaPSD_post_funnel4, mctc1);
  mcDEBUG_COMPONENT("PSD_post_funnel4", mcposaPSD_post_funnel4, mcrotaPSD_post_funnel4)
  mccomp_posa[111] = mcposaPSD_post_funnel4;
  mccomp_posr[111] = mcposrPSD_post_funnel4;
  mcNCounter[111]  = mcPCounter[111] = mcP2Counter[111] = 0;
  mcAbsorbProp[111]= 0;
    /* Component Guide_End_ToF. */
  /* Setting parameters for component Guide_End_ToF. */
  SIG_MESSAGE("Guide_End_ToF (Init:SetPar)");
#line 827 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(myfilename_4) strncpy(mccGuide_End_ToF_filename, myfilename_4 ? myfilename_4 : "", 16384); else mccGuide_End_ToF_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_ymax = 0.05;
#line 827 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_xwidth = 0.4;
#line 828 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_yheight = 0.4;
#line 828 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_tmin = 0;
#line 828 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_tmax = 300000;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_dt = 1.0;
#line 827 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_nowritefile = 0;
#line 30736 "./SNS_BASIS.c"

  SIG_MESSAGE("Guide_End_ToF (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 30743 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaFunnel_1, mcrotaGuide_End_ToF);
  rot_transpose(mcrotaPSD_post_funnel4, mctr1);
  rot_mul(mcrotaGuide_End_ToF, mctr1, mcrotrGuide_End_ToF);
  mctc1 = coords_set(
#line 829 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 829 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 829 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    8 + 1e-4);
#line 30754 "./SNS_BASIS.c"
  rot_transpose(mcrotaFunnel_1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGuide_End_ToF = coords_add(mcposaFunnel_1, mctc2);
  mctc1 = coords_sub(mcposaPSD_post_funnel4, mcposaGuide_End_ToF);
  mcposrGuide_End_ToF = rot_apply(mcrotaGuide_End_ToF, mctc1);
  mcDEBUG_COMPONENT("Guide_End_ToF", mcposaGuide_End_ToF, mcrotaGuide_End_ToF)
  mccomp_posa[112] = mcposaGuide_End_ToF;
  mccomp_posr[112] = mcposrGuide_End_ToF;
  mcNCounter[112]  = mcPCounter[112] = mcP2Counter[112] = 0;
  mcAbsorbProp[112]= 0;
    /* Component Guide_End_ToF_Z. */
  /* Setting parameters for component Guide_End_ToF_Z. */
  SIG_MESSAGE("Guide_End_ToF_Z (Init:SetPar)");
#line 832 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("Guide_End_ToF_Zoom") strncpy(mccGuide_End_ToF_Z_filename, "Guide_End_ToF_Zoom" ? "Guide_End_ToF_Zoom" : "", 16384); else mccGuide_End_ToF_Z_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_Z_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_Z_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_Z_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_Z_ymax = 0.05;
#line 832 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_Z_xwidth = 0.4;
#line 833 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_Z_yheight = 0.4;
#line 833 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_Z_tmin = 1.32e5;
#line 833 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_Z_tmax = 1.335e5;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_Z_dt = 1.0;
#line 832 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_Z_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_End_ToF_Z_nowritefile = 0;
#line 30792 "./SNS_BASIS.c"

  SIG_MESSAGE("Guide_End_ToF_Z (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 30799 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaFunnel_1, mcrotaGuide_End_ToF_Z);
  rot_transpose(mcrotaGuide_End_ToF, mctr1);
  rot_mul(mcrotaGuide_End_ToF_Z, mctr1, mcrotrGuide_End_ToF_Z);
  mctc1 = coords_set(
#line 834 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 834 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 834 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    8 + 2e-4);
#line 30810 "./SNS_BASIS.c"
  rot_transpose(mcrotaFunnel_1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGuide_End_ToF_Z = coords_add(mcposaFunnel_1, mctc2);
  mctc1 = coords_sub(mcposaGuide_End_ToF, mcposaGuide_End_ToF_Z);
  mcposrGuide_End_ToF_Z = rot_apply(mcrotaGuide_End_ToF_Z, mctc1);
  mcDEBUG_COMPONENT("Guide_End_ToF_Z", mcposaGuide_End_ToF_Z, mcrotaGuide_End_ToF_Z)
  mccomp_posa[113] = mcposaGuide_End_ToF_Z;
  mccomp_posr[113] = mcposrGuide_End_ToF_Z;
  mcNCounter[113]  = mcPCounter[113] = mcP2Counter[113] = 0;
  mcAbsorbProp[113]= 0;
    /* Component Guide_end_Lam. */
  /* Setting parameters for component Guide_end_Lam. */
  SIG_MESSAGE("Guide_end_Lam (Init:SetPar)");
#line 837 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(myfilename_5) strncpy(mccGuide_end_Lam_filename, myfilename_5 ? myfilename_5 : "", 16384); else mccGuide_end_Lam_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_Lam_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_Lam_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_Lam_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_Lam_ymax = 0.05;
#line 837 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_Lam_xwidth = 0.4;
#line 838 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_Lam_yheight = 0.4;
#line 838 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_Lam_Lmin = 0.5;
#line 838 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_Lam_Lmax = 30.0;
#line 837 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_Lam_restore_neutron = 1;
#line 51 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_Lam_nowritefile = 0;
#line 30846 "./SNS_BASIS.c"

  SIG_MESSAGE("Guide_end_Lam (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 30853 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGuide_End_ToF_Z, mcrotaGuide_end_Lam);
  rot_transpose(mcrotaGuide_End_ToF_Z, mctr1);
  rot_mul(mcrotaGuide_end_Lam, mctr1, mcrotrGuide_end_Lam);
  mctc1 = coords_set(
#line 839 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 839 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 839 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 30864 "./SNS_BASIS.c"
  rot_transpose(mcrotaGuide_End_ToF_Z, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGuide_end_Lam = coords_add(mcposaGuide_End_ToF_Z, mctc2);
  mctc1 = coords_sub(mcposaGuide_End_ToF_Z, mcposaGuide_end_Lam);
  mcposrGuide_end_Lam = rot_apply(mcrotaGuide_end_Lam, mctc1);
  mcDEBUG_COMPONENT("Guide_end_Lam", mcposaGuide_end_Lam, mcrotaGuide_end_Lam)
  mccomp_posa[114] = mcposaGuide_end_Lam;
  mccomp_posr[114] = mcposrGuide_end_Lam;
  mcNCounter[114]  = mcPCounter[114] = mcP2Counter[114] = 0;
  mcAbsorbProp[114]= 0;
    /* Component Guide_end_divx. */
  /* Setting parameters for component Guide_end_divx. */
  SIG_MESSAGE("Guide_end_divx (Init:SetPar)");
#line 842 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divx_xwidth = 0.10;
#line 842 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divx_yheight = 0.12;
#line 203 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divx_zdepth = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divx_xmin = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divx_xmax = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divx_ymin = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divx_ymax = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divx_zmin = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divx_zmax = 0;
#line 842 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divx_bins = 200;
#line 842 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divx_min = -5;
#line 842 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divx_max = 5;
#line 842 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divx_restore_neutron = 1;
#line 205 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divx_radius = 0;
#line 842 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("dx, Guide_end_divx") strncpy(mccGuide_end_divx_options, "dx, Guide_end_divx" ? "dx, Guide_end_divx" : "", 16384); else mccGuide_end_divx_options[0]='\0';
#line 206 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccGuide_end_divx_filename, "NULL" ? "NULL" : "", 16384); else mccGuide_end_divx_filename[0]='\0';
#line 206 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccGuide_end_divx_geometry, "NULL" ? "NULL" : "", 16384); else mccGuide_end_divx_geometry[0]='\0';
#line 207 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccGuide_end_divx_username1, "NULL" ? "NULL" : "", 16384); else mccGuide_end_divx_username1[0]='\0';
#line 207 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccGuide_end_divx_username2, "NULL" ? "NULL" : "", 16384); else mccGuide_end_divx_username2[0]='\0';
#line 207 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccGuide_end_divx_username3, "NULL" ? "NULL" : "", 16384); else mccGuide_end_divx_username3[0]='\0';
#line 208 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divx_nowritefile = 0;
#line 30920 "./SNS_BASIS.c"

  SIG_MESSAGE("Guide_end_divx (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 30927 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGuide_end_Lam, mcrotaGuide_end_divx);
  rot_transpose(mcrotaGuide_end_Lam, mctr1);
  rot_mul(mcrotaGuide_end_divx, mctr1, mcrotrGuide_end_divx);
  mctc1 = coords_set(
#line 843 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 843 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 843 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 30938 "./SNS_BASIS.c"
  rot_transpose(mcrotaGuide_end_Lam, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGuide_end_divx = coords_add(mcposaGuide_end_Lam, mctc2);
  mctc1 = coords_sub(mcposaGuide_end_Lam, mcposaGuide_end_divx);
  mcposrGuide_end_divx = rot_apply(mcrotaGuide_end_divx, mctc1);
  mcDEBUG_COMPONENT("Guide_end_divx", mcposaGuide_end_divx, mcrotaGuide_end_divx)
  mccomp_posa[115] = mcposaGuide_end_divx;
  mccomp_posr[115] = mcposrGuide_end_divx;
  mcNCounter[115]  = mcPCounter[115] = mcP2Counter[115] = 0;
  mcAbsorbProp[115]= 0;
    /* Component Guide_end_divy. */
  /* Setting parameters for component Guide_end_divy. */
  SIG_MESSAGE("Guide_end_divy (Init:SetPar)");
#line 846 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divy_xwidth = 0.10;
#line 846 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divy_yheight = 0.12;
#line 203 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divy_zdepth = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divy_xmin = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divy_xmax = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divy_ymin = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divy_ymax = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divy_zmin = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divy_zmax = 0;
#line 846 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divy_bins = 200;
#line 846 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divy_min = -5;
#line 846 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divy_max = 5;
#line 846 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divy_restore_neutron = 1;
#line 205 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divy_radius = 0;
#line 846 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("dy,Guide_end_divy") strncpy(mccGuide_end_divy_options, "dy,Guide_end_divy" ? "dy,Guide_end_divy" : "", 16384); else mccGuide_end_divy_options[0]='\0';
#line 206 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccGuide_end_divy_filename, "NULL" ? "NULL" : "", 16384); else mccGuide_end_divy_filename[0]='\0';
#line 206 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccGuide_end_divy_geometry, "NULL" ? "NULL" : "", 16384); else mccGuide_end_divy_geometry[0]='\0';
#line 207 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccGuide_end_divy_username1, "NULL" ? "NULL" : "", 16384); else mccGuide_end_divy_username1[0]='\0';
#line 207 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccGuide_end_divy_username2, "NULL" ? "NULL" : "", 16384); else mccGuide_end_divy_username2[0]='\0';
#line 207 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccGuide_end_divy_username3, "NULL" ? "NULL" : "", 16384); else mccGuide_end_divy_username3[0]='\0';
#line 208 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_divy_nowritefile = 0;
#line 30994 "./SNS_BASIS.c"

  SIG_MESSAGE("Guide_end_divy (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 31001 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGuide_end_divx, mcrotaGuide_end_divy);
  rot_transpose(mcrotaGuide_end_divx, mctr1);
  rot_mul(mcrotaGuide_end_divy, mctr1, mcrotrGuide_end_divy);
  mctc1 = coords_set(
#line 847 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 847 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 847 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 31012 "./SNS_BASIS.c"
  rot_transpose(mcrotaGuide_end_divx, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGuide_end_divy = coords_add(mcposaGuide_end_divx, mctc2);
  mctc1 = coords_sub(mcposaGuide_end_divx, mcposaGuide_end_divy);
  mcposrGuide_end_divy = rot_apply(mcrotaGuide_end_divy, mctc1);
  mcDEBUG_COMPONENT("Guide_end_divy", mcposaGuide_end_divy, mcrotaGuide_end_divy)
  mccomp_posa[116] = mcposaGuide_end_divy;
  mccomp_posr[116] = mcposrGuide_end_divy;
  mcNCounter[116]  = mcPCounter[116] = mcP2Counter[116] = 0;
  mcAbsorbProp[116]= 0;
    /* Component Guide_end_PSD. */
  /* Setting parameters for component Guide_end_PSD. */
  SIG_MESSAGE("Guide_end_PSD (Init:SetPar)");
#line 851 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_PSD_nx = 100;
#line 851 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_PSD_ny = 50;
#line 851 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(myfilename_6) strncpy(mccGuide_end_PSD_filename, myfilename_6 ? myfilename_6 : "", 16384); else mccGuide_end_PSD_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_PSD_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_PSD_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_PSD_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_PSD_ymax = 0.05;
#line 852 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_PSD_xwidth = 0.04;
#line 852 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_PSD_yheight = 0.04;
#line 852 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccGuide_end_PSD_restore_neutron = 1;
#line 31046 "./SNS_BASIS.c"

  SIG_MESSAGE("Guide_end_PSD (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 31053 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGuide_end_divy, mcrotaGuide_end_PSD);
  rot_transpose(mcrotaGuide_end_divy, mctr1);
  rot_mul(mcrotaGuide_end_PSD, mctr1, mcrotrGuide_end_PSD);
  mctc1 = coords_set(
#line 853 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 853 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 853 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 31064 "./SNS_BASIS.c"
  rot_transpose(mcrotaGuide_end_divy, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaGuide_end_PSD = coords_add(mcposaGuide_end_divy, mctc2);
  mctc1 = coords_sub(mcposaGuide_end_divy, mcposaGuide_end_PSD);
  mcposrGuide_end_PSD = rot_apply(mcrotaGuide_end_PSD, mctc1);
  mcDEBUG_COMPONENT("Guide_end_PSD", mcposaGuide_end_PSD, mcrotaGuide_end_PSD)
  mccomp_posa[117] = mcposaGuide_end_PSD;
  mccomp_posr[117] = mcposrGuide_end_PSD;
  mcNCounter[117]  = mcPCounter[117] = mcP2Counter[117] = 0;
  mcAbsorbProp[117]= 0;
    /* Component Sample_split. */
  /* Setting parameters for component Sample_split. */
  SIG_MESSAGE("Sample_split (Init:SetPar)");

  SIG_MESSAGE("Sample_split (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 31084 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaGuide_end_PSD, mcrotaSample_split);
  rot_transpose(mcrotaGuide_end_PSD, mctr1);
  rot_mul(mcrotaSample_split, mctr1, mcrotrSample_split);
  mctc1 = coords_set(
#line 865 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 865 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 865 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 31095 "./SNS_BASIS.c"
  rot_transpose(mcrotaGuide_end_PSD, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaSample_split = coords_add(mcposaGuide_end_PSD, mctc2);
  mctc1 = coords_sub(mcposaGuide_end_PSD, mcposaSample_split);
  mcposrSample_split = rot_apply(mcrotaSample_split, mctc1);
  mcDEBUG_COMPONENT("Sample_split", mcposaSample_split, mcrotaSample_split)
  mccomp_posa[118] = mcposaSample_split;
  mccomp_posr[118] = mcposrSample_split;
  mcNCounter[118]  = mcPCounter[118] = mcP2Counter[118] = 0;
  mcAbsorbProp[118]= 0;
    /* Component SamplePos. */
  /* Setting parameters for component SamplePos. */
  SIG_MESSAGE("SamplePos (Init:SetPar)");
#line 49 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSamplePos_nx = 90;
#line 49 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSamplePos_ny = 90;
#line 878 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("SampleFlux") strncpy(mccSamplePos_filename, "SampleFlux" ? "SampleFlux" : "", 16384); else mccSamplePos_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSamplePos_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSamplePos_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSamplePos_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSamplePos_ymax = 0.05;
#line 878 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSamplePos_xwidth = 0.05;
#line 878 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSamplePos_yheight = 0.05;
#line 878 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSamplePos_restore_neutron = 1;
#line 31129 "./SNS_BASIS.c"

  SIG_MESSAGE("SamplePos (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 31136 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaFunnel_4, mcrotaSamplePos);
  rot_transpose(mcrotaSample_split, mctr1);
  rot_mul(mcrotaSamplePos, mctr1, mcrotrSamplePos);
  mctc1 = coords_set(
#line 879 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 879 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 879 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    3.54);
#line 31147 "./SNS_BASIS.c"
  rot_transpose(mcrotaFunnel_4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaSamplePos = coords_add(mcposaFunnel_4, mctc2);
  mctc1 = coords_sub(mcposaSample_split, mcposaSamplePos);
  mcposrSamplePos = rot_apply(mcrotaSamplePos, mctc1);
  mcDEBUG_COMPONENT("SamplePos", mcposaSamplePos, mcrotaSamplePos)
  mccomp_posa[119] = mcposaSamplePos;
  mccomp_posr[119] = mcposrSamplePos;
  mcNCounter[119]  = mcPCounter[119] = mcP2Counter[119] = 0;
  mcAbsorbProp[119]= 0;
    /* Component Sample. */
  /* Setting parameters for component Sample. */
  SIG_MESSAGE("Sample (Init:SetPar)");
#line 270 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(0) strncpy(mccSample_Sqw_coh, 0 ? 0 : "", 16384); else mccSample_Sqw_coh[0]='\0';
#line 270 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(0) strncpy(mccSample_Sqw_inc, 0 ? 0 : "", 16384); else mccSample_Sqw_inc[0]='\0';
#line 270 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(0) strncpy(mccSample_geometry, 0 ? 0 : "", 16384); else mccSample_geometry[0]='\0';
#line 882 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_radius = 0.015;
#line 271 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_thickness = 0;
#line 272 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_xwidth = 0;
#line 882 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_yheight = 0.03;
#line 272 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_zdepth = 0;
#line 273 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_threshold = 1e-20;
#line 883 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_order = 1;
#line 273 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_T = 0;
#line 273 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_verbose = 1;
#line 883 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_d_phi = 18;
#line 273 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_concentric = 0;
#line 882 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_rho = 1 / 13.827;
#line 883 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_sigma_abs = 5.08;
#line 883 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_sigma_coh = 0;
#line 883 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_sigma_inc = 4.935;
#line 274 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_classical = -1;
#line 275 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_powder_Dd = 0;
#line 275 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_powder_DW = 0;
#line 275 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_powder_Vc = 0;
#line 275 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_density = 0;
#line 275 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_weight = 0;
#line 276 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_p_interact = -1;
#line 276 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_norm = -1;
#line 276 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccSample_powder_barns = 1;
#line 276 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("Frommhold") strncpy(mccSample_quantum_correction, "Frommhold" ? "Frommhold" : "", 16384); else mccSample_quantum_correction[0]='\0';
#line 31217 "./SNS_BASIS.c"

  SIG_MESSAGE("Sample (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 31224 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaFunnel_4, mcrotaSample);
  rot_transpose(mcrotaSamplePos, mctr1);
  rot_mul(mcrotaSample, mctr1, mcrotrSample);
  mctc1 = coords_set(
#line 884 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 884 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 884 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    3.54);
#line 31235 "./SNS_BASIS.c"
  rot_transpose(mcrotaFunnel_4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaSample = coords_add(mcposaFunnel_4, mctc2);
  mctc1 = coords_sub(mcposaSamplePos, mcposaSample);
  mcposrSample = rot_apply(mcrotaSample, mctc1);
  mcDEBUG_COMPONENT("Sample", mcposaSample, mcrotaSample)
  mccomp_posa[120] = mcposaSample;
  mccomp_posr[120] = mcposrSample;
  mcNCounter[120]  = mcPCounter[120] = mcP2Counter[120] = 0;
  mcAbsorbProp[120]= 0;
    /* Component An1_rot_axis. */
  /* Setting parameters for component An1_rot_axis. */
  SIG_MESSAGE("An1_rot_axis (Init:SetPar)");

  SIG_MESSAGE("An1_rot_axis (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 901 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 901 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (mcipROT1)*DEG2RAD,
#line 901 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 31258 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaSample, mcrotaAn1_rot_axis);
  rot_transpose(mcrotaSample, mctr1);
  rot_mul(mcrotaAn1_rot_axis, mctr1, mcrotrAn1_rot_axis);
  mctc1 = coords_set(
#line 900 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 900 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 900 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0);
#line 31269 "./SNS_BASIS.c"
  rot_transpose(mcrotaSample, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAn1_rot_axis = coords_add(mcposaSample, mctc2);
  mctc1 = coords_sub(mcposaSample, mcposaAn1_rot_axis);
  mcposrAn1_rot_axis = rot_apply(mcrotaAn1_rot_axis, mctc1);
  mcDEBUG_COMPONENT("An1_rot_axis", mcposaAn1_rot_axis, mcrotaAn1_rot_axis)
  mccomp_posa[121] = mcposaAn1_rot_axis;
  mccomp_posr[121] = mcposrAn1_rot_axis;
  mcNCounter[121]  = mcPCounter[121] = mcP2Counter[121] = 0;
  mcAbsorbProp[121]= 0;
    /* Component An2_rot_axis. */
  /* Setting parameters for component An2_rot_axis. */
  SIG_MESSAGE("An2_rot_axis (Init:SetPar)");

  SIG_MESSAGE("An2_rot_axis (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 905 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 905 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (mcipROT1 - mcipdROT)*DEG2RAD,
#line 905 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 31292 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaSample, mcrotaAn2_rot_axis);
  rot_transpose(mcrotaAn1_rot_axis, mctr1);
  rot_mul(mcrotaAn2_rot_axis, mctr1, mcrotrAn2_rot_axis);
  mctc1 = coords_set(
#line 904 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 904 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 904 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0);
#line 31303 "./SNS_BASIS.c"
  rot_transpose(mcrotaSample, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAn2_rot_axis = coords_add(mcposaSample, mctc2);
  mctc1 = coords_sub(mcposaAn1_rot_axis, mcposaAn2_rot_axis);
  mcposrAn2_rot_axis = rot_apply(mcrotaAn2_rot_axis, mctc1);
  mcDEBUG_COMPONENT("An2_rot_axis", mcposaAn2_rot_axis, mcrotaAn2_rot_axis)
  mccomp_posa[122] = mcposaAn2_rot_axis;
  mccomp_posr[122] = mcposrAn2_rot_axis;
  mcNCounter[122]  = mcPCounter[122] = mcP2Counter[122] = 0;
  mcAbsorbProp[122]= 0;
    /* Component An3_rot_axis. */
  /* Setting parameters for component An3_rot_axis. */
  SIG_MESSAGE("An3_rot_axis (Init:SetPar)");

  SIG_MESSAGE("An3_rot_axis (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 909 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 909 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (mcipROT1 + mcipdROT)*DEG2RAD,
#line 909 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 31326 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaSample, mcrotaAn3_rot_axis);
  rot_transpose(mcrotaAn2_rot_axis, mctr1);
  rot_mul(mcrotaAn3_rot_axis, mctr1, mcrotrAn3_rot_axis);
  mctc1 = coords_set(
#line 908 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 908 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 908 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0);
#line 31337 "./SNS_BASIS.c"
  rot_transpose(mcrotaSample, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAn3_rot_axis = coords_add(mcposaSample, mctc2);
  mctc1 = coords_sub(mcposaAn2_rot_axis, mcposaAn3_rot_axis);
  mcposrAn3_rot_axis = rot_apply(mcrotaAn3_rot_axis, mctc1);
  mcDEBUG_COMPONENT("An3_rot_axis", mcposaAn3_rot_axis, mcrotaAn3_rot_axis)
  mccomp_posa[123] = mcposaAn3_rot_axis;
  mccomp_posr[123] = mcposrAn3_rot_axis;
  mcNCounter[123]  = mcPCounter[123] = mcP2Counter[123] = 0;
  mcAbsorbProp[123]= 0;
    /* Component An1_ToF. */
  /* Setting parameters for component An1_ToF. */
  SIG_MESSAGE("An1_ToF (Init:SetPar)");
#line 912 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(myfilename_7) strncpy(mccAn1_ToF_filename, myfilename_7 ? myfilename_7 : "", 16384); else mccAn1_ToF_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_ymax = 0.05;
#line 912 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_xwidth = 0.4;
#line 913 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_yheight = 0.4;
#line 913 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_tmin = 0;
#line 913 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_tmax = 300000;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_dt = 1.0;
#line 912 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_nowritefile = 0;
#line 31375 "./SNS_BASIS.c"

  SIG_MESSAGE("An1_ToF (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 31382 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaAn1_rot_axis, mcrotaAn1_ToF);
  rot_transpose(mcrotaAn3_rot_axis, mctr1);
  rot_mul(mcrotaAn1_ToF, mctr1, mcrotrAn1_ToF);
  mctc1 = coords_set(
#line 914 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 914 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 914 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.49);
#line 31393 "./SNS_BASIS.c"
  rot_transpose(mcrotaAn1_rot_axis, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAn1_ToF = coords_add(mcposaAn1_rot_axis, mctc2);
  mctc1 = coords_sub(mcposaAn3_rot_axis, mcposaAn1_ToF);
  mcposrAn1_ToF = rot_apply(mcrotaAn1_ToF, mctc1);
  mcDEBUG_COMPONENT("An1_ToF", mcposaAn1_ToF, mcrotaAn1_ToF)
  mccomp_posa[124] = mcposaAn1_ToF;
  mccomp_posr[124] = mcposrAn1_ToF;
  mcNCounter[124]  = mcPCounter[124] = mcP2Counter[124] = 0;
  mcAbsorbProp[124]= 0;
    /* Component An1_ToF_variable_range. */
  /* Setting parameters for component An1_ToF_variable_range. */
  SIG_MESSAGE("An1_ToF_variable_range (Init:SetPar)");
#line 917 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(myfilename_8) strncpy(mccAn1_ToF_variable_range_filename, myfilename_8 ? myfilename_8 : "", 16384); else mccAn1_ToF_variable_range_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_variable_range_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_variable_range_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_variable_range_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_variable_range_ymax = 0.05;
#line 917 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_variable_range_xwidth = 0.4;
#line 918 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_variable_range_yheight = 0.4;
#line 918 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_variable_range_tmin = 1.362e5;
#line 918 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_variable_range_tmax = 1.38e5;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_variable_range_dt = 1.0;
#line 917 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_variable_range_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ToF_variable_range_nowritefile = 0;
#line 31431 "./SNS_BASIS.c"

  SIG_MESSAGE("An1_ToF_variable_range (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 31438 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaAn1_ToF, mcrotaAn1_ToF_variable_range);
  rot_transpose(mcrotaAn1_ToF, mctr1);
  rot_mul(mcrotaAn1_ToF_variable_range, mctr1, mcrotrAn1_ToF_variable_range);
  mctc1 = coords_set(
#line 919 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 919 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 919 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2e-4);
#line 31449 "./SNS_BASIS.c"
  rot_transpose(mcrotaAn1_ToF, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAn1_ToF_variable_range = coords_add(mcposaAn1_ToF, mctc2);
  mctc1 = coords_sub(mcposaAn1_ToF, mcposaAn1_ToF_variable_range);
  mcposrAn1_ToF_variable_range = rot_apply(mcrotaAn1_ToF_variable_range, mctc1);
  mcDEBUG_COMPONENT("An1_ToF_variable_range", mcposaAn1_ToF_variable_range, mcrotaAn1_ToF_variable_range)
  mccomp_posa[125] = mcposaAn1_ToF_variable_range;
  mccomp_posr[125] = mcposrAn1_ToF_variable_range;
  mcNCounter[125]  = mcPCounter[125] = mcP2Counter[125] = 0;
  mcAbsorbProp[125]= 0;
    /* Component An1_Lam. */
  /* Setting parameters for component An1_Lam. */
  SIG_MESSAGE("An1_Lam (Init:SetPar)");
#line 922 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(myfilename_9) strncpy(mccAn1_Lam_filename, myfilename_9 ? myfilename_9 : "", 16384); else mccAn1_Lam_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_Lam_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_Lam_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_Lam_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_Lam_ymax = 0.05;
#line 922 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_Lam_xwidth = 0.4;
#line 923 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_Lam_yheight = 0.4;
#line 923 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_Lam_Lmin = 2.0;
#line 923 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_Lam_Lmax = 10.0;
#line 922 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_Lam_restore_neutron = 1;
#line 51 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_Lam_nowritefile = 0;
#line 31485 "./SNS_BASIS.c"

  SIG_MESSAGE("An1_Lam (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 31492 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaAn1_ToF, mcrotaAn1_Lam);
  rot_transpose(mcrotaAn1_ToF_variable_range, mctr1);
  rot_mul(mcrotaAn1_Lam, mctr1, mcrotrAn1_Lam);
  mctc1 = coords_set(
#line 924 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 924 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 924 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2e-4);
#line 31503 "./SNS_BASIS.c"
  rot_transpose(mcrotaAn1_ToF, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAn1_Lam = coords_add(mcposaAn1_ToF, mctc2);
  mctc1 = coords_sub(mcposaAn1_ToF_variable_range, mcposaAn1_Lam);
  mcposrAn1_Lam = rot_apply(mcrotaAn1_Lam, mctc1);
  mcDEBUG_COMPONENT("An1_Lam", mcposaAn1_Lam, mcrotaAn1_Lam)
  mccomp_posa[126] = mcposaAn1_Lam;
  mccomp_posr[126] = mcposrAn1_Lam;
  mcNCounter[126]  = mcPCounter[126] = mcP2Counter[126] = 0;
  mcAbsorbProp[126]= 0;
    /* Component An1_Lam_variable_range. */
  /* Setting parameters for component An1_Lam_variable_range. */
  SIG_MESSAGE("An1_Lam_variable_range (Init:SetPar)");
#line 927 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(myfilename_10) strncpy(mccAn1_Lam_variable_range_filename, myfilename_10 ? myfilename_10 : "", 16384); else mccAn1_Lam_variable_range_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_Lam_variable_range_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_Lam_variable_range_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_Lam_variable_range_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_Lam_variable_range_ymax = 0.05;
#line 927 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_Lam_variable_range_xwidth = 0.4;
#line 928 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_Lam_variable_range_yheight = 0.4;
#line 928 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_Lam_variable_range_Lmin = 0.1;
#line 928 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_Lam_variable_range_Lmax = 40.0;
#line 927 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_Lam_variable_range_restore_neutron = 1;
#line 51 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_Lam_variable_range_nowritefile = 0;
#line 31539 "./SNS_BASIS.c"

  SIG_MESSAGE("An1_Lam_variable_range (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 31546 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaAn1_ToF, mcrotaAn1_Lam_variable_range);
  rot_transpose(mcrotaAn1_Lam, mctr1);
  rot_mul(mcrotaAn1_Lam_variable_range, mctr1, mcrotrAn1_Lam_variable_range);
  mctc1 = coords_set(
#line 929 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 929 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 929 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    3e-4);
#line 31557 "./SNS_BASIS.c"
  rot_transpose(mcrotaAn1_ToF, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAn1_Lam_variable_range = coords_add(mcposaAn1_ToF, mctc2);
  mctc1 = coords_sub(mcposaAn1_Lam, mcposaAn1_Lam_variable_range);
  mcposrAn1_Lam_variable_range = rot_apply(mcrotaAn1_Lam_variable_range, mctc1);
  mcDEBUG_COMPONENT("An1_Lam_variable_range", mcposaAn1_Lam_variable_range, mcrotaAn1_Lam_variable_range)
  mccomp_posa[127] = mcposaAn1_Lam_variable_range;
  mccomp_posr[127] = mcposrAn1_Lam_variable_range;
  mcNCounter[127]  = mcPCounter[127] = mcP2Counter[127] = 0;
  mcAbsorbProp[127]= 0;
    /* Component An1_E. */
  /* Setting parameters for component An1_E. */
  SIG_MESSAGE("An1_E (Init:SetPar)");
#line 932 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(myfilename_11) strncpy(mccAn1_E_filename, myfilename_11 ? myfilename_11 : "", 16384); else mccAn1_E_filename[0]='\0';
#line 931 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_E_xmin = -0.05;
#line 931 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_E_xmax = 0.05;
#line 931 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_E_ymin = -0.1;
#line 931 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_E_ymax = 0.1;
#line 54 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_E_xwidth = 0;
#line 54 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_E_yheight = 0;
#line 932 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_E_Emin = 1.0;
#line 932 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_E_Emax = 6.0;
#line 932 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_E_restore_neutron = 1;
#line 54 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_E_nowritefile = 0;
#line 31593 "./SNS_BASIS.c"

  SIG_MESSAGE("An1_E (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 31600 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaAn1_Lam, mcrotaAn1_E);
  rot_transpose(mcrotaAn1_Lam_variable_range, mctr1);
  rot_mul(mcrotaAn1_E, mctr1, mcrotrAn1_E);
  mctc1 = coords_set(
#line 933 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 933 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 933 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    1e-4);
#line 31611 "./SNS_BASIS.c"
  rot_transpose(mcrotaAn1_Lam, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAn1_E = coords_add(mcposaAn1_Lam, mctc2);
  mctc1 = coords_sub(mcposaAn1_Lam_variable_range, mcposaAn1_E);
  mcposrAn1_E = rot_apply(mcrotaAn1_E, mctc1);
  mcDEBUG_COMPONENT("An1_E", mcposaAn1_E, mcrotaAn1_E)
  mccomp_posa[128] = mcposaAn1_E;
  mccomp_posr[128] = mcposrAn1_E;
  mcNCounter[128]  = mcPCounter[128] = mcP2Counter[128] = 0;
  mcAbsorbProp[128]= 0;
    /* Component An1_E_variable_range. */
  /* Setting parameters for component An1_E_variable_range. */
  SIG_MESSAGE("An1_E_variable_range (Init:SetPar)");
#line 936 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(myfilename_12) strncpy(mccAn1_E_variable_range_filename, myfilename_12 ? myfilename_12 : "", 16384); else mccAn1_E_variable_range_filename[0]='\0';
#line 935 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_E_variable_range_xmin = -0.05;
#line 935 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_E_variable_range_xmax = 0.05;
#line 935 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_E_variable_range_ymin = -0.1;
#line 935 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_E_variable_range_ymax = 0.1;
#line 54 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_E_variable_range_xwidth = 0;
#line 54 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_E_variable_range_yheight = 0;
#line 936 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_E_variable_range_Emin = 1.0;
#line 936 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_E_variable_range_Emax = 6.0;
#line 936 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_E_variable_range_restore_neutron = 1;
#line 54 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_E_variable_range_nowritefile = 0;
#line 31647 "./SNS_BASIS.c"

  SIG_MESSAGE("An1_E_variable_range (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 31654 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaAn1_Lam, mcrotaAn1_E_variable_range);
  rot_transpose(mcrotaAn1_E, mctr1);
  rot_mul(mcrotaAn1_E_variable_range, mctr1, mcrotrAn1_E_variable_range);
  mctc1 = coords_set(
#line 937 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 937 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 937 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2e-4);
#line 31665 "./SNS_BASIS.c"
  rot_transpose(mcrotaAn1_Lam, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAn1_E_variable_range = coords_add(mcposaAn1_Lam, mctc2);
  mctc1 = coords_sub(mcposaAn1_E, mcposaAn1_E_variable_range);
  mcposrAn1_E_variable_range = rot_apply(mcrotaAn1_E_variable_range, mctc1);
  mcDEBUG_COMPONENT("An1_E_variable_range", mcposaAn1_E_variable_range, mcrotaAn1_E_variable_range)
  mccomp_posa[129] = mcposaAn1_E_variable_range;
  mccomp_posr[129] = mcposrAn1_E_variable_range;
  mcNCounter[129]  = mcPCounter[129] = mcP2Counter[129] = 0;
  mcAbsorbProp[129]= 0;
    /* Component An1_rot_axis2. */
  /* Setting parameters for component An1_rot_axis2. */
  SIG_MESSAGE("An1_rot_axis2 (Init:SetPar)");

  SIG_MESSAGE("An1_rot_axis2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 941 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (mcipAN_ROT)*DEG2RAD,
#line 941 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 941 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 31688 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaAn1_rot_axis, mcrotaAn1_rot_axis2);
  rot_transpose(mcrotaAn1_E_variable_range, mctr1);
  rot_mul(mcrotaAn1_rot_axis2, mctr1, mcrotrAn1_rot_axis2);
  mctc1 = coords_set(
#line 940 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 940 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 940 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.5);
#line 31699 "./SNS_BASIS.c"
  rot_transpose(mcrotaAn1_rot_axis, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAn1_rot_axis2 = coords_add(mcposaAn1_rot_axis, mctc2);
  mctc1 = coords_sub(mcposaAn1_E_variable_range, mcposaAn1_rot_axis2);
  mcposrAn1_rot_axis2 = rot_apply(mcrotaAn1_rot_axis2, mctc1);
  mcDEBUG_COMPONENT("An1_rot_axis2", mcposaAn1_rot_axis2, mcrotaAn1_rot_axis2)
  mccomp_posa[130] = mcposaAn1_rot_axis2;
  mccomp_posr[130] = mcposrAn1_rot_axis2;
  mcNCounter[130]  = mcPCounter[130] = mcP2Counter[130] = 0;
  mcAbsorbProp[130]= 0;
    /* Component An2_rot_axis2. */
  /* Setting parameters for component An2_rot_axis2. */
  SIG_MESSAGE("An2_rot_axis2 (Init:SetPar)");

  SIG_MESSAGE("An2_rot_axis2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 945 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (mcipAN_ROT)*DEG2RAD,
#line 945 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 945 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 31722 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaAn2_rot_axis, mcrotaAn2_rot_axis2);
  rot_transpose(mcrotaAn1_rot_axis2, mctr1);
  rot_mul(mcrotaAn2_rot_axis2, mctr1, mcrotrAn2_rot_axis2);
  mctc1 = coords_set(
#line 944 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 944 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 944 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.5);
#line 31733 "./SNS_BASIS.c"
  rot_transpose(mcrotaAn2_rot_axis, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAn2_rot_axis2 = coords_add(mcposaAn2_rot_axis, mctc2);
  mctc1 = coords_sub(mcposaAn1_rot_axis2, mcposaAn2_rot_axis2);
  mcposrAn2_rot_axis2 = rot_apply(mcrotaAn2_rot_axis2, mctc1);
  mcDEBUG_COMPONENT("An2_rot_axis2", mcposaAn2_rot_axis2, mcrotaAn2_rot_axis2)
  mccomp_posa[131] = mcposaAn2_rot_axis2;
  mccomp_posr[131] = mcposrAn2_rot_axis2;
  mcNCounter[131]  = mcPCounter[131] = mcP2Counter[131] = 0;
  mcAbsorbProp[131]= 0;
    /* Component An3_rot_axis2. */
  /* Setting parameters for component An3_rot_axis2. */
  SIG_MESSAGE("An3_rot_axis2 (Init:SetPar)");

  SIG_MESSAGE("An3_rot_axis2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 949 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (mcipAN_ROT)*DEG2RAD,
#line 949 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 949 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 31756 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaAn3_rot_axis, mcrotaAn3_rot_axis2);
  rot_transpose(mcrotaAn2_rot_axis2, mctr1);
  rot_mul(mcrotaAn3_rot_axis2, mctr1, mcrotrAn3_rot_axis2);
  mctc1 = coords_set(
#line 948 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 948 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 948 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.5);
#line 31767 "./SNS_BASIS.c"
  rot_transpose(mcrotaAn3_rot_axis, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAn3_rot_axis2 = coords_add(mcposaAn3_rot_axis, mctc2);
  mctc1 = coords_sub(mcposaAn2_rot_axis2, mcposaAn3_rot_axis2);
  mcposrAn3_rot_axis2 = rot_apply(mcrotaAn3_rot_axis2, mctc1);
  mcDEBUG_COMPONENT("An3_rot_axis2", mcposaAn3_rot_axis2, mcrotaAn3_rot_axis2)
  mccomp_posa[132] = mcposaAn3_rot_axis2;
  mccomp_posr[132] = mcposrAn3_rot_axis2;
  mcNCounter[132]  = mcPCounter[132] = mcP2Counter[132] = 0;
  mcAbsorbProp[132]= 0;
    /* Component An1. */
  /* Setting parameters for component An1. */
  SIG_MESSAGE("An1 (Init:SetPar)");
#line 953 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_xmin = -0.235;
#line 953 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_xmax = 0.235;
#line 953 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ymin = -0.49;
#line 953 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_ymax = 0.49;
#line 954 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_mosaic = 0.0;
#line 954 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_dspread = 0.00035;
#line 954 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_Q = q_si111;
#line 41 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_DM = 0;
#line 954 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_radius = 2.5;
#line 41 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_f_doppler = 0;
#line 41 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_A_doppler = 0;
#line 954 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_R0 = 1;
#line 954 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn1_debug = 0;
#line 31807 "./SNS_BASIS.c"

  SIG_MESSAGE("An1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 31814 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaAn1_rot_axis2, mcrotaAn1);
  rot_transpose(mcrotaAn3_rot_axis2, mctr1);
  rot_mul(mcrotaAn1, mctr1, mcrotrAn1);
  mctc1 = coords_set(
#line 955 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 955 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 955 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0);
#line 31825 "./SNS_BASIS.c"
  rot_transpose(mcrotaAn1_rot_axis2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAn1 = coords_add(mcposaAn1_rot_axis2, mctc2);
  mctc1 = coords_sub(mcposaAn3_rot_axis2, mcposaAn1);
  mcposrAn1 = rot_apply(mcrotaAn1, mctc1);
  mcDEBUG_COMPONENT("An1", mcposaAn1, mcrotaAn1)
  mccomp_posa[133] = mcposaAn1;
  mccomp_posr[133] = mcposrAn1;
  mcNCounter[133]  = mcPCounter[133] = mcP2Counter[133] = 0;
  mcAbsorbProp[133]= 0;
    /* Component An2. */
  /* Setting parameters for component An2. */
  SIG_MESSAGE("An2 (Init:SetPar)");
#line 959 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn2_xmin = -0.235;
#line 959 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn2_xmax = 0.235;
#line 959 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn2_ymin = -0.49;
#line 959 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn2_ymax = 0.49;
#line 960 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn2_mosaic = 0.0;
#line 960 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn2_dspread = 0.00035;
#line 960 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn2_Q = q_si111;
#line 41 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn2_DM = 0;
#line 960 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn2_radius = 2.5;
#line 41 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn2_f_doppler = 0;
#line 41 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn2_A_doppler = 0;
#line 960 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn2_R0 = 1;
#line 960 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn2_debug = 0;
#line 31865 "./SNS_BASIS.c"

  SIG_MESSAGE("An2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 31872 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaAn2_rot_axis2, mcrotaAn2);
  rot_transpose(mcrotaAn1, mctr1);
  rot_mul(mcrotaAn2, mctr1, mcrotrAn2);
  mctc1 = coords_set(
#line 961 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 961 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 961 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0);
#line 31883 "./SNS_BASIS.c"
  rot_transpose(mcrotaAn2_rot_axis2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAn2 = coords_add(mcposaAn2_rot_axis2, mctc2);
  mctc1 = coords_sub(mcposaAn1, mcposaAn2);
  mcposrAn2 = rot_apply(mcrotaAn2, mctc1);
  mcDEBUG_COMPONENT("An2", mcposaAn2, mcrotaAn2)
  mccomp_posa[134] = mcposaAn2;
  mccomp_posr[134] = mcposrAn2;
  mcNCounter[134]  = mcPCounter[134] = mcP2Counter[134] = 0;
  mcAbsorbProp[134]= 0;
    /* Component An3. */
  /* Setting parameters for component An3. */
  SIG_MESSAGE("An3 (Init:SetPar)");
#line 965 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn3_xmin = -0.235;
#line 965 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn3_xmax = 0.235;
#line 965 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn3_ymin = -0.49;
#line 965 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn3_ymax = 0.49;
#line 966 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn3_mosaic = 0.0;
#line 966 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn3_dspread = 0.00035;
#line 966 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn3_Q = q_si111;
#line 41 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn3_DM = 0;
#line 966 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn3_radius = 2.5;
#line 41 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn3_f_doppler = 0;
#line 41 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn3_A_doppler = 0;
#line 966 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn3_R0 = 1;
#line 966 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccAn3_debug = 0;
#line 31923 "./SNS_BASIS.c"

  SIG_MESSAGE("An3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 31930 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaAn3_rot_axis2, mcrotaAn3);
  rot_transpose(mcrotaAn2, mctr1);
  rot_mul(mcrotaAn3, mctr1, mcrotrAn3);
  mctc1 = coords_set(
#line 967 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 967 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 967 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0);
#line 31941 "./SNS_BASIS.c"
  rot_transpose(mcrotaAn3_rot_axis2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAn3 = coords_add(mcposaAn3_rot_axis2, mctc2);
  mctc1 = coords_sub(mcposaAn2, mcposaAn3);
  mcposrAn3 = rot_apply(mcrotaAn3, mctc1);
  mcDEBUG_COMPONENT("An3", mcposaAn3, mcrotaAn3)
  mccomp_posa[135] = mcposaAn3;
  mccomp_posr[135] = mcposrAn3;
  mcNCounter[135]  = mcPCounter[135] = mcP2Counter[135] = 0;
  mcAbsorbProp[135]= 0;
    /* Component ArmForDet1. */
  /* Setting parameters for component ArmForDet1. */
  SIG_MESSAGE("ArmForDet1 (Init:SetPar)");

  SIG_MESSAGE("ArmForDet1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 975 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (180 + mcipAN_ROT)*DEG2RAD,
#line 975 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD,
#line 975 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    (0)*DEG2RAD);
#line 31964 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaAn1, mcrotaArmForDet1);
  rot_transpose(mcrotaAn3, mctr1);
  rot_mul(mcrotaArmForDet1, mctr1, mcrotrArmForDet1);
  mctc1 = coords_set(
#line 974 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 974 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 974 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0);
#line 31975 "./SNS_BASIS.c"
  rot_transpose(mcrotaAn1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaArmForDet1 = coords_add(mcposaAn1, mctc2);
  mctc1 = coords_sub(mcposaAn3, mcposaArmForDet1);
  mcposrArmForDet1 = rot_apply(mcrotaArmForDet1, mctc1);
  mcDEBUG_COMPONENT("ArmForDet1", mcposaArmForDet1, mcrotaArmForDet1)
  mccomp_posa[136] = mcposaArmForDet1;
  mccomp_posr[136] = mcposrArmForDet1;
  mcNCounter[136]  = mcPCounter[136] = mcP2Counter[136] = 0;
  mcAbsorbProp[136]= 0;
    /* Component Det1_E. */
  /* Setting parameters for component Det1_E. */
  SIG_MESSAGE("Det1_E (Init:SetPar)");
#line 978 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(myfilename_13) strncpy(mccDet1_E_filename, myfilename_13 ? myfilename_13 : "", 16384); else mccDet1_E_filename[0]='\0';
#line 977 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_E_xmin = -0.025;
#line 977 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_E_xmax = 0.025;
#line 977 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_E_ymin = -0.025;
#line 977 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_E_ymax = 0.025;
#line 54 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_E_xwidth = 0;
#line 54 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_E_yheight = 0;
#line 978 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_E_Emin = 2.05;
#line 978 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_E_Emax = 2.12;
#line 978 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_E_restore_neutron = 1;
#line 54 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_E_nowritefile = 0;
#line 32011 "./SNS_BASIS.c"

  SIG_MESSAGE("Det1_E (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 32018 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaArmForDet1, mcrotaDet1_E);
  rot_transpose(mcrotaArmForDet1, mctr1);
  rot_mul(mcrotaDet1_E, mctr1, mcrotrDet1_E);
  mctc1 = coords_set(
#line 979 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 979 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 979 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.23);
#line 32029 "./SNS_BASIS.c"
  rot_transpose(mcrotaArmForDet1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDet1_E = coords_add(mcposaArmForDet1, mctc2);
  mctc1 = coords_sub(mcposaArmForDet1, mcposaDet1_E);
  mcposrDet1_E = rot_apply(mcrotaDet1_E, mctc1);
  mcDEBUG_COMPONENT("Det1_E", mcposaDet1_E, mcrotaDet1_E)
  mccomp_posa[137] = mcposaDet1_E;
  mccomp_posr[137] = mcposrDet1_E;
  mcNCounter[137]  = mcPCounter[137] = mcP2Counter[137] = 0;
  mcAbsorbProp[137]= 0;
    /* Component Det1_E_variable_range. */
  /* Setting parameters for component Det1_E_variable_range. */
  SIG_MESSAGE("Det1_E_variable_range (Init:SetPar)");
#line 982 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(myfilename_14) strncpy(mccDet1_E_variable_range_filename, myfilename_14 ? myfilename_14 : "", 16384); else mccDet1_E_variable_range_filename[0]='\0';
#line 981 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_E_variable_range_xmin = -0.025;
#line 981 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_E_variable_range_xmax = 0.025;
#line 981 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_E_variable_range_ymin = -0.025;
#line 981 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_E_variable_range_ymax = 0.025;
#line 54 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_E_variable_range_xwidth = 0;
#line 54 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_E_variable_range_yheight = 0;
#line 982 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_E_variable_range_Emin = 2.077;
#line 982 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_E_variable_range_Emax = 2.092;
#line 982 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_E_variable_range_restore_neutron = 1;
#line 54 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_E_variable_range_nowritefile = 0;
#line 32065 "./SNS_BASIS.c"

  SIG_MESSAGE("Det1_E_variable_range (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 32072 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaArmForDet1, mcrotaDet1_E_variable_range);
  rot_transpose(mcrotaDet1_E, mctr1);
  rot_mul(mcrotaDet1_E_variable_range, mctr1, mcrotrDet1_E_variable_range);
  mctc1 = coords_set(
#line 983 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 983 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 983 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.23);
#line 32083 "./SNS_BASIS.c"
  rot_transpose(mcrotaArmForDet1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDet1_E_variable_range = coords_add(mcposaArmForDet1, mctc2);
  mctc1 = coords_sub(mcposaDet1_E, mcposaDet1_E_variable_range);
  mcposrDet1_E_variable_range = rot_apply(mcrotaDet1_E_variable_range, mctc1);
  mcDEBUG_COMPONENT("Det1_E_variable_range", mcposaDet1_E_variable_range, mcrotaDet1_E_variable_range)
  mccomp_posa[138] = mcposaDet1_E_variable_range;
  mccomp_posr[138] = mcposrDet1_E_variable_range;
  mcNCounter[138]  = mcPCounter[138] = mcP2Counter[138] = 0;
  mcAbsorbProp[138]= 0;
    /* Component Det1_Lam. */
  /* Setting parameters for component Det1_Lam. */
  SIG_MESSAGE("Det1_Lam (Init:SetPar)");
#line 986 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(myfilename_15) strncpy(mccDet1_Lam_filename, myfilename_15 ? myfilename_15 : "", 16384); else mccDet1_Lam_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_Lam_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_Lam_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_Lam_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_Lam_ymax = 0.05;
#line 986 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_Lam_xwidth = 0.05;
#line 987 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_Lam_yheight = 0.2;
#line 987 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_Lam_Lmin = 4.267;
#line 987 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_Lam_Lmax = 8.267;
#line 986 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_Lam_restore_neutron = 1;
#line 51 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_Lam_nowritefile = 0;
#line 32119 "./SNS_BASIS.c"

  SIG_MESSAGE("Det1_Lam (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 32126 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaArmForDet1, mcrotaDet1_Lam);
  rot_transpose(mcrotaDet1_E_variable_range, mctr1);
  rot_mul(mcrotaDet1_Lam, mctr1, mcrotrDet1_Lam);
  mctc1 = coords_set(
#line 988 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 988 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 988 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.2302);
#line 32137 "./SNS_BASIS.c"
  rot_transpose(mcrotaArmForDet1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDet1_Lam = coords_add(mcposaArmForDet1, mctc2);
  mctc1 = coords_sub(mcposaDet1_E_variable_range, mcposaDet1_Lam);
  mcposrDet1_Lam = rot_apply(mcrotaDet1_Lam, mctc1);
  mcDEBUG_COMPONENT("Det1_Lam", mcposaDet1_Lam, mcrotaDet1_Lam)
  mccomp_posa[139] = mcposaDet1_Lam;
  mccomp_posr[139] = mcposrDet1_Lam;
  mcNCounter[139]  = mcPCounter[139] = mcP2Counter[139] = 0;
  mcAbsorbProp[139]= 0;
    /* Component Det1_Lam_variable_range. */
  /* Setting parameters for component Det1_Lam_variable_range. */
  SIG_MESSAGE("Det1_Lam_variable_range (Init:SetPar)");
#line 991 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(myfilename_16) strncpy(mccDet1_Lam_variable_range_filename, myfilename_16 ? myfilename_16 : "", 16384); else mccDet1_Lam_variable_range_filename[0]='\0';
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_Lam_variable_range_xmin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_Lam_variable_range_xmax = 0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_Lam_variable_range_ymin = -0.05;
#line 50 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_Lam_variable_range_ymax = 0.05;
#line 991 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_Lam_variable_range_xwidth = 0.05;
#line 992 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_Lam_variable_range_yheight = 0.2;
#line 992 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_Lam_variable_range_Lmin = 6.1;
#line 992 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_Lam_variable_range_Lmax = 6.3;
#line 991 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_Lam_variable_range_restore_neutron = 1;
#line 51 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_Lam_variable_range_nowritefile = 0;
#line 32173 "./SNS_BASIS.c"

  SIG_MESSAGE("Det1_Lam_variable_range (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 32180 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaArmForDet1, mcrotaDet1_Lam_variable_range);
  rot_transpose(mcrotaDet1_Lam, mctr1);
  rot_mul(mcrotaDet1_Lam_variable_range, mctr1, mcrotrDet1_Lam_variable_range);
  mctc1 = coords_set(
#line 993 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 993 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 993 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.2302);
#line 32191 "./SNS_BASIS.c"
  rot_transpose(mcrotaArmForDet1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDet1_Lam_variable_range = coords_add(mcposaArmForDet1, mctc2);
  mctc1 = coords_sub(mcposaDet1_Lam, mcposaDet1_Lam_variable_range);
  mcposrDet1_Lam_variable_range = rot_apply(mcrotaDet1_Lam_variable_range, mctc1);
  mcDEBUG_COMPONENT("Det1_Lam_variable_range", mcposaDet1_Lam_variable_range, mcrotaDet1_Lam_variable_range)
  mccomp_posa[140] = mcposaDet1_Lam_variable_range;
  mccomp_posr[140] = mcposrDet1_Lam_variable_range;
  mcNCounter[140]  = mcPCounter[140] = mcP2Counter[140] = 0;
  mcAbsorbProp[140]= 0;
    /* Component Det1_ToF. */
  /* Setting parameters for component Det1_ToF. */
  SIG_MESSAGE("Det1_ToF (Init:SetPar)");
#line 996 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(myfilename_17) strncpy(mccDet1_ToF_filename, myfilename_17 ? myfilename_17 : "", 16384); else mccDet1_ToF_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_ymax = 0.05;
#line 996 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_xwidth = 0.05;
#line 997 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_yheight = 0.2;
#line 997 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_tmin = 130000;
#line 997 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_tmax = 150000;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_dt = 1.0;
#line 996 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_nowritefile = 0;
#line 32229 "./SNS_BASIS.c"

  SIG_MESSAGE("Det1_ToF (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 32236 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaArmForDet1, mcrotaDet1_ToF);
  rot_transpose(mcrotaDet1_Lam_variable_range, mctr1);
  rot_mul(mcrotaDet1_ToF, mctr1, mcrotrDet1_ToF);
  mctc1 = coords_set(
#line 998 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 998 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 998 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.2306);
#line 32247 "./SNS_BASIS.c"
  rot_transpose(mcrotaArmForDet1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDet1_ToF = coords_add(mcposaArmForDet1, mctc2);
  mctc1 = coords_sub(mcposaDet1_Lam_variable_range, mcposaDet1_ToF);
  mcposrDet1_ToF = rot_apply(mcrotaDet1_ToF, mctc1);
  mcDEBUG_COMPONENT("Det1_ToF", mcposaDet1_ToF, mcrotaDet1_ToF)
  mccomp_posa[141] = mcposaDet1_ToF;
  mccomp_posr[141] = mcposrDet1_ToF;
  mcNCounter[141]  = mcPCounter[141] = mcP2Counter[141] = 0;
  mcAbsorbProp[141]= 0;
    /* Component Det1_ToF_variable_range. */
  /* Setting parameters for component Det1_ToF_variable_range. */
  SIG_MESSAGE("Det1_ToF_variable_range (Init:SetPar)");
#line 1001 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(myfilename_18) strncpy(mccDet1_ToF_variable_range_filename, myfilename_18 ? myfilename_18 : "", 16384); else mccDet1_ToF_variable_range_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_ymax = 0.05;
#line 1001 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_xwidth = 0.05;
#line 1002 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_yheight = 0.2;
#line 1002 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_tmin = 100000;
#line 1002 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_tmax = 160000;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_dt = 1.0;
#line 1001 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_nowritefile = 0;
#line 32285 "./SNS_BASIS.c"

  SIG_MESSAGE("Det1_ToF_variable_range (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 32292 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaArmForDet1, mcrotaDet1_ToF_variable_range);
  rot_transpose(mcrotaDet1_ToF, mctr1);
  rot_mul(mcrotaDet1_ToF_variable_range, mctr1, mcrotrDet1_ToF_variable_range);
  mctc1 = coords_set(
#line 1003 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 1003 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 1003 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.2306);
#line 32303 "./SNS_BASIS.c"
  rot_transpose(mcrotaArmForDet1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDet1_ToF_variable_range = coords_add(mcposaArmForDet1, mctc2);
  mctc1 = coords_sub(mcposaDet1_ToF, mcposaDet1_ToF_variable_range);
  mcposrDet1_ToF_variable_range = rot_apply(mcrotaDet1_ToF_variable_range, mctc1);
  mcDEBUG_COMPONENT("Det1_ToF_variable_range", mcposaDet1_ToF_variable_range, mcrotaDet1_ToF_variable_range)
  mccomp_posa[142] = mcposaDet1_ToF_variable_range;
  mccomp_posr[142] = mcposrDet1_ToF_variable_range;
  mcNCounter[142]  = mcPCounter[142] = mcP2Counter[142] = 0;
  mcAbsorbProp[142]= 0;
    /* Component Det1_ToF_variable_range_lessnL. */
  /* Setting parameters for component Det1_ToF_variable_range_lessnL. */
  SIG_MESSAGE("Det1_ToF_variable_range_lessnL (Init:SetPar)");
#line 1006 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if(myfilename_19) strncpy(mccDet1_ToF_variable_range_lessnL_filename, myfilename_19 ? myfilename_19 : "", 16384); else mccDet1_ToF_variable_range_lessnL_filename[0]='\0';
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_lessnL_xmin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_lessnL_xmax = 0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_lessnL_ymin = -0.05;
#line 47 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_lessnL_ymax = 0.05;
#line 1006 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_lessnL_xwidth = 0.05;
#line 1007 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_lessnL_yheight = 0.2;
#line 1007 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_lessnL_tmin = 140200;
#line 1007 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_lessnL_tmax = 141000;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_lessnL_dt = 1.0;
#line 1006 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_lessnL_restore_neutron = 1;
#line 48 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccDet1_ToF_variable_range_lessnL_nowritefile = 0;
#line 32341 "./SNS_BASIS.c"

  SIG_MESSAGE("Det1_ToF_variable_range_lessnL (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 32348 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaArmForDet1, mcrotaDet1_ToF_variable_range_lessnL);
  rot_transpose(mcrotaDet1_ToF_variable_range, mctr1);
  rot_mul(mcrotaDet1_ToF_variable_range_lessnL, mctr1, mcrotrDet1_ToF_variable_range_lessnL);
  mctc1 = coords_set(
#line 1008 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 1008 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 1008 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    2.2306);
#line 32359 "./SNS_BASIS.c"
  rot_transpose(mcrotaArmForDet1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDet1_ToF_variable_range_lessnL = coords_add(mcposaArmForDet1, mctc2);
  mctc1 = coords_sub(mcposaDet1_ToF_variable_range, mcposaDet1_ToF_variable_range_lessnL);
  mcposrDet1_ToF_variable_range_lessnL = rot_apply(mcrotaDet1_ToF_variable_range_lessnL, mctc1);
  mcDEBUG_COMPONENT("Det1_ToF_variable_range_lessnL", mcposaDet1_ToF_variable_range_lessnL, mcrotaDet1_ToF_variable_range_lessnL)
  mccomp_posa[143] = mcposaDet1_ToF_variable_range_lessnL;
  mccomp_posr[143] = mcposrDet1_ToF_variable_range_lessnL;
  mcNCounter[143]  = mcPCounter[143] = mcP2Counter[143] = 0;
  mcAbsorbProp[143]= 0;
    /* Component PSDcyl. */
  /* Setting parameters for component PSDcyl. */
  SIG_MESSAGE("PSDcyl (Init:SetPar)");
#line 203 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSDcyl_xwidth = 0;
#line 1010 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSDcyl_yheight = 0.4;
#line 203 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSDcyl_zdepth = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSDcyl_xmin = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSDcyl_xmax = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSDcyl_ymin = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSDcyl_ymax = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSDcyl_zmin = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSDcyl_zmax = 0;
#line 205 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSDcyl_bins = 0;
#line 205 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSDcyl_min = -1e40;
#line 205 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSDcyl_max = 1e40;
#line 205 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSDcyl_restore_neutron = 0;
#line 1010 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSDcyl_radius = 0.27;
#line 1010 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("theta bins=180 limits=[0 180], y bins=201,   incoming") strncpy(mccPSDcyl_options, "theta bins=180 limits=[0 180], y bins=201,   incoming" ? "theta bins=180 limits=[0 180], y bins=201,   incoming" : "", 16384); else mccPSDcyl_options[0]='\0';
#line 1010 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("PSDcyl") strncpy(mccPSDcyl_filename, "PSDcyl" ? "PSDcyl" : "", 16384); else mccPSDcyl_filename[0]='\0';
#line 206 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccPSDcyl_geometry, "NULL" ? "NULL" : "", 16384); else mccPSDcyl_geometry[0]='\0';
#line 207 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccPSDcyl_username1, "NULL" ? "NULL" : "", 16384); else mccPSDcyl_username1[0]='\0';
#line 207 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccPSDcyl_username2, "NULL" ? "NULL" : "", 16384); else mccPSDcyl_username2[0]='\0';
#line 207 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccPSDcyl_username3, "NULL" ? "NULL" : "", 16384); else mccPSDcyl_username3[0]='\0';
#line 208 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccPSDcyl_nowritefile = 0;
#line 32415 "./SNS_BASIS.c"

  SIG_MESSAGE("PSDcyl (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 32422 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaSample, mcrotaPSDcyl);
  rot_transpose(mcrotaDet1_ToF_variable_range_lessnL, mctr1);
  rot_mul(mcrotaPSDcyl, mctr1, mcrotrPSDcyl);
  mctc1 = coords_set(
#line 1011 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 1011 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.1,
#line 1011 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0);
#line 32433 "./SNS_BASIS.c"
  rot_transpose(mcrotaSample, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPSDcyl = coords_add(mcposaSample, mctc2);
  mctc1 = coords_sub(mcposaDet1_ToF_variable_range_lessnL, mcposaPSDcyl);
  mcposrPSDcyl = rot_apply(mcrotaPSDcyl, mctc1);
  mcDEBUG_COMPONENT("PSDcyl", mcposaPSDcyl, mcrotaPSDcyl)
  mccomp_posa[144] = mcposaPSDcyl;
  mccomp_posr[144] = mcposrPSDcyl;
  mcNCounter[144]  = mcPCounter[144] = mcP2Counter[144] = 0;
  mcAbsorbProp[144]= 0;
    /* Component TOFcyl. */
  /* Setting parameters for component TOFcyl. */
  SIG_MESSAGE("TOFcyl (Init:SetPar)");
#line 203 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccTOFcyl_xwidth = 0;
#line 1013 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccTOFcyl_yheight = 0.4;
#line 203 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccTOFcyl_zdepth = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccTOFcyl_xmin = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccTOFcyl_xmax = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccTOFcyl_ymin = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccTOFcyl_ymax = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccTOFcyl_zmin = 0;
#line 204 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccTOFcyl_zmax = 0;
#line 205 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccTOFcyl_bins = 0;
#line 205 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccTOFcyl_min = -1e40;
#line 205 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccTOFcyl_max = 1e40;
#line 205 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccTOFcyl_restore_neutron = 0;
#line 1013 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccTOFcyl_radius = 0.2699;
#line 1013 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("auto q, t limits=[0.140200 0.141000] bins=500, incoming") strncpy(mccTOFcyl_options, "auto q, t limits=[0.140200 0.141000] bins=500, incoming" ? "auto q, t limits=[0.140200 0.141000] bins=500, incoming" : "", 16384); else mccTOFcyl_options[0]='\0';
#line 1013 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("TOFcyl") strncpy(mccTOFcyl_filename, "TOFcyl" ? "TOFcyl" : "", 16384); else mccTOFcyl_filename[0]='\0';
#line 206 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccTOFcyl_geometry, "NULL" ? "NULL" : "", 16384); else mccTOFcyl_geometry[0]='\0';
#line 207 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccTOFcyl_username1, "NULL" ? "NULL" : "", 16384); else mccTOFcyl_username1[0]='\0';
#line 207 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccTOFcyl_username2, "NULL" ? "NULL" : "", 16384); else mccTOFcyl_username2[0]='\0';
#line 207 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if("NULL") strncpy(mccTOFcyl_username3, "NULL" ? "NULL" : "", 16384); else mccTOFcyl_username3[0]='\0';
#line 208 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  mccTOFcyl_nowritefile = 0;
#line 32489 "./SNS_BASIS.c"

  SIG_MESSAGE("TOFcyl (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 32496 "./SNS_BASIS.c"
  rot_mul(mctr1, mcrotaSample, mcrotaTOFcyl);
  rot_transpose(mcrotaPSDcyl, mctr1);
  rot_mul(mcrotaTOFcyl, mctr1, mcrotrTOFcyl);
  mctc1 = coords_set(
#line 1014 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0,
#line 1014 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0.1,
#line 1014 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
    0);
#line 32507 "./SNS_BASIS.c"
  rot_transpose(mcrotaSample, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaTOFcyl = coords_add(mcposaSample, mctc2);
  mctc1 = coords_sub(mcposaPSDcyl, mcposaTOFcyl);
  mcposrTOFcyl = rot_apply(mcrotaTOFcyl, mctc1);
  mcDEBUG_COMPONENT("TOFcyl", mcposaTOFcyl, mcrotaTOFcyl)
  mccomp_posa[145] = mcposaTOFcyl;
  mccomp_posr[145] = mcposrTOFcyl;
  mcNCounter[145]  = mcPCounter[145] = mcP2Counter[145] = 0;
  mcAbsorbProp[145]= 0;
  /* Component initializations. */
  /* Initializations for component Origin. */
  SIG_MESSAGE("Origin (Init)");
#define mccompcurname  Origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccOrigin_IntermediateCnts
#define StartTime mccOrigin_StartTime
#define EndTime mccOrigin_EndTime
#define CurrentTime mccOrigin_CurrentTime
#define profile mccOrigin_profile
#define percent mccOrigin_percent
#define flag_save mccOrigin_flag_save
#define minutes mccOrigin_minutes
#line 57 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../misc/Progress_bar.comp"
{
IntermediateCnts=0;
StartTime=0;
EndTime=0;
CurrentTime=0;

fprintf(stdout, "[%s] Initialize\n", mcinstrument_name);
  if (percent*mcget_ncount()/100 < 1e5) {
    percent=1e5*100.0/mcget_ncount();
  }
}
#line 32544 "./SNS_BASIS.c"
#undef minutes
#undef flag_save
#undef percent
#undef profile
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Source. */
  SIG_MESSAGE("Source (Init)");
#define mccompcurname  Source
#define mccompcurtype  ESS_moderator_short
#define mccompcurindex 2
#define l_range mccSource_l_range
#define w_mult mccSource_w_mult
#define size mccSource_size
#define Lmin mccSource_Lmin
#define Lmax mccSource_Lmax
#define dist mccSource_dist
#define focus_xw mccSource_focus_xw
#define focus_yh mccSource_focus_yh
#define nu mccSource_nu
#define T mccSource_T
#define tau mccSource_tau
#define tau1 mccSource_tau1
#define tau2 mccSource_tau2
#define n mccSource_n
#define n2 mccSource_n2
#define chi2 mccSource_chi2
#define I0 mccSource_I0
#define I2 mccSource_I2
#define branch1 mccSource_branch1
#define branch2 mccSource_branch2
#define branchframe mccSource_branchframe
#define target_index mccSource_target_index
#line 119 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../obsolete/ESS_moderator_short.comp"
{
  if (target_index && !dist)
  {
    Coords ToTarget;
    double tx,ty,tz;
    ToTarget = coords_sub(POS_A_COMP_INDEX(INDEX_CURRENT_COMP+target_index),POS_A_CURRENT_COMP);
    ToTarget = rot_apply(ROT_A_CURRENT_COMP, ToTarget);
    coords_get(ToTarget, &tx, &ty, &tz);
    dist=sqrt(tx*tx+ty*ty+tz*tz);
  }

  if (n == 1 || n2 == 1 || Lmin<=0 || Lmax <=0 || dist == 0
    || branch1 == 1 || branch2 == 1 || tau == 0)
  {
    printf("ESS_moderator_short: %s: Check parameters (lead to Math Error).\n Avoid 0 value for {Lmin Lmax dist tau} and 1 value for {n n2 branch1/2/frame}\n", NAME_CURRENT_COMP);
    exit(-1);
  }

  Delta_t = 1.0/(double)nu;
  l_range = Lmax-Lmin;
  w_mult = size*size*1.0e4;     /* source area correction */
  w_mult *= l_range;            /* wavelength range correction */
  w_mult *= 1.0/mcget_ncount();  /* Flux value */
}
#line 32609 "./SNS_BASIS.c"
#undef target_index
#undef branchframe
#undef branch2
#undef branch1
#undef I2
#undef I0
#undef chi2
#undef n2
#undef n
#undef tau2
#undef tau1
#undef tau
#undef T
#undef nu
#undef focus_yh
#undef focus_xw
#undef dist
#undef Lmax
#undef Lmin
#undef size
#undef w_mult
#undef l_range
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component tofSTART. */
  SIG_MESSAGE("tofSTART (Init)");
#define mccompcurname  tofSTART
#define mccompcurtype  TOF_monitor
#define mccompcurindex 3
#define nt mcctofSTART_nt
#define TOF_N mcctofSTART_TOF_N
#define TOF_p mcctofSTART_TOF_p
#define TOF_p2 mcctofSTART_TOF_p2
#define t_min mcctofSTART_t_min
#define t_max mcctofSTART_t_max
#define delta_t mcctofSTART_delta_t
#define filename mcctofSTART_filename
#define xmin mcctofSTART_xmin
#define xmax mcctofSTART_xmax
#define ymin mcctofSTART_ymin
#define ymax mcctofSTART_ymax
#define xwidth mcctofSTART_xwidth
#define yheight mcctofSTART_yheight
#define tmin mcctofSTART_tmin
#define tmax mcctofSTART_tmax
#define dt mcctofSTART_dt
#define restore_neutron mcctofSTART_restore_neutron
#define nowritefile mcctofSTART_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 32693 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Source_Lam. */
  SIG_MESSAGE("Source_Lam (Init)");
#define mccompcurname  Source_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 4
#define nL mccSource_Lam_nL
#define L_N mccSource_Lam_L_N
#define L_p mccSource_Lam_L_p
#define L_p2 mccSource_Lam_L_p2
#define filename mccSource_Lam_filename
#define xmin mccSource_Lam_xmin
#define xmax mccSource_Lam_xmax
#define ymin mccSource_Lam_ymin
#define ymax mccSource_Lam_ymax
#define xwidth mccSource_Lam_xwidth
#define yheight mccSource_Lam_yheight
#define Lmin mccSource_Lam_Lmin
#define Lmax mccSource_Lam_Lmax
#define restore_neutron mccSource_Lam_restore_neutron
#define nowritefile mccSource_Lam_nowritefile
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 32758 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Source_En. */
  SIG_MESSAGE("Source_En (Init)");
#define mccompcurname  Source_En
#define mccompcurtype  E_monitor
#define mccompcurindex 5
#define nE mccSource_En_nE
#define E_N mccSource_En_E_N
#define E_p mccSource_En_E_p
#define E_p2 mccSource_En_E_p2
#define S_p mccSource_En_S_p
#define S_pE mccSource_En_S_pE
#define S_pE2 mccSource_En_S_pE2
#define filename mccSource_En_filename
#define xmin mccSource_En_xmin
#define xmax mccSource_En_xmax
#define ymin mccSource_En_ymin
#define ymax mccSource_En_ymax
#define xwidth mccSource_En_xwidth
#define yheight mccSource_En_yheight
#define Emin mccSource_En_Emin
#define Emax mccSource_En_Emax
#define restore_neutron mccSource_En_restore_neutron
#define nowritefile mccSource_En_nowritefile
#line 66 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("E_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nE; i++)
    {
      E_N[i] = 0;
      E_p[i] = 0;
      E_p2[i] = 0;
    }
    S_p = S_pE = S_pE2 = 0;
}
#line 32823 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap0_start. */
  SIG_MESSAGE("Gap0_start (Init)");
#define mccompcurname  Gap0_start
#define mccompcurtype  PSD_monitor
#define mccompcurindex 6
#define PSD_N mccGap0_start_PSD_N
#define PSD_p mccGap0_start_PSD_p
#define PSD_p2 mccGap0_start_PSD_p2
#define nx mccGap0_start_nx
#define ny mccGap0_start_ny
#define filename mccGap0_start_filename
#define xmin mccGap0_start_xmin
#define xmax mccGap0_start_xmax
#define ymin mccGap0_start_ymin
#define ymax mccGap0_start_ymax
#define xwidth mccGap0_start_xwidth
#define yheight mccGap0_start_yheight
#define restore_neutron mccGap0_start_restore_neutron
#line 68 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
  if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

  if ((xmin >= xmax) || (ymin >= ymax)){
    printf("PSD_monitor: %s: Null detection area !\n"
           "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
    NAME_CURRENT_COMP);
    exit(0);
  }

  PSD_N = create_darr2d(nx, ny);
  PSD_p = create_darr2d(nx, ny);
  PSD_p2 = create_darr2d(nx, ny);

  int i, j;
  for (i=0; i<nx; i++){
    for (j=0; j<ny; j++){
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
    }
  }
}
#line 32889 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap0_end_Lam. */
  SIG_MESSAGE("Gap0_end_Lam (Init)");
#define mccompcurname  Gap0_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 7
#define nL mccGap0_end_Lam_nL
#define L_N mccGap0_end_Lam_L_N
#define L_p mccGap0_end_Lam_L_p
#define L_p2 mccGap0_end_Lam_L_p2
#define filename mccGap0_end_Lam_filename
#define xmin mccGap0_end_Lam_xmin
#define xmax mccGap0_end_Lam_xmax
#define ymin mccGap0_end_Lam_ymin
#define ymax mccGap0_end_Lam_ymax
#define xwidth mccGap0_end_Lam_xwidth
#define yheight mccGap0_end_Lam_yheight
#define Lmin mccGap0_end_Lam_Lmin
#define Lmax mccGap0_end_Lam_Lmax
#define restore_neutron mccGap0_end_Lam_restore_neutron
#define nowritefile mccGap0_end_Lam_nowritefile
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 32948 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap0_end_divx. */
  SIG_MESSAGE("Gap0_end_divx (Init)");
#define mccompcurname  Gap0_end_divx
#define mccompcurtype  Monitor_nD
#define mccompcurindex 8
#define user1 mccGap0_end_divx_user1
#define user2 mccGap0_end_divx_user2
#define user3 mccGap0_end_divx_user3
#define DEFS mccGap0_end_divx_DEFS
#define Vars mccGap0_end_divx_Vars
#define detector mccGap0_end_divx_detector
#define offdata mccGap0_end_divx_offdata
#define xwidth mccGap0_end_divx_xwidth
#define yheight mccGap0_end_divx_yheight
#define zdepth mccGap0_end_divx_zdepth
#define xmin mccGap0_end_divx_xmin
#define xmax mccGap0_end_divx_xmax
#define ymin mccGap0_end_divx_ymin
#define ymax mccGap0_end_divx_ymax
#define zmin mccGap0_end_divx_zmin
#define zmax mccGap0_end_divx_zmax
#define bins mccGap0_end_divx_bins
#define min mccGap0_end_divx_min
#define max mccGap0_end_divx_max
#define restore_neutron mccGap0_end_divx_restore_neutron
#define radius mccGap0_end_divx_radius
#define options mccGap0_end_divx_options
#define filename mccGap0_end_divx_filename
#define geometry mccGap0_end_divx_geometry
#define username1 mccGap0_end_divx_username1
#define username2 mccGap0_end_divx_username2
#define username3 mccGap0_end_divx_username3
#define nowritefile mccGap0_end_divx_nowritefile
#line 230 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  char tmp[CHAR_BUF_LENGTH];
  strcpy(Vars.compcurname, NAME_CURRENT_COMP);
  if (options != NULL)
    strncpy(Vars.option, options, CHAR_BUF_LENGTH);
  else {
    strcpy(Vars.option, "x y");
    printf("Monitor_nD: %s has no option specified. Setting to PSD ('x y') monitor.\n", NAME_CURRENT_COMP);
  }
  Vars.compcurpos = POS_A_CURRENT_COMP;

  if (strstr(Vars.option, "source"))
    strcat(Vars.option, " list, x y z vx vy vz t sx sy sz ");

  if (bins) { sprintf(tmp, " all bins=%ld ", (long)bins); strcat(Vars.option, tmp); }
  if (min > -FLT_MAX && max < FLT_MAX) { sprintf(tmp, " all limits=[%g %g]", min, max); strcat(Vars.option, tmp); }
  else if (min > -FLT_MAX) { sprintf(tmp, " all min=%g", min); strcat(Vars.option, tmp); }
  else if (max <  FLT_MAX) { sprintf(tmp, " all max=%g", max); strcat(Vars.option, tmp); }

  strncpy(Vars.UserName1,
    username1 && strlen(username1) && strcmp(username1, "0") && strcmp(username1, "NULL") ?
    username1 : "", 128);
  strncpy(Vars.UserName2,
    username2 && strlen(username2) && strcmp(username2, "0") && strcmp(username2, "NULL") ?
    username2 : "", 128);
  strncpy(Vars.UserName3,
    username3 && strlen(username3) && strcmp(username3, "0") && strcmp(username3, "NULL") ?
    username3 : "", 128);
  if (radius) {
    xwidth = zdepth = 2*radius;
    if (yheight && !strstr(Vars.option, "cylinder") && !strstr(Vars.option, "banana") && !strstr(Vars.option, "sphere"))
      strcat(Vars.option, " banana");
    else if (!yheight && !strstr(Vars.option ,"sphere")) {
      strcat(Vars.option, " sphere");
      yheight=2*radius;
    }
  }
  int offflag=0;
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) {
    if (!off_init(  geometry, xwidth, yheight, zdepth, 1, &offdata )) {
      printf("Monitor_nD: %s could not initiate the OFF geometry %s. \n"
             "            Defaulting to normal Monitor dimensions.\n",
             NAME_CURRENT_COMP, geometry);
      strcpy(geometry, "");
    } else {
      offflag=1;
    }
  }

  if (!radius && !xwidth && !yheight && !zdepth && !xmin && !xmax && !ymin && !ymax &&
    !strstr(Vars.option, "previous") && (!geometry || !strlen(geometry)))
    exit(printf("Monitor_nD: %s has no dimension specified. Aborting (radius, xwidth, yheight, zdepth, previous, geometry).\n", NAME_CURRENT_COMP));

  Monitor_nD_Init(&DEFS, &Vars, xwidth, yheight, zdepth, xmin,xmax,ymin,ymax,zmin,zmax,offflag);

  if (Vars.Flag_OFF) {
    offdata.mantidflag=Vars.Flag_mantid;
    offdata.mantidoffset=Vars.Coord_Min[Vars.Coord_Number-1];
  }


  if (filename && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
    strncpy(Vars.Mon_File, filename, 128);

  /* check if user given filename with ext will be used more than once */
  if ( ((Vars.Flag_Multiple && Vars.Coord_Number > 1) || Vars.Flag_List) && strchr(Vars.Mon_File,'.') )
  { char *XY; XY = strrchr(Vars.Mon_File,'.'); *XY='_'; }

  if (restore_neutron) Vars.Flag_parallel=1;
  detector.m = 0;

#ifdef USE_MPI
MPI_MASTER(
  if (strstr(Vars.option, "auto") && mpi_node_count > 1)
    printf("Monitor_nD: %s is using automatic limits option 'auto' together with MPI.\n"
           "WARNING     this may create incorrect distributions (but integrated flux will be right).\n", NAME_CURRENT_COMP);
);
#endif
}
#line 33081 "./SNS_BASIS.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap0_end_divy. */
  SIG_MESSAGE("Gap0_end_divy (Init)");
#define mccompcurname  Gap0_end_divy
#define mccompcurtype  Monitor_nD
#define mccompcurindex 9
#define user1 mccGap0_end_divy_user1
#define user2 mccGap0_end_divy_user2
#define user3 mccGap0_end_divy_user3
#define DEFS mccGap0_end_divy_DEFS
#define Vars mccGap0_end_divy_Vars
#define detector mccGap0_end_divy_detector
#define offdata mccGap0_end_divy_offdata
#define xwidth mccGap0_end_divy_xwidth
#define yheight mccGap0_end_divy_yheight
#define zdepth mccGap0_end_divy_zdepth
#define xmin mccGap0_end_divy_xmin
#define xmax mccGap0_end_divy_xmax
#define ymin mccGap0_end_divy_ymin
#define ymax mccGap0_end_divy_ymax
#define zmin mccGap0_end_divy_zmin
#define zmax mccGap0_end_divy_zmax
#define bins mccGap0_end_divy_bins
#define min mccGap0_end_divy_min
#define max mccGap0_end_divy_max
#define restore_neutron mccGap0_end_divy_restore_neutron
#define radius mccGap0_end_divy_radius
#define options mccGap0_end_divy_options
#define filename mccGap0_end_divy_filename
#define geometry mccGap0_end_divy_geometry
#define username1 mccGap0_end_divy_username1
#define username2 mccGap0_end_divy_username2
#define username3 mccGap0_end_divy_username3
#define nowritefile mccGap0_end_divy_nowritefile
#line 230 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  char tmp[CHAR_BUF_LENGTH];
  strcpy(Vars.compcurname, NAME_CURRENT_COMP);
  if (options != NULL)
    strncpy(Vars.option, options, CHAR_BUF_LENGTH);
  else {
    strcpy(Vars.option, "x y");
    printf("Monitor_nD: %s has no option specified. Setting to PSD ('x y') monitor.\n", NAME_CURRENT_COMP);
  }
  Vars.compcurpos = POS_A_CURRENT_COMP;

  if (strstr(Vars.option, "source"))
    strcat(Vars.option, " list, x y z vx vy vz t sx sy sz ");

  if (bins) { sprintf(tmp, " all bins=%ld ", (long)bins); strcat(Vars.option, tmp); }
  if (min > -FLT_MAX && max < FLT_MAX) { sprintf(tmp, " all limits=[%g %g]", min, max); strcat(Vars.option, tmp); }
  else if (min > -FLT_MAX) { sprintf(tmp, " all min=%g", min); strcat(Vars.option, tmp); }
  else if (max <  FLT_MAX) { sprintf(tmp, " all max=%g", max); strcat(Vars.option, tmp); }

  strncpy(Vars.UserName1,
    username1 && strlen(username1) && strcmp(username1, "0") && strcmp(username1, "NULL") ?
    username1 : "", 128);
  strncpy(Vars.UserName2,
    username2 && strlen(username2) && strcmp(username2, "0") && strcmp(username2, "NULL") ?
    username2 : "", 128);
  strncpy(Vars.UserName3,
    username3 && strlen(username3) && strcmp(username3, "0") && strcmp(username3, "NULL") ?
    username3 : "", 128);
  if (radius) {
    xwidth = zdepth = 2*radius;
    if (yheight && !strstr(Vars.option, "cylinder") && !strstr(Vars.option, "banana") && !strstr(Vars.option, "sphere"))
      strcat(Vars.option, " banana");
    else if (!yheight && !strstr(Vars.option ,"sphere")) {
      strcat(Vars.option, " sphere");
      yheight=2*radius;
    }
  }
  int offflag=0;
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) {
    if (!off_init(  geometry, xwidth, yheight, zdepth, 1, &offdata )) {
      printf("Monitor_nD: %s could not initiate the OFF geometry %s. \n"
             "            Defaulting to normal Monitor dimensions.\n",
             NAME_CURRENT_COMP, geometry);
      strcpy(geometry, "");
    } else {
      offflag=1;
    }
  }

  if (!radius && !xwidth && !yheight && !zdepth && !xmin && !xmax && !ymin && !ymax &&
    !strstr(Vars.option, "previous") && (!geometry || !strlen(geometry)))
    exit(printf("Monitor_nD: %s has no dimension specified. Aborting (radius, xwidth, yheight, zdepth, previous, geometry).\n", NAME_CURRENT_COMP));

  Monitor_nD_Init(&DEFS, &Vars, xwidth, yheight, zdepth, xmin,xmax,ymin,ymax,zmin,zmax,offflag);

  if (Vars.Flag_OFF) {
    offdata.mantidflag=Vars.Flag_mantid;
    offdata.mantidoffset=Vars.Coord_Min[Vars.Coord_Number-1];
  }


  if (filename && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
    strncpy(Vars.Mon_File, filename, 128);

  /* check if user given filename with ext will be used more than once */
  if ( ((Vars.Flag_Multiple && Vars.Coord_Number > 1) || Vars.Flag_List) && strchr(Vars.Mon_File,'.') )
  { char *XY; XY = strrchr(Vars.Mon_File,'.'); *XY='_'; }

  if (restore_neutron) Vars.Flag_parallel=1;
  detector.m = 0;

#ifdef USE_MPI
MPI_MASTER(
  if (strstr(Vars.option, "auto") && mpi_node_count > 1)
    printf("Monitor_nD: %s is using automatic limits option 'auto' together with MPI.\n"
           "WARNING     this may create incorrect distributions (but integrated flux will be right).\n", NAME_CURRENT_COMP);
);
#endif
}
#line 33227 "./SNS_BASIS.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Core_Vessel_Section. */
  SIG_MESSAGE("Core_Vessel_Section (Init)");
#define mccompcurname  Core_Vessel_Section
#define mccompcurtype  Guide
#define mccompcurindex 10
#define pTable mccCore_Vessel_Section_pTable
#define reflect mccCore_Vessel_Section_reflect
#define w1 mccCore_Vessel_Section_w1
#define h1 mccCore_Vessel_Section_h1
#define w2 mccCore_Vessel_Section_w2
#define h2 mccCore_Vessel_Section_h2
#define l mccCore_Vessel_Section_l
#define R0 mccCore_Vessel_Section_R0
#define Qc mccCore_Vessel_Section_Qc
#define alpha mccCore_Vessel_Section_alpha
#define m mccCore_Vessel_Section_m
#define W mccCore_Vessel_Section_W
#line 74 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 33296 "./SNS_BASIS.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap1_start. */
  SIG_MESSAGE("Gap1_start (Init)");

  /* Initializations for component Gap1_start_Lam. */
  SIG_MESSAGE("Gap1_start_Lam (Init)");
#define mccompcurname  Gap1_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 12
#define nL mccGap1_start_Lam_nL
#define L_N mccGap1_start_Lam_L_N
#define L_p mccGap1_start_Lam_L_p
#define L_p2 mccGap1_start_Lam_L_p2
#define filename mccGap1_start_Lam_filename
#define xmin mccGap1_start_Lam_xmin
#define xmax mccGap1_start_Lam_xmax
#define ymin mccGap1_start_Lam_ymin
#define ymax mccGap1_start_Lam_ymax
#define xwidth mccGap1_start_Lam_xwidth
#define yheight mccGap1_start_Lam_yheight
#define Lmin mccGap1_start_Lam_Lmin
#define Lmax mccGap1_start_Lam_Lmax
#define restore_neutron mccGap1_start_Lam_restore_neutron
#define nowritefile mccGap1_start_Lam_nowritefile
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 33357 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap1_end_Lam. */
  SIG_MESSAGE("Gap1_end_Lam (Init)");
#define mccompcurname  Gap1_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 13
#define nL mccGap1_end_Lam_nL
#define L_N mccGap1_end_Lam_L_N
#define L_p mccGap1_end_Lam_L_p
#define L_p2 mccGap1_end_Lam_L_p2
#define filename mccGap1_end_Lam_filename
#define xmin mccGap1_end_Lam_xmin
#define xmax mccGap1_end_Lam_xmax
#define ymin mccGap1_end_Lam_ymin
#define ymax mccGap1_end_Lam_ymax
#define xwidth mccGap1_end_Lam_xwidth
#define yheight mccGap1_end_Lam_yheight
#define Lmin mccGap1_end_Lam_Lmin
#define Lmax mccGap1_end_Lam_Lmax
#define restore_neutron mccGap1_end_Lam_restore_neutron
#define nowritefile mccGap1_end_Lam_nowritefile
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 33418 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap1_end. */
  SIG_MESSAGE("Gap1_end (Init)");

  /* Initializations for component Shutter_Guide_Insert. */
  SIG_MESSAGE("Shutter_Guide_Insert (Init)");
#define mccompcurname  Shutter_Guide_Insert
#define mccompcurtype  Guide_gravity
#define mccompcurindex 15
#define GVars mccShutter_Guide_Insert_GVars
#define pTable mccShutter_Guide_Insert_pTable
#define w1 mccShutter_Guide_Insert_w1
#define h1 mccShutter_Guide_Insert_h1
#define w2 mccShutter_Guide_Insert_w2
#define h2 mccShutter_Guide_Insert_h2
#define l mccShutter_Guide_Insert_l
#define R0 mccShutter_Guide_Insert_R0
#define Qc mccShutter_Guide_Insert_Qc
#define alpha mccShutter_Guide_Insert_alpha
#define m mccShutter_Guide_Insert_m
#define W mccShutter_Guide_Insert_W
#define nslit mccShutter_Guide_Insert_nslit
#define d mccShutter_Guide_Insert_d
#define mleft mccShutter_Guide_Insert_mleft
#define mright mccShutter_Guide_Insert_mright
#define mtop mccShutter_Guide_Insert_mtop
#define mbottom mccShutter_Guide_Insert_mbottom
#define nhslit mccShutter_Guide_Insert_nhslit
#define G mccShutter_Guide_Insert_G
#define aleft mccShutter_Guide_Insert_aleft
#define aright mccShutter_Guide_Insert_aright
#define atop mccShutter_Guide_Insert_atop
#define abottom mccShutter_Guide_Insert_abottom
#define wavy mccShutter_Guide_Insert_wavy
#define wavy_z mccShutter_Guide_Insert_wavy_z
#define wavy_tb mccShutter_Guide_Insert_wavy_tb
#define wavy_lr mccShutter_Guide_Insert_wavy_lr
#define chamfers mccShutter_Guide_Insert_chamfers
#define chamfers_z mccShutter_Guide_Insert_chamfers_z
#define chamfers_lr mccShutter_Guide_Insert_chamfers_lr
#define chamfers_tb mccShutter_Guide_Insert_chamfers_tb
#define nelements mccShutter_Guide_Insert_nelements
#define nu mccShutter_Guide_Insert_nu
#define phase mccShutter_Guide_Insert_phase
#define reflect mccShutter_Guide_Insert_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33534 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Shutter_Guide_Insert_16. */
  SIG_MESSAGE("Shutter_Guide_Insert_16 (Init)");
#define mccompcurname  Shutter_Guide_Insert_16
#define mccompcurtype  Guide_gravity
#define mccompcurindex 16
#define GVars mccShutter_Guide_Insert_16_GVars
#define pTable mccShutter_Guide_Insert_16_pTable
#define w1 mccShutter_Guide_Insert_16_w1
#define h1 mccShutter_Guide_Insert_16_h1
#define w2 mccShutter_Guide_Insert_16_w2
#define h2 mccShutter_Guide_Insert_16_h2
#define l mccShutter_Guide_Insert_16_l
#define R0 mccShutter_Guide_Insert_16_R0
#define Qc mccShutter_Guide_Insert_16_Qc
#define alpha mccShutter_Guide_Insert_16_alpha
#define m mccShutter_Guide_Insert_16_m
#define W mccShutter_Guide_Insert_16_W
#define nslit mccShutter_Guide_Insert_16_nslit
#define d mccShutter_Guide_Insert_16_d
#define mleft mccShutter_Guide_Insert_16_mleft
#define mright mccShutter_Guide_Insert_16_mright
#define mtop mccShutter_Guide_Insert_16_mtop
#define mbottom mccShutter_Guide_Insert_16_mbottom
#define nhslit mccShutter_Guide_Insert_16_nhslit
#define G mccShutter_Guide_Insert_16_G
#define aleft mccShutter_Guide_Insert_16_aleft
#define aright mccShutter_Guide_Insert_16_aright
#define atop mccShutter_Guide_Insert_16_atop
#define abottom mccShutter_Guide_Insert_16_abottom
#define wavy mccShutter_Guide_Insert_16_wavy
#define wavy_z mccShutter_Guide_Insert_16_wavy_z
#define wavy_tb mccShutter_Guide_Insert_16_wavy_tb
#define wavy_lr mccShutter_Guide_Insert_16_wavy_lr
#define chamfers mccShutter_Guide_Insert_16_chamfers
#define chamfers_z mccShutter_Guide_Insert_16_chamfers_z
#define chamfers_lr mccShutter_Guide_Insert_16_chamfers_lr
#define chamfers_tb mccShutter_Guide_Insert_16_chamfers_tb
#define nelements mccShutter_Guide_Insert_16_nelements
#define nu mccShutter_Guide_Insert_16_nu
#define phase mccShutter_Guide_Insert_16_phase
#define reflect mccShutter_Guide_Insert_16_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33668 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Shutter_Guide_Insert_17. */
  SIG_MESSAGE("Shutter_Guide_Insert_17 (Init)");
#define mccompcurname  Shutter_Guide_Insert_17
#define mccompcurtype  Guide_gravity
#define mccompcurindex 17
#define GVars mccShutter_Guide_Insert_17_GVars
#define pTable mccShutter_Guide_Insert_17_pTable
#define w1 mccShutter_Guide_Insert_17_w1
#define h1 mccShutter_Guide_Insert_17_h1
#define w2 mccShutter_Guide_Insert_17_w2
#define h2 mccShutter_Guide_Insert_17_h2
#define l mccShutter_Guide_Insert_17_l
#define R0 mccShutter_Guide_Insert_17_R0
#define Qc mccShutter_Guide_Insert_17_Qc
#define alpha mccShutter_Guide_Insert_17_alpha
#define m mccShutter_Guide_Insert_17_m
#define W mccShutter_Guide_Insert_17_W
#define nslit mccShutter_Guide_Insert_17_nslit
#define d mccShutter_Guide_Insert_17_d
#define mleft mccShutter_Guide_Insert_17_mleft
#define mright mccShutter_Guide_Insert_17_mright
#define mtop mccShutter_Guide_Insert_17_mtop
#define mbottom mccShutter_Guide_Insert_17_mbottom
#define nhslit mccShutter_Guide_Insert_17_nhslit
#define G mccShutter_Guide_Insert_17_G
#define aleft mccShutter_Guide_Insert_17_aleft
#define aright mccShutter_Guide_Insert_17_aright
#define atop mccShutter_Guide_Insert_17_atop
#define abottom mccShutter_Guide_Insert_17_abottom
#define wavy mccShutter_Guide_Insert_17_wavy
#define wavy_z mccShutter_Guide_Insert_17_wavy_z
#define wavy_tb mccShutter_Guide_Insert_17_wavy_tb
#define wavy_lr mccShutter_Guide_Insert_17_wavy_lr
#define chamfers mccShutter_Guide_Insert_17_chamfers
#define chamfers_z mccShutter_Guide_Insert_17_chamfers_z
#define chamfers_lr mccShutter_Guide_Insert_17_chamfers_lr
#define chamfers_tb mccShutter_Guide_Insert_17_chamfers_tb
#define nelements mccShutter_Guide_Insert_17_nelements
#define nu mccShutter_Guide_Insert_17_nu
#define phase mccShutter_Guide_Insert_17_phase
#define reflect mccShutter_Guide_Insert_17_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33802 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Shutter_Guide_Insert_18. */
  SIG_MESSAGE("Shutter_Guide_Insert_18 (Init)");
#define mccompcurname  Shutter_Guide_Insert_18
#define mccompcurtype  Guide_gravity
#define mccompcurindex 18
#define GVars mccShutter_Guide_Insert_18_GVars
#define pTable mccShutter_Guide_Insert_18_pTable
#define w1 mccShutter_Guide_Insert_18_w1
#define h1 mccShutter_Guide_Insert_18_h1
#define w2 mccShutter_Guide_Insert_18_w2
#define h2 mccShutter_Guide_Insert_18_h2
#define l mccShutter_Guide_Insert_18_l
#define R0 mccShutter_Guide_Insert_18_R0
#define Qc mccShutter_Guide_Insert_18_Qc
#define alpha mccShutter_Guide_Insert_18_alpha
#define m mccShutter_Guide_Insert_18_m
#define W mccShutter_Guide_Insert_18_W
#define nslit mccShutter_Guide_Insert_18_nslit
#define d mccShutter_Guide_Insert_18_d
#define mleft mccShutter_Guide_Insert_18_mleft
#define mright mccShutter_Guide_Insert_18_mright
#define mtop mccShutter_Guide_Insert_18_mtop
#define mbottom mccShutter_Guide_Insert_18_mbottom
#define nhslit mccShutter_Guide_Insert_18_nhslit
#define G mccShutter_Guide_Insert_18_G
#define aleft mccShutter_Guide_Insert_18_aleft
#define aright mccShutter_Guide_Insert_18_aright
#define atop mccShutter_Guide_Insert_18_atop
#define abottom mccShutter_Guide_Insert_18_abottom
#define wavy mccShutter_Guide_Insert_18_wavy
#define wavy_z mccShutter_Guide_Insert_18_wavy_z
#define wavy_tb mccShutter_Guide_Insert_18_wavy_tb
#define wavy_lr mccShutter_Guide_Insert_18_wavy_lr
#define chamfers mccShutter_Guide_Insert_18_chamfers
#define chamfers_z mccShutter_Guide_Insert_18_chamfers_z
#define chamfers_lr mccShutter_Guide_Insert_18_chamfers_lr
#define chamfers_tb mccShutter_Guide_Insert_18_chamfers_tb
#define nelements mccShutter_Guide_Insert_18_nelements
#define nu mccShutter_Guide_Insert_18_nu
#define phase mccShutter_Guide_Insert_18_phase
#define reflect mccShutter_Guide_Insert_18_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33936 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Shutter_Guide_Insert_19. */
  SIG_MESSAGE("Shutter_Guide_Insert_19 (Init)");
#define mccompcurname  Shutter_Guide_Insert_19
#define mccompcurtype  Guide_gravity
#define mccompcurindex 19
#define GVars mccShutter_Guide_Insert_19_GVars
#define pTable mccShutter_Guide_Insert_19_pTable
#define w1 mccShutter_Guide_Insert_19_w1
#define h1 mccShutter_Guide_Insert_19_h1
#define w2 mccShutter_Guide_Insert_19_w2
#define h2 mccShutter_Guide_Insert_19_h2
#define l mccShutter_Guide_Insert_19_l
#define R0 mccShutter_Guide_Insert_19_R0
#define Qc mccShutter_Guide_Insert_19_Qc
#define alpha mccShutter_Guide_Insert_19_alpha
#define m mccShutter_Guide_Insert_19_m
#define W mccShutter_Guide_Insert_19_W
#define nslit mccShutter_Guide_Insert_19_nslit
#define d mccShutter_Guide_Insert_19_d
#define mleft mccShutter_Guide_Insert_19_mleft
#define mright mccShutter_Guide_Insert_19_mright
#define mtop mccShutter_Guide_Insert_19_mtop
#define mbottom mccShutter_Guide_Insert_19_mbottom
#define nhslit mccShutter_Guide_Insert_19_nhslit
#define G mccShutter_Guide_Insert_19_G
#define aleft mccShutter_Guide_Insert_19_aleft
#define aright mccShutter_Guide_Insert_19_aright
#define atop mccShutter_Guide_Insert_19_atop
#define abottom mccShutter_Guide_Insert_19_abottom
#define wavy mccShutter_Guide_Insert_19_wavy
#define wavy_z mccShutter_Guide_Insert_19_wavy_z
#define wavy_tb mccShutter_Guide_Insert_19_wavy_tb
#define wavy_lr mccShutter_Guide_Insert_19_wavy_lr
#define chamfers mccShutter_Guide_Insert_19_chamfers
#define chamfers_z mccShutter_Guide_Insert_19_chamfers_z
#define chamfers_lr mccShutter_Guide_Insert_19_chamfers_lr
#define chamfers_tb mccShutter_Guide_Insert_19_chamfers_tb
#define nelements mccShutter_Guide_Insert_19_nelements
#define nu mccShutter_Guide_Insert_19_nu
#define phase mccShutter_Guide_Insert_19_phase
#define reflect mccShutter_Guide_Insert_19_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34070 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Shutter_Guide_Insert_20. */
  SIG_MESSAGE("Shutter_Guide_Insert_20 (Init)");
#define mccompcurname  Shutter_Guide_Insert_20
#define mccompcurtype  Guide_gravity
#define mccompcurindex 20
#define GVars mccShutter_Guide_Insert_20_GVars
#define pTable mccShutter_Guide_Insert_20_pTable
#define w1 mccShutter_Guide_Insert_20_w1
#define h1 mccShutter_Guide_Insert_20_h1
#define w2 mccShutter_Guide_Insert_20_w2
#define h2 mccShutter_Guide_Insert_20_h2
#define l mccShutter_Guide_Insert_20_l
#define R0 mccShutter_Guide_Insert_20_R0
#define Qc mccShutter_Guide_Insert_20_Qc
#define alpha mccShutter_Guide_Insert_20_alpha
#define m mccShutter_Guide_Insert_20_m
#define W mccShutter_Guide_Insert_20_W
#define nslit mccShutter_Guide_Insert_20_nslit
#define d mccShutter_Guide_Insert_20_d
#define mleft mccShutter_Guide_Insert_20_mleft
#define mright mccShutter_Guide_Insert_20_mright
#define mtop mccShutter_Guide_Insert_20_mtop
#define mbottom mccShutter_Guide_Insert_20_mbottom
#define nhslit mccShutter_Guide_Insert_20_nhslit
#define G mccShutter_Guide_Insert_20_G
#define aleft mccShutter_Guide_Insert_20_aleft
#define aright mccShutter_Guide_Insert_20_aright
#define atop mccShutter_Guide_Insert_20_atop
#define abottom mccShutter_Guide_Insert_20_abottom
#define wavy mccShutter_Guide_Insert_20_wavy
#define wavy_z mccShutter_Guide_Insert_20_wavy_z
#define wavy_tb mccShutter_Guide_Insert_20_wavy_tb
#define wavy_lr mccShutter_Guide_Insert_20_wavy_lr
#define chamfers mccShutter_Guide_Insert_20_chamfers
#define chamfers_z mccShutter_Guide_Insert_20_chamfers_z
#define chamfers_lr mccShutter_Guide_Insert_20_chamfers_lr
#define chamfers_tb mccShutter_Guide_Insert_20_chamfers_tb
#define nelements mccShutter_Guide_Insert_20_nelements
#define nu mccShutter_Guide_Insert_20_nu
#define phase mccShutter_Guide_Insert_20_phase
#define reflect mccShutter_Guide_Insert_20_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34204 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Shutter_Guide_Insert_21. */
  SIG_MESSAGE("Shutter_Guide_Insert_21 (Init)");
#define mccompcurname  Shutter_Guide_Insert_21
#define mccompcurtype  Guide_gravity
#define mccompcurindex 21
#define GVars mccShutter_Guide_Insert_21_GVars
#define pTable mccShutter_Guide_Insert_21_pTable
#define w1 mccShutter_Guide_Insert_21_w1
#define h1 mccShutter_Guide_Insert_21_h1
#define w2 mccShutter_Guide_Insert_21_w2
#define h2 mccShutter_Guide_Insert_21_h2
#define l mccShutter_Guide_Insert_21_l
#define R0 mccShutter_Guide_Insert_21_R0
#define Qc mccShutter_Guide_Insert_21_Qc
#define alpha mccShutter_Guide_Insert_21_alpha
#define m mccShutter_Guide_Insert_21_m
#define W mccShutter_Guide_Insert_21_W
#define nslit mccShutter_Guide_Insert_21_nslit
#define d mccShutter_Guide_Insert_21_d
#define mleft mccShutter_Guide_Insert_21_mleft
#define mright mccShutter_Guide_Insert_21_mright
#define mtop mccShutter_Guide_Insert_21_mtop
#define mbottom mccShutter_Guide_Insert_21_mbottom
#define nhslit mccShutter_Guide_Insert_21_nhslit
#define G mccShutter_Guide_Insert_21_G
#define aleft mccShutter_Guide_Insert_21_aleft
#define aright mccShutter_Guide_Insert_21_aright
#define atop mccShutter_Guide_Insert_21_atop
#define abottom mccShutter_Guide_Insert_21_abottom
#define wavy mccShutter_Guide_Insert_21_wavy
#define wavy_z mccShutter_Guide_Insert_21_wavy_z
#define wavy_tb mccShutter_Guide_Insert_21_wavy_tb
#define wavy_lr mccShutter_Guide_Insert_21_wavy_lr
#define chamfers mccShutter_Guide_Insert_21_chamfers
#define chamfers_z mccShutter_Guide_Insert_21_chamfers_z
#define chamfers_lr mccShutter_Guide_Insert_21_chamfers_lr
#define chamfers_tb mccShutter_Guide_Insert_21_chamfers_tb
#define nelements mccShutter_Guide_Insert_21_nelements
#define nu mccShutter_Guide_Insert_21_nu
#define phase mccShutter_Guide_Insert_21_phase
#define reflect mccShutter_Guide_Insert_21_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34338 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Shutter_Guide_Insert_short. */
  SIG_MESSAGE("Shutter_Guide_Insert_short (Init)");
#define mccompcurname  Shutter_Guide_Insert_short
#define mccompcurtype  Guide_gravity
#define mccompcurindex 22
#define GVars mccShutter_Guide_Insert_short_GVars
#define pTable mccShutter_Guide_Insert_short_pTable
#define w1 mccShutter_Guide_Insert_short_w1
#define h1 mccShutter_Guide_Insert_short_h1
#define w2 mccShutter_Guide_Insert_short_w2
#define h2 mccShutter_Guide_Insert_short_h2
#define l mccShutter_Guide_Insert_short_l
#define R0 mccShutter_Guide_Insert_short_R0
#define Qc mccShutter_Guide_Insert_short_Qc
#define alpha mccShutter_Guide_Insert_short_alpha
#define m mccShutter_Guide_Insert_short_m
#define W mccShutter_Guide_Insert_short_W
#define nslit mccShutter_Guide_Insert_short_nslit
#define d mccShutter_Guide_Insert_short_d
#define mleft mccShutter_Guide_Insert_short_mleft
#define mright mccShutter_Guide_Insert_short_mright
#define mtop mccShutter_Guide_Insert_short_mtop
#define mbottom mccShutter_Guide_Insert_short_mbottom
#define nhslit mccShutter_Guide_Insert_short_nhslit
#define G mccShutter_Guide_Insert_short_G
#define aleft mccShutter_Guide_Insert_short_aleft
#define aright mccShutter_Guide_Insert_short_aright
#define atop mccShutter_Guide_Insert_short_atop
#define abottom mccShutter_Guide_Insert_short_abottom
#define wavy mccShutter_Guide_Insert_short_wavy
#define wavy_z mccShutter_Guide_Insert_short_wavy_z
#define wavy_tb mccShutter_Guide_Insert_short_wavy_tb
#define wavy_lr mccShutter_Guide_Insert_short_wavy_lr
#define chamfers mccShutter_Guide_Insert_short_chamfers
#define chamfers_z mccShutter_Guide_Insert_short_chamfers_z
#define chamfers_lr mccShutter_Guide_Insert_short_chamfers_lr
#define chamfers_tb mccShutter_Guide_Insert_short_chamfers_tb
#define nelements mccShutter_Guide_Insert_short_nelements
#define nu mccShutter_Guide_Insert_short_nu
#define phase mccShutter_Guide_Insert_short_phase
#define reflect mccShutter_Guide_Insert_short_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34472 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap2_start. */
  SIG_MESSAGE("Gap2_start (Init)");

  /* Initializations for component Gap2_start_Lam. */
  SIG_MESSAGE("Gap2_start_Lam (Init)");
#define mccompcurname  Gap2_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 24
#define nL mccGap2_start_Lam_nL
#define L_N mccGap2_start_Lam_L_N
#define L_p mccGap2_start_Lam_L_p
#define L_p2 mccGap2_start_Lam_L_p2
#define filename mccGap2_start_Lam_filename
#define xmin mccGap2_start_Lam_xmin
#define xmax mccGap2_start_Lam_xmax
#define ymin mccGap2_start_Lam_ymin
#define ymax mccGap2_start_Lam_ymax
#define xwidth mccGap2_start_Lam_xwidth
#define yheight mccGap2_start_Lam_yheight
#define Lmin mccGap2_start_Lam_Lmin
#define Lmax mccGap2_start_Lam_Lmax
#define restore_neutron mccGap2_start_Lam_restore_neutron
#define nowritefile mccGap2_start_Lam_nowritefile
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 34557 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap2_start_PSD. */
  SIG_MESSAGE("Gap2_start_PSD (Init)");
#define mccompcurname  Gap2_start_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 25
#define PSD_N mccGap2_start_PSD_PSD_N
#define PSD_p mccGap2_start_PSD_PSD_p
#define PSD_p2 mccGap2_start_PSD_PSD_p2
#define nx mccGap2_start_PSD_nx
#define ny mccGap2_start_PSD_ny
#define filename mccGap2_start_PSD_filename
#define xmin mccGap2_start_PSD_xmin
#define xmax mccGap2_start_PSD_xmax
#define ymin mccGap2_start_PSD_ymin
#define ymax mccGap2_start_PSD_ymax
#define xwidth mccGap2_start_PSD_xwidth
#define yheight mccGap2_start_PSD_yheight
#define restore_neutron mccGap2_start_PSD_restore_neutron
#line 68 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
  if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

  if ((xmin >= xmax) || (ymin >= ymax)){
    printf("PSD_monitor: %s: Null detection area !\n"
           "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
    NAME_CURRENT_COMP);
    exit(0);
  }

  PSD_N = create_darr2d(nx, ny);
  PSD_p = create_darr2d(nx, ny);
  PSD_p2 = create_darr2d(nx, ny);

  int i, j;
  for (i=0; i<nx; i++){
    for (j=0; j<ny; j++){
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
    }
  }
}
#line 34620 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap2_end_Lam. */
  SIG_MESSAGE("Gap2_end_Lam (Init)");
#define mccompcurname  Gap2_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 26
#define nL mccGap2_end_Lam_nL
#define L_N mccGap2_end_Lam_L_N
#define L_p mccGap2_end_Lam_L_p
#define L_p2 mccGap2_end_Lam_L_p2
#define filename mccGap2_end_Lam_filename
#define xmin mccGap2_end_Lam_xmin
#define xmax mccGap2_end_Lam_xmax
#define ymin mccGap2_end_Lam_ymin
#define ymax mccGap2_end_Lam_ymax
#define xwidth mccGap2_end_Lam_xwidth
#define yheight mccGap2_end_Lam_yheight
#define Lmin mccGap2_end_Lam_Lmin
#define Lmax mccGap2_end_Lam_Lmax
#define restore_neutron mccGap2_end_Lam_restore_neutron
#define nowritefile mccGap2_end_Lam_nowritefile
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 34679 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap2_end_PSD. */
  SIG_MESSAGE("Gap2_end_PSD (Init)");
#define mccompcurname  Gap2_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 27
#define PSD_N mccGap2_end_PSD_PSD_N
#define PSD_p mccGap2_end_PSD_PSD_p
#define PSD_p2 mccGap2_end_PSD_PSD_p2
#define nx mccGap2_end_PSD_nx
#define ny mccGap2_end_PSD_ny
#define filename mccGap2_end_PSD_filename
#define xmin mccGap2_end_PSD_xmin
#define xmax mccGap2_end_PSD_xmax
#define ymin mccGap2_end_PSD_ymin
#define ymax mccGap2_end_PSD_ymax
#define xwidth mccGap2_end_PSD_xwidth
#define yheight mccGap2_end_PSD_yheight
#define restore_neutron mccGap2_end_PSD_restore_neutron
#line 68 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
  if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

  if ((xmin >= xmax) || (ymin >= ymax)){
    printf("PSD_monitor: %s: Null detection area !\n"
           "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
    NAME_CURRENT_COMP);
    exit(0);
  }

  PSD_N = create_darr2d(nx, ny);
  PSD_p = create_darr2d(nx, ny);
  PSD_p2 = create_darr2d(nx, ny);

  int i, j;
  for (i=0; i<nx; i++){
    for (j=0; j<ny; j++){
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
    }
  }
}
#line 34742 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap2_end. */
  SIG_MESSAGE("Gap2_end (Init)");

  /* Initializations for component Curved_Guide_Section_I. */
  SIG_MESSAGE("Curved_Guide_Section_I (Init)");
#define mccompcurname  Curved_Guide_Section_I
#define mccompcurtype  Guide_gravity
#define mccompcurindex 29
#define GVars mccCurved_Guide_Section_I_GVars
#define pTable mccCurved_Guide_Section_I_pTable
#define w1 mccCurved_Guide_Section_I_w1
#define h1 mccCurved_Guide_Section_I_h1
#define w2 mccCurved_Guide_Section_I_w2
#define h2 mccCurved_Guide_Section_I_h2
#define l mccCurved_Guide_Section_I_l
#define R0 mccCurved_Guide_Section_I_R0
#define Qc mccCurved_Guide_Section_I_Qc
#define alpha mccCurved_Guide_Section_I_alpha
#define m mccCurved_Guide_Section_I_m
#define W mccCurved_Guide_Section_I_W
#define nslit mccCurved_Guide_Section_I_nslit
#define d mccCurved_Guide_Section_I_d
#define mleft mccCurved_Guide_Section_I_mleft
#define mright mccCurved_Guide_Section_I_mright
#define mtop mccCurved_Guide_Section_I_mtop
#define mbottom mccCurved_Guide_Section_I_mbottom
#define nhslit mccCurved_Guide_Section_I_nhslit
#define G mccCurved_Guide_Section_I_G
#define aleft mccCurved_Guide_Section_I_aleft
#define aright mccCurved_Guide_Section_I_aright
#define atop mccCurved_Guide_Section_I_atop
#define abottom mccCurved_Guide_Section_I_abottom
#define wavy mccCurved_Guide_Section_I_wavy
#define wavy_z mccCurved_Guide_Section_I_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_wavy_lr
#define chamfers mccCurved_Guide_Section_I_chamfers
#define chamfers_z mccCurved_Guide_Section_I_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_chamfers_tb
#define nelements mccCurved_Guide_Section_I_nelements
#define nu mccCurved_Guide_Section_I_nu
#define phase mccCurved_Guide_Section_I_phase
#define reflect mccCurved_Guide_Section_I_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34856 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_I_30. */
  SIG_MESSAGE("Curved_Guide_Section_I_30 (Init)");
#define mccompcurname  Curved_Guide_Section_I_30
#define mccompcurtype  Guide_gravity
#define mccompcurindex 30
#define GVars mccCurved_Guide_Section_I_30_GVars
#define pTable mccCurved_Guide_Section_I_30_pTable
#define w1 mccCurved_Guide_Section_I_30_w1
#define h1 mccCurved_Guide_Section_I_30_h1
#define w2 mccCurved_Guide_Section_I_30_w2
#define h2 mccCurved_Guide_Section_I_30_h2
#define l mccCurved_Guide_Section_I_30_l
#define R0 mccCurved_Guide_Section_I_30_R0
#define Qc mccCurved_Guide_Section_I_30_Qc
#define alpha mccCurved_Guide_Section_I_30_alpha
#define m mccCurved_Guide_Section_I_30_m
#define W mccCurved_Guide_Section_I_30_W
#define nslit mccCurved_Guide_Section_I_30_nslit
#define d mccCurved_Guide_Section_I_30_d
#define mleft mccCurved_Guide_Section_I_30_mleft
#define mright mccCurved_Guide_Section_I_30_mright
#define mtop mccCurved_Guide_Section_I_30_mtop
#define mbottom mccCurved_Guide_Section_I_30_mbottom
#define nhslit mccCurved_Guide_Section_I_30_nhslit
#define G mccCurved_Guide_Section_I_30_G
#define aleft mccCurved_Guide_Section_I_30_aleft
#define aright mccCurved_Guide_Section_I_30_aright
#define atop mccCurved_Guide_Section_I_30_atop
#define abottom mccCurved_Guide_Section_I_30_abottom
#define wavy mccCurved_Guide_Section_I_30_wavy
#define wavy_z mccCurved_Guide_Section_I_30_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_30_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_30_wavy_lr
#define chamfers mccCurved_Guide_Section_I_30_chamfers
#define chamfers_z mccCurved_Guide_Section_I_30_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_30_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_30_chamfers_tb
#define nelements mccCurved_Guide_Section_I_30_nelements
#define nu mccCurved_Guide_Section_I_30_nu
#define phase mccCurved_Guide_Section_I_30_phase
#define reflect mccCurved_Guide_Section_I_30_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34990 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_I_31. */
  SIG_MESSAGE("Curved_Guide_Section_I_31 (Init)");
#define mccompcurname  Curved_Guide_Section_I_31
#define mccompcurtype  Guide_gravity
#define mccompcurindex 31
#define GVars mccCurved_Guide_Section_I_31_GVars
#define pTable mccCurved_Guide_Section_I_31_pTable
#define w1 mccCurved_Guide_Section_I_31_w1
#define h1 mccCurved_Guide_Section_I_31_h1
#define w2 mccCurved_Guide_Section_I_31_w2
#define h2 mccCurved_Guide_Section_I_31_h2
#define l mccCurved_Guide_Section_I_31_l
#define R0 mccCurved_Guide_Section_I_31_R0
#define Qc mccCurved_Guide_Section_I_31_Qc
#define alpha mccCurved_Guide_Section_I_31_alpha
#define m mccCurved_Guide_Section_I_31_m
#define W mccCurved_Guide_Section_I_31_W
#define nslit mccCurved_Guide_Section_I_31_nslit
#define d mccCurved_Guide_Section_I_31_d
#define mleft mccCurved_Guide_Section_I_31_mleft
#define mright mccCurved_Guide_Section_I_31_mright
#define mtop mccCurved_Guide_Section_I_31_mtop
#define mbottom mccCurved_Guide_Section_I_31_mbottom
#define nhslit mccCurved_Guide_Section_I_31_nhslit
#define G mccCurved_Guide_Section_I_31_G
#define aleft mccCurved_Guide_Section_I_31_aleft
#define aright mccCurved_Guide_Section_I_31_aright
#define atop mccCurved_Guide_Section_I_31_atop
#define abottom mccCurved_Guide_Section_I_31_abottom
#define wavy mccCurved_Guide_Section_I_31_wavy
#define wavy_z mccCurved_Guide_Section_I_31_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_31_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_31_wavy_lr
#define chamfers mccCurved_Guide_Section_I_31_chamfers
#define chamfers_z mccCurved_Guide_Section_I_31_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_31_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_31_chamfers_tb
#define nelements mccCurved_Guide_Section_I_31_nelements
#define nu mccCurved_Guide_Section_I_31_nu
#define phase mccCurved_Guide_Section_I_31_phase
#define reflect mccCurved_Guide_Section_I_31_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 35124 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_I_32. */
  SIG_MESSAGE("Curved_Guide_Section_I_32 (Init)");
#define mccompcurname  Curved_Guide_Section_I_32
#define mccompcurtype  Guide_gravity
#define mccompcurindex 32
#define GVars mccCurved_Guide_Section_I_32_GVars
#define pTable mccCurved_Guide_Section_I_32_pTable
#define w1 mccCurved_Guide_Section_I_32_w1
#define h1 mccCurved_Guide_Section_I_32_h1
#define w2 mccCurved_Guide_Section_I_32_w2
#define h2 mccCurved_Guide_Section_I_32_h2
#define l mccCurved_Guide_Section_I_32_l
#define R0 mccCurved_Guide_Section_I_32_R0
#define Qc mccCurved_Guide_Section_I_32_Qc
#define alpha mccCurved_Guide_Section_I_32_alpha
#define m mccCurved_Guide_Section_I_32_m
#define W mccCurved_Guide_Section_I_32_W
#define nslit mccCurved_Guide_Section_I_32_nslit
#define d mccCurved_Guide_Section_I_32_d
#define mleft mccCurved_Guide_Section_I_32_mleft
#define mright mccCurved_Guide_Section_I_32_mright
#define mtop mccCurved_Guide_Section_I_32_mtop
#define mbottom mccCurved_Guide_Section_I_32_mbottom
#define nhslit mccCurved_Guide_Section_I_32_nhslit
#define G mccCurved_Guide_Section_I_32_G
#define aleft mccCurved_Guide_Section_I_32_aleft
#define aright mccCurved_Guide_Section_I_32_aright
#define atop mccCurved_Guide_Section_I_32_atop
#define abottom mccCurved_Guide_Section_I_32_abottom
#define wavy mccCurved_Guide_Section_I_32_wavy
#define wavy_z mccCurved_Guide_Section_I_32_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_32_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_32_wavy_lr
#define chamfers mccCurved_Guide_Section_I_32_chamfers
#define chamfers_z mccCurved_Guide_Section_I_32_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_32_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_32_chamfers_tb
#define nelements mccCurved_Guide_Section_I_32_nelements
#define nu mccCurved_Guide_Section_I_32_nu
#define phase mccCurved_Guide_Section_I_32_phase
#define reflect mccCurved_Guide_Section_I_32_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 35258 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_I_33. */
  SIG_MESSAGE("Curved_Guide_Section_I_33 (Init)");
#define mccompcurname  Curved_Guide_Section_I_33
#define mccompcurtype  Guide_gravity
#define mccompcurindex 33
#define GVars mccCurved_Guide_Section_I_33_GVars
#define pTable mccCurved_Guide_Section_I_33_pTable
#define w1 mccCurved_Guide_Section_I_33_w1
#define h1 mccCurved_Guide_Section_I_33_h1
#define w2 mccCurved_Guide_Section_I_33_w2
#define h2 mccCurved_Guide_Section_I_33_h2
#define l mccCurved_Guide_Section_I_33_l
#define R0 mccCurved_Guide_Section_I_33_R0
#define Qc mccCurved_Guide_Section_I_33_Qc
#define alpha mccCurved_Guide_Section_I_33_alpha
#define m mccCurved_Guide_Section_I_33_m
#define W mccCurved_Guide_Section_I_33_W
#define nslit mccCurved_Guide_Section_I_33_nslit
#define d mccCurved_Guide_Section_I_33_d
#define mleft mccCurved_Guide_Section_I_33_mleft
#define mright mccCurved_Guide_Section_I_33_mright
#define mtop mccCurved_Guide_Section_I_33_mtop
#define mbottom mccCurved_Guide_Section_I_33_mbottom
#define nhslit mccCurved_Guide_Section_I_33_nhslit
#define G mccCurved_Guide_Section_I_33_G
#define aleft mccCurved_Guide_Section_I_33_aleft
#define aright mccCurved_Guide_Section_I_33_aright
#define atop mccCurved_Guide_Section_I_33_atop
#define abottom mccCurved_Guide_Section_I_33_abottom
#define wavy mccCurved_Guide_Section_I_33_wavy
#define wavy_z mccCurved_Guide_Section_I_33_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_33_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_33_wavy_lr
#define chamfers mccCurved_Guide_Section_I_33_chamfers
#define chamfers_z mccCurved_Guide_Section_I_33_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_33_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_33_chamfers_tb
#define nelements mccCurved_Guide_Section_I_33_nelements
#define nu mccCurved_Guide_Section_I_33_nu
#define phase mccCurved_Guide_Section_I_33_phase
#define reflect mccCurved_Guide_Section_I_33_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 35392 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_I_34. */
  SIG_MESSAGE("Curved_Guide_Section_I_34 (Init)");
#define mccompcurname  Curved_Guide_Section_I_34
#define mccompcurtype  Guide_gravity
#define mccompcurindex 34
#define GVars mccCurved_Guide_Section_I_34_GVars
#define pTable mccCurved_Guide_Section_I_34_pTable
#define w1 mccCurved_Guide_Section_I_34_w1
#define h1 mccCurved_Guide_Section_I_34_h1
#define w2 mccCurved_Guide_Section_I_34_w2
#define h2 mccCurved_Guide_Section_I_34_h2
#define l mccCurved_Guide_Section_I_34_l
#define R0 mccCurved_Guide_Section_I_34_R0
#define Qc mccCurved_Guide_Section_I_34_Qc
#define alpha mccCurved_Guide_Section_I_34_alpha
#define m mccCurved_Guide_Section_I_34_m
#define W mccCurved_Guide_Section_I_34_W
#define nslit mccCurved_Guide_Section_I_34_nslit
#define d mccCurved_Guide_Section_I_34_d
#define mleft mccCurved_Guide_Section_I_34_mleft
#define mright mccCurved_Guide_Section_I_34_mright
#define mtop mccCurved_Guide_Section_I_34_mtop
#define mbottom mccCurved_Guide_Section_I_34_mbottom
#define nhslit mccCurved_Guide_Section_I_34_nhslit
#define G mccCurved_Guide_Section_I_34_G
#define aleft mccCurved_Guide_Section_I_34_aleft
#define aright mccCurved_Guide_Section_I_34_aright
#define atop mccCurved_Guide_Section_I_34_atop
#define abottom mccCurved_Guide_Section_I_34_abottom
#define wavy mccCurved_Guide_Section_I_34_wavy
#define wavy_z mccCurved_Guide_Section_I_34_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_34_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_34_wavy_lr
#define chamfers mccCurved_Guide_Section_I_34_chamfers
#define chamfers_z mccCurved_Guide_Section_I_34_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_34_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_34_chamfers_tb
#define nelements mccCurved_Guide_Section_I_34_nelements
#define nu mccCurved_Guide_Section_I_34_nu
#define phase mccCurved_Guide_Section_I_34_phase
#define reflect mccCurved_Guide_Section_I_34_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 35526 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_I_35. */
  SIG_MESSAGE("Curved_Guide_Section_I_35 (Init)");
#define mccompcurname  Curved_Guide_Section_I_35
#define mccompcurtype  Guide_gravity
#define mccompcurindex 35
#define GVars mccCurved_Guide_Section_I_35_GVars
#define pTable mccCurved_Guide_Section_I_35_pTable
#define w1 mccCurved_Guide_Section_I_35_w1
#define h1 mccCurved_Guide_Section_I_35_h1
#define w2 mccCurved_Guide_Section_I_35_w2
#define h2 mccCurved_Guide_Section_I_35_h2
#define l mccCurved_Guide_Section_I_35_l
#define R0 mccCurved_Guide_Section_I_35_R0
#define Qc mccCurved_Guide_Section_I_35_Qc
#define alpha mccCurved_Guide_Section_I_35_alpha
#define m mccCurved_Guide_Section_I_35_m
#define W mccCurved_Guide_Section_I_35_W
#define nslit mccCurved_Guide_Section_I_35_nslit
#define d mccCurved_Guide_Section_I_35_d
#define mleft mccCurved_Guide_Section_I_35_mleft
#define mright mccCurved_Guide_Section_I_35_mright
#define mtop mccCurved_Guide_Section_I_35_mtop
#define mbottom mccCurved_Guide_Section_I_35_mbottom
#define nhslit mccCurved_Guide_Section_I_35_nhslit
#define G mccCurved_Guide_Section_I_35_G
#define aleft mccCurved_Guide_Section_I_35_aleft
#define aright mccCurved_Guide_Section_I_35_aright
#define atop mccCurved_Guide_Section_I_35_atop
#define abottom mccCurved_Guide_Section_I_35_abottom
#define wavy mccCurved_Guide_Section_I_35_wavy
#define wavy_z mccCurved_Guide_Section_I_35_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_35_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_35_wavy_lr
#define chamfers mccCurved_Guide_Section_I_35_chamfers
#define chamfers_z mccCurved_Guide_Section_I_35_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_35_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_35_chamfers_tb
#define nelements mccCurved_Guide_Section_I_35_nelements
#define nu mccCurved_Guide_Section_I_35_nu
#define phase mccCurved_Guide_Section_I_35_phase
#define reflect mccCurved_Guide_Section_I_35_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 35660 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_I_36. */
  SIG_MESSAGE("Curved_Guide_Section_I_36 (Init)");
#define mccompcurname  Curved_Guide_Section_I_36
#define mccompcurtype  Guide_gravity
#define mccompcurindex 36
#define GVars mccCurved_Guide_Section_I_36_GVars
#define pTable mccCurved_Guide_Section_I_36_pTable
#define w1 mccCurved_Guide_Section_I_36_w1
#define h1 mccCurved_Guide_Section_I_36_h1
#define w2 mccCurved_Guide_Section_I_36_w2
#define h2 mccCurved_Guide_Section_I_36_h2
#define l mccCurved_Guide_Section_I_36_l
#define R0 mccCurved_Guide_Section_I_36_R0
#define Qc mccCurved_Guide_Section_I_36_Qc
#define alpha mccCurved_Guide_Section_I_36_alpha
#define m mccCurved_Guide_Section_I_36_m
#define W mccCurved_Guide_Section_I_36_W
#define nslit mccCurved_Guide_Section_I_36_nslit
#define d mccCurved_Guide_Section_I_36_d
#define mleft mccCurved_Guide_Section_I_36_mleft
#define mright mccCurved_Guide_Section_I_36_mright
#define mtop mccCurved_Guide_Section_I_36_mtop
#define mbottom mccCurved_Guide_Section_I_36_mbottom
#define nhslit mccCurved_Guide_Section_I_36_nhslit
#define G mccCurved_Guide_Section_I_36_G
#define aleft mccCurved_Guide_Section_I_36_aleft
#define aright mccCurved_Guide_Section_I_36_aright
#define atop mccCurved_Guide_Section_I_36_atop
#define abottom mccCurved_Guide_Section_I_36_abottom
#define wavy mccCurved_Guide_Section_I_36_wavy
#define wavy_z mccCurved_Guide_Section_I_36_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_36_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_36_wavy_lr
#define chamfers mccCurved_Guide_Section_I_36_chamfers
#define chamfers_z mccCurved_Guide_Section_I_36_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_36_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_36_chamfers_tb
#define nelements mccCurved_Guide_Section_I_36_nelements
#define nu mccCurved_Guide_Section_I_36_nu
#define phase mccCurved_Guide_Section_I_36_phase
#define reflect mccCurved_Guide_Section_I_36_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 35794 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_I_37. */
  SIG_MESSAGE("Curved_Guide_Section_I_37 (Init)");
#define mccompcurname  Curved_Guide_Section_I_37
#define mccompcurtype  Guide_gravity
#define mccompcurindex 37
#define GVars mccCurved_Guide_Section_I_37_GVars
#define pTable mccCurved_Guide_Section_I_37_pTable
#define w1 mccCurved_Guide_Section_I_37_w1
#define h1 mccCurved_Guide_Section_I_37_h1
#define w2 mccCurved_Guide_Section_I_37_w2
#define h2 mccCurved_Guide_Section_I_37_h2
#define l mccCurved_Guide_Section_I_37_l
#define R0 mccCurved_Guide_Section_I_37_R0
#define Qc mccCurved_Guide_Section_I_37_Qc
#define alpha mccCurved_Guide_Section_I_37_alpha
#define m mccCurved_Guide_Section_I_37_m
#define W mccCurved_Guide_Section_I_37_W
#define nslit mccCurved_Guide_Section_I_37_nslit
#define d mccCurved_Guide_Section_I_37_d
#define mleft mccCurved_Guide_Section_I_37_mleft
#define mright mccCurved_Guide_Section_I_37_mright
#define mtop mccCurved_Guide_Section_I_37_mtop
#define mbottom mccCurved_Guide_Section_I_37_mbottom
#define nhslit mccCurved_Guide_Section_I_37_nhslit
#define G mccCurved_Guide_Section_I_37_G
#define aleft mccCurved_Guide_Section_I_37_aleft
#define aright mccCurved_Guide_Section_I_37_aright
#define atop mccCurved_Guide_Section_I_37_atop
#define abottom mccCurved_Guide_Section_I_37_abottom
#define wavy mccCurved_Guide_Section_I_37_wavy
#define wavy_z mccCurved_Guide_Section_I_37_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_37_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_37_wavy_lr
#define chamfers mccCurved_Guide_Section_I_37_chamfers
#define chamfers_z mccCurved_Guide_Section_I_37_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_37_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_37_chamfers_tb
#define nelements mccCurved_Guide_Section_I_37_nelements
#define nu mccCurved_Guide_Section_I_37_nu
#define phase mccCurved_Guide_Section_I_37_phase
#define reflect mccCurved_Guide_Section_I_37_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 35928 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_I_38. */
  SIG_MESSAGE("Curved_Guide_Section_I_38 (Init)");
#define mccompcurname  Curved_Guide_Section_I_38
#define mccompcurtype  Guide_gravity
#define mccompcurindex 38
#define GVars mccCurved_Guide_Section_I_38_GVars
#define pTable mccCurved_Guide_Section_I_38_pTable
#define w1 mccCurved_Guide_Section_I_38_w1
#define h1 mccCurved_Guide_Section_I_38_h1
#define w2 mccCurved_Guide_Section_I_38_w2
#define h2 mccCurved_Guide_Section_I_38_h2
#define l mccCurved_Guide_Section_I_38_l
#define R0 mccCurved_Guide_Section_I_38_R0
#define Qc mccCurved_Guide_Section_I_38_Qc
#define alpha mccCurved_Guide_Section_I_38_alpha
#define m mccCurved_Guide_Section_I_38_m
#define W mccCurved_Guide_Section_I_38_W
#define nslit mccCurved_Guide_Section_I_38_nslit
#define d mccCurved_Guide_Section_I_38_d
#define mleft mccCurved_Guide_Section_I_38_mleft
#define mright mccCurved_Guide_Section_I_38_mright
#define mtop mccCurved_Guide_Section_I_38_mtop
#define mbottom mccCurved_Guide_Section_I_38_mbottom
#define nhslit mccCurved_Guide_Section_I_38_nhslit
#define G mccCurved_Guide_Section_I_38_G
#define aleft mccCurved_Guide_Section_I_38_aleft
#define aright mccCurved_Guide_Section_I_38_aright
#define atop mccCurved_Guide_Section_I_38_atop
#define abottom mccCurved_Guide_Section_I_38_abottom
#define wavy mccCurved_Guide_Section_I_38_wavy
#define wavy_z mccCurved_Guide_Section_I_38_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_38_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_38_wavy_lr
#define chamfers mccCurved_Guide_Section_I_38_chamfers
#define chamfers_z mccCurved_Guide_Section_I_38_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_38_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_38_chamfers_tb
#define nelements mccCurved_Guide_Section_I_38_nelements
#define nu mccCurved_Guide_Section_I_38_nu
#define phase mccCurved_Guide_Section_I_38_phase
#define reflect mccCurved_Guide_Section_I_38_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 36062 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_I_short. */
  SIG_MESSAGE("Curved_Guide_Section_I_short (Init)");
#define mccompcurname  Curved_Guide_Section_I_short
#define mccompcurtype  Guide_gravity
#define mccompcurindex 39
#define GVars mccCurved_Guide_Section_I_short_GVars
#define pTable mccCurved_Guide_Section_I_short_pTable
#define w1 mccCurved_Guide_Section_I_short_w1
#define h1 mccCurved_Guide_Section_I_short_h1
#define w2 mccCurved_Guide_Section_I_short_w2
#define h2 mccCurved_Guide_Section_I_short_h2
#define l mccCurved_Guide_Section_I_short_l
#define R0 mccCurved_Guide_Section_I_short_R0
#define Qc mccCurved_Guide_Section_I_short_Qc
#define alpha mccCurved_Guide_Section_I_short_alpha
#define m mccCurved_Guide_Section_I_short_m
#define W mccCurved_Guide_Section_I_short_W
#define nslit mccCurved_Guide_Section_I_short_nslit
#define d mccCurved_Guide_Section_I_short_d
#define mleft mccCurved_Guide_Section_I_short_mleft
#define mright mccCurved_Guide_Section_I_short_mright
#define mtop mccCurved_Guide_Section_I_short_mtop
#define mbottom mccCurved_Guide_Section_I_short_mbottom
#define nhslit mccCurved_Guide_Section_I_short_nhslit
#define G mccCurved_Guide_Section_I_short_G
#define aleft mccCurved_Guide_Section_I_short_aleft
#define aright mccCurved_Guide_Section_I_short_aright
#define atop mccCurved_Guide_Section_I_short_atop
#define abottom mccCurved_Guide_Section_I_short_abottom
#define wavy mccCurved_Guide_Section_I_short_wavy
#define wavy_z mccCurved_Guide_Section_I_short_wavy_z
#define wavy_tb mccCurved_Guide_Section_I_short_wavy_tb
#define wavy_lr mccCurved_Guide_Section_I_short_wavy_lr
#define chamfers mccCurved_Guide_Section_I_short_chamfers
#define chamfers_z mccCurved_Guide_Section_I_short_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_I_short_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_I_short_chamfers_tb
#define nelements mccCurved_Guide_Section_I_short_nelements
#define nu mccCurved_Guide_Section_I_short_nu
#define phase mccCurved_Guide_Section_I_short_phase
#define reflect mccCurved_Guide_Section_I_short_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 36196 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap3_start. */
  SIG_MESSAGE("Gap3_start (Init)");

  /* Initializations for component Gap3_start_Lam. */
  SIG_MESSAGE("Gap3_start_Lam (Init)");
#define mccompcurname  Gap3_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 41
#define nL mccGap3_start_Lam_nL
#define L_N mccGap3_start_Lam_L_N
#define L_p mccGap3_start_Lam_L_p
#define L_p2 mccGap3_start_Lam_L_p2
#define filename mccGap3_start_Lam_filename
#define xmin mccGap3_start_Lam_xmin
#define xmax mccGap3_start_Lam_xmax
#define ymin mccGap3_start_Lam_ymin
#define ymax mccGap3_start_Lam_ymax
#define xwidth mccGap3_start_Lam_xwidth
#define yheight mccGap3_start_Lam_yheight
#define Lmin mccGap3_start_Lam_Lmin
#define Lmax mccGap3_start_Lam_Lmax
#define restore_neutron mccGap3_start_Lam_restore_neutron
#define nowritefile mccGap3_start_Lam_nowritefile
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 36281 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component CGS1_end. */
  SIG_MESSAGE("CGS1_end (Init)");
#define mccompcurname  CGS1_end
#define mccompcurtype  PSD_monitor
#define mccompcurindex 42
#define PSD_N mccCGS1_end_PSD_N
#define PSD_p mccCGS1_end_PSD_p
#define PSD_p2 mccCGS1_end_PSD_p2
#define nx mccCGS1_end_nx
#define ny mccCGS1_end_ny
#define filename mccCGS1_end_filename
#define xmin mccCGS1_end_xmin
#define xmax mccCGS1_end_xmax
#define ymin mccCGS1_end_ymin
#define ymax mccCGS1_end_ymax
#define xwidth mccCGS1_end_xwidth
#define yheight mccCGS1_end_yheight
#define restore_neutron mccCGS1_end_restore_neutron
#line 68 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
  if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

  if ((xmin >= xmax) || (ymin >= ymax)){
    printf("PSD_monitor: %s: Null detection area !\n"
           "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
    NAME_CURRENT_COMP);
    exit(0);
  }

  PSD_N = create_darr2d(nx, ny);
  PSD_p = create_darr2d(nx, ny);
  PSD_p2 = create_darr2d(nx, ny);

  int i, j;
  for (i=0; i<nx; i++){
    for (j=0; j<ny; j++){
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
    }
  }
}
#line 36344 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component before_Chopper1_ToF. */
  SIG_MESSAGE("before_Chopper1_ToF (Init)");
#define mccompcurname  before_Chopper1_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 43
#define nt mccbefore_Chopper1_ToF_nt
#define TOF_N mccbefore_Chopper1_ToF_TOF_N
#define TOF_p mccbefore_Chopper1_ToF_TOF_p
#define TOF_p2 mccbefore_Chopper1_ToF_TOF_p2
#define t_min mccbefore_Chopper1_ToF_t_min
#define t_max mccbefore_Chopper1_ToF_t_max
#define delta_t mccbefore_Chopper1_ToF_delta_t
#define filename mccbefore_Chopper1_ToF_filename
#define xmin mccbefore_Chopper1_ToF_xmin
#define xmax mccbefore_Chopper1_ToF_xmax
#define ymin mccbefore_Chopper1_ToF_ymin
#define ymax mccbefore_Chopper1_ToF_ymax
#define xwidth mccbefore_Chopper1_ToF_xwidth
#define yheight mccbefore_Chopper1_ToF_yheight
#define tmin mccbefore_Chopper1_ToF_tmin
#define tmax mccbefore_Chopper1_ToF_tmax
#define dt mccbefore_Chopper1_ToF_dt
#define restore_neutron mccbefore_Chopper1_ToF_restore_neutron
#define nowritefile mccbefore_Chopper1_ToF_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 36419 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component before_Chopper1_ToF_Z. */
  SIG_MESSAGE("before_Chopper1_ToF_Z (Init)");
#define mccompcurname  before_Chopper1_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 44
#define nt mccbefore_Chopper1_ToF_Z_nt
#define TOF_N mccbefore_Chopper1_ToF_Z_TOF_N
#define TOF_p mccbefore_Chopper1_ToF_Z_TOF_p
#define TOF_p2 mccbefore_Chopper1_ToF_Z_TOF_p2
#define t_min mccbefore_Chopper1_ToF_Z_t_min
#define t_max mccbefore_Chopper1_ToF_Z_t_max
#define delta_t mccbefore_Chopper1_ToF_Z_delta_t
#define filename mccbefore_Chopper1_ToF_Z_filename
#define xmin mccbefore_Chopper1_ToF_Z_xmin
#define xmax mccbefore_Chopper1_ToF_Z_xmax
#define ymin mccbefore_Chopper1_ToF_Z_ymin
#define ymax mccbefore_Chopper1_ToF_Z_ymax
#define xwidth mccbefore_Chopper1_ToF_Z_xwidth
#define yheight mccbefore_Chopper1_ToF_Z_yheight
#define tmin mccbefore_Chopper1_ToF_Z_tmin
#define tmax mccbefore_Chopper1_ToF_Z_tmax
#define dt mccbefore_Chopper1_ToF_Z_dt
#define restore_neutron mccbefore_Chopper1_ToF_Z_restore_neutron
#define nowritefile mccbefore_Chopper1_ToF_Z_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 36500 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Chopper1. */
  SIG_MESSAGE("Chopper1 (Init)");
#define mccompcurname  Chopper1
#define mccompcurtype  DiskChopper
#define mccompcurindex 45
#define Tg mccChopper1_Tg
#define To mccChopper1_To
#define delta_y mccChopper1_delta_y
#define height mccChopper1_height
#define omega mccChopper1_omega
#define theta_0 mccChopper1_theta_0
#define radius mccChopper1_radius
#define yheight mccChopper1_yheight
#define nu mccChopper1_nu
#define nslit mccChopper1_nslit
#define jitter mccChopper1_jitter
#define delay mccChopper1_delay
#define isfirst mccChopper1_isfirst
#define n_pulse mccChopper1_n_pulse
#define abs_out mccChopper1_abs_out
#define phase mccChopper1_phase
#define xwidth mccChopper1_xwidth
#define verbose mccChopper1_verbose
#line 70 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/DiskChopper.comp"
{
/* If slit height 'unset', assume full opening */
if (yheight == 0) {
        height=radius;
      } else {
        height=yheight;
      }
      delta_y = radius-height/2; /* radius at beam center */
      omega=2.0*PI*nu; /* rad/s */
      if (xwidth && !theta_0 && radius) theta_0 = 2*RAD2DEG*asin(xwidth/2/delta_y);

      if (nslit<=0 || theta_0 <= 0 || radius <=0)
      { fprintf(stderr,"DiskChopper: %s: nslit, theta_0 and radius must be > 0\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (nslit*theta_0 >= 360)
      { fprintf(stderr,"DiskChopper: %s: nslit * theta_0 exceeds 2PI\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (yheight && yheight>radius) {
        fprintf(stderr,"DiskChopper: %s: yheight must be < radius\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (isfirst && n_pulse <=0)
      { fprintf(stderr,"DiskChopper: %s: wrong First chopper pulse number (n_pulse=%g)\n", NAME_CURRENT_COMP, n_pulse);
        exit(-1); }
      if (!omega) {
        fprintf(stderr,"DiskChopper: %s WARNING: chopper frequency is 0!\n", NAME_CURRENT_COMP);
        omega = 1e-15; /* We should actually use machine epsilon here... */
      }
      if (!abs_out) {
        fprintf(stderr,"DiskChopper: %s WARNING: chopper will NOT absorb neutrons outside radius %g [m]\n", NAME_CURRENT_COMP, radius);
      }

      theta_0*=DEG2RAD;


      /* Calulate delay from phase and vice versa */
      if (phase) {
        if (delay) {
          fprintf(stderr,"DiskChopper: %s WARNING: delay AND phase specified. Using phase setting\n", NAME_CURRENT_COMP);
        }
        phase*=DEG2RAD;
        /* 'Delay' should always be a delay, taking rotation direction into account: */
        delay=phase/fabs(omega);
      } else {
        phase=delay*omega;  /* rad */
      }

      /* Time from opening of slit to next opening of slit */
      Tg=2.0*PI/fabs(omega)/nslit;

      /* How long can neutrons pass the Chopper at a single point */
      To=theta_0/fabs(omega);

      if (!xwidth) xwidth=2*delta_y*sin(theta_0/2);

      if (verbose && nu) {
        printf("DiskChopper: %s: frequency=%g [Hz] %g [rpm], time frame=%g [s] phase=%g [deg]\n",
          NAME_CURRENT_COMP, nu, nu*60, Tg, phase*RAD2DEG);
        printf("             %g slits, angle=%g [deg] height=%g [m], width=%g [m] at radius=%g [m]\n",
          nslit, theta_0*RAD2DEG, height, xwidth, delta_y);
      }
}
#line 36609 "./SNS_BASIS.c"
#undef verbose
#undef xwidth
#undef phase
#undef abs_out
#undef n_pulse
#undef isfirst
#undef delay
#undef jitter
#undef nslit
#undef nu
#undef yheight
#undef radius
#undef theta_0
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Chopper1_ToF. */
  SIG_MESSAGE("Chopper1_ToF (Init)");
#define mccompcurname  Chopper1_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 46
#define nt mccChopper1_ToF_nt
#define TOF_N mccChopper1_ToF_TOF_N
#define TOF_p mccChopper1_ToF_TOF_p
#define TOF_p2 mccChopper1_ToF_TOF_p2
#define t_min mccChopper1_ToF_t_min
#define t_max mccChopper1_ToF_t_max
#define delta_t mccChopper1_ToF_delta_t
#define filename mccChopper1_ToF_filename
#define xmin mccChopper1_ToF_xmin
#define xmax mccChopper1_ToF_xmax
#define ymin mccChopper1_ToF_ymin
#define ymax mccChopper1_ToF_ymax
#define xwidth mccChopper1_ToF_xwidth
#define yheight mccChopper1_ToF_yheight
#define tmin mccChopper1_ToF_tmin
#define tmax mccChopper1_ToF_tmax
#define dt mccChopper1_ToF_dt
#define restore_neutron mccChopper1_ToF_restore_neutron
#define nowritefile mccChopper1_ToF_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 36689 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Chopper1_ToF_Z. */
  SIG_MESSAGE("Chopper1_ToF_Z (Init)");
#define mccompcurname  Chopper1_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 47
#define nt mccChopper1_ToF_Z_nt
#define TOF_N mccChopper1_ToF_Z_TOF_N
#define TOF_p mccChopper1_ToF_Z_TOF_p
#define TOF_p2 mccChopper1_ToF_Z_TOF_p2
#define t_min mccChopper1_ToF_Z_t_min
#define t_max mccChopper1_ToF_Z_t_max
#define delta_t mccChopper1_ToF_Z_delta_t
#define filename mccChopper1_ToF_Z_filename
#define xmin mccChopper1_ToF_Z_xmin
#define xmax mccChopper1_ToF_Z_xmax
#define ymin mccChopper1_ToF_Z_ymin
#define ymax mccChopper1_ToF_Z_ymax
#define xwidth mccChopper1_ToF_Z_xwidth
#define yheight mccChopper1_ToF_Z_yheight
#define tmin mccChopper1_ToF_Z_tmin
#define tmax mccChopper1_ToF_Z_tmax
#define dt mccChopper1_ToF_Z_dt
#define restore_neutron mccChopper1_ToF_Z_restore_neutron
#define nowritefile mccChopper1_ToF_Z_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 36770 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap3_end_Lam. */
  SIG_MESSAGE("Gap3_end_Lam (Init)");
#define mccompcurname  Gap3_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 48
#define nL mccGap3_end_Lam_nL
#define L_N mccGap3_end_Lam_L_N
#define L_p mccGap3_end_Lam_L_p
#define L_p2 mccGap3_end_Lam_L_p2
#define filename mccGap3_end_Lam_filename
#define xmin mccGap3_end_Lam_xmin
#define xmax mccGap3_end_Lam_xmax
#define ymin mccGap3_end_Lam_ymin
#define ymax mccGap3_end_Lam_ymax
#define xwidth mccGap3_end_Lam_xwidth
#define yheight mccGap3_end_Lam_yheight
#define Lmin mccGap3_end_Lam_Lmin
#define Lmax mccGap3_end_Lam_Lmax
#define restore_neutron mccGap3_end_Lam_restore_neutron
#define nowritefile mccGap3_end_Lam_nowritefile
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 36835 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap3_end_PSD. */
  SIG_MESSAGE("Gap3_end_PSD (Init)");
#define mccompcurname  Gap3_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 49
#define PSD_N mccGap3_end_PSD_PSD_N
#define PSD_p mccGap3_end_PSD_PSD_p
#define PSD_p2 mccGap3_end_PSD_PSD_p2
#define nx mccGap3_end_PSD_nx
#define ny mccGap3_end_PSD_ny
#define filename mccGap3_end_PSD_filename
#define xmin mccGap3_end_PSD_xmin
#define xmax mccGap3_end_PSD_xmax
#define ymin mccGap3_end_PSD_ymin
#define ymax mccGap3_end_PSD_ymax
#define xwidth mccGap3_end_PSD_xwidth
#define yheight mccGap3_end_PSD_yheight
#define restore_neutron mccGap3_end_PSD_restore_neutron
#line 68 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
  if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

  if ((xmin >= xmax) || (ymin >= ymax)){
    printf("PSD_monitor: %s: Null detection area !\n"
           "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
    NAME_CURRENT_COMP);
    exit(0);
  }

  PSD_N = create_darr2d(nx, ny);
  PSD_p = create_darr2d(nx, ny);
  PSD_p2 = create_darr2d(nx, ny);

  int i, j;
  for (i=0; i<nx; i++){
    for (j=0; j<ny; j++){
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
    }
  }
}
#line 36898 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap3_end. */
  SIG_MESSAGE("Gap3_end (Init)");

  /* Initializations for component Curved_Guide_Section_II. */
  SIG_MESSAGE("Curved_Guide_Section_II (Init)");
#define mccompcurname  Curved_Guide_Section_II
#define mccompcurtype  Guide_gravity
#define mccompcurindex 51
#define GVars mccCurved_Guide_Section_II_GVars
#define pTable mccCurved_Guide_Section_II_pTable
#define w1 mccCurved_Guide_Section_II_w1
#define h1 mccCurved_Guide_Section_II_h1
#define w2 mccCurved_Guide_Section_II_w2
#define h2 mccCurved_Guide_Section_II_h2
#define l mccCurved_Guide_Section_II_l
#define R0 mccCurved_Guide_Section_II_R0
#define Qc mccCurved_Guide_Section_II_Qc
#define alpha mccCurved_Guide_Section_II_alpha
#define m mccCurved_Guide_Section_II_m
#define W mccCurved_Guide_Section_II_W
#define nslit mccCurved_Guide_Section_II_nslit
#define d mccCurved_Guide_Section_II_d
#define mleft mccCurved_Guide_Section_II_mleft
#define mright mccCurved_Guide_Section_II_mright
#define mtop mccCurved_Guide_Section_II_mtop
#define mbottom mccCurved_Guide_Section_II_mbottom
#define nhslit mccCurved_Guide_Section_II_nhslit
#define G mccCurved_Guide_Section_II_G
#define aleft mccCurved_Guide_Section_II_aleft
#define aright mccCurved_Guide_Section_II_aright
#define atop mccCurved_Guide_Section_II_atop
#define abottom mccCurved_Guide_Section_II_abottom
#define wavy mccCurved_Guide_Section_II_wavy
#define wavy_z mccCurved_Guide_Section_II_wavy_z
#define wavy_tb mccCurved_Guide_Section_II_wavy_tb
#define wavy_lr mccCurved_Guide_Section_II_wavy_lr
#define chamfers mccCurved_Guide_Section_II_chamfers
#define chamfers_z mccCurved_Guide_Section_II_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_II_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_II_chamfers_tb
#define nelements mccCurved_Guide_Section_II_nelements
#define nu mccCurved_Guide_Section_II_nu
#define phase mccCurved_Guide_Section_II_phase
#define reflect mccCurved_Guide_Section_II_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 37012 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_II_52. */
  SIG_MESSAGE("Curved_Guide_Section_II_52 (Init)");
#define mccompcurname  Curved_Guide_Section_II_52
#define mccompcurtype  Guide_gravity
#define mccompcurindex 52
#define GVars mccCurved_Guide_Section_II_52_GVars
#define pTable mccCurved_Guide_Section_II_52_pTable
#define w1 mccCurved_Guide_Section_II_52_w1
#define h1 mccCurved_Guide_Section_II_52_h1
#define w2 mccCurved_Guide_Section_II_52_w2
#define h2 mccCurved_Guide_Section_II_52_h2
#define l mccCurved_Guide_Section_II_52_l
#define R0 mccCurved_Guide_Section_II_52_R0
#define Qc mccCurved_Guide_Section_II_52_Qc
#define alpha mccCurved_Guide_Section_II_52_alpha
#define m mccCurved_Guide_Section_II_52_m
#define W mccCurved_Guide_Section_II_52_W
#define nslit mccCurved_Guide_Section_II_52_nslit
#define d mccCurved_Guide_Section_II_52_d
#define mleft mccCurved_Guide_Section_II_52_mleft
#define mright mccCurved_Guide_Section_II_52_mright
#define mtop mccCurved_Guide_Section_II_52_mtop
#define mbottom mccCurved_Guide_Section_II_52_mbottom
#define nhslit mccCurved_Guide_Section_II_52_nhslit
#define G mccCurved_Guide_Section_II_52_G
#define aleft mccCurved_Guide_Section_II_52_aleft
#define aright mccCurved_Guide_Section_II_52_aright
#define atop mccCurved_Guide_Section_II_52_atop
#define abottom mccCurved_Guide_Section_II_52_abottom
#define wavy mccCurved_Guide_Section_II_52_wavy
#define wavy_z mccCurved_Guide_Section_II_52_wavy_z
#define wavy_tb mccCurved_Guide_Section_II_52_wavy_tb
#define wavy_lr mccCurved_Guide_Section_II_52_wavy_lr
#define chamfers mccCurved_Guide_Section_II_52_chamfers
#define chamfers_z mccCurved_Guide_Section_II_52_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_II_52_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_II_52_chamfers_tb
#define nelements mccCurved_Guide_Section_II_52_nelements
#define nu mccCurved_Guide_Section_II_52_nu
#define phase mccCurved_Guide_Section_II_52_phase
#define reflect mccCurved_Guide_Section_II_52_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 37146 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_II_53. */
  SIG_MESSAGE("Curved_Guide_Section_II_53 (Init)");
#define mccompcurname  Curved_Guide_Section_II_53
#define mccompcurtype  Guide_gravity
#define mccompcurindex 53
#define GVars mccCurved_Guide_Section_II_53_GVars
#define pTable mccCurved_Guide_Section_II_53_pTable
#define w1 mccCurved_Guide_Section_II_53_w1
#define h1 mccCurved_Guide_Section_II_53_h1
#define w2 mccCurved_Guide_Section_II_53_w2
#define h2 mccCurved_Guide_Section_II_53_h2
#define l mccCurved_Guide_Section_II_53_l
#define R0 mccCurved_Guide_Section_II_53_R0
#define Qc mccCurved_Guide_Section_II_53_Qc
#define alpha mccCurved_Guide_Section_II_53_alpha
#define m mccCurved_Guide_Section_II_53_m
#define W mccCurved_Guide_Section_II_53_W
#define nslit mccCurved_Guide_Section_II_53_nslit
#define d mccCurved_Guide_Section_II_53_d
#define mleft mccCurved_Guide_Section_II_53_mleft
#define mright mccCurved_Guide_Section_II_53_mright
#define mtop mccCurved_Guide_Section_II_53_mtop
#define mbottom mccCurved_Guide_Section_II_53_mbottom
#define nhslit mccCurved_Guide_Section_II_53_nhslit
#define G mccCurved_Guide_Section_II_53_G
#define aleft mccCurved_Guide_Section_II_53_aleft
#define aright mccCurved_Guide_Section_II_53_aright
#define atop mccCurved_Guide_Section_II_53_atop
#define abottom mccCurved_Guide_Section_II_53_abottom
#define wavy mccCurved_Guide_Section_II_53_wavy
#define wavy_z mccCurved_Guide_Section_II_53_wavy_z
#define wavy_tb mccCurved_Guide_Section_II_53_wavy_tb
#define wavy_lr mccCurved_Guide_Section_II_53_wavy_lr
#define chamfers mccCurved_Guide_Section_II_53_chamfers
#define chamfers_z mccCurved_Guide_Section_II_53_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_II_53_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_II_53_chamfers_tb
#define nelements mccCurved_Guide_Section_II_53_nelements
#define nu mccCurved_Guide_Section_II_53_nu
#define phase mccCurved_Guide_Section_II_53_phase
#define reflect mccCurved_Guide_Section_II_53_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 37280 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_II_54. */
  SIG_MESSAGE("Curved_Guide_Section_II_54 (Init)");
#define mccompcurname  Curved_Guide_Section_II_54
#define mccompcurtype  Guide_gravity
#define mccompcurindex 54
#define GVars mccCurved_Guide_Section_II_54_GVars
#define pTable mccCurved_Guide_Section_II_54_pTable
#define w1 mccCurved_Guide_Section_II_54_w1
#define h1 mccCurved_Guide_Section_II_54_h1
#define w2 mccCurved_Guide_Section_II_54_w2
#define h2 mccCurved_Guide_Section_II_54_h2
#define l mccCurved_Guide_Section_II_54_l
#define R0 mccCurved_Guide_Section_II_54_R0
#define Qc mccCurved_Guide_Section_II_54_Qc
#define alpha mccCurved_Guide_Section_II_54_alpha
#define m mccCurved_Guide_Section_II_54_m
#define W mccCurved_Guide_Section_II_54_W
#define nslit mccCurved_Guide_Section_II_54_nslit
#define d mccCurved_Guide_Section_II_54_d
#define mleft mccCurved_Guide_Section_II_54_mleft
#define mright mccCurved_Guide_Section_II_54_mright
#define mtop mccCurved_Guide_Section_II_54_mtop
#define mbottom mccCurved_Guide_Section_II_54_mbottom
#define nhslit mccCurved_Guide_Section_II_54_nhslit
#define G mccCurved_Guide_Section_II_54_G
#define aleft mccCurved_Guide_Section_II_54_aleft
#define aright mccCurved_Guide_Section_II_54_aright
#define atop mccCurved_Guide_Section_II_54_atop
#define abottom mccCurved_Guide_Section_II_54_abottom
#define wavy mccCurved_Guide_Section_II_54_wavy
#define wavy_z mccCurved_Guide_Section_II_54_wavy_z
#define wavy_tb mccCurved_Guide_Section_II_54_wavy_tb
#define wavy_lr mccCurved_Guide_Section_II_54_wavy_lr
#define chamfers mccCurved_Guide_Section_II_54_chamfers
#define chamfers_z mccCurved_Guide_Section_II_54_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_II_54_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_II_54_chamfers_tb
#define nelements mccCurved_Guide_Section_II_54_nelements
#define nu mccCurved_Guide_Section_II_54_nu
#define phase mccCurved_Guide_Section_II_54_phase
#define reflect mccCurved_Guide_Section_II_54_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 37414 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_II_55. */
  SIG_MESSAGE("Curved_Guide_Section_II_55 (Init)");
#define mccompcurname  Curved_Guide_Section_II_55
#define mccompcurtype  Guide_gravity
#define mccompcurindex 55
#define GVars mccCurved_Guide_Section_II_55_GVars
#define pTable mccCurved_Guide_Section_II_55_pTable
#define w1 mccCurved_Guide_Section_II_55_w1
#define h1 mccCurved_Guide_Section_II_55_h1
#define w2 mccCurved_Guide_Section_II_55_w2
#define h2 mccCurved_Guide_Section_II_55_h2
#define l mccCurved_Guide_Section_II_55_l
#define R0 mccCurved_Guide_Section_II_55_R0
#define Qc mccCurved_Guide_Section_II_55_Qc
#define alpha mccCurved_Guide_Section_II_55_alpha
#define m mccCurved_Guide_Section_II_55_m
#define W mccCurved_Guide_Section_II_55_W
#define nslit mccCurved_Guide_Section_II_55_nslit
#define d mccCurved_Guide_Section_II_55_d
#define mleft mccCurved_Guide_Section_II_55_mleft
#define mright mccCurved_Guide_Section_II_55_mright
#define mtop mccCurved_Guide_Section_II_55_mtop
#define mbottom mccCurved_Guide_Section_II_55_mbottom
#define nhslit mccCurved_Guide_Section_II_55_nhslit
#define G mccCurved_Guide_Section_II_55_G
#define aleft mccCurved_Guide_Section_II_55_aleft
#define aright mccCurved_Guide_Section_II_55_aright
#define atop mccCurved_Guide_Section_II_55_atop
#define abottom mccCurved_Guide_Section_II_55_abottom
#define wavy mccCurved_Guide_Section_II_55_wavy
#define wavy_z mccCurved_Guide_Section_II_55_wavy_z
#define wavy_tb mccCurved_Guide_Section_II_55_wavy_tb
#define wavy_lr mccCurved_Guide_Section_II_55_wavy_lr
#define chamfers mccCurved_Guide_Section_II_55_chamfers
#define chamfers_z mccCurved_Guide_Section_II_55_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_II_55_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_II_55_chamfers_tb
#define nelements mccCurved_Guide_Section_II_55_nelements
#define nu mccCurved_Guide_Section_II_55_nu
#define phase mccCurved_Guide_Section_II_55_phase
#define reflect mccCurved_Guide_Section_II_55_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 37548 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_II_56. */
  SIG_MESSAGE("Curved_Guide_Section_II_56 (Init)");
#define mccompcurname  Curved_Guide_Section_II_56
#define mccompcurtype  Guide_gravity
#define mccompcurindex 56
#define GVars mccCurved_Guide_Section_II_56_GVars
#define pTable mccCurved_Guide_Section_II_56_pTable
#define w1 mccCurved_Guide_Section_II_56_w1
#define h1 mccCurved_Guide_Section_II_56_h1
#define w2 mccCurved_Guide_Section_II_56_w2
#define h2 mccCurved_Guide_Section_II_56_h2
#define l mccCurved_Guide_Section_II_56_l
#define R0 mccCurved_Guide_Section_II_56_R0
#define Qc mccCurved_Guide_Section_II_56_Qc
#define alpha mccCurved_Guide_Section_II_56_alpha
#define m mccCurved_Guide_Section_II_56_m
#define W mccCurved_Guide_Section_II_56_W
#define nslit mccCurved_Guide_Section_II_56_nslit
#define d mccCurved_Guide_Section_II_56_d
#define mleft mccCurved_Guide_Section_II_56_mleft
#define mright mccCurved_Guide_Section_II_56_mright
#define mtop mccCurved_Guide_Section_II_56_mtop
#define mbottom mccCurved_Guide_Section_II_56_mbottom
#define nhslit mccCurved_Guide_Section_II_56_nhslit
#define G mccCurved_Guide_Section_II_56_G
#define aleft mccCurved_Guide_Section_II_56_aleft
#define aright mccCurved_Guide_Section_II_56_aright
#define atop mccCurved_Guide_Section_II_56_atop
#define abottom mccCurved_Guide_Section_II_56_abottom
#define wavy mccCurved_Guide_Section_II_56_wavy
#define wavy_z mccCurved_Guide_Section_II_56_wavy_z
#define wavy_tb mccCurved_Guide_Section_II_56_wavy_tb
#define wavy_lr mccCurved_Guide_Section_II_56_wavy_lr
#define chamfers mccCurved_Guide_Section_II_56_chamfers
#define chamfers_z mccCurved_Guide_Section_II_56_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_II_56_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_II_56_chamfers_tb
#define nelements mccCurved_Guide_Section_II_56_nelements
#define nu mccCurved_Guide_Section_II_56_nu
#define phase mccCurved_Guide_Section_II_56_phase
#define reflect mccCurved_Guide_Section_II_56_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 37682 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_II_57. */
  SIG_MESSAGE("Curved_Guide_Section_II_57 (Init)");
#define mccompcurname  Curved_Guide_Section_II_57
#define mccompcurtype  Guide_gravity
#define mccompcurindex 57
#define GVars mccCurved_Guide_Section_II_57_GVars
#define pTable mccCurved_Guide_Section_II_57_pTable
#define w1 mccCurved_Guide_Section_II_57_w1
#define h1 mccCurved_Guide_Section_II_57_h1
#define w2 mccCurved_Guide_Section_II_57_w2
#define h2 mccCurved_Guide_Section_II_57_h2
#define l mccCurved_Guide_Section_II_57_l
#define R0 mccCurved_Guide_Section_II_57_R0
#define Qc mccCurved_Guide_Section_II_57_Qc
#define alpha mccCurved_Guide_Section_II_57_alpha
#define m mccCurved_Guide_Section_II_57_m
#define W mccCurved_Guide_Section_II_57_W
#define nslit mccCurved_Guide_Section_II_57_nslit
#define d mccCurved_Guide_Section_II_57_d
#define mleft mccCurved_Guide_Section_II_57_mleft
#define mright mccCurved_Guide_Section_II_57_mright
#define mtop mccCurved_Guide_Section_II_57_mtop
#define mbottom mccCurved_Guide_Section_II_57_mbottom
#define nhslit mccCurved_Guide_Section_II_57_nhslit
#define G mccCurved_Guide_Section_II_57_G
#define aleft mccCurved_Guide_Section_II_57_aleft
#define aright mccCurved_Guide_Section_II_57_aright
#define atop mccCurved_Guide_Section_II_57_atop
#define abottom mccCurved_Guide_Section_II_57_abottom
#define wavy mccCurved_Guide_Section_II_57_wavy
#define wavy_z mccCurved_Guide_Section_II_57_wavy_z
#define wavy_tb mccCurved_Guide_Section_II_57_wavy_tb
#define wavy_lr mccCurved_Guide_Section_II_57_wavy_lr
#define chamfers mccCurved_Guide_Section_II_57_chamfers
#define chamfers_z mccCurved_Guide_Section_II_57_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_II_57_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_II_57_chamfers_tb
#define nelements mccCurved_Guide_Section_II_57_nelements
#define nu mccCurved_Guide_Section_II_57_nu
#define phase mccCurved_Guide_Section_II_57_phase
#define reflect mccCurved_Guide_Section_II_57_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 37816 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_II_last. */
  SIG_MESSAGE("Curved_Guide_Section_II_last (Init)");
#define mccompcurname  Curved_Guide_Section_II_last
#define mccompcurtype  Guide_gravity
#define mccompcurindex 58
#define GVars mccCurved_Guide_Section_II_last_GVars
#define pTable mccCurved_Guide_Section_II_last_pTable
#define w1 mccCurved_Guide_Section_II_last_w1
#define h1 mccCurved_Guide_Section_II_last_h1
#define w2 mccCurved_Guide_Section_II_last_w2
#define h2 mccCurved_Guide_Section_II_last_h2
#define l mccCurved_Guide_Section_II_last_l
#define R0 mccCurved_Guide_Section_II_last_R0
#define Qc mccCurved_Guide_Section_II_last_Qc
#define alpha mccCurved_Guide_Section_II_last_alpha
#define m mccCurved_Guide_Section_II_last_m
#define W mccCurved_Guide_Section_II_last_W
#define nslit mccCurved_Guide_Section_II_last_nslit
#define d mccCurved_Guide_Section_II_last_d
#define mleft mccCurved_Guide_Section_II_last_mleft
#define mright mccCurved_Guide_Section_II_last_mright
#define mtop mccCurved_Guide_Section_II_last_mtop
#define mbottom mccCurved_Guide_Section_II_last_mbottom
#define nhslit mccCurved_Guide_Section_II_last_nhslit
#define G mccCurved_Guide_Section_II_last_G
#define aleft mccCurved_Guide_Section_II_last_aleft
#define aright mccCurved_Guide_Section_II_last_aright
#define atop mccCurved_Guide_Section_II_last_atop
#define abottom mccCurved_Guide_Section_II_last_abottom
#define wavy mccCurved_Guide_Section_II_last_wavy
#define wavy_z mccCurved_Guide_Section_II_last_wavy_z
#define wavy_tb mccCurved_Guide_Section_II_last_wavy_tb
#define wavy_lr mccCurved_Guide_Section_II_last_wavy_lr
#define chamfers mccCurved_Guide_Section_II_last_chamfers
#define chamfers_z mccCurved_Guide_Section_II_last_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_II_last_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_II_last_chamfers_tb
#define nelements mccCurved_Guide_Section_II_last_nelements
#define nu mccCurved_Guide_Section_II_last_nu
#define phase mccCurved_Guide_Section_II_last_phase
#define reflect mccCurved_Guide_Section_II_last_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 37950 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap4_start. */
  SIG_MESSAGE("Gap4_start (Init)");

  /* Initializations for component Gap4_start_Lam. */
  SIG_MESSAGE("Gap4_start_Lam (Init)");
#define mccompcurname  Gap4_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 60
#define nL mccGap4_start_Lam_nL
#define L_N mccGap4_start_Lam_L_N
#define L_p mccGap4_start_Lam_L_p
#define L_p2 mccGap4_start_Lam_L_p2
#define filename mccGap4_start_Lam_filename
#define xmin mccGap4_start_Lam_xmin
#define xmax mccGap4_start_Lam_xmax
#define ymin mccGap4_start_Lam_ymin
#define ymax mccGap4_start_Lam_ymax
#define xwidth mccGap4_start_Lam_xwidth
#define yheight mccGap4_start_Lam_yheight
#define Lmin mccGap4_start_Lam_Lmin
#define Lmax mccGap4_start_Lam_Lmax
#define restore_neutron mccGap4_start_Lam_restore_neutron
#define nowritefile mccGap4_start_Lam_nowritefile
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 38035 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap4_start_PSD. */
  SIG_MESSAGE("Gap4_start_PSD (Init)");
#define mccompcurname  Gap4_start_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 61
#define PSD_N mccGap4_start_PSD_PSD_N
#define PSD_p mccGap4_start_PSD_PSD_p
#define PSD_p2 mccGap4_start_PSD_PSD_p2
#define nx mccGap4_start_PSD_nx
#define ny mccGap4_start_PSD_ny
#define filename mccGap4_start_PSD_filename
#define xmin mccGap4_start_PSD_xmin
#define xmax mccGap4_start_PSD_xmax
#define ymin mccGap4_start_PSD_ymin
#define ymax mccGap4_start_PSD_ymax
#define xwidth mccGap4_start_PSD_xwidth
#define yheight mccGap4_start_PSD_yheight
#define restore_neutron mccGap4_start_PSD_restore_neutron
#line 68 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
  if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

  if ((xmin >= xmax) || (ymin >= ymax)){
    printf("PSD_monitor: %s: Null detection area !\n"
           "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
    NAME_CURRENT_COMP);
    exit(0);
  }

  PSD_N = create_darr2d(nx, ny);
  PSD_p = create_darr2d(nx, ny);
  PSD_p2 = create_darr2d(nx, ny);

  int i, j;
  for (i=0; i<nx; i++){
    for (j=0; j<ny; j++){
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
    }
  }
}
#line 38098 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component before_Chopper2_ToF. */
  SIG_MESSAGE("before_Chopper2_ToF (Init)");
#define mccompcurname  before_Chopper2_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 62
#define nt mccbefore_Chopper2_ToF_nt
#define TOF_N mccbefore_Chopper2_ToF_TOF_N
#define TOF_p mccbefore_Chopper2_ToF_TOF_p
#define TOF_p2 mccbefore_Chopper2_ToF_TOF_p2
#define t_min mccbefore_Chopper2_ToF_t_min
#define t_max mccbefore_Chopper2_ToF_t_max
#define delta_t mccbefore_Chopper2_ToF_delta_t
#define filename mccbefore_Chopper2_ToF_filename
#define xmin mccbefore_Chopper2_ToF_xmin
#define xmax mccbefore_Chopper2_ToF_xmax
#define ymin mccbefore_Chopper2_ToF_ymin
#define ymax mccbefore_Chopper2_ToF_ymax
#define xwidth mccbefore_Chopper2_ToF_xwidth
#define yheight mccbefore_Chopper2_ToF_yheight
#define tmin mccbefore_Chopper2_ToF_tmin
#define tmax mccbefore_Chopper2_ToF_tmax
#define dt mccbefore_Chopper2_ToF_dt
#define restore_neutron mccbefore_Chopper2_ToF_restore_neutron
#define nowritefile mccbefore_Chopper2_ToF_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 38173 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component before_Chopper2_ToF_Z. */
  SIG_MESSAGE("before_Chopper2_ToF_Z (Init)");
#define mccompcurname  before_Chopper2_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 63
#define nt mccbefore_Chopper2_ToF_Z_nt
#define TOF_N mccbefore_Chopper2_ToF_Z_TOF_N
#define TOF_p mccbefore_Chopper2_ToF_Z_TOF_p
#define TOF_p2 mccbefore_Chopper2_ToF_Z_TOF_p2
#define t_min mccbefore_Chopper2_ToF_Z_t_min
#define t_max mccbefore_Chopper2_ToF_Z_t_max
#define delta_t mccbefore_Chopper2_ToF_Z_delta_t
#define filename mccbefore_Chopper2_ToF_Z_filename
#define xmin mccbefore_Chopper2_ToF_Z_xmin
#define xmax mccbefore_Chopper2_ToF_Z_xmax
#define ymin mccbefore_Chopper2_ToF_Z_ymin
#define ymax mccbefore_Chopper2_ToF_Z_ymax
#define xwidth mccbefore_Chopper2_ToF_Z_xwidth
#define yheight mccbefore_Chopper2_ToF_Z_yheight
#define tmin mccbefore_Chopper2_ToF_Z_tmin
#define tmax mccbefore_Chopper2_ToF_Z_tmax
#define dt mccbefore_Chopper2_ToF_Z_dt
#define restore_neutron mccbefore_Chopper2_ToF_Z_restore_neutron
#define nowritefile mccbefore_Chopper2_ToF_Z_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 38254 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Chopper2. */
  SIG_MESSAGE("Chopper2 (Init)");
#define mccompcurname  Chopper2
#define mccompcurtype  DiskChopper
#define mccompcurindex 64
#define Tg mccChopper2_Tg
#define To mccChopper2_To
#define delta_y mccChopper2_delta_y
#define height mccChopper2_height
#define omega mccChopper2_omega
#define theta_0 mccChopper2_theta_0
#define radius mccChopper2_radius
#define yheight mccChopper2_yheight
#define nu mccChopper2_nu
#define nslit mccChopper2_nslit
#define jitter mccChopper2_jitter
#define delay mccChopper2_delay
#define isfirst mccChopper2_isfirst
#define n_pulse mccChopper2_n_pulse
#define abs_out mccChopper2_abs_out
#define phase mccChopper2_phase
#define xwidth mccChopper2_xwidth
#define verbose mccChopper2_verbose
#line 70 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/DiskChopper.comp"
{
/* If slit height 'unset', assume full opening */
if (yheight == 0) {
        height=radius;
      } else {
        height=yheight;
      }
      delta_y = radius-height/2; /* radius at beam center */
      omega=2.0*PI*nu; /* rad/s */
      if (xwidth && !theta_0 && radius) theta_0 = 2*RAD2DEG*asin(xwidth/2/delta_y);

      if (nslit<=0 || theta_0 <= 0 || radius <=0)
      { fprintf(stderr,"DiskChopper: %s: nslit, theta_0 and radius must be > 0\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (nslit*theta_0 >= 360)
      { fprintf(stderr,"DiskChopper: %s: nslit * theta_0 exceeds 2PI\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (yheight && yheight>radius) {
        fprintf(stderr,"DiskChopper: %s: yheight must be < radius\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (isfirst && n_pulse <=0)
      { fprintf(stderr,"DiskChopper: %s: wrong First chopper pulse number (n_pulse=%g)\n", NAME_CURRENT_COMP, n_pulse);
        exit(-1); }
      if (!omega) {
        fprintf(stderr,"DiskChopper: %s WARNING: chopper frequency is 0!\n", NAME_CURRENT_COMP);
        omega = 1e-15; /* We should actually use machine epsilon here... */
      }
      if (!abs_out) {
        fprintf(stderr,"DiskChopper: %s WARNING: chopper will NOT absorb neutrons outside radius %g [m]\n", NAME_CURRENT_COMP, radius);
      }

      theta_0*=DEG2RAD;


      /* Calulate delay from phase and vice versa */
      if (phase) {
        if (delay) {
          fprintf(stderr,"DiskChopper: %s WARNING: delay AND phase specified. Using phase setting\n", NAME_CURRENT_COMP);
        }
        phase*=DEG2RAD;
        /* 'Delay' should always be a delay, taking rotation direction into account: */
        delay=phase/fabs(omega);
      } else {
        phase=delay*omega;  /* rad */
      }

      /* Time from opening of slit to next opening of slit */
      Tg=2.0*PI/fabs(omega)/nslit;

      /* How long can neutrons pass the Chopper at a single point */
      To=theta_0/fabs(omega);

      if (!xwidth) xwidth=2*delta_y*sin(theta_0/2);

      if (verbose && nu) {
        printf("DiskChopper: %s: frequency=%g [Hz] %g [rpm], time frame=%g [s] phase=%g [deg]\n",
          NAME_CURRENT_COMP, nu, nu*60, Tg, phase*RAD2DEG);
        printf("             %g slits, angle=%g [deg] height=%g [m], width=%g [m] at radius=%g [m]\n",
          nslit, theta_0*RAD2DEG, height, xwidth, delta_y);
      }
}
#line 38363 "./SNS_BASIS.c"
#undef verbose
#undef xwidth
#undef phase
#undef abs_out
#undef n_pulse
#undef isfirst
#undef delay
#undef jitter
#undef nslit
#undef nu
#undef yheight
#undef radius
#undef theta_0
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Chopper2_ToF. */
  SIG_MESSAGE("Chopper2_ToF (Init)");
#define mccompcurname  Chopper2_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 65
#define nt mccChopper2_ToF_nt
#define TOF_N mccChopper2_ToF_TOF_N
#define TOF_p mccChopper2_ToF_TOF_p
#define TOF_p2 mccChopper2_ToF_TOF_p2
#define t_min mccChopper2_ToF_t_min
#define t_max mccChopper2_ToF_t_max
#define delta_t mccChopper2_ToF_delta_t
#define filename mccChopper2_ToF_filename
#define xmin mccChopper2_ToF_xmin
#define xmax mccChopper2_ToF_xmax
#define ymin mccChopper2_ToF_ymin
#define ymax mccChopper2_ToF_ymax
#define xwidth mccChopper2_ToF_xwidth
#define yheight mccChopper2_ToF_yheight
#define tmin mccChopper2_ToF_tmin
#define tmax mccChopper2_ToF_tmax
#define dt mccChopper2_ToF_dt
#define restore_neutron mccChopper2_ToF_restore_neutron
#define nowritefile mccChopper2_ToF_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 38443 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Chopper2_ToF_Z. */
  SIG_MESSAGE("Chopper2_ToF_Z (Init)");
#define mccompcurname  Chopper2_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 66
#define nt mccChopper2_ToF_Z_nt
#define TOF_N mccChopper2_ToF_Z_TOF_N
#define TOF_p mccChopper2_ToF_Z_TOF_p
#define TOF_p2 mccChopper2_ToF_Z_TOF_p2
#define t_min mccChopper2_ToF_Z_t_min
#define t_max mccChopper2_ToF_Z_t_max
#define delta_t mccChopper2_ToF_Z_delta_t
#define filename mccChopper2_ToF_Z_filename
#define xmin mccChopper2_ToF_Z_xmin
#define xmax mccChopper2_ToF_Z_xmax
#define ymin mccChopper2_ToF_Z_ymin
#define ymax mccChopper2_ToF_Z_ymax
#define xwidth mccChopper2_ToF_Z_xwidth
#define yheight mccChopper2_ToF_Z_yheight
#define tmin mccChopper2_ToF_Z_tmin
#define tmax mccChopper2_ToF_Z_tmax
#define dt mccChopper2_ToF_Z_dt
#define restore_neutron mccChopper2_ToF_Z_restore_neutron
#define nowritefile mccChopper2_ToF_Z_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 38524 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap4_end_Lam. */
  SIG_MESSAGE("Gap4_end_Lam (Init)");
#define mccompcurname  Gap4_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 67
#define nL mccGap4_end_Lam_nL
#define L_N mccGap4_end_Lam_L_N
#define L_p mccGap4_end_Lam_L_p
#define L_p2 mccGap4_end_Lam_L_p2
#define filename mccGap4_end_Lam_filename
#define xmin mccGap4_end_Lam_xmin
#define xmax mccGap4_end_Lam_xmax
#define ymin mccGap4_end_Lam_ymin
#define ymax mccGap4_end_Lam_ymax
#define xwidth mccGap4_end_Lam_xwidth
#define yheight mccGap4_end_Lam_yheight
#define Lmin mccGap4_end_Lam_Lmin
#define Lmax mccGap4_end_Lam_Lmax
#define restore_neutron mccGap4_end_Lam_restore_neutron
#define nowritefile mccGap4_end_Lam_nowritefile
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 38589 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap4_end_PSD. */
  SIG_MESSAGE("Gap4_end_PSD (Init)");
#define mccompcurname  Gap4_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 68
#define PSD_N mccGap4_end_PSD_PSD_N
#define PSD_p mccGap4_end_PSD_PSD_p
#define PSD_p2 mccGap4_end_PSD_PSD_p2
#define nx mccGap4_end_PSD_nx
#define ny mccGap4_end_PSD_ny
#define filename mccGap4_end_PSD_filename
#define xmin mccGap4_end_PSD_xmin
#define xmax mccGap4_end_PSD_xmax
#define ymin mccGap4_end_PSD_ymin
#define ymax mccGap4_end_PSD_ymax
#define xwidth mccGap4_end_PSD_xwidth
#define yheight mccGap4_end_PSD_yheight
#define restore_neutron mccGap4_end_PSD_restore_neutron
#line 68 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
  if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

  if ((xmin >= xmax) || (ymin >= ymax)){
    printf("PSD_monitor: %s: Null detection area !\n"
           "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
    NAME_CURRENT_COMP);
    exit(0);
  }

  PSD_N = create_darr2d(nx, ny);
  PSD_p = create_darr2d(nx, ny);
  PSD_p2 = create_darr2d(nx, ny);

  int i, j;
  for (i=0; i<nx; i++){
    for (j=0; j<ny; j++){
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
    }
  }
}
#line 38652 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap4_end. */
  SIG_MESSAGE("Gap4_end (Init)");

  /* Initializations for component Curved_Guide_Section_III. */
  SIG_MESSAGE("Curved_Guide_Section_III (Init)");
#define mccompcurname  Curved_Guide_Section_III
#define mccompcurtype  Guide_gravity
#define mccompcurindex 70
#define GVars mccCurved_Guide_Section_III_GVars
#define pTable mccCurved_Guide_Section_III_pTable
#define w1 mccCurved_Guide_Section_III_w1
#define h1 mccCurved_Guide_Section_III_h1
#define w2 mccCurved_Guide_Section_III_w2
#define h2 mccCurved_Guide_Section_III_h2
#define l mccCurved_Guide_Section_III_l
#define R0 mccCurved_Guide_Section_III_R0
#define Qc mccCurved_Guide_Section_III_Qc
#define alpha mccCurved_Guide_Section_III_alpha
#define m mccCurved_Guide_Section_III_m
#define W mccCurved_Guide_Section_III_W
#define nslit mccCurved_Guide_Section_III_nslit
#define d mccCurved_Guide_Section_III_d
#define mleft mccCurved_Guide_Section_III_mleft
#define mright mccCurved_Guide_Section_III_mright
#define mtop mccCurved_Guide_Section_III_mtop
#define mbottom mccCurved_Guide_Section_III_mbottom
#define nhslit mccCurved_Guide_Section_III_nhslit
#define G mccCurved_Guide_Section_III_G
#define aleft mccCurved_Guide_Section_III_aleft
#define aright mccCurved_Guide_Section_III_aright
#define atop mccCurved_Guide_Section_III_atop
#define abottom mccCurved_Guide_Section_III_abottom
#define wavy mccCurved_Guide_Section_III_wavy
#define wavy_z mccCurved_Guide_Section_III_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_wavy_lr
#define chamfers mccCurved_Guide_Section_III_chamfers
#define chamfers_z mccCurved_Guide_Section_III_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_chamfers_tb
#define nelements mccCurved_Guide_Section_III_nelements
#define nu mccCurved_Guide_Section_III_nu
#define phase mccCurved_Guide_Section_III_phase
#define reflect mccCurved_Guide_Section_III_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 38766 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_III_71. */
  SIG_MESSAGE("Curved_Guide_Section_III_71 (Init)");
#define mccompcurname  Curved_Guide_Section_III_71
#define mccompcurtype  Guide_gravity
#define mccompcurindex 71
#define GVars mccCurved_Guide_Section_III_71_GVars
#define pTable mccCurved_Guide_Section_III_71_pTable
#define w1 mccCurved_Guide_Section_III_71_w1
#define h1 mccCurved_Guide_Section_III_71_h1
#define w2 mccCurved_Guide_Section_III_71_w2
#define h2 mccCurved_Guide_Section_III_71_h2
#define l mccCurved_Guide_Section_III_71_l
#define R0 mccCurved_Guide_Section_III_71_R0
#define Qc mccCurved_Guide_Section_III_71_Qc
#define alpha mccCurved_Guide_Section_III_71_alpha
#define m mccCurved_Guide_Section_III_71_m
#define W mccCurved_Guide_Section_III_71_W
#define nslit mccCurved_Guide_Section_III_71_nslit
#define d mccCurved_Guide_Section_III_71_d
#define mleft mccCurved_Guide_Section_III_71_mleft
#define mright mccCurved_Guide_Section_III_71_mright
#define mtop mccCurved_Guide_Section_III_71_mtop
#define mbottom mccCurved_Guide_Section_III_71_mbottom
#define nhslit mccCurved_Guide_Section_III_71_nhslit
#define G mccCurved_Guide_Section_III_71_G
#define aleft mccCurved_Guide_Section_III_71_aleft
#define aright mccCurved_Guide_Section_III_71_aright
#define atop mccCurved_Guide_Section_III_71_atop
#define abottom mccCurved_Guide_Section_III_71_abottom
#define wavy mccCurved_Guide_Section_III_71_wavy
#define wavy_z mccCurved_Guide_Section_III_71_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_71_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_71_wavy_lr
#define chamfers mccCurved_Guide_Section_III_71_chamfers
#define chamfers_z mccCurved_Guide_Section_III_71_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_71_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_71_chamfers_tb
#define nelements mccCurved_Guide_Section_III_71_nelements
#define nu mccCurved_Guide_Section_III_71_nu
#define phase mccCurved_Guide_Section_III_71_phase
#define reflect mccCurved_Guide_Section_III_71_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 38900 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_III_72. */
  SIG_MESSAGE("Curved_Guide_Section_III_72 (Init)");
#define mccompcurname  Curved_Guide_Section_III_72
#define mccompcurtype  Guide_gravity
#define mccompcurindex 72
#define GVars mccCurved_Guide_Section_III_72_GVars
#define pTable mccCurved_Guide_Section_III_72_pTable
#define w1 mccCurved_Guide_Section_III_72_w1
#define h1 mccCurved_Guide_Section_III_72_h1
#define w2 mccCurved_Guide_Section_III_72_w2
#define h2 mccCurved_Guide_Section_III_72_h2
#define l mccCurved_Guide_Section_III_72_l
#define R0 mccCurved_Guide_Section_III_72_R0
#define Qc mccCurved_Guide_Section_III_72_Qc
#define alpha mccCurved_Guide_Section_III_72_alpha
#define m mccCurved_Guide_Section_III_72_m
#define W mccCurved_Guide_Section_III_72_W
#define nslit mccCurved_Guide_Section_III_72_nslit
#define d mccCurved_Guide_Section_III_72_d
#define mleft mccCurved_Guide_Section_III_72_mleft
#define mright mccCurved_Guide_Section_III_72_mright
#define mtop mccCurved_Guide_Section_III_72_mtop
#define mbottom mccCurved_Guide_Section_III_72_mbottom
#define nhslit mccCurved_Guide_Section_III_72_nhslit
#define G mccCurved_Guide_Section_III_72_G
#define aleft mccCurved_Guide_Section_III_72_aleft
#define aright mccCurved_Guide_Section_III_72_aright
#define atop mccCurved_Guide_Section_III_72_atop
#define abottom mccCurved_Guide_Section_III_72_abottom
#define wavy mccCurved_Guide_Section_III_72_wavy
#define wavy_z mccCurved_Guide_Section_III_72_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_72_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_72_wavy_lr
#define chamfers mccCurved_Guide_Section_III_72_chamfers
#define chamfers_z mccCurved_Guide_Section_III_72_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_72_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_72_chamfers_tb
#define nelements mccCurved_Guide_Section_III_72_nelements
#define nu mccCurved_Guide_Section_III_72_nu
#define phase mccCurved_Guide_Section_III_72_phase
#define reflect mccCurved_Guide_Section_III_72_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 39034 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_III_73. */
  SIG_MESSAGE("Curved_Guide_Section_III_73 (Init)");
#define mccompcurname  Curved_Guide_Section_III_73
#define mccompcurtype  Guide_gravity
#define mccompcurindex 73
#define GVars mccCurved_Guide_Section_III_73_GVars
#define pTable mccCurved_Guide_Section_III_73_pTable
#define w1 mccCurved_Guide_Section_III_73_w1
#define h1 mccCurved_Guide_Section_III_73_h1
#define w2 mccCurved_Guide_Section_III_73_w2
#define h2 mccCurved_Guide_Section_III_73_h2
#define l mccCurved_Guide_Section_III_73_l
#define R0 mccCurved_Guide_Section_III_73_R0
#define Qc mccCurved_Guide_Section_III_73_Qc
#define alpha mccCurved_Guide_Section_III_73_alpha
#define m mccCurved_Guide_Section_III_73_m
#define W mccCurved_Guide_Section_III_73_W
#define nslit mccCurved_Guide_Section_III_73_nslit
#define d mccCurved_Guide_Section_III_73_d
#define mleft mccCurved_Guide_Section_III_73_mleft
#define mright mccCurved_Guide_Section_III_73_mright
#define mtop mccCurved_Guide_Section_III_73_mtop
#define mbottom mccCurved_Guide_Section_III_73_mbottom
#define nhslit mccCurved_Guide_Section_III_73_nhslit
#define G mccCurved_Guide_Section_III_73_G
#define aleft mccCurved_Guide_Section_III_73_aleft
#define aright mccCurved_Guide_Section_III_73_aright
#define atop mccCurved_Guide_Section_III_73_atop
#define abottom mccCurved_Guide_Section_III_73_abottom
#define wavy mccCurved_Guide_Section_III_73_wavy
#define wavy_z mccCurved_Guide_Section_III_73_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_73_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_73_wavy_lr
#define chamfers mccCurved_Guide_Section_III_73_chamfers
#define chamfers_z mccCurved_Guide_Section_III_73_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_73_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_73_chamfers_tb
#define nelements mccCurved_Guide_Section_III_73_nelements
#define nu mccCurved_Guide_Section_III_73_nu
#define phase mccCurved_Guide_Section_III_73_phase
#define reflect mccCurved_Guide_Section_III_73_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 39168 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_III_74. */
  SIG_MESSAGE("Curved_Guide_Section_III_74 (Init)");
#define mccompcurname  Curved_Guide_Section_III_74
#define mccompcurtype  Guide_gravity
#define mccompcurindex 74
#define GVars mccCurved_Guide_Section_III_74_GVars
#define pTable mccCurved_Guide_Section_III_74_pTable
#define w1 mccCurved_Guide_Section_III_74_w1
#define h1 mccCurved_Guide_Section_III_74_h1
#define w2 mccCurved_Guide_Section_III_74_w2
#define h2 mccCurved_Guide_Section_III_74_h2
#define l mccCurved_Guide_Section_III_74_l
#define R0 mccCurved_Guide_Section_III_74_R0
#define Qc mccCurved_Guide_Section_III_74_Qc
#define alpha mccCurved_Guide_Section_III_74_alpha
#define m mccCurved_Guide_Section_III_74_m
#define W mccCurved_Guide_Section_III_74_W
#define nslit mccCurved_Guide_Section_III_74_nslit
#define d mccCurved_Guide_Section_III_74_d
#define mleft mccCurved_Guide_Section_III_74_mleft
#define mright mccCurved_Guide_Section_III_74_mright
#define mtop mccCurved_Guide_Section_III_74_mtop
#define mbottom mccCurved_Guide_Section_III_74_mbottom
#define nhslit mccCurved_Guide_Section_III_74_nhslit
#define G mccCurved_Guide_Section_III_74_G
#define aleft mccCurved_Guide_Section_III_74_aleft
#define aright mccCurved_Guide_Section_III_74_aright
#define atop mccCurved_Guide_Section_III_74_atop
#define abottom mccCurved_Guide_Section_III_74_abottom
#define wavy mccCurved_Guide_Section_III_74_wavy
#define wavy_z mccCurved_Guide_Section_III_74_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_74_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_74_wavy_lr
#define chamfers mccCurved_Guide_Section_III_74_chamfers
#define chamfers_z mccCurved_Guide_Section_III_74_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_74_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_74_chamfers_tb
#define nelements mccCurved_Guide_Section_III_74_nelements
#define nu mccCurved_Guide_Section_III_74_nu
#define phase mccCurved_Guide_Section_III_74_phase
#define reflect mccCurved_Guide_Section_III_74_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 39302 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_III_75. */
  SIG_MESSAGE("Curved_Guide_Section_III_75 (Init)");
#define mccompcurname  Curved_Guide_Section_III_75
#define mccompcurtype  Guide_gravity
#define mccompcurindex 75
#define GVars mccCurved_Guide_Section_III_75_GVars
#define pTable mccCurved_Guide_Section_III_75_pTable
#define w1 mccCurved_Guide_Section_III_75_w1
#define h1 mccCurved_Guide_Section_III_75_h1
#define w2 mccCurved_Guide_Section_III_75_w2
#define h2 mccCurved_Guide_Section_III_75_h2
#define l mccCurved_Guide_Section_III_75_l
#define R0 mccCurved_Guide_Section_III_75_R0
#define Qc mccCurved_Guide_Section_III_75_Qc
#define alpha mccCurved_Guide_Section_III_75_alpha
#define m mccCurved_Guide_Section_III_75_m
#define W mccCurved_Guide_Section_III_75_W
#define nslit mccCurved_Guide_Section_III_75_nslit
#define d mccCurved_Guide_Section_III_75_d
#define mleft mccCurved_Guide_Section_III_75_mleft
#define mright mccCurved_Guide_Section_III_75_mright
#define mtop mccCurved_Guide_Section_III_75_mtop
#define mbottom mccCurved_Guide_Section_III_75_mbottom
#define nhslit mccCurved_Guide_Section_III_75_nhslit
#define G mccCurved_Guide_Section_III_75_G
#define aleft mccCurved_Guide_Section_III_75_aleft
#define aright mccCurved_Guide_Section_III_75_aright
#define atop mccCurved_Guide_Section_III_75_atop
#define abottom mccCurved_Guide_Section_III_75_abottom
#define wavy mccCurved_Guide_Section_III_75_wavy
#define wavy_z mccCurved_Guide_Section_III_75_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_75_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_75_wavy_lr
#define chamfers mccCurved_Guide_Section_III_75_chamfers
#define chamfers_z mccCurved_Guide_Section_III_75_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_75_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_75_chamfers_tb
#define nelements mccCurved_Guide_Section_III_75_nelements
#define nu mccCurved_Guide_Section_III_75_nu
#define phase mccCurved_Guide_Section_III_75_phase
#define reflect mccCurved_Guide_Section_III_75_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 39436 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_III_76. */
  SIG_MESSAGE("Curved_Guide_Section_III_76 (Init)");
#define mccompcurname  Curved_Guide_Section_III_76
#define mccompcurtype  Guide_gravity
#define mccompcurindex 76
#define GVars mccCurved_Guide_Section_III_76_GVars
#define pTable mccCurved_Guide_Section_III_76_pTable
#define w1 mccCurved_Guide_Section_III_76_w1
#define h1 mccCurved_Guide_Section_III_76_h1
#define w2 mccCurved_Guide_Section_III_76_w2
#define h2 mccCurved_Guide_Section_III_76_h2
#define l mccCurved_Guide_Section_III_76_l
#define R0 mccCurved_Guide_Section_III_76_R0
#define Qc mccCurved_Guide_Section_III_76_Qc
#define alpha mccCurved_Guide_Section_III_76_alpha
#define m mccCurved_Guide_Section_III_76_m
#define W mccCurved_Guide_Section_III_76_W
#define nslit mccCurved_Guide_Section_III_76_nslit
#define d mccCurved_Guide_Section_III_76_d
#define mleft mccCurved_Guide_Section_III_76_mleft
#define mright mccCurved_Guide_Section_III_76_mright
#define mtop mccCurved_Guide_Section_III_76_mtop
#define mbottom mccCurved_Guide_Section_III_76_mbottom
#define nhslit mccCurved_Guide_Section_III_76_nhslit
#define G mccCurved_Guide_Section_III_76_G
#define aleft mccCurved_Guide_Section_III_76_aleft
#define aright mccCurved_Guide_Section_III_76_aright
#define atop mccCurved_Guide_Section_III_76_atop
#define abottom mccCurved_Guide_Section_III_76_abottom
#define wavy mccCurved_Guide_Section_III_76_wavy
#define wavy_z mccCurved_Guide_Section_III_76_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_76_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_76_wavy_lr
#define chamfers mccCurved_Guide_Section_III_76_chamfers
#define chamfers_z mccCurved_Guide_Section_III_76_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_76_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_76_chamfers_tb
#define nelements mccCurved_Guide_Section_III_76_nelements
#define nu mccCurved_Guide_Section_III_76_nu
#define phase mccCurved_Guide_Section_III_76_phase
#define reflect mccCurved_Guide_Section_III_76_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 39570 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_III_77. */
  SIG_MESSAGE("Curved_Guide_Section_III_77 (Init)");
#define mccompcurname  Curved_Guide_Section_III_77
#define mccompcurtype  Guide_gravity
#define mccompcurindex 77
#define GVars mccCurved_Guide_Section_III_77_GVars
#define pTable mccCurved_Guide_Section_III_77_pTable
#define w1 mccCurved_Guide_Section_III_77_w1
#define h1 mccCurved_Guide_Section_III_77_h1
#define w2 mccCurved_Guide_Section_III_77_w2
#define h2 mccCurved_Guide_Section_III_77_h2
#define l mccCurved_Guide_Section_III_77_l
#define R0 mccCurved_Guide_Section_III_77_R0
#define Qc mccCurved_Guide_Section_III_77_Qc
#define alpha mccCurved_Guide_Section_III_77_alpha
#define m mccCurved_Guide_Section_III_77_m
#define W mccCurved_Guide_Section_III_77_W
#define nslit mccCurved_Guide_Section_III_77_nslit
#define d mccCurved_Guide_Section_III_77_d
#define mleft mccCurved_Guide_Section_III_77_mleft
#define mright mccCurved_Guide_Section_III_77_mright
#define mtop mccCurved_Guide_Section_III_77_mtop
#define mbottom mccCurved_Guide_Section_III_77_mbottom
#define nhslit mccCurved_Guide_Section_III_77_nhslit
#define G mccCurved_Guide_Section_III_77_G
#define aleft mccCurved_Guide_Section_III_77_aleft
#define aright mccCurved_Guide_Section_III_77_aright
#define atop mccCurved_Guide_Section_III_77_atop
#define abottom mccCurved_Guide_Section_III_77_abottom
#define wavy mccCurved_Guide_Section_III_77_wavy
#define wavy_z mccCurved_Guide_Section_III_77_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_77_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_77_wavy_lr
#define chamfers mccCurved_Guide_Section_III_77_chamfers
#define chamfers_z mccCurved_Guide_Section_III_77_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_77_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_77_chamfers_tb
#define nelements mccCurved_Guide_Section_III_77_nelements
#define nu mccCurved_Guide_Section_III_77_nu
#define phase mccCurved_Guide_Section_III_77_phase
#define reflect mccCurved_Guide_Section_III_77_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 39704 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_III_78. */
  SIG_MESSAGE("Curved_Guide_Section_III_78 (Init)");
#define mccompcurname  Curved_Guide_Section_III_78
#define mccompcurtype  Guide_gravity
#define mccompcurindex 78
#define GVars mccCurved_Guide_Section_III_78_GVars
#define pTable mccCurved_Guide_Section_III_78_pTable
#define w1 mccCurved_Guide_Section_III_78_w1
#define h1 mccCurved_Guide_Section_III_78_h1
#define w2 mccCurved_Guide_Section_III_78_w2
#define h2 mccCurved_Guide_Section_III_78_h2
#define l mccCurved_Guide_Section_III_78_l
#define R0 mccCurved_Guide_Section_III_78_R0
#define Qc mccCurved_Guide_Section_III_78_Qc
#define alpha mccCurved_Guide_Section_III_78_alpha
#define m mccCurved_Guide_Section_III_78_m
#define W mccCurved_Guide_Section_III_78_W
#define nslit mccCurved_Guide_Section_III_78_nslit
#define d mccCurved_Guide_Section_III_78_d
#define mleft mccCurved_Guide_Section_III_78_mleft
#define mright mccCurved_Guide_Section_III_78_mright
#define mtop mccCurved_Guide_Section_III_78_mtop
#define mbottom mccCurved_Guide_Section_III_78_mbottom
#define nhslit mccCurved_Guide_Section_III_78_nhslit
#define G mccCurved_Guide_Section_III_78_G
#define aleft mccCurved_Guide_Section_III_78_aleft
#define aright mccCurved_Guide_Section_III_78_aright
#define atop mccCurved_Guide_Section_III_78_atop
#define abottom mccCurved_Guide_Section_III_78_abottom
#define wavy mccCurved_Guide_Section_III_78_wavy
#define wavy_z mccCurved_Guide_Section_III_78_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_78_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_78_wavy_lr
#define chamfers mccCurved_Guide_Section_III_78_chamfers
#define chamfers_z mccCurved_Guide_Section_III_78_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_78_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_78_chamfers_tb
#define nelements mccCurved_Guide_Section_III_78_nelements
#define nu mccCurved_Guide_Section_III_78_nu
#define phase mccCurved_Guide_Section_III_78_phase
#define reflect mccCurved_Guide_Section_III_78_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 39838 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_III_79. */
  SIG_MESSAGE("Curved_Guide_Section_III_79 (Init)");
#define mccompcurname  Curved_Guide_Section_III_79
#define mccompcurtype  Guide_gravity
#define mccompcurindex 79
#define GVars mccCurved_Guide_Section_III_79_GVars
#define pTable mccCurved_Guide_Section_III_79_pTable
#define w1 mccCurved_Guide_Section_III_79_w1
#define h1 mccCurved_Guide_Section_III_79_h1
#define w2 mccCurved_Guide_Section_III_79_w2
#define h2 mccCurved_Guide_Section_III_79_h2
#define l mccCurved_Guide_Section_III_79_l
#define R0 mccCurved_Guide_Section_III_79_R0
#define Qc mccCurved_Guide_Section_III_79_Qc
#define alpha mccCurved_Guide_Section_III_79_alpha
#define m mccCurved_Guide_Section_III_79_m
#define W mccCurved_Guide_Section_III_79_W
#define nslit mccCurved_Guide_Section_III_79_nslit
#define d mccCurved_Guide_Section_III_79_d
#define mleft mccCurved_Guide_Section_III_79_mleft
#define mright mccCurved_Guide_Section_III_79_mright
#define mtop mccCurved_Guide_Section_III_79_mtop
#define mbottom mccCurved_Guide_Section_III_79_mbottom
#define nhslit mccCurved_Guide_Section_III_79_nhslit
#define G mccCurved_Guide_Section_III_79_G
#define aleft mccCurved_Guide_Section_III_79_aleft
#define aright mccCurved_Guide_Section_III_79_aright
#define atop mccCurved_Guide_Section_III_79_atop
#define abottom mccCurved_Guide_Section_III_79_abottom
#define wavy mccCurved_Guide_Section_III_79_wavy
#define wavy_z mccCurved_Guide_Section_III_79_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_79_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_79_wavy_lr
#define chamfers mccCurved_Guide_Section_III_79_chamfers
#define chamfers_z mccCurved_Guide_Section_III_79_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_79_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_79_chamfers_tb
#define nelements mccCurved_Guide_Section_III_79_nelements
#define nu mccCurved_Guide_Section_III_79_nu
#define phase mccCurved_Guide_Section_III_79_phase
#define reflect mccCurved_Guide_Section_III_79_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 39972 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Curved_Guide_Section_III_short. */
  SIG_MESSAGE("Curved_Guide_Section_III_short (Init)");
#define mccompcurname  Curved_Guide_Section_III_short
#define mccompcurtype  Guide_gravity
#define mccompcurindex 80
#define GVars mccCurved_Guide_Section_III_short_GVars
#define pTable mccCurved_Guide_Section_III_short_pTable
#define w1 mccCurved_Guide_Section_III_short_w1
#define h1 mccCurved_Guide_Section_III_short_h1
#define w2 mccCurved_Guide_Section_III_short_w2
#define h2 mccCurved_Guide_Section_III_short_h2
#define l mccCurved_Guide_Section_III_short_l
#define R0 mccCurved_Guide_Section_III_short_R0
#define Qc mccCurved_Guide_Section_III_short_Qc
#define alpha mccCurved_Guide_Section_III_short_alpha
#define m mccCurved_Guide_Section_III_short_m
#define W mccCurved_Guide_Section_III_short_W
#define nslit mccCurved_Guide_Section_III_short_nslit
#define d mccCurved_Guide_Section_III_short_d
#define mleft mccCurved_Guide_Section_III_short_mleft
#define mright mccCurved_Guide_Section_III_short_mright
#define mtop mccCurved_Guide_Section_III_short_mtop
#define mbottom mccCurved_Guide_Section_III_short_mbottom
#define nhslit mccCurved_Guide_Section_III_short_nhslit
#define G mccCurved_Guide_Section_III_short_G
#define aleft mccCurved_Guide_Section_III_short_aleft
#define aright mccCurved_Guide_Section_III_short_aright
#define atop mccCurved_Guide_Section_III_short_atop
#define abottom mccCurved_Guide_Section_III_short_abottom
#define wavy mccCurved_Guide_Section_III_short_wavy
#define wavy_z mccCurved_Guide_Section_III_short_wavy_z
#define wavy_tb mccCurved_Guide_Section_III_short_wavy_tb
#define wavy_lr mccCurved_Guide_Section_III_short_wavy_lr
#define chamfers mccCurved_Guide_Section_III_short_chamfers
#define chamfers_z mccCurved_Guide_Section_III_short_chamfers_z
#define chamfers_lr mccCurved_Guide_Section_III_short_chamfers_lr
#define chamfers_tb mccCurved_Guide_Section_III_short_chamfers_tb
#define nelements mccCurved_Guide_Section_III_short_nelements
#define nu mccCurved_Guide_Section_III_short_nu
#define phase mccCurved_Guide_Section_III_short_phase
#define reflect mccCurved_Guide_Section_III_short_reflect
#line 340 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 40106 "./SNS_BASIS.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component CGS3_end_ToF. */
  SIG_MESSAGE("CGS3_end_ToF (Init)");
#define mccompcurname  CGS3_end_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 81
#define nt mccCGS3_end_ToF_nt
#define TOF_N mccCGS3_end_ToF_TOF_N
#define TOF_p mccCGS3_end_ToF_TOF_p
#define TOF_p2 mccCGS3_end_ToF_TOF_p2
#define t_min mccCGS3_end_ToF_t_min
#define t_max mccCGS3_end_ToF_t_max
#define delta_t mccCGS3_end_ToF_delta_t
#define filename mccCGS3_end_ToF_filename
#define xmin mccCGS3_end_ToF_xmin
#define xmax mccCGS3_end_ToF_xmax
#define ymin mccCGS3_end_ToF_ymin
#define ymax mccCGS3_end_ToF_ymax
#define xwidth mccCGS3_end_ToF_xwidth
#define yheight mccCGS3_end_ToF_yheight
#define tmin mccCGS3_end_ToF_tmin
#define tmax mccCGS3_end_ToF_tmax
#define dt mccCGS3_end_ToF_dt
#define restore_neutron mccCGS3_end_ToF_restore_neutron
#define nowritefile mccCGS3_end_ToF_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 40204 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component CGS3_end_ToF_Z. */
  SIG_MESSAGE("CGS3_end_ToF_Z (Init)");
#define mccompcurname  CGS3_end_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 82
#define nt mccCGS3_end_ToF_Z_nt
#define TOF_N mccCGS3_end_ToF_Z_TOF_N
#define TOF_p mccCGS3_end_ToF_Z_TOF_p
#define TOF_p2 mccCGS3_end_ToF_Z_TOF_p2
#define t_min mccCGS3_end_ToF_Z_t_min
#define t_max mccCGS3_end_ToF_Z_t_max
#define delta_t mccCGS3_end_ToF_Z_delta_t
#define filename mccCGS3_end_ToF_Z_filename
#define xmin mccCGS3_end_ToF_Z_xmin
#define xmax mccCGS3_end_ToF_Z_xmax
#define ymin mccCGS3_end_ToF_Z_ymin
#define ymax mccCGS3_end_ToF_Z_ymax
#define xwidth mccCGS3_end_ToF_Z_xwidth
#define yheight mccCGS3_end_ToF_Z_yheight
#define tmin mccCGS3_end_ToF_Z_tmin
#define tmax mccCGS3_end_ToF_Z_tmax
#define dt mccCGS3_end_ToF_Z_dt
#define restore_neutron mccCGS3_end_ToF_Z_restore_neutron
#define nowritefile mccCGS3_end_ToF_Z_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 40285 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component CGS3_end_Lam. */
  SIG_MESSAGE("CGS3_end_Lam (Init)");
#define mccompcurname  CGS3_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 83
#define nL mccCGS3_end_Lam_nL
#define L_N mccCGS3_end_Lam_L_N
#define L_p mccCGS3_end_Lam_L_p
#define L_p2 mccCGS3_end_Lam_L_p2
#define filename mccCGS3_end_Lam_filename
#define xmin mccCGS3_end_Lam_xmin
#define xmax mccCGS3_end_Lam_xmax
#define ymin mccCGS3_end_Lam_ymin
#define ymax mccCGS3_end_Lam_ymax
#define xwidth mccCGS3_end_Lam_xwidth
#define yheight mccCGS3_end_Lam_yheight
#define Lmin mccCGS3_end_Lam_Lmin
#define Lmax mccCGS3_end_Lam_Lmax
#define restore_neutron mccCGS3_end_Lam_restore_neutron
#define nowritefile mccCGS3_end_Lam_nowritefile
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 40350 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Straight_Guide_Section_I. */
  SIG_MESSAGE("Straight_Guide_Section_I (Init)");
#define mccompcurname  Straight_Guide_Section_I
#define mccompcurtype  Guide
#define mccompcurindex 84
#define pTable mccStraight_Guide_Section_I_pTable
#define reflect mccStraight_Guide_Section_I_reflect
#define w1 mccStraight_Guide_Section_I_w1
#define h1 mccStraight_Guide_Section_I_h1
#define w2 mccStraight_Guide_Section_I_w2
#define h2 mccStraight_Guide_Section_I_h2
#define l mccStraight_Guide_Section_I_l
#define R0 mccStraight_Guide_Section_I_R0
#define Qc mccStraight_Guide_Section_I_Qc
#define alpha mccStraight_Guide_Section_I_alpha
#define m mccStraight_Guide_Section_I_m
#define W mccStraight_Guide_Section_I_W
#line 74 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 40406 "./SNS_BASIS.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap5_start. */
  SIG_MESSAGE("Gap5_start (Init)");

  /* Initializations for component Gap5_start_ToF. */
  SIG_MESSAGE("Gap5_start_ToF (Init)");
#define mccompcurname  Gap5_start_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 86
#define nt mccGap5_start_ToF_nt
#define TOF_N mccGap5_start_ToF_TOF_N
#define TOF_p mccGap5_start_ToF_TOF_p
#define TOF_p2 mccGap5_start_ToF_TOF_p2
#define t_min mccGap5_start_ToF_t_min
#define t_max mccGap5_start_ToF_t_max
#define delta_t mccGap5_start_ToF_delta_t
#define filename mccGap5_start_ToF_filename
#define xmin mccGap5_start_ToF_xmin
#define xmax mccGap5_start_ToF_xmax
#define ymin mccGap5_start_ToF_ymin
#define ymax mccGap5_start_ToF_ymax
#define xwidth mccGap5_start_ToF_xwidth
#define yheight mccGap5_start_ToF_yheight
#define tmin mccGap5_start_ToF_tmin
#define tmax mccGap5_start_ToF_tmax
#define dt mccGap5_start_ToF_dt
#define restore_neutron mccGap5_start_ToF_restore_neutron
#define nowritefile mccGap5_start_ToF_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 40483 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap5_start_ToF_Z. */
  SIG_MESSAGE("Gap5_start_ToF_Z (Init)");
#define mccompcurname  Gap5_start_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 87
#define nt mccGap5_start_ToF_Z_nt
#define TOF_N mccGap5_start_ToF_Z_TOF_N
#define TOF_p mccGap5_start_ToF_Z_TOF_p
#define TOF_p2 mccGap5_start_ToF_Z_TOF_p2
#define t_min mccGap5_start_ToF_Z_t_min
#define t_max mccGap5_start_ToF_Z_t_max
#define delta_t mccGap5_start_ToF_Z_delta_t
#define filename mccGap5_start_ToF_Z_filename
#define xmin mccGap5_start_ToF_Z_xmin
#define xmax mccGap5_start_ToF_Z_xmax
#define ymin mccGap5_start_ToF_Z_ymin
#define ymax mccGap5_start_ToF_Z_ymax
#define xwidth mccGap5_start_ToF_Z_xwidth
#define yheight mccGap5_start_ToF_Z_yheight
#define tmin mccGap5_start_ToF_Z_tmin
#define tmax mccGap5_start_ToF_Z_tmax
#define dt mccGap5_start_ToF_Z_dt
#define restore_neutron mccGap5_start_ToF_Z_restore_neutron
#define nowritefile mccGap5_start_ToF_Z_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 40564 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap5_start_Lam. */
  SIG_MESSAGE("Gap5_start_Lam (Init)");
#define mccompcurname  Gap5_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 88
#define nL mccGap5_start_Lam_nL
#define L_N mccGap5_start_Lam_L_N
#define L_p mccGap5_start_Lam_L_p
#define L_p2 mccGap5_start_Lam_L_p2
#define filename mccGap5_start_Lam_filename
#define xmin mccGap5_start_Lam_xmin
#define xmax mccGap5_start_Lam_xmax
#define ymin mccGap5_start_Lam_ymin
#define ymax mccGap5_start_Lam_ymax
#define xwidth mccGap5_start_Lam_xwidth
#define yheight mccGap5_start_Lam_yheight
#define Lmin mccGap5_start_Lam_Lmin
#define Lmax mccGap5_start_Lam_Lmax
#define restore_neutron mccGap5_start_Lam_restore_neutron
#define nowritefile mccGap5_start_Lam_nowritefile
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 40629 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap5_start_PSD. */
  SIG_MESSAGE("Gap5_start_PSD (Init)");
#define mccompcurname  Gap5_start_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 89
#define PSD_N mccGap5_start_PSD_PSD_N
#define PSD_p mccGap5_start_PSD_PSD_p
#define PSD_p2 mccGap5_start_PSD_PSD_p2
#define nx mccGap5_start_PSD_nx
#define ny mccGap5_start_PSD_ny
#define filename mccGap5_start_PSD_filename
#define xmin mccGap5_start_PSD_xmin
#define xmax mccGap5_start_PSD_xmax
#define ymin mccGap5_start_PSD_ymin
#define ymax mccGap5_start_PSD_ymax
#define xwidth mccGap5_start_PSD_xwidth
#define yheight mccGap5_start_PSD_yheight
#define restore_neutron mccGap5_start_PSD_restore_neutron
#line 68 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
  if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

  if ((xmin >= xmax) || (ymin >= ymax)){
    printf("PSD_monitor: %s: Null detection area !\n"
           "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
    NAME_CURRENT_COMP);
    exit(0);
  }

  PSD_N = create_darr2d(nx, ny);
  PSD_p = create_darr2d(nx, ny);
  PSD_p2 = create_darr2d(nx, ny);

  int i, j;
  for (i=0; i<nx; i++){
    for (j=0; j<ny; j++){
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
    }
  }
}
#line 40692 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Chopper3. */
  SIG_MESSAGE("Chopper3 (Init)");
#define mccompcurname  Chopper3
#define mccompcurtype  DiskChopper
#define mccompcurindex 90
#define Tg mccChopper3_Tg
#define To mccChopper3_To
#define delta_y mccChopper3_delta_y
#define height mccChopper3_height
#define omega mccChopper3_omega
#define theta_0 mccChopper3_theta_0
#define radius mccChopper3_radius
#define yheight mccChopper3_yheight
#define nu mccChopper3_nu
#define nslit mccChopper3_nslit
#define jitter mccChopper3_jitter
#define delay mccChopper3_delay
#define isfirst mccChopper3_isfirst
#define n_pulse mccChopper3_n_pulse
#define abs_out mccChopper3_abs_out
#define phase mccChopper3_phase
#define xwidth mccChopper3_xwidth
#define verbose mccChopper3_verbose
#line 70 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/DiskChopper.comp"
{
/* If slit height 'unset', assume full opening */
if (yheight == 0) {
        height=radius;
      } else {
        height=yheight;
      }
      delta_y = radius-height/2; /* radius at beam center */
      omega=2.0*PI*nu; /* rad/s */
      if (xwidth && !theta_0 && radius) theta_0 = 2*RAD2DEG*asin(xwidth/2/delta_y);

      if (nslit<=0 || theta_0 <= 0 || radius <=0)
      { fprintf(stderr,"DiskChopper: %s: nslit, theta_0 and radius must be > 0\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (nslit*theta_0 >= 360)
      { fprintf(stderr,"DiskChopper: %s: nslit * theta_0 exceeds 2PI\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (yheight && yheight>radius) {
        fprintf(stderr,"DiskChopper: %s: yheight must be < radius\n", NAME_CURRENT_COMP);
        exit(-1); }
      if (isfirst && n_pulse <=0)
      { fprintf(stderr,"DiskChopper: %s: wrong First chopper pulse number (n_pulse=%g)\n", NAME_CURRENT_COMP, n_pulse);
        exit(-1); }
      if (!omega) {
        fprintf(stderr,"DiskChopper: %s WARNING: chopper frequency is 0!\n", NAME_CURRENT_COMP);
        omega = 1e-15; /* We should actually use machine epsilon here... */
      }
      if (!abs_out) {
        fprintf(stderr,"DiskChopper: %s WARNING: chopper will NOT absorb neutrons outside radius %g [m]\n", NAME_CURRENT_COMP, radius);
      }

      theta_0*=DEG2RAD;


      /* Calulate delay from phase and vice versa */
      if (phase) {
        if (delay) {
          fprintf(stderr,"DiskChopper: %s WARNING: delay AND phase specified. Using phase setting\n", NAME_CURRENT_COMP);
        }
        phase*=DEG2RAD;
        /* 'Delay' should always be a delay, taking rotation direction into account: */
        delay=phase/fabs(omega);
      } else {
        phase=delay*omega;  /* rad */
      }

      /* Time from opening of slit to next opening of slit */
      Tg=2.0*PI/fabs(omega)/nslit;

      /* How long can neutrons pass the Chopper at a single point */
      To=theta_0/fabs(omega);

      if (!xwidth) xwidth=2*delta_y*sin(theta_0/2);

      if (verbose && nu) {
        printf("DiskChopper: %s: frequency=%g [Hz] %g [rpm], time frame=%g [s] phase=%g [deg]\n",
          NAME_CURRENT_COMP, nu, nu*60, Tg, phase*RAD2DEG);
        printf("             %g slits, angle=%g [deg] height=%g [m], width=%g [m] at radius=%g [m]\n",
          nslit, theta_0*RAD2DEG, height, xwidth, delta_y);
      }
}
#line 40795 "./SNS_BASIS.c"
#undef verbose
#undef xwidth
#undef phase
#undef abs_out
#undef n_pulse
#undef isfirst
#undef delay
#undef jitter
#undef nslit
#undef nu
#undef yheight
#undef radius
#undef theta_0
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Chopper3_ToF. */
  SIG_MESSAGE("Chopper3_ToF (Init)");
#define mccompcurname  Chopper3_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 91
#define nt mccChopper3_ToF_nt
#define TOF_N mccChopper3_ToF_TOF_N
#define TOF_p mccChopper3_ToF_TOF_p
#define TOF_p2 mccChopper3_ToF_TOF_p2
#define t_min mccChopper3_ToF_t_min
#define t_max mccChopper3_ToF_t_max
#define delta_t mccChopper3_ToF_delta_t
#define filename mccChopper3_ToF_filename
#define xmin mccChopper3_ToF_xmin
#define xmax mccChopper3_ToF_xmax
#define ymin mccChopper3_ToF_ymin
#define ymax mccChopper3_ToF_ymax
#define xwidth mccChopper3_ToF_xwidth
#define yheight mccChopper3_ToF_yheight
#define tmin mccChopper3_ToF_tmin
#define tmax mccChopper3_ToF_tmax
#define dt mccChopper3_ToF_dt
#define restore_neutron mccChopper3_ToF_restore_neutron
#define nowritefile mccChopper3_ToF_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 40875 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Chopper3_ToF_Z. */
  SIG_MESSAGE("Chopper3_ToF_Z (Init)");
#define mccompcurname  Chopper3_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 92
#define nt mccChopper3_ToF_Z_nt
#define TOF_N mccChopper3_ToF_Z_TOF_N
#define TOF_p mccChopper3_ToF_Z_TOF_p
#define TOF_p2 mccChopper3_ToF_Z_TOF_p2
#define t_min mccChopper3_ToF_Z_t_min
#define t_max mccChopper3_ToF_Z_t_max
#define delta_t mccChopper3_ToF_Z_delta_t
#define filename mccChopper3_ToF_Z_filename
#define xmin mccChopper3_ToF_Z_xmin
#define xmax mccChopper3_ToF_Z_xmax
#define ymin mccChopper3_ToF_Z_ymin
#define ymax mccChopper3_ToF_Z_ymax
#define xwidth mccChopper3_ToF_Z_xwidth
#define yheight mccChopper3_ToF_Z_yheight
#define tmin mccChopper3_ToF_Z_tmin
#define tmax mccChopper3_ToF_Z_tmax
#define dt mccChopper3_ToF_Z_dt
#define restore_neutron mccChopper3_ToF_Z_restore_neutron
#define nowritefile mccChopper3_ToF_Z_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 40956 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap5_end_Lam. */
  SIG_MESSAGE("Gap5_end_Lam (Init)");
#define mccompcurname  Gap5_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 93
#define nL mccGap5_end_Lam_nL
#define L_N mccGap5_end_Lam_L_N
#define L_p mccGap5_end_Lam_L_p
#define L_p2 mccGap5_end_Lam_L_p2
#define filename mccGap5_end_Lam_filename
#define xmin mccGap5_end_Lam_xmin
#define xmax mccGap5_end_Lam_xmax
#define ymin mccGap5_end_Lam_ymin
#define ymax mccGap5_end_Lam_ymax
#define xwidth mccGap5_end_Lam_xwidth
#define yheight mccGap5_end_Lam_yheight
#define Lmin mccGap5_end_Lam_Lmin
#define Lmax mccGap5_end_Lam_Lmax
#define restore_neutron mccGap5_end_Lam_restore_neutron
#define nowritefile mccGap5_end_Lam_nowritefile
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 41021 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap5_end_PSD. */
  SIG_MESSAGE("Gap5_end_PSD (Init)");
#define mccompcurname  Gap5_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 94
#define PSD_N mccGap5_end_PSD_PSD_N
#define PSD_p mccGap5_end_PSD_PSD_p
#define PSD_p2 mccGap5_end_PSD_PSD_p2
#define nx mccGap5_end_PSD_nx
#define ny mccGap5_end_PSD_ny
#define filename mccGap5_end_PSD_filename
#define xmin mccGap5_end_PSD_xmin
#define xmax mccGap5_end_PSD_xmax
#define ymin mccGap5_end_PSD_ymin
#define ymax mccGap5_end_PSD_ymax
#define xwidth mccGap5_end_PSD_xwidth
#define yheight mccGap5_end_PSD_yheight
#define restore_neutron mccGap5_end_PSD_restore_neutron
#line 68 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
  if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

  if ((xmin >= xmax) || (ymin >= ymax)){
    printf("PSD_monitor: %s: Null detection area !\n"
           "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
    NAME_CURRENT_COMP);
    exit(0);
  }

  PSD_N = create_darr2d(nx, ny);
  PSD_p = create_darr2d(nx, ny);
  PSD_p2 = create_darr2d(nx, ny);

  int i, j;
  for (i=0; i<nx; i++){
    for (j=0; j<ny; j++){
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
    }
  }
}
#line 41084 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Gap5_end. */
  SIG_MESSAGE("Gap5_end (Init)");

  /* Initializations for component Straight_Guide_Section_II. */
  SIG_MESSAGE("Straight_Guide_Section_II (Init)");
#define mccompcurname  Straight_Guide_Section_II
#define mccompcurtype  Guide
#define mccompcurindex 96
#define pTable mccStraight_Guide_Section_II_pTable
#define reflect mccStraight_Guide_Section_II_reflect
#define w1 mccStraight_Guide_Section_II_w1
#define h1 mccStraight_Guide_Section_II_h1
#define w2 mccStraight_Guide_Section_II_w2
#define h2 mccStraight_Guide_Section_II_h2
#define l mccStraight_Guide_Section_II_l
#define R0 mccStraight_Guide_Section_II_R0
#define Qc mccStraight_Guide_Section_II_Qc
#define alpha mccStraight_Guide_Section_II_alpha
#define m mccStraight_Guide_Section_II_m
#define W mccStraight_Guide_Section_II_W
#line 74 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 41141 "./SNS_BASIS.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component SGS2_end_Lam. */
  SIG_MESSAGE("SGS2_end_Lam (Init)");
#define mccompcurname  SGS2_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 97
#define nL mccSGS2_end_Lam_nL
#define L_N mccSGS2_end_Lam_L_N
#define L_p mccSGS2_end_Lam_L_p
#define L_p2 mccSGS2_end_Lam_L_p2
#define filename mccSGS2_end_Lam_filename
#define xmin mccSGS2_end_Lam_xmin
#define xmax mccSGS2_end_Lam_xmax
#define ymin mccSGS2_end_Lam_ymin
#define ymax mccSGS2_end_Lam_ymax
#define xwidth mccSGS2_end_Lam_xwidth
#define yheight mccSGS2_end_Lam_yheight
#define Lmin mccSGS2_end_Lam_Lmin
#define Lmax mccSGS2_end_Lam_Lmax
#define restore_neutron mccSGS2_end_Lam_restore_neutron
#define nowritefile mccSGS2_end_Lam_nowritefile
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 41199 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component SGS2_end_PSD. */
  SIG_MESSAGE("SGS2_end_PSD (Init)");
#define mccompcurname  SGS2_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 98
#define PSD_N mccSGS2_end_PSD_PSD_N
#define PSD_p mccSGS2_end_PSD_PSD_p
#define PSD_p2 mccSGS2_end_PSD_PSD_p2
#define nx mccSGS2_end_PSD_nx
#define ny mccSGS2_end_PSD_ny
#define filename mccSGS2_end_PSD_filename
#define xmin mccSGS2_end_PSD_xmin
#define xmax mccSGS2_end_PSD_xmax
#define ymin mccSGS2_end_PSD_ymin
#define ymax mccSGS2_end_PSD_ymax
#define xwidth mccSGS2_end_PSD_xwidth
#define yheight mccSGS2_end_PSD_yheight
#define restore_neutron mccSGS2_end_PSD_restore_neutron
#line 68 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
  if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

  if ((xmin >= xmax) || (ymin >= ymax)){
    printf("PSD_monitor: %s: Null detection area !\n"
           "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
    NAME_CURRENT_COMP);
    exit(0);
  }

  PSD_N = create_darr2d(nx, ny);
  PSD_p = create_darr2d(nx, ny);
  PSD_p2 = create_darr2d(nx, ny);

  int i, j;
  for (i=0; i<nx; i++){
    for (j=0; j<ny; j++){
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
    }
  }
}
#line 41262 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Straight_Guide_Section_III. */
  SIG_MESSAGE("Straight_Guide_Section_III (Init)");
#define mccompcurname  Straight_Guide_Section_III
#define mccompcurtype  Guide
#define mccompcurindex 99
#define pTable mccStraight_Guide_Section_III_pTable
#define reflect mccStraight_Guide_Section_III_reflect
#define w1 mccStraight_Guide_Section_III_w1
#define h1 mccStraight_Guide_Section_III_h1
#define w2 mccStraight_Guide_Section_III_w2
#define h2 mccStraight_Guide_Section_III_h2
#define l mccStraight_Guide_Section_III_l
#define R0 mccStraight_Guide_Section_III_R0
#define Qc mccStraight_Guide_Section_III_Qc
#define alpha mccStraight_Guide_Section_III_alpha
#define m mccStraight_Guide_Section_III_m
#define W mccStraight_Guide_Section_III_W
#line 74 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide.comp"
{
if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0 || m < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }
}
#line 41316 "./SNS_BASIS.c"
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef reflect
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component SG3_end_ToF. */
  SIG_MESSAGE("SG3_end_ToF (Init)");
#define mccompcurname  SG3_end_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 100
#define nt mccSG3_end_ToF_nt
#define TOF_N mccSG3_end_ToF_TOF_N
#define TOF_p mccSG3_end_ToF_TOF_p
#define TOF_p2 mccSG3_end_ToF_TOF_p2
#define t_min mccSG3_end_ToF_t_min
#define t_max mccSG3_end_ToF_t_max
#define delta_t mccSG3_end_ToF_delta_t
#define filename mccSG3_end_ToF_filename
#define xmin mccSG3_end_ToF_xmin
#define xmax mccSG3_end_ToF_xmax
#define ymin mccSG3_end_ToF_ymin
#define ymax mccSG3_end_ToF_ymax
#define xwidth mccSG3_end_ToF_xwidth
#define yheight mccSG3_end_ToF_yheight
#define tmin mccSG3_end_ToF_tmin
#define tmax mccSG3_end_ToF_tmax
#define dt mccSG3_end_ToF_dt
#define restore_neutron mccSG3_end_ToF_restore_neutron
#define nowritefile mccSG3_end_ToF_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 41390 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component SG3_end_ToF_Z. */
  SIG_MESSAGE("SG3_end_ToF_Z (Init)");
#define mccompcurname  SG3_end_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 101
#define nt mccSG3_end_ToF_Z_nt
#define TOF_N mccSG3_end_ToF_Z_TOF_N
#define TOF_p mccSG3_end_ToF_Z_TOF_p
#define TOF_p2 mccSG3_end_ToF_Z_TOF_p2
#define t_min mccSG3_end_ToF_Z_t_min
#define t_max mccSG3_end_ToF_Z_t_max
#define delta_t mccSG3_end_ToF_Z_delta_t
#define filename mccSG3_end_ToF_Z_filename
#define xmin mccSG3_end_ToF_Z_xmin
#define xmax mccSG3_end_ToF_Z_xmax
#define ymin mccSG3_end_ToF_Z_ymin
#define ymax mccSG3_end_ToF_Z_ymax
#define xwidth mccSG3_end_ToF_Z_xwidth
#define yheight mccSG3_end_ToF_Z_yheight
#define tmin mccSG3_end_ToF_Z_tmin
#define tmax mccSG3_end_ToF_Z_tmax
#define dt mccSG3_end_ToF_Z_dt
#define restore_neutron mccSG3_end_ToF_Z_restore_neutron
#define nowritefile mccSG3_end_ToF_Z_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 41471 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component SG3_end_Lam. */
  SIG_MESSAGE("SG3_end_Lam (Init)");
#define mccompcurname  SG3_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 102
#define nL mccSG3_end_Lam_nL
#define L_N mccSG3_end_Lam_L_N
#define L_p mccSG3_end_Lam_L_p
#define L_p2 mccSG3_end_Lam_L_p2
#define filename mccSG3_end_Lam_filename
#define xmin mccSG3_end_Lam_xmin
#define xmax mccSG3_end_Lam_xmax
#define ymin mccSG3_end_Lam_ymin
#define ymax mccSG3_end_Lam_ymax
#define xwidth mccSG3_end_Lam_xwidth
#define yheight mccSG3_end_Lam_yheight
#define Lmin mccSG3_end_Lam_Lmin
#define Lmax mccSG3_end_Lam_Lmax
#define restore_neutron mccSG3_end_Lam_restore_neutron
#define nowritefile mccSG3_end_Lam_nowritefile
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 41536 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component SG3_end_PSD. */
  SIG_MESSAGE("SG3_end_PSD (Init)");
#define mccompcurname  SG3_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 103
#define PSD_N mccSG3_end_PSD_PSD_N
#define PSD_p mccSG3_end_PSD_PSD_p
#define PSD_p2 mccSG3_end_PSD_PSD_p2
#define nx mccSG3_end_PSD_nx
#define ny mccSG3_end_PSD_ny
#define filename mccSG3_end_PSD_filename
#define xmin mccSG3_end_PSD_xmin
#define xmax mccSG3_end_PSD_xmax
#define ymin mccSG3_end_PSD_ymin
#define ymax mccSG3_end_PSD_ymax
#define xwidth mccSG3_end_PSD_xwidth
#define yheight mccSG3_end_PSD_yheight
#define restore_neutron mccSG3_end_PSD_restore_neutron
#line 68 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
  if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

  if ((xmin >= xmax) || (ymin >= ymax)){
    printf("PSD_monitor: %s: Null detection area !\n"
           "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
    NAME_CURRENT_COMP);
    exit(0);
  }

  PSD_N = create_darr2d(nx, ny);
  PSD_p = create_darr2d(nx, ny);
  PSD_p2 = create_darr2d(nx, ny);

  int i, j;
  for (i=0; i<nx; i++){
    for (j=0; j<ny; j++){
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
    }
  }
}
#line 41599 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Funnel_1. */
  SIG_MESSAGE("Funnel_1 (Init)");
#define mccompcurname  Funnel_1
#define mccompcurtype  Guide_m
#define mccompcurindex 104
#define reflect mccFunnel_1_reflect
#define pTable mccFunnel_1_pTable
#define m mccFunnel_1_m
#define alpha mccFunnel_1_alpha
#define Qc mccFunnel_1_Qc
#define R0 mccFunnel_1_R0
#define W mccFunnel_1_W
#define w1 mccFunnel_1_w1
#define h1 mccFunnel_1_h1
#define w2 mccFunnel_1_w2
#define h2 mccFunnel_1_h2
#define l mccFunnel_1_l
#define R0_left mccFunnel_1_R0_left
#define R0_right mccFunnel_1_R0_right
#define R0_top mccFunnel_1_R0_top
#define R0_bottom mccFunnel_1_R0_bottom
#define Qc_left mccFunnel_1_Qc_left
#define Qc_right mccFunnel_1_Qc_right
#define Qc_top mccFunnel_1_Qc_top
#define Qc_bottom mccFunnel_1_Qc_bottom
#define alpha_left mccFunnel_1_alpha_left
#define alpha_right mccFunnel_1_alpha_right
#define alpha_top mccFunnel_1_alpha_top
#define alpha_bottom mccFunnel_1_alpha_bottom
#define m_left mccFunnel_1_m_left
#define m_right mccFunnel_1_m_right
#define m_top mccFunnel_1_m_top
#define m_bottom mccFunnel_1_m_bottom
#define W_left mccFunnel_1_W_left
#define W_right mccFunnel_1_W_right
#define W_top mccFunnel_1_W_top
#define W_bottom mccFunnel_1_W_bottom
#line 96 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_m.comp"
{
  if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (reflect && strlen(reflect)) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W_left < 0 || W_right < 0 || W_top < 0 || W_bottom < 0 || R0_left < 0 ||R0_right < 0 || R0_top < 0 || R0_bottom < 0 || Qc_left < 0 || Qc_right < 0 || Qc_top < 0 || Qc_bottom < 0 || m_left < 0 || m_right < 0 || m_top < 0 || m_bottom < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
    if (m_left < 1 && m_left != 0) fprintf(stderr,"WARNING: Guide: %s: m_left < 1 behaves as if m=1.\n",
      NAME_CURRENT_COMP);
	if (m_right < 1 && m_right != 0) fprintf(stderr,"WARNING: Guide: %s: m_right < 1 behaves as if m=1.\n",
      NAME_CURRENT_COMP);
	if (m_top < 1 && m_top != 0) fprintf(stderr,"WARNING: Guide: %s: m_top < 1 behaves as if m=1.\n",
      NAME_CURRENT_COMP);
	if (m_bottom < 1 && m_bottom != 0) fprintf(stderr,"WARNING: Guide: %s: m_bottom < 1 behaves as if m=1.\n",
      NAME_CURRENT_COMP);
  }
}
#line 41678 "./SNS_BASIS.c"
#undef W_bottom
#undef W_top
#undef W_right
#undef W_left
#undef m_bottom
#undef m_top
#undef m_right
#undef m_left
#undef alpha_bottom
#undef alpha_top
#undef alpha_right
#undef alpha_left
#undef Qc_bottom
#undef Qc_top
#undef Qc_right
#undef Qc_left
#undef R0_bottom
#undef R0_top
#undef R0_right
#undef R0_left
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef W
#undef R0
#undef Qc
#undef alpha
#undef m
#undef pTable
#undef reflect
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PSD_post_funnel1. */
  SIG_MESSAGE("PSD_post_funnel1 (Init)");
#define mccompcurname  PSD_post_funnel1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 105
#define PSD_N mccPSD_post_funnel1_PSD_N
#define PSD_p mccPSD_post_funnel1_PSD_p
#define PSD_p2 mccPSD_post_funnel1_PSD_p2
#define nx mccPSD_post_funnel1_nx
#define ny mccPSD_post_funnel1_ny
#define filename mccPSD_post_funnel1_filename
#define xmin mccPSD_post_funnel1_xmin
#define xmax mccPSD_post_funnel1_xmax
#define ymin mccPSD_post_funnel1_ymin
#define ymax mccPSD_post_funnel1_ymax
#define xwidth mccPSD_post_funnel1_xwidth
#define yheight mccPSD_post_funnel1_yheight
#define restore_neutron mccPSD_post_funnel1_restore_neutron
#line 68 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
  if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

  if ((xmin >= xmax) || (ymin >= ymax)){
    printf("PSD_monitor: %s: Null detection area !\n"
           "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
    NAME_CURRENT_COMP);
    exit(0);
  }

  PSD_N = create_darr2d(nx, ny);
  PSD_p = create_darr2d(nx, ny);
  PSD_p2 = create_darr2d(nx, ny);

  int i, j;
  for (i=0; i<nx; i++){
    for (j=0; j<ny; j++){
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
    }
  }
}
#line 41758 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Funnel_2. */
  SIG_MESSAGE("Funnel_2 (Init)");
#define mccompcurname  Funnel_2
#define mccompcurtype  Guide_m
#define mccompcurindex 106
#define reflect mccFunnel_2_reflect
#define pTable mccFunnel_2_pTable
#define m mccFunnel_2_m
#define alpha mccFunnel_2_alpha
#define Qc mccFunnel_2_Qc
#define R0 mccFunnel_2_R0
#define W mccFunnel_2_W
#define w1 mccFunnel_2_w1
#define h1 mccFunnel_2_h1
#define w2 mccFunnel_2_w2
#define h2 mccFunnel_2_h2
#define l mccFunnel_2_l
#define R0_left mccFunnel_2_R0_left
#define R0_right mccFunnel_2_R0_right
#define R0_top mccFunnel_2_R0_top
#define R0_bottom mccFunnel_2_R0_bottom
#define Qc_left mccFunnel_2_Qc_left
#define Qc_right mccFunnel_2_Qc_right
#define Qc_top mccFunnel_2_Qc_top
#define Qc_bottom mccFunnel_2_Qc_bottom
#define alpha_left mccFunnel_2_alpha_left
#define alpha_right mccFunnel_2_alpha_right
#define alpha_top mccFunnel_2_alpha_top
#define alpha_bottom mccFunnel_2_alpha_bottom
#define m_left mccFunnel_2_m_left
#define m_right mccFunnel_2_m_right
#define m_top mccFunnel_2_m_top
#define m_bottom mccFunnel_2_m_bottom
#define W_left mccFunnel_2_W_left
#define W_right mccFunnel_2_W_right
#define W_top mccFunnel_2_W_top
#define W_bottom mccFunnel_2_W_bottom
#line 96 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_m.comp"
{
  if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (reflect && strlen(reflect)) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W_left < 0 || W_right < 0 || W_top < 0 || W_bottom < 0 || R0_left < 0 ||R0_right < 0 || R0_top < 0 || R0_bottom < 0 || Qc_left < 0 || Qc_right < 0 || Qc_top < 0 || Qc_bottom < 0 || m_left < 0 || m_right < 0 || m_top < 0 || m_bottom < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
    if (m_left < 1 && m_left != 0) fprintf(stderr,"WARNING: Guide: %s: m_left < 1 behaves as if m=1.\n",
      NAME_CURRENT_COMP);
	if (m_right < 1 && m_right != 0) fprintf(stderr,"WARNING: Guide: %s: m_right < 1 behaves as if m=1.\n",
      NAME_CURRENT_COMP);
	if (m_top < 1 && m_top != 0) fprintf(stderr,"WARNING: Guide: %s: m_top < 1 behaves as if m=1.\n",
      NAME_CURRENT_COMP);
	if (m_bottom < 1 && m_bottom != 0) fprintf(stderr,"WARNING: Guide: %s: m_bottom < 1 behaves as if m=1.\n",
      NAME_CURRENT_COMP);
  }
}
#line 41837 "./SNS_BASIS.c"
#undef W_bottom
#undef W_top
#undef W_right
#undef W_left
#undef m_bottom
#undef m_top
#undef m_right
#undef m_left
#undef alpha_bottom
#undef alpha_top
#undef alpha_right
#undef alpha_left
#undef Qc_bottom
#undef Qc_top
#undef Qc_right
#undef Qc_left
#undef R0_bottom
#undef R0_top
#undef R0_right
#undef R0_left
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef W
#undef R0
#undef Qc
#undef alpha
#undef m
#undef pTable
#undef reflect
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PSD_post_funnel2. */
  SIG_MESSAGE("PSD_post_funnel2 (Init)");
#define mccompcurname  PSD_post_funnel2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 107
#define PSD_N mccPSD_post_funnel2_PSD_N
#define PSD_p mccPSD_post_funnel2_PSD_p
#define PSD_p2 mccPSD_post_funnel2_PSD_p2
#define nx mccPSD_post_funnel2_nx
#define ny mccPSD_post_funnel2_ny
#define filename mccPSD_post_funnel2_filename
#define xmin mccPSD_post_funnel2_xmin
#define xmax mccPSD_post_funnel2_xmax
#define ymin mccPSD_post_funnel2_ymin
#define ymax mccPSD_post_funnel2_ymax
#define xwidth mccPSD_post_funnel2_xwidth
#define yheight mccPSD_post_funnel2_yheight
#define restore_neutron mccPSD_post_funnel2_restore_neutron
#line 68 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
  if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

  if ((xmin >= xmax) || (ymin >= ymax)){
    printf("PSD_monitor: %s: Null detection area !\n"
           "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
    NAME_CURRENT_COMP);
    exit(0);
  }

  PSD_N = create_darr2d(nx, ny);
  PSD_p = create_darr2d(nx, ny);
  PSD_p2 = create_darr2d(nx, ny);

  int i, j;
  for (i=0; i<nx; i++){
    for (j=0; j<ny; j++){
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
    }
  }
}
#line 41917 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Funnel_3. */
  SIG_MESSAGE("Funnel_3 (Init)");
#define mccompcurname  Funnel_3
#define mccompcurtype  Guide_m
#define mccompcurindex 108
#define reflect mccFunnel_3_reflect
#define pTable mccFunnel_3_pTable
#define m mccFunnel_3_m
#define alpha mccFunnel_3_alpha
#define Qc mccFunnel_3_Qc
#define R0 mccFunnel_3_R0
#define W mccFunnel_3_W
#define w1 mccFunnel_3_w1
#define h1 mccFunnel_3_h1
#define w2 mccFunnel_3_w2
#define h2 mccFunnel_3_h2
#define l mccFunnel_3_l
#define R0_left mccFunnel_3_R0_left
#define R0_right mccFunnel_3_R0_right
#define R0_top mccFunnel_3_R0_top
#define R0_bottom mccFunnel_3_R0_bottom
#define Qc_left mccFunnel_3_Qc_left
#define Qc_right mccFunnel_3_Qc_right
#define Qc_top mccFunnel_3_Qc_top
#define Qc_bottom mccFunnel_3_Qc_bottom
#define alpha_left mccFunnel_3_alpha_left
#define alpha_right mccFunnel_3_alpha_right
#define alpha_top mccFunnel_3_alpha_top
#define alpha_bottom mccFunnel_3_alpha_bottom
#define m_left mccFunnel_3_m_left
#define m_right mccFunnel_3_m_right
#define m_top mccFunnel_3_m_top
#define m_bottom mccFunnel_3_m_bottom
#define W_left mccFunnel_3_W_left
#define W_right mccFunnel_3_W_right
#define W_top mccFunnel_3_W_top
#define W_bottom mccFunnel_3_W_bottom
#line 96 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_m.comp"
{
  if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (reflect && strlen(reflect)) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W_left < 0 || W_right < 0 || W_top < 0 || W_bottom < 0 || R0_left < 0 ||R0_right < 0 || R0_top < 0 || R0_bottom < 0 || Qc_left < 0 || Qc_right < 0 || Qc_top < 0 || Qc_bottom < 0 || m_left < 0 || m_right < 0 || m_top < 0 || m_bottom < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
    if (m_left < 1 && m_left != 0) fprintf(stderr,"WARNING: Guide: %s: m_left < 1 behaves as if m=1.\n",
      NAME_CURRENT_COMP);
	if (m_right < 1 && m_right != 0) fprintf(stderr,"WARNING: Guide: %s: m_right < 1 behaves as if m=1.\n",
      NAME_CURRENT_COMP);
	if (m_top < 1 && m_top != 0) fprintf(stderr,"WARNING: Guide: %s: m_top < 1 behaves as if m=1.\n",
      NAME_CURRENT_COMP);
	if (m_bottom < 1 && m_bottom != 0) fprintf(stderr,"WARNING: Guide: %s: m_bottom < 1 behaves as if m=1.\n",
      NAME_CURRENT_COMP);
  }
}
#line 41996 "./SNS_BASIS.c"
#undef W_bottom
#undef W_top
#undef W_right
#undef W_left
#undef m_bottom
#undef m_top
#undef m_right
#undef m_left
#undef alpha_bottom
#undef alpha_top
#undef alpha_right
#undef alpha_left
#undef Qc_bottom
#undef Qc_top
#undef Qc_right
#undef Qc_left
#undef R0_bottom
#undef R0_top
#undef R0_right
#undef R0_left
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef W
#undef R0
#undef Qc
#undef alpha
#undef m
#undef pTable
#undef reflect
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PSD_post_funnel3. */
  SIG_MESSAGE("PSD_post_funnel3 (Init)");
#define mccompcurname  PSD_post_funnel3
#define mccompcurtype  PSD_monitor
#define mccompcurindex 109
#define PSD_N mccPSD_post_funnel3_PSD_N
#define PSD_p mccPSD_post_funnel3_PSD_p
#define PSD_p2 mccPSD_post_funnel3_PSD_p2
#define nx mccPSD_post_funnel3_nx
#define ny mccPSD_post_funnel3_ny
#define filename mccPSD_post_funnel3_filename
#define xmin mccPSD_post_funnel3_xmin
#define xmax mccPSD_post_funnel3_xmax
#define ymin mccPSD_post_funnel3_ymin
#define ymax mccPSD_post_funnel3_ymax
#define xwidth mccPSD_post_funnel3_xwidth
#define yheight mccPSD_post_funnel3_yheight
#define restore_neutron mccPSD_post_funnel3_restore_neutron
#line 68 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
  if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

  if ((xmin >= xmax) || (ymin >= ymax)){
    printf("PSD_monitor: %s: Null detection area !\n"
           "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
    NAME_CURRENT_COMP);
    exit(0);
  }

  PSD_N = create_darr2d(nx, ny);
  PSD_p = create_darr2d(nx, ny);
  PSD_p2 = create_darr2d(nx, ny);

  int i, j;
  for (i=0; i<nx; i++){
    for (j=0; j<ny; j++){
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
    }
  }
}
#line 42076 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Funnel_4. */
  SIG_MESSAGE("Funnel_4 (Init)");
#define mccompcurname  Funnel_4
#define mccompcurtype  Guide_m
#define mccompcurindex 110
#define reflect mccFunnel_4_reflect
#define pTable mccFunnel_4_pTable
#define m mccFunnel_4_m
#define alpha mccFunnel_4_alpha
#define Qc mccFunnel_4_Qc
#define R0 mccFunnel_4_R0
#define W mccFunnel_4_W
#define w1 mccFunnel_4_w1
#define h1 mccFunnel_4_h1
#define w2 mccFunnel_4_w2
#define h2 mccFunnel_4_h2
#define l mccFunnel_4_l
#define R0_left mccFunnel_4_R0_left
#define R0_right mccFunnel_4_R0_right
#define R0_top mccFunnel_4_R0_top
#define R0_bottom mccFunnel_4_R0_bottom
#define Qc_left mccFunnel_4_Qc_left
#define Qc_right mccFunnel_4_Qc_right
#define Qc_top mccFunnel_4_Qc_top
#define Qc_bottom mccFunnel_4_Qc_bottom
#define alpha_left mccFunnel_4_alpha_left
#define alpha_right mccFunnel_4_alpha_right
#define alpha_top mccFunnel_4_alpha_top
#define alpha_bottom mccFunnel_4_alpha_bottom
#define m_left mccFunnel_4_m_left
#define m_right mccFunnel_4_m_right
#define m_top mccFunnel_4_m_top
#define m_bottom mccFunnel_4_m_bottom
#define W_left mccFunnel_4_W_left
#define W_right mccFunnel_4_W_right
#define W_top mccFunnel_4_W_top
#define W_bottom mccFunnel_4_W_bottom
#line 96 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_m.comp"
{
  if (mcgravitation) fprintf(stderr,"WARNING: Guide: %s: "
    "This component produces wrong results with gravitation !\n"
    "Use Guide_gravity.\n",
    NAME_CURRENT_COMP);

  if (reflect && strlen(reflect)) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W_left < 0 || W_right < 0 || W_top < 0 || W_bottom < 0 || R0_left < 0 ||R0_right < 0 || R0_top < 0 || R0_bottom < 0 || Qc_left < 0 || Qc_right < 0 || Qc_top < 0 || Qc_bottom < 0 || m_left < 0 || m_right < 0 || m_top < 0 || m_bottom < 0)
    { fprintf(stderr,"Guide: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
    if (m_left < 1 && m_left != 0) fprintf(stderr,"WARNING: Guide: %s: m_left < 1 behaves as if m=1.\n",
      NAME_CURRENT_COMP);
	if (m_right < 1 && m_right != 0) fprintf(stderr,"WARNING: Guide: %s: m_right < 1 behaves as if m=1.\n",
      NAME_CURRENT_COMP);
	if (m_top < 1 && m_top != 0) fprintf(stderr,"WARNING: Guide: %s: m_top < 1 behaves as if m=1.\n",
      NAME_CURRENT_COMP);
	if (m_bottom < 1 && m_bottom != 0) fprintf(stderr,"WARNING: Guide: %s: m_bottom < 1 behaves as if m=1.\n",
      NAME_CURRENT_COMP);
  }
}
#line 42155 "./SNS_BASIS.c"
#undef W_bottom
#undef W_top
#undef W_right
#undef W_left
#undef m_bottom
#undef m_top
#undef m_right
#undef m_left
#undef alpha_bottom
#undef alpha_top
#undef alpha_right
#undef alpha_left
#undef Qc_bottom
#undef Qc_top
#undef Qc_right
#undef Qc_left
#undef R0_bottom
#undef R0_top
#undef R0_right
#undef R0_left
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef W
#undef R0
#undef Qc
#undef alpha
#undef m
#undef pTable
#undef reflect
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PSD_post_funnel4. */
  SIG_MESSAGE("PSD_post_funnel4 (Init)");
#define mccompcurname  PSD_post_funnel4
#define mccompcurtype  PSD_monitor
#define mccompcurindex 111
#define PSD_N mccPSD_post_funnel4_PSD_N
#define PSD_p mccPSD_post_funnel4_PSD_p
#define PSD_p2 mccPSD_post_funnel4_PSD_p2
#define nx mccPSD_post_funnel4_nx
#define ny mccPSD_post_funnel4_ny
#define filename mccPSD_post_funnel4_filename
#define xmin mccPSD_post_funnel4_xmin
#define xmax mccPSD_post_funnel4_xmax
#define ymin mccPSD_post_funnel4_ymin
#define ymax mccPSD_post_funnel4_ymax
#define xwidth mccPSD_post_funnel4_xwidth
#define yheight mccPSD_post_funnel4_yheight
#define restore_neutron mccPSD_post_funnel4_restore_neutron
#line 68 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
  if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

  if ((xmin >= xmax) || (ymin >= ymax)){
    printf("PSD_monitor: %s: Null detection area !\n"
           "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
    NAME_CURRENT_COMP);
    exit(0);
  }

  PSD_N = create_darr2d(nx, ny);
  PSD_p = create_darr2d(nx, ny);
  PSD_p2 = create_darr2d(nx, ny);

  int i, j;
  for (i=0; i<nx; i++){
    for (j=0; j<ny; j++){
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
    }
  }
}
#line 42235 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Guide_End_ToF. */
  SIG_MESSAGE("Guide_End_ToF (Init)");
#define mccompcurname  Guide_End_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 112
#define nt mccGuide_End_ToF_nt
#define TOF_N mccGuide_End_ToF_TOF_N
#define TOF_p mccGuide_End_ToF_TOF_p
#define TOF_p2 mccGuide_End_ToF_TOF_p2
#define t_min mccGuide_End_ToF_t_min
#define t_max mccGuide_End_ToF_t_max
#define delta_t mccGuide_End_ToF_delta_t
#define filename mccGuide_End_ToF_filename
#define xmin mccGuide_End_ToF_xmin
#define xmax mccGuide_End_ToF_xmax
#define ymin mccGuide_End_ToF_ymin
#define ymax mccGuide_End_ToF_ymax
#define xwidth mccGuide_End_ToF_xwidth
#define yheight mccGuide_End_ToF_yheight
#define tmin mccGuide_End_ToF_tmin
#define tmax mccGuide_End_ToF_tmax
#define dt mccGuide_End_ToF_dt
#define restore_neutron mccGuide_End_ToF_restore_neutron
#define nowritefile mccGuide_End_ToF_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 42310 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Guide_End_ToF_Z. */
  SIG_MESSAGE("Guide_End_ToF_Z (Init)");
#define mccompcurname  Guide_End_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 113
#define nt mccGuide_End_ToF_Z_nt
#define TOF_N mccGuide_End_ToF_Z_TOF_N
#define TOF_p mccGuide_End_ToF_Z_TOF_p
#define TOF_p2 mccGuide_End_ToF_Z_TOF_p2
#define t_min mccGuide_End_ToF_Z_t_min
#define t_max mccGuide_End_ToF_Z_t_max
#define delta_t mccGuide_End_ToF_Z_delta_t
#define filename mccGuide_End_ToF_Z_filename
#define xmin mccGuide_End_ToF_Z_xmin
#define xmax mccGuide_End_ToF_Z_xmax
#define ymin mccGuide_End_ToF_Z_ymin
#define ymax mccGuide_End_ToF_Z_ymax
#define xwidth mccGuide_End_ToF_Z_xwidth
#define yheight mccGuide_End_ToF_Z_yheight
#define tmin mccGuide_End_ToF_Z_tmin
#define tmax mccGuide_End_ToF_Z_tmax
#define dt mccGuide_End_ToF_Z_dt
#define restore_neutron mccGuide_End_ToF_Z_restore_neutron
#define nowritefile mccGuide_End_ToF_Z_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 42391 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Guide_end_Lam. */
  SIG_MESSAGE("Guide_end_Lam (Init)");
#define mccompcurname  Guide_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 114
#define nL mccGuide_end_Lam_nL
#define L_N mccGuide_end_Lam_L_N
#define L_p mccGuide_end_Lam_L_p
#define L_p2 mccGuide_end_Lam_L_p2
#define filename mccGuide_end_Lam_filename
#define xmin mccGuide_end_Lam_xmin
#define xmax mccGuide_end_Lam_xmax
#define ymin mccGuide_end_Lam_ymin
#define ymax mccGuide_end_Lam_ymax
#define xwidth mccGuide_end_Lam_xwidth
#define yheight mccGuide_end_Lam_yheight
#define Lmin mccGuide_end_Lam_Lmin
#define Lmax mccGuide_end_Lam_Lmax
#define restore_neutron mccGuide_end_Lam_restore_neutron
#define nowritefile mccGuide_end_Lam_nowritefile
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 42456 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Guide_end_divx. */
  SIG_MESSAGE("Guide_end_divx (Init)");
#define mccompcurname  Guide_end_divx
#define mccompcurtype  Monitor_nD
#define mccompcurindex 115
#define user1 mccGuide_end_divx_user1
#define user2 mccGuide_end_divx_user2
#define user3 mccGuide_end_divx_user3
#define DEFS mccGuide_end_divx_DEFS
#define Vars mccGuide_end_divx_Vars
#define detector mccGuide_end_divx_detector
#define offdata mccGuide_end_divx_offdata
#define xwidth mccGuide_end_divx_xwidth
#define yheight mccGuide_end_divx_yheight
#define zdepth mccGuide_end_divx_zdepth
#define xmin mccGuide_end_divx_xmin
#define xmax mccGuide_end_divx_xmax
#define ymin mccGuide_end_divx_ymin
#define ymax mccGuide_end_divx_ymax
#define zmin mccGuide_end_divx_zmin
#define zmax mccGuide_end_divx_zmax
#define bins mccGuide_end_divx_bins
#define min mccGuide_end_divx_min
#define max mccGuide_end_divx_max
#define restore_neutron mccGuide_end_divx_restore_neutron
#define radius mccGuide_end_divx_radius
#define options mccGuide_end_divx_options
#define filename mccGuide_end_divx_filename
#define geometry mccGuide_end_divx_geometry
#define username1 mccGuide_end_divx_username1
#define username2 mccGuide_end_divx_username2
#define username3 mccGuide_end_divx_username3
#define nowritefile mccGuide_end_divx_nowritefile
#line 230 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  char tmp[CHAR_BUF_LENGTH];
  strcpy(Vars.compcurname, NAME_CURRENT_COMP);
  if (options != NULL)
    strncpy(Vars.option, options, CHAR_BUF_LENGTH);
  else {
    strcpy(Vars.option, "x y");
    printf("Monitor_nD: %s has no option specified. Setting to PSD ('x y') monitor.\n", NAME_CURRENT_COMP);
  }
  Vars.compcurpos = POS_A_CURRENT_COMP;

  if (strstr(Vars.option, "source"))
    strcat(Vars.option, " list, x y z vx vy vz t sx sy sz ");

  if (bins) { sprintf(tmp, " all bins=%ld ", (long)bins); strcat(Vars.option, tmp); }
  if (min > -FLT_MAX && max < FLT_MAX) { sprintf(tmp, " all limits=[%g %g]", min, max); strcat(Vars.option, tmp); }
  else if (min > -FLT_MAX) { sprintf(tmp, " all min=%g", min); strcat(Vars.option, tmp); }
  else if (max <  FLT_MAX) { sprintf(tmp, " all max=%g", max); strcat(Vars.option, tmp); }

  strncpy(Vars.UserName1,
    username1 && strlen(username1) && strcmp(username1, "0") && strcmp(username1, "NULL") ?
    username1 : "", 128);
  strncpy(Vars.UserName2,
    username2 && strlen(username2) && strcmp(username2, "0") && strcmp(username2, "NULL") ?
    username2 : "", 128);
  strncpy(Vars.UserName3,
    username3 && strlen(username3) && strcmp(username3, "0") && strcmp(username3, "NULL") ?
    username3 : "", 128);
  if (radius) {
    xwidth = zdepth = 2*radius;
    if (yheight && !strstr(Vars.option, "cylinder") && !strstr(Vars.option, "banana") && !strstr(Vars.option, "sphere"))
      strcat(Vars.option, " banana");
    else if (!yheight && !strstr(Vars.option ,"sphere")) {
      strcat(Vars.option, " sphere");
      yheight=2*radius;
    }
  }
  int offflag=0;
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) {
    if (!off_init(  geometry, xwidth, yheight, zdepth, 1, &offdata )) {
      printf("Monitor_nD: %s could not initiate the OFF geometry %s. \n"
             "            Defaulting to normal Monitor dimensions.\n",
             NAME_CURRENT_COMP, geometry);
      strcpy(geometry, "");
    } else {
      offflag=1;
    }
  }

  if (!radius && !xwidth && !yheight && !zdepth && !xmin && !xmax && !ymin && !ymax &&
    !strstr(Vars.option, "previous") && (!geometry || !strlen(geometry)))
    exit(printf("Monitor_nD: %s has no dimension specified. Aborting (radius, xwidth, yheight, zdepth, previous, geometry).\n", NAME_CURRENT_COMP));

  Monitor_nD_Init(&DEFS, &Vars, xwidth, yheight, zdepth, xmin,xmax,ymin,ymax,zmin,zmax,offflag);

  if (Vars.Flag_OFF) {
    offdata.mantidflag=Vars.Flag_mantid;
    offdata.mantidoffset=Vars.Coord_Min[Vars.Coord_Number-1];
  }


  if (filename && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
    strncpy(Vars.Mon_File, filename, 128);

  /* check if user given filename with ext will be used more than once */
  if ( ((Vars.Flag_Multiple && Vars.Coord_Number > 1) || Vars.Flag_List) && strchr(Vars.Mon_File,'.') )
  { char *XY; XY = strrchr(Vars.Mon_File,'.'); *XY='_'; }

  if (restore_neutron) Vars.Flag_parallel=1;
  detector.m = 0;

#ifdef USE_MPI
MPI_MASTER(
  if (strstr(Vars.option, "auto") && mpi_node_count > 1)
    printf("Monitor_nD: %s is using automatic limits option 'auto' together with MPI.\n"
           "WARNING     this may create incorrect distributions (but integrated flux will be right).\n", NAME_CURRENT_COMP);
);
#endif
}
#line 42589 "./SNS_BASIS.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Guide_end_divy. */
  SIG_MESSAGE("Guide_end_divy (Init)");
#define mccompcurname  Guide_end_divy
#define mccompcurtype  Monitor_nD
#define mccompcurindex 116
#define user1 mccGuide_end_divy_user1
#define user2 mccGuide_end_divy_user2
#define user3 mccGuide_end_divy_user3
#define DEFS mccGuide_end_divy_DEFS
#define Vars mccGuide_end_divy_Vars
#define detector mccGuide_end_divy_detector
#define offdata mccGuide_end_divy_offdata
#define xwidth mccGuide_end_divy_xwidth
#define yheight mccGuide_end_divy_yheight
#define zdepth mccGuide_end_divy_zdepth
#define xmin mccGuide_end_divy_xmin
#define xmax mccGuide_end_divy_xmax
#define ymin mccGuide_end_divy_ymin
#define ymax mccGuide_end_divy_ymax
#define zmin mccGuide_end_divy_zmin
#define zmax mccGuide_end_divy_zmax
#define bins mccGuide_end_divy_bins
#define min mccGuide_end_divy_min
#define max mccGuide_end_divy_max
#define restore_neutron mccGuide_end_divy_restore_neutron
#define radius mccGuide_end_divy_radius
#define options mccGuide_end_divy_options
#define filename mccGuide_end_divy_filename
#define geometry mccGuide_end_divy_geometry
#define username1 mccGuide_end_divy_username1
#define username2 mccGuide_end_divy_username2
#define username3 mccGuide_end_divy_username3
#define nowritefile mccGuide_end_divy_nowritefile
#line 230 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  char tmp[CHAR_BUF_LENGTH];
  strcpy(Vars.compcurname, NAME_CURRENT_COMP);
  if (options != NULL)
    strncpy(Vars.option, options, CHAR_BUF_LENGTH);
  else {
    strcpy(Vars.option, "x y");
    printf("Monitor_nD: %s has no option specified. Setting to PSD ('x y') monitor.\n", NAME_CURRENT_COMP);
  }
  Vars.compcurpos = POS_A_CURRENT_COMP;

  if (strstr(Vars.option, "source"))
    strcat(Vars.option, " list, x y z vx vy vz t sx sy sz ");

  if (bins) { sprintf(tmp, " all bins=%ld ", (long)bins); strcat(Vars.option, tmp); }
  if (min > -FLT_MAX && max < FLT_MAX) { sprintf(tmp, " all limits=[%g %g]", min, max); strcat(Vars.option, tmp); }
  else if (min > -FLT_MAX) { sprintf(tmp, " all min=%g", min); strcat(Vars.option, tmp); }
  else if (max <  FLT_MAX) { sprintf(tmp, " all max=%g", max); strcat(Vars.option, tmp); }

  strncpy(Vars.UserName1,
    username1 && strlen(username1) && strcmp(username1, "0") && strcmp(username1, "NULL") ?
    username1 : "", 128);
  strncpy(Vars.UserName2,
    username2 && strlen(username2) && strcmp(username2, "0") && strcmp(username2, "NULL") ?
    username2 : "", 128);
  strncpy(Vars.UserName3,
    username3 && strlen(username3) && strcmp(username3, "0") && strcmp(username3, "NULL") ?
    username3 : "", 128);
  if (radius) {
    xwidth = zdepth = 2*radius;
    if (yheight && !strstr(Vars.option, "cylinder") && !strstr(Vars.option, "banana") && !strstr(Vars.option, "sphere"))
      strcat(Vars.option, " banana");
    else if (!yheight && !strstr(Vars.option ,"sphere")) {
      strcat(Vars.option, " sphere");
      yheight=2*radius;
    }
  }
  int offflag=0;
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) {
    if (!off_init(  geometry, xwidth, yheight, zdepth, 1, &offdata )) {
      printf("Monitor_nD: %s could not initiate the OFF geometry %s. \n"
             "            Defaulting to normal Monitor dimensions.\n",
             NAME_CURRENT_COMP, geometry);
      strcpy(geometry, "");
    } else {
      offflag=1;
    }
  }

  if (!radius && !xwidth && !yheight && !zdepth && !xmin && !xmax && !ymin && !ymax &&
    !strstr(Vars.option, "previous") && (!geometry || !strlen(geometry)))
    exit(printf("Monitor_nD: %s has no dimension specified. Aborting (radius, xwidth, yheight, zdepth, previous, geometry).\n", NAME_CURRENT_COMP));

  Monitor_nD_Init(&DEFS, &Vars, xwidth, yheight, zdepth, xmin,xmax,ymin,ymax,zmin,zmax,offflag);

  if (Vars.Flag_OFF) {
    offdata.mantidflag=Vars.Flag_mantid;
    offdata.mantidoffset=Vars.Coord_Min[Vars.Coord_Number-1];
  }


  if (filename && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
    strncpy(Vars.Mon_File, filename, 128);

  /* check if user given filename with ext will be used more than once */
  if ( ((Vars.Flag_Multiple && Vars.Coord_Number > 1) || Vars.Flag_List) && strchr(Vars.Mon_File,'.') )
  { char *XY; XY = strrchr(Vars.Mon_File,'.'); *XY='_'; }

  if (restore_neutron) Vars.Flag_parallel=1;
  detector.m = 0;

#ifdef USE_MPI
MPI_MASTER(
  if (strstr(Vars.option, "auto") && mpi_node_count > 1)
    printf("Monitor_nD: %s is using automatic limits option 'auto' together with MPI.\n"
           "WARNING     this may create incorrect distributions (but integrated flux will be right).\n", NAME_CURRENT_COMP);
);
#endif
}
#line 42735 "./SNS_BASIS.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Guide_end_PSD. */
  SIG_MESSAGE("Guide_end_PSD (Init)");
#define mccompcurname  Guide_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 117
#define PSD_N mccGuide_end_PSD_PSD_N
#define PSD_p mccGuide_end_PSD_PSD_p
#define PSD_p2 mccGuide_end_PSD_PSD_p2
#define nx mccGuide_end_PSD_nx
#define ny mccGuide_end_PSD_ny
#define filename mccGuide_end_PSD_filename
#define xmin mccGuide_end_PSD_xmin
#define xmax mccGuide_end_PSD_xmax
#define ymin mccGuide_end_PSD_ymin
#define ymax mccGuide_end_PSD_ymax
#define xwidth mccGuide_end_PSD_xwidth
#define yheight mccGuide_end_PSD_yheight
#define restore_neutron mccGuide_end_PSD_restore_neutron
#line 68 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
  if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

  if ((xmin >= xmax) || (ymin >= ymax)){
    printf("PSD_monitor: %s: Null detection area !\n"
           "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
    NAME_CURRENT_COMP);
    exit(0);
  }

  PSD_N = create_darr2d(nx, ny);
  PSD_p = create_darr2d(nx, ny);
  PSD_p2 = create_darr2d(nx, ny);

  int i, j;
  for (i=0; i<nx; i++){
    for (j=0; j<ny; j++){
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
    }
  }
}
#line 42811 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Sample_split. */
  SIG_MESSAGE("Sample_split (Init)");

  /* Initializations for component SamplePos. */
  SIG_MESSAGE("SamplePos (Init)");
#define mccompcurname  SamplePos
#define mccompcurtype  PSD_monitor
#define mccompcurindex 119
#define PSD_N mccSamplePos_PSD_N
#define PSD_p mccSamplePos_PSD_p
#define PSD_p2 mccSamplePos_PSD_p2
#define nx mccSamplePos_nx
#define ny mccSamplePos_ny
#define filename mccSamplePos_filename
#define xmin mccSamplePos_xmin
#define xmax mccSamplePos_xmax
#define ymin mccSamplePos_ymin
#define ymax mccSamplePos_ymax
#define xwidth mccSamplePos_xwidth
#define yheight mccSamplePos_yheight
#define restore_neutron mccSamplePos_restore_neutron
#line 68 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
  if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

  if ((xmin >= xmax) || (ymin >= ymax)){
    printf("PSD_monitor: %s: Null detection area !\n"
           "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
    NAME_CURRENT_COMP);
    exit(0);
  }

  PSD_N = create_darr2d(nx, ny);
  PSD_p = create_darr2d(nx, ny);
  PSD_p2 = create_darr2d(nx, ny);

  int i, j;
  for (i=0; i<nx; i++){
    for (j=0; j<ny; j++){
      PSD_N[i][j] = 0;
      PSD_p[i][j] = 0;
      PSD_p2[i][j] = 0;
    }
  }
}
#line 42875 "./SNS_BASIS.c"
#undef restore_neutron
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef ny
#undef nx
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Sample. */
  SIG_MESSAGE("Sample (Init)");
#define mccompcurname  Sample
#define mccompcurtype  Isotropic_Sqw
#define mccompcurindex 120
#define powder_format mccSample_powder_format
#define VarSqw mccSample_VarSqw
#define columns mccSample_columns
#define offdata mccSample_offdata
#define Sqw_coh mccSample_Sqw_coh
#define Sqw_inc mccSample_Sqw_inc
#define geometry mccSample_geometry
#define radius mccSample_radius
#define thickness mccSample_thickness
#define xwidth mccSample_xwidth
#define yheight mccSample_yheight
#define zdepth mccSample_zdepth
#define threshold mccSample_threshold
#define order mccSample_order
#define T mccSample_T
#define verbose mccSample_verbose
#define d_phi mccSample_d_phi
#define concentric mccSample_concentric
#define rho mccSample_rho
#define sigma_abs mccSample_sigma_abs
#define sigma_coh mccSample_sigma_coh
#define sigma_inc mccSample_sigma_inc
#define classical mccSample_classical
#define powder_Dd mccSample_powder_Dd
#define powder_DW mccSample_powder_DW
#define powder_Vc mccSample_powder_Vc
#define density mccSample_density
#define weight mccSample_weight
#define p_interact mccSample_p_interact
#define norm mccSample_norm
#define powder_barns mccSample_powder_barns
#define quantum_correction mccSample_quantum_correction
#line 2008 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../samples/Isotropic_Sqw.comp"
{
  int i;
  /* check for parameters */
  columns = (int[])powder_format;

  VarSqw.verbose_output= verbose;
  VarSqw.shape = -1; /* -1:no shape, 0:cyl, 1:box, 2:sphere, 3:any-shape  */
  if (geometry && strlen(geometry) && strcmp(geometry, "NULL") && strcmp(geometry, "0")) {
	  if (off_init(geometry, xwidth, yheight, zdepth, 0, &offdata)) {
      VarSqw.shape=3; thickness=0; concentric=0;
    }
  }
  else if (xwidth && yheight && zdepth)  VarSqw.shape=1; /* box */
  else if (radius > 0 && yheight)        VarSqw.shape=0; /* cylinder */
  else if (radius > 0 && !yheight)       VarSqw.shape=2; /* sphere */

  if (VarSqw.shape < 0)
    exit(fprintf(stderr,"Isotropic_Sqw: %s: sample has invalid dimensions.\n"
                        "ERROR          Please check parameter values (xwidth, yheight, zdepth, radius).\n", NAME_CURRENT_COMP));



  if (thickness) {
    if (radius && (radius < fabs(thickness) )) {
      MPI_MASTER(
      fprintf(stderr,"Isotropic_Sqw: %s: hollow sample thickness is larger than its volume (sphere/cylinder).\n"
                     "WARNING        Please check parameter values. Using bulk sample (thickness=0).\n", NAME_CURRENT_COMP);
      );
      thickness=0;
    }
    else if (!radius && (xwidth < 2*fabs(thickness) || yheight < 2*fabs(thickness) || zdepth < 2*fabs(thickness))) {
      MPI_MASTER(
      fprintf(stderr,"Isotropic_Sqw: %s: hollow sample thickness is larger than its volume (box).\n"
                     "WARNING        Please check parameter values.\n", NAME_CURRENT_COMP);
      );
    }
  }
  MPI_MASTER(
  if (VarSqw.verbose_output) {
    switch (VarSqw.shape) {
      case 0: printf("Isotropic_Sqw: %s: is a %scylinder: radius=%f thickness=%f height=%f [J Comp Phys 228 (2009) 5251]\n",
              NAME_CURRENT_COMP, (thickness ? "hollow " : ""),
              radius,fabs(thickness),yheight);
              break;
      case 1: printf("Isotropic_Sqw: %s: is a %sbox: width=%f height=%f depth=%f \n",
              NAME_CURRENT_COMP, (thickness ? "hollow " : ""), xwidth,yheight,zdepth);
              break;
      case 2: printf("Isotropic_Sqw: %s: is a %ssphere: radius=%f thickness=%f\n",
              NAME_CURRENT_COMP, (thickness ? "hollow " : ""),
              radius,fabs(thickness));
              break;
      case 3: printf("Isotropic_Sqw: %s: is a volume defined from file %s\n",
              NAME_CURRENT_COMP, geometry);
    }
  }
  );

  if (concentric && !thickness) {
    MPI_MASTER(
    printf("Isotropic_Sqw: %s:Can not use concentric mode\n"
           "WARNING        on non hollow shape. Ignoring.\n",
           NAME_CURRENT_COMP);
    );
    concentric=0;
  }

  strncpy(VarSqw.compname, NAME_CURRENT_COMP, 256);
  VarSqw.T2E       =(1/11.605);   /* Kelvin to meV = 1000*KB/e */
  VarSqw.sqSE2K    = (V2K*SE2V)*(V2K*SE2V);
  VarSqw.sqw_threshold = (threshold > 0 ? threshold : 0);
  VarSqw.s_abs     = sigma_abs;
  VarSqw.s_coh     = sigma_coh;
  VarSqw.s_inc     = sigma_inc; /* s_scatt member initialized in Sqw_init */
  VarSqw.maxloop   = 100;       /* atempts to close triangle */
  VarSqw.minevents = 100;       /* minimal # of events required to get dynamical range */
  VarSqw.neutron_removed = 0;
  VarSqw.neutron_enter   = 0;
  VarSqw.neutron_pmult   = 0;
  VarSqw.neutron_exit    = 0;
  VarSqw.mat_rho       = rho;
  VarSqw.sqw_norm  = norm;
  VarSqw.mean_scatt= 0;
  VarSqw.mean_abs  = 0;
  VarSqw.psum_scatt= 0;
  VarSqw.single_coh= 0;
  VarSqw.single_inc= 0;
  VarSqw.multi     = 0;
  VarSqw.barns     = powder_barns;
  VarSqw.sqw_classical = classical;
  VarSqw.lookup_length=100;
  VarSqw.mat_weight    = weight;
  VarSqw.mat_density   = density;
  if (quantum_correction && strlen(quantum_correction)) 
    strncpy(VarSqw.Q_correction, quantum_correction, 256);
  else
    strncpy(VarSqw.Q_correction, "default", 256);

  /* PowderN compatibility members */
  VarSqw.Dd        = powder_Dd;
  VarSqw.DWfactor  = powder_DW;
  VarSqw.Temperature= T;
  for (i=0; i< 9; i++) VarSqw.column_order[i] = columns[i];
  VarSqw.column_order[8] = (VarSqw.column_order[0] >= 0 ? 0 : 2);

  /* optional ways to define rho */
  if (!VarSqw.mat_rho && powder_Vc > 0)
    VarSqw.mat_rho = 1/powder_Vc;
  /* import the data files ================================================== */
  if (!Sqw_init(&VarSqw, Sqw_coh, Sqw_inc)) {
    MPI_MASTER(
    printf("Isotropic_Sqw: %s: ERROR importing data files (Sqw_init coh=%s inc=%s).\n",NAME_CURRENT_COMP, Sqw_coh, Sqw_inc);
    );
  }
  if ( VarSqw.s_coh < 0) VarSqw.s_coh=0;
  if ( VarSqw.s_inc < 0) VarSqw.s_inc=0;
  if ( VarSqw.s_abs < 0) VarSqw.s_abs=0;
  if ((VarSqw.s_coh > 0 || VarSqw.s_inc > 0) && VarSqw.mat_rho <= 0) {
    MPI_MASTER(
    printf("Isotropic_Sqw: %s: WARNING: Null density (V_rho). Unactivating component.\n",NAME_CURRENT_COMP);
    );
    VarSqw.s_coh=VarSqw.s_inc=0;
  }
  /* 100: convert from barns to fm^2 */
  VarSqw.my_a_v  =(VarSqw.mat_rho*100*VarSqw.s_abs*2200);
  VarSqw.my_s    =(VarSqw.mat_rho*100*(VarSqw.s_coh>0 ? VarSqw.s_coh : 0
                                     +VarSqw.s_inc>0 ? VarSqw.s_inc : 0));
  MPI_MASTER(
  if ((VarSqw.s_coh > 0 || VarSqw.s_inc > 0) && !VarSqw.Temperature
   && (VarSqw.Data_coh.intensity || VarSqw.Data_inc.intensity)
   && VarSqw.verbose_output)
    printf("Isotropic_Sqw: %s: Sample temperature not defined (T=0).\n"
           "Warning        Disabling detailed balance.\n", NAME_CURRENT_COMP);
  if (VarSqw.s_coh<=0 && VarSqw.s_inc<=0) {
    printf("Isotropic_Sqw: %s: Scattering cross section is zero\n"
           "ERROR          (sigma_coh, sigma_inc).\n",NAME_CURRENT_COMP);
  }
  );
  if (d_phi) d_phi = fabs(d_phi)*DEG2RAD;

  if (d_phi > PI) d_phi = 0; /* V_scatt on 4*PI */

  if (d_phi && order != 1) {
    MPI_MASTER(
    printf("Isotropic_Sqw: %s: Focusing can only apply for single\n"
           "               scattering. Setting to order=1.\n",
           NAME_CURRENT_COMP);
    );
    order = 1;
  }

  /* request statistics */
  if (VarSqw.verbose_output > 1) {
    Sqw_diagnosis(&VarSqw, &VarSqw.Data_coh);
    Sqw_diagnosis(&VarSqw, &VarSqw.Data_inc);
  }

  for (i=0; i < 2; i++) {
    struct Sqw_Data_struct Data_sqw;
    Data_sqw =  (i == 0 ? VarSqw.Data_coh : VarSqw.Data_inc);
    Table_Free(&(Data_sqw.Sqw));
  }

/* end INITIALIZE */
}
#line 43095 "./SNS_BASIS.c"
#undef quantum_correction
#undef powder_barns
#undef norm
#undef p_interact
#undef weight
#undef density
#undef powder_Vc
#undef powder_DW
#undef powder_Dd
#undef classical
#undef sigma_inc
#undef sigma_coh
#undef sigma_abs
#undef rho
#undef concentric
#undef d_phi
#undef verbose
#undef T
#undef order
#undef threshold
#undef zdepth
#undef yheight
#undef xwidth
#undef thickness
#undef radius
#undef geometry
#undef Sqw_inc
#undef Sqw_coh
#undef offdata
#undef columns
#undef VarSqw
#undef powder_format
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component An1_rot_axis. */
  SIG_MESSAGE("An1_rot_axis (Init)");

  /* Initializations for component An2_rot_axis. */
  SIG_MESSAGE("An2_rot_axis (Init)");

  /* Initializations for component An3_rot_axis. */
  SIG_MESSAGE("An3_rot_axis (Init)");

  /* Initializations for component An1_ToF. */
  SIG_MESSAGE("An1_ToF (Init)");
#define mccompcurname  An1_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 124
#define nt mccAn1_ToF_nt
#define TOF_N mccAn1_ToF_TOF_N
#define TOF_p mccAn1_ToF_TOF_p
#define TOF_p2 mccAn1_ToF_TOF_p2
#define t_min mccAn1_ToF_t_min
#define t_max mccAn1_ToF_t_max
#define delta_t mccAn1_ToF_delta_t
#define filename mccAn1_ToF_filename
#define xmin mccAn1_ToF_xmin
#define xmax mccAn1_ToF_xmax
#define ymin mccAn1_ToF_ymin
#define ymax mccAn1_ToF_ymax
#define xwidth mccAn1_ToF_xwidth
#define yheight mccAn1_ToF_yheight
#define tmin mccAn1_ToF_tmin
#define tmax mccAn1_ToF_tmax
#define dt mccAn1_ToF_dt
#define restore_neutron mccAn1_ToF_restore_neutron
#define nowritefile mccAn1_ToF_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 43198 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component An1_ToF_variable_range. */
  SIG_MESSAGE("An1_ToF_variable_range (Init)");
#define mccompcurname  An1_ToF_variable_range
#define mccompcurtype  TOF_monitor
#define mccompcurindex 125
#define nt mccAn1_ToF_variable_range_nt
#define TOF_N mccAn1_ToF_variable_range_TOF_N
#define TOF_p mccAn1_ToF_variable_range_TOF_p
#define TOF_p2 mccAn1_ToF_variable_range_TOF_p2
#define t_min mccAn1_ToF_variable_range_t_min
#define t_max mccAn1_ToF_variable_range_t_max
#define delta_t mccAn1_ToF_variable_range_delta_t
#define filename mccAn1_ToF_variable_range_filename
#define xmin mccAn1_ToF_variable_range_xmin
#define xmax mccAn1_ToF_variable_range_xmax
#define ymin mccAn1_ToF_variable_range_ymin
#define ymax mccAn1_ToF_variable_range_ymax
#define xwidth mccAn1_ToF_variable_range_xwidth
#define yheight mccAn1_ToF_variable_range_yheight
#define tmin mccAn1_ToF_variable_range_tmin
#define tmax mccAn1_ToF_variable_range_tmax
#define dt mccAn1_ToF_variable_range_dt
#define restore_neutron mccAn1_ToF_variable_range_restore_neutron
#define nowritefile mccAn1_ToF_variable_range_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 43279 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component An1_Lam. */
  SIG_MESSAGE("An1_Lam (Init)");
#define mccompcurname  An1_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 126
#define nL mccAn1_Lam_nL
#define L_N mccAn1_Lam_L_N
#define L_p mccAn1_Lam_L_p
#define L_p2 mccAn1_Lam_L_p2
#define filename mccAn1_Lam_filename
#define xmin mccAn1_Lam_xmin
#define xmax mccAn1_Lam_xmax
#define ymin mccAn1_Lam_ymin
#define ymax mccAn1_Lam_ymax
#define xwidth mccAn1_Lam_xwidth
#define yheight mccAn1_Lam_yheight
#define Lmin mccAn1_Lam_Lmin
#define Lmax mccAn1_Lam_Lmax
#define restore_neutron mccAn1_Lam_restore_neutron
#define nowritefile mccAn1_Lam_nowritefile
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 43344 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component An1_Lam_variable_range. */
  SIG_MESSAGE("An1_Lam_variable_range (Init)");
#define mccompcurname  An1_Lam_variable_range
#define mccompcurtype  L_monitor
#define mccompcurindex 127
#define nL mccAn1_Lam_variable_range_nL
#define L_N mccAn1_Lam_variable_range_L_N
#define L_p mccAn1_Lam_variable_range_L_p
#define L_p2 mccAn1_Lam_variable_range_L_p2
#define filename mccAn1_Lam_variable_range_filename
#define xmin mccAn1_Lam_variable_range_xmin
#define xmax mccAn1_Lam_variable_range_xmax
#define ymin mccAn1_Lam_variable_range_ymin
#define ymax mccAn1_Lam_variable_range_ymax
#define xwidth mccAn1_Lam_variable_range_xwidth
#define yheight mccAn1_Lam_variable_range_yheight
#define Lmin mccAn1_Lam_variable_range_Lmin
#define Lmax mccAn1_Lam_variable_range_Lmax
#define restore_neutron mccAn1_Lam_variable_range_restore_neutron
#define nowritefile mccAn1_Lam_variable_range_nowritefile
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 43405 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component An1_E. */
  SIG_MESSAGE("An1_E (Init)");
#define mccompcurname  An1_E
#define mccompcurtype  E_monitor
#define mccompcurindex 128
#define nE mccAn1_E_nE
#define E_N mccAn1_E_E_N
#define E_p mccAn1_E_E_p
#define E_p2 mccAn1_E_E_p2
#define S_p mccAn1_E_S_p
#define S_pE mccAn1_E_S_pE
#define S_pE2 mccAn1_E_S_pE2
#define filename mccAn1_E_filename
#define xmin mccAn1_E_xmin
#define xmax mccAn1_E_xmax
#define ymin mccAn1_E_ymin
#define ymax mccAn1_E_ymax
#define xwidth mccAn1_E_xwidth
#define yheight mccAn1_E_yheight
#define Emin mccAn1_E_Emin
#define Emax mccAn1_E_Emax
#define restore_neutron mccAn1_E_restore_neutron
#define nowritefile mccAn1_E_nowritefile
#line 66 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("E_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nE; i++)
    {
      E_N[i] = 0;
      E_p[i] = 0;
      E_p2[i] = 0;
    }
    S_p = S_pE = S_pE2 = 0;
}
#line 43470 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component An1_E_variable_range. */
  SIG_MESSAGE("An1_E_variable_range (Init)");
#define mccompcurname  An1_E_variable_range
#define mccompcurtype  E_monitor
#define mccompcurindex 129
#define nE mccAn1_E_variable_range_nE
#define E_N mccAn1_E_variable_range_E_N
#define E_p mccAn1_E_variable_range_E_p
#define E_p2 mccAn1_E_variable_range_E_p2
#define S_p mccAn1_E_variable_range_S_p
#define S_pE mccAn1_E_variable_range_S_pE
#define S_pE2 mccAn1_E_variable_range_S_pE2
#define filename mccAn1_E_variable_range_filename
#define xmin mccAn1_E_variable_range_xmin
#define xmax mccAn1_E_variable_range_xmax
#define ymin mccAn1_E_variable_range_ymin
#define ymax mccAn1_E_variable_range_ymax
#define xwidth mccAn1_E_variable_range_xwidth
#define yheight mccAn1_E_variable_range_yheight
#define Emin mccAn1_E_variable_range_Emin
#define Emax mccAn1_E_variable_range_Emax
#define restore_neutron mccAn1_E_variable_range_restore_neutron
#define nowritefile mccAn1_E_variable_range_nowritefile
#line 66 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("E_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nE; i++)
    {
      E_N[i] = 0;
      E_p[i] = 0;
      E_p2[i] = 0;
    }
    S_p = S_pE = S_pE2 = 0;
}
#line 43538 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component An1_rot_axis2. */
  SIG_MESSAGE("An1_rot_axis2 (Init)");

  /* Initializations for component An2_rot_axis2. */
  SIG_MESSAGE("An2_rot_axis2 (Init)");

  /* Initializations for component An3_rot_axis2. */
  SIG_MESSAGE("An3_rot_axis2 (Init)");

  /* Initializations for component An1. */
  SIG_MESSAGE("An1 (Init)");
#define mccompcurname  An1
#define mccompcurtype  Spherical_Backscattering_Analyser
#define mccompcurindex 133
#define d_rms mccAn1_d_rms
#define mos_rms mccAn1_mos_rms
#define mono_Q mccAn1_mono_Q
#define xmin mccAn1_xmin
#define xmax mccAn1_xmax
#define ymin mccAn1_ymin
#define ymax mccAn1_ymax
#define mosaic mccAn1_mosaic
#define dspread mccAn1_dspread
#define Q mccAn1_Q
#define DM mccAn1_DM
#define radius mccAn1_radius
#define f_doppler mccAn1_f_doppler
#define A_doppler mccAn1_A_doppler
#define R0 mccAn1_R0
#define debug mccAn1_debug
#line 58 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Spherical_Backscattering_Analyser.comp"
{
  mos_rms = MIN2RAD*mosaic/sqrt(8*log(2));
  
  mono_Q = Q;
  if (DM != 0) 
    mono_Q = 2*PI/DM;
  
  DM = 2*PI/mono_Q;
  d_rms = dspread*DM/sqrt(8*log(2));
}
#line 43602 "./SNS_BASIS.c"
#undef debug
#undef R0
#undef A_doppler
#undef f_doppler
#undef radius
#undef DM
#undef Q
#undef dspread
#undef mosaic
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mono_Q
#undef mos_rms
#undef d_rms
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component An2. */
  SIG_MESSAGE("An2 (Init)");
#define mccompcurname  An2
#define mccompcurtype  Spherical_Backscattering_Analyser
#define mccompcurindex 134
#define d_rms mccAn2_d_rms
#define mos_rms mccAn2_mos_rms
#define mono_Q mccAn2_mono_Q
#define xmin mccAn2_xmin
#define xmax mccAn2_xmax
#define ymin mccAn2_ymin
#define ymax mccAn2_ymax
#define mosaic mccAn2_mosaic
#define dspread mccAn2_dspread
#define Q mccAn2_Q
#define DM mccAn2_DM
#define radius mccAn2_radius
#define f_doppler mccAn2_f_doppler
#define A_doppler mccAn2_A_doppler
#define R0 mccAn2_R0
#define debug mccAn2_debug
#line 58 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Spherical_Backscattering_Analyser.comp"
{
  mos_rms = MIN2RAD*mosaic/sqrt(8*log(2));
  
  mono_Q = Q;
  if (DM != 0) 
    mono_Q = 2*PI/DM;
  
  DM = 2*PI/mono_Q;
  d_rms = dspread*DM/sqrt(8*log(2));
}
#line 43655 "./SNS_BASIS.c"
#undef debug
#undef R0
#undef A_doppler
#undef f_doppler
#undef radius
#undef DM
#undef Q
#undef dspread
#undef mosaic
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mono_Q
#undef mos_rms
#undef d_rms
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component An3. */
  SIG_MESSAGE("An3 (Init)");
#define mccompcurname  An3
#define mccompcurtype  Spherical_Backscattering_Analyser
#define mccompcurindex 135
#define d_rms mccAn3_d_rms
#define mos_rms mccAn3_mos_rms
#define mono_Q mccAn3_mono_Q
#define xmin mccAn3_xmin
#define xmax mccAn3_xmax
#define ymin mccAn3_ymin
#define ymax mccAn3_ymax
#define mosaic mccAn3_mosaic
#define dspread mccAn3_dspread
#define Q mccAn3_Q
#define DM mccAn3_DM
#define radius mccAn3_radius
#define f_doppler mccAn3_f_doppler
#define A_doppler mccAn3_A_doppler
#define R0 mccAn3_R0
#define debug mccAn3_debug
#line 58 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Spherical_Backscattering_Analyser.comp"
{
  mos_rms = MIN2RAD*mosaic/sqrt(8*log(2));
  
  mono_Q = Q;
  if (DM != 0) 
    mono_Q = 2*PI/DM;
  
  DM = 2*PI/mono_Q;
  d_rms = dspread*DM/sqrt(8*log(2));
}
#line 43708 "./SNS_BASIS.c"
#undef debug
#undef R0
#undef A_doppler
#undef f_doppler
#undef radius
#undef DM
#undef Q
#undef dspread
#undef mosaic
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef mono_Q
#undef mos_rms
#undef d_rms
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component ArmForDet1. */
  SIG_MESSAGE("ArmForDet1 (Init)");

  /* Initializations for component Det1_E. */
  SIG_MESSAGE("Det1_E (Init)");
#define mccompcurname  Det1_E
#define mccompcurtype  E_monitor
#define mccompcurindex 137
#define nE mccDet1_E_nE
#define E_N mccDet1_E_E_N
#define E_p mccDet1_E_E_p
#define E_p2 mccDet1_E_E_p2
#define S_p mccDet1_E_S_p
#define S_pE mccDet1_E_S_pE
#define S_pE2 mccDet1_E_S_pE2
#define filename mccDet1_E_filename
#define xmin mccDet1_E_xmin
#define xmax mccDet1_E_xmax
#define ymin mccDet1_E_ymin
#define ymax mccDet1_E_ymax
#define xwidth mccDet1_E_xwidth
#define yheight mccDet1_E_yheight
#define Emin mccDet1_E_Emin
#define Emax mccDet1_E_Emax
#define restore_neutron mccDet1_E_restore_neutron
#define nowritefile mccDet1_E_nowritefile
#line 66 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("E_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nE; i++)
    {
      E_N[i] = 0;
      E_p[i] = 0;
      E_p2[i] = 0;
    }
    S_p = S_pE = S_pE2 = 0;
}
#line 43777 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Det1_E_variable_range. */
  SIG_MESSAGE("Det1_E_variable_range (Init)");
#define mccompcurname  Det1_E_variable_range
#define mccompcurtype  E_monitor
#define mccompcurindex 138
#define nE mccDet1_E_variable_range_nE
#define E_N mccDet1_E_variable_range_E_N
#define E_p mccDet1_E_variable_range_E_p
#define E_p2 mccDet1_E_variable_range_E_p2
#define S_p mccDet1_E_variable_range_S_p
#define S_pE mccDet1_E_variable_range_S_pE
#define S_pE2 mccDet1_E_variable_range_S_pE2
#define filename mccDet1_E_variable_range_filename
#define xmin mccDet1_E_variable_range_xmin
#define xmax mccDet1_E_variable_range_xmax
#define ymin mccDet1_E_variable_range_ymin
#define ymax mccDet1_E_variable_range_ymax
#define xwidth mccDet1_E_variable_range_xwidth
#define yheight mccDet1_E_variable_range_yheight
#define Emin mccDet1_E_variable_range_Emin
#define Emax mccDet1_E_variable_range_Emax
#define restore_neutron mccDet1_E_variable_range_restore_neutron
#define nowritefile mccDet1_E_variable_range_nowritefile
#line 66 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("E_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nE; i++)
    {
      E_N[i] = 0;
      E_p[i] = 0;
      E_p2[i] = 0;
    }
    S_p = S_pE = S_pE2 = 0;
}
#line 43845 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Emax
#undef Emin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Det1_Lam. */
  SIG_MESSAGE("Det1_Lam (Init)");
#define mccompcurname  Det1_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 139
#define nL mccDet1_Lam_nL
#define L_N mccDet1_Lam_L_N
#define L_p mccDet1_Lam_L_p
#define L_p2 mccDet1_Lam_L_p2
#define filename mccDet1_Lam_filename
#define xmin mccDet1_Lam_xmin
#define xmax mccDet1_Lam_xmax
#define ymin mccDet1_Lam_ymin
#define ymax mccDet1_Lam_ymax
#define xwidth mccDet1_Lam_xwidth
#define yheight mccDet1_Lam_yheight
#define Lmin mccDet1_Lam_Lmin
#define Lmax mccDet1_Lam_Lmax
#define restore_neutron mccDet1_Lam_restore_neutron
#define nowritefile mccDet1_Lam_nowritefile
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 43909 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Det1_Lam_variable_range. */
  SIG_MESSAGE("Det1_Lam_variable_range (Init)");
#define mccompcurname  Det1_Lam_variable_range
#define mccompcurtype  L_monitor
#define mccompcurindex 140
#define nL mccDet1_Lam_variable_range_nL
#define L_N mccDet1_Lam_variable_range_L_N
#define L_p mccDet1_Lam_variable_range_L_p
#define L_p2 mccDet1_Lam_variable_range_L_p2
#define filename mccDet1_Lam_variable_range_filename
#define xmin mccDet1_Lam_variable_range_xmin
#define xmax mccDet1_Lam_variable_range_xmax
#define ymin mccDet1_Lam_variable_range_ymin
#define ymax mccDet1_Lam_variable_range_ymax
#define xwidth mccDet1_Lam_variable_range_xwidth
#define yheight mccDet1_Lam_variable_range_yheight
#define Lmin mccDet1_Lam_variable_range_Lmin
#define Lmax mccDet1_Lam_variable_range_Lmax
#define restore_neutron mccDet1_Lam_variable_range_restore_neutron
#define nowritefile mccDet1_Lam_variable_range_nowritefile
#line 62 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("L_monitor: %s: Null detection area !\n"
                   "ERROR      (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nL; i++)
    {
      L_N[i] = 0;
      L_p[i] = 0;
      L_p2[i] = 0;
    }
}
#line 43970 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef Lmax
#undef Lmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Det1_ToF. */
  SIG_MESSAGE("Det1_ToF (Init)");
#define mccompcurname  Det1_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 141
#define nt mccDet1_ToF_nt
#define TOF_N mccDet1_ToF_TOF_N
#define TOF_p mccDet1_ToF_TOF_p
#define TOF_p2 mccDet1_ToF_TOF_p2
#define t_min mccDet1_ToF_t_min
#define t_max mccDet1_ToF_t_max
#define delta_t mccDet1_ToF_delta_t
#define filename mccDet1_ToF_filename
#define xmin mccDet1_ToF_xmin
#define xmax mccDet1_ToF_xmax
#define ymin mccDet1_ToF_ymin
#define ymax mccDet1_ToF_ymax
#define xwidth mccDet1_ToF_xwidth
#define yheight mccDet1_ToF_yheight
#define tmin mccDet1_ToF_tmin
#define tmax mccDet1_ToF_tmax
#define dt mccDet1_ToF_dt
#define restore_neutron mccDet1_ToF_restore_neutron
#define nowritefile mccDet1_ToF_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 44047 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Det1_ToF_variable_range. */
  SIG_MESSAGE("Det1_ToF_variable_range (Init)");
#define mccompcurname  Det1_ToF_variable_range
#define mccompcurtype  TOF_monitor
#define mccompcurindex 142
#define nt mccDet1_ToF_variable_range_nt
#define TOF_N mccDet1_ToF_variable_range_TOF_N
#define TOF_p mccDet1_ToF_variable_range_TOF_p
#define TOF_p2 mccDet1_ToF_variable_range_TOF_p2
#define t_min mccDet1_ToF_variable_range_t_min
#define t_max mccDet1_ToF_variable_range_t_max
#define delta_t mccDet1_ToF_variable_range_delta_t
#define filename mccDet1_ToF_variable_range_filename
#define xmin mccDet1_ToF_variable_range_xmin
#define xmax mccDet1_ToF_variable_range_xmax
#define ymin mccDet1_ToF_variable_range_ymin
#define ymax mccDet1_ToF_variable_range_ymax
#define xwidth mccDet1_ToF_variable_range_xwidth
#define yheight mccDet1_ToF_variable_range_yheight
#define tmin mccDet1_ToF_variable_range_tmin
#define tmax mccDet1_ToF_variable_range_tmax
#define dt mccDet1_ToF_variable_range_dt
#define restore_neutron mccDet1_ToF_variable_range_restore_neutron
#define nowritefile mccDet1_ToF_variable_range_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 44128 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Det1_ToF_variable_range_lessnL. */
  SIG_MESSAGE("Det1_ToF_variable_range_lessnL (Init)");
#define mccompcurname  Det1_ToF_variable_range_lessnL
#define mccompcurtype  TOF_monitor
#define mccompcurindex 143
#define nt mccDet1_ToF_variable_range_lessnL_nt
#define TOF_N mccDet1_ToF_variable_range_lessnL_TOF_N
#define TOF_p mccDet1_ToF_variable_range_lessnL_TOF_p
#define TOF_p2 mccDet1_ToF_variable_range_lessnL_TOF_p2
#define t_min mccDet1_ToF_variable_range_lessnL_t_min
#define t_max mccDet1_ToF_variable_range_lessnL_t_max
#define delta_t mccDet1_ToF_variable_range_lessnL_delta_t
#define filename mccDet1_ToF_variable_range_lessnL_filename
#define xmin mccDet1_ToF_variable_range_lessnL_xmin
#define xmax mccDet1_ToF_variable_range_lessnL_xmax
#define ymin mccDet1_ToF_variable_range_lessnL_ymin
#define ymax mccDet1_ToF_variable_range_lessnL_ymax
#define xwidth mccDet1_ToF_variable_range_lessnL_xwidth
#define yheight mccDet1_ToF_variable_range_lessnL_yheight
#define tmin mccDet1_ToF_variable_range_lessnL_tmin
#define tmax mccDet1_ToF_variable_range_lessnL_tmax
#define dt mccDet1_ToF_variable_range_lessnL_dt
#define restore_neutron mccDet1_ToF_variable_range_lessnL_restore_neutron
#define nowritefile mccDet1_ToF_variable_range_lessnL_nowritefile
#line 61 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
int i;

if (xwidth  > 0) { xmax = xwidth/2;  xmin = -xmax; }
    if (yheight > 0) { ymax = yheight/2; ymin = -ymax; }

    if ((xmin >= xmax) || (ymin >= ymax)) {
            printf("TOF_monitor: %s: Null detection area !\n"
                   "ERROR        (xwidth,yheight,xmin,xmax,ymin,ymax). Exiting",
           NAME_CURRENT_COMP);
      exit(0);
    }

    for (i=0; i<nt; i++)
    {
      TOF_N[i] = 0;
      TOF_p[i] = 0;
      TOF_p2[i] = 0;
    }
    if (tmax!=0)
    {
      t_max=tmax;
      t_min=tmin;
      delta_t=(t_max-t_min)/nt;
    }
    else
    {
     delta_t=dt;
     t_min=0;
     t_max=nt*dt+tmin;
    }
}
#line 44209 "./SNS_BASIS.c"
#undef nowritefile
#undef restore_neutron
#undef dt
#undef tmax
#undef tmin
#undef yheight
#undef xwidth
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef filename
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component PSDcyl. */
  SIG_MESSAGE("PSDcyl (Init)");
#define mccompcurname  PSDcyl
#define mccompcurtype  Monitor_nD
#define mccompcurindex 144
#define user1 mccPSDcyl_user1
#define user2 mccPSDcyl_user2
#define user3 mccPSDcyl_user3
#define DEFS mccPSDcyl_DEFS
#define Vars mccPSDcyl_Vars
#define detector mccPSDcyl_detector
#define offdata mccPSDcyl_offdata
#define xwidth mccPSDcyl_xwidth
#define yheight mccPSDcyl_yheight
#define zdepth mccPSDcyl_zdepth
#define xmin mccPSDcyl_xmin
#define xmax mccPSDcyl_xmax
#define ymin mccPSDcyl_ymin
#define ymax mccPSDcyl_ymax
#define zmin mccPSDcyl_zmin
#define zmax mccPSDcyl_zmax
#define bins mccPSDcyl_bins
#define min mccPSDcyl_min
#define max mccPSDcyl_max
#define restore_neutron mccPSDcyl_restore_neutron
#define radius mccPSDcyl_radius
#define options mccPSDcyl_options
#define filename mccPSDcyl_filename
#define geometry mccPSDcyl_geometry
#define username1 mccPSDcyl_username1
#define username2 mccPSDcyl_username2
#define username3 mccPSDcyl_username3
#define nowritefile mccPSDcyl_nowritefile
#line 230 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  char tmp[CHAR_BUF_LENGTH];
  strcpy(Vars.compcurname, NAME_CURRENT_COMP);
  if (options != NULL)
    strncpy(Vars.option, options, CHAR_BUF_LENGTH);
  else {
    strcpy(Vars.option, "x y");
    printf("Monitor_nD: %s has no option specified. Setting to PSD ('x y') monitor.\n", NAME_CURRENT_COMP);
  }
  Vars.compcurpos = POS_A_CURRENT_COMP;

  if (strstr(Vars.option, "source"))
    strcat(Vars.option, " list, x y z vx vy vz t sx sy sz ");

  if (bins) { sprintf(tmp, " all bins=%ld ", (long)bins); strcat(Vars.option, tmp); }
  if (min > -FLT_MAX && max < FLT_MAX) { sprintf(tmp, " all limits=[%g %g]", min, max); strcat(Vars.option, tmp); }
  else if (min > -FLT_MAX) { sprintf(tmp, " all min=%g", min); strcat(Vars.option, tmp); }
  else if (max <  FLT_MAX) { sprintf(tmp, " all max=%g", max); strcat(Vars.option, tmp); }

  strncpy(Vars.UserName1,
    username1 && strlen(username1) && strcmp(username1, "0") && strcmp(username1, "NULL") ?
    username1 : "", 128);
  strncpy(Vars.UserName2,
    username2 && strlen(username2) && strcmp(username2, "0") && strcmp(username2, "NULL") ?
    username2 : "", 128);
  strncpy(Vars.UserName3,
    username3 && strlen(username3) && strcmp(username3, "0") && strcmp(username3, "NULL") ?
    username3 : "", 128);
  if (radius) {
    xwidth = zdepth = 2*radius;
    if (yheight && !strstr(Vars.option, "cylinder") && !strstr(Vars.option, "banana") && !strstr(Vars.option, "sphere"))
      strcat(Vars.option, " banana");
    else if (!yheight && !strstr(Vars.option ,"sphere")) {
      strcat(Vars.option, " sphere");
      yheight=2*radius;
    }
  }
  int offflag=0;
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) {
    if (!off_init(  geometry, xwidth, yheight, zdepth, 1, &offdata )) {
      printf("Monitor_nD: %s could not initiate the OFF geometry %s. \n"
             "            Defaulting to normal Monitor dimensions.\n",
             NAME_CURRENT_COMP, geometry);
      strcpy(geometry, "");
    } else {
      offflag=1;
    }
  }

  if (!radius && !xwidth && !yheight && !zdepth && !xmin && !xmax && !ymin && !ymax &&
    !strstr(Vars.option, "previous") && (!geometry || !strlen(geometry)))
    exit(printf("Monitor_nD: %s has no dimension specified. Aborting (radius, xwidth, yheight, zdepth, previous, geometry).\n", NAME_CURRENT_COMP));

  Monitor_nD_Init(&DEFS, &Vars, xwidth, yheight, zdepth, xmin,xmax,ymin,ymax,zmin,zmax,offflag);

  if (Vars.Flag_OFF) {
    offdata.mantidflag=Vars.Flag_mantid;
    offdata.mantidoffset=Vars.Coord_Min[Vars.Coord_Number-1];
  }


  if (filename && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
    strncpy(Vars.Mon_File, filename, 128);

  /* check if user given filename with ext will be used more than once */
  if ( ((Vars.Flag_Multiple && Vars.Coord_Number > 1) || Vars.Flag_List) && strchr(Vars.Mon_File,'.') )
  { char *XY; XY = strrchr(Vars.Mon_File,'.'); *XY='_'; }

  if (restore_neutron) Vars.Flag_parallel=1;
  detector.m = 0;

#ifdef USE_MPI
MPI_MASTER(
  if (strstr(Vars.option, "auto") && mpi_node_count > 1)
    printf("Monitor_nD: %s is using automatic limits option 'auto' together with MPI.\n"
           "WARNING     this may create incorrect distributions (but integrated flux will be right).\n", NAME_CURRENT_COMP);
);
#endif
}
#line 44346 "./SNS_BASIS.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component TOFcyl. */
  SIG_MESSAGE("TOFcyl (Init)");
#define mccompcurname  TOFcyl
#define mccompcurtype  Monitor_nD
#define mccompcurindex 145
#define user1 mccTOFcyl_user1
#define user2 mccTOFcyl_user2
#define user3 mccTOFcyl_user3
#define DEFS mccTOFcyl_DEFS
#define Vars mccTOFcyl_Vars
#define detector mccTOFcyl_detector
#define offdata mccTOFcyl_offdata
#define xwidth mccTOFcyl_xwidth
#define yheight mccTOFcyl_yheight
#define zdepth mccTOFcyl_zdepth
#define xmin mccTOFcyl_xmin
#define xmax mccTOFcyl_xmax
#define ymin mccTOFcyl_ymin
#define ymax mccTOFcyl_ymax
#define zmin mccTOFcyl_zmin
#define zmax mccTOFcyl_zmax
#define bins mccTOFcyl_bins
#define min mccTOFcyl_min
#define max mccTOFcyl_max
#define restore_neutron mccTOFcyl_restore_neutron
#define radius mccTOFcyl_radius
#define options mccTOFcyl_options
#define filename mccTOFcyl_filename
#define geometry mccTOFcyl_geometry
#define username1 mccTOFcyl_username1
#define username2 mccTOFcyl_username2
#define username3 mccTOFcyl_username3
#define nowritefile mccTOFcyl_nowritefile
#line 230 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  char tmp[CHAR_BUF_LENGTH];
  strcpy(Vars.compcurname, NAME_CURRENT_COMP);
  if (options != NULL)
    strncpy(Vars.option, options, CHAR_BUF_LENGTH);
  else {
    strcpy(Vars.option, "x y");
    printf("Monitor_nD: %s has no option specified. Setting to PSD ('x y') monitor.\n", NAME_CURRENT_COMP);
  }
  Vars.compcurpos = POS_A_CURRENT_COMP;

  if (strstr(Vars.option, "source"))
    strcat(Vars.option, " list, x y z vx vy vz t sx sy sz ");

  if (bins) { sprintf(tmp, " all bins=%ld ", (long)bins); strcat(Vars.option, tmp); }
  if (min > -FLT_MAX && max < FLT_MAX) { sprintf(tmp, " all limits=[%g %g]", min, max); strcat(Vars.option, tmp); }
  else if (min > -FLT_MAX) { sprintf(tmp, " all min=%g", min); strcat(Vars.option, tmp); }
  else if (max <  FLT_MAX) { sprintf(tmp, " all max=%g", max); strcat(Vars.option, tmp); }

  strncpy(Vars.UserName1,
    username1 && strlen(username1) && strcmp(username1, "0") && strcmp(username1, "NULL") ?
    username1 : "", 128);
  strncpy(Vars.UserName2,
    username2 && strlen(username2) && strcmp(username2, "0") && strcmp(username2, "NULL") ?
    username2 : "", 128);
  strncpy(Vars.UserName3,
    username3 && strlen(username3) && strcmp(username3, "0") && strcmp(username3, "NULL") ?
    username3 : "", 128);
  if (radius) {
    xwidth = zdepth = 2*radius;
    if (yheight && !strstr(Vars.option, "cylinder") && !strstr(Vars.option, "banana") && !strstr(Vars.option, "sphere"))
      strcat(Vars.option, " banana");
    else if (!yheight && !strstr(Vars.option ,"sphere")) {
      strcat(Vars.option, " sphere");
      yheight=2*radius;
    }
  }
  int offflag=0;
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) {
    if (!off_init(  geometry, xwidth, yheight, zdepth, 1, &offdata )) {
      printf("Monitor_nD: %s could not initiate the OFF geometry %s. \n"
             "            Defaulting to normal Monitor dimensions.\n",
             NAME_CURRENT_COMP, geometry);
      strcpy(geometry, "");
    } else {
      offflag=1;
    }
  }

  if (!radius && !xwidth && !yheight && !zdepth && !xmin && !xmax && !ymin && !ymax &&
    !strstr(Vars.option, "previous") && (!geometry || !strlen(geometry)))
    exit(printf("Monitor_nD: %s has no dimension specified. Aborting (radius, xwidth, yheight, zdepth, previous, geometry).\n", NAME_CURRENT_COMP));

  Monitor_nD_Init(&DEFS, &Vars, xwidth, yheight, zdepth, xmin,xmax,ymin,ymax,zmin,zmax,offflag);

  if (Vars.Flag_OFF) {
    offdata.mantidflag=Vars.Flag_mantid;
    offdata.mantidoffset=Vars.Coord_Min[Vars.Coord_Number-1];
  }


  if (filename && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
    strncpy(Vars.Mon_File, filename, 128);

  /* check if user given filename with ext will be used more than once */
  if ( ((Vars.Flag_Multiple && Vars.Coord_Number > 1) || Vars.Flag_List) && strchr(Vars.Mon_File,'.') )
  { char *XY; XY = strrchr(Vars.Mon_File,'.'); *XY='_'; }

  if (restore_neutron) Vars.Flag_parallel=1;
  detector.m = 0;

#ifdef USE_MPI
MPI_MASTER(
  if (strstr(Vars.option, "auto") && mpi_node_count > 1)
    printf("Monitor_nD: %s is using automatic limits option 'auto' together with MPI.\n"
           "WARNING     this may create incorrect distributions (but integrated flux will be right).\n", NAME_CURRENT_COMP);
);
#endif
}
#line 44492 "./SNS_BASIS.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if(mcdotrace) mcdisplay();
    mcDEBUG_INSTR_END()
  }

} /* end init */

void mcraytrace(void) {
  /* Neutronics-specific defines */
#ifdef NEUTRONICS
extern double mcnx, mcny, mcnz, mcnvx, mcnvy, mcnvz;
extern double mcnt, mcnsx, mcnsy, mcnsz, mcnp;
#endif
  /* End of Neutronics-specific defines */
  /* Copy neutron state to local variables. */
  MCNUM mcnlx = mcnx;
  MCNUM mcnly = mcny;
  MCNUM mcnlz = mcnz;
  MCNUM mcnlvx = mcnvx;
  MCNUM mcnlvy = mcnvy;
  MCNUM mcnlvz = mcnvz;
  MCNUM mcnlt = mcnt;
  MCNUM mcnlsx = mcnsx;
  MCNUM mcnlsy = mcnsy;
  MCNUM mcnlsz = mcnsz;
  MCNUM mcnlp = mcnp;

  mcDEBUG_ENTER()
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
/* Set Component group definitions (flags) */
  mcGroupANALYZERS=0; /* equals index of scattering comp when in group */
#define mcabsorb mcabsorbAll
  /* TRACE Component Origin [1] */
  mccoordschange(mcposrOrigin, mcrotrOrigin,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Origin (without coords transformations) */
  mcJumpTrace_Origin:
  SIG_MESSAGE("Origin (Trace)");
  mcDEBUG_COMP("Origin")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompOrigin
  STORE_NEUTRON(1,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[1]++;
  mcPCounter[1] += p;
  mcP2Counter[1] += p*p;
#define mccompcurname  Origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccOrigin_IntermediateCnts
#define StartTime mccOrigin_StartTime
#define EndTime mccOrigin_EndTime
#define CurrentTime mccOrigin_CurrentTime
{   /* Declarations of Origin=Progress_bar() SETTING parameters. */
char* profile = mccOrigin_profile;
MCNUM percent = mccOrigin_percent;
MCNUM flag_save = mccOrigin_flag_save;
MCNUM minutes = mccOrigin_minutes;
#line 70 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../misc/Progress_bar.comp"
{
  double ncount;
  ncount = mcget_run_num();
  if (!StartTime) {
    time(&StartTime); /* compute starting time */
    IntermediateCnts = 1e3;
  }
  time_t NowTime;
  time(&NowTime);
  /* compute initial estimate of computation duration */
  if (!EndTime && ncount >= IntermediateCnts) {
    CurrentTime = NowTime;
    if (difftime(NowTime,StartTime) > 10 && ncount) { /* wait 10 sec before writing ETA */
      EndTime = StartTime + (time_t)(difftime(NowTime,StartTime)
				     *(double)mcget_ncount()/ncount);
      IntermediateCnts = 0;
      fprintf(stdout, "\nTrace ETA ");
      if (difftime(EndTime,StartTime) < 60.0)
        fprintf(stdout, "%g [s] %% ", difftime(EndTime,StartTime));
      else if (difftime(EndTime,StartTime) > 3600.0)
        fprintf(stdout, "%g [h] %% ", difftime(EndTime,StartTime)/3600.0);
      else
        fprintf(stdout, "%g [min] %% ", difftime(EndTime,StartTime)/60.0);
    } else IntermediateCnts += 1e3;
    fflush(stdout);
  }

  /* display percentage when percent or minutes have reached step */
  if (EndTime && mcget_ncount() &&
    (    (minutes && difftime(NowTime,CurrentTime) > minutes*60)
      || (percent && !minutes && ncount >= IntermediateCnts))   )
  {
    fprintf(stdout, "%d ", (int)(ncount*100.0/mcget_ncount())); fflush(stdout);
    CurrentTime = NowTime;

    IntermediateCnts = ncount + percent*mcget_ncount()/100;
    /* check that next intermediate ncount check is a multiple of the desired percentage */
    IntermediateCnts = floor(IntermediateCnts*100/percent/mcget_ncount())*percent*mcget_ncount()/100;
    /* raise flag to indicate that we did something */
    SCATTER;
    if (flag_save) mcsave(NULL);
  }
}
#line 44680 "./SNS_BASIS.c"
}   /* End of Origin=Progress_bar() SETTING parameter declarations. */
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompOrigin:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(1,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Source [2] */
  mccoordschange(mcposrSource, mcrotrSource,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Source (without coords transformations) */
  mcJumpTrace_Source:
  SIG_MESSAGE("Source (Trace)");
  mcDEBUG_COMP("Source")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompSource
  STORE_NEUTRON(2,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[2]++;
  mcPCounter[2] += p;
  mcP2Counter[2] += p*p;
#define mccompcurname  Source
#define mccompcurtype  ESS_moderator_short
#define mccompcurindex 2
#define l_range mccSource_l_range
#define w_mult mccSource_w_mult
{   /* Declarations of Source=ESS_moderator_short() SETTING parameters. */
MCNUM size = mccSource_size;
MCNUM Lmin = mccSource_Lmin;
MCNUM Lmax = mccSource_Lmax;
MCNUM dist = mccSource_dist;
MCNUM focus_xw = mccSource_focus_xw;
MCNUM focus_yh = mccSource_focus_yh;
MCNUM nu = mccSource_nu;
MCNUM T = mccSource_T;
MCNUM tau = mccSource_tau;
MCNUM tau1 = mccSource_tau1;
MCNUM tau2 = mccSource_tau2;
MCNUM n = mccSource_n;
MCNUM n2 = mccSource_n2;
MCNUM chi2 = mccSource_chi2;
MCNUM I0 = mccSource_I0;
MCNUM I2 = mccSource_I2;
MCNUM branch1 = mccSource_branch1;
MCNUM branch2 = mccSource_branch2;
MCNUM branchframe = mccSource_branchframe;
int target_index = mccSource_target_index;
#line 145 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../obsolete/ESS_moderator_short.comp"
{
  double v,tau_l,E,lambda,k,r,xf,yf,dx,dy,w_focus;

  z=0;

  x = 0.5*size*randpm1();
  y = 0.5*size*randpm1();         /* Choose initial position */

  randvec_target_rect_real(&xf, &yf, &r, &w_focus,
			   0, 0, dist, focus_xw, focus_yh, ROT_A_CURRENT_COMP, x, y, z, 2);

  dx = xf-x;
  dy = yf-y;
  r = sqrt(dx*dx+dy*dy+dist*dist);

  lambda = Lmin+l_range*rand01();    /* Choose from uniform distribution */
  k = 2*PI/lambda;
  v = K2V*k;

  vz = v*dist/r;
  vy = v*dy/r;
  vx = v*dx/r;


/*  printf("pos0 (%g %g %g), pos1 (%g %g %g), r: %g, v (%g %g %g), v %g\n",
  x,y,z,xf,yf,dist,r,vx,vy,vz, v);
  printf("l %g, w_focus %g \n", lambda, w_focus);  */

  if (rand01() < branch2)
  {
    if (tau1>0)  /* coupled water */
      if (rand01() < branch1)
      {  /* FIRST CASE a */
        tau_l = tau;
        p = 1/(branch1*branch2);            /* Correct for switching prob. */
      }
      else
      {  /* FIRST CASE b */
        tau_l = tau1;
        p = 1/((1-branch1)*branch2);        /* Correct for switching prob. */
      }
    else /* all other moderators */
      {
        tau_l = tau;
        p = 1/branch2;            /* Correct for switching prob. */
      }
    t = -tau_l*log(1e-12+rand01());       /* Sample from long-time tail a */
    p *= n/(n-1)*(1-exp(-(n-1)*t/tau_l)); /* Correct for true pulse shape */
    p *= w_focus;                         /* Correct for target focusing */
    p *= I0*w_mult*Mezei_M_fct(lambda,T);           /* Calculate true intensity */
  }
  else
  {
    /* SECOND CASE */
    tau_l = tau2*lambda;  /* CHECK THIS */
    t = -tau_l*log(1e-12+rand01());       /* Sample from long-time tail */
    p = n2/(n2-1)*(1-exp(-(n2-1)*t/tau_l));/* Correct for true pulse shape */
    p /= (1-branch2);                     /* Correct for switching prob. */
    p *= w_focus;                         /* Correct for target focusing */
    p *= I2*w_mult/(1+exp(chi2*lambda-2.2))/lambda;
                                          /* Calculate true intensity */
  }

 if (branchframe > 0 && rand01() <= branchframe)
  {
   p /= branchframe;
  }
 else
  {
   if (rand01() < 0.5)
     t += Delta_t;
   else
     t -= Delta_t;
   p *= 2.0/(1-branchframe);
  }

 /* Go to per-second units */
 p*=nu;

}
#line 44893 "./SNS_BASIS.c"
/* 'Source=ESS_moderator_short()' component instance extend code */
    SIG_MESSAGE("Source (Trace:Extend)");
#line 216 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  p/=1.3;
  p*=2.5;
  //printf("Energies as calculated by the component: %g - %g\n",Emin,Emax);
#line 44900 "./SNS_BASIS.c"
}   /* End of Source=ESS_moderator_short() SETTING parameter declarations. */
#undef w_mult
#undef l_range
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompSource:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(2,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component tofSTART [3] */
  mccoordschange(mcposrtofSTART, mcrotrtofSTART,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component tofSTART (without coords transformations) */
  mcJumpTrace_tofSTART:
  SIG_MESSAGE("tofSTART (Trace)");
  mcDEBUG_COMP("tofSTART")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbComptofSTART
  STORE_NEUTRON(3,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[3]++;
  mcPCounter[3] += p;
  mcP2Counter[3] += p*p;
#define mccompcurname  tofSTART
#define mccompcurtype  TOF_monitor
#define mccompcurindex 3
#define nt mcctofSTART_nt
#define TOF_N mcctofSTART_TOF_N
#define TOF_p mcctofSTART_TOF_p
#define TOF_p2 mcctofSTART_TOF_p2
#define t_min mcctofSTART_t_min
#define t_max mcctofSTART_t_max
#define delta_t mcctofSTART_delta_t
{   /* Declarations of tofSTART=TOF_monitor() SETTING parameters. */
char* filename = mcctofSTART_filename;
MCNUM xmin = mcctofSTART_xmin;
MCNUM xmax = mcctofSTART_xmax;
MCNUM ymin = mcctofSTART_ymin;
MCNUM ymax = mcctofSTART_ymax;
MCNUM xwidth = mcctofSTART_xwidth;
MCNUM yheight = mcctofSTART_yheight;
MCNUM tmin = mcctofSTART_tmin;
MCNUM tmax = mcctofSTART_tmax;
MCNUM dt = mcctofSTART_dt;
MCNUM restore_neutron = mcctofSTART_restore_neutron;
int nowritefile = mcctofSTART_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 45046 "./SNS_BASIS.c"
}   /* End of tofSTART=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbComptofSTART:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(3,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Source_Lam [4] */
  mccoordschange(mcposrSource_Lam, mcrotrSource_Lam,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Source_Lam (without coords transformations) */
  mcJumpTrace_Source_Lam:
  SIG_MESSAGE("Source_Lam (Trace)");
  mcDEBUG_COMP("Source_Lam")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompSource_Lam
  STORE_NEUTRON(4,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[4]++;
  mcPCounter[4] += p;
  mcP2Counter[4] += p*p;
#define mccompcurname  Source_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 4
#define nL mccSource_Lam_nL
#define L_N mccSource_Lam_L_N
#define L_p mccSource_Lam_L_p
#define L_p2 mccSource_Lam_L_p2
{   /* Declarations of Source_Lam=L_monitor() SETTING parameters. */
char* filename = mccSource_Lam_filename;
MCNUM xmin = mccSource_Lam_xmin;
MCNUM xmax = mccSource_Lam_xmax;
MCNUM ymin = mccSource_Lam_ymin;
MCNUM ymax = mccSource_Lam_ymax;
MCNUM xwidth = mccSource_Lam_xwidth;
MCNUM yheight = mccSource_Lam_yheight;
MCNUM Lmin = mccSource_Lam_Lmin;
MCNUM Lmax = mccSource_Lam_Lmax;
MCNUM restore_neutron = mccSource_Lam_restore_neutron;
int nowritefile = mccSource_Lam_nowritefile;
#line 84 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 45196 "./SNS_BASIS.c"
}   /* End of Source_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompSource_Lam:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(4,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Source_En [5] */
  mccoordschange(mcposrSource_En, mcrotrSource_En,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Source_En (without coords transformations) */
  mcJumpTrace_Source_En:
  SIG_MESSAGE("Source_En (Trace)");
  mcDEBUG_COMP("Source_En")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompSource_En
  STORE_NEUTRON(5,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[5]++;
  mcPCounter[5] += p;
  mcP2Counter[5] += p*p;
#define mccompcurname  Source_En
#define mccompcurtype  E_monitor
#define mccompcurindex 5
#define nE mccSource_En_nE
#define E_N mccSource_En_E_N
#define E_p mccSource_En_E_p
#define E_p2 mccSource_En_E_p2
#define S_p mccSource_En_S_p
#define S_pE mccSource_En_S_pE
#define S_pE2 mccSource_En_S_pE2
{   /* Declarations of Source_En=E_monitor() SETTING parameters. */
char* filename = mccSource_En_filename;
MCNUM xmin = mccSource_En_xmin;
MCNUM xmax = mccSource_En_xmax;
MCNUM ymin = mccSource_En_ymin;
MCNUM ymax = mccSource_En_ymax;
MCNUM xwidth = mccSource_En_xwidth;
MCNUM yheight = mccSource_En_yheight;
MCNUM Emin = mccSource_En_Emin;
MCNUM Emax = mccSource_En_Emax;
MCNUM restore_neutron = mccSource_En_restore_neutron;
int nowritefile = mccSource_En_nowritefile;
#line 89 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
{
    int i;
    double E;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      E = VS2E*(vx*vx + vy*vy + vz*vz);

      S_p += p;
      S_pE += p*E;
      S_pE2 += p*E*E;

      i = floor((E-Emin)*nE/(Emax-Emin));
      if(i >= 0 && i < nE)
      {
        E_N[i]++;
        E_p[i] += p;
        E_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 45351 "./SNS_BASIS.c"
}   /* End of Source_En=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompSource_En:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(5,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap0_start [6] */
  mccoordschange(mcposrGap0_start, mcrotrGap0_start,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap0_start (without coords transformations) */
  mcJumpTrace_Gap0_start:
  SIG_MESSAGE("Gap0_start (Trace)");
  mcDEBUG_COMP("Gap0_start")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap0_start
  STORE_NEUTRON(6,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[6]++;
  mcPCounter[6] += p;
  mcP2Counter[6] += p*p;
#define mccompcurname  Gap0_start
#define mccompcurtype  PSD_monitor
#define mccompcurindex 6
#define PSD_N mccGap0_start_PSD_N
#define PSD_p mccGap0_start_PSD_p
#define PSD_p2 mccGap0_start_PSD_p2
{   /* Declarations of Gap0_start=PSD_monitor() SETTING parameters. */
int nx = mccGap0_start_nx;
int ny = mccGap0_start_ny;
char* filename = mccGap0_start_filename;
MCNUM xmin = mccGap0_start_xmin;
MCNUM xmax = mccGap0_start_xmax;
MCNUM ymin = mccGap0_start_ymin;
MCNUM ymax = mccGap0_start_ymax;
MCNUM xwidth = mccGap0_start_xwidth;
MCNUM yheight = mccGap0_start_yheight;
MCNUM restore_neutron = mccGap0_start_restore_neutron;
#line 94 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  PROP_Z0;
  if (x>xmin && x<xmax && y>ymin && y<ymax){
    int i = floor((x - xmin)*nx/(xmax - xmin));
    int j = floor((y - ymin)*ny/(ymax - ymin));
    PSD_N[i][j]++;
    PSD_p[i][j] += p;
    PSD_p2[i][j] += p*p;
    SCATTER;
  }
  if (restore_neutron) {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 45492 "./SNS_BASIS.c"
}   /* End of Gap0_start=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap0_start:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(6,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap0_end_Lam [7] */
  mccoordschange(mcposrGap0_end_Lam, mcrotrGap0_end_Lam,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap0_end_Lam (without coords transformations) */
  mcJumpTrace_Gap0_end_Lam:
  SIG_MESSAGE("Gap0_end_Lam (Trace)");
  mcDEBUG_COMP("Gap0_end_Lam")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap0_end_Lam
  STORE_NEUTRON(7,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[7]++;
  mcPCounter[7] += p;
  mcP2Counter[7] += p*p;
#define mccompcurname  Gap0_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 7
#define nL mccGap0_end_Lam_nL
#define L_N mccGap0_end_Lam_L_N
#define L_p mccGap0_end_Lam_L_p
#define L_p2 mccGap0_end_Lam_L_p2
{   /* Declarations of Gap0_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap0_end_Lam_filename;
MCNUM xmin = mccGap0_end_Lam_xmin;
MCNUM xmax = mccGap0_end_Lam_xmax;
MCNUM ymin = mccGap0_end_Lam_ymin;
MCNUM ymax = mccGap0_end_Lam_ymax;
MCNUM xwidth = mccGap0_end_Lam_xwidth;
MCNUM yheight = mccGap0_end_Lam_yheight;
MCNUM Lmin = mccGap0_end_Lam_Lmin;
MCNUM Lmax = mccGap0_end_Lam_Lmax;
MCNUM restore_neutron = mccGap0_end_Lam_restore_neutron;
int nowritefile = mccGap0_end_Lam_nowritefile;
#line 84 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 45638 "./SNS_BASIS.c"
}   /* End of Gap0_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap0_end_Lam:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(7,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap0_end_divx [8] */
  mccoordschange(mcposrGap0_end_divx, mcrotrGap0_end_divx,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap0_end_divx (without coords transformations) */
  mcJumpTrace_Gap0_end_divx:
  SIG_MESSAGE("Gap0_end_divx (Trace)");
  mcDEBUG_COMP("Gap0_end_divx")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap0_end_divx
  STORE_NEUTRON(8,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[8]++;
  mcPCounter[8] += p;
  mcP2Counter[8] += p*p;
#define mccompcurname  Gap0_end_divx
#define mccompcurtype  Monitor_nD
#define mccompcurindex 8
#define user1 mccGap0_end_divx_user1
#define user2 mccGap0_end_divx_user2
#define user3 mccGap0_end_divx_user3
#define DEFS mccGap0_end_divx_DEFS
#define Vars mccGap0_end_divx_Vars
#define detector mccGap0_end_divx_detector
#define offdata mccGap0_end_divx_offdata
{   /* Declarations of Gap0_end_divx=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccGap0_end_divx_xwidth;
MCNUM yheight = mccGap0_end_divx_yheight;
MCNUM zdepth = mccGap0_end_divx_zdepth;
MCNUM xmin = mccGap0_end_divx_xmin;
MCNUM xmax = mccGap0_end_divx_xmax;
MCNUM ymin = mccGap0_end_divx_ymin;
MCNUM ymax = mccGap0_end_divx_ymax;
MCNUM zmin = mccGap0_end_divx_zmin;
MCNUM zmax = mccGap0_end_divx_zmax;
MCNUM bins = mccGap0_end_divx_bins;
MCNUM min = mccGap0_end_divx_min;
MCNUM max = mccGap0_end_divx_max;
MCNUM restore_neutron = mccGap0_end_divx_restore_neutron;
MCNUM radius = mccGap0_end_divx_radius;
char* options = mccGap0_end_divx_options;
char* filename = mccGap0_end_divx_filename;
char* geometry = mccGap0_end_divx_geometry;
char* username1 = mccGap0_end_divx_username1;
char* username2 = mccGap0_end_divx_username2;
char* username3 = mccGap0_end_divx_username3;
int nowritefile = mccGap0_end_divx_nowritefile;
#line 311 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  double  XY=0;
  double  t0 = 0;
  double  t1 = 0;
  double  pp;
  int     intersect   = 0;
  char    Flag_Restore = 0;

  if (user1 != FLT_MAX) Vars.UserVariable1 = user1;
  if (user2 != FLT_MAX) Vars.UserVariable2 = user2;
  if (user3 != FLT_MAX) Vars.UserVariable3 = user3;

  /* this is done automatically
    STORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  */

  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    /* determine intersections with object */
    intersect = off_intersect_all(&t0, &t1, NULL, NULL,
       x,y,z, vx, vy, vz, &offdata );
    if (Vars.Flag_mantid) {
      if(intersect) {
        Vars.OFF_polyidx=(offdata.intersects[offdata.nextintersect]).index;
      } else {
        Vars.OFF_polyidx=-1;
      }
    }
  }
  else if ( (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
            || (abs(Vars.Flag_Shape) == DEFS.SHAPE_DISK) ) /* square xy or disk xy */
  {
    // propagate to xy plane and find intersection
    // make sure the event is recoverable afterwards
    t0 = t;
    ALLOW_BACKPROP;
    PROP_Z0;
    if ( (t>=t0) && (z==0.0) ) // forward propagation to xy plane was successful
    {
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
      {
        // square xy
        intersect = (x>=Vars.mxmin && x<=Vars.mxmax && y>=Vars.mymin && y<=Vars.mymax);
      }
      else
      {
        // disk xy
        intersect = (SQR(x) + SQR(y)) <= SQR(Vars.Sphere_Radius);
      }
    }
    else
    {
      intersect=0;
    }
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) /* sphere */
  {
    intersect = sphere_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius);
  /*      intersect = (intersect && t0 > 0); */
  }
  else if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)) /* cylinder */
  {
    intersect = cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius, Vars.Cylinder_Height);
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) /* box */
  {
    intersect = box_intersect(&t0, &t1, x, y, z, vx, vy, vz,
                              fabs(Vars.mxmax-Vars.mxmin), fabs(Vars.mymax-Vars.mymin), fabs(Vars.mzmax-Vars.mzmin));
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_PREVIOUS) /* previous comp */
  { intersect = 1; }

  if (intersect)
  {
    if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND)
     || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)
     || (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) )
    {
      /* check if we have to remove the top/bottom with BANANA shape */
      if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA) && (intersect != 1)) {
        double y0,y1;
        /* propagate to intersection point as temporary variable to check top/bottom */
        y0 = y+t0*vy;
        y1 = y+t1*vy;
        if (fabs(y0) >= Vars.Cylinder_Height/2*0.99) t0 = t1;
        if (fabs(y1) >= Vars.Cylinder_Height/2*0.99) t1 = t0;
      }
      if (t0 < 0 && t1 > 0)
        t0 = t;  /* neutron was already inside ! */
      if (t1 < 0 && t0 > 0) /* neutron exit before entering !! */
        t1 = t;
      /* t0 is now time of incoming intersection with the detection area */
      if ((Vars.Flag_Shape < 0) && (t1 > 0))
        PROP_DT(t1); /* t1 outgoing beam */
      else
        PROP_DT(t0); /* t0 incoming beam */
      /* Final test if we are on lid / bottom of banana/sphere */
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA || abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) {
        if (fabs(y) >= Vars.Cylinder_Height/2*0.99) {
          intersect=0;
          Flag_Restore=1;
        }
      }
    }
  }

  if (intersect)
  {
    /* Now get the data to monitor: current or keep from PreMonitor */
    if (Vars.Flag_UsePreMonitor != 1)
    {
      Vars.cp  = p;
      Vars.cx  = x;
      Vars.cvx = vx;
      Vars.csx = sx;
      Vars.cy  = y;
      Vars.cvy = vy;
      Vars.csy = sy;
      Vars.cz  = z;
      Vars.cvz = vz;
      Vars.csz = sz;
      Vars.ct  = t;
    }

    if ((Vars.He3_pressure > 0) && (t1 != t0) && ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX)))
    {
      XY = exp(-7.417*Vars.He3_pressure*fabs(t1-t0)*2*PI*K2V);
      /* will monitor the absorbed part */
      Vars.cp *= 1-XY;
      /* and modify the neutron weight after monitor, only remains 1-p_detect */
      p *= XY;
    }

    if (Vars.Flag_capture)
    {
      XY = sqrt(Vars.cvx*Vars.cvx+Vars.cvy*Vars.cvy+Vars.cvz*Vars.cvz);
      XY *= V2K;
      if (XY != 0) XY = 2*PI/XY; /* lambda. lambda(2200 m/2) = 1.7985 Angs  */
      Vars.cp *= XY/1.7985;
    }

    pp = Monitor_nD_Trace(&DEFS, &Vars);
    if (pp==0.0)
    { ABSORB;
    }
    else if(pp==1)
    {
      SCATTER;
    }

    if (Vars.Flag_parallel) /* back to neutron state before detection */
      Flag_Restore = 1;
  } /* end if intersection */
  else {
    if (Vars.Flag_Absorb && !Vars.Flag_parallel)
    {
      // restore neutron ray before absorbing for correct mcdisplay
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
      ABSORB;
    }
    else Flag_Restore = 1;  /* no intersection, back to previous state */
  }

  if (Flag_Restore)
  {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 45945 "./SNS_BASIS.c"
}   /* End of Gap0_end_divx=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap0_end_divx:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(8,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap0_end_divy [9] */
  mccoordschange(mcposrGap0_end_divy, mcrotrGap0_end_divy,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap0_end_divy (without coords transformations) */
  mcJumpTrace_Gap0_end_divy:
  SIG_MESSAGE("Gap0_end_divy (Trace)");
  mcDEBUG_COMP("Gap0_end_divy")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap0_end_divy
  STORE_NEUTRON(9,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[9]++;
  mcPCounter[9] += p;
  mcP2Counter[9] += p*p;
#define mccompcurname  Gap0_end_divy
#define mccompcurtype  Monitor_nD
#define mccompcurindex 9
#define user1 mccGap0_end_divy_user1
#define user2 mccGap0_end_divy_user2
#define user3 mccGap0_end_divy_user3
#define DEFS mccGap0_end_divy_DEFS
#define Vars mccGap0_end_divy_Vars
#define detector mccGap0_end_divy_detector
#define offdata mccGap0_end_divy_offdata
{   /* Declarations of Gap0_end_divy=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccGap0_end_divy_xwidth;
MCNUM yheight = mccGap0_end_divy_yheight;
MCNUM zdepth = mccGap0_end_divy_zdepth;
MCNUM xmin = mccGap0_end_divy_xmin;
MCNUM xmax = mccGap0_end_divy_xmax;
MCNUM ymin = mccGap0_end_divy_ymin;
MCNUM ymax = mccGap0_end_divy_ymax;
MCNUM zmin = mccGap0_end_divy_zmin;
MCNUM zmax = mccGap0_end_divy_zmax;
MCNUM bins = mccGap0_end_divy_bins;
MCNUM min = mccGap0_end_divy_min;
MCNUM max = mccGap0_end_divy_max;
MCNUM restore_neutron = mccGap0_end_divy_restore_neutron;
MCNUM radius = mccGap0_end_divy_radius;
char* options = mccGap0_end_divy_options;
char* filename = mccGap0_end_divy_filename;
char* geometry = mccGap0_end_divy_geometry;
char* username1 = mccGap0_end_divy_username1;
char* username2 = mccGap0_end_divy_username2;
char* username3 = mccGap0_end_divy_username3;
int nowritefile = mccGap0_end_divy_nowritefile;
#line 311 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  double  XY=0;
  double  t0 = 0;
  double  t1 = 0;
  double  pp;
  int     intersect   = 0;
  char    Flag_Restore = 0;

  if (user1 != FLT_MAX) Vars.UserVariable1 = user1;
  if (user2 != FLT_MAX) Vars.UserVariable2 = user2;
  if (user3 != FLT_MAX) Vars.UserVariable3 = user3;

  /* this is done automatically
    STORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  */

  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    /* determine intersections with object */
    intersect = off_intersect_all(&t0, &t1, NULL, NULL,
       x,y,z, vx, vy, vz, &offdata );
    if (Vars.Flag_mantid) {
      if(intersect) {
        Vars.OFF_polyidx=(offdata.intersects[offdata.nextintersect]).index;
      } else {
        Vars.OFF_polyidx=-1;
      }
    }
  }
  else if ( (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
            || (abs(Vars.Flag_Shape) == DEFS.SHAPE_DISK) ) /* square xy or disk xy */
  {
    // propagate to xy plane and find intersection
    // make sure the event is recoverable afterwards
    t0 = t;
    ALLOW_BACKPROP;
    PROP_Z0;
    if ( (t>=t0) && (z==0.0) ) // forward propagation to xy plane was successful
    {
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
      {
        // square xy
        intersect = (x>=Vars.mxmin && x<=Vars.mxmax && y>=Vars.mymin && y<=Vars.mymax);
      }
      else
      {
        // disk xy
        intersect = (SQR(x) + SQR(y)) <= SQR(Vars.Sphere_Radius);
      }
    }
    else
    {
      intersect=0;
    }
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) /* sphere */
  {
    intersect = sphere_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius);
  /*      intersect = (intersect && t0 > 0); */
  }
  else if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)) /* cylinder */
  {
    intersect = cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius, Vars.Cylinder_Height);
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) /* box */
  {
    intersect = box_intersect(&t0, &t1, x, y, z, vx, vy, vz,
                              fabs(Vars.mxmax-Vars.mxmin), fabs(Vars.mymax-Vars.mymin), fabs(Vars.mzmax-Vars.mzmin));
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_PREVIOUS) /* previous comp */
  { intersect = 1; }

  if (intersect)
  {
    if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND)
     || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)
     || (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) )
    {
      /* check if we have to remove the top/bottom with BANANA shape */
      if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA) && (intersect != 1)) {
        double y0,y1;
        /* propagate to intersection point as temporary variable to check top/bottom */
        y0 = y+t0*vy;
        y1 = y+t1*vy;
        if (fabs(y0) >= Vars.Cylinder_Height/2*0.99) t0 = t1;
        if (fabs(y1) >= Vars.Cylinder_Height/2*0.99) t1 = t0;
      }
      if (t0 < 0 && t1 > 0)
        t0 = t;  /* neutron was already inside ! */
      if (t1 < 0 && t0 > 0) /* neutron exit before entering !! */
        t1 = t;
      /* t0 is now time of incoming intersection with the detection area */
      if ((Vars.Flag_Shape < 0) && (t1 > 0))
        PROP_DT(t1); /* t1 outgoing beam */
      else
        PROP_DT(t0); /* t0 incoming beam */
      /* Final test if we are on lid / bottom of banana/sphere */
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA || abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) {
        if (fabs(y) >= Vars.Cylinder_Height/2*0.99) {
          intersect=0;
          Flag_Restore=1;
        }
      }
    }
  }

  if (intersect)
  {
    /* Now get the data to monitor: current or keep from PreMonitor */
    if (Vars.Flag_UsePreMonitor != 1)
    {
      Vars.cp  = p;
      Vars.cx  = x;
      Vars.cvx = vx;
      Vars.csx = sx;
      Vars.cy  = y;
      Vars.cvy = vy;
      Vars.csy = sy;
      Vars.cz  = z;
      Vars.cvz = vz;
      Vars.csz = sz;
      Vars.ct  = t;
    }

    if ((Vars.He3_pressure > 0) && (t1 != t0) && ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX)))
    {
      XY = exp(-7.417*Vars.He3_pressure*fabs(t1-t0)*2*PI*K2V);
      /* will monitor the absorbed part */
      Vars.cp *= 1-XY;
      /* and modify the neutron weight after monitor, only remains 1-p_detect */
      p *= XY;
    }

    if (Vars.Flag_capture)
    {
      XY = sqrt(Vars.cvx*Vars.cvx+Vars.cvy*Vars.cvy+Vars.cvz*Vars.cvz);
      XY *= V2K;
      if (XY != 0) XY = 2*PI/XY; /* lambda. lambda(2200 m/2) = 1.7985 Angs  */
      Vars.cp *= XY/1.7985;
    }

    pp = Monitor_nD_Trace(&DEFS, &Vars);
    if (pp==0.0)
    { ABSORB;
    }
    else if(pp==1)
    {
      SCATTER;
    }

    if (Vars.Flag_parallel) /* back to neutron state before detection */
      Flag_Restore = 1;
  } /* end if intersection */
  else {
    if (Vars.Flag_Absorb && !Vars.Flag_parallel)
    {
      // restore neutron ray before absorbing for correct mcdisplay
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
      ABSORB;
    }
    else Flag_Restore = 1;  /* no intersection, back to previous state */
  }

  if (Flag_Restore)
  {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 46255 "./SNS_BASIS.c"
}   /* End of Gap0_end_divy=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap0_end_divy:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(9,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Core_Vessel_Section [10] */
  mccoordschange(mcposrCore_Vessel_Section, mcrotrCore_Vessel_Section,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Core_Vessel_Section (without coords transformations) */
  mcJumpTrace_Core_Vessel_Section:
  SIG_MESSAGE("Core_Vessel_Section (Trace)");
  mcDEBUG_COMP("Core_Vessel_Section")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCore_Vessel_Section
  STORE_NEUTRON(10,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[10]++;
  mcPCounter[10] += p;
  mcP2Counter[10] += p*p;
#define mccompcurname  Core_Vessel_Section
#define mccompcurtype  Guide
#define mccompcurindex 10
#define pTable mccCore_Vessel_Section_pTable
{   /* Declarations of Core_Vessel_Section=Guide() SETTING parameters. */
char* reflect = mccCore_Vessel_Section_reflect;
MCNUM w1 = mccCore_Vessel_Section_w1;
MCNUM h1 = mccCore_Vessel_Section_h1;
MCNUM w2 = mccCore_Vessel_Section_w2;
MCNUM h2 = mccCore_Vessel_Section_h2;
MCNUM l = mccCore_Vessel_Section_l;
MCNUM R0 = mccCore_Vessel_Section_R0;
MCNUM Qc = mccCore_Vessel_Section_Qc;
MCNUM alpha = mccCore_Vessel_Section_alpha;
MCNUM m = mccCore_Vessel_Section_m;
MCNUM W = mccCore_Vessel_Section_W;
#line 94 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 46487 "./SNS_BASIS.c"
}   /* End of Core_Vessel_Section=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCore_Vessel_Section:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(10,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap1_start [11] */
  mccoordschange(mcposrGap1_start, mcrotrGap1_start,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap1_start (without coords transformations) */
  mcJumpTrace_Gap1_start:
  SIG_MESSAGE("Gap1_start (Trace)");
  mcDEBUG_COMP("Gap1_start")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap1_start
  STORE_NEUTRON(11,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[11]++;
  mcPCounter[11] += p;
  mcP2Counter[11] += p*p;
#define mccompcurname  Gap1_start
#define mccompcurtype  Arm
#define mccompcurindex 11
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap1_start:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(11,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap1_start_Lam [12] */
  mccoordschange(mcposrGap1_start_Lam, mcrotrGap1_start_Lam,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap1_start_Lam (without coords transformations) */
  mcJumpTrace_Gap1_start_Lam:
  SIG_MESSAGE("Gap1_start_Lam (Trace)");
  mcDEBUG_COMP("Gap1_start_Lam")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap1_start_Lam
  STORE_NEUTRON(12,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[12]++;
  mcPCounter[12] += p;
  mcP2Counter[12] += p*p;
#define mccompcurname  Gap1_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 12
#define nL mccGap1_start_Lam_nL
#define L_N mccGap1_start_Lam_L_N
#define L_p mccGap1_start_Lam_L_p
#define L_p2 mccGap1_start_Lam_L_p2
{   /* Declarations of Gap1_start_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap1_start_Lam_filename;
MCNUM xmin = mccGap1_start_Lam_xmin;
MCNUM xmax = mccGap1_start_Lam_xmax;
MCNUM ymin = mccGap1_start_Lam_ymin;
MCNUM ymax = mccGap1_start_Lam_ymax;
MCNUM xwidth = mccGap1_start_Lam_xwidth;
MCNUM yheight = mccGap1_start_Lam_yheight;
MCNUM Lmin = mccGap1_start_Lam_Lmin;
MCNUM Lmax = mccGap1_start_Lam_Lmax;
MCNUM restore_neutron = mccGap1_start_Lam_restore_neutron;
int nowritefile = mccGap1_start_Lam_nowritefile;
#line 84 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 46734 "./SNS_BASIS.c"
}   /* End of Gap1_start_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap1_start_Lam:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(12,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap1_end_Lam [13] */
  mccoordschange(mcposrGap1_end_Lam, mcrotrGap1_end_Lam,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap1_end_Lam (without coords transformations) */
  mcJumpTrace_Gap1_end_Lam:
  SIG_MESSAGE("Gap1_end_Lam (Trace)");
  mcDEBUG_COMP("Gap1_end_Lam")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap1_end_Lam
  STORE_NEUTRON(13,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[13]++;
  mcPCounter[13] += p;
  mcP2Counter[13] += p*p;
#define mccompcurname  Gap1_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 13
#define nL mccGap1_end_Lam_nL
#define L_N mccGap1_end_Lam_L_N
#define L_p mccGap1_end_Lam_L_p
#define L_p2 mccGap1_end_Lam_L_p2
{   /* Declarations of Gap1_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap1_end_Lam_filename;
MCNUM xmin = mccGap1_end_Lam_xmin;
MCNUM xmax = mccGap1_end_Lam_xmax;
MCNUM ymin = mccGap1_end_Lam_ymin;
MCNUM ymax = mccGap1_end_Lam_ymax;
MCNUM xwidth = mccGap1_end_Lam_xwidth;
MCNUM yheight = mccGap1_end_Lam_yheight;
MCNUM Lmin = mccGap1_end_Lam_Lmin;
MCNUM Lmax = mccGap1_end_Lam_Lmax;
MCNUM restore_neutron = mccGap1_end_Lam_restore_neutron;
int nowritefile = mccGap1_end_Lam_nowritefile;
#line 84 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 46881 "./SNS_BASIS.c"
}   /* End of Gap1_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap1_end_Lam:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(13,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap1_end [14] */
  mccoordschange(mcposrGap1_end, mcrotrGap1_end,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap1_end (without coords transformations) */
  mcJumpTrace_Gap1_end:
  SIG_MESSAGE("Gap1_end (Trace)");
  mcDEBUG_COMP("Gap1_end")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap1_end
  STORE_NEUTRON(14,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[14]++;
  mcPCounter[14] += p;
  mcP2Counter[14] += p*p;
#define mccompcurname  Gap1_end
#define mccompcurtype  Arm
#define mccompcurindex 14
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap1_end:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(14,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Shutter_Guide_Insert [15] */
  mccoordschange(mcposrShutter_Guide_Insert, mcrotrShutter_Guide_Insert,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Shutter_Guide_Insert (without coords transformations) */
  mcJumpTrace_Shutter_Guide_Insert:
  SIG_MESSAGE("Shutter_Guide_Insert (Trace)");
  mcDEBUG_COMP("Shutter_Guide_Insert")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompShutter_Guide_Insert
  STORE_NEUTRON(15,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[15]++;
  mcPCounter[15] += p;
  mcP2Counter[15] += p*p;
#define mccompcurname  Shutter_Guide_Insert
#define mccompcurtype  Guide_gravity
#define mccompcurindex 15
#define GVars mccShutter_Guide_Insert_GVars
#define pTable mccShutter_Guide_Insert_pTable
{   /* Declarations of Shutter_Guide_Insert=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_w1;
MCNUM h1 = mccShutter_Guide_Insert_h1;
MCNUM w2 = mccShutter_Guide_Insert_w2;
MCNUM h2 = mccShutter_Guide_Insert_h2;
MCNUM l = mccShutter_Guide_Insert_l;
MCNUM R0 = mccShutter_Guide_Insert_R0;
MCNUM Qc = mccShutter_Guide_Insert_Qc;
MCNUM alpha = mccShutter_Guide_Insert_alpha;
MCNUM m = mccShutter_Guide_Insert_m;
MCNUM W = mccShutter_Guide_Insert_W;
MCNUM nslit = mccShutter_Guide_Insert_nslit;
MCNUM d = mccShutter_Guide_Insert_d;
MCNUM mleft = mccShutter_Guide_Insert_mleft;
MCNUM mright = mccShutter_Guide_Insert_mright;
MCNUM mtop = mccShutter_Guide_Insert_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_nhslit;
MCNUM G = mccShutter_Guide_Insert_G;
MCNUM aleft = mccShutter_Guide_Insert_aleft;
MCNUM aright = mccShutter_Guide_Insert_aright;
MCNUM atop = mccShutter_Guide_Insert_atop;
MCNUM abottom = mccShutter_Guide_Insert_abottom;
MCNUM wavy = mccShutter_Guide_Insert_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_nelements;
MCNUM nu = mccShutter_Guide_Insert_nu;
MCNUM phase = mccShutter_Guide_Insert_phase;
char* reflect = mccShutter_Guide_Insert_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 47299 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompShutter_Guide_Insert:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(15,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Shutter_Guide_Insert_16 [16] */
  mccoordschange(mcposrShutter_Guide_Insert_16, mcrotrShutter_Guide_Insert_16,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Shutter_Guide_Insert_16 (without coords transformations) */
  mcJumpTrace_Shutter_Guide_Insert_16:
  SIG_MESSAGE("Shutter_Guide_Insert_16 (Trace)");
  mcDEBUG_COMP("Shutter_Guide_Insert_16")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompShutter_Guide_Insert_16
  STORE_NEUTRON(16,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[16]++;
  mcPCounter[16] += p;
  mcP2Counter[16] += p*p;
#define mccompcurname  Shutter_Guide_Insert_16
#define mccompcurtype  Guide_gravity
#define mccompcurindex 16
#define GVars mccShutter_Guide_Insert_16_GVars
#define pTable mccShutter_Guide_Insert_16_pTable
{   /* Declarations of Shutter_Guide_Insert_16=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_16_w1;
MCNUM h1 = mccShutter_Guide_Insert_16_h1;
MCNUM w2 = mccShutter_Guide_Insert_16_w2;
MCNUM h2 = mccShutter_Guide_Insert_16_h2;
MCNUM l = mccShutter_Guide_Insert_16_l;
MCNUM R0 = mccShutter_Guide_Insert_16_R0;
MCNUM Qc = mccShutter_Guide_Insert_16_Qc;
MCNUM alpha = mccShutter_Guide_Insert_16_alpha;
MCNUM m = mccShutter_Guide_Insert_16_m;
MCNUM W = mccShutter_Guide_Insert_16_W;
MCNUM nslit = mccShutter_Guide_Insert_16_nslit;
MCNUM d = mccShutter_Guide_Insert_16_d;
MCNUM mleft = mccShutter_Guide_Insert_16_mleft;
MCNUM mright = mccShutter_Guide_Insert_16_mright;
MCNUM mtop = mccShutter_Guide_Insert_16_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_16_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_16_nhslit;
MCNUM G = mccShutter_Guide_Insert_16_G;
MCNUM aleft = mccShutter_Guide_Insert_16_aleft;
MCNUM aright = mccShutter_Guide_Insert_16_aright;
MCNUM atop = mccShutter_Guide_Insert_16_atop;
MCNUM abottom = mccShutter_Guide_Insert_16_abottom;
MCNUM wavy = mccShutter_Guide_Insert_16_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_16_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_16_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_16_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_16_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_16_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_16_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_16_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_16_nelements;
MCNUM nu = mccShutter_Guide_Insert_16_nu;
MCNUM phase = mccShutter_Guide_Insert_16_phase;
char* reflect = mccShutter_Guide_Insert_16_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 47612 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert_16=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompShutter_Guide_Insert_16:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(16,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Shutter_Guide_Insert_17 [17] */
  mccoordschange(mcposrShutter_Guide_Insert_17, mcrotrShutter_Guide_Insert_17,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Shutter_Guide_Insert_17 (without coords transformations) */
  mcJumpTrace_Shutter_Guide_Insert_17:
  SIG_MESSAGE("Shutter_Guide_Insert_17 (Trace)");
  mcDEBUG_COMP("Shutter_Guide_Insert_17")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompShutter_Guide_Insert_17
  STORE_NEUTRON(17,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[17]++;
  mcPCounter[17] += p;
  mcP2Counter[17] += p*p;
#define mccompcurname  Shutter_Guide_Insert_17
#define mccompcurtype  Guide_gravity
#define mccompcurindex 17
#define GVars mccShutter_Guide_Insert_17_GVars
#define pTable mccShutter_Guide_Insert_17_pTable
{   /* Declarations of Shutter_Guide_Insert_17=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_17_w1;
MCNUM h1 = mccShutter_Guide_Insert_17_h1;
MCNUM w2 = mccShutter_Guide_Insert_17_w2;
MCNUM h2 = mccShutter_Guide_Insert_17_h2;
MCNUM l = mccShutter_Guide_Insert_17_l;
MCNUM R0 = mccShutter_Guide_Insert_17_R0;
MCNUM Qc = mccShutter_Guide_Insert_17_Qc;
MCNUM alpha = mccShutter_Guide_Insert_17_alpha;
MCNUM m = mccShutter_Guide_Insert_17_m;
MCNUM W = mccShutter_Guide_Insert_17_W;
MCNUM nslit = mccShutter_Guide_Insert_17_nslit;
MCNUM d = mccShutter_Guide_Insert_17_d;
MCNUM mleft = mccShutter_Guide_Insert_17_mleft;
MCNUM mright = mccShutter_Guide_Insert_17_mright;
MCNUM mtop = mccShutter_Guide_Insert_17_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_17_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_17_nhslit;
MCNUM G = mccShutter_Guide_Insert_17_G;
MCNUM aleft = mccShutter_Guide_Insert_17_aleft;
MCNUM aright = mccShutter_Guide_Insert_17_aright;
MCNUM atop = mccShutter_Guide_Insert_17_atop;
MCNUM abottom = mccShutter_Guide_Insert_17_abottom;
MCNUM wavy = mccShutter_Guide_Insert_17_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_17_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_17_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_17_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_17_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_17_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_17_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_17_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_17_nelements;
MCNUM nu = mccShutter_Guide_Insert_17_nu;
MCNUM phase = mccShutter_Guide_Insert_17_phase;
char* reflect = mccShutter_Guide_Insert_17_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 47925 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert_17=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompShutter_Guide_Insert_17:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(17,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Shutter_Guide_Insert_18 [18] */
  mccoordschange(mcposrShutter_Guide_Insert_18, mcrotrShutter_Guide_Insert_18,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Shutter_Guide_Insert_18 (without coords transformations) */
  mcJumpTrace_Shutter_Guide_Insert_18:
  SIG_MESSAGE("Shutter_Guide_Insert_18 (Trace)");
  mcDEBUG_COMP("Shutter_Guide_Insert_18")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompShutter_Guide_Insert_18
  STORE_NEUTRON(18,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[18]++;
  mcPCounter[18] += p;
  mcP2Counter[18] += p*p;
#define mccompcurname  Shutter_Guide_Insert_18
#define mccompcurtype  Guide_gravity
#define mccompcurindex 18
#define GVars mccShutter_Guide_Insert_18_GVars
#define pTable mccShutter_Guide_Insert_18_pTable
{   /* Declarations of Shutter_Guide_Insert_18=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_18_w1;
MCNUM h1 = mccShutter_Guide_Insert_18_h1;
MCNUM w2 = mccShutter_Guide_Insert_18_w2;
MCNUM h2 = mccShutter_Guide_Insert_18_h2;
MCNUM l = mccShutter_Guide_Insert_18_l;
MCNUM R0 = mccShutter_Guide_Insert_18_R0;
MCNUM Qc = mccShutter_Guide_Insert_18_Qc;
MCNUM alpha = mccShutter_Guide_Insert_18_alpha;
MCNUM m = mccShutter_Guide_Insert_18_m;
MCNUM W = mccShutter_Guide_Insert_18_W;
MCNUM nslit = mccShutter_Guide_Insert_18_nslit;
MCNUM d = mccShutter_Guide_Insert_18_d;
MCNUM mleft = mccShutter_Guide_Insert_18_mleft;
MCNUM mright = mccShutter_Guide_Insert_18_mright;
MCNUM mtop = mccShutter_Guide_Insert_18_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_18_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_18_nhslit;
MCNUM G = mccShutter_Guide_Insert_18_G;
MCNUM aleft = mccShutter_Guide_Insert_18_aleft;
MCNUM aright = mccShutter_Guide_Insert_18_aright;
MCNUM atop = mccShutter_Guide_Insert_18_atop;
MCNUM abottom = mccShutter_Guide_Insert_18_abottom;
MCNUM wavy = mccShutter_Guide_Insert_18_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_18_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_18_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_18_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_18_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_18_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_18_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_18_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_18_nelements;
MCNUM nu = mccShutter_Guide_Insert_18_nu;
MCNUM phase = mccShutter_Guide_Insert_18_phase;
char* reflect = mccShutter_Guide_Insert_18_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 48238 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert_18=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompShutter_Guide_Insert_18:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(18,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Shutter_Guide_Insert_19 [19] */
  mccoordschange(mcposrShutter_Guide_Insert_19, mcrotrShutter_Guide_Insert_19,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Shutter_Guide_Insert_19 (without coords transformations) */
  mcJumpTrace_Shutter_Guide_Insert_19:
  SIG_MESSAGE("Shutter_Guide_Insert_19 (Trace)");
  mcDEBUG_COMP("Shutter_Guide_Insert_19")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompShutter_Guide_Insert_19
  STORE_NEUTRON(19,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[19]++;
  mcPCounter[19] += p;
  mcP2Counter[19] += p*p;
#define mccompcurname  Shutter_Guide_Insert_19
#define mccompcurtype  Guide_gravity
#define mccompcurindex 19
#define GVars mccShutter_Guide_Insert_19_GVars
#define pTable mccShutter_Guide_Insert_19_pTable
{   /* Declarations of Shutter_Guide_Insert_19=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_19_w1;
MCNUM h1 = mccShutter_Guide_Insert_19_h1;
MCNUM w2 = mccShutter_Guide_Insert_19_w2;
MCNUM h2 = mccShutter_Guide_Insert_19_h2;
MCNUM l = mccShutter_Guide_Insert_19_l;
MCNUM R0 = mccShutter_Guide_Insert_19_R0;
MCNUM Qc = mccShutter_Guide_Insert_19_Qc;
MCNUM alpha = mccShutter_Guide_Insert_19_alpha;
MCNUM m = mccShutter_Guide_Insert_19_m;
MCNUM W = mccShutter_Guide_Insert_19_W;
MCNUM nslit = mccShutter_Guide_Insert_19_nslit;
MCNUM d = mccShutter_Guide_Insert_19_d;
MCNUM mleft = mccShutter_Guide_Insert_19_mleft;
MCNUM mright = mccShutter_Guide_Insert_19_mright;
MCNUM mtop = mccShutter_Guide_Insert_19_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_19_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_19_nhslit;
MCNUM G = mccShutter_Guide_Insert_19_G;
MCNUM aleft = mccShutter_Guide_Insert_19_aleft;
MCNUM aright = mccShutter_Guide_Insert_19_aright;
MCNUM atop = mccShutter_Guide_Insert_19_atop;
MCNUM abottom = mccShutter_Guide_Insert_19_abottom;
MCNUM wavy = mccShutter_Guide_Insert_19_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_19_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_19_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_19_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_19_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_19_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_19_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_19_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_19_nelements;
MCNUM nu = mccShutter_Guide_Insert_19_nu;
MCNUM phase = mccShutter_Guide_Insert_19_phase;
char* reflect = mccShutter_Guide_Insert_19_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 48551 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert_19=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompShutter_Guide_Insert_19:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(19,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Shutter_Guide_Insert_20 [20] */
  mccoordschange(mcposrShutter_Guide_Insert_20, mcrotrShutter_Guide_Insert_20,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Shutter_Guide_Insert_20 (without coords transformations) */
  mcJumpTrace_Shutter_Guide_Insert_20:
  SIG_MESSAGE("Shutter_Guide_Insert_20 (Trace)");
  mcDEBUG_COMP("Shutter_Guide_Insert_20")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompShutter_Guide_Insert_20
  STORE_NEUTRON(20,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[20]++;
  mcPCounter[20] += p;
  mcP2Counter[20] += p*p;
#define mccompcurname  Shutter_Guide_Insert_20
#define mccompcurtype  Guide_gravity
#define mccompcurindex 20
#define GVars mccShutter_Guide_Insert_20_GVars
#define pTable mccShutter_Guide_Insert_20_pTable
{   /* Declarations of Shutter_Guide_Insert_20=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_20_w1;
MCNUM h1 = mccShutter_Guide_Insert_20_h1;
MCNUM w2 = mccShutter_Guide_Insert_20_w2;
MCNUM h2 = mccShutter_Guide_Insert_20_h2;
MCNUM l = mccShutter_Guide_Insert_20_l;
MCNUM R0 = mccShutter_Guide_Insert_20_R0;
MCNUM Qc = mccShutter_Guide_Insert_20_Qc;
MCNUM alpha = mccShutter_Guide_Insert_20_alpha;
MCNUM m = mccShutter_Guide_Insert_20_m;
MCNUM W = mccShutter_Guide_Insert_20_W;
MCNUM nslit = mccShutter_Guide_Insert_20_nslit;
MCNUM d = mccShutter_Guide_Insert_20_d;
MCNUM mleft = mccShutter_Guide_Insert_20_mleft;
MCNUM mright = mccShutter_Guide_Insert_20_mright;
MCNUM mtop = mccShutter_Guide_Insert_20_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_20_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_20_nhslit;
MCNUM G = mccShutter_Guide_Insert_20_G;
MCNUM aleft = mccShutter_Guide_Insert_20_aleft;
MCNUM aright = mccShutter_Guide_Insert_20_aright;
MCNUM atop = mccShutter_Guide_Insert_20_atop;
MCNUM abottom = mccShutter_Guide_Insert_20_abottom;
MCNUM wavy = mccShutter_Guide_Insert_20_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_20_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_20_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_20_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_20_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_20_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_20_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_20_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_20_nelements;
MCNUM nu = mccShutter_Guide_Insert_20_nu;
MCNUM phase = mccShutter_Guide_Insert_20_phase;
char* reflect = mccShutter_Guide_Insert_20_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 48864 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert_20=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompShutter_Guide_Insert_20:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(20,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Shutter_Guide_Insert_21 [21] */
  mccoordschange(mcposrShutter_Guide_Insert_21, mcrotrShutter_Guide_Insert_21,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Shutter_Guide_Insert_21 (without coords transformations) */
  mcJumpTrace_Shutter_Guide_Insert_21:
  SIG_MESSAGE("Shutter_Guide_Insert_21 (Trace)");
  mcDEBUG_COMP("Shutter_Guide_Insert_21")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompShutter_Guide_Insert_21
  STORE_NEUTRON(21,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[21]++;
  mcPCounter[21] += p;
  mcP2Counter[21] += p*p;
#define mccompcurname  Shutter_Guide_Insert_21
#define mccompcurtype  Guide_gravity
#define mccompcurindex 21
#define GVars mccShutter_Guide_Insert_21_GVars
#define pTable mccShutter_Guide_Insert_21_pTable
{   /* Declarations of Shutter_Guide_Insert_21=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_21_w1;
MCNUM h1 = mccShutter_Guide_Insert_21_h1;
MCNUM w2 = mccShutter_Guide_Insert_21_w2;
MCNUM h2 = mccShutter_Guide_Insert_21_h2;
MCNUM l = mccShutter_Guide_Insert_21_l;
MCNUM R0 = mccShutter_Guide_Insert_21_R0;
MCNUM Qc = mccShutter_Guide_Insert_21_Qc;
MCNUM alpha = mccShutter_Guide_Insert_21_alpha;
MCNUM m = mccShutter_Guide_Insert_21_m;
MCNUM W = mccShutter_Guide_Insert_21_W;
MCNUM nslit = mccShutter_Guide_Insert_21_nslit;
MCNUM d = mccShutter_Guide_Insert_21_d;
MCNUM mleft = mccShutter_Guide_Insert_21_mleft;
MCNUM mright = mccShutter_Guide_Insert_21_mright;
MCNUM mtop = mccShutter_Guide_Insert_21_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_21_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_21_nhslit;
MCNUM G = mccShutter_Guide_Insert_21_G;
MCNUM aleft = mccShutter_Guide_Insert_21_aleft;
MCNUM aright = mccShutter_Guide_Insert_21_aright;
MCNUM atop = mccShutter_Guide_Insert_21_atop;
MCNUM abottom = mccShutter_Guide_Insert_21_abottom;
MCNUM wavy = mccShutter_Guide_Insert_21_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_21_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_21_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_21_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_21_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_21_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_21_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_21_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_21_nelements;
MCNUM nu = mccShutter_Guide_Insert_21_nu;
MCNUM phase = mccShutter_Guide_Insert_21_phase;
char* reflect = mccShutter_Guide_Insert_21_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 49177 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert_21=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompShutter_Guide_Insert_21:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(21,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Shutter_Guide_Insert_short [22] */
  mccoordschange(mcposrShutter_Guide_Insert_short, mcrotrShutter_Guide_Insert_short,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Shutter_Guide_Insert_short (without coords transformations) */
  mcJumpTrace_Shutter_Guide_Insert_short:
  SIG_MESSAGE("Shutter_Guide_Insert_short (Trace)");
  mcDEBUG_COMP("Shutter_Guide_Insert_short")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompShutter_Guide_Insert_short
  STORE_NEUTRON(22,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[22]++;
  mcPCounter[22] += p;
  mcP2Counter[22] += p*p;
#define mccompcurname  Shutter_Guide_Insert_short
#define mccompcurtype  Guide_gravity
#define mccompcurindex 22
#define GVars mccShutter_Guide_Insert_short_GVars
#define pTable mccShutter_Guide_Insert_short_pTable
{   /* Declarations of Shutter_Guide_Insert_short=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_short_w1;
MCNUM h1 = mccShutter_Guide_Insert_short_h1;
MCNUM w2 = mccShutter_Guide_Insert_short_w2;
MCNUM h2 = mccShutter_Guide_Insert_short_h2;
MCNUM l = mccShutter_Guide_Insert_short_l;
MCNUM R0 = mccShutter_Guide_Insert_short_R0;
MCNUM Qc = mccShutter_Guide_Insert_short_Qc;
MCNUM alpha = mccShutter_Guide_Insert_short_alpha;
MCNUM m = mccShutter_Guide_Insert_short_m;
MCNUM W = mccShutter_Guide_Insert_short_W;
MCNUM nslit = mccShutter_Guide_Insert_short_nslit;
MCNUM d = mccShutter_Guide_Insert_short_d;
MCNUM mleft = mccShutter_Guide_Insert_short_mleft;
MCNUM mright = mccShutter_Guide_Insert_short_mright;
MCNUM mtop = mccShutter_Guide_Insert_short_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_short_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_short_nhslit;
MCNUM G = mccShutter_Guide_Insert_short_G;
MCNUM aleft = mccShutter_Guide_Insert_short_aleft;
MCNUM aright = mccShutter_Guide_Insert_short_aright;
MCNUM atop = mccShutter_Guide_Insert_short_atop;
MCNUM abottom = mccShutter_Guide_Insert_short_abottom;
MCNUM wavy = mccShutter_Guide_Insert_short_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_short_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_short_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_short_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_short_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_short_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_short_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_short_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_short_nelements;
MCNUM nu = mccShutter_Guide_Insert_short_nu;
MCNUM phase = mccShutter_Guide_Insert_short_phase;
char* reflect = mccShutter_Guide_Insert_short_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 49490 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert_short=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompShutter_Guide_Insert_short:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(22,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap2_start [23] */
  mccoordschange(mcposrGap2_start, mcrotrGap2_start,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap2_start (without coords transformations) */
  mcJumpTrace_Gap2_start:
  SIG_MESSAGE("Gap2_start (Trace)");
  mcDEBUG_COMP("Gap2_start")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap2_start
  STORE_NEUTRON(23,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[23]++;
  mcPCounter[23] += p;
  mcP2Counter[23] += p*p;
#define mccompcurname  Gap2_start
#define mccompcurtype  Arm
#define mccompcurindex 23
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap2_start:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(23,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap2_start_Lam [24] */
  mccoordschange(mcposrGap2_start_Lam, mcrotrGap2_start_Lam,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap2_start_Lam (without coords transformations) */
  mcJumpTrace_Gap2_start_Lam:
  SIG_MESSAGE("Gap2_start_Lam (Trace)");
  mcDEBUG_COMP("Gap2_start_Lam")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap2_start_Lam
  STORE_NEUTRON(24,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[24]++;
  mcPCounter[24] += p;
  mcP2Counter[24] += p*p;
#define mccompcurname  Gap2_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 24
#define nL mccGap2_start_Lam_nL
#define L_N mccGap2_start_Lam_L_N
#define L_p mccGap2_start_Lam_L_p
#define L_p2 mccGap2_start_Lam_L_p2
{   /* Declarations of Gap2_start_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap2_start_Lam_filename;
MCNUM xmin = mccGap2_start_Lam_xmin;
MCNUM xmax = mccGap2_start_Lam_xmax;
MCNUM ymin = mccGap2_start_Lam_ymin;
MCNUM ymax = mccGap2_start_Lam_ymax;
MCNUM xwidth = mccGap2_start_Lam_xwidth;
MCNUM yheight = mccGap2_start_Lam_yheight;
MCNUM Lmin = mccGap2_start_Lam_Lmin;
MCNUM Lmax = mccGap2_start_Lam_Lmax;
MCNUM restore_neutron = mccGap2_start_Lam_restore_neutron;
int nowritefile = mccGap2_start_Lam_nowritefile;
#line 84 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 49738 "./SNS_BASIS.c"
}   /* End of Gap2_start_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap2_start_Lam:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(24,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap2_start_PSD [25] */
  mccoordschange(mcposrGap2_start_PSD, mcrotrGap2_start_PSD,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap2_start_PSD (without coords transformations) */
  mcJumpTrace_Gap2_start_PSD:
  SIG_MESSAGE("Gap2_start_PSD (Trace)");
  mcDEBUG_COMP("Gap2_start_PSD")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap2_start_PSD
  STORE_NEUTRON(25,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[25]++;
  mcPCounter[25] += p;
  mcP2Counter[25] += p*p;
#define mccompcurname  Gap2_start_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 25
#define PSD_N mccGap2_start_PSD_PSD_N
#define PSD_p mccGap2_start_PSD_PSD_p
#define PSD_p2 mccGap2_start_PSD_PSD_p2
{   /* Declarations of Gap2_start_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap2_start_PSD_nx;
int ny = mccGap2_start_PSD_ny;
char* filename = mccGap2_start_PSD_filename;
MCNUM xmin = mccGap2_start_PSD_xmin;
MCNUM xmax = mccGap2_start_PSD_xmax;
MCNUM ymin = mccGap2_start_PSD_ymin;
MCNUM ymax = mccGap2_start_PSD_ymax;
MCNUM xwidth = mccGap2_start_PSD_xwidth;
MCNUM yheight = mccGap2_start_PSD_yheight;
MCNUM restore_neutron = mccGap2_start_PSD_restore_neutron;
#line 94 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  PROP_Z0;
  if (x>xmin && x<xmax && y>ymin && y<ymax){
    int i = floor((x - xmin)*nx/(xmax - xmin));
    int j = floor((y - ymin)*ny/(ymax - ymin));
    PSD_N[i][j]++;
    PSD_p[i][j] += p;
    PSD_p2[i][j] += p*p;
    SCATTER;
  }
  if (restore_neutron) {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 49876 "./SNS_BASIS.c"
}   /* End of Gap2_start_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap2_start_PSD:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(25,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap2_end_Lam [26] */
  mccoordschange(mcposrGap2_end_Lam, mcrotrGap2_end_Lam,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap2_end_Lam (without coords transformations) */
  mcJumpTrace_Gap2_end_Lam:
  SIG_MESSAGE("Gap2_end_Lam (Trace)");
  mcDEBUG_COMP("Gap2_end_Lam")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap2_end_Lam
  STORE_NEUTRON(26,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[26]++;
  mcPCounter[26] += p;
  mcP2Counter[26] += p*p;
#define mccompcurname  Gap2_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 26
#define nL mccGap2_end_Lam_nL
#define L_N mccGap2_end_Lam_L_N
#define L_p mccGap2_end_Lam_L_p
#define L_p2 mccGap2_end_Lam_L_p2
{   /* Declarations of Gap2_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap2_end_Lam_filename;
MCNUM xmin = mccGap2_end_Lam_xmin;
MCNUM xmax = mccGap2_end_Lam_xmax;
MCNUM ymin = mccGap2_end_Lam_ymin;
MCNUM ymax = mccGap2_end_Lam_ymax;
MCNUM xwidth = mccGap2_end_Lam_xwidth;
MCNUM yheight = mccGap2_end_Lam_yheight;
MCNUM Lmin = mccGap2_end_Lam_Lmin;
MCNUM Lmax = mccGap2_end_Lam_Lmax;
MCNUM restore_neutron = mccGap2_end_Lam_restore_neutron;
int nowritefile = mccGap2_end_Lam_nowritefile;
#line 84 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 50022 "./SNS_BASIS.c"
}   /* End of Gap2_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap2_end_Lam:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(26,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap2_end_PSD [27] */
  mccoordschange(mcposrGap2_end_PSD, mcrotrGap2_end_PSD,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap2_end_PSD (without coords transformations) */
  mcJumpTrace_Gap2_end_PSD:
  SIG_MESSAGE("Gap2_end_PSD (Trace)");
  mcDEBUG_COMP("Gap2_end_PSD")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap2_end_PSD
  STORE_NEUTRON(27,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[27]++;
  mcPCounter[27] += p;
  mcP2Counter[27] += p*p;
#define mccompcurname  Gap2_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 27
#define PSD_N mccGap2_end_PSD_PSD_N
#define PSD_p mccGap2_end_PSD_PSD_p
#define PSD_p2 mccGap2_end_PSD_PSD_p2
{   /* Declarations of Gap2_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap2_end_PSD_nx;
int ny = mccGap2_end_PSD_ny;
char* filename = mccGap2_end_PSD_filename;
MCNUM xmin = mccGap2_end_PSD_xmin;
MCNUM xmax = mccGap2_end_PSD_xmax;
MCNUM ymin = mccGap2_end_PSD_ymin;
MCNUM ymax = mccGap2_end_PSD_ymax;
MCNUM xwidth = mccGap2_end_PSD_xwidth;
MCNUM yheight = mccGap2_end_PSD_yheight;
MCNUM restore_neutron = mccGap2_end_PSD_restore_neutron;
#line 94 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  PROP_Z0;
  if (x>xmin && x<xmax && y>ymin && y<ymax){
    int i = floor((x - xmin)*nx/(xmax - xmin));
    int j = floor((y - ymin)*ny/(ymax - ymin));
    PSD_N[i][j]++;
    PSD_p[i][j] += p;
    PSD_p2[i][j] += p*p;
    SCATTER;
  }
  if (restore_neutron) {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 50160 "./SNS_BASIS.c"
}   /* End of Gap2_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap2_end_PSD:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(27,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap2_end [28] */
  mccoordschange(mcposrGap2_end, mcrotrGap2_end,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap2_end (without coords transformations) */
  mcJumpTrace_Gap2_end:
  SIG_MESSAGE("Gap2_end (Trace)");
  mcDEBUG_COMP("Gap2_end")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap2_end
  STORE_NEUTRON(28,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[28]++;
  mcPCounter[28] += p;
  mcP2Counter[28] += p*p;
#define mccompcurname  Gap2_end
#define mccompcurtype  Arm
#define mccompcurindex 28
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap2_end:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(28,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_I [29] */
  mccoordschange(mcposrCurved_Guide_Section_I, mcrotrCurved_Guide_Section_I,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_I (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_I:
  SIG_MESSAGE("Curved_Guide_Section_I (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_I")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_I
  STORE_NEUTRON(29,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[29]++;
  mcPCounter[29] += p;
  mcP2Counter[29] += p*p;
#define mccompcurname  Curved_Guide_Section_I
#define mccompcurtype  Guide_gravity
#define mccompcurindex 29
#define GVars mccCurved_Guide_Section_I_GVars
#define pTable mccCurved_Guide_Section_I_pTable
{   /* Declarations of Curved_Guide_Section_I=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_w1;
MCNUM h1 = mccCurved_Guide_Section_I_h1;
MCNUM w2 = mccCurved_Guide_Section_I_w2;
MCNUM h2 = mccCurved_Guide_Section_I_h2;
MCNUM l = mccCurved_Guide_Section_I_l;
MCNUM R0 = mccCurved_Guide_Section_I_R0;
MCNUM Qc = mccCurved_Guide_Section_I_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_alpha;
MCNUM m = mccCurved_Guide_Section_I_m;
MCNUM W = mccCurved_Guide_Section_I_W;
MCNUM nslit = mccCurved_Guide_Section_I_nslit;
MCNUM d = mccCurved_Guide_Section_I_d;
MCNUM mleft = mccCurved_Guide_Section_I_mleft;
MCNUM mright = mccCurved_Guide_Section_I_mright;
MCNUM mtop = mccCurved_Guide_Section_I_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_nhslit;
MCNUM G = mccCurved_Guide_Section_I_G;
MCNUM aleft = mccCurved_Guide_Section_I_aleft;
MCNUM aright = mccCurved_Guide_Section_I_aright;
MCNUM atop = mccCurved_Guide_Section_I_atop;
MCNUM abottom = mccCurved_Guide_Section_I_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_nelements;
MCNUM nu = mccCurved_Guide_Section_I_nu;
MCNUM phase = mccCurved_Guide_Section_I_phase;
char* reflect = mccCurved_Guide_Section_I_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 50577 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_I:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(29,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_I_30 [30] */
  mccoordschange(mcposrCurved_Guide_Section_I_30, mcrotrCurved_Guide_Section_I_30,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_I_30 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_I_30:
  SIG_MESSAGE("Curved_Guide_Section_I_30 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_I_30")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_I_30
  STORE_NEUTRON(30,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[30]++;
  mcPCounter[30] += p;
  mcP2Counter[30] += p*p;
#define mccompcurname  Curved_Guide_Section_I_30
#define mccompcurtype  Guide_gravity
#define mccompcurindex 30
#define GVars mccCurved_Guide_Section_I_30_GVars
#define pTable mccCurved_Guide_Section_I_30_pTable
{   /* Declarations of Curved_Guide_Section_I_30=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_30_w1;
MCNUM h1 = mccCurved_Guide_Section_I_30_h1;
MCNUM w2 = mccCurved_Guide_Section_I_30_w2;
MCNUM h2 = mccCurved_Guide_Section_I_30_h2;
MCNUM l = mccCurved_Guide_Section_I_30_l;
MCNUM R0 = mccCurved_Guide_Section_I_30_R0;
MCNUM Qc = mccCurved_Guide_Section_I_30_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_30_alpha;
MCNUM m = mccCurved_Guide_Section_I_30_m;
MCNUM W = mccCurved_Guide_Section_I_30_W;
MCNUM nslit = mccCurved_Guide_Section_I_30_nslit;
MCNUM d = mccCurved_Guide_Section_I_30_d;
MCNUM mleft = mccCurved_Guide_Section_I_30_mleft;
MCNUM mright = mccCurved_Guide_Section_I_30_mright;
MCNUM mtop = mccCurved_Guide_Section_I_30_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_30_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_30_nhslit;
MCNUM G = mccCurved_Guide_Section_I_30_G;
MCNUM aleft = mccCurved_Guide_Section_I_30_aleft;
MCNUM aright = mccCurved_Guide_Section_I_30_aright;
MCNUM atop = mccCurved_Guide_Section_I_30_atop;
MCNUM abottom = mccCurved_Guide_Section_I_30_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_30_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_30_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_30_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_30_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_30_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_30_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_30_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_30_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_30_nelements;
MCNUM nu = mccCurved_Guide_Section_I_30_nu;
MCNUM phase = mccCurved_Guide_Section_I_30_phase;
char* reflect = mccCurved_Guide_Section_I_30_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 50890 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_30=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_I_30:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(30,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_I_31 [31] */
  mccoordschange(mcposrCurved_Guide_Section_I_31, mcrotrCurved_Guide_Section_I_31,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_I_31 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_I_31:
  SIG_MESSAGE("Curved_Guide_Section_I_31 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_I_31")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_I_31
  STORE_NEUTRON(31,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[31]++;
  mcPCounter[31] += p;
  mcP2Counter[31] += p*p;
#define mccompcurname  Curved_Guide_Section_I_31
#define mccompcurtype  Guide_gravity
#define mccompcurindex 31
#define GVars mccCurved_Guide_Section_I_31_GVars
#define pTable mccCurved_Guide_Section_I_31_pTable
{   /* Declarations of Curved_Guide_Section_I_31=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_31_w1;
MCNUM h1 = mccCurved_Guide_Section_I_31_h1;
MCNUM w2 = mccCurved_Guide_Section_I_31_w2;
MCNUM h2 = mccCurved_Guide_Section_I_31_h2;
MCNUM l = mccCurved_Guide_Section_I_31_l;
MCNUM R0 = mccCurved_Guide_Section_I_31_R0;
MCNUM Qc = mccCurved_Guide_Section_I_31_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_31_alpha;
MCNUM m = mccCurved_Guide_Section_I_31_m;
MCNUM W = mccCurved_Guide_Section_I_31_W;
MCNUM nslit = mccCurved_Guide_Section_I_31_nslit;
MCNUM d = mccCurved_Guide_Section_I_31_d;
MCNUM mleft = mccCurved_Guide_Section_I_31_mleft;
MCNUM mright = mccCurved_Guide_Section_I_31_mright;
MCNUM mtop = mccCurved_Guide_Section_I_31_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_31_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_31_nhslit;
MCNUM G = mccCurved_Guide_Section_I_31_G;
MCNUM aleft = mccCurved_Guide_Section_I_31_aleft;
MCNUM aright = mccCurved_Guide_Section_I_31_aright;
MCNUM atop = mccCurved_Guide_Section_I_31_atop;
MCNUM abottom = mccCurved_Guide_Section_I_31_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_31_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_31_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_31_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_31_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_31_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_31_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_31_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_31_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_31_nelements;
MCNUM nu = mccCurved_Guide_Section_I_31_nu;
MCNUM phase = mccCurved_Guide_Section_I_31_phase;
char* reflect = mccCurved_Guide_Section_I_31_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 51203 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_31=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_I_31:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(31,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_I_32 [32] */
  mccoordschange(mcposrCurved_Guide_Section_I_32, mcrotrCurved_Guide_Section_I_32,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_I_32 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_I_32:
  SIG_MESSAGE("Curved_Guide_Section_I_32 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_I_32")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_I_32
  STORE_NEUTRON(32,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[32]++;
  mcPCounter[32] += p;
  mcP2Counter[32] += p*p;
#define mccompcurname  Curved_Guide_Section_I_32
#define mccompcurtype  Guide_gravity
#define mccompcurindex 32
#define GVars mccCurved_Guide_Section_I_32_GVars
#define pTable mccCurved_Guide_Section_I_32_pTable
{   /* Declarations of Curved_Guide_Section_I_32=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_32_w1;
MCNUM h1 = mccCurved_Guide_Section_I_32_h1;
MCNUM w2 = mccCurved_Guide_Section_I_32_w2;
MCNUM h2 = mccCurved_Guide_Section_I_32_h2;
MCNUM l = mccCurved_Guide_Section_I_32_l;
MCNUM R0 = mccCurved_Guide_Section_I_32_R0;
MCNUM Qc = mccCurved_Guide_Section_I_32_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_32_alpha;
MCNUM m = mccCurved_Guide_Section_I_32_m;
MCNUM W = mccCurved_Guide_Section_I_32_W;
MCNUM nslit = mccCurved_Guide_Section_I_32_nslit;
MCNUM d = mccCurved_Guide_Section_I_32_d;
MCNUM mleft = mccCurved_Guide_Section_I_32_mleft;
MCNUM mright = mccCurved_Guide_Section_I_32_mright;
MCNUM mtop = mccCurved_Guide_Section_I_32_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_32_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_32_nhslit;
MCNUM G = mccCurved_Guide_Section_I_32_G;
MCNUM aleft = mccCurved_Guide_Section_I_32_aleft;
MCNUM aright = mccCurved_Guide_Section_I_32_aright;
MCNUM atop = mccCurved_Guide_Section_I_32_atop;
MCNUM abottom = mccCurved_Guide_Section_I_32_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_32_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_32_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_32_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_32_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_32_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_32_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_32_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_32_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_32_nelements;
MCNUM nu = mccCurved_Guide_Section_I_32_nu;
MCNUM phase = mccCurved_Guide_Section_I_32_phase;
char* reflect = mccCurved_Guide_Section_I_32_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 51516 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_32=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_I_32:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(32,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_I_33 [33] */
  mccoordschange(mcposrCurved_Guide_Section_I_33, mcrotrCurved_Guide_Section_I_33,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_I_33 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_I_33:
  SIG_MESSAGE("Curved_Guide_Section_I_33 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_I_33")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_I_33
  STORE_NEUTRON(33,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[33]++;
  mcPCounter[33] += p;
  mcP2Counter[33] += p*p;
#define mccompcurname  Curved_Guide_Section_I_33
#define mccompcurtype  Guide_gravity
#define mccompcurindex 33
#define GVars mccCurved_Guide_Section_I_33_GVars
#define pTable mccCurved_Guide_Section_I_33_pTable
{   /* Declarations of Curved_Guide_Section_I_33=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_33_w1;
MCNUM h1 = mccCurved_Guide_Section_I_33_h1;
MCNUM w2 = mccCurved_Guide_Section_I_33_w2;
MCNUM h2 = mccCurved_Guide_Section_I_33_h2;
MCNUM l = mccCurved_Guide_Section_I_33_l;
MCNUM R0 = mccCurved_Guide_Section_I_33_R0;
MCNUM Qc = mccCurved_Guide_Section_I_33_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_33_alpha;
MCNUM m = mccCurved_Guide_Section_I_33_m;
MCNUM W = mccCurved_Guide_Section_I_33_W;
MCNUM nslit = mccCurved_Guide_Section_I_33_nslit;
MCNUM d = mccCurved_Guide_Section_I_33_d;
MCNUM mleft = mccCurved_Guide_Section_I_33_mleft;
MCNUM mright = mccCurved_Guide_Section_I_33_mright;
MCNUM mtop = mccCurved_Guide_Section_I_33_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_33_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_33_nhslit;
MCNUM G = mccCurved_Guide_Section_I_33_G;
MCNUM aleft = mccCurved_Guide_Section_I_33_aleft;
MCNUM aright = mccCurved_Guide_Section_I_33_aright;
MCNUM atop = mccCurved_Guide_Section_I_33_atop;
MCNUM abottom = mccCurved_Guide_Section_I_33_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_33_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_33_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_33_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_33_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_33_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_33_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_33_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_33_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_33_nelements;
MCNUM nu = mccCurved_Guide_Section_I_33_nu;
MCNUM phase = mccCurved_Guide_Section_I_33_phase;
char* reflect = mccCurved_Guide_Section_I_33_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 51829 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_33=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_I_33:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(33,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_I_34 [34] */
  mccoordschange(mcposrCurved_Guide_Section_I_34, mcrotrCurved_Guide_Section_I_34,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_I_34 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_I_34:
  SIG_MESSAGE("Curved_Guide_Section_I_34 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_I_34")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_I_34
  STORE_NEUTRON(34,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[34]++;
  mcPCounter[34] += p;
  mcP2Counter[34] += p*p;
#define mccompcurname  Curved_Guide_Section_I_34
#define mccompcurtype  Guide_gravity
#define mccompcurindex 34
#define GVars mccCurved_Guide_Section_I_34_GVars
#define pTable mccCurved_Guide_Section_I_34_pTable
{   /* Declarations of Curved_Guide_Section_I_34=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_34_w1;
MCNUM h1 = mccCurved_Guide_Section_I_34_h1;
MCNUM w2 = mccCurved_Guide_Section_I_34_w2;
MCNUM h2 = mccCurved_Guide_Section_I_34_h2;
MCNUM l = mccCurved_Guide_Section_I_34_l;
MCNUM R0 = mccCurved_Guide_Section_I_34_R0;
MCNUM Qc = mccCurved_Guide_Section_I_34_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_34_alpha;
MCNUM m = mccCurved_Guide_Section_I_34_m;
MCNUM W = mccCurved_Guide_Section_I_34_W;
MCNUM nslit = mccCurved_Guide_Section_I_34_nslit;
MCNUM d = mccCurved_Guide_Section_I_34_d;
MCNUM mleft = mccCurved_Guide_Section_I_34_mleft;
MCNUM mright = mccCurved_Guide_Section_I_34_mright;
MCNUM mtop = mccCurved_Guide_Section_I_34_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_34_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_34_nhslit;
MCNUM G = mccCurved_Guide_Section_I_34_G;
MCNUM aleft = mccCurved_Guide_Section_I_34_aleft;
MCNUM aright = mccCurved_Guide_Section_I_34_aright;
MCNUM atop = mccCurved_Guide_Section_I_34_atop;
MCNUM abottom = mccCurved_Guide_Section_I_34_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_34_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_34_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_34_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_34_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_34_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_34_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_34_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_34_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_34_nelements;
MCNUM nu = mccCurved_Guide_Section_I_34_nu;
MCNUM phase = mccCurved_Guide_Section_I_34_phase;
char* reflect = mccCurved_Guide_Section_I_34_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 52142 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_34=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_I_34:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(34,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_I_35 [35] */
  mccoordschange(mcposrCurved_Guide_Section_I_35, mcrotrCurved_Guide_Section_I_35,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_I_35 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_I_35:
  SIG_MESSAGE("Curved_Guide_Section_I_35 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_I_35")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_I_35
  STORE_NEUTRON(35,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[35]++;
  mcPCounter[35] += p;
  mcP2Counter[35] += p*p;
#define mccompcurname  Curved_Guide_Section_I_35
#define mccompcurtype  Guide_gravity
#define mccompcurindex 35
#define GVars mccCurved_Guide_Section_I_35_GVars
#define pTable mccCurved_Guide_Section_I_35_pTable
{   /* Declarations of Curved_Guide_Section_I_35=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_35_w1;
MCNUM h1 = mccCurved_Guide_Section_I_35_h1;
MCNUM w2 = mccCurved_Guide_Section_I_35_w2;
MCNUM h2 = mccCurved_Guide_Section_I_35_h2;
MCNUM l = mccCurved_Guide_Section_I_35_l;
MCNUM R0 = mccCurved_Guide_Section_I_35_R0;
MCNUM Qc = mccCurved_Guide_Section_I_35_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_35_alpha;
MCNUM m = mccCurved_Guide_Section_I_35_m;
MCNUM W = mccCurved_Guide_Section_I_35_W;
MCNUM nslit = mccCurved_Guide_Section_I_35_nslit;
MCNUM d = mccCurved_Guide_Section_I_35_d;
MCNUM mleft = mccCurved_Guide_Section_I_35_mleft;
MCNUM mright = mccCurved_Guide_Section_I_35_mright;
MCNUM mtop = mccCurved_Guide_Section_I_35_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_35_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_35_nhslit;
MCNUM G = mccCurved_Guide_Section_I_35_G;
MCNUM aleft = mccCurved_Guide_Section_I_35_aleft;
MCNUM aright = mccCurved_Guide_Section_I_35_aright;
MCNUM atop = mccCurved_Guide_Section_I_35_atop;
MCNUM abottom = mccCurved_Guide_Section_I_35_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_35_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_35_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_35_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_35_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_35_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_35_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_35_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_35_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_35_nelements;
MCNUM nu = mccCurved_Guide_Section_I_35_nu;
MCNUM phase = mccCurved_Guide_Section_I_35_phase;
char* reflect = mccCurved_Guide_Section_I_35_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 52455 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_35=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_I_35:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(35,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_I_36 [36] */
  mccoordschange(mcposrCurved_Guide_Section_I_36, mcrotrCurved_Guide_Section_I_36,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_I_36 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_I_36:
  SIG_MESSAGE("Curved_Guide_Section_I_36 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_I_36")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_I_36
  STORE_NEUTRON(36,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[36]++;
  mcPCounter[36] += p;
  mcP2Counter[36] += p*p;
#define mccompcurname  Curved_Guide_Section_I_36
#define mccompcurtype  Guide_gravity
#define mccompcurindex 36
#define GVars mccCurved_Guide_Section_I_36_GVars
#define pTable mccCurved_Guide_Section_I_36_pTable
{   /* Declarations of Curved_Guide_Section_I_36=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_36_w1;
MCNUM h1 = mccCurved_Guide_Section_I_36_h1;
MCNUM w2 = mccCurved_Guide_Section_I_36_w2;
MCNUM h2 = mccCurved_Guide_Section_I_36_h2;
MCNUM l = mccCurved_Guide_Section_I_36_l;
MCNUM R0 = mccCurved_Guide_Section_I_36_R0;
MCNUM Qc = mccCurved_Guide_Section_I_36_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_36_alpha;
MCNUM m = mccCurved_Guide_Section_I_36_m;
MCNUM W = mccCurved_Guide_Section_I_36_W;
MCNUM nslit = mccCurved_Guide_Section_I_36_nslit;
MCNUM d = mccCurved_Guide_Section_I_36_d;
MCNUM mleft = mccCurved_Guide_Section_I_36_mleft;
MCNUM mright = mccCurved_Guide_Section_I_36_mright;
MCNUM mtop = mccCurved_Guide_Section_I_36_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_36_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_36_nhslit;
MCNUM G = mccCurved_Guide_Section_I_36_G;
MCNUM aleft = mccCurved_Guide_Section_I_36_aleft;
MCNUM aright = mccCurved_Guide_Section_I_36_aright;
MCNUM atop = mccCurved_Guide_Section_I_36_atop;
MCNUM abottom = mccCurved_Guide_Section_I_36_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_36_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_36_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_36_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_36_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_36_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_36_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_36_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_36_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_36_nelements;
MCNUM nu = mccCurved_Guide_Section_I_36_nu;
MCNUM phase = mccCurved_Guide_Section_I_36_phase;
char* reflect = mccCurved_Guide_Section_I_36_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 52768 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_36=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_I_36:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(36,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_I_37 [37] */
  mccoordschange(mcposrCurved_Guide_Section_I_37, mcrotrCurved_Guide_Section_I_37,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_I_37 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_I_37:
  SIG_MESSAGE("Curved_Guide_Section_I_37 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_I_37")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_I_37
  STORE_NEUTRON(37,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[37]++;
  mcPCounter[37] += p;
  mcP2Counter[37] += p*p;
#define mccompcurname  Curved_Guide_Section_I_37
#define mccompcurtype  Guide_gravity
#define mccompcurindex 37
#define GVars mccCurved_Guide_Section_I_37_GVars
#define pTable mccCurved_Guide_Section_I_37_pTable
{   /* Declarations of Curved_Guide_Section_I_37=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_37_w1;
MCNUM h1 = mccCurved_Guide_Section_I_37_h1;
MCNUM w2 = mccCurved_Guide_Section_I_37_w2;
MCNUM h2 = mccCurved_Guide_Section_I_37_h2;
MCNUM l = mccCurved_Guide_Section_I_37_l;
MCNUM R0 = mccCurved_Guide_Section_I_37_R0;
MCNUM Qc = mccCurved_Guide_Section_I_37_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_37_alpha;
MCNUM m = mccCurved_Guide_Section_I_37_m;
MCNUM W = mccCurved_Guide_Section_I_37_W;
MCNUM nslit = mccCurved_Guide_Section_I_37_nslit;
MCNUM d = mccCurved_Guide_Section_I_37_d;
MCNUM mleft = mccCurved_Guide_Section_I_37_mleft;
MCNUM mright = mccCurved_Guide_Section_I_37_mright;
MCNUM mtop = mccCurved_Guide_Section_I_37_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_37_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_37_nhslit;
MCNUM G = mccCurved_Guide_Section_I_37_G;
MCNUM aleft = mccCurved_Guide_Section_I_37_aleft;
MCNUM aright = mccCurved_Guide_Section_I_37_aright;
MCNUM atop = mccCurved_Guide_Section_I_37_atop;
MCNUM abottom = mccCurved_Guide_Section_I_37_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_37_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_37_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_37_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_37_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_37_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_37_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_37_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_37_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_37_nelements;
MCNUM nu = mccCurved_Guide_Section_I_37_nu;
MCNUM phase = mccCurved_Guide_Section_I_37_phase;
char* reflect = mccCurved_Guide_Section_I_37_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 53081 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_37=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_I_37:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(37,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_I_38 [38] */
  mccoordschange(mcposrCurved_Guide_Section_I_38, mcrotrCurved_Guide_Section_I_38,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_I_38 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_I_38:
  SIG_MESSAGE("Curved_Guide_Section_I_38 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_I_38")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_I_38
  STORE_NEUTRON(38,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[38]++;
  mcPCounter[38] += p;
  mcP2Counter[38] += p*p;
#define mccompcurname  Curved_Guide_Section_I_38
#define mccompcurtype  Guide_gravity
#define mccompcurindex 38
#define GVars mccCurved_Guide_Section_I_38_GVars
#define pTable mccCurved_Guide_Section_I_38_pTable
{   /* Declarations of Curved_Guide_Section_I_38=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_38_w1;
MCNUM h1 = mccCurved_Guide_Section_I_38_h1;
MCNUM w2 = mccCurved_Guide_Section_I_38_w2;
MCNUM h2 = mccCurved_Guide_Section_I_38_h2;
MCNUM l = mccCurved_Guide_Section_I_38_l;
MCNUM R0 = mccCurved_Guide_Section_I_38_R0;
MCNUM Qc = mccCurved_Guide_Section_I_38_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_38_alpha;
MCNUM m = mccCurved_Guide_Section_I_38_m;
MCNUM W = mccCurved_Guide_Section_I_38_W;
MCNUM nslit = mccCurved_Guide_Section_I_38_nslit;
MCNUM d = mccCurved_Guide_Section_I_38_d;
MCNUM mleft = mccCurved_Guide_Section_I_38_mleft;
MCNUM mright = mccCurved_Guide_Section_I_38_mright;
MCNUM mtop = mccCurved_Guide_Section_I_38_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_38_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_38_nhslit;
MCNUM G = mccCurved_Guide_Section_I_38_G;
MCNUM aleft = mccCurved_Guide_Section_I_38_aleft;
MCNUM aright = mccCurved_Guide_Section_I_38_aright;
MCNUM atop = mccCurved_Guide_Section_I_38_atop;
MCNUM abottom = mccCurved_Guide_Section_I_38_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_38_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_38_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_38_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_38_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_38_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_38_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_38_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_38_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_38_nelements;
MCNUM nu = mccCurved_Guide_Section_I_38_nu;
MCNUM phase = mccCurved_Guide_Section_I_38_phase;
char* reflect = mccCurved_Guide_Section_I_38_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 53394 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_38=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_I_38:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(38,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_I_short [39] */
  mccoordschange(mcposrCurved_Guide_Section_I_short, mcrotrCurved_Guide_Section_I_short,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_I_short (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_I_short:
  SIG_MESSAGE("Curved_Guide_Section_I_short (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_I_short")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_I_short
  STORE_NEUTRON(39,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[39]++;
  mcPCounter[39] += p;
  mcP2Counter[39] += p*p;
#define mccompcurname  Curved_Guide_Section_I_short
#define mccompcurtype  Guide_gravity
#define mccompcurindex 39
#define GVars mccCurved_Guide_Section_I_short_GVars
#define pTable mccCurved_Guide_Section_I_short_pTable
{   /* Declarations of Curved_Guide_Section_I_short=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_short_w1;
MCNUM h1 = mccCurved_Guide_Section_I_short_h1;
MCNUM w2 = mccCurved_Guide_Section_I_short_w2;
MCNUM h2 = mccCurved_Guide_Section_I_short_h2;
MCNUM l = mccCurved_Guide_Section_I_short_l;
MCNUM R0 = mccCurved_Guide_Section_I_short_R0;
MCNUM Qc = mccCurved_Guide_Section_I_short_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_short_alpha;
MCNUM m = mccCurved_Guide_Section_I_short_m;
MCNUM W = mccCurved_Guide_Section_I_short_W;
MCNUM nslit = mccCurved_Guide_Section_I_short_nslit;
MCNUM d = mccCurved_Guide_Section_I_short_d;
MCNUM mleft = mccCurved_Guide_Section_I_short_mleft;
MCNUM mright = mccCurved_Guide_Section_I_short_mright;
MCNUM mtop = mccCurved_Guide_Section_I_short_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_short_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_short_nhslit;
MCNUM G = mccCurved_Guide_Section_I_short_G;
MCNUM aleft = mccCurved_Guide_Section_I_short_aleft;
MCNUM aright = mccCurved_Guide_Section_I_short_aright;
MCNUM atop = mccCurved_Guide_Section_I_short_atop;
MCNUM abottom = mccCurved_Guide_Section_I_short_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_short_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_short_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_short_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_short_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_short_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_short_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_short_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_short_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_short_nelements;
MCNUM nu = mccCurved_Guide_Section_I_short_nu;
MCNUM phase = mccCurved_Guide_Section_I_short_phase;
char* reflect = mccCurved_Guide_Section_I_short_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 53707 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_short=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_I_short:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(39,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap3_start [40] */
  mccoordschange(mcposrGap3_start, mcrotrGap3_start,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap3_start (without coords transformations) */
  mcJumpTrace_Gap3_start:
  SIG_MESSAGE("Gap3_start (Trace)");
  mcDEBUG_COMP("Gap3_start")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap3_start
  STORE_NEUTRON(40,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[40]++;
  mcPCounter[40] += p;
  mcP2Counter[40] += p*p;
#define mccompcurname  Gap3_start
#define mccompcurtype  Arm
#define mccompcurindex 40
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap3_start:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(40,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap3_start_Lam [41] */
  mccoordschange(mcposrGap3_start_Lam, mcrotrGap3_start_Lam,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap3_start_Lam (without coords transformations) */
  mcJumpTrace_Gap3_start_Lam:
  SIG_MESSAGE("Gap3_start_Lam (Trace)");
  mcDEBUG_COMP("Gap3_start_Lam")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap3_start_Lam
  STORE_NEUTRON(41,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[41]++;
  mcPCounter[41] += p;
  mcP2Counter[41] += p*p;
#define mccompcurname  Gap3_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 41
#define nL mccGap3_start_Lam_nL
#define L_N mccGap3_start_Lam_L_N
#define L_p mccGap3_start_Lam_L_p
#define L_p2 mccGap3_start_Lam_L_p2
{   /* Declarations of Gap3_start_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap3_start_Lam_filename;
MCNUM xmin = mccGap3_start_Lam_xmin;
MCNUM xmax = mccGap3_start_Lam_xmax;
MCNUM ymin = mccGap3_start_Lam_ymin;
MCNUM ymax = mccGap3_start_Lam_ymax;
MCNUM xwidth = mccGap3_start_Lam_xwidth;
MCNUM yheight = mccGap3_start_Lam_yheight;
MCNUM Lmin = mccGap3_start_Lam_Lmin;
MCNUM Lmax = mccGap3_start_Lam_Lmax;
MCNUM restore_neutron = mccGap3_start_Lam_restore_neutron;
int nowritefile = mccGap3_start_Lam_nowritefile;
#line 84 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 53955 "./SNS_BASIS.c"
}   /* End of Gap3_start_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap3_start_Lam:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(41,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component CGS1_end [42] */
  mccoordschange(mcposrCGS1_end, mcrotrCGS1_end,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component CGS1_end (without coords transformations) */
  mcJumpTrace_CGS1_end:
  SIG_MESSAGE("CGS1_end (Trace)");
  mcDEBUG_COMP("CGS1_end")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCGS1_end
  STORE_NEUTRON(42,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[42]++;
  mcPCounter[42] += p;
  mcP2Counter[42] += p*p;
#define mccompcurname  CGS1_end
#define mccompcurtype  PSD_monitor
#define mccompcurindex 42
#define PSD_N mccCGS1_end_PSD_N
#define PSD_p mccCGS1_end_PSD_p
#define PSD_p2 mccCGS1_end_PSD_p2
{   /* Declarations of CGS1_end=PSD_monitor() SETTING parameters. */
int nx = mccCGS1_end_nx;
int ny = mccCGS1_end_ny;
char* filename = mccCGS1_end_filename;
MCNUM xmin = mccCGS1_end_xmin;
MCNUM xmax = mccCGS1_end_xmax;
MCNUM ymin = mccCGS1_end_ymin;
MCNUM ymax = mccCGS1_end_ymax;
MCNUM xwidth = mccCGS1_end_xwidth;
MCNUM yheight = mccCGS1_end_yheight;
MCNUM restore_neutron = mccCGS1_end_restore_neutron;
#line 94 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  PROP_Z0;
  if (x>xmin && x<xmax && y>ymin && y<ymax){
    int i = floor((x - xmin)*nx/(xmax - xmin));
    int j = floor((y - ymin)*ny/(ymax - ymin));
    PSD_N[i][j]++;
    PSD_p[i][j] += p;
    PSD_p2[i][j] += p*p;
    SCATTER;
  }
  if (restore_neutron) {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 54093 "./SNS_BASIS.c"
}   /* End of CGS1_end=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCGS1_end:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(42,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component before_Chopper1_ToF [43] */
  mccoordschange(mcposrbefore_Chopper1_ToF, mcrotrbefore_Chopper1_ToF,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component before_Chopper1_ToF (without coords transformations) */
  mcJumpTrace_before_Chopper1_ToF:
  SIG_MESSAGE("before_Chopper1_ToF (Trace)");
  mcDEBUG_COMP("before_Chopper1_ToF")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompbefore_Chopper1_ToF
  STORE_NEUTRON(43,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[43]++;
  mcPCounter[43] += p;
  mcP2Counter[43] += p*p;
#define mccompcurname  before_Chopper1_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 43
#define nt mccbefore_Chopper1_ToF_nt
#define TOF_N mccbefore_Chopper1_ToF_TOF_N
#define TOF_p mccbefore_Chopper1_ToF_TOF_p
#define TOF_p2 mccbefore_Chopper1_ToF_TOF_p2
#define t_min mccbefore_Chopper1_ToF_t_min
#define t_max mccbefore_Chopper1_ToF_t_max
#define delta_t mccbefore_Chopper1_ToF_delta_t
{   /* Declarations of before_Chopper1_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccbefore_Chopper1_ToF_filename;
MCNUM xmin = mccbefore_Chopper1_ToF_xmin;
MCNUM xmax = mccbefore_Chopper1_ToF_xmax;
MCNUM ymin = mccbefore_Chopper1_ToF_ymin;
MCNUM ymax = mccbefore_Chopper1_ToF_ymax;
MCNUM xwidth = mccbefore_Chopper1_ToF_xwidth;
MCNUM yheight = mccbefore_Chopper1_ToF_yheight;
MCNUM tmin = mccbefore_Chopper1_ToF_tmin;
MCNUM tmax = mccbefore_Chopper1_ToF_tmax;
MCNUM dt = mccbefore_Chopper1_ToF_dt;
MCNUM restore_neutron = mccbefore_Chopper1_ToF_restore_neutron;
int nowritefile = mccbefore_Chopper1_ToF_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 54240 "./SNS_BASIS.c"
}   /* End of before_Chopper1_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompbefore_Chopper1_ToF:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(43,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component before_Chopper1_ToF_Z [44] */
  mccoordschange(mcposrbefore_Chopper1_ToF_Z, mcrotrbefore_Chopper1_ToF_Z,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component before_Chopper1_ToF_Z (without coords transformations) */
  mcJumpTrace_before_Chopper1_ToF_Z:
  SIG_MESSAGE("before_Chopper1_ToF_Z (Trace)");
  mcDEBUG_COMP("before_Chopper1_ToF_Z")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompbefore_Chopper1_ToF_Z
  STORE_NEUTRON(44,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[44]++;
  mcPCounter[44] += p;
  mcP2Counter[44] += p*p;
#define mccompcurname  before_Chopper1_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 44
#define nt mccbefore_Chopper1_ToF_Z_nt
#define TOF_N mccbefore_Chopper1_ToF_Z_TOF_N
#define TOF_p mccbefore_Chopper1_ToF_Z_TOF_p
#define TOF_p2 mccbefore_Chopper1_ToF_Z_TOF_p2
#define t_min mccbefore_Chopper1_ToF_Z_t_min
#define t_max mccbefore_Chopper1_ToF_Z_t_max
#define delta_t mccbefore_Chopper1_ToF_Z_delta_t
{   /* Declarations of before_Chopper1_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccbefore_Chopper1_ToF_Z_filename;
MCNUM xmin = mccbefore_Chopper1_ToF_Z_xmin;
MCNUM xmax = mccbefore_Chopper1_ToF_Z_xmax;
MCNUM ymin = mccbefore_Chopper1_ToF_Z_ymin;
MCNUM ymax = mccbefore_Chopper1_ToF_Z_ymax;
MCNUM xwidth = mccbefore_Chopper1_ToF_Z_xwidth;
MCNUM yheight = mccbefore_Chopper1_ToF_Z_yheight;
MCNUM tmin = mccbefore_Chopper1_ToF_Z_tmin;
MCNUM tmax = mccbefore_Chopper1_ToF_Z_tmax;
MCNUM dt = mccbefore_Chopper1_ToF_Z_dt;
MCNUM restore_neutron = mccbefore_Chopper1_ToF_Z_restore_neutron;
int nowritefile = mccbefore_Chopper1_ToF_Z_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 54391 "./SNS_BASIS.c"
}   /* End of before_Chopper1_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompbefore_Chopper1_ToF_Z:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(44,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Chopper1 [45] */
  mccoordschange(mcposrChopper1, mcrotrChopper1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Chopper1 (without coords transformations) */
  mcJumpTrace_Chopper1:
  SIG_MESSAGE("Chopper1 (Trace)");
  mcDEBUG_COMP("Chopper1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompChopper1
  STORE_NEUTRON(45,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[45]++;
  mcPCounter[45] += p;
  mcP2Counter[45] += p*p;
#define mccompcurname  Chopper1
#define mccompcurtype  DiskChopper
#define mccompcurindex 45
#define Tg mccChopper1_Tg
#define To mccChopper1_To
#define delta_y mccChopper1_delta_y
#define height mccChopper1_height
#define omega mccChopper1_omega
{   /* Declarations of Chopper1=DiskChopper() SETTING parameters. */
MCNUM theta_0 = mccChopper1_theta_0;
MCNUM radius = mccChopper1_radius;
MCNUM yheight = mccChopper1_yheight;
MCNUM nu = mccChopper1_nu;
MCNUM nslit = mccChopper1_nslit;
MCNUM jitter = mccChopper1_jitter;
MCNUM delay = mccChopper1_delay;
MCNUM isfirst = mccChopper1_isfirst;
MCNUM n_pulse = mccChopper1_n_pulse;
MCNUM abs_out = mccChopper1_abs_out;
MCNUM phase = mccChopper1_phase;
MCNUM xwidth = mccChopper1_xwidth;
MCNUM verbose = mccChopper1_verbose;
/* 'Chopper1=DiskChopper()' component instance has conditional execution */
if (( Omega1 > 0 ))

#line 133 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/DiskChopper.comp"
{
    double toff;
    double yprime;
    PROP_Z0;
    yprime = y+delta_y;

    /* Is neutron outside the vertical slit range and should we absorb? */
    if (abs_out && (x*x+yprime*yprime)>radius*radius) {
      ABSORB;
    }
    /* Does neutron hit inner solid part of chopper in case of yheight!=radius? */
    if ((x*x+yprime*yprime)<(radius-height)*(radius-height)) {
      ABSORB;
    }


    if (isfirst)
      {
        /* all events are put in the transmitted time frame */
        t=atan2(x,yprime)/omega + To*randpm1()/2.0 + delay + (jitter ? jitter*randnorm():0) + (n_pulse > 1 ? floor(n_pulse*rand01())*Tg : 0);
        /* correction: chopper slits transmission opening/full disk */
        p *= nslit*theta_0/2.0/PI;
      }
    else
      {
        toff=fabs(t-atan2(x,yprime)/omega - delay - (jitter ? jitter*randnorm():0));

        /* does neutron hit outside slit? */
        if (fmod(toff+To/2.0,Tg)>To) ABSORB;
      }
    SCATTER;

}
#line 54558 "./SNS_BASIS.c"
}   /* End of Chopper1=DiskChopper() SETTING parameter declarations. */
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompChopper1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(45,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Chopper1_ToF [46] */
  mccoordschange(mcposrChopper1_ToF, mcrotrChopper1_ToF,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Chopper1_ToF (without coords transformations) */
  mcJumpTrace_Chopper1_ToF:
  SIG_MESSAGE("Chopper1_ToF (Trace)");
  mcDEBUG_COMP("Chopper1_ToF")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompChopper1_ToF
  STORE_NEUTRON(46,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[46]++;
  mcPCounter[46] += p;
  mcP2Counter[46] += p*p;
#define mccompcurname  Chopper1_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 46
#define nt mccChopper1_ToF_nt
#define TOF_N mccChopper1_ToF_TOF_N
#define TOF_p mccChopper1_ToF_TOF_p
#define TOF_p2 mccChopper1_ToF_TOF_p2
#define t_min mccChopper1_ToF_t_min
#define t_max mccChopper1_ToF_t_max
#define delta_t mccChopper1_ToF_delta_t
{   /* Declarations of Chopper1_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccChopper1_ToF_filename;
MCNUM xmin = mccChopper1_ToF_xmin;
MCNUM xmax = mccChopper1_ToF_xmax;
MCNUM ymin = mccChopper1_ToF_ymin;
MCNUM ymax = mccChopper1_ToF_ymax;
MCNUM xwidth = mccChopper1_ToF_xwidth;
MCNUM yheight = mccChopper1_ToF_yheight;
MCNUM tmin = mccChopper1_ToF_tmin;
MCNUM tmax = mccChopper1_ToF_tmax;
MCNUM dt = mccChopper1_ToF_dt;
MCNUM restore_neutron = mccChopper1_ToF_restore_neutron;
int nowritefile = mccChopper1_ToF_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 54707 "./SNS_BASIS.c"
}   /* End of Chopper1_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompChopper1_ToF:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(46,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Chopper1_ToF_Z [47] */
  mccoordschange(mcposrChopper1_ToF_Z, mcrotrChopper1_ToF_Z,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Chopper1_ToF_Z (without coords transformations) */
  mcJumpTrace_Chopper1_ToF_Z:
  SIG_MESSAGE("Chopper1_ToF_Z (Trace)");
  mcDEBUG_COMP("Chopper1_ToF_Z")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompChopper1_ToF_Z
  STORE_NEUTRON(47,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[47]++;
  mcPCounter[47] += p;
  mcP2Counter[47] += p*p;
#define mccompcurname  Chopper1_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 47
#define nt mccChopper1_ToF_Z_nt
#define TOF_N mccChopper1_ToF_Z_TOF_N
#define TOF_p mccChopper1_ToF_Z_TOF_p
#define TOF_p2 mccChopper1_ToF_Z_TOF_p2
#define t_min mccChopper1_ToF_Z_t_min
#define t_max mccChopper1_ToF_Z_t_max
#define delta_t mccChopper1_ToF_Z_delta_t
{   /* Declarations of Chopper1_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccChopper1_ToF_Z_filename;
MCNUM xmin = mccChopper1_ToF_Z_xmin;
MCNUM xmax = mccChopper1_ToF_Z_xmax;
MCNUM ymin = mccChopper1_ToF_Z_ymin;
MCNUM ymax = mccChopper1_ToF_Z_ymax;
MCNUM xwidth = mccChopper1_ToF_Z_xwidth;
MCNUM yheight = mccChopper1_ToF_Z_yheight;
MCNUM tmin = mccChopper1_ToF_Z_tmin;
MCNUM tmax = mccChopper1_ToF_Z_tmax;
MCNUM dt = mccChopper1_ToF_Z_dt;
MCNUM restore_neutron = mccChopper1_ToF_Z_restore_neutron;
int nowritefile = mccChopper1_ToF_Z_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 54858 "./SNS_BASIS.c"
}   /* End of Chopper1_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompChopper1_ToF_Z:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(47,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap3_end_Lam [48] */
  mccoordschange(mcposrGap3_end_Lam, mcrotrGap3_end_Lam,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap3_end_Lam (without coords transformations) */
  mcJumpTrace_Gap3_end_Lam:
  SIG_MESSAGE("Gap3_end_Lam (Trace)");
  mcDEBUG_COMP("Gap3_end_Lam")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap3_end_Lam
  STORE_NEUTRON(48,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[48]++;
  mcPCounter[48] += p;
  mcP2Counter[48] += p*p;
#define mccompcurname  Gap3_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 48
#define nL mccGap3_end_Lam_nL
#define L_N mccGap3_end_Lam_L_N
#define L_p mccGap3_end_Lam_L_p
#define L_p2 mccGap3_end_Lam_L_p2
{   /* Declarations of Gap3_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap3_end_Lam_filename;
MCNUM xmin = mccGap3_end_Lam_xmin;
MCNUM xmax = mccGap3_end_Lam_xmax;
MCNUM ymin = mccGap3_end_Lam_ymin;
MCNUM ymax = mccGap3_end_Lam_ymax;
MCNUM xwidth = mccGap3_end_Lam_xwidth;
MCNUM yheight = mccGap3_end_Lam_yheight;
MCNUM Lmin = mccGap3_end_Lam_Lmin;
MCNUM Lmax = mccGap3_end_Lam_Lmax;
MCNUM restore_neutron = mccGap3_end_Lam_restore_neutron;
int nowritefile = mccGap3_end_Lam_nowritefile;
#line 84 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 55008 "./SNS_BASIS.c"
}   /* End of Gap3_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap3_end_Lam:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(48,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap3_end_PSD [49] */
  mccoordschange(mcposrGap3_end_PSD, mcrotrGap3_end_PSD,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap3_end_PSD (without coords transformations) */
  mcJumpTrace_Gap3_end_PSD:
  SIG_MESSAGE("Gap3_end_PSD (Trace)");
  mcDEBUG_COMP("Gap3_end_PSD")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap3_end_PSD
  STORE_NEUTRON(49,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[49]++;
  mcPCounter[49] += p;
  mcP2Counter[49] += p*p;
#define mccompcurname  Gap3_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 49
#define PSD_N mccGap3_end_PSD_PSD_N
#define PSD_p mccGap3_end_PSD_PSD_p
#define PSD_p2 mccGap3_end_PSD_PSD_p2
{   /* Declarations of Gap3_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap3_end_PSD_nx;
int ny = mccGap3_end_PSD_ny;
char* filename = mccGap3_end_PSD_filename;
MCNUM xmin = mccGap3_end_PSD_xmin;
MCNUM xmax = mccGap3_end_PSD_xmax;
MCNUM ymin = mccGap3_end_PSD_ymin;
MCNUM ymax = mccGap3_end_PSD_ymax;
MCNUM xwidth = mccGap3_end_PSD_xwidth;
MCNUM yheight = mccGap3_end_PSD_yheight;
MCNUM restore_neutron = mccGap3_end_PSD_restore_neutron;
#line 94 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  PROP_Z0;
  if (x>xmin && x<xmax && y>ymin && y<ymax){
    int i = floor((x - xmin)*nx/(xmax - xmin));
    int j = floor((y - ymin)*ny/(ymax - ymin));
    PSD_N[i][j]++;
    PSD_p[i][j] += p;
    PSD_p2[i][j] += p*p;
    SCATTER;
  }
  if (restore_neutron) {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 55146 "./SNS_BASIS.c"
}   /* End of Gap3_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap3_end_PSD:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(49,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap3_end [50] */
  mccoordschange(mcposrGap3_end, mcrotrGap3_end,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap3_end (without coords transformations) */
  mcJumpTrace_Gap3_end:
  SIG_MESSAGE("Gap3_end (Trace)");
  mcDEBUG_COMP("Gap3_end")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap3_end
  STORE_NEUTRON(50,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[50]++;
  mcPCounter[50] += p;
  mcP2Counter[50] += p*p;
#define mccompcurname  Gap3_end
#define mccompcurtype  Arm
#define mccompcurindex 50
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap3_end:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(50,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_II [51] */
  mccoordschange(mcposrCurved_Guide_Section_II, mcrotrCurved_Guide_Section_II,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_II (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_II:
  SIG_MESSAGE("Curved_Guide_Section_II (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_II")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_II
  STORE_NEUTRON(51,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[51]++;
  mcPCounter[51] += p;
  mcP2Counter[51] += p*p;
#define mccompcurname  Curved_Guide_Section_II
#define mccompcurtype  Guide_gravity
#define mccompcurindex 51
#define GVars mccCurved_Guide_Section_II_GVars
#define pTable mccCurved_Guide_Section_II_pTable
{   /* Declarations of Curved_Guide_Section_II=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_w1;
MCNUM h1 = mccCurved_Guide_Section_II_h1;
MCNUM w2 = mccCurved_Guide_Section_II_w2;
MCNUM h2 = mccCurved_Guide_Section_II_h2;
MCNUM l = mccCurved_Guide_Section_II_l;
MCNUM R0 = mccCurved_Guide_Section_II_R0;
MCNUM Qc = mccCurved_Guide_Section_II_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_alpha;
MCNUM m = mccCurved_Guide_Section_II_m;
MCNUM W = mccCurved_Guide_Section_II_W;
MCNUM nslit = mccCurved_Guide_Section_II_nslit;
MCNUM d = mccCurved_Guide_Section_II_d;
MCNUM mleft = mccCurved_Guide_Section_II_mleft;
MCNUM mright = mccCurved_Guide_Section_II_mright;
MCNUM mtop = mccCurved_Guide_Section_II_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_nhslit;
MCNUM G = mccCurved_Guide_Section_II_G;
MCNUM aleft = mccCurved_Guide_Section_II_aleft;
MCNUM aright = mccCurved_Guide_Section_II_aright;
MCNUM atop = mccCurved_Guide_Section_II_atop;
MCNUM abottom = mccCurved_Guide_Section_II_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_nelements;
MCNUM nu = mccCurved_Guide_Section_II_nu;
MCNUM phase = mccCurved_Guide_Section_II_phase;
char* reflect = mccCurved_Guide_Section_II_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 55563 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_II:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(51,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_II_52 [52] */
  mccoordschange(mcposrCurved_Guide_Section_II_52, mcrotrCurved_Guide_Section_II_52,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_II_52 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_II_52:
  SIG_MESSAGE("Curved_Guide_Section_II_52 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_II_52")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_II_52
  STORE_NEUTRON(52,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[52]++;
  mcPCounter[52] += p;
  mcP2Counter[52] += p*p;
#define mccompcurname  Curved_Guide_Section_II_52
#define mccompcurtype  Guide_gravity
#define mccompcurindex 52
#define GVars mccCurved_Guide_Section_II_52_GVars
#define pTable mccCurved_Guide_Section_II_52_pTable
{   /* Declarations of Curved_Guide_Section_II_52=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_52_w1;
MCNUM h1 = mccCurved_Guide_Section_II_52_h1;
MCNUM w2 = mccCurved_Guide_Section_II_52_w2;
MCNUM h2 = mccCurved_Guide_Section_II_52_h2;
MCNUM l = mccCurved_Guide_Section_II_52_l;
MCNUM R0 = mccCurved_Guide_Section_II_52_R0;
MCNUM Qc = mccCurved_Guide_Section_II_52_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_52_alpha;
MCNUM m = mccCurved_Guide_Section_II_52_m;
MCNUM W = mccCurved_Guide_Section_II_52_W;
MCNUM nslit = mccCurved_Guide_Section_II_52_nslit;
MCNUM d = mccCurved_Guide_Section_II_52_d;
MCNUM mleft = mccCurved_Guide_Section_II_52_mleft;
MCNUM mright = mccCurved_Guide_Section_II_52_mright;
MCNUM mtop = mccCurved_Guide_Section_II_52_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_52_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_52_nhslit;
MCNUM G = mccCurved_Guide_Section_II_52_G;
MCNUM aleft = mccCurved_Guide_Section_II_52_aleft;
MCNUM aright = mccCurved_Guide_Section_II_52_aright;
MCNUM atop = mccCurved_Guide_Section_II_52_atop;
MCNUM abottom = mccCurved_Guide_Section_II_52_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_52_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_52_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_52_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_52_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_52_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_52_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_52_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_52_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_52_nelements;
MCNUM nu = mccCurved_Guide_Section_II_52_nu;
MCNUM phase = mccCurved_Guide_Section_II_52_phase;
char* reflect = mccCurved_Guide_Section_II_52_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 55876 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II_52=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_II_52:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(52,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_II_53 [53] */
  mccoordschange(mcposrCurved_Guide_Section_II_53, mcrotrCurved_Guide_Section_II_53,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_II_53 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_II_53:
  SIG_MESSAGE("Curved_Guide_Section_II_53 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_II_53")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_II_53
  STORE_NEUTRON(53,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[53]++;
  mcPCounter[53] += p;
  mcP2Counter[53] += p*p;
#define mccompcurname  Curved_Guide_Section_II_53
#define mccompcurtype  Guide_gravity
#define mccompcurindex 53
#define GVars mccCurved_Guide_Section_II_53_GVars
#define pTable mccCurved_Guide_Section_II_53_pTable
{   /* Declarations of Curved_Guide_Section_II_53=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_53_w1;
MCNUM h1 = mccCurved_Guide_Section_II_53_h1;
MCNUM w2 = mccCurved_Guide_Section_II_53_w2;
MCNUM h2 = mccCurved_Guide_Section_II_53_h2;
MCNUM l = mccCurved_Guide_Section_II_53_l;
MCNUM R0 = mccCurved_Guide_Section_II_53_R0;
MCNUM Qc = mccCurved_Guide_Section_II_53_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_53_alpha;
MCNUM m = mccCurved_Guide_Section_II_53_m;
MCNUM W = mccCurved_Guide_Section_II_53_W;
MCNUM nslit = mccCurved_Guide_Section_II_53_nslit;
MCNUM d = mccCurved_Guide_Section_II_53_d;
MCNUM mleft = mccCurved_Guide_Section_II_53_mleft;
MCNUM mright = mccCurved_Guide_Section_II_53_mright;
MCNUM mtop = mccCurved_Guide_Section_II_53_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_53_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_53_nhslit;
MCNUM G = mccCurved_Guide_Section_II_53_G;
MCNUM aleft = mccCurved_Guide_Section_II_53_aleft;
MCNUM aright = mccCurved_Guide_Section_II_53_aright;
MCNUM atop = mccCurved_Guide_Section_II_53_atop;
MCNUM abottom = mccCurved_Guide_Section_II_53_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_53_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_53_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_53_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_53_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_53_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_53_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_53_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_53_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_53_nelements;
MCNUM nu = mccCurved_Guide_Section_II_53_nu;
MCNUM phase = mccCurved_Guide_Section_II_53_phase;
char* reflect = mccCurved_Guide_Section_II_53_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 56189 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II_53=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_II_53:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(53,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_II_54 [54] */
  mccoordschange(mcposrCurved_Guide_Section_II_54, mcrotrCurved_Guide_Section_II_54,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_II_54 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_II_54:
  SIG_MESSAGE("Curved_Guide_Section_II_54 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_II_54")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_II_54
  STORE_NEUTRON(54,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[54]++;
  mcPCounter[54] += p;
  mcP2Counter[54] += p*p;
#define mccompcurname  Curved_Guide_Section_II_54
#define mccompcurtype  Guide_gravity
#define mccompcurindex 54
#define GVars mccCurved_Guide_Section_II_54_GVars
#define pTable mccCurved_Guide_Section_II_54_pTable
{   /* Declarations of Curved_Guide_Section_II_54=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_54_w1;
MCNUM h1 = mccCurved_Guide_Section_II_54_h1;
MCNUM w2 = mccCurved_Guide_Section_II_54_w2;
MCNUM h2 = mccCurved_Guide_Section_II_54_h2;
MCNUM l = mccCurved_Guide_Section_II_54_l;
MCNUM R0 = mccCurved_Guide_Section_II_54_R0;
MCNUM Qc = mccCurved_Guide_Section_II_54_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_54_alpha;
MCNUM m = mccCurved_Guide_Section_II_54_m;
MCNUM W = mccCurved_Guide_Section_II_54_W;
MCNUM nslit = mccCurved_Guide_Section_II_54_nslit;
MCNUM d = mccCurved_Guide_Section_II_54_d;
MCNUM mleft = mccCurved_Guide_Section_II_54_mleft;
MCNUM mright = mccCurved_Guide_Section_II_54_mright;
MCNUM mtop = mccCurved_Guide_Section_II_54_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_54_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_54_nhslit;
MCNUM G = mccCurved_Guide_Section_II_54_G;
MCNUM aleft = mccCurved_Guide_Section_II_54_aleft;
MCNUM aright = mccCurved_Guide_Section_II_54_aright;
MCNUM atop = mccCurved_Guide_Section_II_54_atop;
MCNUM abottom = mccCurved_Guide_Section_II_54_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_54_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_54_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_54_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_54_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_54_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_54_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_54_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_54_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_54_nelements;
MCNUM nu = mccCurved_Guide_Section_II_54_nu;
MCNUM phase = mccCurved_Guide_Section_II_54_phase;
char* reflect = mccCurved_Guide_Section_II_54_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 56502 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II_54=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_II_54:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(54,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_II_55 [55] */
  mccoordschange(mcposrCurved_Guide_Section_II_55, mcrotrCurved_Guide_Section_II_55,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_II_55 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_II_55:
  SIG_MESSAGE("Curved_Guide_Section_II_55 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_II_55")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_II_55
  STORE_NEUTRON(55,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[55]++;
  mcPCounter[55] += p;
  mcP2Counter[55] += p*p;
#define mccompcurname  Curved_Guide_Section_II_55
#define mccompcurtype  Guide_gravity
#define mccompcurindex 55
#define GVars mccCurved_Guide_Section_II_55_GVars
#define pTable mccCurved_Guide_Section_II_55_pTable
{   /* Declarations of Curved_Guide_Section_II_55=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_55_w1;
MCNUM h1 = mccCurved_Guide_Section_II_55_h1;
MCNUM w2 = mccCurved_Guide_Section_II_55_w2;
MCNUM h2 = mccCurved_Guide_Section_II_55_h2;
MCNUM l = mccCurved_Guide_Section_II_55_l;
MCNUM R0 = mccCurved_Guide_Section_II_55_R0;
MCNUM Qc = mccCurved_Guide_Section_II_55_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_55_alpha;
MCNUM m = mccCurved_Guide_Section_II_55_m;
MCNUM W = mccCurved_Guide_Section_II_55_W;
MCNUM nslit = mccCurved_Guide_Section_II_55_nslit;
MCNUM d = mccCurved_Guide_Section_II_55_d;
MCNUM mleft = mccCurved_Guide_Section_II_55_mleft;
MCNUM mright = mccCurved_Guide_Section_II_55_mright;
MCNUM mtop = mccCurved_Guide_Section_II_55_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_55_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_55_nhslit;
MCNUM G = mccCurved_Guide_Section_II_55_G;
MCNUM aleft = mccCurved_Guide_Section_II_55_aleft;
MCNUM aright = mccCurved_Guide_Section_II_55_aright;
MCNUM atop = mccCurved_Guide_Section_II_55_atop;
MCNUM abottom = mccCurved_Guide_Section_II_55_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_55_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_55_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_55_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_55_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_55_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_55_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_55_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_55_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_55_nelements;
MCNUM nu = mccCurved_Guide_Section_II_55_nu;
MCNUM phase = mccCurved_Guide_Section_II_55_phase;
char* reflect = mccCurved_Guide_Section_II_55_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 56815 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II_55=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_II_55:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(55,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_II_56 [56] */
  mccoordschange(mcposrCurved_Guide_Section_II_56, mcrotrCurved_Guide_Section_II_56,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_II_56 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_II_56:
  SIG_MESSAGE("Curved_Guide_Section_II_56 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_II_56")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_II_56
  STORE_NEUTRON(56,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[56]++;
  mcPCounter[56] += p;
  mcP2Counter[56] += p*p;
#define mccompcurname  Curved_Guide_Section_II_56
#define mccompcurtype  Guide_gravity
#define mccompcurindex 56
#define GVars mccCurved_Guide_Section_II_56_GVars
#define pTable mccCurved_Guide_Section_II_56_pTable
{   /* Declarations of Curved_Guide_Section_II_56=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_56_w1;
MCNUM h1 = mccCurved_Guide_Section_II_56_h1;
MCNUM w2 = mccCurved_Guide_Section_II_56_w2;
MCNUM h2 = mccCurved_Guide_Section_II_56_h2;
MCNUM l = mccCurved_Guide_Section_II_56_l;
MCNUM R0 = mccCurved_Guide_Section_II_56_R0;
MCNUM Qc = mccCurved_Guide_Section_II_56_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_56_alpha;
MCNUM m = mccCurved_Guide_Section_II_56_m;
MCNUM W = mccCurved_Guide_Section_II_56_W;
MCNUM nslit = mccCurved_Guide_Section_II_56_nslit;
MCNUM d = mccCurved_Guide_Section_II_56_d;
MCNUM mleft = mccCurved_Guide_Section_II_56_mleft;
MCNUM mright = mccCurved_Guide_Section_II_56_mright;
MCNUM mtop = mccCurved_Guide_Section_II_56_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_56_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_56_nhslit;
MCNUM G = mccCurved_Guide_Section_II_56_G;
MCNUM aleft = mccCurved_Guide_Section_II_56_aleft;
MCNUM aright = mccCurved_Guide_Section_II_56_aright;
MCNUM atop = mccCurved_Guide_Section_II_56_atop;
MCNUM abottom = mccCurved_Guide_Section_II_56_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_56_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_56_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_56_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_56_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_56_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_56_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_56_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_56_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_56_nelements;
MCNUM nu = mccCurved_Guide_Section_II_56_nu;
MCNUM phase = mccCurved_Guide_Section_II_56_phase;
char* reflect = mccCurved_Guide_Section_II_56_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 57128 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II_56=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_II_56:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(56,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_II_57 [57] */
  mccoordschange(mcposrCurved_Guide_Section_II_57, mcrotrCurved_Guide_Section_II_57,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_II_57 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_II_57:
  SIG_MESSAGE("Curved_Guide_Section_II_57 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_II_57")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_II_57
  STORE_NEUTRON(57,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[57]++;
  mcPCounter[57] += p;
  mcP2Counter[57] += p*p;
#define mccompcurname  Curved_Guide_Section_II_57
#define mccompcurtype  Guide_gravity
#define mccompcurindex 57
#define GVars mccCurved_Guide_Section_II_57_GVars
#define pTable mccCurved_Guide_Section_II_57_pTable
{   /* Declarations of Curved_Guide_Section_II_57=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_57_w1;
MCNUM h1 = mccCurved_Guide_Section_II_57_h1;
MCNUM w2 = mccCurved_Guide_Section_II_57_w2;
MCNUM h2 = mccCurved_Guide_Section_II_57_h2;
MCNUM l = mccCurved_Guide_Section_II_57_l;
MCNUM R0 = mccCurved_Guide_Section_II_57_R0;
MCNUM Qc = mccCurved_Guide_Section_II_57_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_57_alpha;
MCNUM m = mccCurved_Guide_Section_II_57_m;
MCNUM W = mccCurved_Guide_Section_II_57_W;
MCNUM nslit = mccCurved_Guide_Section_II_57_nslit;
MCNUM d = mccCurved_Guide_Section_II_57_d;
MCNUM mleft = mccCurved_Guide_Section_II_57_mleft;
MCNUM mright = mccCurved_Guide_Section_II_57_mright;
MCNUM mtop = mccCurved_Guide_Section_II_57_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_57_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_57_nhslit;
MCNUM G = mccCurved_Guide_Section_II_57_G;
MCNUM aleft = mccCurved_Guide_Section_II_57_aleft;
MCNUM aright = mccCurved_Guide_Section_II_57_aright;
MCNUM atop = mccCurved_Guide_Section_II_57_atop;
MCNUM abottom = mccCurved_Guide_Section_II_57_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_57_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_57_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_57_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_57_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_57_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_57_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_57_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_57_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_57_nelements;
MCNUM nu = mccCurved_Guide_Section_II_57_nu;
MCNUM phase = mccCurved_Guide_Section_II_57_phase;
char* reflect = mccCurved_Guide_Section_II_57_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 57441 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II_57=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_II_57:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(57,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_II_last [58] */
  mccoordschange(mcposrCurved_Guide_Section_II_last, mcrotrCurved_Guide_Section_II_last,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_II_last (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_II_last:
  SIG_MESSAGE("Curved_Guide_Section_II_last (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_II_last")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_II_last
  STORE_NEUTRON(58,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[58]++;
  mcPCounter[58] += p;
  mcP2Counter[58] += p*p;
#define mccompcurname  Curved_Guide_Section_II_last
#define mccompcurtype  Guide_gravity
#define mccompcurindex 58
#define GVars mccCurved_Guide_Section_II_last_GVars
#define pTable mccCurved_Guide_Section_II_last_pTable
{   /* Declarations of Curved_Guide_Section_II_last=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_last_w1;
MCNUM h1 = mccCurved_Guide_Section_II_last_h1;
MCNUM w2 = mccCurved_Guide_Section_II_last_w2;
MCNUM h2 = mccCurved_Guide_Section_II_last_h2;
MCNUM l = mccCurved_Guide_Section_II_last_l;
MCNUM R0 = mccCurved_Guide_Section_II_last_R0;
MCNUM Qc = mccCurved_Guide_Section_II_last_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_last_alpha;
MCNUM m = mccCurved_Guide_Section_II_last_m;
MCNUM W = mccCurved_Guide_Section_II_last_W;
MCNUM nslit = mccCurved_Guide_Section_II_last_nslit;
MCNUM d = mccCurved_Guide_Section_II_last_d;
MCNUM mleft = mccCurved_Guide_Section_II_last_mleft;
MCNUM mright = mccCurved_Guide_Section_II_last_mright;
MCNUM mtop = mccCurved_Guide_Section_II_last_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_last_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_last_nhslit;
MCNUM G = mccCurved_Guide_Section_II_last_G;
MCNUM aleft = mccCurved_Guide_Section_II_last_aleft;
MCNUM aright = mccCurved_Guide_Section_II_last_aright;
MCNUM atop = mccCurved_Guide_Section_II_last_atop;
MCNUM abottom = mccCurved_Guide_Section_II_last_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_last_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_last_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_last_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_last_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_last_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_last_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_last_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_last_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_last_nelements;
MCNUM nu = mccCurved_Guide_Section_II_last_nu;
MCNUM phase = mccCurved_Guide_Section_II_last_phase;
char* reflect = mccCurved_Guide_Section_II_last_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 57754 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II_last=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_II_last:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(58,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap4_start [59] */
  mccoordschange(mcposrGap4_start, mcrotrGap4_start,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap4_start (without coords transformations) */
  mcJumpTrace_Gap4_start:
  SIG_MESSAGE("Gap4_start (Trace)");
  mcDEBUG_COMP("Gap4_start")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap4_start
  STORE_NEUTRON(59,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[59]++;
  mcPCounter[59] += p;
  mcP2Counter[59] += p*p;
#define mccompcurname  Gap4_start
#define mccompcurtype  Arm
#define mccompcurindex 59
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap4_start:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(59,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap4_start_Lam [60] */
  mccoordschange(mcposrGap4_start_Lam, mcrotrGap4_start_Lam,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap4_start_Lam (without coords transformations) */
  mcJumpTrace_Gap4_start_Lam:
  SIG_MESSAGE("Gap4_start_Lam (Trace)");
  mcDEBUG_COMP("Gap4_start_Lam")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap4_start_Lam
  STORE_NEUTRON(60,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[60]++;
  mcPCounter[60] += p;
  mcP2Counter[60] += p*p;
#define mccompcurname  Gap4_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 60
#define nL mccGap4_start_Lam_nL
#define L_N mccGap4_start_Lam_L_N
#define L_p mccGap4_start_Lam_L_p
#define L_p2 mccGap4_start_Lam_L_p2
{   /* Declarations of Gap4_start_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap4_start_Lam_filename;
MCNUM xmin = mccGap4_start_Lam_xmin;
MCNUM xmax = mccGap4_start_Lam_xmax;
MCNUM ymin = mccGap4_start_Lam_ymin;
MCNUM ymax = mccGap4_start_Lam_ymax;
MCNUM xwidth = mccGap4_start_Lam_xwidth;
MCNUM yheight = mccGap4_start_Lam_yheight;
MCNUM Lmin = mccGap4_start_Lam_Lmin;
MCNUM Lmax = mccGap4_start_Lam_Lmax;
MCNUM restore_neutron = mccGap4_start_Lam_restore_neutron;
int nowritefile = mccGap4_start_Lam_nowritefile;
#line 84 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 58002 "./SNS_BASIS.c"
}   /* End of Gap4_start_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap4_start_Lam:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(60,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap4_start_PSD [61] */
  mccoordschange(mcposrGap4_start_PSD, mcrotrGap4_start_PSD,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap4_start_PSD (without coords transformations) */
  mcJumpTrace_Gap4_start_PSD:
  SIG_MESSAGE("Gap4_start_PSD (Trace)");
  mcDEBUG_COMP("Gap4_start_PSD")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap4_start_PSD
  STORE_NEUTRON(61,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[61]++;
  mcPCounter[61] += p;
  mcP2Counter[61] += p*p;
#define mccompcurname  Gap4_start_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 61
#define PSD_N mccGap4_start_PSD_PSD_N
#define PSD_p mccGap4_start_PSD_PSD_p
#define PSD_p2 mccGap4_start_PSD_PSD_p2
{   /* Declarations of Gap4_start_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap4_start_PSD_nx;
int ny = mccGap4_start_PSD_ny;
char* filename = mccGap4_start_PSD_filename;
MCNUM xmin = mccGap4_start_PSD_xmin;
MCNUM xmax = mccGap4_start_PSD_xmax;
MCNUM ymin = mccGap4_start_PSD_ymin;
MCNUM ymax = mccGap4_start_PSD_ymax;
MCNUM xwidth = mccGap4_start_PSD_xwidth;
MCNUM yheight = mccGap4_start_PSD_yheight;
MCNUM restore_neutron = mccGap4_start_PSD_restore_neutron;
#line 94 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  PROP_Z0;
  if (x>xmin && x<xmax && y>ymin && y<ymax){
    int i = floor((x - xmin)*nx/(xmax - xmin));
    int j = floor((y - ymin)*ny/(ymax - ymin));
    PSD_N[i][j]++;
    PSD_p[i][j] += p;
    PSD_p2[i][j] += p*p;
    SCATTER;
  }
  if (restore_neutron) {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 58140 "./SNS_BASIS.c"
}   /* End of Gap4_start_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap4_start_PSD:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(61,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component before_Chopper2_ToF [62] */
  mccoordschange(mcposrbefore_Chopper2_ToF, mcrotrbefore_Chopper2_ToF,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component before_Chopper2_ToF (without coords transformations) */
  mcJumpTrace_before_Chopper2_ToF:
  SIG_MESSAGE("before_Chopper2_ToF (Trace)");
  mcDEBUG_COMP("before_Chopper2_ToF")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompbefore_Chopper2_ToF
  STORE_NEUTRON(62,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[62]++;
  mcPCounter[62] += p;
  mcP2Counter[62] += p*p;
#define mccompcurname  before_Chopper2_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 62
#define nt mccbefore_Chopper2_ToF_nt
#define TOF_N mccbefore_Chopper2_ToF_TOF_N
#define TOF_p mccbefore_Chopper2_ToF_TOF_p
#define TOF_p2 mccbefore_Chopper2_ToF_TOF_p2
#define t_min mccbefore_Chopper2_ToF_t_min
#define t_max mccbefore_Chopper2_ToF_t_max
#define delta_t mccbefore_Chopper2_ToF_delta_t
{   /* Declarations of before_Chopper2_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccbefore_Chopper2_ToF_filename;
MCNUM xmin = mccbefore_Chopper2_ToF_xmin;
MCNUM xmax = mccbefore_Chopper2_ToF_xmax;
MCNUM ymin = mccbefore_Chopper2_ToF_ymin;
MCNUM ymax = mccbefore_Chopper2_ToF_ymax;
MCNUM xwidth = mccbefore_Chopper2_ToF_xwidth;
MCNUM yheight = mccbefore_Chopper2_ToF_yheight;
MCNUM tmin = mccbefore_Chopper2_ToF_tmin;
MCNUM tmax = mccbefore_Chopper2_ToF_tmax;
MCNUM dt = mccbefore_Chopper2_ToF_dt;
MCNUM restore_neutron = mccbefore_Chopper2_ToF_restore_neutron;
int nowritefile = mccbefore_Chopper2_ToF_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 58287 "./SNS_BASIS.c"
}   /* End of before_Chopper2_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompbefore_Chopper2_ToF:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(62,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component before_Chopper2_ToF_Z [63] */
  mccoordschange(mcposrbefore_Chopper2_ToF_Z, mcrotrbefore_Chopper2_ToF_Z,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component before_Chopper2_ToF_Z (without coords transformations) */
  mcJumpTrace_before_Chopper2_ToF_Z:
  SIG_MESSAGE("before_Chopper2_ToF_Z (Trace)");
  mcDEBUG_COMP("before_Chopper2_ToF_Z")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompbefore_Chopper2_ToF_Z
  STORE_NEUTRON(63,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[63]++;
  mcPCounter[63] += p;
  mcP2Counter[63] += p*p;
#define mccompcurname  before_Chopper2_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 63
#define nt mccbefore_Chopper2_ToF_Z_nt
#define TOF_N mccbefore_Chopper2_ToF_Z_TOF_N
#define TOF_p mccbefore_Chopper2_ToF_Z_TOF_p
#define TOF_p2 mccbefore_Chopper2_ToF_Z_TOF_p2
#define t_min mccbefore_Chopper2_ToF_Z_t_min
#define t_max mccbefore_Chopper2_ToF_Z_t_max
#define delta_t mccbefore_Chopper2_ToF_Z_delta_t
{   /* Declarations of before_Chopper2_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccbefore_Chopper2_ToF_Z_filename;
MCNUM xmin = mccbefore_Chopper2_ToF_Z_xmin;
MCNUM xmax = mccbefore_Chopper2_ToF_Z_xmax;
MCNUM ymin = mccbefore_Chopper2_ToF_Z_ymin;
MCNUM ymax = mccbefore_Chopper2_ToF_Z_ymax;
MCNUM xwidth = mccbefore_Chopper2_ToF_Z_xwidth;
MCNUM yheight = mccbefore_Chopper2_ToF_Z_yheight;
MCNUM tmin = mccbefore_Chopper2_ToF_Z_tmin;
MCNUM tmax = mccbefore_Chopper2_ToF_Z_tmax;
MCNUM dt = mccbefore_Chopper2_ToF_Z_dt;
MCNUM restore_neutron = mccbefore_Chopper2_ToF_Z_restore_neutron;
int nowritefile = mccbefore_Chopper2_ToF_Z_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 58438 "./SNS_BASIS.c"
}   /* End of before_Chopper2_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompbefore_Chopper2_ToF_Z:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(63,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Chopper2 [64] */
  mccoordschange(mcposrChopper2, mcrotrChopper2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Chopper2 (without coords transformations) */
  mcJumpTrace_Chopper2:
  SIG_MESSAGE("Chopper2 (Trace)");
  mcDEBUG_COMP("Chopper2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompChopper2
  STORE_NEUTRON(64,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[64]++;
  mcPCounter[64] += p;
  mcP2Counter[64] += p*p;
#define mccompcurname  Chopper2
#define mccompcurtype  DiskChopper
#define mccompcurindex 64
#define Tg mccChopper2_Tg
#define To mccChopper2_To
#define delta_y mccChopper2_delta_y
#define height mccChopper2_height
#define omega mccChopper2_omega
{   /* Declarations of Chopper2=DiskChopper() SETTING parameters. */
MCNUM theta_0 = mccChopper2_theta_0;
MCNUM radius = mccChopper2_radius;
MCNUM yheight = mccChopper2_yheight;
MCNUM nu = mccChopper2_nu;
MCNUM nslit = mccChopper2_nslit;
MCNUM jitter = mccChopper2_jitter;
MCNUM delay = mccChopper2_delay;
MCNUM isfirst = mccChopper2_isfirst;
MCNUM n_pulse = mccChopper2_n_pulse;
MCNUM abs_out = mccChopper2_abs_out;
MCNUM phase = mccChopper2_phase;
MCNUM xwidth = mccChopper2_xwidth;
MCNUM verbose = mccChopper2_verbose;
/* 'Chopper2=DiskChopper()' component instance has conditional execution */
if (( Omega2 > 0 ))

#line 133 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/DiskChopper.comp"
{
    double toff;
    double yprime;
    PROP_Z0;
    yprime = y+delta_y;

    /* Is neutron outside the vertical slit range and should we absorb? */
    if (abs_out && (x*x+yprime*yprime)>radius*radius) {
      ABSORB;
    }
    /* Does neutron hit inner solid part of chopper in case of yheight!=radius? */
    if ((x*x+yprime*yprime)<(radius-height)*(radius-height)) {
      ABSORB;
    }


    if (isfirst)
      {
        /* all events are put in the transmitted time frame */
        t=atan2(x,yprime)/omega + To*randpm1()/2.0 + delay + (jitter ? jitter*randnorm():0) + (n_pulse > 1 ? floor(n_pulse*rand01())*Tg : 0);
        /* correction: chopper slits transmission opening/full disk */
        p *= nslit*theta_0/2.0/PI;
      }
    else
      {
        toff=fabs(t-atan2(x,yprime)/omega - delay - (jitter ? jitter*randnorm():0));

        /* does neutron hit outside slit? */
        if (fmod(toff+To/2.0,Tg)>To) ABSORB;
      }
    SCATTER;

}
#line 58605 "./SNS_BASIS.c"
}   /* End of Chopper2=DiskChopper() SETTING parameter declarations. */
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompChopper2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(64,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Chopper2_ToF [65] */
  mccoordschange(mcposrChopper2_ToF, mcrotrChopper2_ToF,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Chopper2_ToF (without coords transformations) */
  mcJumpTrace_Chopper2_ToF:
  SIG_MESSAGE("Chopper2_ToF (Trace)");
  mcDEBUG_COMP("Chopper2_ToF")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompChopper2_ToF
  STORE_NEUTRON(65,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[65]++;
  mcPCounter[65] += p;
  mcP2Counter[65] += p*p;
#define mccompcurname  Chopper2_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 65
#define nt mccChopper2_ToF_nt
#define TOF_N mccChopper2_ToF_TOF_N
#define TOF_p mccChopper2_ToF_TOF_p
#define TOF_p2 mccChopper2_ToF_TOF_p2
#define t_min mccChopper2_ToF_t_min
#define t_max mccChopper2_ToF_t_max
#define delta_t mccChopper2_ToF_delta_t
{   /* Declarations of Chopper2_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccChopper2_ToF_filename;
MCNUM xmin = mccChopper2_ToF_xmin;
MCNUM xmax = mccChopper2_ToF_xmax;
MCNUM ymin = mccChopper2_ToF_ymin;
MCNUM ymax = mccChopper2_ToF_ymax;
MCNUM xwidth = mccChopper2_ToF_xwidth;
MCNUM yheight = mccChopper2_ToF_yheight;
MCNUM tmin = mccChopper2_ToF_tmin;
MCNUM tmax = mccChopper2_ToF_tmax;
MCNUM dt = mccChopper2_ToF_dt;
MCNUM restore_neutron = mccChopper2_ToF_restore_neutron;
int nowritefile = mccChopper2_ToF_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 58754 "./SNS_BASIS.c"
}   /* End of Chopper2_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompChopper2_ToF:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(65,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Chopper2_ToF_Z [66] */
  mccoordschange(mcposrChopper2_ToF_Z, mcrotrChopper2_ToF_Z,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Chopper2_ToF_Z (without coords transformations) */
  mcJumpTrace_Chopper2_ToF_Z:
  SIG_MESSAGE("Chopper2_ToF_Z (Trace)");
  mcDEBUG_COMP("Chopper2_ToF_Z")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompChopper2_ToF_Z
  STORE_NEUTRON(66,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[66]++;
  mcPCounter[66] += p;
  mcP2Counter[66] += p*p;
#define mccompcurname  Chopper2_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 66
#define nt mccChopper2_ToF_Z_nt
#define TOF_N mccChopper2_ToF_Z_TOF_N
#define TOF_p mccChopper2_ToF_Z_TOF_p
#define TOF_p2 mccChopper2_ToF_Z_TOF_p2
#define t_min mccChopper2_ToF_Z_t_min
#define t_max mccChopper2_ToF_Z_t_max
#define delta_t mccChopper2_ToF_Z_delta_t
{   /* Declarations of Chopper2_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccChopper2_ToF_Z_filename;
MCNUM xmin = mccChopper2_ToF_Z_xmin;
MCNUM xmax = mccChopper2_ToF_Z_xmax;
MCNUM ymin = mccChopper2_ToF_Z_ymin;
MCNUM ymax = mccChopper2_ToF_Z_ymax;
MCNUM xwidth = mccChopper2_ToF_Z_xwidth;
MCNUM yheight = mccChopper2_ToF_Z_yheight;
MCNUM tmin = mccChopper2_ToF_Z_tmin;
MCNUM tmax = mccChopper2_ToF_Z_tmax;
MCNUM dt = mccChopper2_ToF_Z_dt;
MCNUM restore_neutron = mccChopper2_ToF_Z_restore_neutron;
int nowritefile = mccChopper2_ToF_Z_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 58905 "./SNS_BASIS.c"
}   /* End of Chopper2_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompChopper2_ToF_Z:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(66,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap4_end_Lam [67] */
  mccoordschange(mcposrGap4_end_Lam, mcrotrGap4_end_Lam,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap4_end_Lam (without coords transformations) */
  mcJumpTrace_Gap4_end_Lam:
  SIG_MESSAGE("Gap4_end_Lam (Trace)");
  mcDEBUG_COMP("Gap4_end_Lam")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap4_end_Lam
  STORE_NEUTRON(67,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[67]++;
  mcPCounter[67] += p;
  mcP2Counter[67] += p*p;
#define mccompcurname  Gap4_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 67
#define nL mccGap4_end_Lam_nL
#define L_N mccGap4_end_Lam_L_N
#define L_p mccGap4_end_Lam_L_p
#define L_p2 mccGap4_end_Lam_L_p2
{   /* Declarations of Gap4_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap4_end_Lam_filename;
MCNUM xmin = mccGap4_end_Lam_xmin;
MCNUM xmax = mccGap4_end_Lam_xmax;
MCNUM ymin = mccGap4_end_Lam_ymin;
MCNUM ymax = mccGap4_end_Lam_ymax;
MCNUM xwidth = mccGap4_end_Lam_xwidth;
MCNUM yheight = mccGap4_end_Lam_yheight;
MCNUM Lmin = mccGap4_end_Lam_Lmin;
MCNUM Lmax = mccGap4_end_Lam_Lmax;
MCNUM restore_neutron = mccGap4_end_Lam_restore_neutron;
int nowritefile = mccGap4_end_Lam_nowritefile;
#line 84 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 59055 "./SNS_BASIS.c"
}   /* End of Gap4_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap4_end_Lam:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(67,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap4_end_PSD [68] */
  mccoordschange(mcposrGap4_end_PSD, mcrotrGap4_end_PSD,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap4_end_PSD (without coords transformations) */
  mcJumpTrace_Gap4_end_PSD:
  SIG_MESSAGE("Gap4_end_PSD (Trace)");
  mcDEBUG_COMP("Gap4_end_PSD")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap4_end_PSD
  STORE_NEUTRON(68,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[68]++;
  mcPCounter[68] += p;
  mcP2Counter[68] += p*p;
#define mccompcurname  Gap4_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 68
#define PSD_N mccGap4_end_PSD_PSD_N
#define PSD_p mccGap4_end_PSD_PSD_p
#define PSD_p2 mccGap4_end_PSD_PSD_p2
{   /* Declarations of Gap4_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap4_end_PSD_nx;
int ny = mccGap4_end_PSD_ny;
char* filename = mccGap4_end_PSD_filename;
MCNUM xmin = mccGap4_end_PSD_xmin;
MCNUM xmax = mccGap4_end_PSD_xmax;
MCNUM ymin = mccGap4_end_PSD_ymin;
MCNUM ymax = mccGap4_end_PSD_ymax;
MCNUM xwidth = mccGap4_end_PSD_xwidth;
MCNUM yheight = mccGap4_end_PSD_yheight;
MCNUM restore_neutron = mccGap4_end_PSD_restore_neutron;
#line 94 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  PROP_Z0;
  if (x>xmin && x<xmax && y>ymin && y<ymax){
    int i = floor((x - xmin)*nx/(xmax - xmin));
    int j = floor((y - ymin)*ny/(ymax - ymin));
    PSD_N[i][j]++;
    PSD_p[i][j] += p;
    PSD_p2[i][j] += p*p;
    SCATTER;
  }
  if (restore_neutron) {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 59193 "./SNS_BASIS.c"
}   /* End of Gap4_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap4_end_PSD:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(68,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap4_end [69] */
  mccoordschange(mcposrGap4_end, mcrotrGap4_end,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap4_end (without coords transformations) */
  mcJumpTrace_Gap4_end:
  SIG_MESSAGE("Gap4_end (Trace)");
  mcDEBUG_COMP("Gap4_end")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap4_end
  STORE_NEUTRON(69,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[69]++;
  mcPCounter[69] += p;
  mcP2Counter[69] += p*p;
#define mccompcurname  Gap4_end
#define mccompcurtype  Arm
#define mccompcurindex 69
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap4_end:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(69,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_III [70] */
  mccoordschange(mcposrCurved_Guide_Section_III, mcrotrCurved_Guide_Section_III,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_III (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_III:
  SIG_MESSAGE("Curved_Guide_Section_III (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_III")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_III
  STORE_NEUTRON(70,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[70]++;
  mcPCounter[70] += p;
  mcP2Counter[70] += p*p;
#define mccompcurname  Curved_Guide_Section_III
#define mccompcurtype  Guide_gravity
#define mccompcurindex 70
#define GVars mccCurved_Guide_Section_III_GVars
#define pTable mccCurved_Guide_Section_III_pTable
{   /* Declarations of Curved_Guide_Section_III=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_w1;
MCNUM h1 = mccCurved_Guide_Section_III_h1;
MCNUM w2 = mccCurved_Guide_Section_III_w2;
MCNUM h2 = mccCurved_Guide_Section_III_h2;
MCNUM l = mccCurved_Guide_Section_III_l;
MCNUM R0 = mccCurved_Guide_Section_III_R0;
MCNUM Qc = mccCurved_Guide_Section_III_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_alpha;
MCNUM m = mccCurved_Guide_Section_III_m;
MCNUM W = mccCurved_Guide_Section_III_W;
MCNUM nslit = mccCurved_Guide_Section_III_nslit;
MCNUM d = mccCurved_Guide_Section_III_d;
MCNUM mleft = mccCurved_Guide_Section_III_mleft;
MCNUM mright = mccCurved_Guide_Section_III_mright;
MCNUM mtop = mccCurved_Guide_Section_III_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_nhslit;
MCNUM G = mccCurved_Guide_Section_III_G;
MCNUM aleft = mccCurved_Guide_Section_III_aleft;
MCNUM aright = mccCurved_Guide_Section_III_aright;
MCNUM atop = mccCurved_Guide_Section_III_atop;
MCNUM abottom = mccCurved_Guide_Section_III_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_nelements;
MCNUM nu = mccCurved_Guide_Section_III_nu;
MCNUM phase = mccCurved_Guide_Section_III_phase;
char* reflect = mccCurved_Guide_Section_III_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 59610 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_III:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(70,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_III_71 [71] */
  mccoordschange(mcposrCurved_Guide_Section_III_71, mcrotrCurved_Guide_Section_III_71,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_III_71 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_III_71:
  SIG_MESSAGE("Curved_Guide_Section_III_71 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_III_71")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_III_71
  STORE_NEUTRON(71,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[71]++;
  mcPCounter[71] += p;
  mcP2Counter[71] += p*p;
#define mccompcurname  Curved_Guide_Section_III_71
#define mccompcurtype  Guide_gravity
#define mccompcurindex 71
#define GVars mccCurved_Guide_Section_III_71_GVars
#define pTable mccCurved_Guide_Section_III_71_pTable
{   /* Declarations of Curved_Guide_Section_III_71=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_71_w1;
MCNUM h1 = mccCurved_Guide_Section_III_71_h1;
MCNUM w2 = mccCurved_Guide_Section_III_71_w2;
MCNUM h2 = mccCurved_Guide_Section_III_71_h2;
MCNUM l = mccCurved_Guide_Section_III_71_l;
MCNUM R0 = mccCurved_Guide_Section_III_71_R0;
MCNUM Qc = mccCurved_Guide_Section_III_71_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_71_alpha;
MCNUM m = mccCurved_Guide_Section_III_71_m;
MCNUM W = mccCurved_Guide_Section_III_71_W;
MCNUM nslit = mccCurved_Guide_Section_III_71_nslit;
MCNUM d = mccCurved_Guide_Section_III_71_d;
MCNUM mleft = mccCurved_Guide_Section_III_71_mleft;
MCNUM mright = mccCurved_Guide_Section_III_71_mright;
MCNUM mtop = mccCurved_Guide_Section_III_71_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_71_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_71_nhslit;
MCNUM G = mccCurved_Guide_Section_III_71_G;
MCNUM aleft = mccCurved_Guide_Section_III_71_aleft;
MCNUM aright = mccCurved_Guide_Section_III_71_aright;
MCNUM atop = mccCurved_Guide_Section_III_71_atop;
MCNUM abottom = mccCurved_Guide_Section_III_71_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_71_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_71_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_71_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_71_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_71_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_71_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_71_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_71_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_71_nelements;
MCNUM nu = mccCurved_Guide_Section_III_71_nu;
MCNUM phase = mccCurved_Guide_Section_III_71_phase;
char* reflect = mccCurved_Guide_Section_III_71_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 59923 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_71=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_III_71:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(71,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_III_72 [72] */
  mccoordschange(mcposrCurved_Guide_Section_III_72, mcrotrCurved_Guide_Section_III_72,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_III_72 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_III_72:
  SIG_MESSAGE("Curved_Guide_Section_III_72 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_III_72")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_III_72
  STORE_NEUTRON(72,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[72]++;
  mcPCounter[72] += p;
  mcP2Counter[72] += p*p;
#define mccompcurname  Curved_Guide_Section_III_72
#define mccompcurtype  Guide_gravity
#define mccompcurindex 72
#define GVars mccCurved_Guide_Section_III_72_GVars
#define pTable mccCurved_Guide_Section_III_72_pTable
{   /* Declarations of Curved_Guide_Section_III_72=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_72_w1;
MCNUM h1 = mccCurved_Guide_Section_III_72_h1;
MCNUM w2 = mccCurved_Guide_Section_III_72_w2;
MCNUM h2 = mccCurved_Guide_Section_III_72_h2;
MCNUM l = mccCurved_Guide_Section_III_72_l;
MCNUM R0 = mccCurved_Guide_Section_III_72_R0;
MCNUM Qc = mccCurved_Guide_Section_III_72_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_72_alpha;
MCNUM m = mccCurved_Guide_Section_III_72_m;
MCNUM W = mccCurved_Guide_Section_III_72_W;
MCNUM nslit = mccCurved_Guide_Section_III_72_nslit;
MCNUM d = mccCurved_Guide_Section_III_72_d;
MCNUM mleft = mccCurved_Guide_Section_III_72_mleft;
MCNUM mright = mccCurved_Guide_Section_III_72_mright;
MCNUM mtop = mccCurved_Guide_Section_III_72_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_72_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_72_nhslit;
MCNUM G = mccCurved_Guide_Section_III_72_G;
MCNUM aleft = mccCurved_Guide_Section_III_72_aleft;
MCNUM aright = mccCurved_Guide_Section_III_72_aright;
MCNUM atop = mccCurved_Guide_Section_III_72_atop;
MCNUM abottom = mccCurved_Guide_Section_III_72_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_72_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_72_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_72_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_72_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_72_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_72_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_72_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_72_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_72_nelements;
MCNUM nu = mccCurved_Guide_Section_III_72_nu;
MCNUM phase = mccCurved_Guide_Section_III_72_phase;
char* reflect = mccCurved_Guide_Section_III_72_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 60236 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_72=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_III_72:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(72,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_III_73 [73] */
  mccoordschange(mcposrCurved_Guide_Section_III_73, mcrotrCurved_Guide_Section_III_73,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_III_73 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_III_73:
  SIG_MESSAGE("Curved_Guide_Section_III_73 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_III_73")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_III_73
  STORE_NEUTRON(73,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[73]++;
  mcPCounter[73] += p;
  mcP2Counter[73] += p*p;
#define mccompcurname  Curved_Guide_Section_III_73
#define mccompcurtype  Guide_gravity
#define mccompcurindex 73
#define GVars mccCurved_Guide_Section_III_73_GVars
#define pTable mccCurved_Guide_Section_III_73_pTable
{   /* Declarations of Curved_Guide_Section_III_73=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_73_w1;
MCNUM h1 = mccCurved_Guide_Section_III_73_h1;
MCNUM w2 = mccCurved_Guide_Section_III_73_w2;
MCNUM h2 = mccCurved_Guide_Section_III_73_h2;
MCNUM l = mccCurved_Guide_Section_III_73_l;
MCNUM R0 = mccCurved_Guide_Section_III_73_R0;
MCNUM Qc = mccCurved_Guide_Section_III_73_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_73_alpha;
MCNUM m = mccCurved_Guide_Section_III_73_m;
MCNUM W = mccCurved_Guide_Section_III_73_W;
MCNUM nslit = mccCurved_Guide_Section_III_73_nslit;
MCNUM d = mccCurved_Guide_Section_III_73_d;
MCNUM mleft = mccCurved_Guide_Section_III_73_mleft;
MCNUM mright = mccCurved_Guide_Section_III_73_mright;
MCNUM mtop = mccCurved_Guide_Section_III_73_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_73_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_73_nhslit;
MCNUM G = mccCurved_Guide_Section_III_73_G;
MCNUM aleft = mccCurved_Guide_Section_III_73_aleft;
MCNUM aright = mccCurved_Guide_Section_III_73_aright;
MCNUM atop = mccCurved_Guide_Section_III_73_atop;
MCNUM abottom = mccCurved_Guide_Section_III_73_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_73_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_73_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_73_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_73_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_73_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_73_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_73_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_73_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_73_nelements;
MCNUM nu = mccCurved_Guide_Section_III_73_nu;
MCNUM phase = mccCurved_Guide_Section_III_73_phase;
char* reflect = mccCurved_Guide_Section_III_73_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 60549 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_73=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_III_73:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(73,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_III_74 [74] */
  mccoordschange(mcposrCurved_Guide_Section_III_74, mcrotrCurved_Guide_Section_III_74,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_III_74 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_III_74:
  SIG_MESSAGE("Curved_Guide_Section_III_74 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_III_74")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_III_74
  STORE_NEUTRON(74,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[74]++;
  mcPCounter[74] += p;
  mcP2Counter[74] += p*p;
#define mccompcurname  Curved_Guide_Section_III_74
#define mccompcurtype  Guide_gravity
#define mccompcurindex 74
#define GVars mccCurved_Guide_Section_III_74_GVars
#define pTable mccCurved_Guide_Section_III_74_pTable
{   /* Declarations of Curved_Guide_Section_III_74=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_74_w1;
MCNUM h1 = mccCurved_Guide_Section_III_74_h1;
MCNUM w2 = mccCurved_Guide_Section_III_74_w2;
MCNUM h2 = mccCurved_Guide_Section_III_74_h2;
MCNUM l = mccCurved_Guide_Section_III_74_l;
MCNUM R0 = mccCurved_Guide_Section_III_74_R0;
MCNUM Qc = mccCurved_Guide_Section_III_74_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_74_alpha;
MCNUM m = mccCurved_Guide_Section_III_74_m;
MCNUM W = mccCurved_Guide_Section_III_74_W;
MCNUM nslit = mccCurved_Guide_Section_III_74_nslit;
MCNUM d = mccCurved_Guide_Section_III_74_d;
MCNUM mleft = mccCurved_Guide_Section_III_74_mleft;
MCNUM mright = mccCurved_Guide_Section_III_74_mright;
MCNUM mtop = mccCurved_Guide_Section_III_74_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_74_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_74_nhslit;
MCNUM G = mccCurved_Guide_Section_III_74_G;
MCNUM aleft = mccCurved_Guide_Section_III_74_aleft;
MCNUM aright = mccCurved_Guide_Section_III_74_aright;
MCNUM atop = mccCurved_Guide_Section_III_74_atop;
MCNUM abottom = mccCurved_Guide_Section_III_74_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_74_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_74_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_74_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_74_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_74_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_74_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_74_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_74_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_74_nelements;
MCNUM nu = mccCurved_Guide_Section_III_74_nu;
MCNUM phase = mccCurved_Guide_Section_III_74_phase;
char* reflect = mccCurved_Guide_Section_III_74_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 60862 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_74=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_III_74:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(74,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_III_75 [75] */
  mccoordschange(mcposrCurved_Guide_Section_III_75, mcrotrCurved_Guide_Section_III_75,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_III_75 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_III_75:
  SIG_MESSAGE("Curved_Guide_Section_III_75 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_III_75")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_III_75
  STORE_NEUTRON(75,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[75]++;
  mcPCounter[75] += p;
  mcP2Counter[75] += p*p;
#define mccompcurname  Curved_Guide_Section_III_75
#define mccompcurtype  Guide_gravity
#define mccompcurindex 75
#define GVars mccCurved_Guide_Section_III_75_GVars
#define pTable mccCurved_Guide_Section_III_75_pTable
{   /* Declarations of Curved_Guide_Section_III_75=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_75_w1;
MCNUM h1 = mccCurved_Guide_Section_III_75_h1;
MCNUM w2 = mccCurved_Guide_Section_III_75_w2;
MCNUM h2 = mccCurved_Guide_Section_III_75_h2;
MCNUM l = mccCurved_Guide_Section_III_75_l;
MCNUM R0 = mccCurved_Guide_Section_III_75_R0;
MCNUM Qc = mccCurved_Guide_Section_III_75_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_75_alpha;
MCNUM m = mccCurved_Guide_Section_III_75_m;
MCNUM W = mccCurved_Guide_Section_III_75_W;
MCNUM nslit = mccCurved_Guide_Section_III_75_nslit;
MCNUM d = mccCurved_Guide_Section_III_75_d;
MCNUM mleft = mccCurved_Guide_Section_III_75_mleft;
MCNUM mright = mccCurved_Guide_Section_III_75_mright;
MCNUM mtop = mccCurved_Guide_Section_III_75_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_75_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_75_nhslit;
MCNUM G = mccCurved_Guide_Section_III_75_G;
MCNUM aleft = mccCurved_Guide_Section_III_75_aleft;
MCNUM aright = mccCurved_Guide_Section_III_75_aright;
MCNUM atop = mccCurved_Guide_Section_III_75_atop;
MCNUM abottom = mccCurved_Guide_Section_III_75_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_75_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_75_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_75_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_75_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_75_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_75_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_75_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_75_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_75_nelements;
MCNUM nu = mccCurved_Guide_Section_III_75_nu;
MCNUM phase = mccCurved_Guide_Section_III_75_phase;
char* reflect = mccCurved_Guide_Section_III_75_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 61175 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_75=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_III_75:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(75,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_III_76 [76] */
  mccoordschange(mcposrCurved_Guide_Section_III_76, mcrotrCurved_Guide_Section_III_76,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_III_76 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_III_76:
  SIG_MESSAGE("Curved_Guide_Section_III_76 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_III_76")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_III_76
  STORE_NEUTRON(76,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[76]++;
  mcPCounter[76] += p;
  mcP2Counter[76] += p*p;
#define mccompcurname  Curved_Guide_Section_III_76
#define mccompcurtype  Guide_gravity
#define mccompcurindex 76
#define GVars mccCurved_Guide_Section_III_76_GVars
#define pTable mccCurved_Guide_Section_III_76_pTable
{   /* Declarations of Curved_Guide_Section_III_76=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_76_w1;
MCNUM h1 = mccCurved_Guide_Section_III_76_h1;
MCNUM w2 = mccCurved_Guide_Section_III_76_w2;
MCNUM h2 = mccCurved_Guide_Section_III_76_h2;
MCNUM l = mccCurved_Guide_Section_III_76_l;
MCNUM R0 = mccCurved_Guide_Section_III_76_R0;
MCNUM Qc = mccCurved_Guide_Section_III_76_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_76_alpha;
MCNUM m = mccCurved_Guide_Section_III_76_m;
MCNUM W = mccCurved_Guide_Section_III_76_W;
MCNUM nslit = mccCurved_Guide_Section_III_76_nslit;
MCNUM d = mccCurved_Guide_Section_III_76_d;
MCNUM mleft = mccCurved_Guide_Section_III_76_mleft;
MCNUM mright = mccCurved_Guide_Section_III_76_mright;
MCNUM mtop = mccCurved_Guide_Section_III_76_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_76_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_76_nhslit;
MCNUM G = mccCurved_Guide_Section_III_76_G;
MCNUM aleft = mccCurved_Guide_Section_III_76_aleft;
MCNUM aright = mccCurved_Guide_Section_III_76_aright;
MCNUM atop = mccCurved_Guide_Section_III_76_atop;
MCNUM abottom = mccCurved_Guide_Section_III_76_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_76_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_76_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_76_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_76_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_76_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_76_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_76_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_76_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_76_nelements;
MCNUM nu = mccCurved_Guide_Section_III_76_nu;
MCNUM phase = mccCurved_Guide_Section_III_76_phase;
char* reflect = mccCurved_Guide_Section_III_76_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 61488 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_76=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_III_76:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(76,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_III_77 [77] */
  mccoordschange(mcposrCurved_Guide_Section_III_77, mcrotrCurved_Guide_Section_III_77,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_III_77 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_III_77:
  SIG_MESSAGE("Curved_Guide_Section_III_77 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_III_77")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_III_77
  STORE_NEUTRON(77,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[77]++;
  mcPCounter[77] += p;
  mcP2Counter[77] += p*p;
#define mccompcurname  Curved_Guide_Section_III_77
#define mccompcurtype  Guide_gravity
#define mccompcurindex 77
#define GVars mccCurved_Guide_Section_III_77_GVars
#define pTable mccCurved_Guide_Section_III_77_pTable
{   /* Declarations of Curved_Guide_Section_III_77=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_77_w1;
MCNUM h1 = mccCurved_Guide_Section_III_77_h1;
MCNUM w2 = mccCurved_Guide_Section_III_77_w2;
MCNUM h2 = mccCurved_Guide_Section_III_77_h2;
MCNUM l = mccCurved_Guide_Section_III_77_l;
MCNUM R0 = mccCurved_Guide_Section_III_77_R0;
MCNUM Qc = mccCurved_Guide_Section_III_77_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_77_alpha;
MCNUM m = mccCurved_Guide_Section_III_77_m;
MCNUM W = mccCurved_Guide_Section_III_77_W;
MCNUM nslit = mccCurved_Guide_Section_III_77_nslit;
MCNUM d = mccCurved_Guide_Section_III_77_d;
MCNUM mleft = mccCurved_Guide_Section_III_77_mleft;
MCNUM mright = mccCurved_Guide_Section_III_77_mright;
MCNUM mtop = mccCurved_Guide_Section_III_77_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_77_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_77_nhslit;
MCNUM G = mccCurved_Guide_Section_III_77_G;
MCNUM aleft = mccCurved_Guide_Section_III_77_aleft;
MCNUM aright = mccCurved_Guide_Section_III_77_aright;
MCNUM atop = mccCurved_Guide_Section_III_77_atop;
MCNUM abottom = mccCurved_Guide_Section_III_77_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_77_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_77_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_77_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_77_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_77_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_77_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_77_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_77_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_77_nelements;
MCNUM nu = mccCurved_Guide_Section_III_77_nu;
MCNUM phase = mccCurved_Guide_Section_III_77_phase;
char* reflect = mccCurved_Guide_Section_III_77_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 61801 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_77=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_III_77:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(77,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_III_78 [78] */
  mccoordschange(mcposrCurved_Guide_Section_III_78, mcrotrCurved_Guide_Section_III_78,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_III_78 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_III_78:
  SIG_MESSAGE("Curved_Guide_Section_III_78 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_III_78")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_III_78
  STORE_NEUTRON(78,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[78]++;
  mcPCounter[78] += p;
  mcP2Counter[78] += p*p;
#define mccompcurname  Curved_Guide_Section_III_78
#define mccompcurtype  Guide_gravity
#define mccompcurindex 78
#define GVars mccCurved_Guide_Section_III_78_GVars
#define pTable mccCurved_Guide_Section_III_78_pTable
{   /* Declarations of Curved_Guide_Section_III_78=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_78_w1;
MCNUM h1 = mccCurved_Guide_Section_III_78_h1;
MCNUM w2 = mccCurved_Guide_Section_III_78_w2;
MCNUM h2 = mccCurved_Guide_Section_III_78_h2;
MCNUM l = mccCurved_Guide_Section_III_78_l;
MCNUM R0 = mccCurved_Guide_Section_III_78_R0;
MCNUM Qc = mccCurved_Guide_Section_III_78_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_78_alpha;
MCNUM m = mccCurved_Guide_Section_III_78_m;
MCNUM W = mccCurved_Guide_Section_III_78_W;
MCNUM nslit = mccCurved_Guide_Section_III_78_nslit;
MCNUM d = mccCurved_Guide_Section_III_78_d;
MCNUM mleft = mccCurved_Guide_Section_III_78_mleft;
MCNUM mright = mccCurved_Guide_Section_III_78_mright;
MCNUM mtop = mccCurved_Guide_Section_III_78_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_78_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_78_nhslit;
MCNUM G = mccCurved_Guide_Section_III_78_G;
MCNUM aleft = mccCurved_Guide_Section_III_78_aleft;
MCNUM aright = mccCurved_Guide_Section_III_78_aright;
MCNUM atop = mccCurved_Guide_Section_III_78_atop;
MCNUM abottom = mccCurved_Guide_Section_III_78_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_78_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_78_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_78_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_78_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_78_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_78_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_78_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_78_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_78_nelements;
MCNUM nu = mccCurved_Guide_Section_III_78_nu;
MCNUM phase = mccCurved_Guide_Section_III_78_phase;
char* reflect = mccCurved_Guide_Section_III_78_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 62114 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_78=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_III_78:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(78,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_III_79 [79] */
  mccoordschange(mcposrCurved_Guide_Section_III_79, mcrotrCurved_Guide_Section_III_79,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_III_79 (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_III_79:
  SIG_MESSAGE("Curved_Guide_Section_III_79 (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_III_79")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_III_79
  STORE_NEUTRON(79,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[79]++;
  mcPCounter[79] += p;
  mcP2Counter[79] += p*p;
#define mccompcurname  Curved_Guide_Section_III_79
#define mccompcurtype  Guide_gravity
#define mccompcurindex 79
#define GVars mccCurved_Guide_Section_III_79_GVars
#define pTable mccCurved_Guide_Section_III_79_pTable
{   /* Declarations of Curved_Guide_Section_III_79=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_79_w1;
MCNUM h1 = mccCurved_Guide_Section_III_79_h1;
MCNUM w2 = mccCurved_Guide_Section_III_79_w2;
MCNUM h2 = mccCurved_Guide_Section_III_79_h2;
MCNUM l = mccCurved_Guide_Section_III_79_l;
MCNUM R0 = mccCurved_Guide_Section_III_79_R0;
MCNUM Qc = mccCurved_Guide_Section_III_79_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_79_alpha;
MCNUM m = mccCurved_Guide_Section_III_79_m;
MCNUM W = mccCurved_Guide_Section_III_79_W;
MCNUM nslit = mccCurved_Guide_Section_III_79_nslit;
MCNUM d = mccCurved_Guide_Section_III_79_d;
MCNUM mleft = mccCurved_Guide_Section_III_79_mleft;
MCNUM mright = mccCurved_Guide_Section_III_79_mright;
MCNUM mtop = mccCurved_Guide_Section_III_79_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_79_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_79_nhslit;
MCNUM G = mccCurved_Guide_Section_III_79_G;
MCNUM aleft = mccCurved_Guide_Section_III_79_aleft;
MCNUM aright = mccCurved_Guide_Section_III_79_aright;
MCNUM atop = mccCurved_Guide_Section_III_79_atop;
MCNUM abottom = mccCurved_Guide_Section_III_79_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_79_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_79_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_79_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_79_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_79_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_79_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_79_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_79_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_79_nelements;
MCNUM nu = mccCurved_Guide_Section_III_79_nu;
MCNUM phase = mccCurved_Guide_Section_III_79_phase;
char* reflect = mccCurved_Guide_Section_III_79_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 62427 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_79=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_III_79:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(79,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Curved_Guide_Section_III_short [80] */
  mccoordschange(mcposrCurved_Guide_Section_III_short, mcrotrCurved_Guide_Section_III_short,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Curved_Guide_Section_III_short (without coords transformations) */
  mcJumpTrace_Curved_Guide_Section_III_short:
  SIG_MESSAGE("Curved_Guide_Section_III_short (Trace)");
  mcDEBUG_COMP("Curved_Guide_Section_III_short")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurved_Guide_Section_III_short
  STORE_NEUTRON(80,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[80]++;
  mcPCounter[80] += p;
  mcP2Counter[80] += p*p;
#define mccompcurname  Curved_Guide_Section_III_short
#define mccompcurtype  Guide_gravity
#define mccompcurindex 80
#define GVars mccCurved_Guide_Section_III_short_GVars
#define pTable mccCurved_Guide_Section_III_short_pTable
{   /* Declarations of Curved_Guide_Section_III_short=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_short_w1;
MCNUM h1 = mccCurved_Guide_Section_III_short_h1;
MCNUM w2 = mccCurved_Guide_Section_III_short_w2;
MCNUM h2 = mccCurved_Guide_Section_III_short_h2;
MCNUM l = mccCurved_Guide_Section_III_short_l;
MCNUM R0 = mccCurved_Guide_Section_III_short_R0;
MCNUM Qc = mccCurved_Guide_Section_III_short_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_short_alpha;
MCNUM m = mccCurved_Guide_Section_III_short_m;
MCNUM W = mccCurved_Guide_Section_III_short_W;
MCNUM nslit = mccCurved_Guide_Section_III_short_nslit;
MCNUM d = mccCurved_Guide_Section_III_short_d;
MCNUM mleft = mccCurved_Guide_Section_III_short_mleft;
MCNUM mright = mccCurved_Guide_Section_III_short_mright;
MCNUM mtop = mccCurved_Guide_Section_III_short_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_short_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_short_nhslit;
MCNUM G = mccCurved_Guide_Section_III_short_G;
MCNUM aleft = mccCurved_Guide_Section_III_short_aleft;
MCNUM aright = mccCurved_Guide_Section_III_short_aright;
MCNUM atop = mccCurved_Guide_Section_III_short_atop;
MCNUM abottom = mccCurved_Guide_Section_III_short_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_short_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_short_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_short_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_short_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_short_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_short_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_short_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_short_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_short_nelements;
MCNUM nu = mccCurved_Guide_Section_III_short_nu;
MCNUM phase = mccCurved_Guide_Section_III_short_phase;
char* reflect = mccCurved_Guide_Section_III_short_reflect;
#line 393 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 62740 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_short=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurved_Guide_Section_III_short:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(80,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component CGS3_end_ToF [81] */
  mccoordschange(mcposrCGS3_end_ToF, mcrotrCGS3_end_ToF,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component CGS3_end_ToF (without coords transformations) */
  mcJumpTrace_CGS3_end_ToF:
  SIG_MESSAGE("CGS3_end_ToF (Trace)");
  mcDEBUG_COMP("CGS3_end_ToF")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCGS3_end_ToF
  STORE_NEUTRON(81,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[81]++;
  mcPCounter[81] += p;
  mcP2Counter[81] += p*p;
#define mccompcurname  CGS3_end_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 81
#define nt mccCGS3_end_ToF_nt
#define TOF_N mccCGS3_end_ToF_TOF_N
#define TOF_p mccCGS3_end_ToF_TOF_p
#define TOF_p2 mccCGS3_end_ToF_TOF_p2
#define t_min mccCGS3_end_ToF_t_min
#define t_max mccCGS3_end_ToF_t_max
#define delta_t mccCGS3_end_ToF_delta_t
{   /* Declarations of CGS3_end_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccCGS3_end_ToF_filename;
MCNUM xmin = mccCGS3_end_ToF_xmin;
MCNUM xmax = mccCGS3_end_ToF_xmax;
MCNUM ymin = mccCGS3_end_ToF_ymin;
MCNUM ymax = mccCGS3_end_ToF_ymax;
MCNUM xwidth = mccCGS3_end_ToF_xwidth;
MCNUM yheight = mccCGS3_end_ToF_yheight;
MCNUM tmin = mccCGS3_end_ToF_tmin;
MCNUM tmax = mccCGS3_end_ToF_tmax;
MCNUM dt = mccCGS3_end_ToF_dt;
MCNUM restore_neutron = mccCGS3_end_ToF_restore_neutron;
int nowritefile = mccCGS3_end_ToF_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 62886 "./SNS_BASIS.c"
}   /* End of CGS3_end_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCGS3_end_ToF:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(81,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component CGS3_end_ToF_Z [82] */
  mccoordschange(mcposrCGS3_end_ToF_Z, mcrotrCGS3_end_ToF_Z,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component CGS3_end_ToF_Z (without coords transformations) */
  mcJumpTrace_CGS3_end_ToF_Z:
  SIG_MESSAGE("CGS3_end_ToF_Z (Trace)");
  mcDEBUG_COMP("CGS3_end_ToF_Z")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCGS3_end_ToF_Z
  STORE_NEUTRON(82,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[82]++;
  mcPCounter[82] += p;
  mcP2Counter[82] += p*p;
#define mccompcurname  CGS3_end_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 82
#define nt mccCGS3_end_ToF_Z_nt
#define TOF_N mccCGS3_end_ToF_Z_TOF_N
#define TOF_p mccCGS3_end_ToF_Z_TOF_p
#define TOF_p2 mccCGS3_end_ToF_Z_TOF_p2
#define t_min mccCGS3_end_ToF_Z_t_min
#define t_max mccCGS3_end_ToF_Z_t_max
#define delta_t mccCGS3_end_ToF_Z_delta_t
{   /* Declarations of CGS3_end_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccCGS3_end_ToF_Z_filename;
MCNUM xmin = mccCGS3_end_ToF_Z_xmin;
MCNUM xmax = mccCGS3_end_ToF_Z_xmax;
MCNUM ymin = mccCGS3_end_ToF_Z_ymin;
MCNUM ymax = mccCGS3_end_ToF_Z_ymax;
MCNUM xwidth = mccCGS3_end_ToF_Z_xwidth;
MCNUM yheight = mccCGS3_end_ToF_Z_yheight;
MCNUM tmin = mccCGS3_end_ToF_Z_tmin;
MCNUM tmax = mccCGS3_end_ToF_Z_tmax;
MCNUM dt = mccCGS3_end_ToF_Z_dt;
MCNUM restore_neutron = mccCGS3_end_ToF_Z_restore_neutron;
int nowritefile = mccCGS3_end_ToF_Z_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 63037 "./SNS_BASIS.c"
}   /* End of CGS3_end_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCGS3_end_ToF_Z:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(82,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component CGS3_end_Lam [83] */
  mccoordschange(mcposrCGS3_end_Lam, mcrotrCGS3_end_Lam,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component CGS3_end_Lam (without coords transformations) */
  mcJumpTrace_CGS3_end_Lam:
  SIG_MESSAGE("CGS3_end_Lam (Trace)");
  mcDEBUG_COMP("CGS3_end_Lam")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCGS3_end_Lam
  STORE_NEUTRON(83,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[83]++;
  mcPCounter[83] += p;
  mcP2Counter[83] += p*p;
#define mccompcurname  CGS3_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 83
#define nL mccCGS3_end_Lam_nL
#define L_N mccCGS3_end_Lam_L_N
#define L_p mccCGS3_end_Lam_L_p
#define L_p2 mccCGS3_end_Lam_L_p2
{   /* Declarations of CGS3_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccCGS3_end_Lam_filename;
MCNUM xmin = mccCGS3_end_Lam_xmin;
MCNUM xmax = mccCGS3_end_Lam_xmax;
MCNUM ymin = mccCGS3_end_Lam_ymin;
MCNUM ymax = mccCGS3_end_Lam_ymax;
MCNUM xwidth = mccCGS3_end_Lam_xwidth;
MCNUM yheight = mccCGS3_end_Lam_yheight;
MCNUM Lmin = mccCGS3_end_Lam_Lmin;
MCNUM Lmax = mccCGS3_end_Lam_Lmax;
MCNUM restore_neutron = mccCGS3_end_Lam_restore_neutron;
int nowritefile = mccCGS3_end_Lam_nowritefile;
#line 84 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 63187 "./SNS_BASIS.c"
}   /* End of CGS3_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCGS3_end_Lam:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(83,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Straight_Guide_Section_I [84] */
  mccoordschange(mcposrStraight_Guide_Section_I, mcrotrStraight_Guide_Section_I,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Straight_Guide_Section_I (without coords transformations) */
  mcJumpTrace_Straight_Guide_Section_I:
  SIG_MESSAGE("Straight_Guide_Section_I (Trace)");
  mcDEBUG_COMP("Straight_Guide_Section_I")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompStraight_Guide_Section_I
  STORE_NEUTRON(84,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[84]++;
  mcPCounter[84] += p;
  mcP2Counter[84] += p*p;
#define mccompcurname  Straight_Guide_Section_I
#define mccompcurtype  Guide
#define mccompcurindex 84
#define pTable mccStraight_Guide_Section_I_pTable
{   /* Declarations of Straight_Guide_Section_I=Guide() SETTING parameters. */
char* reflect = mccStraight_Guide_Section_I_reflect;
MCNUM w1 = mccStraight_Guide_Section_I_w1;
MCNUM h1 = mccStraight_Guide_Section_I_h1;
MCNUM w2 = mccStraight_Guide_Section_I_w2;
MCNUM h2 = mccStraight_Guide_Section_I_h2;
MCNUM l = mccStraight_Guide_Section_I_l;
MCNUM R0 = mccStraight_Guide_Section_I_R0;
MCNUM Qc = mccStraight_Guide_Section_I_Qc;
MCNUM alpha = mccStraight_Guide_Section_I_alpha;
MCNUM m = mccStraight_Guide_Section_I_m;
MCNUM W = mccStraight_Guide_Section_I_W;
#line 94 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 63416 "./SNS_BASIS.c"
}   /* End of Straight_Guide_Section_I=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompStraight_Guide_Section_I:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(84,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap5_start [85] */
  mccoordschange(mcposrGap5_start, mcrotrGap5_start,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap5_start (without coords transformations) */
  mcJumpTrace_Gap5_start:
  SIG_MESSAGE("Gap5_start (Trace)");
  mcDEBUG_COMP("Gap5_start")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap5_start
  STORE_NEUTRON(85,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[85]++;
  mcPCounter[85] += p;
  mcP2Counter[85] += p*p;
#define mccompcurname  Gap5_start
#define mccompcurtype  Arm
#define mccompcurindex 85
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap5_start:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(85,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap5_start_ToF [86] */
  mccoordschange(mcposrGap5_start_ToF, mcrotrGap5_start_ToF,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap5_start_ToF (without coords transformations) */
  mcJumpTrace_Gap5_start_ToF:
  SIG_MESSAGE("Gap5_start_ToF (Trace)");
  mcDEBUG_COMP("Gap5_start_ToF")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap5_start_ToF
  STORE_NEUTRON(86,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[86]++;
  mcPCounter[86] += p;
  mcP2Counter[86] += p*p;
#define mccompcurname  Gap5_start_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 86
#define nt mccGap5_start_ToF_nt
#define TOF_N mccGap5_start_ToF_TOF_N
#define TOF_p mccGap5_start_ToF_TOF_p
#define TOF_p2 mccGap5_start_ToF_TOF_p2
#define t_min mccGap5_start_ToF_t_min
#define t_max mccGap5_start_ToF_t_max
#define delta_t mccGap5_start_ToF_delta_t
{   /* Declarations of Gap5_start_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccGap5_start_ToF_filename;
MCNUM xmin = mccGap5_start_ToF_xmin;
MCNUM xmax = mccGap5_start_ToF_xmax;
MCNUM ymin = mccGap5_start_ToF_ymin;
MCNUM ymax = mccGap5_start_ToF_ymax;
MCNUM xwidth = mccGap5_start_ToF_xwidth;
MCNUM yheight = mccGap5_start_ToF_yheight;
MCNUM tmin = mccGap5_start_ToF_tmin;
MCNUM tmax = mccGap5_start_ToF_tmax;
MCNUM dt = mccGap5_start_ToF_dt;
MCNUM restore_neutron = mccGap5_start_ToF_restore_neutron;
int nowritefile = mccGap5_start_ToF_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 63664 "./SNS_BASIS.c"
}   /* End of Gap5_start_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap5_start_ToF:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(86,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap5_start_ToF_Z [87] */
  mccoordschange(mcposrGap5_start_ToF_Z, mcrotrGap5_start_ToF_Z,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap5_start_ToF_Z (without coords transformations) */
  mcJumpTrace_Gap5_start_ToF_Z:
  SIG_MESSAGE("Gap5_start_ToF_Z (Trace)");
  mcDEBUG_COMP("Gap5_start_ToF_Z")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap5_start_ToF_Z
  STORE_NEUTRON(87,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[87]++;
  mcPCounter[87] += p;
  mcP2Counter[87] += p*p;
#define mccompcurname  Gap5_start_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 87
#define nt mccGap5_start_ToF_Z_nt
#define TOF_N mccGap5_start_ToF_Z_TOF_N
#define TOF_p mccGap5_start_ToF_Z_TOF_p
#define TOF_p2 mccGap5_start_ToF_Z_TOF_p2
#define t_min mccGap5_start_ToF_Z_t_min
#define t_max mccGap5_start_ToF_Z_t_max
#define delta_t mccGap5_start_ToF_Z_delta_t
{   /* Declarations of Gap5_start_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccGap5_start_ToF_Z_filename;
MCNUM xmin = mccGap5_start_ToF_Z_xmin;
MCNUM xmax = mccGap5_start_ToF_Z_xmax;
MCNUM ymin = mccGap5_start_ToF_Z_ymin;
MCNUM ymax = mccGap5_start_ToF_Z_ymax;
MCNUM xwidth = mccGap5_start_ToF_Z_xwidth;
MCNUM yheight = mccGap5_start_ToF_Z_yheight;
MCNUM tmin = mccGap5_start_ToF_Z_tmin;
MCNUM tmax = mccGap5_start_ToF_Z_tmax;
MCNUM dt = mccGap5_start_ToF_Z_dt;
MCNUM restore_neutron = mccGap5_start_ToF_Z_restore_neutron;
int nowritefile = mccGap5_start_ToF_Z_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 63815 "./SNS_BASIS.c"
}   /* End of Gap5_start_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap5_start_ToF_Z:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(87,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap5_start_Lam [88] */
  mccoordschange(mcposrGap5_start_Lam, mcrotrGap5_start_Lam,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap5_start_Lam (without coords transformations) */
  mcJumpTrace_Gap5_start_Lam:
  SIG_MESSAGE("Gap5_start_Lam (Trace)");
  mcDEBUG_COMP("Gap5_start_Lam")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap5_start_Lam
  STORE_NEUTRON(88,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[88]++;
  mcPCounter[88] += p;
  mcP2Counter[88] += p*p;
#define mccompcurname  Gap5_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 88
#define nL mccGap5_start_Lam_nL
#define L_N mccGap5_start_Lam_L_N
#define L_p mccGap5_start_Lam_L_p
#define L_p2 mccGap5_start_Lam_L_p2
{   /* Declarations of Gap5_start_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap5_start_Lam_filename;
MCNUM xmin = mccGap5_start_Lam_xmin;
MCNUM xmax = mccGap5_start_Lam_xmax;
MCNUM ymin = mccGap5_start_Lam_ymin;
MCNUM ymax = mccGap5_start_Lam_ymax;
MCNUM xwidth = mccGap5_start_Lam_xwidth;
MCNUM yheight = mccGap5_start_Lam_yheight;
MCNUM Lmin = mccGap5_start_Lam_Lmin;
MCNUM Lmax = mccGap5_start_Lam_Lmax;
MCNUM restore_neutron = mccGap5_start_Lam_restore_neutron;
int nowritefile = mccGap5_start_Lam_nowritefile;
#line 84 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 63965 "./SNS_BASIS.c"
}   /* End of Gap5_start_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap5_start_Lam:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(88,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap5_start_PSD [89] */
  mccoordschange(mcposrGap5_start_PSD, mcrotrGap5_start_PSD,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap5_start_PSD (without coords transformations) */
  mcJumpTrace_Gap5_start_PSD:
  SIG_MESSAGE("Gap5_start_PSD (Trace)");
  mcDEBUG_COMP("Gap5_start_PSD")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap5_start_PSD
  STORE_NEUTRON(89,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[89]++;
  mcPCounter[89] += p;
  mcP2Counter[89] += p*p;
#define mccompcurname  Gap5_start_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 89
#define PSD_N mccGap5_start_PSD_PSD_N
#define PSD_p mccGap5_start_PSD_PSD_p
#define PSD_p2 mccGap5_start_PSD_PSD_p2
{   /* Declarations of Gap5_start_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap5_start_PSD_nx;
int ny = mccGap5_start_PSD_ny;
char* filename = mccGap5_start_PSD_filename;
MCNUM xmin = mccGap5_start_PSD_xmin;
MCNUM xmax = mccGap5_start_PSD_xmax;
MCNUM ymin = mccGap5_start_PSD_ymin;
MCNUM ymax = mccGap5_start_PSD_ymax;
MCNUM xwidth = mccGap5_start_PSD_xwidth;
MCNUM yheight = mccGap5_start_PSD_yheight;
MCNUM restore_neutron = mccGap5_start_PSD_restore_neutron;
#line 94 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  PROP_Z0;
  if (x>xmin && x<xmax && y>ymin && y<ymax){
    int i = floor((x - xmin)*nx/(xmax - xmin));
    int j = floor((y - ymin)*ny/(ymax - ymin));
    PSD_N[i][j]++;
    PSD_p[i][j] += p;
    PSD_p2[i][j] += p*p;
    SCATTER;
  }
  if (restore_neutron) {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 64103 "./SNS_BASIS.c"
}   /* End of Gap5_start_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap5_start_PSD:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(89,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Chopper3 [90] */
  mccoordschange(mcposrChopper3, mcrotrChopper3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Chopper3 (without coords transformations) */
  mcJumpTrace_Chopper3:
  SIG_MESSAGE("Chopper3 (Trace)");
  mcDEBUG_COMP("Chopper3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompChopper3
  STORE_NEUTRON(90,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[90]++;
  mcPCounter[90] += p;
  mcP2Counter[90] += p*p;
#define mccompcurname  Chopper3
#define mccompcurtype  DiskChopper
#define mccompcurindex 90
#define Tg mccChopper3_Tg
#define To mccChopper3_To
#define delta_y mccChopper3_delta_y
#define height mccChopper3_height
#define omega mccChopper3_omega
{   /* Declarations of Chopper3=DiskChopper() SETTING parameters. */
MCNUM theta_0 = mccChopper3_theta_0;
MCNUM radius = mccChopper3_radius;
MCNUM yheight = mccChopper3_yheight;
MCNUM nu = mccChopper3_nu;
MCNUM nslit = mccChopper3_nslit;
MCNUM jitter = mccChopper3_jitter;
MCNUM delay = mccChopper3_delay;
MCNUM isfirst = mccChopper3_isfirst;
MCNUM n_pulse = mccChopper3_n_pulse;
MCNUM abs_out = mccChopper3_abs_out;
MCNUM phase = mccChopper3_phase;
MCNUM xwidth = mccChopper3_xwidth;
MCNUM verbose = mccChopper3_verbose;
/* 'Chopper3=DiskChopper()' component instance has conditional execution */
if (( Omega3 > 0 ))

#line 133 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/DiskChopper.comp"
{
    double toff;
    double yprime;
    PROP_Z0;
    yprime = y+delta_y;

    /* Is neutron outside the vertical slit range and should we absorb? */
    if (abs_out && (x*x+yprime*yprime)>radius*radius) {
      ABSORB;
    }
    /* Does neutron hit inner solid part of chopper in case of yheight!=radius? */
    if ((x*x+yprime*yprime)<(radius-height)*(radius-height)) {
      ABSORB;
    }


    if (isfirst)
      {
        /* all events are put in the transmitted time frame */
        t=atan2(x,yprime)/omega + To*randpm1()/2.0 + delay + (jitter ? jitter*randnorm():0) + (n_pulse > 1 ? floor(n_pulse*rand01())*Tg : 0);
        /* correction: chopper slits transmission opening/full disk */
        p *= nslit*theta_0/2.0/PI;
      }
    else
      {
        toff=fabs(t-atan2(x,yprime)/omega - delay - (jitter ? jitter*randnorm():0));

        /* does neutron hit outside slit? */
        if (fmod(toff+To/2.0,Tg)>To) ABSORB;
      }
    SCATTER;

}
#line 64266 "./SNS_BASIS.c"
}   /* End of Chopper3=DiskChopper() SETTING parameter declarations. */
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompChopper3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(90,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Chopper3_ToF [91] */
  mccoordschange(mcposrChopper3_ToF, mcrotrChopper3_ToF,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Chopper3_ToF (without coords transformations) */
  mcJumpTrace_Chopper3_ToF:
  SIG_MESSAGE("Chopper3_ToF (Trace)");
  mcDEBUG_COMP("Chopper3_ToF")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompChopper3_ToF
  STORE_NEUTRON(91,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[91]++;
  mcPCounter[91] += p;
  mcP2Counter[91] += p*p;
#define mccompcurname  Chopper3_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 91
#define nt mccChopper3_ToF_nt
#define TOF_N mccChopper3_ToF_TOF_N
#define TOF_p mccChopper3_ToF_TOF_p
#define TOF_p2 mccChopper3_ToF_TOF_p2
#define t_min mccChopper3_ToF_t_min
#define t_max mccChopper3_ToF_t_max
#define delta_t mccChopper3_ToF_delta_t
{   /* Declarations of Chopper3_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccChopper3_ToF_filename;
MCNUM xmin = mccChopper3_ToF_xmin;
MCNUM xmax = mccChopper3_ToF_xmax;
MCNUM ymin = mccChopper3_ToF_ymin;
MCNUM ymax = mccChopper3_ToF_ymax;
MCNUM xwidth = mccChopper3_ToF_xwidth;
MCNUM yheight = mccChopper3_ToF_yheight;
MCNUM tmin = mccChopper3_ToF_tmin;
MCNUM tmax = mccChopper3_ToF_tmax;
MCNUM dt = mccChopper3_ToF_dt;
MCNUM restore_neutron = mccChopper3_ToF_restore_neutron;
int nowritefile = mccChopper3_ToF_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 64415 "./SNS_BASIS.c"
}   /* End of Chopper3_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompChopper3_ToF:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(91,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Chopper3_ToF_Z [92] */
  mccoordschange(mcposrChopper3_ToF_Z, mcrotrChopper3_ToF_Z,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Chopper3_ToF_Z (without coords transformations) */
  mcJumpTrace_Chopper3_ToF_Z:
  SIG_MESSAGE("Chopper3_ToF_Z (Trace)");
  mcDEBUG_COMP("Chopper3_ToF_Z")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompChopper3_ToF_Z
  STORE_NEUTRON(92,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[92]++;
  mcPCounter[92] += p;
  mcP2Counter[92] += p*p;
#define mccompcurname  Chopper3_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 92
#define nt mccChopper3_ToF_Z_nt
#define TOF_N mccChopper3_ToF_Z_TOF_N
#define TOF_p mccChopper3_ToF_Z_TOF_p
#define TOF_p2 mccChopper3_ToF_Z_TOF_p2
#define t_min mccChopper3_ToF_Z_t_min
#define t_max mccChopper3_ToF_Z_t_max
#define delta_t mccChopper3_ToF_Z_delta_t
{   /* Declarations of Chopper3_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccChopper3_ToF_Z_filename;
MCNUM xmin = mccChopper3_ToF_Z_xmin;
MCNUM xmax = mccChopper3_ToF_Z_xmax;
MCNUM ymin = mccChopper3_ToF_Z_ymin;
MCNUM ymax = mccChopper3_ToF_Z_ymax;
MCNUM xwidth = mccChopper3_ToF_Z_xwidth;
MCNUM yheight = mccChopper3_ToF_Z_yheight;
MCNUM tmin = mccChopper3_ToF_Z_tmin;
MCNUM tmax = mccChopper3_ToF_Z_tmax;
MCNUM dt = mccChopper3_ToF_Z_dt;
MCNUM restore_neutron = mccChopper3_ToF_Z_restore_neutron;
int nowritefile = mccChopper3_ToF_Z_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 64566 "./SNS_BASIS.c"
}   /* End of Chopper3_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompChopper3_ToF_Z:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(92,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap5_end_Lam [93] */
  mccoordschange(mcposrGap5_end_Lam, mcrotrGap5_end_Lam,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap5_end_Lam (without coords transformations) */
  mcJumpTrace_Gap5_end_Lam:
  SIG_MESSAGE("Gap5_end_Lam (Trace)");
  mcDEBUG_COMP("Gap5_end_Lam")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap5_end_Lam
  STORE_NEUTRON(93,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[93]++;
  mcPCounter[93] += p;
  mcP2Counter[93] += p*p;
#define mccompcurname  Gap5_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 93
#define nL mccGap5_end_Lam_nL
#define L_N mccGap5_end_Lam_L_N
#define L_p mccGap5_end_Lam_L_p
#define L_p2 mccGap5_end_Lam_L_p2
{   /* Declarations of Gap5_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap5_end_Lam_filename;
MCNUM xmin = mccGap5_end_Lam_xmin;
MCNUM xmax = mccGap5_end_Lam_xmax;
MCNUM ymin = mccGap5_end_Lam_ymin;
MCNUM ymax = mccGap5_end_Lam_ymax;
MCNUM xwidth = mccGap5_end_Lam_xwidth;
MCNUM yheight = mccGap5_end_Lam_yheight;
MCNUM Lmin = mccGap5_end_Lam_Lmin;
MCNUM Lmax = mccGap5_end_Lam_Lmax;
MCNUM restore_neutron = mccGap5_end_Lam_restore_neutron;
int nowritefile = mccGap5_end_Lam_nowritefile;
#line 84 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 64716 "./SNS_BASIS.c"
}   /* End of Gap5_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap5_end_Lam:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(93,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap5_end_PSD [94] */
  mccoordschange(mcposrGap5_end_PSD, mcrotrGap5_end_PSD,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap5_end_PSD (without coords transformations) */
  mcJumpTrace_Gap5_end_PSD:
  SIG_MESSAGE("Gap5_end_PSD (Trace)");
  mcDEBUG_COMP("Gap5_end_PSD")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap5_end_PSD
  STORE_NEUTRON(94,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[94]++;
  mcPCounter[94] += p;
  mcP2Counter[94] += p*p;
#define mccompcurname  Gap5_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 94
#define PSD_N mccGap5_end_PSD_PSD_N
#define PSD_p mccGap5_end_PSD_PSD_p
#define PSD_p2 mccGap5_end_PSD_PSD_p2
{   /* Declarations of Gap5_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap5_end_PSD_nx;
int ny = mccGap5_end_PSD_ny;
char* filename = mccGap5_end_PSD_filename;
MCNUM xmin = mccGap5_end_PSD_xmin;
MCNUM xmax = mccGap5_end_PSD_xmax;
MCNUM ymin = mccGap5_end_PSD_ymin;
MCNUM ymax = mccGap5_end_PSD_ymax;
MCNUM xwidth = mccGap5_end_PSD_xwidth;
MCNUM yheight = mccGap5_end_PSD_yheight;
MCNUM restore_neutron = mccGap5_end_PSD_restore_neutron;
#line 94 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  PROP_Z0;
  if (x>xmin && x<xmax && y>ymin && y<ymax){
    int i = floor((x - xmin)*nx/(xmax - xmin));
    int j = floor((y - ymin)*ny/(ymax - ymin));
    PSD_N[i][j]++;
    PSD_p[i][j] += p;
    PSD_p2[i][j] += p*p;
    SCATTER;
  }
  if (restore_neutron) {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 64854 "./SNS_BASIS.c"
}   /* End of Gap5_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap5_end_PSD:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(94,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Gap5_end [95] */
  mccoordschange(mcposrGap5_end, mcrotrGap5_end,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Gap5_end (without coords transformations) */
  mcJumpTrace_Gap5_end:
  SIG_MESSAGE("Gap5_end (Trace)");
  mcDEBUG_COMP("Gap5_end")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGap5_end
  STORE_NEUTRON(95,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[95]++;
  mcPCounter[95] += p;
  mcP2Counter[95] += p*p;
#define mccompcurname  Gap5_end
#define mccompcurtype  Arm
#define mccompcurindex 95
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGap5_end:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(95,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Straight_Guide_Section_II [96] */
  mccoordschange(mcposrStraight_Guide_Section_II, mcrotrStraight_Guide_Section_II,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Straight_Guide_Section_II (without coords transformations) */
  mcJumpTrace_Straight_Guide_Section_II:
  SIG_MESSAGE("Straight_Guide_Section_II (Trace)");
  mcDEBUG_COMP("Straight_Guide_Section_II")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompStraight_Guide_Section_II
  STORE_NEUTRON(96,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[96]++;
  mcPCounter[96] += p;
  mcP2Counter[96] += p*p;
#define mccompcurname  Straight_Guide_Section_II
#define mccompcurtype  Guide
#define mccompcurindex 96
#define pTable mccStraight_Guide_Section_II_pTable
{   /* Declarations of Straight_Guide_Section_II=Guide() SETTING parameters. */
char* reflect = mccStraight_Guide_Section_II_reflect;
MCNUM w1 = mccStraight_Guide_Section_II_w1;
MCNUM h1 = mccStraight_Guide_Section_II_h1;
MCNUM w2 = mccStraight_Guide_Section_II_w2;
MCNUM h2 = mccStraight_Guide_Section_II_h2;
MCNUM l = mccStraight_Guide_Section_II_l;
MCNUM R0 = mccStraight_Guide_Section_II_R0;
MCNUM Qc = mccStraight_Guide_Section_II_Qc;
MCNUM alpha = mccStraight_Guide_Section_II_alpha;
MCNUM m = mccStraight_Guide_Section_II_m;
MCNUM W = mccStraight_Guide_Section_II_W;
#line 94 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 65185 "./SNS_BASIS.c"
}   /* End of Straight_Guide_Section_II=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompStraight_Guide_Section_II:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(96,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component SGS2_end_Lam [97] */
  mccoordschange(mcposrSGS2_end_Lam, mcrotrSGS2_end_Lam,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component SGS2_end_Lam (without coords transformations) */
  mcJumpTrace_SGS2_end_Lam:
  SIG_MESSAGE("SGS2_end_Lam (Trace)");
  mcDEBUG_COMP("SGS2_end_Lam")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompSGS2_end_Lam
  STORE_NEUTRON(97,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[97]++;
  mcPCounter[97] += p;
  mcP2Counter[97] += p*p;
#define mccompcurname  SGS2_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 97
#define nL mccSGS2_end_Lam_nL
#define L_N mccSGS2_end_Lam_L_N
#define L_p mccSGS2_end_Lam_L_p
#define L_p2 mccSGS2_end_Lam_L_p2
{   /* Declarations of SGS2_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccSGS2_end_Lam_filename;
MCNUM xmin = mccSGS2_end_Lam_xmin;
MCNUM xmax = mccSGS2_end_Lam_xmax;
MCNUM ymin = mccSGS2_end_Lam_ymin;
MCNUM ymax = mccSGS2_end_Lam_ymax;
MCNUM xwidth = mccSGS2_end_Lam_xwidth;
MCNUM yheight = mccSGS2_end_Lam_yheight;
MCNUM Lmin = mccSGS2_end_Lam_Lmin;
MCNUM Lmax = mccSGS2_end_Lam_Lmax;
MCNUM restore_neutron = mccSGS2_end_Lam_restore_neutron;
int nowritefile = mccSGS2_end_Lam_nowritefile;
#line 84 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 65329 "./SNS_BASIS.c"
}   /* End of SGS2_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompSGS2_end_Lam:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(97,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component SGS2_end_PSD [98] */
  mccoordschange(mcposrSGS2_end_PSD, mcrotrSGS2_end_PSD,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component SGS2_end_PSD (without coords transformations) */
  mcJumpTrace_SGS2_end_PSD:
  SIG_MESSAGE("SGS2_end_PSD (Trace)");
  mcDEBUG_COMP("SGS2_end_PSD")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompSGS2_end_PSD
  STORE_NEUTRON(98,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[98]++;
  mcPCounter[98] += p;
  mcP2Counter[98] += p*p;
#define mccompcurname  SGS2_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 98
#define PSD_N mccSGS2_end_PSD_PSD_N
#define PSD_p mccSGS2_end_PSD_PSD_p
#define PSD_p2 mccSGS2_end_PSD_PSD_p2
{   /* Declarations of SGS2_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccSGS2_end_PSD_nx;
int ny = mccSGS2_end_PSD_ny;
char* filename = mccSGS2_end_PSD_filename;
MCNUM xmin = mccSGS2_end_PSD_xmin;
MCNUM xmax = mccSGS2_end_PSD_xmax;
MCNUM ymin = mccSGS2_end_PSD_ymin;
MCNUM ymax = mccSGS2_end_PSD_ymax;
MCNUM xwidth = mccSGS2_end_PSD_xwidth;
MCNUM yheight = mccSGS2_end_PSD_yheight;
MCNUM restore_neutron = mccSGS2_end_PSD_restore_neutron;
#line 94 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  PROP_Z0;
  if (x>xmin && x<xmax && y>ymin && y<ymax){
    int i = floor((x - xmin)*nx/(xmax - xmin));
    int j = floor((y - ymin)*ny/(ymax - ymin));
    PSD_N[i][j]++;
    PSD_p[i][j] += p;
    PSD_p2[i][j] += p*p;
    SCATTER;
  }
  if (restore_neutron) {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 65467 "./SNS_BASIS.c"
}   /* End of SGS2_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompSGS2_end_PSD:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(98,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Straight_Guide_Section_III [99] */
  mccoordschange(mcposrStraight_Guide_Section_III, mcrotrStraight_Guide_Section_III,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Straight_Guide_Section_III (without coords transformations) */
  mcJumpTrace_Straight_Guide_Section_III:
  SIG_MESSAGE("Straight_Guide_Section_III (Trace)");
  mcDEBUG_COMP("Straight_Guide_Section_III")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompStraight_Guide_Section_III
  STORE_NEUTRON(99,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[99]++;
  mcPCounter[99] += p;
  mcP2Counter[99] += p*p;
#define mccompcurname  Straight_Guide_Section_III
#define mccompcurtype  Guide
#define mccompcurindex 99
#define pTable mccStraight_Guide_Section_III_pTable
{   /* Declarations of Straight_Guide_Section_III=Guide() SETTING parameters. */
char* reflect = mccStraight_Guide_Section_III_reflect;
MCNUM w1 = mccStraight_Guide_Section_III_w1;
MCNUM h1 = mccStraight_Guide_Section_III_h1;
MCNUM w2 = mccStraight_Guide_Section_III_w2;
MCNUM h2 = mccStraight_Guide_Section_III_h2;
MCNUM l = mccStraight_Guide_Section_III_l;
MCNUM R0 = mccStraight_Guide_Section_III_R0;
MCNUM Qc = mccStraight_Guide_Section_III_Qc;
MCNUM alpha = mccStraight_Guide_Section_III_alpha;
MCNUM m = mccStraight_Guide_Section_III_m;
MCNUM W = mccStraight_Guide_Section_III_W;
#line 94 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
       TableReflecFunc(q, &pTable, &weight);
    else {
      double par[] = {R0, Qc, alpha, m, W};
      StdReflecFunc(q, par, &weight);
    }
    if (weight > 0)
      p *= weight;
    else ABSORB;
    SCATTER;
  }
}
#line 65695 "./SNS_BASIS.c"
}   /* End of Straight_Guide_Section_III=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompStraight_Guide_Section_III:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(99,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component SG3_end_ToF [100] */
  mccoordschange(mcposrSG3_end_ToF, mcrotrSG3_end_ToF,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component SG3_end_ToF (without coords transformations) */
  mcJumpTrace_SG3_end_ToF:
  SIG_MESSAGE("SG3_end_ToF (Trace)");
  mcDEBUG_COMP("SG3_end_ToF")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompSG3_end_ToF
  STORE_NEUTRON(100,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[100]++;
  mcPCounter[100] += p;
  mcP2Counter[100] += p*p;
#define mccompcurname  SG3_end_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 100
#define nt mccSG3_end_ToF_nt
#define TOF_N mccSG3_end_ToF_TOF_N
#define TOF_p mccSG3_end_ToF_TOF_p
#define TOF_p2 mccSG3_end_ToF_TOF_p2
#define t_min mccSG3_end_ToF_t_min
#define t_max mccSG3_end_ToF_t_max
#define delta_t mccSG3_end_ToF_delta_t
{   /* Declarations of SG3_end_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccSG3_end_ToF_filename;
MCNUM xmin = mccSG3_end_ToF_xmin;
MCNUM xmax = mccSG3_end_ToF_xmax;
MCNUM ymin = mccSG3_end_ToF_ymin;
MCNUM ymax = mccSG3_end_ToF_ymax;
MCNUM xwidth = mccSG3_end_ToF_xwidth;
MCNUM yheight = mccSG3_end_ToF_yheight;
MCNUM tmin = mccSG3_end_ToF_tmin;
MCNUM tmax = mccSG3_end_ToF_tmax;
MCNUM dt = mccSG3_end_ToF_dt;
MCNUM restore_neutron = mccSG3_end_ToF_restore_neutron;
int nowritefile = mccSG3_end_ToF_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 65840 "./SNS_BASIS.c"
}   /* End of SG3_end_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompSG3_end_ToF:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(100,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component SG3_end_ToF_Z [101] */
  mccoordschange(mcposrSG3_end_ToF_Z, mcrotrSG3_end_ToF_Z,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component SG3_end_ToF_Z (without coords transformations) */
  mcJumpTrace_SG3_end_ToF_Z:
  SIG_MESSAGE("SG3_end_ToF_Z (Trace)");
  mcDEBUG_COMP("SG3_end_ToF_Z")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompSG3_end_ToF_Z
  STORE_NEUTRON(101,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[101]++;
  mcPCounter[101] += p;
  mcP2Counter[101] += p*p;
#define mccompcurname  SG3_end_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 101
#define nt mccSG3_end_ToF_Z_nt
#define TOF_N mccSG3_end_ToF_Z_TOF_N
#define TOF_p mccSG3_end_ToF_Z_TOF_p
#define TOF_p2 mccSG3_end_ToF_Z_TOF_p2
#define t_min mccSG3_end_ToF_Z_t_min
#define t_max mccSG3_end_ToF_Z_t_max
#define delta_t mccSG3_end_ToF_Z_delta_t
{   /* Declarations of SG3_end_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccSG3_end_ToF_Z_filename;
MCNUM xmin = mccSG3_end_ToF_Z_xmin;
MCNUM xmax = mccSG3_end_ToF_Z_xmax;
MCNUM ymin = mccSG3_end_ToF_Z_ymin;
MCNUM ymax = mccSG3_end_ToF_Z_ymax;
MCNUM xwidth = mccSG3_end_ToF_Z_xwidth;
MCNUM yheight = mccSG3_end_ToF_Z_yheight;
MCNUM tmin = mccSG3_end_ToF_Z_tmin;
MCNUM tmax = mccSG3_end_ToF_Z_tmax;
MCNUM dt = mccSG3_end_ToF_Z_dt;
MCNUM restore_neutron = mccSG3_end_ToF_Z_restore_neutron;
int nowritefile = mccSG3_end_ToF_Z_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 65991 "./SNS_BASIS.c"
}   /* End of SG3_end_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompSG3_end_ToF_Z:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(101,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component SG3_end_Lam [102] */
  mccoordschange(mcposrSG3_end_Lam, mcrotrSG3_end_Lam,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component SG3_end_Lam (without coords transformations) */
  mcJumpTrace_SG3_end_Lam:
  SIG_MESSAGE("SG3_end_Lam (Trace)");
  mcDEBUG_COMP("SG3_end_Lam")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompSG3_end_Lam
  STORE_NEUTRON(102,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[102]++;
  mcPCounter[102] += p;
  mcP2Counter[102] += p*p;
#define mccompcurname  SG3_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 102
#define nL mccSG3_end_Lam_nL
#define L_N mccSG3_end_Lam_L_N
#define L_p mccSG3_end_Lam_L_p
#define L_p2 mccSG3_end_Lam_L_p2
{   /* Declarations of SG3_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccSG3_end_Lam_filename;
MCNUM xmin = mccSG3_end_Lam_xmin;
MCNUM xmax = mccSG3_end_Lam_xmax;
MCNUM ymin = mccSG3_end_Lam_ymin;
MCNUM ymax = mccSG3_end_Lam_ymax;
MCNUM xwidth = mccSG3_end_Lam_xwidth;
MCNUM yheight = mccSG3_end_Lam_yheight;
MCNUM Lmin = mccSG3_end_Lam_Lmin;
MCNUM Lmax = mccSG3_end_Lam_Lmax;
MCNUM restore_neutron = mccSG3_end_Lam_restore_neutron;
int nowritefile = mccSG3_end_Lam_nowritefile;
#line 84 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 66141 "./SNS_BASIS.c"
}   /* End of SG3_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompSG3_end_Lam:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(102,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component SG3_end_PSD [103] */
  mccoordschange(mcposrSG3_end_PSD, mcrotrSG3_end_PSD,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component SG3_end_PSD (without coords transformations) */
  mcJumpTrace_SG3_end_PSD:
  SIG_MESSAGE("SG3_end_PSD (Trace)");
  mcDEBUG_COMP("SG3_end_PSD")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompSG3_end_PSD
  STORE_NEUTRON(103,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[103]++;
  mcPCounter[103] += p;
  mcP2Counter[103] += p*p;
#define mccompcurname  SG3_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 103
#define PSD_N mccSG3_end_PSD_PSD_N
#define PSD_p mccSG3_end_PSD_PSD_p
#define PSD_p2 mccSG3_end_PSD_PSD_p2
{   /* Declarations of SG3_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccSG3_end_PSD_nx;
int ny = mccSG3_end_PSD_ny;
char* filename = mccSG3_end_PSD_filename;
MCNUM xmin = mccSG3_end_PSD_xmin;
MCNUM xmax = mccSG3_end_PSD_xmax;
MCNUM ymin = mccSG3_end_PSD_ymin;
MCNUM ymax = mccSG3_end_PSD_ymax;
MCNUM xwidth = mccSG3_end_PSD_xwidth;
MCNUM yheight = mccSG3_end_PSD_yheight;
MCNUM restore_neutron = mccSG3_end_PSD_restore_neutron;
#line 94 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  PROP_Z0;
  if (x>xmin && x<xmax && y>ymin && y<ymax){
    int i = floor((x - xmin)*nx/(xmax - xmin));
    int j = floor((y - ymin)*ny/(ymax - ymin));
    PSD_N[i][j]++;
    PSD_p[i][j] += p;
    PSD_p2[i][j] += p*p;
    SCATTER;
  }
  if (restore_neutron) {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 66279 "./SNS_BASIS.c"
}   /* End of SG3_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompSG3_end_PSD:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(103,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Funnel_1 [104] */
  mccoordschange(mcposrFunnel_1, mcrotrFunnel_1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Funnel_1 (without coords transformations) */
  mcJumpTrace_Funnel_1:
  SIG_MESSAGE("Funnel_1 (Trace)");
  mcDEBUG_COMP("Funnel_1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompFunnel_1
  STORE_NEUTRON(104,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[104]++;
  mcPCounter[104] += p;
  mcP2Counter[104] += p*p;
#define mccompcurname  Funnel_1
#define mccompcurtype  Guide_m
#define mccompcurindex 104
#define reflect mccFunnel_1_reflect
#define pTable mccFunnel_1_pTable
#define m mccFunnel_1_m
#define alpha mccFunnel_1_alpha
#define Qc mccFunnel_1_Qc
#define R0 mccFunnel_1_R0
#define W mccFunnel_1_W
{   /* Declarations of Funnel_1=Guide_m() SETTING parameters. */
MCNUM w1 = mccFunnel_1_w1;
MCNUM h1 = mccFunnel_1_h1;
MCNUM w2 = mccFunnel_1_w2;
MCNUM h2 = mccFunnel_1_h2;
MCNUM l = mccFunnel_1_l;
MCNUM R0_left = mccFunnel_1_R0_left;
MCNUM R0_right = mccFunnel_1_R0_right;
MCNUM R0_top = mccFunnel_1_R0_top;
MCNUM R0_bottom = mccFunnel_1_R0_bottom;
MCNUM Qc_left = mccFunnel_1_Qc_left;
MCNUM Qc_right = mccFunnel_1_Qc_right;
MCNUM Qc_top = mccFunnel_1_Qc_top;
MCNUM Qc_bottom = mccFunnel_1_Qc_bottom;
MCNUM alpha_left = mccFunnel_1_alpha_left;
MCNUM alpha_right = mccFunnel_1_alpha_right;
MCNUM alpha_top = mccFunnel_1_alpha_top;
MCNUM alpha_bottom = mccFunnel_1_alpha_bottom;
MCNUM m_left = mccFunnel_1_m_left;
MCNUM m_right = mccFunnel_1_m_right;
MCNUM m_top = mccFunnel_1_m_top;
MCNUM m_bottom = mccFunnel_1_m_bottom;
MCNUM W_left = mccFunnel_1_W_left;
MCNUM W_right = mccFunnel_1_W_right;
MCNUM W_top = mccFunnel_1_W_top;
MCNUM W_bottom = mccFunnel_1_W_bottom;
#line 121 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_m.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        m = m_left;
		Qc = Qc_left;
		W = W_left;
		alpha= alpha_left;
		R0= R0_left;
		break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
		m = m_right;
		Qc = Qc_right;
		W = W_right;
		alpha= alpha_right;
		R0= R0_right;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        m = m_bottom;
		Qc = Qc_bottom;
		W = W_bottom;
		alpha= alpha_bottom;
		R0= R0_bottom;
		break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
		m = m_top;
		Qc = Qc_top;
		W = W_top;
		alpha= alpha_top;
		R0= R0_top;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect))
      weight = Table_Value(pTable, q, 1);
    else if(q > Qc)
    {
      double arg = (q-m*Qc)/W;
      if(arg < 10)
        weight = .5*(1-tanh(arg))*(1-alpha*(q-Qc));
      else
        ABSORB;                               /* Cutoff ~ 1E-10 */
      weight *= R0;
    } else { /* q <= Qc */
      weight *= R0;
    }
    p *= weight;
    SCATTER;
  }
}
#line 66552 "./SNS_BASIS.c"
}   /* End of Funnel_1=Guide_m() SETTING parameter declarations. */
#undef W
#undef R0
#undef Qc
#undef alpha
#undef m
#undef pTable
#undef reflect
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompFunnel_1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(104,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component PSD_post_funnel1 [105] */
  mccoordschange(mcposrPSD_post_funnel1, mcrotrPSD_post_funnel1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component PSD_post_funnel1 (without coords transformations) */
  mcJumpTrace_PSD_post_funnel1:
  SIG_MESSAGE("PSD_post_funnel1 (Trace)");
  mcDEBUG_COMP("PSD_post_funnel1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPSD_post_funnel1
  STORE_NEUTRON(105,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[105]++;
  mcPCounter[105] += p;
  mcP2Counter[105] += p*p;
#define mccompcurname  PSD_post_funnel1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 105
#define PSD_N mccPSD_post_funnel1_PSD_N
#define PSD_p mccPSD_post_funnel1_PSD_p
#define PSD_p2 mccPSD_post_funnel1_PSD_p2
{   /* Declarations of PSD_post_funnel1=PSD_monitor() SETTING parameters. */
int nx = mccPSD_post_funnel1_nx;
int ny = mccPSD_post_funnel1_ny;
char* filename = mccPSD_post_funnel1_filename;
MCNUM xmin = mccPSD_post_funnel1_xmin;
MCNUM xmax = mccPSD_post_funnel1_xmax;
MCNUM ymin = mccPSD_post_funnel1_ymin;
MCNUM ymax = mccPSD_post_funnel1_ymax;
MCNUM xwidth = mccPSD_post_funnel1_xwidth;
MCNUM yheight = mccPSD_post_funnel1_yheight;
MCNUM restore_neutron = mccPSD_post_funnel1_restore_neutron;
#line 94 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  PROP_Z0;
  if (x>xmin && x<xmax && y>ymin && y<ymax){
    int i = floor((x - xmin)*nx/(xmax - xmin));
    int j = floor((y - ymin)*ny/(ymax - ymin));
    PSD_N[i][j]++;
    PSD_p[i][j] += p;
    PSD_p2[i][j] += p*p;
    SCATTER;
  }
  if (restore_neutron) {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 66693 "./SNS_BASIS.c"
}   /* End of PSD_post_funnel1=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPSD_post_funnel1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(105,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Funnel_2 [106] */
  mccoordschange(mcposrFunnel_2, mcrotrFunnel_2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Funnel_2 (without coords transformations) */
  mcJumpTrace_Funnel_2:
  SIG_MESSAGE("Funnel_2 (Trace)");
  mcDEBUG_COMP("Funnel_2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompFunnel_2
  STORE_NEUTRON(106,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[106]++;
  mcPCounter[106] += p;
  mcP2Counter[106] += p*p;
#define mccompcurname  Funnel_2
#define mccompcurtype  Guide_m
#define mccompcurindex 106
#define reflect mccFunnel_2_reflect
#define pTable mccFunnel_2_pTable
#define m mccFunnel_2_m
#define alpha mccFunnel_2_alpha
#define Qc mccFunnel_2_Qc
#define R0 mccFunnel_2_R0
#define W mccFunnel_2_W
{   /* Declarations of Funnel_2=Guide_m() SETTING parameters. */
MCNUM w1 = mccFunnel_2_w1;
MCNUM h1 = mccFunnel_2_h1;
MCNUM w2 = mccFunnel_2_w2;
MCNUM h2 = mccFunnel_2_h2;
MCNUM l = mccFunnel_2_l;
MCNUM R0_left = mccFunnel_2_R0_left;
MCNUM R0_right = mccFunnel_2_R0_right;
MCNUM R0_top = mccFunnel_2_R0_top;
MCNUM R0_bottom = mccFunnel_2_R0_bottom;
MCNUM Qc_left = mccFunnel_2_Qc_left;
MCNUM Qc_right = mccFunnel_2_Qc_right;
MCNUM Qc_top = mccFunnel_2_Qc_top;
MCNUM Qc_bottom = mccFunnel_2_Qc_bottom;
MCNUM alpha_left = mccFunnel_2_alpha_left;
MCNUM alpha_right = mccFunnel_2_alpha_right;
MCNUM alpha_top = mccFunnel_2_alpha_top;
MCNUM alpha_bottom = mccFunnel_2_alpha_bottom;
MCNUM m_left = mccFunnel_2_m_left;
MCNUM m_right = mccFunnel_2_m_right;
MCNUM m_top = mccFunnel_2_m_top;
MCNUM m_bottom = mccFunnel_2_m_bottom;
MCNUM W_left = mccFunnel_2_W_left;
MCNUM W_right = mccFunnel_2_W_right;
MCNUM W_top = mccFunnel_2_W_top;
MCNUM W_bottom = mccFunnel_2_W_bottom;
#line 121 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_m.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        m = m_left;
		Qc = Qc_left;
		W = W_left;
		alpha= alpha_left;
		R0= R0_left;
		break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
		m = m_right;
		Qc = Qc_right;
		W = W_right;
		alpha= alpha_right;
		R0= R0_right;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        m = m_bottom;
		Qc = Qc_bottom;
		W = W_bottom;
		alpha= alpha_bottom;
		R0= R0_bottom;
		break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
		m = m_top;
		Qc = Qc_top;
		W = W_top;
		alpha= alpha_top;
		R0= R0_top;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect))
      weight = Table_Value(pTable, q, 1);
    else if(q > Qc)
    {
      double arg = (q-m*Qc)/W;
      if(arg < 10)
        weight = .5*(1-tanh(arg))*(1-alpha*(q-Qc));
      else
        ABSORB;                               /* Cutoff ~ 1E-10 */
      weight *= R0;
    } else { /* q <= Qc */
      weight *= R0;
    }
    p *= weight;
    SCATTER;
  }
}
#line 66966 "./SNS_BASIS.c"
}   /* End of Funnel_2=Guide_m() SETTING parameter declarations. */
#undef W
#undef R0
#undef Qc
#undef alpha
#undef m
#undef pTable
#undef reflect
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompFunnel_2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(106,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component PSD_post_funnel2 [107] */
  mccoordschange(mcposrPSD_post_funnel2, mcrotrPSD_post_funnel2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component PSD_post_funnel2 (without coords transformations) */
  mcJumpTrace_PSD_post_funnel2:
  SIG_MESSAGE("PSD_post_funnel2 (Trace)");
  mcDEBUG_COMP("PSD_post_funnel2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPSD_post_funnel2
  STORE_NEUTRON(107,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[107]++;
  mcPCounter[107] += p;
  mcP2Counter[107] += p*p;
#define mccompcurname  PSD_post_funnel2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 107
#define PSD_N mccPSD_post_funnel2_PSD_N
#define PSD_p mccPSD_post_funnel2_PSD_p
#define PSD_p2 mccPSD_post_funnel2_PSD_p2
{   /* Declarations of PSD_post_funnel2=PSD_monitor() SETTING parameters. */
int nx = mccPSD_post_funnel2_nx;
int ny = mccPSD_post_funnel2_ny;
char* filename = mccPSD_post_funnel2_filename;
MCNUM xmin = mccPSD_post_funnel2_xmin;
MCNUM xmax = mccPSD_post_funnel2_xmax;
MCNUM ymin = mccPSD_post_funnel2_ymin;
MCNUM ymax = mccPSD_post_funnel2_ymax;
MCNUM xwidth = mccPSD_post_funnel2_xwidth;
MCNUM yheight = mccPSD_post_funnel2_yheight;
MCNUM restore_neutron = mccPSD_post_funnel2_restore_neutron;
#line 94 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  PROP_Z0;
  if (x>xmin && x<xmax && y>ymin && y<ymax){
    int i = floor((x - xmin)*nx/(xmax - xmin));
    int j = floor((y - ymin)*ny/(ymax - ymin));
    PSD_N[i][j]++;
    PSD_p[i][j] += p;
    PSD_p2[i][j] += p*p;
    SCATTER;
  }
  if (restore_neutron) {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 67107 "./SNS_BASIS.c"
}   /* End of PSD_post_funnel2=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPSD_post_funnel2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(107,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Funnel_3 [108] */
  mccoordschange(mcposrFunnel_3, mcrotrFunnel_3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Funnel_3 (without coords transformations) */
  mcJumpTrace_Funnel_3:
  SIG_MESSAGE("Funnel_3 (Trace)");
  mcDEBUG_COMP("Funnel_3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompFunnel_3
  STORE_NEUTRON(108,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[108]++;
  mcPCounter[108] += p;
  mcP2Counter[108] += p*p;
#define mccompcurname  Funnel_3
#define mccompcurtype  Guide_m
#define mccompcurindex 108
#define reflect mccFunnel_3_reflect
#define pTable mccFunnel_3_pTable
#define m mccFunnel_3_m
#define alpha mccFunnel_3_alpha
#define Qc mccFunnel_3_Qc
#define R0 mccFunnel_3_R0
#define W mccFunnel_3_W
{   /* Declarations of Funnel_3=Guide_m() SETTING parameters. */
MCNUM w1 = mccFunnel_3_w1;
MCNUM h1 = mccFunnel_3_h1;
MCNUM w2 = mccFunnel_3_w2;
MCNUM h2 = mccFunnel_3_h2;
MCNUM l = mccFunnel_3_l;
MCNUM R0_left = mccFunnel_3_R0_left;
MCNUM R0_right = mccFunnel_3_R0_right;
MCNUM R0_top = mccFunnel_3_R0_top;
MCNUM R0_bottom = mccFunnel_3_R0_bottom;
MCNUM Qc_left = mccFunnel_3_Qc_left;
MCNUM Qc_right = mccFunnel_3_Qc_right;
MCNUM Qc_top = mccFunnel_3_Qc_top;
MCNUM Qc_bottom = mccFunnel_3_Qc_bottom;
MCNUM alpha_left = mccFunnel_3_alpha_left;
MCNUM alpha_right = mccFunnel_3_alpha_right;
MCNUM alpha_top = mccFunnel_3_alpha_top;
MCNUM alpha_bottom = mccFunnel_3_alpha_bottom;
MCNUM m_left = mccFunnel_3_m_left;
MCNUM m_right = mccFunnel_3_m_right;
MCNUM m_top = mccFunnel_3_m_top;
MCNUM m_bottom = mccFunnel_3_m_bottom;
MCNUM W_left = mccFunnel_3_W_left;
MCNUM W_right = mccFunnel_3_W_right;
MCNUM W_top = mccFunnel_3_W_top;
MCNUM W_bottom = mccFunnel_3_W_bottom;
#line 121 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_m.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        m = m_left;
		Qc = Qc_left;
		W = W_left;
		alpha= alpha_left;
		R0= R0_left;
		break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
		m = m_right;
		Qc = Qc_right;
		W = W_right;
		alpha= alpha_right;
		R0= R0_right;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        m = m_bottom;
		Qc = Qc_bottom;
		W = W_bottom;
		alpha= alpha_bottom;
		R0= R0_bottom;
		break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
		m = m_top;
		Qc = Qc_top;
		W = W_top;
		alpha= alpha_top;
		R0= R0_top;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect))
      weight = Table_Value(pTable, q, 1);
    else if(q > Qc)
    {
      double arg = (q-m*Qc)/W;
      if(arg < 10)
        weight = .5*(1-tanh(arg))*(1-alpha*(q-Qc));
      else
        ABSORB;                               /* Cutoff ~ 1E-10 */
      weight *= R0;
    } else { /* q <= Qc */
      weight *= R0;
    }
    p *= weight;
    SCATTER;
  }
}
#line 67380 "./SNS_BASIS.c"
}   /* End of Funnel_3=Guide_m() SETTING parameter declarations. */
#undef W
#undef R0
#undef Qc
#undef alpha
#undef m
#undef pTable
#undef reflect
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompFunnel_3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(108,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component PSD_post_funnel3 [109] */
  mccoordschange(mcposrPSD_post_funnel3, mcrotrPSD_post_funnel3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component PSD_post_funnel3 (without coords transformations) */
  mcJumpTrace_PSD_post_funnel3:
  SIG_MESSAGE("PSD_post_funnel3 (Trace)");
  mcDEBUG_COMP("PSD_post_funnel3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPSD_post_funnel3
  STORE_NEUTRON(109,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[109]++;
  mcPCounter[109] += p;
  mcP2Counter[109] += p*p;
#define mccompcurname  PSD_post_funnel3
#define mccompcurtype  PSD_monitor
#define mccompcurindex 109
#define PSD_N mccPSD_post_funnel3_PSD_N
#define PSD_p mccPSD_post_funnel3_PSD_p
#define PSD_p2 mccPSD_post_funnel3_PSD_p2
{   /* Declarations of PSD_post_funnel3=PSD_monitor() SETTING parameters. */
int nx = mccPSD_post_funnel3_nx;
int ny = mccPSD_post_funnel3_ny;
char* filename = mccPSD_post_funnel3_filename;
MCNUM xmin = mccPSD_post_funnel3_xmin;
MCNUM xmax = mccPSD_post_funnel3_xmax;
MCNUM ymin = mccPSD_post_funnel3_ymin;
MCNUM ymax = mccPSD_post_funnel3_ymax;
MCNUM xwidth = mccPSD_post_funnel3_xwidth;
MCNUM yheight = mccPSD_post_funnel3_yheight;
MCNUM restore_neutron = mccPSD_post_funnel3_restore_neutron;
#line 94 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  PROP_Z0;
  if (x>xmin && x<xmax && y>ymin && y<ymax){
    int i = floor((x - xmin)*nx/(xmax - xmin));
    int j = floor((y - ymin)*ny/(ymax - ymin));
    PSD_N[i][j]++;
    PSD_p[i][j] += p;
    PSD_p2[i][j] += p*p;
    SCATTER;
  }
  if (restore_neutron) {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 67521 "./SNS_BASIS.c"
}   /* End of PSD_post_funnel3=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPSD_post_funnel3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(109,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Funnel_4 [110] */
  mccoordschange(mcposrFunnel_4, mcrotrFunnel_4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Funnel_4 (without coords transformations) */
  mcJumpTrace_Funnel_4:
  SIG_MESSAGE("Funnel_4 (Trace)");
  mcDEBUG_COMP("Funnel_4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompFunnel_4
  STORE_NEUTRON(110,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[110]++;
  mcPCounter[110] += p;
  mcP2Counter[110] += p*p;
#define mccompcurname  Funnel_4
#define mccompcurtype  Guide_m
#define mccompcurindex 110
#define reflect mccFunnel_4_reflect
#define pTable mccFunnel_4_pTable
#define m mccFunnel_4_m
#define alpha mccFunnel_4_alpha
#define Qc mccFunnel_4_Qc
#define R0 mccFunnel_4_R0
#define W mccFunnel_4_W
{   /* Declarations of Funnel_4=Guide_m() SETTING parameters. */
MCNUM w1 = mccFunnel_4_w1;
MCNUM h1 = mccFunnel_4_h1;
MCNUM w2 = mccFunnel_4_w2;
MCNUM h2 = mccFunnel_4_h2;
MCNUM l = mccFunnel_4_l;
MCNUM R0_left = mccFunnel_4_R0_left;
MCNUM R0_right = mccFunnel_4_R0_right;
MCNUM R0_top = mccFunnel_4_R0_top;
MCNUM R0_bottom = mccFunnel_4_R0_bottom;
MCNUM Qc_left = mccFunnel_4_Qc_left;
MCNUM Qc_right = mccFunnel_4_Qc_right;
MCNUM Qc_top = mccFunnel_4_Qc_top;
MCNUM Qc_bottom = mccFunnel_4_Qc_bottom;
MCNUM alpha_left = mccFunnel_4_alpha_left;
MCNUM alpha_right = mccFunnel_4_alpha_right;
MCNUM alpha_top = mccFunnel_4_alpha_top;
MCNUM alpha_bottom = mccFunnel_4_alpha_bottom;
MCNUM m_left = mccFunnel_4_m_left;
MCNUM m_right = mccFunnel_4_m_right;
MCNUM m_top = mccFunnel_4_m_top;
MCNUM m_bottom = mccFunnel_4_m_bottom;
MCNUM W_left = mccFunnel_4_W_left;
MCNUM W_right = mccFunnel_4_W_right;
MCNUM W_top = mccFunnel_4_W_top;
MCNUM W_bottom = mccFunnel_4_W_bottom;
#line 121 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_m.comp"
{
  double t1,t2;                                 /* Intersection times. */
  double av,ah,bv,bh,cv1,cv2,ch1,ch2,d;         /* Intermediate values */
  double weight;                                /* Internal probability weight */
  double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2;   /* Dot products. */
  int i;                                        /* Which mirror hit? */
  double q;                                     /* Q [1/AA] of reflection */
  double nlen2;                                 /* Vector lengths squared */

  /* ToDo: These could be precalculated. */
  double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
  double whalf = .5*w1, hhalf = .5*h1;

  /* Propagate neutron to guide entrance. */
  PROP_Z0;
  /* Scatter here to ensure that fully transmitted neutrons will not be
     absorbed in a GROUP construction, e.g. all neutrons - even the
     later absorbed ones are scattered at the guide entry. */
  SCATTER;
  if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
    ABSORB;
  for(;;)
  {
    /* Compute the dot products of v and n for the four mirrors. */
    av = l*vx; bv = ww*vz;
    ah = l*vy; bh = hh*vz;
    vdotn_v1 = bv + av;         /* Left vertical */
    vdotn_v2 = bv - av;         /* Right vertical */
    vdotn_h1 = bh + ah;         /* Lower horizontal */
    vdotn_h2 = bh - ah;         /* Upper horizontal */
    /* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
    cv1 = -whalf*l - z*ww; cv2 = x*l;
    ch1 = -hhalf*l - z*hh; ch2 = y*l;
    /* Compute intersection times. */
    t1 = (l - z)/vz;
    i = 0;
    if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
    {
      t1 = t2;
      i = 1;
    }
    if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
    {
      t1 = t2;
      i = 2;
    }
    if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
    {
      t1 = t2;
      i = 3;
    }
    if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
    {
      t1 = t2;
      i = 4;
    }
    if(i == 0)
      break;                    /* Neutron left guide. */
    PROP_DT(t1);
    switch(i)
    {
      case 1:                   /* Left vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
        d = 2*vdotn_v1/nlen2;
        vx = vx - d*l;
        vz = vz - d*ww;
        m = m_left;
		Qc = Qc_left;
		W = W_left;
		alpha= alpha_left;
		R0= R0_left;
		break;
      case 2:                   /* Right vertical mirror */
        nlen2 = l*l + ww*ww;
        q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
        d = 2*vdotn_v2/nlen2;
        vx = vx + d*l;
        vz = vz - d*ww;
		m = m_right;
		Qc = Qc_right;
		W = W_right;
		alpha= alpha_right;
		R0= R0_right;
        break;
      case 3:                   /* Lower horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
        d = 2*vdotn_h1/nlen2;
        vy = vy - d*l;
        vz = vz - d*hh;
        m = m_bottom;
		Qc = Qc_bottom;
		W = W_bottom;
		alpha= alpha_bottom;
		R0= R0_bottom;
		break;
      case 4:                   /* Upper horizontal mirror */
        nlen2 = l*l + hh*hh;
        q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
        d = 2*vdotn_h2/nlen2;
        vy = vy + d*l;
        vz = vz - d*hh;
		m = m_top;
		Qc = Qc_top;
		W = W_top;
		alpha= alpha_top;
		R0= R0_top;
        break;
    }
    /* Now compute reflectivity. */
    weight = 1.0; /* Initial internal weight factor */
    if(m == 0)
      ABSORB;
    if (reflect && strlen(reflect))
      weight = Table_Value(pTable, q, 1);
    else if(q > Qc)
    {
      double arg = (q-m*Qc)/W;
      if(arg < 10)
        weight = .5*(1-tanh(arg))*(1-alpha*(q-Qc));
      else
        ABSORB;                               /* Cutoff ~ 1E-10 */
      weight *= R0;
    } else { /* q <= Qc */
      weight *= R0;
    }
    p *= weight;
    SCATTER;
  }
}
#line 67794 "./SNS_BASIS.c"
}   /* End of Funnel_4=Guide_m() SETTING parameter declarations. */
#undef W
#undef R0
#undef Qc
#undef alpha
#undef m
#undef pTable
#undef reflect
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompFunnel_4:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(110,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component PSD_post_funnel4 [111] */
  mccoordschange(mcposrPSD_post_funnel4, mcrotrPSD_post_funnel4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component PSD_post_funnel4 (without coords transformations) */
  mcJumpTrace_PSD_post_funnel4:
  SIG_MESSAGE("PSD_post_funnel4 (Trace)");
  mcDEBUG_COMP("PSD_post_funnel4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPSD_post_funnel4
  STORE_NEUTRON(111,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[111]++;
  mcPCounter[111] += p;
  mcP2Counter[111] += p*p;
#define mccompcurname  PSD_post_funnel4
#define mccompcurtype  PSD_monitor
#define mccompcurindex 111
#define PSD_N mccPSD_post_funnel4_PSD_N
#define PSD_p mccPSD_post_funnel4_PSD_p
#define PSD_p2 mccPSD_post_funnel4_PSD_p2
{   /* Declarations of PSD_post_funnel4=PSD_monitor() SETTING parameters. */
int nx = mccPSD_post_funnel4_nx;
int ny = mccPSD_post_funnel4_ny;
char* filename = mccPSD_post_funnel4_filename;
MCNUM xmin = mccPSD_post_funnel4_xmin;
MCNUM xmax = mccPSD_post_funnel4_xmax;
MCNUM ymin = mccPSD_post_funnel4_ymin;
MCNUM ymax = mccPSD_post_funnel4_ymax;
MCNUM xwidth = mccPSD_post_funnel4_xwidth;
MCNUM yheight = mccPSD_post_funnel4_yheight;
MCNUM restore_neutron = mccPSD_post_funnel4_restore_neutron;
#line 94 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  PROP_Z0;
  if (x>xmin && x<xmax && y>ymin && y<ymax){
    int i = floor((x - xmin)*nx/(xmax - xmin));
    int j = floor((y - ymin)*ny/(ymax - ymin));
    PSD_N[i][j]++;
    PSD_p[i][j] += p;
    PSD_p2[i][j] += p*p;
    SCATTER;
  }
  if (restore_neutron) {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 67935 "./SNS_BASIS.c"
}   /* End of PSD_post_funnel4=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPSD_post_funnel4:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(111,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Guide_End_ToF [112] */
  mccoordschange(mcposrGuide_End_ToF, mcrotrGuide_End_ToF,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Guide_End_ToF (without coords transformations) */
  mcJumpTrace_Guide_End_ToF:
  SIG_MESSAGE("Guide_End_ToF (Trace)");
  mcDEBUG_COMP("Guide_End_ToF")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGuide_End_ToF
  STORE_NEUTRON(112,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[112]++;
  mcPCounter[112] += p;
  mcP2Counter[112] += p*p;
#define mccompcurname  Guide_End_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 112
#define nt mccGuide_End_ToF_nt
#define TOF_N mccGuide_End_ToF_TOF_N
#define TOF_p mccGuide_End_ToF_TOF_p
#define TOF_p2 mccGuide_End_ToF_TOF_p2
#define t_min mccGuide_End_ToF_t_min
#define t_max mccGuide_End_ToF_t_max
#define delta_t mccGuide_End_ToF_delta_t
{   /* Declarations of Guide_End_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccGuide_End_ToF_filename;
MCNUM xmin = mccGuide_End_ToF_xmin;
MCNUM xmax = mccGuide_End_ToF_xmax;
MCNUM ymin = mccGuide_End_ToF_ymin;
MCNUM ymax = mccGuide_End_ToF_ymax;
MCNUM xwidth = mccGuide_End_ToF_xwidth;
MCNUM yheight = mccGuide_End_ToF_yheight;
MCNUM tmin = mccGuide_End_ToF_tmin;
MCNUM tmax = mccGuide_End_ToF_tmax;
MCNUM dt = mccGuide_End_ToF_dt;
MCNUM restore_neutron = mccGuide_End_ToF_restore_neutron;
int nowritefile = mccGuide_End_ToF_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 68082 "./SNS_BASIS.c"
}   /* End of Guide_End_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGuide_End_ToF:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(112,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Guide_End_ToF_Z [113] */
  mccoordschange(mcposrGuide_End_ToF_Z, mcrotrGuide_End_ToF_Z,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Guide_End_ToF_Z (without coords transformations) */
  mcJumpTrace_Guide_End_ToF_Z:
  SIG_MESSAGE("Guide_End_ToF_Z (Trace)");
  mcDEBUG_COMP("Guide_End_ToF_Z")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGuide_End_ToF_Z
  STORE_NEUTRON(113,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[113]++;
  mcPCounter[113] += p;
  mcP2Counter[113] += p*p;
#define mccompcurname  Guide_End_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 113
#define nt mccGuide_End_ToF_Z_nt
#define TOF_N mccGuide_End_ToF_Z_TOF_N
#define TOF_p mccGuide_End_ToF_Z_TOF_p
#define TOF_p2 mccGuide_End_ToF_Z_TOF_p2
#define t_min mccGuide_End_ToF_Z_t_min
#define t_max mccGuide_End_ToF_Z_t_max
#define delta_t mccGuide_End_ToF_Z_delta_t
{   /* Declarations of Guide_End_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccGuide_End_ToF_Z_filename;
MCNUM xmin = mccGuide_End_ToF_Z_xmin;
MCNUM xmax = mccGuide_End_ToF_Z_xmax;
MCNUM ymin = mccGuide_End_ToF_Z_ymin;
MCNUM ymax = mccGuide_End_ToF_Z_ymax;
MCNUM xwidth = mccGuide_End_ToF_Z_xwidth;
MCNUM yheight = mccGuide_End_ToF_Z_yheight;
MCNUM tmin = mccGuide_End_ToF_Z_tmin;
MCNUM tmax = mccGuide_End_ToF_Z_tmax;
MCNUM dt = mccGuide_End_ToF_Z_dt;
MCNUM restore_neutron = mccGuide_End_ToF_Z_restore_neutron;
int nowritefile = mccGuide_End_ToF_Z_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 68233 "./SNS_BASIS.c"
}   /* End of Guide_End_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGuide_End_ToF_Z:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(113,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Guide_end_Lam [114] */
  mccoordschange(mcposrGuide_end_Lam, mcrotrGuide_end_Lam,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Guide_end_Lam (without coords transformations) */
  mcJumpTrace_Guide_end_Lam:
  SIG_MESSAGE("Guide_end_Lam (Trace)");
  mcDEBUG_COMP("Guide_end_Lam")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGuide_end_Lam
  STORE_NEUTRON(114,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[114]++;
  mcPCounter[114] += p;
  mcP2Counter[114] += p*p;
#define mccompcurname  Guide_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 114
#define nL mccGuide_end_Lam_nL
#define L_N mccGuide_end_Lam_L_N
#define L_p mccGuide_end_Lam_L_p
#define L_p2 mccGuide_end_Lam_L_p2
{   /* Declarations of Guide_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccGuide_end_Lam_filename;
MCNUM xmin = mccGuide_end_Lam_xmin;
MCNUM xmax = mccGuide_end_Lam_xmax;
MCNUM ymin = mccGuide_end_Lam_ymin;
MCNUM ymax = mccGuide_end_Lam_ymax;
MCNUM xwidth = mccGuide_end_Lam_xwidth;
MCNUM yheight = mccGuide_end_Lam_yheight;
MCNUM Lmin = mccGuide_end_Lam_Lmin;
MCNUM Lmax = mccGuide_end_Lam_Lmax;
MCNUM restore_neutron = mccGuide_end_Lam_restore_neutron;
int nowritefile = mccGuide_end_Lam_nowritefile;
#line 84 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 68383 "./SNS_BASIS.c"
}   /* End of Guide_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGuide_end_Lam:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(114,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Guide_end_divx [115] */
  mccoordschange(mcposrGuide_end_divx, mcrotrGuide_end_divx,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Guide_end_divx (without coords transformations) */
  mcJumpTrace_Guide_end_divx:
  SIG_MESSAGE("Guide_end_divx (Trace)");
  mcDEBUG_COMP("Guide_end_divx")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGuide_end_divx
  STORE_NEUTRON(115,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[115]++;
  mcPCounter[115] += p;
  mcP2Counter[115] += p*p;
#define mccompcurname  Guide_end_divx
#define mccompcurtype  Monitor_nD
#define mccompcurindex 115
#define user1 mccGuide_end_divx_user1
#define user2 mccGuide_end_divx_user2
#define user3 mccGuide_end_divx_user3
#define DEFS mccGuide_end_divx_DEFS
#define Vars mccGuide_end_divx_Vars
#define detector mccGuide_end_divx_detector
#define offdata mccGuide_end_divx_offdata
{   /* Declarations of Guide_end_divx=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccGuide_end_divx_xwidth;
MCNUM yheight = mccGuide_end_divx_yheight;
MCNUM zdepth = mccGuide_end_divx_zdepth;
MCNUM xmin = mccGuide_end_divx_xmin;
MCNUM xmax = mccGuide_end_divx_xmax;
MCNUM ymin = mccGuide_end_divx_ymin;
MCNUM ymax = mccGuide_end_divx_ymax;
MCNUM zmin = mccGuide_end_divx_zmin;
MCNUM zmax = mccGuide_end_divx_zmax;
MCNUM bins = mccGuide_end_divx_bins;
MCNUM min = mccGuide_end_divx_min;
MCNUM max = mccGuide_end_divx_max;
MCNUM restore_neutron = mccGuide_end_divx_restore_neutron;
MCNUM radius = mccGuide_end_divx_radius;
char* options = mccGuide_end_divx_options;
char* filename = mccGuide_end_divx_filename;
char* geometry = mccGuide_end_divx_geometry;
char* username1 = mccGuide_end_divx_username1;
char* username2 = mccGuide_end_divx_username2;
char* username3 = mccGuide_end_divx_username3;
int nowritefile = mccGuide_end_divx_nowritefile;
#line 311 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  double  XY=0;
  double  t0 = 0;
  double  t1 = 0;
  double  pp;
  int     intersect   = 0;
  char    Flag_Restore = 0;

  if (user1 != FLT_MAX) Vars.UserVariable1 = user1;
  if (user2 != FLT_MAX) Vars.UserVariable2 = user2;
  if (user3 != FLT_MAX) Vars.UserVariable3 = user3;

  /* this is done automatically
    STORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  */

  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    /* determine intersections with object */
    intersect = off_intersect_all(&t0, &t1, NULL, NULL,
       x,y,z, vx, vy, vz, &offdata );
    if (Vars.Flag_mantid) {
      if(intersect) {
        Vars.OFF_polyidx=(offdata.intersects[offdata.nextintersect]).index;
      } else {
        Vars.OFF_polyidx=-1;
      }
    }
  }
  else if ( (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
            || (abs(Vars.Flag_Shape) == DEFS.SHAPE_DISK) ) /* square xy or disk xy */
  {
    // propagate to xy plane and find intersection
    // make sure the event is recoverable afterwards
    t0 = t;
    ALLOW_BACKPROP;
    PROP_Z0;
    if ( (t>=t0) && (z==0.0) ) // forward propagation to xy plane was successful
    {
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
      {
        // square xy
        intersect = (x>=Vars.mxmin && x<=Vars.mxmax && y>=Vars.mymin && y<=Vars.mymax);
      }
      else
      {
        // disk xy
        intersect = (SQR(x) + SQR(y)) <= SQR(Vars.Sphere_Radius);
      }
    }
    else
    {
      intersect=0;
    }
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) /* sphere */
  {
    intersect = sphere_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius);
  /*      intersect = (intersect && t0 > 0); */
  }
  else if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)) /* cylinder */
  {
    intersect = cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius, Vars.Cylinder_Height);
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) /* box */
  {
    intersect = box_intersect(&t0, &t1, x, y, z, vx, vy, vz,
                              fabs(Vars.mxmax-Vars.mxmin), fabs(Vars.mymax-Vars.mymin), fabs(Vars.mzmax-Vars.mzmin));
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_PREVIOUS) /* previous comp */
  { intersect = 1; }

  if (intersect)
  {
    if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND)
     || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)
     || (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) )
    {
      /* check if we have to remove the top/bottom with BANANA shape */
      if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA) && (intersect != 1)) {
        double y0,y1;
        /* propagate to intersection point as temporary variable to check top/bottom */
        y0 = y+t0*vy;
        y1 = y+t1*vy;
        if (fabs(y0) >= Vars.Cylinder_Height/2*0.99) t0 = t1;
        if (fabs(y1) >= Vars.Cylinder_Height/2*0.99) t1 = t0;
      }
      if (t0 < 0 && t1 > 0)
        t0 = t;  /* neutron was already inside ! */
      if (t1 < 0 && t0 > 0) /* neutron exit before entering !! */
        t1 = t;
      /* t0 is now time of incoming intersection with the detection area */
      if ((Vars.Flag_Shape < 0) && (t1 > 0))
        PROP_DT(t1); /* t1 outgoing beam */
      else
        PROP_DT(t0); /* t0 incoming beam */
      /* Final test if we are on lid / bottom of banana/sphere */
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA || abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) {
        if (fabs(y) >= Vars.Cylinder_Height/2*0.99) {
          intersect=0;
          Flag_Restore=1;
        }
      }
    }
  }

  if (intersect)
  {
    /* Now get the data to monitor: current or keep from PreMonitor */
    if (Vars.Flag_UsePreMonitor != 1)
    {
      Vars.cp  = p;
      Vars.cx  = x;
      Vars.cvx = vx;
      Vars.csx = sx;
      Vars.cy  = y;
      Vars.cvy = vy;
      Vars.csy = sy;
      Vars.cz  = z;
      Vars.cvz = vz;
      Vars.csz = sz;
      Vars.ct  = t;
    }

    if ((Vars.He3_pressure > 0) && (t1 != t0) && ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX)))
    {
      XY = exp(-7.417*Vars.He3_pressure*fabs(t1-t0)*2*PI*K2V);
      /* will monitor the absorbed part */
      Vars.cp *= 1-XY;
      /* and modify the neutron weight after monitor, only remains 1-p_detect */
      p *= XY;
    }

    if (Vars.Flag_capture)
    {
      XY = sqrt(Vars.cvx*Vars.cvx+Vars.cvy*Vars.cvy+Vars.cvz*Vars.cvz);
      XY *= V2K;
      if (XY != 0) XY = 2*PI/XY; /* lambda. lambda(2200 m/2) = 1.7985 Angs  */
      Vars.cp *= XY/1.7985;
    }

    pp = Monitor_nD_Trace(&DEFS, &Vars);
    if (pp==0.0)
    { ABSORB;
    }
    else if(pp==1)
    {
      SCATTER;
    }

    if (Vars.Flag_parallel) /* back to neutron state before detection */
      Flag_Restore = 1;
  } /* end if intersection */
  else {
    if (Vars.Flag_Absorb && !Vars.Flag_parallel)
    {
      // restore neutron ray before absorbing for correct mcdisplay
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
      ABSORB;
    }
    else Flag_Restore = 1;  /* no intersection, back to previous state */
  }

  if (Flag_Restore)
  {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 68690 "./SNS_BASIS.c"
}   /* End of Guide_end_divx=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGuide_end_divx:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(115,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Guide_end_divy [116] */
  mccoordschange(mcposrGuide_end_divy, mcrotrGuide_end_divy,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Guide_end_divy (without coords transformations) */
  mcJumpTrace_Guide_end_divy:
  SIG_MESSAGE("Guide_end_divy (Trace)");
  mcDEBUG_COMP("Guide_end_divy")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGuide_end_divy
  STORE_NEUTRON(116,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[116]++;
  mcPCounter[116] += p;
  mcP2Counter[116] += p*p;
#define mccompcurname  Guide_end_divy
#define mccompcurtype  Monitor_nD
#define mccompcurindex 116
#define user1 mccGuide_end_divy_user1
#define user2 mccGuide_end_divy_user2
#define user3 mccGuide_end_divy_user3
#define DEFS mccGuide_end_divy_DEFS
#define Vars mccGuide_end_divy_Vars
#define detector mccGuide_end_divy_detector
#define offdata mccGuide_end_divy_offdata
{   /* Declarations of Guide_end_divy=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccGuide_end_divy_xwidth;
MCNUM yheight = mccGuide_end_divy_yheight;
MCNUM zdepth = mccGuide_end_divy_zdepth;
MCNUM xmin = mccGuide_end_divy_xmin;
MCNUM xmax = mccGuide_end_divy_xmax;
MCNUM ymin = mccGuide_end_divy_ymin;
MCNUM ymax = mccGuide_end_divy_ymax;
MCNUM zmin = mccGuide_end_divy_zmin;
MCNUM zmax = mccGuide_end_divy_zmax;
MCNUM bins = mccGuide_end_divy_bins;
MCNUM min = mccGuide_end_divy_min;
MCNUM max = mccGuide_end_divy_max;
MCNUM restore_neutron = mccGuide_end_divy_restore_neutron;
MCNUM radius = mccGuide_end_divy_radius;
char* options = mccGuide_end_divy_options;
char* filename = mccGuide_end_divy_filename;
char* geometry = mccGuide_end_divy_geometry;
char* username1 = mccGuide_end_divy_username1;
char* username2 = mccGuide_end_divy_username2;
char* username3 = mccGuide_end_divy_username3;
int nowritefile = mccGuide_end_divy_nowritefile;
#line 311 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  double  XY=0;
  double  t0 = 0;
  double  t1 = 0;
  double  pp;
  int     intersect   = 0;
  char    Flag_Restore = 0;

  if (user1 != FLT_MAX) Vars.UserVariable1 = user1;
  if (user2 != FLT_MAX) Vars.UserVariable2 = user2;
  if (user3 != FLT_MAX) Vars.UserVariable3 = user3;

  /* this is done automatically
    STORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  */

  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    /* determine intersections with object */
    intersect = off_intersect_all(&t0, &t1, NULL, NULL,
       x,y,z, vx, vy, vz, &offdata );
    if (Vars.Flag_mantid) {
      if(intersect) {
        Vars.OFF_polyidx=(offdata.intersects[offdata.nextintersect]).index;
      } else {
        Vars.OFF_polyidx=-1;
      }
    }
  }
  else if ( (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
            || (abs(Vars.Flag_Shape) == DEFS.SHAPE_DISK) ) /* square xy or disk xy */
  {
    // propagate to xy plane and find intersection
    // make sure the event is recoverable afterwards
    t0 = t;
    ALLOW_BACKPROP;
    PROP_Z0;
    if ( (t>=t0) && (z==0.0) ) // forward propagation to xy plane was successful
    {
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
      {
        // square xy
        intersect = (x>=Vars.mxmin && x<=Vars.mxmax && y>=Vars.mymin && y<=Vars.mymax);
      }
      else
      {
        // disk xy
        intersect = (SQR(x) + SQR(y)) <= SQR(Vars.Sphere_Radius);
      }
    }
    else
    {
      intersect=0;
    }
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) /* sphere */
  {
    intersect = sphere_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius);
  /*      intersect = (intersect && t0 > 0); */
  }
  else if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)) /* cylinder */
  {
    intersect = cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius, Vars.Cylinder_Height);
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) /* box */
  {
    intersect = box_intersect(&t0, &t1, x, y, z, vx, vy, vz,
                              fabs(Vars.mxmax-Vars.mxmin), fabs(Vars.mymax-Vars.mymin), fabs(Vars.mzmax-Vars.mzmin));
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_PREVIOUS) /* previous comp */
  { intersect = 1; }

  if (intersect)
  {
    if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND)
     || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)
     || (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) )
    {
      /* check if we have to remove the top/bottom with BANANA shape */
      if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA) && (intersect != 1)) {
        double y0,y1;
        /* propagate to intersection point as temporary variable to check top/bottom */
        y0 = y+t0*vy;
        y1 = y+t1*vy;
        if (fabs(y0) >= Vars.Cylinder_Height/2*0.99) t0 = t1;
        if (fabs(y1) >= Vars.Cylinder_Height/2*0.99) t1 = t0;
      }
      if (t0 < 0 && t1 > 0)
        t0 = t;  /* neutron was already inside ! */
      if (t1 < 0 && t0 > 0) /* neutron exit before entering !! */
        t1 = t;
      /* t0 is now time of incoming intersection with the detection area */
      if ((Vars.Flag_Shape < 0) && (t1 > 0))
        PROP_DT(t1); /* t1 outgoing beam */
      else
        PROP_DT(t0); /* t0 incoming beam */
      /* Final test if we are on lid / bottom of banana/sphere */
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA || abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) {
        if (fabs(y) >= Vars.Cylinder_Height/2*0.99) {
          intersect=0;
          Flag_Restore=1;
        }
      }
    }
  }

  if (intersect)
  {
    /* Now get the data to monitor: current or keep from PreMonitor */
    if (Vars.Flag_UsePreMonitor != 1)
    {
      Vars.cp  = p;
      Vars.cx  = x;
      Vars.cvx = vx;
      Vars.csx = sx;
      Vars.cy  = y;
      Vars.cvy = vy;
      Vars.csy = sy;
      Vars.cz  = z;
      Vars.cvz = vz;
      Vars.csz = sz;
      Vars.ct  = t;
    }

    if ((Vars.He3_pressure > 0) && (t1 != t0) && ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX)))
    {
      XY = exp(-7.417*Vars.He3_pressure*fabs(t1-t0)*2*PI*K2V);
      /* will monitor the absorbed part */
      Vars.cp *= 1-XY;
      /* and modify the neutron weight after monitor, only remains 1-p_detect */
      p *= XY;
    }

    if (Vars.Flag_capture)
    {
      XY = sqrt(Vars.cvx*Vars.cvx+Vars.cvy*Vars.cvy+Vars.cvz*Vars.cvz);
      XY *= V2K;
      if (XY != 0) XY = 2*PI/XY; /* lambda. lambda(2200 m/2) = 1.7985 Angs  */
      Vars.cp *= XY/1.7985;
    }

    pp = Monitor_nD_Trace(&DEFS, &Vars);
    if (pp==0.0)
    { ABSORB;
    }
    else if(pp==1)
    {
      SCATTER;
    }

    if (Vars.Flag_parallel) /* back to neutron state before detection */
      Flag_Restore = 1;
  } /* end if intersection */
  else {
    if (Vars.Flag_Absorb && !Vars.Flag_parallel)
    {
      // restore neutron ray before absorbing for correct mcdisplay
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
      ABSORB;
    }
    else Flag_Restore = 1;  /* no intersection, back to previous state */
  }

  if (Flag_Restore)
  {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 69000 "./SNS_BASIS.c"
}   /* End of Guide_end_divy=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGuide_end_divy:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(116,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Guide_end_PSD [117] */
  mccoordschange(mcposrGuide_end_PSD, mcrotrGuide_end_PSD,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Guide_end_PSD (without coords transformations) */
  mcJumpTrace_Guide_end_PSD:
  SIG_MESSAGE("Guide_end_PSD (Trace)");
  mcDEBUG_COMP("Guide_end_PSD")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompGuide_end_PSD
  STORE_NEUTRON(117,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[117]++;
  mcPCounter[117] += p;
  mcP2Counter[117] += p*p;
#define mccompcurname  Guide_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 117
#define PSD_N mccGuide_end_PSD_PSD_N
#define PSD_p mccGuide_end_PSD_PSD_p
#define PSD_p2 mccGuide_end_PSD_PSD_p2
{   /* Declarations of Guide_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGuide_end_PSD_nx;
int ny = mccGuide_end_PSD_ny;
char* filename = mccGuide_end_PSD_filename;
MCNUM xmin = mccGuide_end_PSD_xmin;
MCNUM xmax = mccGuide_end_PSD_xmax;
MCNUM ymin = mccGuide_end_PSD_ymin;
MCNUM ymax = mccGuide_end_PSD_ymax;
MCNUM xwidth = mccGuide_end_PSD_xwidth;
MCNUM yheight = mccGuide_end_PSD_yheight;
MCNUM restore_neutron = mccGuide_end_PSD_restore_neutron;
#line 94 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  PROP_Z0;
  if (x>xmin && x<xmax && y>ymin && y<ymax){
    int i = floor((x - xmin)*nx/(xmax - xmin));
    int j = floor((y - ymin)*ny/(ymax - ymin));
    PSD_N[i][j]++;
    PSD_p[i][j] += p;
    PSD_p2[i][j] += p*p;
    SCATTER;
  }
  if (restore_neutron) {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 69141 "./SNS_BASIS.c"
}   /* End of Guide_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompGuide_end_PSD:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(117,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Sample_split [118] */
  mccoordschange(mcposrSample_split, mcrotrSample_split,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Sample_split (without coords transformations) */
  mcJumpTrace_Sample_split:
  SIG_MESSAGE("Sample_split (Trace)");
  mcDEBUG_COMP("Sample_split")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompSample_split
  STORE_NEUTRON(118,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[118]++;
  mcPCounter[118] += p;
  mcP2Counter[118] += p*p;
#define mccompcurname  Sample_split
#define mccompcurtype  Arm
#define mccompcurindex 118
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompSample_split:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(118,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component SamplePos [119] */
  mccoordschange(mcposrSamplePos, mcrotrSamplePos,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component SamplePos (without coords transformations) */
  mcJumpTrace_SamplePos:
  SIG_MESSAGE("SamplePos (Trace)");
  mcDEBUG_COMP("SamplePos")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompSamplePos
  STORE_NEUTRON(119,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[119]++;
  mcPCounter[119] += p;
  mcP2Counter[119] += p*p;
#define mccompcurname  SamplePos
#define mccompcurtype  PSD_monitor
#define mccompcurindex 119
#define PSD_N mccSamplePos_PSD_N
#define PSD_p mccSamplePos_PSD_p
#define PSD_p2 mccSamplePos_PSD_p2
{   /* Declarations of SamplePos=PSD_monitor() SETTING parameters. */
int nx = mccSamplePos_nx;
int ny = mccSamplePos_ny;
char* filename = mccSamplePos_filename;
MCNUM xmin = mccSamplePos_xmin;
MCNUM xmax = mccSamplePos_xmax;
MCNUM ymin = mccSamplePos_ymin;
MCNUM ymax = mccSamplePos_ymax;
MCNUM xwidth = mccSamplePos_xwidth;
MCNUM yheight = mccSamplePos_yheight;
MCNUM restore_neutron = mccSamplePos_restore_neutron;
#line 94 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  PROP_Z0;
  if (x>xmin && x<xmax && y>ymin && y<ymax){
    int i = floor((x - xmin)*nx/(xmax - xmin));
    int j = floor((y - ymin)*ny/(ymax - ymin));
    PSD_N[i][j]++;
    PSD_p[i][j] += p;
    PSD_p2[i][j] += p*p;
    SCATTER;
  }
  if (restore_neutron) {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 69381 "./SNS_BASIS.c"
}   /* End of SamplePos=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompSamplePos:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(119,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Sample [120] */
  mccoordschange(mcposrSample, mcrotrSample,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Sample (without coords transformations) */
  mcJumpTrace_Sample:
  SIG_MESSAGE("Sample (Trace)");
  mcDEBUG_COMP("Sample")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompSample
  STORE_NEUTRON(120,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[120]++;
  mcPCounter[120] += p;
  mcP2Counter[120] += p*p;
#define mccompcurname  Sample
#define mccompcurtype  Isotropic_Sqw
#define mccompcurindex 120
#define powder_format mccSample_powder_format
#define VarSqw mccSample_VarSqw
#define columns mccSample_columns
#define offdata mccSample_offdata
{   /* Declarations of Sample=Isotropic_Sqw() SETTING parameters. */
char* Sqw_coh = mccSample_Sqw_coh;
char* Sqw_inc = mccSample_Sqw_inc;
char* geometry = mccSample_geometry;
MCNUM radius = mccSample_radius;
MCNUM thickness = mccSample_thickness;
MCNUM xwidth = mccSample_xwidth;
MCNUM yheight = mccSample_yheight;
MCNUM zdepth = mccSample_zdepth;
MCNUM threshold = mccSample_threshold;
int order = mccSample_order;
MCNUM T = mccSample_T;
MCNUM verbose = mccSample_verbose;
MCNUM d_phi = mccSample_d_phi;
int concentric = mccSample_concentric;
MCNUM rho = mccSample_rho;
MCNUM sigma_abs = mccSample_sigma_abs;
MCNUM sigma_coh = mccSample_sigma_coh;
MCNUM sigma_inc = mccSample_sigma_inc;
MCNUM classical = mccSample_classical;
MCNUM powder_Dd = mccSample_powder_Dd;
MCNUM powder_DW = mccSample_powder_DW;
MCNUM powder_Vc = mccSample_powder_Vc;
MCNUM density = mccSample_density;
MCNUM weight = mccSample_weight;
MCNUM p_interact = mccSample_p_interact;
MCNUM norm = mccSample_norm;
MCNUM powder_barns = mccSample_powder_barns;
char* quantum_correction = mccSample_quantum_correction;
#line 2176 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../samples/Isotropic_Sqw.comp"
{

int    intersect=0;     /* flag to continue/stop */
double t0,  t1,  t2,  t3; /* times for intersections */
double dt0, dt1, dt2, dt; /* time intervals */
double k=0, Ei=0;
double v=0, vf=0;
double d_path;        /* total path length for straight trajectory */
double my_a;          /* absorption cross-section scaled to velocity (2200) */
double ws, p_scatt;   /* probability for scattering/absorption and for */
                      /* interaction along d_path */
double tmp_rand;      /* temporary var */
double ratio_w=0, ratio_q=0; /* variables for bilinear interpolation */
double q11, q21, q22, q12;
double omega=0;       /* energy transfer */
double q=0;           /* wavevector transfer */
long   index_w;       /* energy index for table look-up SW */
long   index_q;       /* Q index for table look-up P(Q|w) */
double theta=0, costheta=0; /* for the choice of kf direction */
double u1x,u1y,u1z;
double u2x,u2y,u2z;
double u0x,u0y,u0z;
int    index_counter;
int    flag=0;
int    flag_concentric=0;
int    flag_ishollow=0;
double solid_angle=0;
double my_t=0;
double p_mult=1;
double mc_trans, p_trans, mc_scatt;
double coh=0, inc=0;
struct Sqw_Data_struct Data_sqw;


/* Store Initial neutron state */

VarSqw.ki_x = V2K*vx;
VarSqw.ki_y = V2K*vy;
VarSqw.ki_z = V2K*vz;
VarSqw.ti   = t;
VarSqw.vi   = 0;
VarSqw.ki   = 0;
VarSqw.type = '\0';

do { /* Main interaction loop. Ends with intersect=0 */

  /* Intersection neutron trajectory / sample (sample surface) */
  if (VarSqw.s_coh > 0 || VarSqw.s_inc > 0) {
    if (thickness >= 0) {
      if (VarSqw.shape==0)
        intersect=cylinder_intersect(&t0,&t3, x,y,z,vx,vy,vz, radius,yheight);
      else if (VarSqw.shape==1)
        intersect=box_intersect     (&t0,&t3, x,y,z,vx,vy,vz, xwidth,yheight,zdepth);
      else if (VarSqw.shape==2)
        intersect=sphere_intersect  (&t0,&t3, x,y,z,vx,vy,vz, radius);
      else if (VarSqw.shape == 3)
        intersect=off_intersect(&t0, &t3, NULL, NULL, x, y, z, vx, vy, vz, offdata );
    } else {
      if (VarSqw.shape==0)
        intersect=cylinder_intersect(&t0,&t3, x,y,z,vx,vy,vz, radius-thickness,
          yheight-2*thickness > 0 ? yheight-2*thickness : yheight);
      else if (VarSqw.shape==1)
        intersect=box_intersect     (&t0,&t3, x,y,z,vx,vy,vz,
          xwidth-2*thickness > 0 ?  xwidth-2*thickness : xwidth,
          yheight-2*thickness > 0 ? yheight-2*thickness : yheight,
          zdepth-2*thickness > 0 ?  zdepth-2*thickness : zdepth);
      else if (VarSqw.shape==2)
        intersect=sphere_intersect  (&t0,&t3, x,y,z,vx,vy,vz, radius-thickness);
      else if (VarSqw.shape == 3)
        intersect=off_intersect(&t0, &t3, NULL, NULL, x, y, z, vx, vy, vz, offdata );
    }
  } else intersect=0;

  /* Computing the intermediate times */
  if (intersect) {
    flag_ishollow = 0;
    if (thickness > 0) {
      if (VarSqw.shape==0 && cylinder_intersect(&t1,&t2, x,y,z,vx,vy,vz, radius-thickness,
        yheight-2*thickness > 0 ? yheight-2*thickness : yheight))
        flag_ishollow=1;
      else if (VarSqw.shape==2 && sphere_intersect   (&t1,&t2, x,y,z,vx,vy,vz, radius-thickness))
        flag_ishollow=1;
      else if (VarSqw.shape==1 && box_intersect(&t1,&t2, x,y,z,vx,vy,vz,
        xwidth-2*thickness > 0 ? xwidth-2*thickness : xwidth,
        yheight-2*thickness > 0 ? yheight-2*thickness : yheight,
        zdepth-2*thickness > 0 ? zdepth-2*thickness : zdepth))
        flag_ishollow=1;
    } else if (thickness<0) {
      if (VarSqw.shape==0 && cylinder_intersect(&t1,&t2, x,y,z,vx,vy,vz, radius,yheight))
        flag_ishollow=1;
      else if (VarSqw.shape==2 && sphere_intersect   (&t1,&t2, x,y,z,vx,vy,vz, radius))
        flag_ishollow=1;
      else if (VarSqw.shape==1 && box_intersect(&t1,&t2, x,y,z,vx,vy,vz, xwidth, yheight, zdepth))
        flag_ishollow=1;
    }
    if (!flag_ishollow) t1 = t2 = t3; /* no empty space inside */
  } else break; /* neutron does not hit sample: transmitted  */

  if (intersect) { /* the neutron hits the sample */

    if (t0 > 0) {  /* we are before the sample */
      PROP_DT(t0); /* propagates neutron to the entry of the sample */
    } else if (t1 > 0 && t1 > t0) { /* we are inside first part of the sample */
      /* no propagation, stay inside */
    } else if (t2 > 0 && t2 > t1) { /* we are in the hole */
      PROP_DT(t2); /* propagate to inner surface of 2nd part of sample */
    } else if (t3 > 0 && t3 > t2) { /* we are in the 2nd part of sample */
      /* no propagation, stay inside */
    }

    dt0=t1-(t0 > 0 ? t0 : 0); /* Time in first part of hollow/cylinder/box */
    dt1=t2-(t1 > 0 ? t1 : 0); /* Time in hole */
    dt2=t3-(t2 > 0 ? t2 : 0); /* Time in 2nd part of hollow cylinder */

    if (dt0 < 0) dt0 = 0;
    if (dt1 < 0) dt1 = 0;
    if (dt2 < 0) dt2 = 0;

    /* initialize concentric mode */
    if (concentric && !flag_concentric && t0 >= 0
     && VarSqw.shape==0 && thickness) {
      flag_concentric=1;
    }

    if (flag_concentric == 1) {
      dt1=dt2=0; /* force exit when reaching hole/2nd part */
    }

    if (!dt0 && !dt2) {
      intersect = 0; /* the sample was passed entirely */
      break;
    }

    VarSqw.neutron_enter++;
    p_mult = 1;
    if (!v) {
      v  = vx*vx+vy*vy+vz*vz;
      v = sqrt(v);
    }
    k  = V2K*v;
    Ei = VS2E*v*v;

    if (!VarSqw.vi) VarSqw.vi = v;
    if (!VarSqw.ki) VarSqw.ki = k;

    if (v <= 0) {
      printf("Isotropic_Sqw: %s: ERROR: Null velocity !\n",NAME_CURRENT_COMP);
      VarSqw.neutron_removed++;
      ABSORB; /* should never occur */
    }

    /* check for scattering event */
    my_a   = VarSqw.my_a_v / v; /* absorption 'mu' */
    /* compute total scattering X section */
    /* \int q S(q) dq /2 /ki^2 sigma  OR  bare Xsection*/
    /* contains the 4*PI*kf/ki factor */
    coh = VarSqw.s_coh;
    inc = VarSqw.s_inc;
    if (k && VarSqw.s_coh>0 && VarSqw.Data_coh.intensity) {
      double Ei       = VS2E*v*v;
      double index_Ei = Ei / (VarSqw.Data_coh.Ei_max/VarSqw.Data_coh.iqSq_length);
      coh = Table_Value2d(VarSqw.Data_coh.iqSq, index_Ei, 0);
    }
    if (k && VarSqw.s_inc>0 && VarSqw.Data_inc.intensity) {
      double Ei       = VS2E*v*v;
      double index_Ei = Ei / (VarSqw.Data_inc.Ei_max/VarSqw.Data_inc.iqSq_length);
      inc = Table_Value2d(VarSqw.Data_inc.iqSq, index_Ei, 0);
    }
    if (coh<0) coh=0;
    if (inc<0) inc=0;
    VarSqw.my_s    =(VarSqw.mat_rho*100*(coh + inc));

    my_t = my_a + VarSqw.my_s;  /* total scattering Xsect */
    if (my_t <= 0) {
      if (VarSqw.neutron_removed<VarSqw.maxloop) printf("Isotropic_Sqw: %s: ERROR: Null total cross section %g. Removing event.\n",
        NAME_CURRENT_COMP, my_t);
      VarSqw.neutron_removed++;
      ABSORB; /* should never occur */
    } else if (VarSqw.my_s <= 0) {
      if (VarSqw.verbose_output > 1 && VarSqw.neutron_removed<VarSqw.maxloop)
        printf("Isotropic_Sqw: %s: Warning: Null scattering cross section %g. Ignoring.\n",
          NAME_CURRENT_COMP, VarSqw.my_s);
      VarSqw.my_s = 0;
    }

    /* Proba of scattering vs absorption (integrating along the whole trajectory) */
    ws = VarSqw.my_s/my_t;  /* (inc+coh)/(inc+coh+abs) */
    d_path = v*( dt0 +dt2 );    /* total path lenght in sample */
    /* Proba of transmission/interaction along length d_path */
    p_trans = exp(-my_t*d_path);
    p_scatt = 1 - p_trans; /* portion of beam which scatters */

    flag = 0; /* flag used for propagation to exit point before ending */

    /* are we next to the exit ? probably no scattering (avoid rounding errors) */
    if (VarSqw.my_s*d_path <= 4e-7) {
      flag = 1;           /* No interaction before the exit */
    }
    /* force a given fraction of the beam to scatter */
    if (p_interact>0 && p_interact<=1) {
      /* we force a portion of the beam to interact */
      /* This is used to improve statistics on single scattering (and multiple) */
      if (!SCATTERED) mc_trans = 1-p_interact;
      else            mc_trans = 1-p_interact/(4*SCATTERED+1); /* reduce effect on multi scatt */
    } else {
      mc_trans = p_trans; /* 1 - p_scatt */
    }
    mc_scatt = 1 - mc_trans; /* portion of beam to scatter (or force to) */
    if (mc_scatt <= 0 || mc_scatt>1) flag=1;
    /* MC choice: Interaction or transmission ? */
    if (!flag && mc_scatt > 0 && (mc_scatt >= 1 || rand01() < mc_scatt)) { /* Interaction neutron/sample */
      p_mult *= ws; /* Update weight ; account for absorption and retain scattered fraction */
      /* we have chosen portion mc_scatt of beam instead of p_scatt, so we compensate */
      if (!mc_scatt) ABSORB;
      p_mult *= fabs(p_scatt/mc_scatt); /* lower than 1 */
    } else {
      flag = 1; /* Transmission : no interaction neutron/sample */
      if (!VarSqw.type) VarSqw.type = 't';
      if (!mc_trans) ABSORB;
      p_mult *= fabs(p_trans/mc_trans);  /* attenuate beam by portion which is scattered (and left along) */
    }

    if (flag) { /* propagate to exit of sample and finish */
      intersect = 0;
      p *= p_mult; /* apply absorption correction */
      PROP_DT(dt0+dt2);
      break; /* exit main multi scatt while loop */
    }
  } /* end if intersect the neutron hits the sample */
  else break;

  if (intersect) { /* scattering event */
    double kf=0, kf1, kf2;
    /* mean scattering probability and absorption fraction */
    VarSqw.mean_scatt += (1-exp(-VarSqw.my_s*d_path))*p;
    VarSqw.mean_abs   += (1-ws)*p;
    VarSqw.psum_scatt += p;

    /* Decaying exponential distribution of the path length before scattering */
    /* Select a point at which to scatter the neutron, taking
         secondary extinction into account. */
    if (my_t*d_path < 1e-6)
    /* For very weak scattering, use simple uniform sampling of scattering
       point to avoid rounding errors. */
      dt = rand0max(d_path); /* length */
    else
      dt = -log(1 - rand0max((1 - exp(-my_t*d_path)))) / my_t; /* length */
    dt /= v; /* Time from present position to scattering point */

    /* If t0 is in hole, propagate to next part of the hollow cylinder */
    if (dt1 > 0 && dt0 > 0 && dt > dt0) dt += dt1;

    /* Neutron propagation to the scattering point */
    PROP_DT(dt);

    /* choice between coherent/incoherent scattering */
    tmp_rand = rand01();
    /* local description at the scattering point (scat probability for atom) */
    tmp_rand *= (coh+inc);

    flag=0;
    if (VarSqw.s_inc>0 && tmp_rand < inc) {
      /* CASE 1: incoherent case */
      if (!VarSqw.Data_inc.intensity) {
        /* CASE 1a: no incoherent Sqw from file, use isotropic V-like */
        if (d_phi && order == 1) {
          randvec_target_rect_angular(&u1x, &u1y, &u1z, &solid_angle,
              vx, vy, vz, 2*PI, d_phi, ROT_A_CURRENT_COMP);
          p_mult *= solid_angle/4/PI; /* weighted by focused range to total range */
        } else
          randvec_target_circle(&u1x, &u1y, &u1z, NULL, vx, vy, vz, 0);

        vx = u1x; vy = u1y; vz = u1z;
        vf = v; kf = k;
        if (!VarSqw.type) VarSqw.type = 'v';
        SCATTER;
      } else {
        /* CASE 1b: incoherent Sqw from file */
        if (VarSqw.Data_inc.intensity) {
          Data_sqw = VarSqw.Data_inc;
          if (!VarSqw.type) VarSqw.type = 'i';
          flag = 1;
        }
      }
    } else if (VarSqw.s_coh>0 && tmp_rand > VarSqw.s_inc) {
      if (VarSqw.Data_coh.intensity) {
        /* CASE2: coherent case */
        Data_sqw = VarSqw.Data_coh;
        if (!VarSqw.type) VarSqw.type = 'c';
        flag = 1;
      }
    }

    if (flag) { /* true when S(q,w) table exists (Data_sqw) */

      double alpha=0, alpha0;
      /* give us a limited number of tries for scattering: choose W then Q */
      for (index_counter=VarSqw.maxloop; index_counter > 0 ; index_counter--) {

        /* MC choice: energy transfer w=Ei-Ef in the S(w) = SW */
        omega = 0;
        tmp_rand = rand01();
        /* energy index for rand > cumul SW */
        index_w  = Sqw_search_SW(Data_sqw, tmp_rand);
        VarSqw.rw = (double)index_w;
        if (index_w >= 0 && &(Data_sqw.SW[index_w]) != NULL) {
          if (Data_sqw.w_bins > 1) {
            double w1, w2;
            if (index_w > 0) { /* interpolate linearly energy */
              ratio_w = (tmp_rand                         - Data_sqw.SW[index_w-1].cumul_proba)
                       /(Data_sqw.SW[index_w].cumul_proba - Data_sqw.SW[index_w-1].cumul_proba);
              /* ratio_w=0 omega[index_w-1], ratio=1 omega[index] */
              w1 = Data_sqw.SW[index_w-1].omega; w2 = Data_sqw.SW[index_w].omega;
            } else { /* index_w = 0 interpolate to 0 energy */
              /* ratio_w=0 omega=0, ratio=1 omega[index] */
              w1 = Data_sqw.SW[index_w].omega; w2= Data_sqw.SW[index_w+1].omega;
              if (!w2 && index_w+1 < Data_sqw.w_bins)
                w2= Data_sqw.SW[index_w+1].omega;
              if (Data_sqw.w_bins && Data_sqw.SW[index_w].cumul_proba) {
                ratio_w = tmp_rand/Data_sqw.SW[index_w].cumul_proba;
              } else ratio_w=0;
            }
            if (ratio_w<0) ratio_w=0; else if (ratio_w>1) ratio_w=1;
            omega = (1-ratio_w)*w1 + ratio_w*w2;
          } else {
            ratio_w = 0;
            omega = Data_sqw.SW[index_w].omega;
          }
        } else {
          if (VarSqw.verbose_output >= 3 && VarSqw.neutron_removed<VarSqw.maxloop)
            printf("Isotropic_Sqw: %s: Warning: No suitable w transfer for index_w=%li.\n",
              NAME_CURRENT_COMP, index_w);
          continue; /* no W value: try again with an other energy transfer */
        }

        /* MC choice: momentum transfer Q in P(Q|w) */
        tmp_rand = rand01();

        /* momentum index for rand > cumul SQ|W */
        index_q  = Sqw_search_Q_proba_per_w(Data_sqw, tmp_rand, index_w);
        VarSqw.rq = (double)index_q;

        if (index_q >= 0 && &(Data_sqw.SQW[index_w]) != NULL) {
          if (Data_sqw.q_bins > 1 && index_q > 0) {
            if (index_w > 0 && Data_sqw.w_bins > 1) {
              /* bilinear interpolation on - side: index_w > 0, index_q > 0 */
              ratio_q = (tmp_rand - Data_sqw.SQW[index_w][index_q-1].cumul_proba)
                       /(Data_sqw.SQW[index_w][index_q].cumul_proba
                       - Data_sqw.SQW[index_w][index_q-1].cumul_proba);
              q22 = Data_sqw.SQW[index_w]  [index_q].Q;
              q11 = Data_sqw.SQW[index_w-1][index_q-1].Q;
              q21 = Data_sqw.SQW[index_w]  [index_q-1].Q;
              q12 = Data_sqw.SQW[index_w-1][index_q].Q;
              if (ratio_q<0) ratio_q=0; else if (ratio_q>1) ratio_q=1;
              q = (1-ratio_w)*(1-ratio_q)*q11+ratio_w*(1-ratio_q)*q21
                + ratio_w*ratio_q*q22        +(1-ratio_w)*ratio_q*q12;
            } else { /* bilinear interpolation on + side: index_w=0, index_q > 0 */
              ratio_q = (tmp_rand - Data_sqw.SQW[index_w][index_q-1].cumul_proba)
                       /(Data_sqw.SQW[index_w][index_q].cumul_proba
                       - Data_sqw.SQW[index_w][index_q-1].cumul_proba);
              q11 = Data_sqw.SQW[index_w]  [index_q-1].Q;
              q12 = Data_sqw.SQW[index_w]  [index_q].Q;
              if (ratio_q<0) ratio_q=0; else if (ratio_q>1) ratio_q=1;
              if (index_w < Data_sqw.w_bins-1 && Data_sqw.w_bins > 1) {
                q22 = Data_sqw.SQW[index_w+1][index_q].Q;
                q21 = Data_sqw.SQW[index_w+1][index_q-1].Q;
                q = (1-ratio_w)*(1-ratio_q)*q11+ratio_w*(1-ratio_q)*q21
                  + ratio_w*ratio_q*q22        +(1-ratio_w)*ratio_q*q12;
              } else {
                q    = (1-ratio_q)*q11  + ratio_q*q12;
              }
            }
          } else {
            q    = Data_sqw.SQW[index_w][index_q].Q;
          }
        } else {
          if (VarSqw.verbose_output >= 3 && VarSqw.neutron_removed<VarSqw.maxloop)
            printf("Isotropic_Sqw: %s: Warning: No suitable q transfer for w=%g.\n",
              NAME_CURRENT_COMP, omega);
          VarSqw.neutron_removed++;
          continue; /* no Q value for this w choice */
        }

        /* Search for length of final wave vector kf */
        /* kf is such that : hbar*w = hbar*hbar/2/m*(k*k - kf*kf) */
        /* acceptable values for kf are kf1 and kf2 */
        if (!solve_2nd_order(&kf1, &kf2, 1, 0, -k*k + VarSqw.sqSE2K*omega)) {
          if (VarSqw.verbose_output >= 3 && VarSqw.neutron_removed<VarSqw.maxloop)
            printf("Isotropic_Sqw: %s: Warning: imaginary root for w=%g q=%g Ei=%g (triangle can not close)\n",
            NAME_CURRENT_COMP, omega, q, Ei);
          VarSqw.neutron_removed++;
          continue; /* all roots are imaginary */
        }

        /* kf1 and kf2 are opposite */
        kf = fabs(kf1);
        vf = K2V*kf;

        /* Search of the direction of kf such that : q = ki - kf */
        /* cos theta = (ki2+kf2-q2)/(2ki kf) */

        costheta= (k*k+kf*kf-q*q)/(2*kf*k); /* this is cos(theta) */

        if (-1 < costheta && costheta < 1) {
          break; /* satisfies q momentum conservation */
        }
/*      else continue; */

        /* exit for loop on success */
      } /* end for index_counter */

      if (!index_counter) { /* for loop ended: failure for scattering */
        intersect=0; /* Could not scatter: finish multiple scattering loop */
        if (VarSqw.verbose_output >= 2 && VarSqw.neutron_removed<VarSqw.maxloop)
          printf("Isotropic_Sqw: %s: Warning: No scattering [q,w] conditions\n"
               "               last try (%i): type=%c w=%g q=%g cos(theta)=%g k=%g\n",
          NAME_CURRENT_COMP, VarSqw.maxloop, (VarSqw.type ? VarSqw.type : '-'), omega, q, costheta, k);
        VarSqw.neutron_removed++;
        if (order && SCATTERED != order) ABSORB;
        break;       /* finish multiple scattering loop */
      }

      /* scattering angle from ki to DS cone */
      theta = acos(costheta);

      /* Choose point on Debye-Scherrer cone */
      if (order == 1 && d_phi)
      { /* relate height of detector to the height on DS cone */
        double cone_focus;
        cone_focus = sin(d_phi/2)/sin(theta);
        /* If full Debye-Scherrer cone is within d_phi, don't focus */
        if (cone_focus < -1 || cone_focus > 1) d_phi = 0;
        /* Otherwise, determine alpha to rotate from scattering plane
            into d_phi focusing area*/
        else alpha = 2*asin(cone_focus);
        if (d_phi) p_mult *= alpha/PI;
      }
      if (d_phi) {
        /* Focusing */
        alpha = fabs(alpha);
        /* Trick to get scattering for pos/neg theta's */
        alpha0= 2*rand01()*alpha;
        if (alpha0 > alpha) {
          alpha0=PI+(alpha0-1.5*alpha);
        } else {
          alpha0=alpha0-0.5*alpha;
        }
      }
      else
        alpha0 = PI*randpm1();

      /* now find a nearly vertical rotation axis (u1) :
	       * Either
	       *  (v along Z) x (X axis) -> nearly Y axis
	       * Or
	       *  (v along X) x (Z axis) -> nearly Y axis
	       */
	    if (fabs(scalar_prod(1,0,0,vx/v,vy/v,vz/v)) < fabs(scalar_prod(0,0,1,vx/v,vy/v,vz/v))) {
        u1x = 1; u1y = u1z = 0;
	    } else {
        u1x = u1y = 0; u1z = 1;
	    }
	    vec_prod(u2x,u2y,u2z, vx,vy,vz, u1x,u1y,u1z);

      /* handle case where v and aim are parallel */
      if (!u2x && !u2y && !u2z) { u2x=u2z=0; u2y=1; }

      /* u1 = rotate 'v' by theta around u2: DS scattering angle, nearly in horz plane */
      rotate(u1x,u1y,u1z, vx,vy,vz, theta, u2x,u2y,u2z);

      /* u0 = rotate u1 by alpha0 around 'v' (Debye-Scherrer cone) */
      rotate(u0x,u0y,u0z, u1x,u1y,u1z, alpha0, vx, vy, vz);
      NORM(u0x,u0y,u0z);
      vx = u0x*vf;
      vy = u0y*vf;
      vz = u0z*vf;

      SCATTER;

      v = vf; k = kf; /* for next iteration */

    } /* end if (flag) */

    VarSqw.neutron_exit++;
    p *= p_mult;
    if (p_mult > 1) VarSqw.neutron_pmult++;

    /* test for a given multiple order */
    if (order && SCATTERED >= order) {
      intersect=0; /* reached required number of SCATTERing */
      break;       /* finish multiple scattering loop */
    }

  } /* end if (intersect) scattering event  */

} while (intersect); /* end do (intersect) (multiple scattering loop) */

/* Store Final neutron state */
VarSqw.kf_x = V2K*vx;
VarSqw.kf_y = V2K*vy;
VarSqw.kf_z = V2K*vz;
VarSqw.tf   = t;
VarSqw.vf   = v;
VarSqw.kf   = k;
VarSqw.theta= theta;

if (SCATTERED) {



  if (SCATTERED == 1) {
    if (VarSqw.type == 'c') VarSqw.single_coh += p;
    else                    VarSqw.single_inc += p;
    VarSqw.dq = sqrt((VarSqw.kf_x-VarSqw.ki_x)*(VarSqw.kf_x-VarSqw.ki_x)
                  +(VarSqw.kf_y-VarSqw.ki_y)*(VarSqw.kf_y-VarSqw.ki_y)
                  +(VarSqw.kf_z-VarSqw.ki_z)*(VarSqw.kf_z-VarSqw.ki_z));
    VarSqw.dw = VS2E*(VarSqw.vf*VarSqw.vf - VarSqw.vi*VarSqw.vi);
  } else VarSqw.multi += p;

} else VarSqw.dq=VarSqw.dw=0;

/* end TRACE */
}
#line 70046 "./SNS_BASIS.c"
/* 'Sample=Isotropic_Sqw()' component instance extend code */
    SIG_MESSAGE("Sample (Trace:Extend)");
#line 886 "/zhome/89/0/38697/TESTS/2019-11-20/McStas-2.5_CPU_MPICC/SNS_BASIS/SNS_BASIS.instr"
  if (!SCATTERED) ABSORB;
#line 70051 "./SNS_BASIS.c"
}   /* End of Sample=Isotropic_Sqw() SETTING parameter declarations. */
#undef offdata
#undef columns
#undef VarSqw
#undef powder_format
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompSample:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(120,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component An1_rot_axis [121] */
  mccoordschange(mcposrAn1_rot_axis, mcrotrAn1_rot_axis,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component An1_rot_axis (without coords transformations) */
  mcJumpTrace_An1_rot_axis:
  SIG_MESSAGE("An1_rot_axis (Trace)");
  mcDEBUG_COMP("An1_rot_axis")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAn1_rot_axis
  STORE_NEUTRON(121,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[121]++;
  mcPCounter[121] += p;
  mcP2Counter[121] += p*p;
#define mccompcurname  An1_rot_axis
#define mccompcurtype  Arm
#define mccompcurindex 121
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAn1_rot_axis:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(121,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component An2_rot_axis [122] */
  mccoordschange(mcposrAn2_rot_axis, mcrotrAn2_rot_axis,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component An2_rot_axis (without coords transformations) */
  mcJumpTrace_An2_rot_axis:
  SIG_MESSAGE("An2_rot_axis (Trace)");
  mcDEBUG_COMP("An2_rot_axis")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAn2_rot_axis
  STORE_NEUTRON(122,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[122]++;
  mcPCounter[122] += p;
  mcP2Counter[122] += p*p;
#define mccompcurname  An2_rot_axis
#define mccompcurtype  Arm
#define mccompcurindex 122
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAn2_rot_axis:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(122,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component An3_rot_axis [123] */
  mccoordschange(mcposrAn3_rot_axis, mcrotrAn3_rot_axis,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component An3_rot_axis (without coords transformations) */
  mcJumpTrace_An3_rot_axis:
  SIG_MESSAGE("An3_rot_axis (Trace)");
  mcDEBUG_COMP("An3_rot_axis")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAn3_rot_axis
  STORE_NEUTRON(123,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[123]++;
  mcPCounter[123] += p;
  mcP2Counter[123] += p*p;
#define mccompcurname  An3_rot_axis
#define mccompcurtype  Arm
#define mccompcurindex 123
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAn3_rot_axis:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(123,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component An1_ToF [124] */
  mccoordschange(mcposrAn1_ToF, mcrotrAn1_ToF,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component An1_ToF (without coords transformations) */
  mcJumpTrace_An1_ToF:
  SIG_MESSAGE("An1_ToF (Trace)");
  mcDEBUG_COMP("An1_ToF")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAn1_ToF
  STORE_NEUTRON(124,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[124]++;
  mcPCounter[124] += p;
  mcP2Counter[124] += p*p;
#define mccompcurname  An1_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 124
#define nt mccAn1_ToF_nt
#define TOF_N mccAn1_ToF_TOF_N
#define TOF_p mccAn1_ToF_TOF_p
#define TOF_p2 mccAn1_ToF_TOF_p2
#define t_min mccAn1_ToF_t_min
#define t_max mccAn1_ToF_t_max
#define delta_t mccAn1_ToF_delta_t
{   /* Declarations of An1_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccAn1_ToF_filename;
MCNUM xmin = mccAn1_ToF_xmin;
MCNUM xmax = mccAn1_ToF_xmax;
MCNUM ymin = mccAn1_ToF_ymin;
MCNUM ymax = mccAn1_ToF_ymax;
MCNUM xwidth = mccAn1_ToF_xwidth;
MCNUM yheight = mccAn1_ToF_yheight;
MCNUM tmin = mccAn1_ToF_tmin;
MCNUM tmax = mccAn1_ToF_tmax;
MCNUM dt = mccAn1_ToF_dt;
MCNUM restore_neutron = mccAn1_ToF_restore_neutron;
int nowritefile = mccAn1_ToF_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 70508 "./SNS_BASIS.c"
}   /* End of An1_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAn1_ToF:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(124,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component An1_ToF_variable_range [125] */
  mccoordschange(mcposrAn1_ToF_variable_range, mcrotrAn1_ToF_variable_range,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component An1_ToF_variable_range (without coords transformations) */
  mcJumpTrace_An1_ToF_variable_range:
  SIG_MESSAGE("An1_ToF_variable_range (Trace)");
  mcDEBUG_COMP("An1_ToF_variable_range")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAn1_ToF_variable_range
  STORE_NEUTRON(125,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[125]++;
  mcPCounter[125] += p;
  mcP2Counter[125] += p*p;
#define mccompcurname  An1_ToF_variable_range
#define mccompcurtype  TOF_monitor
#define mccompcurindex 125
#define nt mccAn1_ToF_variable_range_nt
#define TOF_N mccAn1_ToF_variable_range_TOF_N
#define TOF_p mccAn1_ToF_variable_range_TOF_p
#define TOF_p2 mccAn1_ToF_variable_range_TOF_p2
#define t_min mccAn1_ToF_variable_range_t_min
#define t_max mccAn1_ToF_variable_range_t_max
#define delta_t mccAn1_ToF_variable_range_delta_t
{   /* Declarations of An1_ToF_variable_range=TOF_monitor() SETTING parameters. */
char* filename = mccAn1_ToF_variable_range_filename;
MCNUM xmin = mccAn1_ToF_variable_range_xmin;
MCNUM xmax = mccAn1_ToF_variable_range_xmax;
MCNUM ymin = mccAn1_ToF_variable_range_ymin;
MCNUM ymax = mccAn1_ToF_variable_range_ymax;
MCNUM xwidth = mccAn1_ToF_variable_range_xwidth;
MCNUM yheight = mccAn1_ToF_variable_range_yheight;
MCNUM tmin = mccAn1_ToF_variable_range_tmin;
MCNUM tmax = mccAn1_ToF_variable_range_tmax;
MCNUM dt = mccAn1_ToF_variable_range_dt;
MCNUM restore_neutron = mccAn1_ToF_variable_range_restore_neutron;
int nowritefile = mccAn1_ToF_variable_range_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 70659 "./SNS_BASIS.c"
}   /* End of An1_ToF_variable_range=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAn1_ToF_variable_range:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(125,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component An1_Lam [126] */
  mccoordschange(mcposrAn1_Lam, mcrotrAn1_Lam,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component An1_Lam (without coords transformations) */
  mcJumpTrace_An1_Lam:
  SIG_MESSAGE("An1_Lam (Trace)");
  mcDEBUG_COMP("An1_Lam")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAn1_Lam
  STORE_NEUTRON(126,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[126]++;
  mcPCounter[126] += p;
  mcP2Counter[126] += p*p;
#define mccompcurname  An1_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 126
#define nL mccAn1_Lam_nL
#define L_N mccAn1_Lam_L_N
#define L_p mccAn1_Lam_L_p
#define L_p2 mccAn1_Lam_L_p2
{   /* Declarations of An1_Lam=L_monitor() SETTING parameters. */
char* filename = mccAn1_Lam_filename;
MCNUM xmin = mccAn1_Lam_xmin;
MCNUM xmax = mccAn1_Lam_xmax;
MCNUM ymin = mccAn1_Lam_ymin;
MCNUM ymax = mccAn1_Lam_ymax;
MCNUM xwidth = mccAn1_Lam_xwidth;
MCNUM yheight = mccAn1_Lam_yheight;
MCNUM Lmin = mccAn1_Lam_Lmin;
MCNUM Lmax = mccAn1_Lam_Lmax;
MCNUM restore_neutron = mccAn1_Lam_restore_neutron;
int nowritefile = mccAn1_Lam_nowritefile;
#line 84 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 70809 "./SNS_BASIS.c"
}   /* End of An1_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAn1_Lam:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(126,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component An1_Lam_variable_range [127] */
  mccoordschange(mcposrAn1_Lam_variable_range, mcrotrAn1_Lam_variable_range,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component An1_Lam_variable_range (without coords transformations) */
  mcJumpTrace_An1_Lam_variable_range:
  SIG_MESSAGE("An1_Lam_variable_range (Trace)");
  mcDEBUG_COMP("An1_Lam_variable_range")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAn1_Lam_variable_range
  STORE_NEUTRON(127,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[127]++;
  mcPCounter[127] += p;
  mcP2Counter[127] += p*p;
#define mccompcurname  An1_Lam_variable_range
#define mccompcurtype  L_monitor
#define mccompcurindex 127
#define nL mccAn1_Lam_variable_range_nL
#define L_N mccAn1_Lam_variable_range_L_N
#define L_p mccAn1_Lam_variable_range_L_p
#define L_p2 mccAn1_Lam_variable_range_L_p2
{   /* Declarations of An1_Lam_variable_range=L_monitor() SETTING parameters. */
char* filename = mccAn1_Lam_variable_range_filename;
MCNUM xmin = mccAn1_Lam_variable_range_xmin;
MCNUM xmax = mccAn1_Lam_variable_range_xmax;
MCNUM ymin = mccAn1_Lam_variable_range_ymin;
MCNUM ymax = mccAn1_Lam_variable_range_ymax;
MCNUM xwidth = mccAn1_Lam_variable_range_xwidth;
MCNUM yheight = mccAn1_Lam_variable_range_yheight;
MCNUM Lmin = mccAn1_Lam_variable_range_Lmin;
MCNUM Lmax = mccAn1_Lam_variable_range_Lmax;
MCNUM restore_neutron = mccAn1_Lam_variable_range_restore_neutron;
int nowritefile = mccAn1_Lam_variable_range_nowritefile;
#line 84 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 70956 "./SNS_BASIS.c"
}   /* End of An1_Lam_variable_range=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAn1_Lam_variable_range:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(127,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component An1_E [128] */
  mccoordschange(mcposrAn1_E, mcrotrAn1_E,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component An1_E (without coords transformations) */
  mcJumpTrace_An1_E:
  SIG_MESSAGE("An1_E (Trace)");
  mcDEBUG_COMP("An1_E")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAn1_E
  STORE_NEUTRON(128,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[128]++;
  mcPCounter[128] += p;
  mcP2Counter[128] += p*p;
#define mccompcurname  An1_E
#define mccompcurtype  E_monitor
#define mccompcurindex 128
#define nE mccAn1_E_nE
#define E_N mccAn1_E_E_N
#define E_p mccAn1_E_E_p
#define E_p2 mccAn1_E_E_p2
#define S_p mccAn1_E_S_p
#define S_pE mccAn1_E_S_pE
#define S_pE2 mccAn1_E_S_pE2
{   /* Declarations of An1_E=E_monitor() SETTING parameters. */
char* filename = mccAn1_E_filename;
MCNUM xmin = mccAn1_E_xmin;
MCNUM xmax = mccAn1_E_xmax;
MCNUM ymin = mccAn1_E_ymin;
MCNUM ymax = mccAn1_E_ymax;
MCNUM xwidth = mccAn1_E_xwidth;
MCNUM yheight = mccAn1_E_yheight;
MCNUM Emin = mccAn1_E_Emin;
MCNUM Emax = mccAn1_E_Emax;
MCNUM restore_neutron = mccAn1_E_restore_neutron;
int nowritefile = mccAn1_E_nowritefile;
#line 89 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
{
    int i;
    double E;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      E = VS2E*(vx*vx + vy*vy + vz*vz);

      S_p += p;
      S_pE += p*E;
      S_pE2 += p*E*E;

      i = floor((E-Emin)*nE/(Emax-Emin));
      if(i >= 0 && i < nE)
      {
        E_N[i]++;
        E_p[i] += p;
        E_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 71111 "./SNS_BASIS.c"
}   /* End of An1_E=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAn1_E:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(128,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component An1_E_variable_range [129] */
  mccoordschange(mcposrAn1_E_variable_range, mcrotrAn1_E_variable_range,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component An1_E_variable_range (without coords transformations) */
  mcJumpTrace_An1_E_variable_range:
  SIG_MESSAGE("An1_E_variable_range (Trace)");
  mcDEBUG_COMP("An1_E_variable_range")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAn1_E_variable_range
  STORE_NEUTRON(129,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[129]++;
  mcPCounter[129] += p;
  mcP2Counter[129] += p*p;
#define mccompcurname  An1_E_variable_range
#define mccompcurtype  E_monitor
#define mccompcurindex 129
#define nE mccAn1_E_variable_range_nE
#define E_N mccAn1_E_variable_range_E_N
#define E_p mccAn1_E_variable_range_E_p
#define E_p2 mccAn1_E_variable_range_E_p2
#define S_p mccAn1_E_variable_range_S_p
#define S_pE mccAn1_E_variable_range_S_pE
#define S_pE2 mccAn1_E_variable_range_S_pE2
{   /* Declarations of An1_E_variable_range=E_monitor() SETTING parameters. */
char* filename = mccAn1_E_variable_range_filename;
MCNUM xmin = mccAn1_E_variable_range_xmin;
MCNUM xmax = mccAn1_E_variable_range_xmax;
MCNUM ymin = mccAn1_E_variable_range_ymin;
MCNUM ymax = mccAn1_E_variable_range_ymax;
MCNUM xwidth = mccAn1_E_variable_range_xwidth;
MCNUM yheight = mccAn1_E_variable_range_yheight;
MCNUM Emin = mccAn1_E_variable_range_Emin;
MCNUM Emax = mccAn1_E_variable_range_Emax;
MCNUM restore_neutron = mccAn1_E_variable_range_restore_neutron;
int nowritefile = mccAn1_E_variable_range_nowritefile;
#line 89 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
{
    int i;
    double E;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      E = VS2E*(vx*vx + vy*vy + vz*vz);

      S_p += p;
      S_pE += p*E;
      S_pE2 += p*E*E;

      i = floor((E-Emin)*nE/(Emax-Emin));
      if(i >= 0 && i < nE)
      {
        E_N[i]++;
        E_p[i] += p;
        E_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 71269 "./SNS_BASIS.c"
}   /* End of An1_E_variable_range=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAn1_E_variable_range:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(129,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component An1_rot_axis2 [130] */
  mccoordschange(mcposrAn1_rot_axis2, mcrotrAn1_rot_axis2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component An1_rot_axis2 (without coords transformations) */
  mcJumpTrace_An1_rot_axis2:
  SIG_MESSAGE("An1_rot_axis2 (Trace)");
  mcDEBUG_COMP("An1_rot_axis2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAn1_rot_axis2
  STORE_NEUTRON(130,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[130]++;
  mcPCounter[130] += p;
  mcP2Counter[130] += p*p;
#define mccompcurname  An1_rot_axis2
#define mccompcurtype  Arm
#define mccompcurindex 130
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAn1_rot_axis2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(130,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component An2_rot_axis2 [131] */
  mccoordschange(mcposrAn2_rot_axis2, mcrotrAn2_rot_axis2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component An2_rot_axis2 (without coords transformations) */
  mcJumpTrace_An2_rot_axis2:
  SIG_MESSAGE("An2_rot_axis2 (Trace)");
  mcDEBUG_COMP("An2_rot_axis2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAn2_rot_axis2
  STORE_NEUTRON(131,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[131]++;
  mcPCounter[131] += p;
  mcP2Counter[131] += p*p;
#define mccompcurname  An2_rot_axis2
#define mccompcurtype  Arm
#define mccompcurindex 131
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAn2_rot_axis2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(131,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component An3_rot_axis2 [132] */
  mccoordschange(mcposrAn3_rot_axis2, mcrotrAn3_rot_axis2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component An3_rot_axis2 (without coords transformations) */
  mcJumpTrace_An3_rot_axis2:
  SIG_MESSAGE("An3_rot_axis2 (Trace)");
  mcDEBUG_COMP("An3_rot_axis2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAn3_rot_axis2
  STORE_NEUTRON(132,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[132]++;
  mcPCounter[132] += p;
  mcP2Counter[132] += p*p;
#define mccompcurname  An3_rot_axis2
#define mccompcurtype  Arm
#define mccompcurindex 132
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAn3_rot_axis2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(132,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component An1 [133] */
  mccoordschange(mcposrAn1, mcrotrAn1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component An1 (without coords transformations) */
  mcJumpTrace_An1:
  SIG_MESSAGE("An1 (Trace)");
  mcDEBUG_COMP("An1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAn1
  STORE_NEUTRON(133,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[133]++;
  mcPCounter[133] += p;
  mcP2Counter[133] += p*p;
  if (!mcGroupANALYZERS) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
RESTORE=1;
#define mcabsorb mcabsorbCompAn1
#define mccompcurname  An1
#define mccompcurtype  Spherical_Backscattering_Analyser
#define mccompcurindex 133
#define d_rms mccAn1_d_rms
#define mos_rms mccAn1_mos_rms
#define mono_Q mccAn1_mono_Q
{   /* Declarations of An1=Spherical_Backscattering_Analyser() SETTING parameters. */
MCNUM xmin = mccAn1_xmin;
MCNUM xmax = mccAn1_xmax;
MCNUM ymin = mccAn1_ymin;
MCNUM ymax = mccAn1_ymax;
MCNUM mosaic = mccAn1_mosaic;
MCNUM dspread = mccAn1_dspread;
MCNUM Q = mccAn1_Q;
MCNUM DM = mccAn1_DM;
MCNUM radius = mccAn1_radius;
MCNUM f_doppler = mccAn1_f_doppler;
MCNUM A_doppler = mccAn1_A_doppler;
MCNUM R0 = mccAn1_R0;
MCNUM debug = mccAn1_debug;
#line 70 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Spherical_Backscattering_Analyser.comp"
{
  double vel;
    double sinTheta, lambdaBragg, lambda, dLambda2, sigmaLambda2;

  double old_x, old_y, old_z, old_t, x0, y0, z0, xi, yi, zi;
  double a, b, c, dt1, dt2, dt;
  double nx, ny, nz, nmod, v;
  double kproj, ydarwin, dkz, p_reflect; 
  double q0mod, q0x, q0y, q0z, kix, kiy, kiz, kfx, kfy, kfz;
        
  double omega_doppler;
  double v_doppler_inst;
    
  omega_doppler=2*PI*f_doppler;
   old_x=x; old_y=y; old_z=z; old_t=t;
    
  // Time interval necessary for the neutron to reach the sphere: solve equation: neutron path (line) crosses monochromator (sphere). Center of sphere is at (0,0,-radius).

//point on neutron path satisfies: xpath= x+vx*t, ypath=y+vy*t, zpath=z+vz*t;
//point on monochromator sphere satisfies: radius^2=x^2+y^2+(z+r)^2
//settings these equal gives an equation for t:
  a = vx*vx + vy*vy + vz*vz;
  b = 2.0 * ( vx*x + vy*y + vz*(z+radius) );  
  c = x*x+y*y+z*z + 2*z*radius;
  if ((b*b-4*a*c) < 0)
     {
      printf("Imaginary solutions. Something has gone wrong. Unphysical.\n");
      ABSORB;
     } 
  dt1 = (-b + sqrt(b*b-4*a*c)) / (2.0*a);
  dt2 = (-b - sqrt(b*b-4*a*c)) / (2.0*a);
  if (dt1 > 0)
     dt = dt1;
  else
     dt = dt2;   
  // propagates the neutron the time dt, so it arrives to the sphere

  PROP_DT(dt);
  
// ABSORB if neutron hits outside sphere
  if (x<xmin || x>xmax || y<ymin || y>ymax)
    ABSORB;

//n is a vector pointing along the radius of the sphere
  nx =x;
  ny= y;
  nz=(z+radius);
//modulus of the vector  n
nmod = sqrt(nx*nx+ny*ny+nz*nz);

// change to moving coordinates (doppler motion parallel to Z) 
  v_doppler_inst=A_doppler*omega_doppler*cos(omega_doppler*t);
  kix = vx*V2K; kiy = vy*V2K ; kiz = vz*V2K + v_doppler_inst*V2K;

// projection of the incident vector on the normal 
   kproj = (kix*nx + kiy*ny + kiz*nz) / nmod;
  
  vel=sqrt(a);  
  
  sinTheta = fabs(K2V*kproj)/vel;  
    
    // calculate lambdaBragg
    lambdaBragg = 2.0*DM*sinTheta;
    
    // calculate lambda of neutron
    lambda = 2*PI/kproj;
        
    // calculate deltaLambda squared and sigmaLambda squared
    dLambda2 = (lambda-lambdaBragg)*(lambda-lambdaBragg);
    // The sigmaLambda is propagated by differentiating the bragg 
    // condition: Lambda = 2*d*sinTheta
  
    sigmaLambda2 = 2.0*2.0 * sinTheta*sinTheta * d_rms*d_rms+2.0*2.0 * DM*DM * (1.0-sinTheta*sinTheta) * mos_rms*mos_rms;
      
    p_reflect = R0*exp(-dLambda2/(2.0*sigmaLambda2));

      if (p_reflect < 1e-5)
        {
          ABSORB;
        }
        else
        {
    // reflection: kf = ki - Q0 (the projection): q points along the normal and to scatter elastically, the component of ki along the normal must change sign, i.e. q0mod=2kproj
    q0mod = 2.0 * kproj;
    q0x = (nx/nmod)*q0mod; q0y = (ny/nmod)*q0mod;  q0z = (nz/nmod)*q0mod;
    kfx = kix - q0x;
    kfy = kiy - q0y;
    kfz = kiz - q0z;
    
      /* change to static coordinates */
      kfz = kfz - v_doppler_inst*V2K;
    
      vx = K2V*kfx;       
    vy = K2V*kfy;
      vz = K2V*kfz;

    p *= p_reflect; 
    SCATTER;
  }
  
    if(debug > 0) {
      printf("\n Lambda: %f, Lambda_Bragg: %f\n", lambda, lambdaBragg);
      printf("sigmaLambda: %f, R0: %f, p_reflect: %f\n", 
       sqrt(sigmaLambda2), R0, p_reflect);}
}
#line 71818 "./SNS_BASIS.c"
}   /* End of An1=Spherical_Backscattering_Analyser() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms
#undef d_rms
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp An1 in GROUP ANALYZERS */
  if (SCATTERED) {
    mcGroupANALYZERS=133;
    RESTORE=0;
  }
  /* Label for restoring  neutron */
  mcabsorbCompAn1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(133,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component An2 [134] */
  mccoordschange(mcposrAn2, mcrotrAn2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component An2 (without coords transformations) */
  mcJumpTrace_An2:
  SIG_MESSAGE("An2 (Trace)");
  mcDEBUG_COMP("An2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAn2
  STORE_NEUTRON(134,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[134]++;
  mcPCounter[134] += p;
  mcP2Counter[134] += p*p;
  if (!mcGroupANALYZERS) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
RESTORE=1;
#define mcabsorb mcabsorbCompAn2
#define mccompcurname  An2
#define mccompcurtype  Spherical_Backscattering_Analyser
#define mccompcurindex 134
#define d_rms mccAn2_d_rms
#define mos_rms mccAn2_mos_rms
#define mono_Q mccAn2_mono_Q
{   /* Declarations of An2=Spherical_Backscattering_Analyser() SETTING parameters. */
MCNUM xmin = mccAn2_xmin;
MCNUM xmax = mccAn2_xmax;
MCNUM ymin = mccAn2_ymin;
MCNUM ymax = mccAn2_ymax;
MCNUM mosaic = mccAn2_mosaic;
MCNUM dspread = mccAn2_dspread;
MCNUM Q = mccAn2_Q;
MCNUM DM = mccAn2_DM;
MCNUM radius = mccAn2_radius;
MCNUM f_doppler = mccAn2_f_doppler;
MCNUM A_doppler = mccAn2_A_doppler;
MCNUM R0 = mccAn2_R0;
MCNUM debug = mccAn2_debug;
#line 70 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Spherical_Backscattering_Analyser.comp"
{
  double vel;
    double sinTheta, lambdaBragg, lambda, dLambda2, sigmaLambda2;

  double old_x, old_y, old_z, old_t, x0, y0, z0, xi, yi, zi;
  double a, b, c, dt1, dt2, dt;
  double nx, ny, nz, nmod, v;
  double kproj, ydarwin, dkz, p_reflect; 
  double q0mod, q0x, q0y, q0z, kix, kiy, kiz, kfx, kfy, kfz;
        
  double omega_doppler;
  double v_doppler_inst;
    
  omega_doppler=2*PI*f_doppler;
   old_x=x; old_y=y; old_z=z; old_t=t;
    
  // Time interval necessary for the neutron to reach the sphere: solve equation: neutron path (line) crosses monochromator (sphere). Center of sphere is at (0,0,-radius).

//point on neutron path satisfies: xpath= x+vx*t, ypath=y+vy*t, zpath=z+vz*t;
//point on monochromator sphere satisfies: radius^2=x^2+y^2+(z+r)^2
//settings these equal gives an equation for t:
  a = vx*vx + vy*vy + vz*vz;
  b = 2.0 * ( vx*x + vy*y + vz*(z+radius) );  
  c = x*x+y*y+z*z + 2*z*radius;
  if ((b*b-4*a*c) < 0)
     {
      printf("Imaginary solutions. Something has gone wrong. Unphysical.\n");
      ABSORB;
     } 
  dt1 = (-b + sqrt(b*b-4*a*c)) / (2.0*a);
  dt2 = (-b - sqrt(b*b-4*a*c)) / (2.0*a);
  if (dt1 > 0)
     dt = dt1;
  else
     dt = dt2;   
  // propagates the neutron the time dt, so it arrives to the sphere

  PROP_DT(dt);
  
// ABSORB if neutron hits outside sphere
  if (x<xmin || x>xmax || y<ymin || y>ymax)
    ABSORB;

//n is a vector pointing along the radius of the sphere
  nx =x;
  ny= y;
  nz=(z+radius);
//modulus of the vector  n
nmod = sqrt(nx*nx+ny*ny+nz*nz);

// change to moving coordinates (doppler motion parallel to Z) 
  v_doppler_inst=A_doppler*omega_doppler*cos(omega_doppler*t);
  kix = vx*V2K; kiy = vy*V2K ; kiz = vz*V2K + v_doppler_inst*V2K;

// projection of the incident vector on the normal 
   kproj = (kix*nx + kiy*ny + kiz*nz) / nmod;
  
  vel=sqrt(a);  
  
  sinTheta = fabs(K2V*kproj)/vel;  
    
    // calculate lambdaBragg
    lambdaBragg = 2.0*DM*sinTheta;
    
    // calculate lambda of neutron
    lambda = 2*PI/kproj;
        
    // calculate deltaLambda squared and sigmaLambda squared
    dLambda2 = (lambda-lambdaBragg)*(lambda-lambdaBragg);
    // The sigmaLambda is propagated by differentiating the bragg 
    // condition: Lambda = 2*d*sinTheta
  
    sigmaLambda2 = 2.0*2.0 * sinTheta*sinTheta * d_rms*d_rms+2.0*2.0 * DM*DM * (1.0-sinTheta*sinTheta) * mos_rms*mos_rms;
      
    p_reflect = R0*exp(-dLambda2/(2.0*sigmaLambda2));

      if (p_reflect < 1e-5)
        {
          ABSORB;
        }
        else
        {
    // reflection: kf = ki - Q0 (the projection): q points along the normal and to scatter elastically, the component of ki along the normal must change sign, i.e. q0mod=2kproj
    q0mod = 2.0 * kproj;
    q0x = (nx/nmod)*q0mod; q0y = (ny/nmod)*q0mod;  q0z = (nz/nmod)*q0mod;
    kfx = kix - q0x;
    kfy = kiy - q0y;
    kfz = kiz - q0z;
    
      /* change to static coordinates */
      kfz = kfz - v_doppler_inst*V2K;
    
      vx = K2V*kfx;       
    vy = K2V*kfy;
      vz = K2V*kfz;

    p *= p_reflect; 
    SCATTER;
  }
  
    if(debug > 0) {
      printf("\n Lambda: %f, Lambda_Bragg: %f\n", lambda, lambdaBragg);
      printf("sigmaLambda: %f, R0: %f, p_reflect: %f\n", 
       sqrt(sigmaLambda2), R0, p_reflect);}
}
#line 72058 "./SNS_BASIS.c"
}   /* End of An2=Spherical_Backscattering_Analyser() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms
#undef d_rms
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp An2 in GROUP ANALYZERS */
  if (SCATTERED) {
    mcGroupANALYZERS=134;
    RESTORE=0;
  }
  /* Label for restoring  neutron */
  mcabsorbCompAn2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(134,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component An3 [135] */
  mccoordschange(mcposrAn3, mcrotrAn3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component An3 (without coords transformations) */
  mcJumpTrace_An3:
  SIG_MESSAGE("An3 (Trace)");
  mcDEBUG_COMP("An3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAn3
  STORE_NEUTRON(135,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[135]++;
  mcPCounter[135] += p;
  mcP2Counter[135] += p*p;
  if (!mcGroupANALYZERS) { /* previous comps of GROUP have not SCATTERED yet */
#undef mcabsorb
/* if ABSORBed in GROUP/comp, will go to end of component */
RESTORE=1;
#define mcabsorb mcabsorbCompAn3
#define mccompcurname  An3
#define mccompcurtype  Spherical_Backscattering_Analyser
#define mccompcurindex 135
#define d_rms mccAn3_d_rms
#define mos_rms mccAn3_mos_rms
#define mono_Q mccAn3_mono_Q
{   /* Declarations of An3=Spherical_Backscattering_Analyser() SETTING parameters. */
MCNUM xmin = mccAn3_xmin;
MCNUM xmax = mccAn3_xmax;
MCNUM ymin = mccAn3_ymin;
MCNUM ymax = mccAn3_ymax;
MCNUM mosaic = mccAn3_mosaic;
MCNUM dspread = mccAn3_dspread;
MCNUM Q = mccAn3_Q;
MCNUM DM = mccAn3_DM;
MCNUM radius = mccAn3_radius;
MCNUM f_doppler = mccAn3_f_doppler;
MCNUM A_doppler = mccAn3_A_doppler;
MCNUM R0 = mccAn3_R0;
MCNUM debug = mccAn3_debug;
#line 70 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Spherical_Backscattering_Analyser.comp"
{
  double vel;
    double sinTheta, lambdaBragg, lambda, dLambda2, sigmaLambda2;

  double old_x, old_y, old_z, old_t, x0, y0, z0, xi, yi, zi;
  double a, b, c, dt1, dt2, dt;
  double nx, ny, nz, nmod, v;
  double kproj, ydarwin, dkz, p_reflect; 
  double q0mod, q0x, q0y, q0z, kix, kiy, kiz, kfx, kfy, kfz;
        
  double omega_doppler;
  double v_doppler_inst;
    
  omega_doppler=2*PI*f_doppler;
   old_x=x; old_y=y; old_z=z; old_t=t;
    
  // Time interval necessary for the neutron to reach the sphere: solve equation: neutron path (line) crosses monochromator (sphere). Center of sphere is at (0,0,-radius).

//point on neutron path satisfies: xpath= x+vx*t, ypath=y+vy*t, zpath=z+vz*t;
//point on monochromator sphere satisfies: radius^2=x^2+y^2+(z+r)^2
//settings these equal gives an equation for t:
  a = vx*vx + vy*vy + vz*vz;
  b = 2.0 * ( vx*x + vy*y + vz*(z+radius) );  
  c = x*x+y*y+z*z + 2*z*radius;
  if ((b*b-4*a*c) < 0)
     {
      printf("Imaginary solutions. Something has gone wrong. Unphysical.\n");
      ABSORB;
     } 
  dt1 = (-b + sqrt(b*b-4*a*c)) / (2.0*a);
  dt2 = (-b - sqrt(b*b-4*a*c)) / (2.0*a);
  if (dt1 > 0)
     dt = dt1;
  else
     dt = dt2;   
  // propagates the neutron the time dt, so it arrives to the sphere

  PROP_DT(dt);
  
// ABSORB if neutron hits outside sphere
  if (x<xmin || x>xmax || y<ymin || y>ymax)
    ABSORB;

//n is a vector pointing along the radius of the sphere
  nx =x;
  ny= y;
  nz=(z+radius);
//modulus of the vector  n
nmod = sqrt(nx*nx+ny*ny+nz*nz);

// change to moving coordinates (doppler motion parallel to Z) 
  v_doppler_inst=A_doppler*omega_doppler*cos(omega_doppler*t);
  kix = vx*V2K; kiy = vy*V2K ; kiz = vz*V2K + v_doppler_inst*V2K;

// projection of the incident vector on the normal 
   kproj = (kix*nx + kiy*ny + kiz*nz) / nmod;
  
  vel=sqrt(a);  
  
  sinTheta = fabs(K2V*kproj)/vel;  
    
    // calculate lambdaBragg
    lambdaBragg = 2.0*DM*sinTheta;
    
    // calculate lambda of neutron
    lambda = 2*PI/kproj;
        
    // calculate deltaLambda squared and sigmaLambda squared
    dLambda2 = (lambda-lambdaBragg)*(lambda-lambdaBragg);
    // The sigmaLambda is propagated by differentiating the bragg 
    // condition: Lambda = 2*d*sinTheta
  
    sigmaLambda2 = 2.0*2.0 * sinTheta*sinTheta * d_rms*d_rms+2.0*2.0 * DM*DM * (1.0-sinTheta*sinTheta) * mos_rms*mos_rms;
      
    p_reflect = R0*exp(-dLambda2/(2.0*sigmaLambda2));

      if (p_reflect < 1e-5)
        {
          ABSORB;
        }
        else
        {
    // reflection: kf = ki - Q0 (the projection): q points along the normal and to scatter elastically, the component of ki along the normal must change sign, i.e. q0mod=2kproj
    q0mod = 2.0 * kproj;
    q0x = (nx/nmod)*q0mod; q0y = (ny/nmod)*q0mod;  q0z = (nz/nmod)*q0mod;
    kfx = kix - q0x;
    kfy = kiy - q0y;
    kfz = kiz - q0z;
    
      /* change to static coordinates */
      kfz = kfz - v_doppler_inst*V2K;
    
      vx = K2V*kfx;       
    vy = K2V*kfy;
      vz = K2V*kfz;

    p *= p_reflect; 
    SCATTER;
  }
  
    if(debug > 0) {
      printf("\n Lambda: %f, Lambda_Bragg: %f\n", lambda, lambdaBragg);
      printf("sigmaLambda: %f, R0: %f, p_reflect: %f\n", 
       sqrt(sigmaLambda2), R0, p_reflect);}
}
#line 72298 "./SNS_BASIS.c"
}   /* End of An3=Spherical_Backscattering_Analyser() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms
#undef d_rms
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
#undef mcabsorb
#define mcabsorb mcabsorbAll
  } /* end comp An3 in GROUP ANALYZERS */
  if (SCATTERED) {
    mcGroupANALYZERS=135;
    RESTORE=0;
  }
  /* Label for restoring  neutron */
  mcabsorbCompAn3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(135,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
/* end of GROUP ANALYZERS */
  if (!mcGroupANALYZERS) ABSORB; /* absorb neutron non scattered in GROUP */
  mcGroupANALYZERS=0; /* reset group scattered flag */
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component ArmForDet1 [136] */
  mccoordschange(mcposrArmForDet1, mcrotrArmForDet1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component ArmForDet1 (without coords transformations) */
  mcJumpTrace_ArmForDet1:
  SIG_MESSAGE("ArmForDet1 (Trace)");
  mcDEBUG_COMP("ArmForDet1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompArmForDet1
  STORE_NEUTRON(136,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[136]++;
  mcPCounter[136] += p;
  mcP2Counter[136] += p*p;
#define mccompcurname  ArmForDet1
#define mccompcurtype  Arm
#define mccompcurindex 136
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompArmForDet1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(136,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Det1_E [137] */
  mccoordschange(mcposrDet1_E, mcrotrDet1_E,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Det1_E (without coords transformations) */
  mcJumpTrace_Det1_E:
  SIG_MESSAGE("Det1_E (Trace)");
  mcDEBUG_COMP("Det1_E")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDet1_E
  STORE_NEUTRON(137,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[137]++;
  mcPCounter[137] += p;
  mcP2Counter[137] += p*p;
#define mccompcurname  Det1_E
#define mccompcurtype  E_monitor
#define mccompcurindex 137
#define nE mccDet1_E_nE
#define E_N mccDet1_E_E_N
#define E_p mccDet1_E_E_p
#define E_p2 mccDet1_E_E_p2
#define S_p mccDet1_E_S_p
#define S_pE mccDet1_E_S_pE
#define S_pE2 mccDet1_E_S_pE2
{   /* Declarations of Det1_E=E_monitor() SETTING parameters. */
char* filename = mccDet1_E_filename;
MCNUM xmin = mccDet1_E_xmin;
MCNUM xmax = mccDet1_E_xmax;
MCNUM ymin = mccDet1_E_ymin;
MCNUM ymax = mccDet1_E_ymax;
MCNUM xwidth = mccDet1_E_xwidth;
MCNUM yheight = mccDet1_E_yheight;
MCNUM Emin = mccDet1_E_Emin;
MCNUM Emax = mccDet1_E_Emax;
MCNUM restore_neutron = mccDet1_E_restore_neutron;
int nowritefile = mccDet1_E_nowritefile;
#line 89 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
{
    int i;
    double E;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      E = VS2E*(vx*vx + vy*vy + vz*vz);

      S_p += p;
      S_pE += p*E;
      S_pE2 += p*E*E;

      i = floor((E-Emin)*nE/(Emax-Emin));
      if(i >= 0 && i < nE)
      {
        E_N[i]++;
        E_p[i] += p;
        E_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 72562 "./SNS_BASIS.c"
}   /* End of Det1_E=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDet1_E:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(137,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Det1_E_variable_range [138] */
  mccoordschange(mcposrDet1_E_variable_range, mcrotrDet1_E_variable_range,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Det1_E_variable_range (without coords transformations) */
  mcJumpTrace_Det1_E_variable_range:
  SIG_MESSAGE("Det1_E_variable_range (Trace)");
  mcDEBUG_COMP("Det1_E_variable_range")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDet1_E_variable_range
  STORE_NEUTRON(138,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[138]++;
  mcPCounter[138] += p;
  mcP2Counter[138] += p*p;
#define mccompcurname  Det1_E_variable_range
#define mccompcurtype  E_monitor
#define mccompcurindex 138
#define nE mccDet1_E_variable_range_nE
#define E_N mccDet1_E_variable_range_E_N
#define E_p mccDet1_E_variable_range_E_p
#define E_p2 mccDet1_E_variable_range_E_p2
#define S_p mccDet1_E_variable_range_S_p
#define S_pE mccDet1_E_variable_range_S_pE
#define S_pE2 mccDet1_E_variable_range_S_pE2
{   /* Declarations of Det1_E_variable_range=E_monitor() SETTING parameters. */
char* filename = mccDet1_E_variable_range_filename;
MCNUM xmin = mccDet1_E_variable_range_xmin;
MCNUM xmax = mccDet1_E_variable_range_xmax;
MCNUM ymin = mccDet1_E_variable_range_ymin;
MCNUM ymax = mccDet1_E_variable_range_ymax;
MCNUM xwidth = mccDet1_E_variable_range_xwidth;
MCNUM yheight = mccDet1_E_variable_range_yheight;
MCNUM Emin = mccDet1_E_variable_range_Emin;
MCNUM Emax = mccDet1_E_variable_range_Emax;
MCNUM restore_neutron = mccDet1_E_variable_range_restore_neutron;
int nowritefile = mccDet1_E_variable_range_nowritefile;
#line 89 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
{
    int i;
    double E;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      E = VS2E*(vx*vx + vy*vy + vz*vz);

      S_p += p;
      S_pE += p*E;
      S_pE2 += p*E*E;

      i = floor((E-Emin)*nE/(Emax-Emin));
      if(i >= 0 && i < nE)
      {
        E_N[i]++;
        E_p[i] += p;
        E_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 72720 "./SNS_BASIS.c"
}   /* End of Det1_E_variable_range=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDet1_E_variable_range:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(138,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Det1_Lam [139] */
  mccoordschange(mcposrDet1_Lam, mcrotrDet1_Lam,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Det1_Lam (without coords transformations) */
  mcJumpTrace_Det1_Lam:
  SIG_MESSAGE("Det1_Lam (Trace)");
  mcDEBUG_COMP("Det1_Lam")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDet1_Lam
  STORE_NEUTRON(139,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[139]++;
  mcPCounter[139] += p;
  mcP2Counter[139] += p*p;
#define mccompcurname  Det1_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 139
#define nL mccDet1_Lam_nL
#define L_N mccDet1_Lam_L_N
#define L_p mccDet1_Lam_L_p
#define L_p2 mccDet1_Lam_L_p2
{   /* Declarations of Det1_Lam=L_monitor() SETTING parameters. */
char* filename = mccDet1_Lam_filename;
MCNUM xmin = mccDet1_Lam_xmin;
MCNUM xmax = mccDet1_Lam_xmax;
MCNUM ymin = mccDet1_Lam_ymin;
MCNUM ymax = mccDet1_Lam_ymax;
MCNUM xwidth = mccDet1_Lam_xwidth;
MCNUM yheight = mccDet1_Lam_yheight;
MCNUM Lmin = mccDet1_Lam_Lmin;
MCNUM Lmax = mccDet1_Lam_Lmax;
MCNUM restore_neutron = mccDet1_Lam_restore_neutron;
int nowritefile = mccDet1_Lam_nowritefile;
#line 84 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 72870 "./SNS_BASIS.c"
}   /* End of Det1_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDet1_Lam:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(139,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Det1_Lam_variable_range [140] */
  mccoordschange(mcposrDet1_Lam_variable_range, mcrotrDet1_Lam_variable_range,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Det1_Lam_variable_range (without coords transformations) */
  mcJumpTrace_Det1_Lam_variable_range:
  SIG_MESSAGE("Det1_Lam_variable_range (Trace)");
  mcDEBUG_COMP("Det1_Lam_variable_range")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDet1_Lam_variable_range
  STORE_NEUTRON(140,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[140]++;
  mcPCounter[140] += p;
  mcP2Counter[140] += p*p;
#define mccompcurname  Det1_Lam_variable_range
#define mccompcurtype  L_monitor
#define mccompcurindex 140
#define nL mccDet1_Lam_variable_range_nL
#define L_N mccDet1_Lam_variable_range_L_N
#define L_p mccDet1_Lam_variable_range_L_p
#define L_p2 mccDet1_Lam_variable_range_L_p2
{   /* Declarations of Det1_Lam_variable_range=L_monitor() SETTING parameters. */
char* filename = mccDet1_Lam_variable_range_filename;
MCNUM xmin = mccDet1_Lam_variable_range_xmin;
MCNUM xmax = mccDet1_Lam_variable_range_xmax;
MCNUM ymin = mccDet1_Lam_variable_range_ymin;
MCNUM ymax = mccDet1_Lam_variable_range_ymax;
MCNUM xwidth = mccDet1_Lam_variable_range_xwidth;
MCNUM yheight = mccDet1_Lam_variable_range_yheight;
MCNUM Lmin = mccDet1_Lam_variable_range_Lmin;
MCNUM Lmax = mccDet1_Lam_variable_range_Lmax;
MCNUM restore_neutron = mccDet1_Lam_variable_range_restore_neutron;
int nowritefile = mccDet1_Lam_variable_range_nowritefile;
#line 84 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    int i;
    double L;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      L = (2*PI/V2K)/sqrt(vx*vx + vy*vy + vz*vz);
      i = floor((L-Lmin)*nL/(Lmax-Lmin));
      if(i >= 0 && i < nL)
      {
        L_N[i]++;
        L_p[i] += p;
        L_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 73017 "./SNS_BASIS.c"
}   /* End of Det1_Lam_variable_range=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDet1_Lam_variable_range:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(140,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Det1_ToF [141] */
  mccoordschange(mcposrDet1_ToF, mcrotrDet1_ToF,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Det1_ToF (without coords transformations) */
  mcJumpTrace_Det1_ToF:
  SIG_MESSAGE("Det1_ToF (Trace)");
  mcDEBUG_COMP("Det1_ToF")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDet1_ToF
  STORE_NEUTRON(141,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[141]++;
  mcPCounter[141] += p;
  mcP2Counter[141] += p*p;
#define mccompcurname  Det1_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 141
#define nt mccDet1_ToF_nt
#define TOF_N mccDet1_ToF_TOF_N
#define TOF_p mccDet1_ToF_TOF_p
#define TOF_p2 mccDet1_ToF_TOF_p2
#define t_min mccDet1_ToF_t_min
#define t_max mccDet1_ToF_t_max
#define delta_t mccDet1_ToF_delta_t
{   /* Declarations of Det1_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccDet1_ToF_filename;
MCNUM xmin = mccDet1_ToF_xmin;
MCNUM xmax = mccDet1_ToF_xmax;
MCNUM ymin = mccDet1_ToF_ymin;
MCNUM ymax = mccDet1_ToF_ymax;
MCNUM xwidth = mccDet1_ToF_xwidth;
MCNUM yheight = mccDet1_ToF_yheight;
MCNUM tmin = mccDet1_ToF_tmin;
MCNUM tmax = mccDet1_ToF_tmax;
MCNUM dt = mccDet1_ToF_dt;
MCNUM restore_neutron = mccDet1_ToF_restore_neutron;
int nowritefile = mccDet1_ToF_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 73165 "./SNS_BASIS.c"
}   /* End of Det1_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDet1_ToF:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(141,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Det1_ToF_variable_range [142] */
  mccoordschange(mcposrDet1_ToF_variable_range, mcrotrDet1_ToF_variable_range,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Det1_ToF_variable_range (without coords transformations) */
  mcJumpTrace_Det1_ToF_variable_range:
  SIG_MESSAGE("Det1_ToF_variable_range (Trace)");
  mcDEBUG_COMP("Det1_ToF_variable_range")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDet1_ToF_variable_range
  STORE_NEUTRON(142,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[142]++;
  mcPCounter[142] += p;
  mcP2Counter[142] += p*p;
#define mccompcurname  Det1_ToF_variable_range
#define mccompcurtype  TOF_monitor
#define mccompcurindex 142
#define nt mccDet1_ToF_variable_range_nt
#define TOF_N mccDet1_ToF_variable_range_TOF_N
#define TOF_p mccDet1_ToF_variable_range_TOF_p
#define TOF_p2 mccDet1_ToF_variable_range_TOF_p2
#define t_min mccDet1_ToF_variable_range_t_min
#define t_max mccDet1_ToF_variable_range_t_max
#define delta_t mccDet1_ToF_variable_range_delta_t
{   /* Declarations of Det1_ToF_variable_range=TOF_monitor() SETTING parameters. */
char* filename = mccDet1_ToF_variable_range_filename;
MCNUM xmin = mccDet1_ToF_variable_range_xmin;
MCNUM xmax = mccDet1_ToF_variable_range_xmax;
MCNUM ymin = mccDet1_ToF_variable_range_ymin;
MCNUM ymax = mccDet1_ToF_variable_range_ymax;
MCNUM xwidth = mccDet1_ToF_variable_range_xwidth;
MCNUM yheight = mccDet1_ToF_variable_range_yheight;
MCNUM tmin = mccDet1_ToF_variable_range_tmin;
MCNUM tmax = mccDet1_ToF_variable_range_tmax;
MCNUM dt = mccDet1_ToF_variable_range_dt;
MCNUM restore_neutron = mccDet1_ToF_variable_range_restore_neutron;
int nowritefile = mccDet1_ToF_variable_range_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 73316 "./SNS_BASIS.c"
}   /* End of Det1_ToF_variable_range=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDet1_ToF_variable_range:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(142,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Det1_ToF_variable_range_lessnL [143] */
  mccoordschange(mcposrDet1_ToF_variable_range_lessnL, mcrotrDet1_ToF_variable_range_lessnL,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Det1_ToF_variable_range_lessnL (without coords transformations) */
  mcJumpTrace_Det1_ToF_variable_range_lessnL:
  SIG_MESSAGE("Det1_ToF_variable_range_lessnL (Trace)");
  mcDEBUG_COMP("Det1_ToF_variable_range_lessnL")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDet1_ToF_variable_range_lessnL
  STORE_NEUTRON(143,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[143]++;
  mcPCounter[143] += p;
  mcP2Counter[143] += p*p;
#define mccompcurname  Det1_ToF_variable_range_lessnL
#define mccompcurtype  TOF_monitor
#define mccompcurindex 143
#define nt mccDet1_ToF_variable_range_lessnL_nt
#define TOF_N mccDet1_ToF_variable_range_lessnL_TOF_N
#define TOF_p mccDet1_ToF_variable_range_lessnL_TOF_p
#define TOF_p2 mccDet1_ToF_variable_range_lessnL_TOF_p2
#define t_min mccDet1_ToF_variable_range_lessnL_t_min
#define t_max mccDet1_ToF_variable_range_lessnL_t_max
#define delta_t mccDet1_ToF_variable_range_lessnL_delta_t
{   /* Declarations of Det1_ToF_variable_range_lessnL=TOF_monitor() SETTING parameters. */
char* filename = mccDet1_ToF_variable_range_lessnL_filename;
MCNUM xmin = mccDet1_ToF_variable_range_lessnL_xmin;
MCNUM xmax = mccDet1_ToF_variable_range_lessnL_xmax;
MCNUM ymin = mccDet1_ToF_variable_range_lessnL_ymin;
MCNUM ymax = mccDet1_ToF_variable_range_lessnL_ymax;
MCNUM xwidth = mccDet1_ToF_variable_range_lessnL_xwidth;
MCNUM yheight = mccDet1_ToF_variable_range_lessnL_yheight;
MCNUM tmin = mccDet1_ToF_variable_range_lessnL_tmin;
MCNUM tmax = mccDet1_ToF_variable_range_lessnL_tmax;
MCNUM dt = mccDet1_ToF_variable_range_lessnL_dt;
MCNUM restore_neutron = mccDet1_ToF_variable_range_lessnL_restore_neutron;
int nowritefile = mccDet1_ToF_variable_range_lessnL_nowritefile;
#line 95 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    int i;

    PROP_Z0;
    if (x>xmin && x<xmax && y>ymin && y<ymax)
    {
      i = floor((1E6*t-t_min)/delta_t);              /* Bin number */
      if(i >= 0 && i < nt) {
        TOF_N[i]++;
        TOF_p[i] += p;
        TOF_p2[i] += p*p;
        SCATTER;
      }
    }
    if (restore_neutron) {
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
    }
}
#line 73467 "./SNS_BASIS.c"
}   /* End of Det1_ToF_variable_range_lessnL=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDet1_ToF_variable_range_lessnL:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(143,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component PSDcyl [144] */
  mccoordschange(mcposrPSDcyl, mcrotrPSDcyl,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component PSDcyl (without coords transformations) */
  mcJumpTrace_PSDcyl:
  SIG_MESSAGE("PSDcyl (Trace)");
  mcDEBUG_COMP("PSDcyl")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPSDcyl
  STORE_NEUTRON(144,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[144]++;
  mcPCounter[144] += p;
  mcP2Counter[144] += p*p;
#define mccompcurname  PSDcyl
#define mccompcurtype  Monitor_nD
#define mccompcurindex 144
#define user1 mccPSDcyl_user1
#define user2 mccPSDcyl_user2
#define user3 mccPSDcyl_user3
#define DEFS mccPSDcyl_DEFS
#define Vars mccPSDcyl_Vars
#define detector mccPSDcyl_detector
#define offdata mccPSDcyl_offdata
{   /* Declarations of PSDcyl=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccPSDcyl_xwidth;
MCNUM yheight = mccPSDcyl_yheight;
MCNUM zdepth = mccPSDcyl_zdepth;
MCNUM xmin = mccPSDcyl_xmin;
MCNUM xmax = mccPSDcyl_xmax;
MCNUM ymin = mccPSDcyl_ymin;
MCNUM ymax = mccPSDcyl_ymax;
MCNUM zmin = mccPSDcyl_zmin;
MCNUM zmax = mccPSDcyl_zmax;
MCNUM bins = mccPSDcyl_bins;
MCNUM min = mccPSDcyl_min;
MCNUM max = mccPSDcyl_max;
MCNUM restore_neutron = mccPSDcyl_restore_neutron;
MCNUM radius = mccPSDcyl_radius;
char* options = mccPSDcyl_options;
char* filename = mccPSDcyl_filename;
char* geometry = mccPSDcyl_geometry;
char* username1 = mccPSDcyl_username1;
char* username2 = mccPSDcyl_username2;
char* username3 = mccPSDcyl_username3;
int nowritefile = mccPSDcyl_nowritefile;
#line 311 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  double  XY=0;
  double  t0 = 0;
  double  t1 = 0;
  double  pp;
  int     intersect   = 0;
  char    Flag_Restore = 0;

  if (user1 != FLT_MAX) Vars.UserVariable1 = user1;
  if (user2 != FLT_MAX) Vars.UserVariable2 = user2;
  if (user3 != FLT_MAX) Vars.UserVariable3 = user3;

  /* this is done automatically
    STORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  */

  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    /* determine intersections with object */
    intersect = off_intersect_all(&t0, &t1, NULL, NULL,
       x,y,z, vx, vy, vz, &offdata );
    if (Vars.Flag_mantid) {
      if(intersect) {
        Vars.OFF_polyidx=(offdata.intersects[offdata.nextintersect]).index;
      } else {
        Vars.OFF_polyidx=-1;
      }
    }
  }
  else if ( (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
            || (abs(Vars.Flag_Shape) == DEFS.SHAPE_DISK) ) /* square xy or disk xy */
  {
    // propagate to xy plane and find intersection
    // make sure the event is recoverable afterwards
    t0 = t;
    ALLOW_BACKPROP;
    PROP_Z0;
    if ( (t>=t0) && (z==0.0) ) // forward propagation to xy plane was successful
    {
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
      {
        // square xy
        intersect = (x>=Vars.mxmin && x<=Vars.mxmax && y>=Vars.mymin && y<=Vars.mymax);
      }
      else
      {
        // disk xy
        intersect = (SQR(x) + SQR(y)) <= SQR(Vars.Sphere_Radius);
      }
    }
    else
    {
      intersect=0;
    }
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) /* sphere */
  {
    intersect = sphere_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius);
  /*      intersect = (intersect && t0 > 0); */
  }
  else if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)) /* cylinder */
  {
    intersect = cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius, Vars.Cylinder_Height);
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) /* box */
  {
    intersect = box_intersect(&t0, &t1, x, y, z, vx, vy, vz,
                              fabs(Vars.mxmax-Vars.mxmin), fabs(Vars.mymax-Vars.mymin), fabs(Vars.mzmax-Vars.mzmin));
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_PREVIOUS) /* previous comp */
  { intersect = 1; }

  if (intersect)
  {
    if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND)
     || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)
     || (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) )
    {
      /* check if we have to remove the top/bottom with BANANA shape */
      if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA) && (intersect != 1)) {
        double y0,y1;
        /* propagate to intersection point as temporary variable to check top/bottom */
        y0 = y+t0*vy;
        y1 = y+t1*vy;
        if (fabs(y0) >= Vars.Cylinder_Height/2*0.99) t0 = t1;
        if (fabs(y1) >= Vars.Cylinder_Height/2*0.99) t1 = t0;
      }
      if (t0 < 0 && t1 > 0)
        t0 = t;  /* neutron was already inside ! */
      if (t1 < 0 && t0 > 0) /* neutron exit before entering !! */
        t1 = t;
      /* t0 is now time of incoming intersection with the detection area */
      if ((Vars.Flag_Shape < 0) && (t1 > 0))
        PROP_DT(t1); /* t1 outgoing beam */
      else
        PROP_DT(t0); /* t0 incoming beam */
      /* Final test if we are on lid / bottom of banana/sphere */
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA || abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) {
        if (fabs(y) >= Vars.Cylinder_Height/2*0.99) {
          intersect=0;
          Flag_Restore=1;
        }
      }
    }
  }

  if (intersect)
  {
    /* Now get the data to monitor: current or keep from PreMonitor */
    if (Vars.Flag_UsePreMonitor != 1)
    {
      Vars.cp  = p;
      Vars.cx  = x;
      Vars.cvx = vx;
      Vars.csx = sx;
      Vars.cy  = y;
      Vars.cvy = vy;
      Vars.csy = sy;
      Vars.cz  = z;
      Vars.cvz = vz;
      Vars.csz = sz;
      Vars.ct  = t;
    }

    if ((Vars.He3_pressure > 0) && (t1 != t0) && ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX)))
    {
      XY = exp(-7.417*Vars.He3_pressure*fabs(t1-t0)*2*PI*K2V);
      /* will monitor the absorbed part */
      Vars.cp *= 1-XY;
      /* and modify the neutron weight after monitor, only remains 1-p_detect */
      p *= XY;
    }

    if (Vars.Flag_capture)
    {
      XY = sqrt(Vars.cvx*Vars.cvx+Vars.cvy*Vars.cvy+Vars.cvz*Vars.cvz);
      XY *= V2K;
      if (XY != 0) XY = 2*PI/XY; /* lambda. lambda(2200 m/2) = 1.7985 Angs  */
      Vars.cp *= XY/1.7985;
    }

    pp = Monitor_nD_Trace(&DEFS, &Vars);
    if (pp==0.0)
    { ABSORB;
    }
    else if(pp==1)
    {
      SCATTER;
    }

    if (Vars.Flag_parallel) /* back to neutron state before detection */
      Flag_Restore = 1;
  } /* end if intersection */
  else {
    if (Vars.Flag_Absorb && !Vars.Flag_parallel)
    {
      // restore neutron ray before absorbing for correct mcdisplay
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
      ABSORB;
    }
    else Flag_Restore = 1;  /* no intersection, back to previous state */
  }

  if (Flag_Restore)
  {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 73777 "./SNS_BASIS.c"
}   /* End of PSDcyl=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPSDcyl:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(144,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component TOFcyl [145] */
  mccoordschange(mcposrTOFcyl, mcrotrTOFcyl,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component TOFcyl (without coords transformations) */
  mcJumpTrace_TOFcyl:
  SIG_MESSAGE("TOFcyl (Trace)");
  mcDEBUG_COMP("TOFcyl")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompTOFcyl
  STORE_NEUTRON(145,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[145]++;
  mcPCounter[145] += p;
  mcP2Counter[145] += p*p;
#define mccompcurname  TOFcyl
#define mccompcurtype  Monitor_nD
#define mccompcurindex 145
#define user1 mccTOFcyl_user1
#define user2 mccTOFcyl_user2
#define user3 mccTOFcyl_user3
#define DEFS mccTOFcyl_DEFS
#define Vars mccTOFcyl_Vars
#define detector mccTOFcyl_detector
#define offdata mccTOFcyl_offdata
{   /* Declarations of TOFcyl=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccTOFcyl_xwidth;
MCNUM yheight = mccTOFcyl_yheight;
MCNUM zdepth = mccTOFcyl_zdepth;
MCNUM xmin = mccTOFcyl_xmin;
MCNUM xmax = mccTOFcyl_xmax;
MCNUM ymin = mccTOFcyl_ymin;
MCNUM ymax = mccTOFcyl_ymax;
MCNUM zmin = mccTOFcyl_zmin;
MCNUM zmax = mccTOFcyl_zmax;
MCNUM bins = mccTOFcyl_bins;
MCNUM min = mccTOFcyl_min;
MCNUM max = mccTOFcyl_max;
MCNUM restore_neutron = mccTOFcyl_restore_neutron;
MCNUM radius = mccTOFcyl_radius;
char* options = mccTOFcyl_options;
char* filename = mccTOFcyl_filename;
char* geometry = mccTOFcyl_geometry;
char* username1 = mccTOFcyl_username1;
char* username2 = mccTOFcyl_username2;
char* username3 = mccTOFcyl_username3;
int nowritefile = mccTOFcyl_nowritefile;
#line 311 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  double  XY=0;
  double  t0 = 0;
  double  t1 = 0;
  double  pp;
  int     intersect   = 0;
  char    Flag_Restore = 0;

  if (user1 != FLT_MAX) Vars.UserVariable1 = user1;
  if (user2 != FLT_MAX) Vars.UserVariable2 = user2;
  if (user3 != FLT_MAX) Vars.UserVariable3 = user3;

  /* this is done automatically
    STORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  */

  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    /* determine intersections with object */
    intersect = off_intersect_all(&t0, &t1, NULL, NULL,
       x,y,z, vx, vy, vz, &offdata );
    if (Vars.Flag_mantid) {
      if(intersect) {
        Vars.OFF_polyidx=(offdata.intersects[offdata.nextintersect]).index;
      } else {
        Vars.OFF_polyidx=-1;
      }
    }
  }
  else if ( (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
            || (abs(Vars.Flag_Shape) == DEFS.SHAPE_DISK) ) /* square xy or disk xy */
  {
    // propagate to xy plane and find intersection
    // make sure the event is recoverable afterwards
    t0 = t;
    ALLOW_BACKPROP;
    PROP_Z0;
    if ( (t>=t0) && (z==0.0) ) // forward propagation to xy plane was successful
    {
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
      {
        // square xy
        intersect = (x>=Vars.mxmin && x<=Vars.mxmax && y>=Vars.mymin && y<=Vars.mymax);
      }
      else
      {
        // disk xy
        intersect = (SQR(x) + SQR(y)) <= SQR(Vars.Sphere_Radius);
      }
    }
    else
    {
      intersect=0;
    }
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) /* sphere */
  {
    intersect = sphere_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius);
  /*      intersect = (intersect && t0 > 0); */
  }
  else if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)) /* cylinder */
  {
    intersect = cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius, Vars.Cylinder_Height);
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) /* box */
  {
    intersect = box_intersect(&t0, &t1, x, y, z, vx, vy, vz,
                              fabs(Vars.mxmax-Vars.mxmin), fabs(Vars.mymax-Vars.mymin), fabs(Vars.mzmax-Vars.mzmin));
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_PREVIOUS) /* previous comp */
  { intersect = 1; }

  if (intersect)
  {
    if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND)
     || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)
     || (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) )
    {
      /* check if we have to remove the top/bottom with BANANA shape */
      if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA) && (intersect != 1)) {
        double y0,y1;
        /* propagate to intersection point as temporary variable to check top/bottom */
        y0 = y+t0*vy;
        y1 = y+t1*vy;
        if (fabs(y0) >= Vars.Cylinder_Height/2*0.99) t0 = t1;
        if (fabs(y1) >= Vars.Cylinder_Height/2*0.99) t1 = t0;
      }
      if (t0 < 0 && t1 > 0)
        t0 = t;  /* neutron was already inside ! */
      if (t1 < 0 && t0 > 0) /* neutron exit before entering !! */
        t1 = t;
      /* t0 is now time of incoming intersection with the detection area */
      if ((Vars.Flag_Shape < 0) && (t1 > 0))
        PROP_DT(t1); /* t1 outgoing beam */
      else
        PROP_DT(t0); /* t0 incoming beam */
      /* Final test if we are on lid / bottom of banana/sphere */
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA || abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) {
        if (fabs(y) >= Vars.Cylinder_Height/2*0.99) {
          intersect=0;
          Flag_Restore=1;
        }
      }
    }
  }

  if (intersect)
  {
    /* Now get the data to monitor: current or keep from PreMonitor */
    if (Vars.Flag_UsePreMonitor != 1)
    {
      Vars.cp  = p;
      Vars.cx  = x;
      Vars.cvx = vx;
      Vars.csx = sx;
      Vars.cy  = y;
      Vars.cvy = vy;
      Vars.csy = sy;
      Vars.cz  = z;
      Vars.cvz = vz;
      Vars.csz = sz;
      Vars.ct  = t;
    }

    if ((Vars.He3_pressure > 0) && (t1 != t0) && ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX)))
    {
      XY = exp(-7.417*Vars.He3_pressure*fabs(t1-t0)*2*PI*K2V);
      /* will monitor the absorbed part */
      Vars.cp *= 1-XY;
      /* and modify the neutron weight after monitor, only remains 1-p_detect */
      p *= XY;
    }

    if (Vars.Flag_capture)
    {
      XY = sqrt(Vars.cvx*Vars.cvx+Vars.cvy*Vars.cvy+Vars.cvz*Vars.cvz);
      XY *= V2K;
      if (XY != 0) XY = 2*PI/XY; /* lambda. lambda(2200 m/2) = 1.7985 Angs  */
      Vars.cp *= XY/1.7985;
    }

    pp = Monitor_nD_Trace(&DEFS, &Vars);
    if (pp==0.0)
    { ABSORB;
    }
    else if(pp==1)
    {
      SCATTER;
    }

    if (Vars.Flag_parallel) /* back to neutron state before detection */
      Flag_Restore = 1;
  } /* end if intersection */
  else {
    if (Vars.Flag_Absorb && !Vars.Flag_parallel)
    {
      // restore neutron ray before absorbing for correct mcdisplay
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
      ABSORB;
    }
    else Flag_Restore = 1;  /* no intersection, back to previous state */
  }

  if (Flag_Restore)
  {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 74087 "./SNS_BASIS.c"
}   /* End of TOFcyl=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompTOFcyl:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(145,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  mcabsorbAll:
  mcDEBUG_LEAVE()
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)
  /* Copy neutron state to global variables. */
  mcnx = mcnlx;
  mcny = mcnly;
  mcnz = mcnlz;
  mcnvx = mcnlvx;
  mcnvy = mcnlvy;
  mcnvz = mcnlvz;
  mcnt = mcnlt;
  mcnsx = mcnlsx;
  mcnsy = mcnlsy;
  mcnsz = mcnlsz;
  mcnp = mcnlp;

} /* end trace */

void mcsave(FILE *handle) {
  if (!handle) mcsiminfo_init(NULL);
  /* User component SAVE code. */

  /* User SAVE code for component 'Origin'. */
  SIG_MESSAGE("Origin (Save)");
#define mccompcurname  Origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccOrigin_IntermediateCnts
#define StartTime mccOrigin_StartTime
#define EndTime mccOrigin_EndTime
#define CurrentTime mccOrigin_CurrentTime
{   /* Declarations of Origin=Progress_bar() SETTING parameters. */
char* profile = mccOrigin_profile;
MCNUM percent = mccOrigin_percent;
MCNUM flag_save = mccOrigin_flag_save;
MCNUM minutes = mccOrigin_minutes;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../misc/Progress_bar.comp"
{
  MPI_MASTER(fprintf(stdout, "\nSave [%s]\n", mcinstrument_name););
  if (profile && strlen(profile) && strcmp(profile,"NULL") && strcmp(profile,"0")) {
    char filename[256];
    if (!strlen(profile) || !strcmp(profile,"NULL") || !strcmp(profile,"0")) strcpy(filename, mcinstrument_name);
    else strcpy(filename, profile);
    DETECTOR_OUT_1D(
        "Intensity profiler",
        "Component index [1]",
        "Intensity",
        "prof", 1, mcNUMCOMP, mcNUMCOMP-1,
        &mcNCounter[1],&mcPCounter[1],&mcP2Counter[1],
        filename);

  }
}
#line 74203 "./SNS_BASIS.c"
}   /* End of Origin=Progress_bar() SETTING parameter declarations. */
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'tofSTART'. */
  SIG_MESSAGE("tofSTART (Save)");
#define mccompcurname  tofSTART
#define mccompcurtype  TOF_monitor
#define mccompcurindex 3
#define nt mcctofSTART_nt
#define TOF_N mcctofSTART_TOF_N
#define TOF_p mcctofSTART_TOF_p
#define TOF_p2 mcctofSTART_TOF_p2
#define t_min mcctofSTART_t_min
#define t_max mcctofSTART_t_max
#define delta_t mcctofSTART_delta_t
{   /* Declarations of tofSTART=TOF_monitor() SETTING parameters. */
char* filename = mcctofSTART_filename;
MCNUM xmin = mcctofSTART_xmin;
MCNUM xmax = mcctofSTART_xmax;
MCNUM ymin = mcctofSTART_ymin;
MCNUM ymax = mcctofSTART_ymax;
MCNUM xwidth = mcctofSTART_xwidth;
MCNUM yheight = mcctofSTART_yheight;
MCNUM tmin = mcctofSTART_tmin;
MCNUM tmax = mcctofSTART_tmax;
MCNUM dt = mcctofSTART_dt;
MCNUM restore_neutron = mcctofSTART_restore_neutron;
int nowritefile = mcctofSTART_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 74250 "./SNS_BASIS.c"
}   /* End of tofSTART=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Source_Lam'. */
  SIG_MESSAGE("Source_Lam (Save)");
#define mccompcurname  Source_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 4
#define nL mccSource_Lam_nL
#define L_N mccSource_Lam_L_N
#define L_p mccSource_Lam_L_p
#define L_p2 mccSource_Lam_L_p2
{   /* Declarations of Source_Lam=L_monitor() SETTING parameters. */
char* filename = mccSource_Lam_filename;
MCNUM xmin = mccSource_Lam_xmin;
MCNUM xmax = mccSource_Lam_xmax;
MCNUM ymin = mccSource_Lam_ymin;
MCNUM ymax = mccSource_Lam_ymax;
MCNUM xwidth = mccSource_Lam_xwidth;
MCNUM yheight = mccSource_Lam_yheight;
MCNUM Lmin = mccSource_Lam_Lmin;
MCNUM Lmax = mccSource_Lam_Lmax;
MCNUM restore_neutron = mccSource_Lam_restore_neutron;
int nowritefile = mccSource_Lam_nowritefile;
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 74296 "./SNS_BASIS.c"
}   /* End of Source_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Source_En'. */
  SIG_MESSAGE("Source_En (Save)");
#define mccompcurname  Source_En
#define mccompcurtype  E_monitor
#define mccompcurindex 5
#define nE mccSource_En_nE
#define E_N mccSource_En_E_N
#define E_p mccSource_En_E_p
#define E_p2 mccSource_En_E_p2
#define S_p mccSource_En_S_p
#define S_pE mccSource_En_S_pE
#define S_pE2 mccSource_En_S_pE2
{   /* Declarations of Source_En=E_monitor() SETTING parameters. */
char* filename = mccSource_En_filename;
MCNUM xmin = mccSource_En_xmin;
MCNUM xmax = mccSource_En_xmax;
MCNUM ymin = mccSource_En_ymin;
MCNUM ymax = mccSource_En_ymax;
MCNUM xwidth = mccSource_En_xwidth;
MCNUM yheight = mccSource_En_yheight;
MCNUM Emin = mccSource_En_Emin;
MCNUM Emax = mccSource_En_Emax;
MCNUM restore_neutron = mccSource_En_restore_neutron;
int nowritefile = mccSource_En_nowritefile;
#line 117 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [meV]",
        "Intensity",
        "E", Emin, Emax, nE,
        &E_N[0],&E_p[0],&E_p2[0],
        filename);
    if (S_p) printf("<E> : %g meV , E-width : %g meV \n",
     S_pE/S_p,sqrt(S_pE2/S_p - S_pE*S_pE/(S_p*S_p)) );
    }
}
#line 74344 "./SNS_BASIS.c"
}   /* End of Source_En=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap0_start'. */
  SIG_MESSAGE("Gap0_start (Save)");
#define mccompcurname  Gap0_start
#define mccompcurtype  PSD_monitor
#define mccompcurindex 6
#define PSD_N mccGap0_start_PSD_N
#define PSD_p mccGap0_start_PSD_p
#define PSD_p2 mccGap0_start_PSD_p2
{   /* Declarations of Gap0_start=PSD_monitor() SETTING parameters. */
int nx = mccGap0_start_nx;
int ny = mccGap0_start_ny;
char* filename = mccGap0_start_filename;
MCNUM xmin = mccGap0_start_xmin;
MCNUM xmax = mccGap0_start_xmax;
MCNUM ymin = mccGap0_start_ymin;
MCNUM ymax = mccGap0_start_ymax;
MCNUM xwidth = mccGap0_start_xwidth;
MCNUM yheight = mccGap0_start_yheight;
MCNUM restore_neutron = mccGap0_start_restore_neutron;
#line 110 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  DETECTOR_OUT_2D(
    "PSD monitor",
    "X position [cm]",
    "Y position [cm]",
    xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
    nx, ny,
    &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
    filename);
}
#line 74387 "./SNS_BASIS.c"
}   /* End of Gap0_start=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap0_end_Lam'. */
  SIG_MESSAGE("Gap0_end_Lam (Save)");
#define mccompcurname  Gap0_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 7
#define nL mccGap0_end_Lam_nL
#define L_N mccGap0_end_Lam_L_N
#define L_p mccGap0_end_Lam_L_p
#define L_p2 mccGap0_end_Lam_L_p2
{   /* Declarations of Gap0_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap0_end_Lam_filename;
MCNUM xmin = mccGap0_end_Lam_xmin;
MCNUM xmax = mccGap0_end_Lam_xmax;
MCNUM ymin = mccGap0_end_Lam_ymin;
MCNUM ymax = mccGap0_end_Lam_ymax;
MCNUM xwidth = mccGap0_end_Lam_xwidth;
MCNUM yheight = mccGap0_end_Lam_yheight;
MCNUM Lmin = mccGap0_end_Lam_Lmin;
MCNUM Lmax = mccGap0_end_Lam_Lmax;
MCNUM restore_neutron = mccGap0_end_Lam_restore_neutron;
int nowritefile = mccGap0_end_Lam_nowritefile;
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 74429 "./SNS_BASIS.c"
}   /* End of Gap0_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap0_end_divx'. */
  SIG_MESSAGE("Gap0_end_divx (Save)");
#define mccompcurname  Gap0_end_divx
#define mccompcurtype  Monitor_nD
#define mccompcurindex 8
#define user1 mccGap0_end_divx_user1
#define user2 mccGap0_end_divx_user2
#define user3 mccGap0_end_divx_user3
#define DEFS mccGap0_end_divx_DEFS
#define Vars mccGap0_end_divx_Vars
#define detector mccGap0_end_divx_detector
#define offdata mccGap0_end_divx_offdata
{   /* Declarations of Gap0_end_divx=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccGap0_end_divx_xwidth;
MCNUM yheight = mccGap0_end_divx_yheight;
MCNUM zdepth = mccGap0_end_divx_zdepth;
MCNUM xmin = mccGap0_end_divx_xmin;
MCNUM xmax = mccGap0_end_divx_xmax;
MCNUM ymin = mccGap0_end_divx_ymin;
MCNUM ymax = mccGap0_end_divx_ymax;
MCNUM zmin = mccGap0_end_divx_zmin;
MCNUM zmax = mccGap0_end_divx_zmax;
MCNUM bins = mccGap0_end_divx_bins;
MCNUM min = mccGap0_end_divx_min;
MCNUM max = mccGap0_end_divx_max;
MCNUM restore_neutron = mccGap0_end_divx_restore_neutron;
MCNUM radius = mccGap0_end_divx_radius;
char* options = mccGap0_end_divx_options;
char* filename = mccGap0_end_divx_filename;
char* geometry = mccGap0_end_divx_geometry;
char* username1 = mccGap0_end_divx_username1;
char* username2 = mccGap0_end_divx_username2;
char* username3 = mccGap0_end_divx_username3;
int nowritefile = mccGap0_end_divx_nowritefile;
#line 481 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  /* save results, but do not free pointers */
  if (!nowritefile) {
    detector = Monitor_nD_Save(&DEFS, &Vars);
  }
}
#line 74480 "./SNS_BASIS.c"
}   /* End of Gap0_end_divx=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap0_end_divy'. */
  SIG_MESSAGE("Gap0_end_divy (Save)");
#define mccompcurname  Gap0_end_divy
#define mccompcurtype  Monitor_nD
#define mccompcurindex 9
#define user1 mccGap0_end_divy_user1
#define user2 mccGap0_end_divy_user2
#define user3 mccGap0_end_divy_user3
#define DEFS mccGap0_end_divy_DEFS
#define Vars mccGap0_end_divy_Vars
#define detector mccGap0_end_divy_detector
#define offdata mccGap0_end_divy_offdata
{   /* Declarations of Gap0_end_divy=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccGap0_end_divy_xwidth;
MCNUM yheight = mccGap0_end_divy_yheight;
MCNUM zdepth = mccGap0_end_divy_zdepth;
MCNUM xmin = mccGap0_end_divy_xmin;
MCNUM xmax = mccGap0_end_divy_xmax;
MCNUM ymin = mccGap0_end_divy_ymin;
MCNUM ymax = mccGap0_end_divy_ymax;
MCNUM zmin = mccGap0_end_divy_zmin;
MCNUM zmax = mccGap0_end_divy_zmax;
MCNUM bins = mccGap0_end_divy_bins;
MCNUM min = mccGap0_end_divy_min;
MCNUM max = mccGap0_end_divy_max;
MCNUM restore_neutron = mccGap0_end_divy_restore_neutron;
MCNUM radius = mccGap0_end_divy_radius;
char* options = mccGap0_end_divy_options;
char* filename = mccGap0_end_divy_filename;
char* geometry = mccGap0_end_divy_geometry;
char* username1 = mccGap0_end_divy_username1;
char* username2 = mccGap0_end_divy_username2;
char* username3 = mccGap0_end_divy_username3;
int nowritefile = mccGap0_end_divy_nowritefile;
#line 481 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  /* save results, but do not free pointers */
  if (!nowritefile) {
    detector = Monitor_nD_Save(&DEFS, &Vars);
  }
}
#line 74534 "./SNS_BASIS.c"
}   /* End of Gap0_end_divy=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap1_start_Lam'. */
  SIG_MESSAGE("Gap1_start_Lam (Save)");
#define mccompcurname  Gap1_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 12
#define nL mccGap1_start_Lam_nL
#define L_N mccGap1_start_Lam_L_N
#define L_p mccGap1_start_Lam_L_p
#define L_p2 mccGap1_start_Lam_L_p2
{   /* Declarations of Gap1_start_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap1_start_Lam_filename;
MCNUM xmin = mccGap1_start_Lam_xmin;
MCNUM xmax = mccGap1_start_Lam_xmax;
MCNUM ymin = mccGap1_start_Lam_ymin;
MCNUM ymax = mccGap1_start_Lam_ymax;
MCNUM xwidth = mccGap1_start_Lam_xwidth;
MCNUM yheight = mccGap1_start_Lam_yheight;
MCNUM Lmin = mccGap1_start_Lam_Lmin;
MCNUM Lmax = mccGap1_start_Lam_Lmax;
MCNUM restore_neutron = mccGap1_start_Lam_restore_neutron;
int nowritefile = mccGap1_start_Lam_nowritefile;
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 74580 "./SNS_BASIS.c"
}   /* End of Gap1_start_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap1_end_Lam'. */
  SIG_MESSAGE("Gap1_end_Lam (Save)");
#define mccompcurname  Gap1_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 13
#define nL mccGap1_end_Lam_nL
#define L_N mccGap1_end_Lam_L_N
#define L_p mccGap1_end_Lam_L_p
#define L_p2 mccGap1_end_Lam_L_p2
{   /* Declarations of Gap1_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap1_end_Lam_filename;
MCNUM xmin = mccGap1_end_Lam_xmin;
MCNUM xmax = mccGap1_end_Lam_xmax;
MCNUM ymin = mccGap1_end_Lam_ymin;
MCNUM ymax = mccGap1_end_Lam_ymax;
MCNUM xwidth = mccGap1_end_Lam_xwidth;
MCNUM yheight = mccGap1_end_Lam_yheight;
MCNUM Lmin = mccGap1_end_Lam_Lmin;
MCNUM Lmax = mccGap1_end_Lam_Lmax;
MCNUM restore_neutron = mccGap1_end_Lam_restore_neutron;
int nowritefile = mccGap1_end_Lam_nowritefile;
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 74623 "./SNS_BASIS.c"
}   /* End of Gap1_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap2_start_Lam'. */
  SIG_MESSAGE("Gap2_start_Lam (Save)");
#define mccompcurname  Gap2_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 24
#define nL mccGap2_start_Lam_nL
#define L_N mccGap2_start_Lam_L_N
#define L_p mccGap2_start_Lam_L_p
#define L_p2 mccGap2_start_Lam_L_p2
{   /* Declarations of Gap2_start_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap2_start_Lam_filename;
MCNUM xmin = mccGap2_start_Lam_xmin;
MCNUM xmax = mccGap2_start_Lam_xmax;
MCNUM ymin = mccGap2_start_Lam_ymin;
MCNUM ymax = mccGap2_start_Lam_ymax;
MCNUM xwidth = mccGap2_start_Lam_xwidth;
MCNUM yheight = mccGap2_start_Lam_yheight;
MCNUM Lmin = mccGap2_start_Lam_Lmin;
MCNUM Lmax = mccGap2_start_Lam_Lmax;
MCNUM restore_neutron = mccGap2_start_Lam_restore_neutron;
int nowritefile = mccGap2_start_Lam_nowritefile;
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 74666 "./SNS_BASIS.c"
}   /* End of Gap2_start_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap2_start_PSD'. */
  SIG_MESSAGE("Gap2_start_PSD (Save)");
#define mccompcurname  Gap2_start_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 25
#define PSD_N mccGap2_start_PSD_PSD_N
#define PSD_p mccGap2_start_PSD_PSD_p
#define PSD_p2 mccGap2_start_PSD_PSD_p2
{   /* Declarations of Gap2_start_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap2_start_PSD_nx;
int ny = mccGap2_start_PSD_ny;
char* filename = mccGap2_start_PSD_filename;
MCNUM xmin = mccGap2_start_PSD_xmin;
MCNUM xmax = mccGap2_start_PSD_xmax;
MCNUM ymin = mccGap2_start_PSD_ymin;
MCNUM ymax = mccGap2_start_PSD_ymax;
MCNUM xwidth = mccGap2_start_PSD_xwidth;
MCNUM yheight = mccGap2_start_PSD_yheight;
MCNUM restore_neutron = mccGap2_start_PSD_restore_neutron;
#line 110 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  DETECTOR_OUT_2D(
    "PSD monitor",
    "X position [cm]",
    "Y position [cm]",
    xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
    nx, ny,
    &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
    filename);
}
#line 74706 "./SNS_BASIS.c"
}   /* End of Gap2_start_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap2_end_Lam'. */
  SIG_MESSAGE("Gap2_end_Lam (Save)");
#define mccompcurname  Gap2_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 26
#define nL mccGap2_end_Lam_nL
#define L_N mccGap2_end_Lam_L_N
#define L_p mccGap2_end_Lam_L_p
#define L_p2 mccGap2_end_Lam_L_p2
{   /* Declarations of Gap2_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap2_end_Lam_filename;
MCNUM xmin = mccGap2_end_Lam_xmin;
MCNUM xmax = mccGap2_end_Lam_xmax;
MCNUM ymin = mccGap2_end_Lam_ymin;
MCNUM ymax = mccGap2_end_Lam_ymax;
MCNUM xwidth = mccGap2_end_Lam_xwidth;
MCNUM yheight = mccGap2_end_Lam_yheight;
MCNUM Lmin = mccGap2_end_Lam_Lmin;
MCNUM Lmax = mccGap2_end_Lam_Lmax;
MCNUM restore_neutron = mccGap2_end_Lam_restore_neutron;
int nowritefile = mccGap2_end_Lam_nowritefile;
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 74748 "./SNS_BASIS.c"
}   /* End of Gap2_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap2_end_PSD'. */
  SIG_MESSAGE("Gap2_end_PSD (Save)");
#define mccompcurname  Gap2_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 27
#define PSD_N mccGap2_end_PSD_PSD_N
#define PSD_p mccGap2_end_PSD_PSD_p
#define PSD_p2 mccGap2_end_PSD_PSD_p2
{   /* Declarations of Gap2_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap2_end_PSD_nx;
int ny = mccGap2_end_PSD_ny;
char* filename = mccGap2_end_PSD_filename;
MCNUM xmin = mccGap2_end_PSD_xmin;
MCNUM xmax = mccGap2_end_PSD_xmax;
MCNUM ymin = mccGap2_end_PSD_ymin;
MCNUM ymax = mccGap2_end_PSD_ymax;
MCNUM xwidth = mccGap2_end_PSD_xwidth;
MCNUM yheight = mccGap2_end_PSD_yheight;
MCNUM restore_neutron = mccGap2_end_PSD_restore_neutron;
#line 110 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  DETECTOR_OUT_2D(
    "PSD monitor",
    "X position [cm]",
    "Y position [cm]",
    xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
    nx, ny,
    &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
    filename);
}
#line 74788 "./SNS_BASIS.c"
}   /* End of Gap2_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap3_start_Lam'. */
  SIG_MESSAGE("Gap3_start_Lam (Save)");
#define mccompcurname  Gap3_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 41
#define nL mccGap3_start_Lam_nL
#define L_N mccGap3_start_Lam_L_N
#define L_p mccGap3_start_Lam_L_p
#define L_p2 mccGap3_start_Lam_L_p2
{   /* Declarations of Gap3_start_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap3_start_Lam_filename;
MCNUM xmin = mccGap3_start_Lam_xmin;
MCNUM xmax = mccGap3_start_Lam_xmax;
MCNUM ymin = mccGap3_start_Lam_ymin;
MCNUM ymax = mccGap3_start_Lam_ymax;
MCNUM xwidth = mccGap3_start_Lam_xwidth;
MCNUM yheight = mccGap3_start_Lam_yheight;
MCNUM Lmin = mccGap3_start_Lam_Lmin;
MCNUM Lmax = mccGap3_start_Lam_Lmax;
MCNUM restore_neutron = mccGap3_start_Lam_restore_neutron;
int nowritefile = mccGap3_start_Lam_nowritefile;
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 74830 "./SNS_BASIS.c"
}   /* End of Gap3_start_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'CGS1_end'. */
  SIG_MESSAGE("CGS1_end (Save)");
#define mccompcurname  CGS1_end
#define mccompcurtype  PSD_monitor
#define mccompcurindex 42
#define PSD_N mccCGS1_end_PSD_N
#define PSD_p mccCGS1_end_PSD_p
#define PSD_p2 mccCGS1_end_PSD_p2
{   /* Declarations of CGS1_end=PSD_monitor() SETTING parameters. */
int nx = mccCGS1_end_nx;
int ny = mccCGS1_end_ny;
char* filename = mccCGS1_end_filename;
MCNUM xmin = mccCGS1_end_xmin;
MCNUM xmax = mccCGS1_end_xmax;
MCNUM ymin = mccCGS1_end_ymin;
MCNUM ymax = mccCGS1_end_ymax;
MCNUM xwidth = mccCGS1_end_xwidth;
MCNUM yheight = mccCGS1_end_yheight;
MCNUM restore_neutron = mccCGS1_end_restore_neutron;
#line 110 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  DETECTOR_OUT_2D(
    "PSD monitor",
    "X position [cm]",
    "Y position [cm]",
    xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
    nx, ny,
    &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
    filename);
}
#line 74870 "./SNS_BASIS.c"
}   /* End of CGS1_end=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'before_Chopper1_ToF'. */
  SIG_MESSAGE("before_Chopper1_ToF (Save)");
#define mccompcurname  before_Chopper1_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 43
#define nt mccbefore_Chopper1_ToF_nt
#define TOF_N mccbefore_Chopper1_ToF_TOF_N
#define TOF_p mccbefore_Chopper1_ToF_TOF_p
#define TOF_p2 mccbefore_Chopper1_ToF_TOF_p2
#define t_min mccbefore_Chopper1_ToF_t_min
#define t_max mccbefore_Chopper1_ToF_t_max
#define delta_t mccbefore_Chopper1_ToF_delta_t
{   /* Declarations of before_Chopper1_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccbefore_Chopper1_ToF_filename;
MCNUM xmin = mccbefore_Chopper1_ToF_xmin;
MCNUM xmax = mccbefore_Chopper1_ToF_xmax;
MCNUM ymin = mccbefore_Chopper1_ToF_ymin;
MCNUM ymax = mccbefore_Chopper1_ToF_ymax;
MCNUM xwidth = mccbefore_Chopper1_ToF_xwidth;
MCNUM yheight = mccbefore_Chopper1_ToF_yheight;
MCNUM tmin = mccbefore_Chopper1_ToF_tmin;
MCNUM tmax = mccbefore_Chopper1_ToF_tmax;
MCNUM dt = mccbefore_Chopper1_ToF_dt;
MCNUM restore_neutron = mccbefore_Chopper1_ToF_restore_neutron;
int nowritefile = mccbefore_Chopper1_ToF_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 74916 "./SNS_BASIS.c"
}   /* End of before_Chopper1_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'before_Chopper1_ToF_Z'. */
  SIG_MESSAGE("before_Chopper1_ToF_Z (Save)");
#define mccompcurname  before_Chopper1_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 44
#define nt mccbefore_Chopper1_ToF_Z_nt
#define TOF_N mccbefore_Chopper1_ToF_Z_TOF_N
#define TOF_p mccbefore_Chopper1_ToF_Z_TOF_p
#define TOF_p2 mccbefore_Chopper1_ToF_Z_TOF_p2
#define t_min mccbefore_Chopper1_ToF_Z_t_min
#define t_max mccbefore_Chopper1_ToF_Z_t_max
#define delta_t mccbefore_Chopper1_ToF_Z_delta_t
{   /* Declarations of before_Chopper1_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccbefore_Chopper1_ToF_Z_filename;
MCNUM xmin = mccbefore_Chopper1_ToF_Z_xmin;
MCNUM xmax = mccbefore_Chopper1_ToF_Z_xmax;
MCNUM ymin = mccbefore_Chopper1_ToF_Z_ymin;
MCNUM ymax = mccbefore_Chopper1_ToF_Z_ymax;
MCNUM xwidth = mccbefore_Chopper1_ToF_Z_xwidth;
MCNUM yheight = mccbefore_Chopper1_ToF_Z_yheight;
MCNUM tmin = mccbefore_Chopper1_ToF_Z_tmin;
MCNUM tmax = mccbefore_Chopper1_ToF_Z_tmax;
MCNUM dt = mccbefore_Chopper1_ToF_Z_dt;
MCNUM restore_neutron = mccbefore_Chopper1_ToF_Z_restore_neutron;
int nowritefile = mccbefore_Chopper1_ToF_Z_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 74966 "./SNS_BASIS.c"
}   /* End of before_Chopper1_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Chopper1_ToF'. */
  SIG_MESSAGE("Chopper1_ToF (Save)");
#define mccompcurname  Chopper1_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 46
#define nt mccChopper1_ToF_nt
#define TOF_N mccChopper1_ToF_TOF_N
#define TOF_p mccChopper1_ToF_TOF_p
#define TOF_p2 mccChopper1_ToF_TOF_p2
#define t_min mccChopper1_ToF_t_min
#define t_max mccChopper1_ToF_t_max
#define delta_t mccChopper1_ToF_delta_t
{   /* Declarations of Chopper1_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccChopper1_ToF_filename;
MCNUM xmin = mccChopper1_ToF_xmin;
MCNUM xmax = mccChopper1_ToF_xmax;
MCNUM ymin = mccChopper1_ToF_ymin;
MCNUM ymax = mccChopper1_ToF_ymax;
MCNUM xwidth = mccChopper1_ToF_xwidth;
MCNUM yheight = mccChopper1_ToF_yheight;
MCNUM tmin = mccChopper1_ToF_tmin;
MCNUM tmax = mccChopper1_ToF_tmax;
MCNUM dt = mccChopper1_ToF_dt;
MCNUM restore_neutron = mccChopper1_ToF_restore_neutron;
int nowritefile = mccChopper1_ToF_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 75016 "./SNS_BASIS.c"
}   /* End of Chopper1_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Chopper1_ToF_Z'. */
  SIG_MESSAGE("Chopper1_ToF_Z (Save)");
#define mccompcurname  Chopper1_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 47
#define nt mccChopper1_ToF_Z_nt
#define TOF_N mccChopper1_ToF_Z_TOF_N
#define TOF_p mccChopper1_ToF_Z_TOF_p
#define TOF_p2 mccChopper1_ToF_Z_TOF_p2
#define t_min mccChopper1_ToF_Z_t_min
#define t_max mccChopper1_ToF_Z_t_max
#define delta_t mccChopper1_ToF_Z_delta_t
{   /* Declarations of Chopper1_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccChopper1_ToF_Z_filename;
MCNUM xmin = mccChopper1_ToF_Z_xmin;
MCNUM xmax = mccChopper1_ToF_Z_xmax;
MCNUM ymin = mccChopper1_ToF_Z_ymin;
MCNUM ymax = mccChopper1_ToF_Z_ymax;
MCNUM xwidth = mccChopper1_ToF_Z_xwidth;
MCNUM yheight = mccChopper1_ToF_Z_yheight;
MCNUM tmin = mccChopper1_ToF_Z_tmin;
MCNUM tmax = mccChopper1_ToF_Z_tmax;
MCNUM dt = mccChopper1_ToF_Z_dt;
MCNUM restore_neutron = mccChopper1_ToF_Z_restore_neutron;
int nowritefile = mccChopper1_ToF_Z_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 75066 "./SNS_BASIS.c"
}   /* End of Chopper1_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap3_end_Lam'. */
  SIG_MESSAGE("Gap3_end_Lam (Save)");
#define mccompcurname  Gap3_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 48
#define nL mccGap3_end_Lam_nL
#define L_N mccGap3_end_Lam_L_N
#define L_p mccGap3_end_Lam_L_p
#define L_p2 mccGap3_end_Lam_L_p2
{   /* Declarations of Gap3_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap3_end_Lam_filename;
MCNUM xmin = mccGap3_end_Lam_xmin;
MCNUM xmax = mccGap3_end_Lam_xmax;
MCNUM ymin = mccGap3_end_Lam_ymin;
MCNUM ymax = mccGap3_end_Lam_ymax;
MCNUM xwidth = mccGap3_end_Lam_xwidth;
MCNUM yheight = mccGap3_end_Lam_yheight;
MCNUM Lmin = mccGap3_end_Lam_Lmin;
MCNUM Lmax = mccGap3_end_Lam_Lmax;
MCNUM restore_neutron = mccGap3_end_Lam_restore_neutron;
int nowritefile = mccGap3_end_Lam_nowritefile;
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 75112 "./SNS_BASIS.c"
}   /* End of Gap3_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap3_end_PSD'. */
  SIG_MESSAGE("Gap3_end_PSD (Save)");
#define mccompcurname  Gap3_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 49
#define PSD_N mccGap3_end_PSD_PSD_N
#define PSD_p mccGap3_end_PSD_PSD_p
#define PSD_p2 mccGap3_end_PSD_PSD_p2
{   /* Declarations of Gap3_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap3_end_PSD_nx;
int ny = mccGap3_end_PSD_ny;
char* filename = mccGap3_end_PSD_filename;
MCNUM xmin = mccGap3_end_PSD_xmin;
MCNUM xmax = mccGap3_end_PSD_xmax;
MCNUM ymin = mccGap3_end_PSD_ymin;
MCNUM ymax = mccGap3_end_PSD_ymax;
MCNUM xwidth = mccGap3_end_PSD_xwidth;
MCNUM yheight = mccGap3_end_PSD_yheight;
MCNUM restore_neutron = mccGap3_end_PSD_restore_neutron;
#line 110 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  DETECTOR_OUT_2D(
    "PSD monitor",
    "X position [cm]",
    "Y position [cm]",
    xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
    nx, ny,
    &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
    filename);
}
#line 75152 "./SNS_BASIS.c"
}   /* End of Gap3_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap4_start_Lam'. */
  SIG_MESSAGE("Gap4_start_Lam (Save)");
#define mccompcurname  Gap4_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 60
#define nL mccGap4_start_Lam_nL
#define L_N mccGap4_start_Lam_L_N
#define L_p mccGap4_start_Lam_L_p
#define L_p2 mccGap4_start_Lam_L_p2
{   /* Declarations of Gap4_start_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap4_start_Lam_filename;
MCNUM xmin = mccGap4_start_Lam_xmin;
MCNUM xmax = mccGap4_start_Lam_xmax;
MCNUM ymin = mccGap4_start_Lam_ymin;
MCNUM ymax = mccGap4_start_Lam_ymax;
MCNUM xwidth = mccGap4_start_Lam_xwidth;
MCNUM yheight = mccGap4_start_Lam_yheight;
MCNUM Lmin = mccGap4_start_Lam_Lmin;
MCNUM Lmax = mccGap4_start_Lam_Lmax;
MCNUM restore_neutron = mccGap4_start_Lam_restore_neutron;
int nowritefile = mccGap4_start_Lam_nowritefile;
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 75194 "./SNS_BASIS.c"
}   /* End of Gap4_start_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap4_start_PSD'. */
  SIG_MESSAGE("Gap4_start_PSD (Save)");
#define mccompcurname  Gap4_start_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 61
#define PSD_N mccGap4_start_PSD_PSD_N
#define PSD_p mccGap4_start_PSD_PSD_p
#define PSD_p2 mccGap4_start_PSD_PSD_p2
{   /* Declarations of Gap4_start_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap4_start_PSD_nx;
int ny = mccGap4_start_PSD_ny;
char* filename = mccGap4_start_PSD_filename;
MCNUM xmin = mccGap4_start_PSD_xmin;
MCNUM xmax = mccGap4_start_PSD_xmax;
MCNUM ymin = mccGap4_start_PSD_ymin;
MCNUM ymax = mccGap4_start_PSD_ymax;
MCNUM xwidth = mccGap4_start_PSD_xwidth;
MCNUM yheight = mccGap4_start_PSD_yheight;
MCNUM restore_neutron = mccGap4_start_PSD_restore_neutron;
#line 110 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  DETECTOR_OUT_2D(
    "PSD monitor",
    "X position [cm]",
    "Y position [cm]",
    xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
    nx, ny,
    &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
    filename);
}
#line 75234 "./SNS_BASIS.c"
}   /* End of Gap4_start_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'before_Chopper2_ToF'. */
  SIG_MESSAGE("before_Chopper2_ToF (Save)");
#define mccompcurname  before_Chopper2_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 62
#define nt mccbefore_Chopper2_ToF_nt
#define TOF_N mccbefore_Chopper2_ToF_TOF_N
#define TOF_p mccbefore_Chopper2_ToF_TOF_p
#define TOF_p2 mccbefore_Chopper2_ToF_TOF_p2
#define t_min mccbefore_Chopper2_ToF_t_min
#define t_max mccbefore_Chopper2_ToF_t_max
#define delta_t mccbefore_Chopper2_ToF_delta_t
{   /* Declarations of before_Chopper2_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccbefore_Chopper2_ToF_filename;
MCNUM xmin = mccbefore_Chopper2_ToF_xmin;
MCNUM xmax = mccbefore_Chopper2_ToF_xmax;
MCNUM ymin = mccbefore_Chopper2_ToF_ymin;
MCNUM ymax = mccbefore_Chopper2_ToF_ymax;
MCNUM xwidth = mccbefore_Chopper2_ToF_xwidth;
MCNUM yheight = mccbefore_Chopper2_ToF_yheight;
MCNUM tmin = mccbefore_Chopper2_ToF_tmin;
MCNUM tmax = mccbefore_Chopper2_ToF_tmax;
MCNUM dt = mccbefore_Chopper2_ToF_dt;
MCNUM restore_neutron = mccbefore_Chopper2_ToF_restore_neutron;
int nowritefile = mccbefore_Chopper2_ToF_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 75280 "./SNS_BASIS.c"
}   /* End of before_Chopper2_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'before_Chopper2_ToF_Z'. */
  SIG_MESSAGE("before_Chopper2_ToF_Z (Save)");
#define mccompcurname  before_Chopper2_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 63
#define nt mccbefore_Chopper2_ToF_Z_nt
#define TOF_N mccbefore_Chopper2_ToF_Z_TOF_N
#define TOF_p mccbefore_Chopper2_ToF_Z_TOF_p
#define TOF_p2 mccbefore_Chopper2_ToF_Z_TOF_p2
#define t_min mccbefore_Chopper2_ToF_Z_t_min
#define t_max mccbefore_Chopper2_ToF_Z_t_max
#define delta_t mccbefore_Chopper2_ToF_Z_delta_t
{   /* Declarations of before_Chopper2_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccbefore_Chopper2_ToF_Z_filename;
MCNUM xmin = mccbefore_Chopper2_ToF_Z_xmin;
MCNUM xmax = mccbefore_Chopper2_ToF_Z_xmax;
MCNUM ymin = mccbefore_Chopper2_ToF_Z_ymin;
MCNUM ymax = mccbefore_Chopper2_ToF_Z_ymax;
MCNUM xwidth = mccbefore_Chopper2_ToF_Z_xwidth;
MCNUM yheight = mccbefore_Chopper2_ToF_Z_yheight;
MCNUM tmin = mccbefore_Chopper2_ToF_Z_tmin;
MCNUM tmax = mccbefore_Chopper2_ToF_Z_tmax;
MCNUM dt = mccbefore_Chopper2_ToF_Z_dt;
MCNUM restore_neutron = mccbefore_Chopper2_ToF_Z_restore_neutron;
int nowritefile = mccbefore_Chopper2_ToF_Z_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 75330 "./SNS_BASIS.c"
}   /* End of before_Chopper2_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Chopper2_ToF'. */
  SIG_MESSAGE("Chopper2_ToF (Save)");
#define mccompcurname  Chopper2_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 65
#define nt mccChopper2_ToF_nt
#define TOF_N mccChopper2_ToF_TOF_N
#define TOF_p mccChopper2_ToF_TOF_p
#define TOF_p2 mccChopper2_ToF_TOF_p2
#define t_min mccChopper2_ToF_t_min
#define t_max mccChopper2_ToF_t_max
#define delta_t mccChopper2_ToF_delta_t
{   /* Declarations of Chopper2_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccChopper2_ToF_filename;
MCNUM xmin = mccChopper2_ToF_xmin;
MCNUM xmax = mccChopper2_ToF_xmax;
MCNUM ymin = mccChopper2_ToF_ymin;
MCNUM ymax = mccChopper2_ToF_ymax;
MCNUM xwidth = mccChopper2_ToF_xwidth;
MCNUM yheight = mccChopper2_ToF_yheight;
MCNUM tmin = mccChopper2_ToF_tmin;
MCNUM tmax = mccChopper2_ToF_tmax;
MCNUM dt = mccChopper2_ToF_dt;
MCNUM restore_neutron = mccChopper2_ToF_restore_neutron;
int nowritefile = mccChopper2_ToF_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 75380 "./SNS_BASIS.c"
}   /* End of Chopper2_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Chopper2_ToF_Z'. */
  SIG_MESSAGE("Chopper2_ToF_Z (Save)");
#define mccompcurname  Chopper2_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 66
#define nt mccChopper2_ToF_Z_nt
#define TOF_N mccChopper2_ToF_Z_TOF_N
#define TOF_p mccChopper2_ToF_Z_TOF_p
#define TOF_p2 mccChopper2_ToF_Z_TOF_p2
#define t_min mccChopper2_ToF_Z_t_min
#define t_max mccChopper2_ToF_Z_t_max
#define delta_t mccChopper2_ToF_Z_delta_t
{   /* Declarations of Chopper2_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccChopper2_ToF_Z_filename;
MCNUM xmin = mccChopper2_ToF_Z_xmin;
MCNUM xmax = mccChopper2_ToF_Z_xmax;
MCNUM ymin = mccChopper2_ToF_Z_ymin;
MCNUM ymax = mccChopper2_ToF_Z_ymax;
MCNUM xwidth = mccChopper2_ToF_Z_xwidth;
MCNUM yheight = mccChopper2_ToF_Z_yheight;
MCNUM tmin = mccChopper2_ToF_Z_tmin;
MCNUM tmax = mccChopper2_ToF_Z_tmax;
MCNUM dt = mccChopper2_ToF_Z_dt;
MCNUM restore_neutron = mccChopper2_ToF_Z_restore_neutron;
int nowritefile = mccChopper2_ToF_Z_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 75430 "./SNS_BASIS.c"
}   /* End of Chopper2_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap4_end_Lam'. */
  SIG_MESSAGE("Gap4_end_Lam (Save)");
#define mccompcurname  Gap4_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 67
#define nL mccGap4_end_Lam_nL
#define L_N mccGap4_end_Lam_L_N
#define L_p mccGap4_end_Lam_L_p
#define L_p2 mccGap4_end_Lam_L_p2
{   /* Declarations of Gap4_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap4_end_Lam_filename;
MCNUM xmin = mccGap4_end_Lam_xmin;
MCNUM xmax = mccGap4_end_Lam_xmax;
MCNUM ymin = mccGap4_end_Lam_ymin;
MCNUM ymax = mccGap4_end_Lam_ymax;
MCNUM xwidth = mccGap4_end_Lam_xwidth;
MCNUM yheight = mccGap4_end_Lam_yheight;
MCNUM Lmin = mccGap4_end_Lam_Lmin;
MCNUM Lmax = mccGap4_end_Lam_Lmax;
MCNUM restore_neutron = mccGap4_end_Lam_restore_neutron;
int nowritefile = mccGap4_end_Lam_nowritefile;
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 75476 "./SNS_BASIS.c"
}   /* End of Gap4_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap4_end_PSD'. */
  SIG_MESSAGE("Gap4_end_PSD (Save)");
#define mccompcurname  Gap4_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 68
#define PSD_N mccGap4_end_PSD_PSD_N
#define PSD_p mccGap4_end_PSD_PSD_p
#define PSD_p2 mccGap4_end_PSD_PSD_p2
{   /* Declarations of Gap4_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap4_end_PSD_nx;
int ny = mccGap4_end_PSD_ny;
char* filename = mccGap4_end_PSD_filename;
MCNUM xmin = mccGap4_end_PSD_xmin;
MCNUM xmax = mccGap4_end_PSD_xmax;
MCNUM ymin = mccGap4_end_PSD_ymin;
MCNUM ymax = mccGap4_end_PSD_ymax;
MCNUM xwidth = mccGap4_end_PSD_xwidth;
MCNUM yheight = mccGap4_end_PSD_yheight;
MCNUM restore_neutron = mccGap4_end_PSD_restore_neutron;
#line 110 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  DETECTOR_OUT_2D(
    "PSD monitor",
    "X position [cm]",
    "Y position [cm]",
    xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
    nx, ny,
    &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
    filename);
}
#line 75516 "./SNS_BASIS.c"
}   /* End of Gap4_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'CGS3_end_ToF'. */
  SIG_MESSAGE("CGS3_end_ToF (Save)");
#define mccompcurname  CGS3_end_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 81
#define nt mccCGS3_end_ToF_nt
#define TOF_N mccCGS3_end_ToF_TOF_N
#define TOF_p mccCGS3_end_ToF_TOF_p
#define TOF_p2 mccCGS3_end_ToF_TOF_p2
#define t_min mccCGS3_end_ToF_t_min
#define t_max mccCGS3_end_ToF_t_max
#define delta_t mccCGS3_end_ToF_delta_t
{   /* Declarations of CGS3_end_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccCGS3_end_ToF_filename;
MCNUM xmin = mccCGS3_end_ToF_xmin;
MCNUM xmax = mccCGS3_end_ToF_xmax;
MCNUM ymin = mccCGS3_end_ToF_ymin;
MCNUM ymax = mccCGS3_end_ToF_ymax;
MCNUM xwidth = mccCGS3_end_ToF_xwidth;
MCNUM yheight = mccCGS3_end_ToF_yheight;
MCNUM tmin = mccCGS3_end_ToF_tmin;
MCNUM tmax = mccCGS3_end_ToF_tmax;
MCNUM dt = mccCGS3_end_ToF_dt;
MCNUM restore_neutron = mccCGS3_end_ToF_restore_neutron;
int nowritefile = mccCGS3_end_ToF_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 75562 "./SNS_BASIS.c"
}   /* End of CGS3_end_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'CGS3_end_ToF_Z'. */
  SIG_MESSAGE("CGS3_end_ToF_Z (Save)");
#define mccompcurname  CGS3_end_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 82
#define nt mccCGS3_end_ToF_Z_nt
#define TOF_N mccCGS3_end_ToF_Z_TOF_N
#define TOF_p mccCGS3_end_ToF_Z_TOF_p
#define TOF_p2 mccCGS3_end_ToF_Z_TOF_p2
#define t_min mccCGS3_end_ToF_Z_t_min
#define t_max mccCGS3_end_ToF_Z_t_max
#define delta_t mccCGS3_end_ToF_Z_delta_t
{   /* Declarations of CGS3_end_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccCGS3_end_ToF_Z_filename;
MCNUM xmin = mccCGS3_end_ToF_Z_xmin;
MCNUM xmax = mccCGS3_end_ToF_Z_xmax;
MCNUM ymin = mccCGS3_end_ToF_Z_ymin;
MCNUM ymax = mccCGS3_end_ToF_Z_ymax;
MCNUM xwidth = mccCGS3_end_ToF_Z_xwidth;
MCNUM yheight = mccCGS3_end_ToF_Z_yheight;
MCNUM tmin = mccCGS3_end_ToF_Z_tmin;
MCNUM tmax = mccCGS3_end_ToF_Z_tmax;
MCNUM dt = mccCGS3_end_ToF_Z_dt;
MCNUM restore_neutron = mccCGS3_end_ToF_Z_restore_neutron;
int nowritefile = mccCGS3_end_ToF_Z_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 75612 "./SNS_BASIS.c"
}   /* End of CGS3_end_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'CGS3_end_Lam'. */
  SIG_MESSAGE("CGS3_end_Lam (Save)");
#define mccompcurname  CGS3_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 83
#define nL mccCGS3_end_Lam_nL
#define L_N mccCGS3_end_Lam_L_N
#define L_p mccCGS3_end_Lam_L_p
#define L_p2 mccCGS3_end_Lam_L_p2
{   /* Declarations of CGS3_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccCGS3_end_Lam_filename;
MCNUM xmin = mccCGS3_end_Lam_xmin;
MCNUM xmax = mccCGS3_end_Lam_xmax;
MCNUM ymin = mccCGS3_end_Lam_ymin;
MCNUM ymax = mccCGS3_end_Lam_ymax;
MCNUM xwidth = mccCGS3_end_Lam_xwidth;
MCNUM yheight = mccCGS3_end_Lam_yheight;
MCNUM Lmin = mccCGS3_end_Lam_Lmin;
MCNUM Lmax = mccCGS3_end_Lam_Lmax;
MCNUM restore_neutron = mccCGS3_end_Lam_restore_neutron;
int nowritefile = mccCGS3_end_Lam_nowritefile;
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 75658 "./SNS_BASIS.c"
}   /* End of CGS3_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap5_start_ToF'. */
  SIG_MESSAGE("Gap5_start_ToF (Save)");
#define mccompcurname  Gap5_start_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 86
#define nt mccGap5_start_ToF_nt
#define TOF_N mccGap5_start_ToF_TOF_N
#define TOF_p mccGap5_start_ToF_TOF_p
#define TOF_p2 mccGap5_start_ToF_TOF_p2
#define t_min mccGap5_start_ToF_t_min
#define t_max mccGap5_start_ToF_t_max
#define delta_t mccGap5_start_ToF_delta_t
{   /* Declarations of Gap5_start_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccGap5_start_ToF_filename;
MCNUM xmin = mccGap5_start_ToF_xmin;
MCNUM xmax = mccGap5_start_ToF_xmax;
MCNUM ymin = mccGap5_start_ToF_ymin;
MCNUM ymax = mccGap5_start_ToF_ymax;
MCNUM xwidth = mccGap5_start_ToF_xwidth;
MCNUM yheight = mccGap5_start_ToF_yheight;
MCNUM tmin = mccGap5_start_ToF_tmin;
MCNUM tmax = mccGap5_start_ToF_tmax;
MCNUM dt = mccGap5_start_ToF_dt;
MCNUM restore_neutron = mccGap5_start_ToF_restore_neutron;
int nowritefile = mccGap5_start_ToF_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 75705 "./SNS_BASIS.c"
}   /* End of Gap5_start_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap5_start_ToF_Z'. */
  SIG_MESSAGE("Gap5_start_ToF_Z (Save)");
#define mccompcurname  Gap5_start_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 87
#define nt mccGap5_start_ToF_Z_nt
#define TOF_N mccGap5_start_ToF_Z_TOF_N
#define TOF_p mccGap5_start_ToF_Z_TOF_p
#define TOF_p2 mccGap5_start_ToF_Z_TOF_p2
#define t_min mccGap5_start_ToF_Z_t_min
#define t_max mccGap5_start_ToF_Z_t_max
#define delta_t mccGap5_start_ToF_Z_delta_t
{   /* Declarations of Gap5_start_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccGap5_start_ToF_Z_filename;
MCNUM xmin = mccGap5_start_ToF_Z_xmin;
MCNUM xmax = mccGap5_start_ToF_Z_xmax;
MCNUM ymin = mccGap5_start_ToF_Z_ymin;
MCNUM ymax = mccGap5_start_ToF_Z_ymax;
MCNUM xwidth = mccGap5_start_ToF_Z_xwidth;
MCNUM yheight = mccGap5_start_ToF_Z_yheight;
MCNUM tmin = mccGap5_start_ToF_Z_tmin;
MCNUM tmax = mccGap5_start_ToF_Z_tmax;
MCNUM dt = mccGap5_start_ToF_Z_dt;
MCNUM restore_neutron = mccGap5_start_ToF_Z_restore_neutron;
int nowritefile = mccGap5_start_ToF_Z_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 75755 "./SNS_BASIS.c"
}   /* End of Gap5_start_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap5_start_Lam'. */
  SIG_MESSAGE("Gap5_start_Lam (Save)");
#define mccompcurname  Gap5_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 88
#define nL mccGap5_start_Lam_nL
#define L_N mccGap5_start_Lam_L_N
#define L_p mccGap5_start_Lam_L_p
#define L_p2 mccGap5_start_Lam_L_p2
{   /* Declarations of Gap5_start_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap5_start_Lam_filename;
MCNUM xmin = mccGap5_start_Lam_xmin;
MCNUM xmax = mccGap5_start_Lam_xmax;
MCNUM ymin = mccGap5_start_Lam_ymin;
MCNUM ymax = mccGap5_start_Lam_ymax;
MCNUM xwidth = mccGap5_start_Lam_xwidth;
MCNUM yheight = mccGap5_start_Lam_yheight;
MCNUM Lmin = mccGap5_start_Lam_Lmin;
MCNUM Lmax = mccGap5_start_Lam_Lmax;
MCNUM restore_neutron = mccGap5_start_Lam_restore_neutron;
int nowritefile = mccGap5_start_Lam_nowritefile;
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 75801 "./SNS_BASIS.c"
}   /* End of Gap5_start_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap5_start_PSD'. */
  SIG_MESSAGE("Gap5_start_PSD (Save)");
#define mccompcurname  Gap5_start_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 89
#define PSD_N mccGap5_start_PSD_PSD_N
#define PSD_p mccGap5_start_PSD_PSD_p
#define PSD_p2 mccGap5_start_PSD_PSD_p2
{   /* Declarations of Gap5_start_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap5_start_PSD_nx;
int ny = mccGap5_start_PSD_ny;
char* filename = mccGap5_start_PSD_filename;
MCNUM xmin = mccGap5_start_PSD_xmin;
MCNUM xmax = mccGap5_start_PSD_xmax;
MCNUM ymin = mccGap5_start_PSD_ymin;
MCNUM ymax = mccGap5_start_PSD_ymax;
MCNUM xwidth = mccGap5_start_PSD_xwidth;
MCNUM yheight = mccGap5_start_PSD_yheight;
MCNUM restore_neutron = mccGap5_start_PSD_restore_neutron;
#line 110 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  DETECTOR_OUT_2D(
    "PSD monitor",
    "X position [cm]",
    "Y position [cm]",
    xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
    nx, ny,
    &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
    filename);
}
#line 75841 "./SNS_BASIS.c"
}   /* End of Gap5_start_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Chopper3_ToF'. */
  SIG_MESSAGE("Chopper3_ToF (Save)");
#define mccompcurname  Chopper3_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 91
#define nt mccChopper3_ToF_nt
#define TOF_N mccChopper3_ToF_TOF_N
#define TOF_p mccChopper3_ToF_TOF_p
#define TOF_p2 mccChopper3_ToF_TOF_p2
#define t_min mccChopper3_ToF_t_min
#define t_max mccChopper3_ToF_t_max
#define delta_t mccChopper3_ToF_delta_t
{   /* Declarations of Chopper3_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccChopper3_ToF_filename;
MCNUM xmin = mccChopper3_ToF_xmin;
MCNUM xmax = mccChopper3_ToF_xmax;
MCNUM ymin = mccChopper3_ToF_ymin;
MCNUM ymax = mccChopper3_ToF_ymax;
MCNUM xwidth = mccChopper3_ToF_xwidth;
MCNUM yheight = mccChopper3_ToF_yheight;
MCNUM tmin = mccChopper3_ToF_tmin;
MCNUM tmax = mccChopper3_ToF_tmax;
MCNUM dt = mccChopper3_ToF_dt;
MCNUM restore_neutron = mccChopper3_ToF_restore_neutron;
int nowritefile = mccChopper3_ToF_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 75887 "./SNS_BASIS.c"
}   /* End of Chopper3_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Chopper3_ToF_Z'. */
  SIG_MESSAGE("Chopper3_ToF_Z (Save)");
#define mccompcurname  Chopper3_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 92
#define nt mccChopper3_ToF_Z_nt
#define TOF_N mccChopper3_ToF_Z_TOF_N
#define TOF_p mccChopper3_ToF_Z_TOF_p
#define TOF_p2 mccChopper3_ToF_Z_TOF_p2
#define t_min mccChopper3_ToF_Z_t_min
#define t_max mccChopper3_ToF_Z_t_max
#define delta_t mccChopper3_ToF_Z_delta_t
{   /* Declarations of Chopper3_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccChopper3_ToF_Z_filename;
MCNUM xmin = mccChopper3_ToF_Z_xmin;
MCNUM xmax = mccChopper3_ToF_Z_xmax;
MCNUM ymin = mccChopper3_ToF_Z_ymin;
MCNUM ymax = mccChopper3_ToF_Z_ymax;
MCNUM xwidth = mccChopper3_ToF_Z_xwidth;
MCNUM yheight = mccChopper3_ToF_Z_yheight;
MCNUM tmin = mccChopper3_ToF_Z_tmin;
MCNUM tmax = mccChopper3_ToF_Z_tmax;
MCNUM dt = mccChopper3_ToF_Z_dt;
MCNUM restore_neutron = mccChopper3_ToF_Z_restore_neutron;
int nowritefile = mccChopper3_ToF_Z_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 75937 "./SNS_BASIS.c"
}   /* End of Chopper3_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap5_end_Lam'. */
  SIG_MESSAGE("Gap5_end_Lam (Save)");
#define mccompcurname  Gap5_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 93
#define nL mccGap5_end_Lam_nL
#define L_N mccGap5_end_Lam_L_N
#define L_p mccGap5_end_Lam_L_p
#define L_p2 mccGap5_end_Lam_L_p2
{   /* Declarations of Gap5_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap5_end_Lam_filename;
MCNUM xmin = mccGap5_end_Lam_xmin;
MCNUM xmax = mccGap5_end_Lam_xmax;
MCNUM ymin = mccGap5_end_Lam_ymin;
MCNUM ymax = mccGap5_end_Lam_ymax;
MCNUM xwidth = mccGap5_end_Lam_xwidth;
MCNUM yheight = mccGap5_end_Lam_yheight;
MCNUM Lmin = mccGap5_end_Lam_Lmin;
MCNUM Lmax = mccGap5_end_Lam_Lmax;
MCNUM restore_neutron = mccGap5_end_Lam_restore_neutron;
int nowritefile = mccGap5_end_Lam_nowritefile;
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 75983 "./SNS_BASIS.c"
}   /* End of Gap5_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Gap5_end_PSD'. */
  SIG_MESSAGE("Gap5_end_PSD (Save)");
#define mccompcurname  Gap5_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 94
#define PSD_N mccGap5_end_PSD_PSD_N
#define PSD_p mccGap5_end_PSD_PSD_p
#define PSD_p2 mccGap5_end_PSD_PSD_p2
{   /* Declarations of Gap5_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap5_end_PSD_nx;
int ny = mccGap5_end_PSD_ny;
char* filename = mccGap5_end_PSD_filename;
MCNUM xmin = mccGap5_end_PSD_xmin;
MCNUM xmax = mccGap5_end_PSD_xmax;
MCNUM ymin = mccGap5_end_PSD_ymin;
MCNUM ymax = mccGap5_end_PSD_ymax;
MCNUM xwidth = mccGap5_end_PSD_xwidth;
MCNUM yheight = mccGap5_end_PSD_yheight;
MCNUM restore_neutron = mccGap5_end_PSD_restore_neutron;
#line 110 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  DETECTOR_OUT_2D(
    "PSD monitor",
    "X position [cm]",
    "Y position [cm]",
    xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
    nx, ny,
    &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
    filename);
}
#line 76023 "./SNS_BASIS.c"
}   /* End of Gap5_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'SGS2_end_Lam'. */
  SIG_MESSAGE("SGS2_end_Lam (Save)");
#define mccompcurname  SGS2_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 97
#define nL mccSGS2_end_Lam_nL
#define L_N mccSGS2_end_Lam_L_N
#define L_p mccSGS2_end_Lam_L_p
#define L_p2 mccSGS2_end_Lam_L_p2
{   /* Declarations of SGS2_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccSGS2_end_Lam_filename;
MCNUM xmin = mccSGS2_end_Lam_xmin;
MCNUM xmax = mccSGS2_end_Lam_xmax;
MCNUM ymin = mccSGS2_end_Lam_ymin;
MCNUM ymax = mccSGS2_end_Lam_ymax;
MCNUM xwidth = mccSGS2_end_Lam_xwidth;
MCNUM yheight = mccSGS2_end_Lam_yheight;
MCNUM Lmin = mccSGS2_end_Lam_Lmin;
MCNUM Lmax = mccSGS2_end_Lam_Lmax;
MCNUM restore_neutron = mccSGS2_end_Lam_restore_neutron;
int nowritefile = mccSGS2_end_Lam_nowritefile;
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 76065 "./SNS_BASIS.c"
}   /* End of SGS2_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'SGS2_end_PSD'. */
  SIG_MESSAGE("SGS2_end_PSD (Save)");
#define mccompcurname  SGS2_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 98
#define PSD_N mccSGS2_end_PSD_PSD_N
#define PSD_p mccSGS2_end_PSD_PSD_p
#define PSD_p2 mccSGS2_end_PSD_PSD_p2
{   /* Declarations of SGS2_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccSGS2_end_PSD_nx;
int ny = mccSGS2_end_PSD_ny;
char* filename = mccSGS2_end_PSD_filename;
MCNUM xmin = mccSGS2_end_PSD_xmin;
MCNUM xmax = mccSGS2_end_PSD_xmax;
MCNUM ymin = mccSGS2_end_PSD_ymin;
MCNUM ymax = mccSGS2_end_PSD_ymax;
MCNUM xwidth = mccSGS2_end_PSD_xwidth;
MCNUM yheight = mccSGS2_end_PSD_yheight;
MCNUM restore_neutron = mccSGS2_end_PSD_restore_neutron;
#line 110 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  DETECTOR_OUT_2D(
    "PSD monitor",
    "X position [cm]",
    "Y position [cm]",
    xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
    nx, ny,
    &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
    filename);
}
#line 76105 "./SNS_BASIS.c"
}   /* End of SGS2_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'SG3_end_ToF'. */
  SIG_MESSAGE("SG3_end_ToF (Save)");
#define mccompcurname  SG3_end_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 100
#define nt mccSG3_end_ToF_nt
#define TOF_N mccSG3_end_ToF_TOF_N
#define TOF_p mccSG3_end_ToF_TOF_p
#define TOF_p2 mccSG3_end_ToF_TOF_p2
#define t_min mccSG3_end_ToF_t_min
#define t_max mccSG3_end_ToF_t_max
#define delta_t mccSG3_end_ToF_delta_t
{   /* Declarations of SG3_end_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccSG3_end_ToF_filename;
MCNUM xmin = mccSG3_end_ToF_xmin;
MCNUM xmax = mccSG3_end_ToF_xmax;
MCNUM ymin = mccSG3_end_ToF_ymin;
MCNUM ymax = mccSG3_end_ToF_ymax;
MCNUM xwidth = mccSG3_end_ToF_xwidth;
MCNUM yheight = mccSG3_end_ToF_yheight;
MCNUM tmin = mccSG3_end_ToF_tmin;
MCNUM tmax = mccSG3_end_ToF_tmax;
MCNUM dt = mccSG3_end_ToF_dt;
MCNUM restore_neutron = mccSG3_end_ToF_restore_neutron;
int nowritefile = mccSG3_end_ToF_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 76151 "./SNS_BASIS.c"
}   /* End of SG3_end_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'SG3_end_ToF_Z'. */
  SIG_MESSAGE("SG3_end_ToF_Z (Save)");
#define mccompcurname  SG3_end_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 101
#define nt mccSG3_end_ToF_Z_nt
#define TOF_N mccSG3_end_ToF_Z_TOF_N
#define TOF_p mccSG3_end_ToF_Z_TOF_p
#define TOF_p2 mccSG3_end_ToF_Z_TOF_p2
#define t_min mccSG3_end_ToF_Z_t_min
#define t_max mccSG3_end_ToF_Z_t_max
#define delta_t mccSG3_end_ToF_Z_delta_t
{   /* Declarations of SG3_end_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccSG3_end_ToF_Z_filename;
MCNUM xmin = mccSG3_end_ToF_Z_xmin;
MCNUM xmax = mccSG3_end_ToF_Z_xmax;
MCNUM ymin = mccSG3_end_ToF_Z_ymin;
MCNUM ymax = mccSG3_end_ToF_Z_ymax;
MCNUM xwidth = mccSG3_end_ToF_Z_xwidth;
MCNUM yheight = mccSG3_end_ToF_Z_yheight;
MCNUM tmin = mccSG3_end_ToF_Z_tmin;
MCNUM tmax = mccSG3_end_ToF_Z_tmax;
MCNUM dt = mccSG3_end_ToF_Z_dt;
MCNUM restore_neutron = mccSG3_end_ToF_Z_restore_neutron;
int nowritefile = mccSG3_end_ToF_Z_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 76201 "./SNS_BASIS.c"
}   /* End of SG3_end_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'SG3_end_Lam'. */
  SIG_MESSAGE("SG3_end_Lam (Save)");
#define mccompcurname  SG3_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 102
#define nL mccSG3_end_Lam_nL
#define L_N mccSG3_end_Lam_L_N
#define L_p mccSG3_end_Lam_L_p
#define L_p2 mccSG3_end_Lam_L_p2
{   /* Declarations of SG3_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccSG3_end_Lam_filename;
MCNUM xmin = mccSG3_end_Lam_xmin;
MCNUM xmax = mccSG3_end_Lam_xmax;
MCNUM ymin = mccSG3_end_Lam_ymin;
MCNUM ymax = mccSG3_end_Lam_ymax;
MCNUM xwidth = mccSG3_end_Lam_xwidth;
MCNUM yheight = mccSG3_end_Lam_yheight;
MCNUM Lmin = mccSG3_end_Lam_Lmin;
MCNUM Lmax = mccSG3_end_Lam_Lmax;
MCNUM restore_neutron = mccSG3_end_Lam_restore_neutron;
int nowritefile = mccSG3_end_Lam_nowritefile;
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 76247 "./SNS_BASIS.c"
}   /* End of SG3_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'SG3_end_PSD'. */
  SIG_MESSAGE("SG3_end_PSD (Save)");
#define mccompcurname  SG3_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 103
#define PSD_N mccSG3_end_PSD_PSD_N
#define PSD_p mccSG3_end_PSD_PSD_p
#define PSD_p2 mccSG3_end_PSD_PSD_p2
{   /* Declarations of SG3_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccSG3_end_PSD_nx;
int ny = mccSG3_end_PSD_ny;
char* filename = mccSG3_end_PSD_filename;
MCNUM xmin = mccSG3_end_PSD_xmin;
MCNUM xmax = mccSG3_end_PSD_xmax;
MCNUM ymin = mccSG3_end_PSD_ymin;
MCNUM ymax = mccSG3_end_PSD_ymax;
MCNUM xwidth = mccSG3_end_PSD_xwidth;
MCNUM yheight = mccSG3_end_PSD_yheight;
MCNUM restore_neutron = mccSG3_end_PSD_restore_neutron;
#line 110 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  DETECTOR_OUT_2D(
    "PSD monitor",
    "X position [cm]",
    "Y position [cm]",
    xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
    nx, ny,
    &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
    filename);
}
#line 76287 "./SNS_BASIS.c"
}   /* End of SG3_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'PSD_post_funnel1'. */
  SIG_MESSAGE("PSD_post_funnel1 (Save)");
#define mccompcurname  PSD_post_funnel1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 105
#define PSD_N mccPSD_post_funnel1_PSD_N
#define PSD_p mccPSD_post_funnel1_PSD_p
#define PSD_p2 mccPSD_post_funnel1_PSD_p2
{   /* Declarations of PSD_post_funnel1=PSD_monitor() SETTING parameters. */
int nx = mccPSD_post_funnel1_nx;
int ny = mccPSD_post_funnel1_ny;
char* filename = mccPSD_post_funnel1_filename;
MCNUM xmin = mccPSD_post_funnel1_xmin;
MCNUM xmax = mccPSD_post_funnel1_xmax;
MCNUM ymin = mccPSD_post_funnel1_ymin;
MCNUM ymax = mccPSD_post_funnel1_ymax;
MCNUM xwidth = mccPSD_post_funnel1_xwidth;
MCNUM yheight = mccPSD_post_funnel1_yheight;
MCNUM restore_neutron = mccPSD_post_funnel1_restore_neutron;
#line 110 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  DETECTOR_OUT_2D(
    "PSD monitor",
    "X position [cm]",
    "Y position [cm]",
    xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
    nx, ny,
    &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
    filename);
}
#line 76326 "./SNS_BASIS.c"
}   /* End of PSD_post_funnel1=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'PSD_post_funnel2'. */
  SIG_MESSAGE("PSD_post_funnel2 (Save)");
#define mccompcurname  PSD_post_funnel2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 107
#define PSD_N mccPSD_post_funnel2_PSD_N
#define PSD_p mccPSD_post_funnel2_PSD_p
#define PSD_p2 mccPSD_post_funnel2_PSD_p2
{   /* Declarations of PSD_post_funnel2=PSD_monitor() SETTING parameters. */
int nx = mccPSD_post_funnel2_nx;
int ny = mccPSD_post_funnel2_ny;
char* filename = mccPSD_post_funnel2_filename;
MCNUM xmin = mccPSD_post_funnel2_xmin;
MCNUM xmax = mccPSD_post_funnel2_xmax;
MCNUM ymin = mccPSD_post_funnel2_ymin;
MCNUM ymax = mccPSD_post_funnel2_ymax;
MCNUM xwidth = mccPSD_post_funnel2_xwidth;
MCNUM yheight = mccPSD_post_funnel2_yheight;
MCNUM restore_neutron = mccPSD_post_funnel2_restore_neutron;
#line 110 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  DETECTOR_OUT_2D(
    "PSD monitor",
    "X position [cm]",
    "Y position [cm]",
    xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
    nx, ny,
    &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
    filename);
}
#line 76365 "./SNS_BASIS.c"
}   /* End of PSD_post_funnel2=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'PSD_post_funnel3'. */
  SIG_MESSAGE("PSD_post_funnel3 (Save)");
#define mccompcurname  PSD_post_funnel3
#define mccompcurtype  PSD_monitor
#define mccompcurindex 109
#define PSD_N mccPSD_post_funnel3_PSD_N
#define PSD_p mccPSD_post_funnel3_PSD_p
#define PSD_p2 mccPSD_post_funnel3_PSD_p2
{   /* Declarations of PSD_post_funnel3=PSD_monitor() SETTING parameters. */
int nx = mccPSD_post_funnel3_nx;
int ny = mccPSD_post_funnel3_ny;
char* filename = mccPSD_post_funnel3_filename;
MCNUM xmin = mccPSD_post_funnel3_xmin;
MCNUM xmax = mccPSD_post_funnel3_xmax;
MCNUM ymin = mccPSD_post_funnel3_ymin;
MCNUM ymax = mccPSD_post_funnel3_ymax;
MCNUM xwidth = mccPSD_post_funnel3_xwidth;
MCNUM yheight = mccPSD_post_funnel3_yheight;
MCNUM restore_neutron = mccPSD_post_funnel3_restore_neutron;
#line 110 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  DETECTOR_OUT_2D(
    "PSD monitor",
    "X position [cm]",
    "Y position [cm]",
    xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
    nx, ny,
    &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
    filename);
}
#line 76404 "./SNS_BASIS.c"
}   /* End of PSD_post_funnel3=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'PSD_post_funnel4'. */
  SIG_MESSAGE("PSD_post_funnel4 (Save)");
#define mccompcurname  PSD_post_funnel4
#define mccompcurtype  PSD_monitor
#define mccompcurindex 111
#define PSD_N mccPSD_post_funnel4_PSD_N
#define PSD_p mccPSD_post_funnel4_PSD_p
#define PSD_p2 mccPSD_post_funnel4_PSD_p2
{   /* Declarations of PSD_post_funnel4=PSD_monitor() SETTING parameters. */
int nx = mccPSD_post_funnel4_nx;
int ny = mccPSD_post_funnel4_ny;
char* filename = mccPSD_post_funnel4_filename;
MCNUM xmin = mccPSD_post_funnel4_xmin;
MCNUM xmax = mccPSD_post_funnel4_xmax;
MCNUM ymin = mccPSD_post_funnel4_ymin;
MCNUM ymax = mccPSD_post_funnel4_ymax;
MCNUM xwidth = mccPSD_post_funnel4_xwidth;
MCNUM yheight = mccPSD_post_funnel4_yheight;
MCNUM restore_neutron = mccPSD_post_funnel4_restore_neutron;
#line 110 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  DETECTOR_OUT_2D(
    "PSD monitor",
    "X position [cm]",
    "Y position [cm]",
    xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
    nx, ny,
    &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
    filename);
}
#line 76443 "./SNS_BASIS.c"
}   /* End of PSD_post_funnel4=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Guide_End_ToF'. */
  SIG_MESSAGE("Guide_End_ToF (Save)");
#define mccompcurname  Guide_End_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 112
#define nt mccGuide_End_ToF_nt
#define TOF_N mccGuide_End_ToF_TOF_N
#define TOF_p mccGuide_End_ToF_TOF_p
#define TOF_p2 mccGuide_End_ToF_TOF_p2
#define t_min mccGuide_End_ToF_t_min
#define t_max mccGuide_End_ToF_t_max
#define delta_t mccGuide_End_ToF_delta_t
{   /* Declarations of Guide_End_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccGuide_End_ToF_filename;
MCNUM xmin = mccGuide_End_ToF_xmin;
MCNUM xmax = mccGuide_End_ToF_xmax;
MCNUM ymin = mccGuide_End_ToF_ymin;
MCNUM ymax = mccGuide_End_ToF_ymax;
MCNUM xwidth = mccGuide_End_ToF_xwidth;
MCNUM yheight = mccGuide_End_ToF_yheight;
MCNUM tmin = mccGuide_End_ToF_tmin;
MCNUM tmax = mccGuide_End_ToF_tmax;
MCNUM dt = mccGuide_End_ToF_dt;
MCNUM restore_neutron = mccGuide_End_ToF_restore_neutron;
int nowritefile = mccGuide_End_ToF_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 76489 "./SNS_BASIS.c"
}   /* End of Guide_End_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Guide_End_ToF_Z'. */
  SIG_MESSAGE("Guide_End_ToF_Z (Save)");
#define mccompcurname  Guide_End_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 113
#define nt mccGuide_End_ToF_Z_nt
#define TOF_N mccGuide_End_ToF_Z_TOF_N
#define TOF_p mccGuide_End_ToF_Z_TOF_p
#define TOF_p2 mccGuide_End_ToF_Z_TOF_p2
#define t_min mccGuide_End_ToF_Z_t_min
#define t_max mccGuide_End_ToF_Z_t_max
#define delta_t mccGuide_End_ToF_Z_delta_t
{   /* Declarations of Guide_End_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccGuide_End_ToF_Z_filename;
MCNUM xmin = mccGuide_End_ToF_Z_xmin;
MCNUM xmax = mccGuide_End_ToF_Z_xmax;
MCNUM ymin = mccGuide_End_ToF_Z_ymin;
MCNUM ymax = mccGuide_End_ToF_Z_ymax;
MCNUM xwidth = mccGuide_End_ToF_Z_xwidth;
MCNUM yheight = mccGuide_End_ToF_Z_yheight;
MCNUM tmin = mccGuide_End_ToF_Z_tmin;
MCNUM tmax = mccGuide_End_ToF_Z_tmax;
MCNUM dt = mccGuide_End_ToF_Z_dt;
MCNUM restore_neutron = mccGuide_End_ToF_Z_restore_neutron;
int nowritefile = mccGuide_End_ToF_Z_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 76539 "./SNS_BASIS.c"
}   /* End of Guide_End_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Guide_end_Lam'. */
  SIG_MESSAGE("Guide_end_Lam (Save)");
#define mccompcurname  Guide_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 114
#define nL mccGuide_end_Lam_nL
#define L_N mccGuide_end_Lam_L_N
#define L_p mccGuide_end_Lam_L_p
#define L_p2 mccGuide_end_Lam_L_p2
{   /* Declarations of Guide_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccGuide_end_Lam_filename;
MCNUM xmin = mccGuide_end_Lam_xmin;
MCNUM xmax = mccGuide_end_Lam_xmax;
MCNUM ymin = mccGuide_end_Lam_ymin;
MCNUM ymax = mccGuide_end_Lam_ymax;
MCNUM xwidth = mccGuide_end_Lam_xwidth;
MCNUM yheight = mccGuide_end_Lam_yheight;
MCNUM Lmin = mccGuide_end_Lam_Lmin;
MCNUM Lmax = mccGuide_end_Lam_Lmax;
MCNUM restore_neutron = mccGuide_end_Lam_restore_neutron;
int nowritefile = mccGuide_end_Lam_nowritefile;
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 76585 "./SNS_BASIS.c"
}   /* End of Guide_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Guide_end_divx'. */
  SIG_MESSAGE("Guide_end_divx (Save)");
#define mccompcurname  Guide_end_divx
#define mccompcurtype  Monitor_nD
#define mccompcurindex 115
#define user1 mccGuide_end_divx_user1
#define user2 mccGuide_end_divx_user2
#define user3 mccGuide_end_divx_user3
#define DEFS mccGuide_end_divx_DEFS
#define Vars mccGuide_end_divx_Vars
#define detector mccGuide_end_divx_detector
#define offdata mccGuide_end_divx_offdata
{   /* Declarations of Guide_end_divx=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccGuide_end_divx_xwidth;
MCNUM yheight = mccGuide_end_divx_yheight;
MCNUM zdepth = mccGuide_end_divx_zdepth;
MCNUM xmin = mccGuide_end_divx_xmin;
MCNUM xmax = mccGuide_end_divx_xmax;
MCNUM ymin = mccGuide_end_divx_ymin;
MCNUM ymax = mccGuide_end_divx_ymax;
MCNUM zmin = mccGuide_end_divx_zmin;
MCNUM zmax = mccGuide_end_divx_zmax;
MCNUM bins = mccGuide_end_divx_bins;
MCNUM min = mccGuide_end_divx_min;
MCNUM max = mccGuide_end_divx_max;
MCNUM restore_neutron = mccGuide_end_divx_restore_neutron;
MCNUM radius = mccGuide_end_divx_radius;
char* options = mccGuide_end_divx_options;
char* filename = mccGuide_end_divx_filename;
char* geometry = mccGuide_end_divx_geometry;
char* username1 = mccGuide_end_divx_username1;
char* username2 = mccGuide_end_divx_username2;
char* username3 = mccGuide_end_divx_username3;
int nowritefile = mccGuide_end_divx_nowritefile;
#line 481 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  /* save results, but do not free pointers */
  if (!nowritefile) {
    detector = Monitor_nD_Save(&DEFS, &Vars);
  }
}
#line 76636 "./SNS_BASIS.c"
}   /* End of Guide_end_divx=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Guide_end_divy'. */
  SIG_MESSAGE("Guide_end_divy (Save)");
#define mccompcurname  Guide_end_divy
#define mccompcurtype  Monitor_nD
#define mccompcurindex 116
#define user1 mccGuide_end_divy_user1
#define user2 mccGuide_end_divy_user2
#define user3 mccGuide_end_divy_user3
#define DEFS mccGuide_end_divy_DEFS
#define Vars mccGuide_end_divy_Vars
#define detector mccGuide_end_divy_detector
#define offdata mccGuide_end_divy_offdata
{   /* Declarations of Guide_end_divy=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccGuide_end_divy_xwidth;
MCNUM yheight = mccGuide_end_divy_yheight;
MCNUM zdepth = mccGuide_end_divy_zdepth;
MCNUM xmin = mccGuide_end_divy_xmin;
MCNUM xmax = mccGuide_end_divy_xmax;
MCNUM ymin = mccGuide_end_divy_ymin;
MCNUM ymax = mccGuide_end_divy_ymax;
MCNUM zmin = mccGuide_end_divy_zmin;
MCNUM zmax = mccGuide_end_divy_zmax;
MCNUM bins = mccGuide_end_divy_bins;
MCNUM min = mccGuide_end_divy_min;
MCNUM max = mccGuide_end_divy_max;
MCNUM restore_neutron = mccGuide_end_divy_restore_neutron;
MCNUM radius = mccGuide_end_divy_radius;
char* options = mccGuide_end_divy_options;
char* filename = mccGuide_end_divy_filename;
char* geometry = mccGuide_end_divy_geometry;
char* username1 = mccGuide_end_divy_username1;
char* username2 = mccGuide_end_divy_username2;
char* username3 = mccGuide_end_divy_username3;
int nowritefile = mccGuide_end_divy_nowritefile;
#line 481 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  /* save results, but do not free pointers */
  if (!nowritefile) {
    detector = Monitor_nD_Save(&DEFS, &Vars);
  }
}
#line 76690 "./SNS_BASIS.c"
}   /* End of Guide_end_divy=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Guide_end_PSD'. */
  SIG_MESSAGE("Guide_end_PSD (Save)");
#define mccompcurname  Guide_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 117
#define PSD_N mccGuide_end_PSD_PSD_N
#define PSD_p mccGuide_end_PSD_PSD_p
#define PSD_p2 mccGuide_end_PSD_PSD_p2
{   /* Declarations of Guide_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGuide_end_PSD_nx;
int ny = mccGuide_end_PSD_ny;
char* filename = mccGuide_end_PSD_filename;
MCNUM xmin = mccGuide_end_PSD_xmin;
MCNUM xmax = mccGuide_end_PSD_xmax;
MCNUM ymin = mccGuide_end_PSD_ymin;
MCNUM ymax = mccGuide_end_PSD_ymax;
MCNUM xwidth = mccGuide_end_PSD_xwidth;
MCNUM yheight = mccGuide_end_PSD_yheight;
MCNUM restore_neutron = mccGuide_end_PSD_restore_neutron;
#line 110 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  DETECTOR_OUT_2D(
    "PSD monitor",
    "X position [cm]",
    "Y position [cm]",
    xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
    nx, ny,
    &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
    filename);
}
#line 76733 "./SNS_BASIS.c"
}   /* End of Guide_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'SamplePos'. */
  SIG_MESSAGE("SamplePos (Save)");
#define mccompcurname  SamplePos
#define mccompcurtype  PSD_monitor
#define mccompcurindex 119
#define PSD_N mccSamplePos_PSD_N
#define PSD_p mccSamplePos_PSD_p
#define PSD_p2 mccSamplePos_PSD_p2
{   /* Declarations of SamplePos=PSD_monitor() SETTING parameters. */
int nx = mccSamplePos_nx;
int ny = mccSamplePos_ny;
char* filename = mccSamplePos_filename;
MCNUM xmin = mccSamplePos_xmin;
MCNUM xmax = mccSamplePos_xmax;
MCNUM ymin = mccSamplePos_ymin;
MCNUM ymax = mccSamplePos_ymax;
MCNUM xwidth = mccSamplePos_xwidth;
MCNUM yheight = mccSamplePos_yheight;
MCNUM restore_neutron = mccSamplePos_restore_neutron;
#line 110 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  DETECTOR_OUT_2D(
    "PSD monitor",
    "X position [cm]",
    "Y position [cm]",
    xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
    nx, ny,
    &PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
    filename);
}
#line 76772 "./SNS_BASIS.c"
}   /* End of SamplePos=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'An1_ToF'. */
  SIG_MESSAGE("An1_ToF (Save)");
#define mccompcurname  An1_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 124
#define nt mccAn1_ToF_nt
#define TOF_N mccAn1_ToF_TOF_N
#define TOF_p mccAn1_ToF_TOF_p
#define TOF_p2 mccAn1_ToF_TOF_p2
#define t_min mccAn1_ToF_t_min
#define t_max mccAn1_ToF_t_max
#define delta_t mccAn1_ToF_delta_t
{   /* Declarations of An1_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccAn1_ToF_filename;
MCNUM xmin = mccAn1_ToF_xmin;
MCNUM xmax = mccAn1_ToF_xmax;
MCNUM ymin = mccAn1_ToF_ymin;
MCNUM ymax = mccAn1_ToF_ymax;
MCNUM xwidth = mccAn1_ToF_xwidth;
MCNUM yheight = mccAn1_ToF_yheight;
MCNUM tmin = mccAn1_ToF_tmin;
MCNUM tmax = mccAn1_ToF_tmax;
MCNUM dt = mccAn1_ToF_dt;
MCNUM restore_neutron = mccAn1_ToF_restore_neutron;
int nowritefile = mccAn1_ToF_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 76818 "./SNS_BASIS.c"
}   /* End of An1_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'An1_ToF_variable_range'. */
  SIG_MESSAGE("An1_ToF_variable_range (Save)");
#define mccompcurname  An1_ToF_variable_range
#define mccompcurtype  TOF_monitor
#define mccompcurindex 125
#define nt mccAn1_ToF_variable_range_nt
#define TOF_N mccAn1_ToF_variable_range_TOF_N
#define TOF_p mccAn1_ToF_variable_range_TOF_p
#define TOF_p2 mccAn1_ToF_variable_range_TOF_p2
#define t_min mccAn1_ToF_variable_range_t_min
#define t_max mccAn1_ToF_variable_range_t_max
#define delta_t mccAn1_ToF_variable_range_delta_t
{   /* Declarations of An1_ToF_variable_range=TOF_monitor() SETTING parameters. */
char* filename = mccAn1_ToF_variable_range_filename;
MCNUM xmin = mccAn1_ToF_variable_range_xmin;
MCNUM xmax = mccAn1_ToF_variable_range_xmax;
MCNUM ymin = mccAn1_ToF_variable_range_ymin;
MCNUM ymax = mccAn1_ToF_variable_range_ymax;
MCNUM xwidth = mccAn1_ToF_variable_range_xwidth;
MCNUM yheight = mccAn1_ToF_variable_range_yheight;
MCNUM tmin = mccAn1_ToF_variable_range_tmin;
MCNUM tmax = mccAn1_ToF_variable_range_tmax;
MCNUM dt = mccAn1_ToF_variable_range_dt;
MCNUM restore_neutron = mccAn1_ToF_variable_range_restore_neutron;
int nowritefile = mccAn1_ToF_variable_range_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 76868 "./SNS_BASIS.c"
}   /* End of An1_ToF_variable_range=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'An1_Lam'. */
  SIG_MESSAGE("An1_Lam (Save)");
#define mccompcurname  An1_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 126
#define nL mccAn1_Lam_nL
#define L_N mccAn1_Lam_L_N
#define L_p mccAn1_Lam_L_p
#define L_p2 mccAn1_Lam_L_p2
{   /* Declarations of An1_Lam=L_monitor() SETTING parameters. */
char* filename = mccAn1_Lam_filename;
MCNUM xmin = mccAn1_Lam_xmin;
MCNUM xmax = mccAn1_Lam_xmax;
MCNUM ymin = mccAn1_Lam_ymin;
MCNUM ymax = mccAn1_Lam_ymax;
MCNUM xwidth = mccAn1_Lam_xwidth;
MCNUM yheight = mccAn1_Lam_yheight;
MCNUM Lmin = mccAn1_Lam_Lmin;
MCNUM Lmax = mccAn1_Lam_Lmax;
MCNUM restore_neutron = mccAn1_Lam_restore_neutron;
int nowritefile = mccAn1_Lam_nowritefile;
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 76914 "./SNS_BASIS.c"
}   /* End of An1_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'An1_Lam_variable_range'. */
  SIG_MESSAGE("An1_Lam_variable_range (Save)");
#define mccompcurname  An1_Lam_variable_range
#define mccompcurtype  L_monitor
#define mccompcurindex 127
#define nL mccAn1_Lam_variable_range_nL
#define L_N mccAn1_Lam_variable_range_L_N
#define L_p mccAn1_Lam_variable_range_L_p
#define L_p2 mccAn1_Lam_variable_range_L_p2
{   /* Declarations of An1_Lam_variable_range=L_monitor() SETTING parameters. */
char* filename = mccAn1_Lam_variable_range_filename;
MCNUM xmin = mccAn1_Lam_variable_range_xmin;
MCNUM xmax = mccAn1_Lam_variable_range_xmax;
MCNUM ymin = mccAn1_Lam_variable_range_ymin;
MCNUM ymax = mccAn1_Lam_variable_range_ymax;
MCNUM xwidth = mccAn1_Lam_variable_range_xwidth;
MCNUM yheight = mccAn1_Lam_variable_range_yheight;
MCNUM Lmin = mccAn1_Lam_variable_range_Lmin;
MCNUM Lmax = mccAn1_Lam_variable_range_Lmax;
MCNUM restore_neutron = mccAn1_Lam_variable_range_restore_neutron;
int nowritefile = mccAn1_Lam_variable_range_nowritefile;
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 76957 "./SNS_BASIS.c"
}   /* End of An1_Lam_variable_range=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'An1_E'. */
  SIG_MESSAGE("An1_E (Save)");
#define mccompcurname  An1_E
#define mccompcurtype  E_monitor
#define mccompcurindex 128
#define nE mccAn1_E_nE
#define E_N mccAn1_E_E_N
#define E_p mccAn1_E_E_p
#define E_p2 mccAn1_E_E_p2
#define S_p mccAn1_E_S_p
#define S_pE mccAn1_E_S_pE
#define S_pE2 mccAn1_E_S_pE2
{   /* Declarations of An1_E=E_monitor() SETTING parameters. */
char* filename = mccAn1_E_filename;
MCNUM xmin = mccAn1_E_xmin;
MCNUM xmax = mccAn1_E_xmax;
MCNUM ymin = mccAn1_E_ymin;
MCNUM ymax = mccAn1_E_ymax;
MCNUM xwidth = mccAn1_E_xwidth;
MCNUM yheight = mccAn1_E_yheight;
MCNUM Emin = mccAn1_E_Emin;
MCNUM Emax = mccAn1_E_Emax;
MCNUM restore_neutron = mccAn1_E_restore_neutron;
int nowritefile = mccAn1_E_nowritefile;
#line 117 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [meV]",
        "Intensity",
        "E", Emin, Emax, nE,
        &E_N[0],&E_p[0],&E_p2[0],
        filename);
    if (S_p) printf("<E> : %g meV , E-width : %g meV \n",
     S_pE/S_p,sqrt(S_pE2/S_p - S_pE*S_pE/(S_p*S_p)) );
    }
}
#line 77005 "./SNS_BASIS.c"
}   /* End of An1_E=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'An1_E_variable_range'. */
  SIG_MESSAGE("An1_E_variable_range (Save)");
#define mccompcurname  An1_E_variable_range
#define mccompcurtype  E_monitor
#define mccompcurindex 129
#define nE mccAn1_E_variable_range_nE
#define E_N mccAn1_E_variable_range_E_N
#define E_p mccAn1_E_variable_range_E_p
#define E_p2 mccAn1_E_variable_range_E_p2
#define S_p mccAn1_E_variable_range_S_p
#define S_pE mccAn1_E_variable_range_S_pE
#define S_pE2 mccAn1_E_variable_range_S_pE2
{   /* Declarations of An1_E_variable_range=E_monitor() SETTING parameters. */
char* filename = mccAn1_E_variable_range_filename;
MCNUM xmin = mccAn1_E_variable_range_xmin;
MCNUM xmax = mccAn1_E_variable_range_xmax;
MCNUM ymin = mccAn1_E_variable_range_ymin;
MCNUM ymax = mccAn1_E_variable_range_ymax;
MCNUM xwidth = mccAn1_E_variable_range_xwidth;
MCNUM yheight = mccAn1_E_variable_range_yheight;
MCNUM Emin = mccAn1_E_variable_range_Emin;
MCNUM Emax = mccAn1_E_variable_range_Emax;
MCNUM restore_neutron = mccAn1_E_variable_range_restore_neutron;
int nowritefile = mccAn1_E_variable_range_nowritefile;
#line 117 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [meV]",
        "Intensity",
        "E", Emin, Emax, nE,
        &E_N[0],&E_p[0],&E_p2[0],
        filename);
    if (S_p) printf("<E> : %g meV , E-width : %g meV \n",
     S_pE/S_p,sqrt(S_pE2/S_p - S_pE*S_pE/(S_p*S_p)) );
    }
}
#line 77056 "./SNS_BASIS.c"
}   /* End of An1_E_variable_range=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Det1_E'. */
  SIG_MESSAGE("Det1_E (Save)");
#define mccompcurname  Det1_E
#define mccompcurtype  E_monitor
#define mccompcurindex 137
#define nE mccDet1_E_nE
#define E_N mccDet1_E_E_N
#define E_p mccDet1_E_E_p
#define E_p2 mccDet1_E_E_p2
#define S_p mccDet1_E_S_p
#define S_pE mccDet1_E_S_pE
#define S_pE2 mccDet1_E_S_pE2
{   /* Declarations of Det1_E=E_monitor() SETTING parameters. */
char* filename = mccDet1_E_filename;
MCNUM xmin = mccDet1_E_xmin;
MCNUM xmax = mccDet1_E_xmax;
MCNUM ymin = mccDet1_E_ymin;
MCNUM ymax = mccDet1_E_ymax;
MCNUM xwidth = mccDet1_E_xwidth;
MCNUM yheight = mccDet1_E_yheight;
MCNUM Emin = mccDet1_E_Emin;
MCNUM Emax = mccDet1_E_Emax;
MCNUM restore_neutron = mccDet1_E_restore_neutron;
int nowritefile = mccDet1_E_nowritefile;
#line 117 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [meV]",
        "Intensity",
        "E", Emin, Emax, nE,
        &E_N[0],&E_p[0],&E_p2[0],
        filename);
    if (S_p) printf("<E> : %g meV , E-width : %g meV \n",
     S_pE/S_p,sqrt(S_pE2/S_p - S_pE*S_pE/(S_p*S_p)) );
    }
}
#line 77107 "./SNS_BASIS.c"
}   /* End of Det1_E=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Det1_E_variable_range'. */
  SIG_MESSAGE("Det1_E_variable_range (Save)");
#define mccompcurname  Det1_E_variable_range
#define mccompcurtype  E_monitor
#define mccompcurindex 138
#define nE mccDet1_E_variable_range_nE
#define E_N mccDet1_E_variable_range_E_N
#define E_p mccDet1_E_variable_range_E_p
#define E_p2 mccDet1_E_variable_range_E_p2
#define S_p mccDet1_E_variable_range_S_p
#define S_pE mccDet1_E_variable_range_S_pE
#define S_pE2 mccDet1_E_variable_range_S_pE2
{   /* Declarations of Det1_E_variable_range=E_monitor() SETTING parameters. */
char* filename = mccDet1_E_variable_range_filename;
MCNUM xmin = mccDet1_E_variable_range_xmin;
MCNUM xmax = mccDet1_E_variable_range_xmax;
MCNUM ymin = mccDet1_E_variable_range_ymin;
MCNUM ymax = mccDet1_E_variable_range_ymax;
MCNUM xwidth = mccDet1_E_variable_range_xwidth;
MCNUM yheight = mccDet1_E_variable_range_yheight;
MCNUM Emin = mccDet1_E_variable_range_Emin;
MCNUM Emax = mccDet1_E_variable_range_Emax;
MCNUM restore_neutron = mccDet1_E_variable_range_restore_neutron;
int nowritefile = mccDet1_E_variable_range_nowritefile;
#line 117 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [meV]",
        "Intensity",
        "E", Emin, Emax, nE,
        &E_N[0],&E_p[0],&E_p2[0],
        filename);
    if (S_p) printf("<E> : %g meV , E-width : %g meV \n",
     S_pE/S_p,sqrt(S_pE2/S_p - S_pE*S_pE/(S_p*S_p)) );
    }
}
#line 77158 "./SNS_BASIS.c"
}   /* End of Det1_E_variable_range=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Det1_Lam'. */
  SIG_MESSAGE("Det1_Lam (Save)");
#define mccompcurname  Det1_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 139
#define nL mccDet1_Lam_nL
#define L_N mccDet1_Lam_L_N
#define L_p mccDet1_Lam_L_p
#define L_p2 mccDet1_Lam_L_p2
{   /* Declarations of Det1_Lam=L_monitor() SETTING parameters. */
char* filename = mccDet1_Lam_filename;
MCNUM xmin = mccDet1_Lam_xmin;
MCNUM xmax = mccDet1_Lam_xmax;
MCNUM ymin = mccDet1_Lam_ymin;
MCNUM ymax = mccDet1_Lam_ymax;
MCNUM xwidth = mccDet1_Lam_xwidth;
MCNUM yheight = mccDet1_Lam_yheight;
MCNUM Lmin = mccDet1_Lam_Lmin;
MCNUM Lmax = mccDet1_Lam_Lmax;
MCNUM restore_neutron = mccDet1_Lam_restore_neutron;
int nowritefile = mccDet1_Lam_nowritefile;
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 77204 "./SNS_BASIS.c"
}   /* End of Det1_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Det1_Lam_variable_range'. */
  SIG_MESSAGE("Det1_Lam_variable_range (Save)");
#define mccompcurname  Det1_Lam_variable_range
#define mccompcurtype  L_monitor
#define mccompcurindex 140
#define nL mccDet1_Lam_variable_range_nL
#define L_N mccDet1_Lam_variable_range_L_N
#define L_p mccDet1_Lam_variable_range_L_p
#define L_p2 mccDet1_Lam_variable_range_L_p2
{   /* Declarations of Det1_Lam_variable_range=L_monitor() SETTING parameters. */
char* filename = mccDet1_Lam_variable_range_filename;
MCNUM xmin = mccDet1_Lam_variable_range_xmin;
MCNUM xmax = mccDet1_Lam_variable_range_xmax;
MCNUM ymin = mccDet1_Lam_variable_range_ymin;
MCNUM ymax = mccDet1_Lam_variable_range_ymax;
MCNUM xwidth = mccDet1_Lam_variable_range_xwidth;
MCNUM yheight = mccDet1_Lam_variable_range_yheight;
MCNUM Lmin = mccDet1_Lam_variable_range_Lmin;
MCNUM Lmax = mccDet1_Lam_variable_range_Lmax;
MCNUM restore_neutron = mccDet1_Lam_variable_range_restore_neutron;
int nowritefile = mccDet1_Lam_variable_range_nowritefile;
#line 107 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Wavelength monitor",
        "Wavelength [AA]",
        "Intensity",
        "L", Lmin, Lmax, nL,
        &L_N[0],&L_p[0],&L_p2[0],
        filename);
    }
}
#line 77247 "./SNS_BASIS.c"
}   /* End of Det1_Lam_variable_range=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Det1_ToF'. */
  SIG_MESSAGE("Det1_ToF (Save)");
#define mccompcurname  Det1_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 141
#define nt mccDet1_ToF_nt
#define TOF_N mccDet1_ToF_TOF_N
#define TOF_p mccDet1_ToF_TOF_p
#define TOF_p2 mccDet1_ToF_TOF_p2
#define t_min mccDet1_ToF_t_min
#define t_max mccDet1_ToF_t_max
#define delta_t mccDet1_ToF_delta_t
{   /* Declarations of Det1_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccDet1_ToF_filename;
MCNUM xmin = mccDet1_ToF_xmin;
MCNUM xmax = mccDet1_ToF_xmax;
MCNUM ymin = mccDet1_ToF_ymin;
MCNUM ymax = mccDet1_ToF_ymax;
MCNUM xwidth = mccDet1_ToF_xwidth;
MCNUM yheight = mccDet1_ToF_yheight;
MCNUM tmin = mccDet1_ToF_tmin;
MCNUM tmax = mccDet1_ToF_tmax;
MCNUM dt = mccDet1_ToF_dt;
MCNUM restore_neutron = mccDet1_ToF_restore_neutron;
int nowritefile = mccDet1_ToF_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 77294 "./SNS_BASIS.c"
}   /* End of Det1_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Det1_ToF_variable_range'. */
  SIG_MESSAGE("Det1_ToF_variable_range (Save)");
#define mccompcurname  Det1_ToF_variable_range
#define mccompcurtype  TOF_monitor
#define mccompcurindex 142
#define nt mccDet1_ToF_variable_range_nt
#define TOF_N mccDet1_ToF_variable_range_TOF_N
#define TOF_p mccDet1_ToF_variable_range_TOF_p
#define TOF_p2 mccDet1_ToF_variable_range_TOF_p2
#define t_min mccDet1_ToF_variable_range_t_min
#define t_max mccDet1_ToF_variable_range_t_max
#define delta_t mccDet1_ToF_variable_range_delta_t
{   /* Declarations of Det1_ToF_variable_range=TOF_monitor() SETTING parameters. */
char* filename = mccDet1_ToF_variable_range_filename;
MCNUM xmin = mccDet1_ToF_variable_range_xmin;
MCNUM xmax = mccDet1_ToF_variable_range_xmax;
MCNUM ymin = mccDet1_ToF_variable_range_ymin;
MCNUM ymax = mccDet1_ToF_variable_range_ymax;
MCNUM xwidth = mccDet1_ToF_variable_range_xwidth;
MCNUM yheight = mccDet1_ToF_variable_range_yheight;
MCNUM tmin = mccDet1_ToF_variable_range_tmin;
MCNUM tmax = mccDet1_ToF_variable_range_tmax;
MCNUM dt = mccDet1_ToF_variable_range_dt;
MCNUM restore_neutron = mccDet1_ToF_variable_range_restore_neutron;
int nowritefile = mccDet1_ToF_variable_range_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 77344 "./SNS_BASIS.c"
}   /* End of Det1_ToF_variable_range=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Det1_ToF_variable_range_lessnL'. */
  SIG_MESSAGE("Det1_ToF_variable_range_lessnL (Save)");
#define mccompcurname  Det1_ToF_variable_range_lessnL
#define mccompcurtype  TOF_monitor
#define mccompcurindex 143
#define nt mccDet1_ToF_variable_range_lessnL_nt
#define TOF_N mccDet1_ToF_variable_range_lessnL_TOF_N
#define TOF_p mccDet1_ToF_variable_range_lessnL_TOF_p
#define TOF_p2 mccDet1_ToF_variable_range_lessnL_TOF_p2
#define t_min mccDet1_ToF_variable_range_lessnL_t_min
#define t_max mccDet1_ToF_variable_range_lessnL_t_max
#define delta_t mccDet1_ToF_variable_range_lessnL_delta_t
{   /* Declarations of Det1_ToF_variable_range_lessnL=TOF_monitor() SETTING parameters. */
char* filename = mccDet1_ToF_variable_range_lessnL_filename;
MCNUM xmin = mccDet1_ToF_variable_range_lessnL_xmin;
MCNUM xmax = mccDet1_ToF_variable_range_lessnL_xmax;
MCNUM ymin = mccDet1_ToF_variable_range_lessnL_ymin;
MCNUM ymax = mccDet1_ToF_variable_range_lessnL_ymax;
MCNUM xwidth = mccDet1_ToF_variable_range_lessnL_xwidth;
MCNUM yheight = mccDet1_ToF_variable_range_lessnL_yheight;
MCNUM tmin = mccDet1_ToF_variable_range_lessnL_tmin;
MCNUM tmax = mccDet1_ToF_variable_range_lessnL_tmax;
MCNUM dt = mccDet1_ToF_variable_range_lessnL_dt;
MCNUM restore_neutron = mccDet1_ToF_variable_range_lessnL_restore_neutron;
int nowritefile = mccDet1_ToF_variable_range_lessnL_nowritefile;
#line 115 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
    if (!nowritefile) {
    DETECTOR_OUT_1D(
        "Time-of-flight monitor",
        "Time-of-flight [\\gms]",
        "Intensity",
        "t", t_min, t_max, nt,
        &TOF_N[0],&TOF_p[0],&TOF_p2[0],
        filename);
    }
}
#line 77394 "./SNS_BASIS.c"
}   /* End of Det1_ToF_variable_range_lessnL=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'PSDcyl'. */
  SIG_MESSAGE("PSDcyl (Save)");
#define mccompcurname  PSDcyl
#define mccompcurtype  Monitor_nD
#define mccompcurindex 144
#define user1 mccPSDcyl_user1
#define user2 mccPSDcyl_user2
#define user3 mccPSDcyl_user3
#define DEFS mccPSDcyl_DEFS
#define Vars mccPSDcyl_Vars
#define detector mccPSDcyl_detector
#define offdata mccPSDcyl_offdata
{   /* Declarations of PSDcyl=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccPSDcyl_xwidth;
MCNUM yheight = mccPSDcyl_yheight;
MCNUM zdepth = mccPSDcyl_zdepth;
MCNUM xmin = mccPSDcyl_xmin;
MCNUM xmax = mccPSDcyl_xmax;
MCNUM ymin = mccPSDcyl_ymin;
MCNUM ymax = mccPSDcyl_ymax;
MCNUM zmin = mccPSDcyl_zmin;
MCNUM zmax = mccPSDcyl_zmax;
MCNUM bins = mccPSDcyl_bins;
MCNUM min = mccPSDcyl_min;
MCNUM max = mccPSDcyl_max;
MCNUM restore_neutron = mccPSDcyl_restore_neutron;
MCNUM radius = mccPSDcyl_radius;
char* options = mccPSDcyl_options;
char* filename = mccPSDcyl_filename;
char* geometry = mccPSDcyl_geometry;
char* username1 = mccPSDcyl_username1;
char* username2 = mccPSDcyl_username2;
char* username3 = mccPSDcyl_username3;
int nowritefile = mccPSDcyl_nowritefile;
#line 481 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  /* save results, but do not free pointers */
  if (!nowritefile) {
    detector = Monitor_nD_Save(&DEFS, &Vars);
  }
}
#line 77448 "./SNS_BASIS.c"
}   /* End of PSDcyl=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'TOFcyl'. */
  SIG_MESSAGE("TOFcyl (Save)");
#define mccompcurname  TOFcyl
#define mccompcurtype  Monitor_nD
#define mccompcurindex 145
#define user1 mccTOFcyl_user1
#define user2 mccTOFcyl_user2
#define user3 mccTOFcyl_user3
#define DEFS mccTOFcyl_DEFS
#define Vars mccTOFcyl_Vars
#define detector mccTOFcyl_detector
#define offdata mccTOFcyl_offdata
{   /* Declarations of TOFcyl=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccTOFcyl_xwidth;
MCNUM yheight = mccTOFcyl_yheight;
MCNUM zdepth = mccTOFcyl_zdepth;
MCNUM xmin = mccTOFcyl_xmin;
MCNUM xmax = mccTOFcyl_xmax;
MCNUM ymin = mccTOFcyl_ymin;
MCNUM ymax = mccTOFcyl_ymax;
MCNUM zmin = mccTOFcyl_zmin;
MCNUM zmax = mccTOFcyl_zmax;
MCNUM bins = mccTOFcyl_bins;
MCNUM min = mccTOFcyl_min;
MCNUM max = mccTOFcyl_max;
MCNUM restore_neutron = mccTOFcyl_restore_neutron;
MCNUM radius = mccTOFcyl_radius;
char* options = mccTOFcyl_options;
char* filename = mccTOFcyl_filename;
char* geometry = mccTOFcyl_geometry;
char* username1 = mccTOFcyl_username1;
char* username2 = mccTOFcyl_username2;
char* username3 = mccTOFcyl_username3;
int nowritefile = mccTOFcyl_nowritefile;
#line 481 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  /* save results, but do not free pointers */
  if (!nowritefile) {
    detector = Monitor_nD_Save(&DEFS, &Vars);
  }
}
#line 77502 "./SNS_BASIS.c"
}   /* End of TOFcyl=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  if (!handle) mcsiminfo_close(); 
} /* end save */
void mcfinally(void) {
  /* User component FINALLY code. */
  mcsiminfo_init(NULL);
  mcsave(mcsiminfo_file); /* save data when simulation ends */

  /* User FINALLY code for component 'Origin'. */
  SIG_MESSAGE("Origin (Finally)");
#define mccompcurname  Origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccOrigin_IntermediateCnts
#define StartTime mccOrigin_StartTime
#define EndTime mccOrigin_EndTime
#define CurrentTime mccOrigin_CurrentTime
{   /* Declarations of Origin=Progress_bar() SETTING parameters. */
char* profile = mccOrigin_profile;
MCNUM percent = mccOrigin_percent;
MCNUM flag_save = mccOrigin_flag_save;
MCNUM minutes = mccOrigin_minutes;
#line 133 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../misc/Progress_bar.comp"
{
  time_t NowTime;
  time(&NowTime);
  fprintf(stdout, "\nFinally [%s: %s]. Time: ", mcinstrument_name, mcdirname ? mcdirname : ".");
  if (difftime(NowTime,StartTime) < 60.0)
    fprintf(stdout, "%g [s] ", difftime(NowTime,StartTime));
  else if (difftime(NowTime,StartTime) > 3600.0)
    fprintf(stdout, "%g [h] ", difftime(NowTime,StartTime)/3660.0);
  else
    fprintf(stdout, "%g [min] ", difftime(NowTime,StartTime)/60.0);
  fprintf(stdout, "\n");
}
#line 77549 "./SNS_BASIS.c"
}   /* End of Origin=Progress_bar() SETTING parameter declarations. */
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[1]) fprintf(stderr, "Warning: No neutron could reach Component[1] Origin\n");
    if (mcAbsorbProp[1]) fprintf(stderr, "Warning: %g events were removed in Component[1] Origin=Progress_bar()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[1]);
    if (!mcNCounter[2]) fprintf(stderr, "Warning: No neutron could reach Component[2] Source\n");
    if (mcAbsorbProp[2]) fprintf(stderr, "Warning: %g events were removed in Component[2] Source=ESS_moderator_short()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[2]);
    if (!mcNCounter[3]) fprintf(stderr, "Warning: No neutron could reach Component[3] tofSTART\n");
    if (mcAbsorbProp[3]) fprintf(stderr, "Warning: %g events were removed in Component[3] tofSTART=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[3]);
    if (!mcNCounter[4]) fprintf(stderr, "Warning: No neutron could reach Component[4] Source_Lam\n");
    if (mcAbsorbProp[4]) fprintf(stderr, "Warning: %g events were removed in Component[4] Source_Lam=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[4]);
    if (!mcNCounter[5]) fprintf(stderr, "Warning: No neutron could reach Component[5] Source_En\n");
    if (mcAbsorbProp[5]) fprintf(stderr, "Warning: %g events were removed in Component[5] Source_En=E_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[5]);
  /* User FINALLY code for component 'Gap0_start'. */
  SIG_MESSAGE("Gap0_start (Finally)");
#define mccompcurname  Gap0_start
#define mccompcurtype  PSD_monitor
#define mccompcurindex 6
#define PSD_N mccGap0_start_PSD_N
#define PSD_p mccGap0_start_PSD_p
#define PSD_p2 mccGap0_start_PSD_p2
{   /* Declarations of Gap0_start=PSD_monitor() SETTING parameters. */
int nx = mccGap0_start_nx;
int ny = mccGap0_start_ny;
char* filename = mccGap0_start_filename;
MCNUM xmin = mccGap0_start_xmin;
MCNUM xmax = mccGap0_start_xmax;
MCNUM ymin = mccGap0_start_ymin;
MCNUM ymax = mccGap0_start_ymax;
MCNUM xwidth = mccGap0_start_xwidth;
MCNUM yheight = mccGap0_start_yheight;
MCNUM restore_neutron = mccGap0_start_restore_neutron;
#line 122 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  destroy_darr2d(PSD_N);
  destroy_darr2d(PSD_p);
  destroy_darr2d(PSD_p2);
}
#line 77594 "./SNS_BASIS.c"
}   /* End of Gap0_start=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[6]) fprintf(stderr, "Warning: No neutron could reach Component[6] Gap0_start\n");
    if (mcAbsorbProp[6]) fprintf(stderr, "Warning: %g events were removed in Component[6] Gap0_start=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[6]);
    if (!mcNCounter[7]) fprintf(stderr, "Warning: No neutron could reach Component[7] Gap0_end_Lam\n");
    if (mcAbsorbProp[7]) fprintf(stderr, "Warning: %g events were removed in Component[7] Gap0_end_Lam=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[7]);
  /* User FINALLY code for component 'Gap0_end_divx'. */
  SIG_MESSAGE("Gap0_end_divx (Finally)");
#define mccompcurname  Gap0_end_divx
#define mccompcurtype  Monitor_nD
#define mccompcurindex 8
#define user1 mccGap0_end_divx_user1
#define user2 mccGap0_end_divx_user2
#define user3 mccGap0_end_divx_user3
#define DEFS mccGap0_end_divx_DEFS
#define Vars mccGap0_end_divx_Vars
#define detector mccGap0_end_divx_detector
#define offdata mccGap0_end_divx_offdata
{   /* Declarations of Gap0_end_divx=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccGap0_end_divx_xwidth;
MCNUM yheight = mccGap0_end_divx_yheight;
MCNUM zdepth = mccGap0_end_divx_zdepth;
MCNUM xmin = mccGap0_end_divx_xmin;
MCNUM xmax = mccGap0_end_divx_xmax;
MCNUM ymin = mccGap0_end_divx_ymin;
MCNUM ymax = mccGap0_end_divx_ymax;
MCNUM zmin = mccGap0_end_divx_zmin;
MCNUM zmax = mccGap0_end_divx_zmax;
MCNUM bins = mccGap0_end_divx_bins;
MCNUM min = mccGap0_end_divx_min;
MCNUM max = mccGap0_end_divx_max;
MCNUM restore_neutron = mccGap0_end_divx_restore_neutron;
MCNUM radius = mccGap0_end_divx_radius;
char* options = mccGap0_end_divx_options;
char* filename = mccGap0_end_divx_filename;
char* geometry = mccGap0_end_divx_geometry;
char* username1 = mccGap0_end_divx_username1;
char* username2 = mccGap0_end_divx_username2;
char* username3 = mccGap0_end_divx_username3;
int nowritefile = mccGap0_end_divx_nowritefile;
#line 489 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  /* free pointers */
  Monitor_nD_Finally(&DEFS, &Vars);
}
#line 77646 "./SNS_BASIS.c"
}   /* End of Gap0_end_divx=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[8]) fprintf(stderr, "Warning: No neutron could reach Component[8] Gap0_end_divx\n");
    if (mcAbsorbProp[8]) fprintf(stderr, "Warning: %g events were removed in Component[8] Gap0_end_divx=Monitor_nD()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[8]);
  /* User FINALLY code for component 'Gap0_end_divy'. */
  SIG_MESSAGE("Gap0_end_divy (Finally)");
#define mccompcurname  Gap0_end_divy
#define mccompcurtype  Monitor_nD
#define mccompcurindex 9
#define user1 mccGap0_end_divy_user1
#define user2 mccGap0_end_divy_user2
#define user3 mccGap0_end_divy_user3
#define DEFS mccGap0_end_divy_DEFS
#define Vars mccGap0_end_divy_Vars
#define detector mccGap0_end_divy_detector
#define offdata mccGap0_end_divy_offdata
{   /* Declarations of Gap0_end_divy=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccGap0_end_divy_xwidth;
MCNUM yheight = mccGap0_end_divy_yheight;
MCNUM zdepth = mccGap0_end_divy_zdepth;
MCNUM xmin = mccGap0_end_divy_xmin;
MCNUM xmax = mccGap0_end_divy_xmax;
MCNUM ymin = mccGap0_end_divy_ymin;
MCNUM ymax = mccGap0_end_divy_ymax;
MCNUM zmin = mccGap0_end_divy_zmin;
MCNUM zmax = mccGap0_end_divy_zmax;
MCNUM bins = mccGap0_end_divy_bins;
MCNUM min = mccGap0_end_divy_min;
MCNUM max = mccGap0_end_divy_max;
MCNUM restore_neutron = mccGap0_end_divy_restore_neutron;
MCNUM radius = mccGap0_end_divy_radius;
char* options = mccGap0_end_divy_options;
char* filename = mccGap0_end_divy_filename;
char* geometry = mccGap0_end_divy_geometry;
char* username1 = mccGap0_end_divy_username1;
char* username2 = mccGap0_end_divy_username2;
char* username3 = mccGap0_end_divy_username3;
int nowritefile = mccGap0_end_divy_nowritefile;
#line 489 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  /* free pointers */
  Monitor_nD_Finally(&DEFS, &Vars);
}
#line 77700 "./SNS_BASIS.c"
}   /* End of Gap0_end_divy=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[9]) fprintf(stderr, "Warning: No neutron could reach Component[9] Gap0_end_divy\n");
    if (mcAbsorbProp[9]) fprintf(stderr, "Warning: %g events were removed in Component[9] Gap0_end_divy=Monitor_nD()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[9]);
    if (!mcNCounter[10]) fprintf(stderr, "Warning: No neutron could reach Component[10] Core_Vessel_Section\n");
    if (mcAbsorbProp[10]) fprintf(stderr, "Warning: %g events were removed in Component[10] Core_Vessel_Section=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[10]);
    if (!mcNCounter[11]) fprintf(stderr, "Warning: No neutron could reach Component[11] Gap1_start\n");
    if (mcAbsorbProp[11]) fprintf(stderr, "Warning: %g events were removed in Component[11] Gap1_start=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[11]);
    if (!mcNCounter[12]) fprintf(stderr, "Warning: No neutron could reach Component[12] Gap1_start_Lam\n");
    if (mcAbsorbProp[12]) fprintf(stderr, "Warning: %g events were removed in Component[12] Gap1_start_Lam=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[12]);
    if (!mcNCounter[13]) fprintf(stderr, "Warning: No neutron could reach Component[13] Gap1_end_Lam\n");
    if (mcAbsorbProp[13]) fprintf(stderr, "Warning: %g events were removed in Component[13] Gap1_end_Lam=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[13]);
    if (!mcNCounter[14]) fprintf(stderr, "Warning: No neutron could reach Component[14] Gap1_end\n");
    if (mcAbsorbProp[14]) fprintf(stderr, "Warning: %g events were removed in Component[14] Gap1_end=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[14]);
  /* User FINALLY code for component 'Shutter_Guide_Insert'. */
  SIG_MESSAGE("Shutter_Guide_Insert (Finally)");
#define mccompcurname  Shutter_Guide_Insert
#define mccompcurtype  Guide_gravity
#define mccompcurindex 15
#define GVars mccShutter_Guide_Insert_GVars
#define pTable mccShutter_Guide_Insert_pTable
{   /* Declarations of Shutter_Guide_Insert=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_w1;
MCNUM h1 = mccShutter_Guide_Insert_h1;
MCNUM w2 = mccShutter_Guide_Insert_w2;
MCNUM h2 = mccShutter_Guide_Insert_h2;
MCNUM l = mccShutter_Guide_Insert_l;
MCNUM R0 = mccShutter_Guide_Insert_R0;
MCNUM Qc = mccShutter_Guide_Insert_Qc;
MCNUM alpha = mccShutter_Guide_Insert_alpha;
MCNUM m = mccShutter_Guide_Insert_m;
MCNUM W = mccShutter_Guide_Insert_W;
MCNUM nslit = mccShutter_Guide_Insert_nslit;
MCNUM d = mccShutter_Guide_Insert_d;
MCNUM mleft = mccShutter_Guide_Insert_mleft;
MCNUM mright = mccShutter_Guide_Insert_mright;
MCNUM mtop = mccShutter_Guide_Insert_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_nhslit;
MCNUM G = mccShutter_Guide_Insert_G;
MCNUM aleft = mccShutter_Guide_Insert_aleft;
MCNUM aright = mccShutter_Guide_Insert_aright;
MCNUM atop = mccShutter_Guide_Insert_atop;
MCNUM abottom = mccShutter_Guide_Insert_abottom;
MCNUM wavy = mccShutter_Guide_Insert_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_nelements;
MCNUM nu = mccShutter_Guide_Insert_nu;
MCNUM phase = mccShutter_Guide_Insert_phase;
char* reflect = mccShutter_Guide_Insert_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 77774 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[15]) fprintf(stderr, "Warning: No neutron could reach Component[15] Shutter_Guide_Insert\n");
    if (mcAbsorbProp[15]) fprintf(stderr, "Warning: %g events were removed in Component[15] Shutter_Guide_Insert=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[15]);
  /* User FINALLY code for component 'Shutter_Guide_Insert_16'. */
  SIG_MESSAGE("Shutter_Guide_Insert_16 (Finally)");
#define mccompcurname  Shutter_Guide_Insert_16
#define mccompcurtype  Guide_gravity
#define mccompcurindex 16
#define GVars mccShutter_Guide_Insert_16_GVars
#define pTable mccShutter_Guide_Insert_16_pTable
{   /* Declarations of Shutter_Guide_Insert_16=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_16_w1;
MCNUM h1 = mccShutter_Guide_Insert_16_h1;
MCNUM w2 = mccShutter_Guide_Insert_16_w2;
MCNUM h2 = mccShutter_Guide_Insert_16_h2;
MCNUM l = mccShutter_Guide_Insert_16_l;
MCNUM R0 = mccShutter_Guide_Insert_16_R0;
MCNUM Qc = mccShutter_Guide_Insert_16_Qc;
MCNUM alpha = mccShutter_Guide_Insert_16_alpha;
MCNUM m = mccShutter_Guide_Insert_16_m;
MCNUM W = mccShutter_Guide_Insert_16_W;
MCNUM nslit = mccShutter_Guide_Insert_16_nslit;
MCNUM d = mccShutter_Guide_Insert_16_d;
MCNUM mleft = mccShutter_Guide_Insert_16_mleft;
MCNUM mright = mccShutter_Guide_Insert_16_mright;
MCNUM mtop = mccShutter_Guide_Insert_16_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_16_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_16_nhslit;
MCNUM G = mccShutter_Guide_Insert_16_G;
MCNUM aleft = mccShutter_Guide_Insert_16_aleft;
MCNUM aright = mccShutter_Guide_Insert_16_aright;
MCNUM atop = mccShutter_Guide_Insert_16_atop;
MCNUM abottom = mccShutter_Guide_Insert_16_abottom;
MCNUM wavy = mccShutter_Guide_Insert_16_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_16_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_16_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_16_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_16_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_16_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_16_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_16_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_16_nelements;
MCNUM nu = mccShutter_Guide_Insert_16_nu;
MCNUM phase = mccShutter_Guide_Insert_16_phase;
char* reflect = mccShutter_Guide_Insert_16_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 77833 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert_16=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[16]) fprintf(stderr, "Warning: No neutron could reach Component[16] Shutter_Guide_Insert_16\n");
    if (mcAbsorbProp[16]) fprintf(stderr, "Warning: %g events were removed in Component[16] Shutter_Guide_Insert_16=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[16]);
  /* User FINALLY code for component 'Shutter_Guide_Insert_17'. */
  SIG_MESSAGE("Shutter_Guide_Insert_17 (Finally)");
#define mccompcurname  Shutter_Guide_Insert_17
#define mccompcurtype  Guide_gravity
#define mccompcurindex 17
#define GVars mccShutter_Guide_Insert_17_GVars
#define pTable mccShutter_Guide_Insert_17_pTable
{   /* Declarations of Shutter_Guide_Insert_17=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_17_w1;
MCNUM h1 = mccShutter_Guide_Insert_17_h1;
MCNUM w2 = mccShutter_Guide_Insert_17_w2;
MCNUM h2 = mccShutter_Guide_Insert_17_h2;
MCNUM l = mccShutter_Guide_Insert_17_l;
MCNUM R0 = mccShutter_Guide_Insert_17_R0;
MCNUM Qc = mccShutter_Guide_Insert_17_Qc;
MCNUM alpha = mccShutter_Guide_Insert_17_alpha;
MCNUM m = mccShutter_Guide_Insert_17_m;
MCNUM W = mccShutter_Guide_Insert_17_W;
MCNUM nslit = mccShutter_Guide_Insert_17_nslit;
MCNUM d = mccShutter_Guide_Insert_17_d;
MCNUM mleft = mccShutter_Guide_Insert_17_mleft;
MCNUM mright = mccShutter_Guide_Insert_17_mright;
MCNUM mtop = mccShutter_Guide_Insert_17_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_17_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_17_nhslit;
MCNUM G = mccShutter_Guide_Insert_17_G;
MCNUM aleft = mccShutter_Guide_Insert_17_aleft;
MCNUM aright = mccShutter_Guide_Insert_17_aright;
MCNUM atop = mccShutter_Guide_Insert_17_atop;
MCNUM abottom = mccShutter_Guide_Insert_17_abottom;
MCNUM wavy = mccShutter_Guide_Insert_17_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_17_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_17_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_17_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_17_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_17_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_17_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_17_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_17_nelements;
MCNUM nu = mccShutter_Guide_Insert_17_nu;
MCNUM phase = mccShutter_Guide_Insert_17_phase;
char* reflect = mccShutter_Guide_Insert_17_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 77892 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert_17=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[17]) fprintf(stderr, "Warning: No neutron could reach Component[17] Shutter_Guide_Insert_17\n");
    if (mcAbsorbProp[17]) fprintf(stderr, "Warning: %g events were removed in Component[17] Shutter_Guide_Insert_17=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[17]);
  /* User FINALLY code for component 'Shutter_Guide_Insert_18'. */
  SIG_MESSAGE("Shutter_Guide_Insert_18 (Finally)");
#define mccompcurname  Shutter_Guide_Insert_18
#define mccompcurtype  Guide_gravity
#define mccompcurindex 18
#define GVars mccShutter_Guide_Insert_18_GVars
#define pTable mccShutter_Guide_Insert_18_pTable
{   /* Declarations of Shutter_Guide_Insert_18=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_18_w1;
MCNUM h1 = mccShutter_Guide_Insert_18_h1;
MCNUM w2 = mccShutter_Guide_Insert_18_w2;
MCNUM h2 = mccShutter_Guide_Insert_18_h2;
MCNUM l = mccShutter_Guide_Insert_18_l;
MCNUM R0 = mccShutter_Guide_Insert_18_R0;
MCNUM Qc = mccShutter_Guide_Insert_18_Qc;
MCNUM alpha = mccShutter_Guide_Insert_18_alpha;
MCNUM m = mccShutter_Guide_Insert_18_m;
MCNUM W = mccShutter_Guide_Insert_18_W;
MCNUM nslit = mccShutter_Guide_Insert_18_nslit;
MCNUM d = mccShutter_Guide_Insert_18_d;
MCNUM mleft = mccShutter_Guide_Insert_18_mleft;
MCNUM mright = mccShutter_Guide_Insert_18_mright;
MCNUM mtop = mccShutter_Guide_Insert_18_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_18_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_18_nhslit;
MCNUM G = mccShutter_Guide_Insert_18_G;
MCNUM aleft = mccShutter_Guide_Insert_18_aleft;
MCNUM aright = mccShutter_Guide_Insert_18_aright;
MCNUM atop = mccShutter_Guide_Insert_18_atop;
MCNUM abottom = mccShutter_Guide_Insert_18_abottom;
MCNUM wavy = mccShutter_Guide_Insert_18_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_18_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_18_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_18_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_18_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_18_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_18_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_18_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_18_nelements;
MCNUM nu = mccShutter_Guide_Insert_18_nu;
MCNUM phase = mccShutter_Guide_Insert_18_phase;
char* reflect = mccShutter_Guide_Insert_18_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 77951 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert_18=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[18]) fprintf(stderr, "Warning: No neutron could reach Component[18] Shutter_Guide_Insert_18\n");
    if (mcAbsorbProp[18]) fprintf(stderr, "Warning: %g events were removed in Component[18] Shutter_Guide_Insert_18=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[18]);
  /* User FINALLY code for component 'Shutter_Guide_Insert_19'. */
  SIG_MESSAGE("Shutter_Guide_Insert_19 (Finally)");
#define mccompcurname  Shutter_Guide_Insert_19
#define mccompcurtype  Guide_gravity
#define mccompcurindex 19
#define GVars mccShutter_Guide_Insert_19_GVars
#define pTable mccShutter_Guide_Insert_19_pTable
{   /* Declarations of Shutter_Guide_Insert_19=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_19_w1;
MCNUM h1 = mccShutter_Guide_Insert_19_h1;
MCNUM w2 = mccShutter_Guide_Insert_19_w2;
MCNUM h2 = mccShutter_Guide_Insert_19_h2;
MCNUM l = mccShutter_Guide_Insert_19_l;
MCNUM R0 = mccShutter_Guide_Insert_19_R0;
MCNUM Qc = mccShutter_Guide_Insert_19_Qc;
MCNUM alpha = mccShutter_Guide_Insert_19_alpha;
MCNUM m = mccShutter_Guide_Insert_19_m;
MCNUM W = mccShutter_Guide_Insert_19_W;
MCNUM nslit = mccShutter_Guide_Insert_19_nslit;
MCNUM d = mccShutter_Guide_Insert_19_d;
MCNUM mleft = mccShutter_Guide_Insert_19_mleft;
MCNUM mright = mccShutter_Guide_Insert_19_mright;
MCNUM mtop = mccShutter_Guide_Insert_19_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_19_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_19_nhslit;
MCNUM G = mccShutter_Guide_Insert_19_G;
MCNUM aleft = mccShutter_Guide_Insert_19_aleft;
MCNUM aright = mccShutter_Guide_Insert_19_aright;
MCNUM atop = mccShutter_Guide_Insert_19_atop;
MCNUM abottom = mccShutter_Guide_Insert_19_abottom;
MCNUM wavy = mccShutter_Guide_Insert_19_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_19_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_19_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_19_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_19_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_19_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_19_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_19_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_19_nelements;
MCNUM nu = mccShutter_Guide_Insert_19_nu;
MCNUM phase = mccShutter_Guide_Insert_19_phase;
char* reflect = mccShutter_Guide_Insert_19_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 78010 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert_19=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[19]) fprintf(stderr, "Warning: No neutron could reach Component[19] Shutter_Guide_Insert_19\n");
    if (mcAbsorbProp[19]) fprintf(stderr, "Warning: %g events were removed in Component[19] Shutter_Guide_Insert_19=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[19]);
  /* User FINALLY code for component 'Shutter_Guide_Insert_20'. */
  SIG_MESSAGE("Shutter_Guide_Insert_20 (Finally)");
#define mccompcurname  Shutter_Guide_Insert_20
#define mccompcurtype  Guide_gravity
#define mccompcurindex 20
#define GVars mccShutter_Guide_Insert_20_GVars
#define pTable mccShutter_Guide_Insert_20_pTable
{   /* Declarations of Shutter_Guide_Insert_20=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_20_w1;
MCNUM h1 = mccShutter_Guide_Insert_20_h1;
MCNUM w2 = mccShutter_Guide_Insert_20_w2;
MCNUM h2 = mccShutter_Guide_Insert_20_h2;
MCNUM l = mccShutter_Guide_Insert_20_l;
MCNUM R0 = mccShutter_Guide_Insert_20_R0;
MCNUM Qc = mccShutter_Guide_Insert_20_Qc;
MCNUM alpha = mccShutter_Guide_Insert_20_alpha;
MCNUM m = mccShutter_Guide_Insert_20_m;
MCNUM W = mccShutter_Guide_Insert_20_W;
MCNUM nslit = mccShutter_Guide_Insert_20_nslit;
MCNUM d = mccShutter_Guide_Insert_20_d;
MCNUM mleft = mccShutter_Guide_Insert_20_mleft;
MCNUM mright = mccShutter_Guide_Insert_20_mright;
MCNUM mtop = mccShutter_Guide_Insert_20_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_20_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_20_nhslit;
MCNUM G = mccShutter_Guide_Insert_20_G;
MCNUM aleft = mccShutter_Guide_Insert_20_aleft;
MCNUM aright = mccShutter_Guide_Insert_20_aright;
MCNUM atop = mccShutter_Guide_Insert_20_atop;
MCNUM abottom = mccShutter_Guide_Insert_20_abottom;
MCNUM wavy = mccShutter_Guide_Insert_20_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_20_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_20_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_20_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_20_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_20_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_20_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_20_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_20_nelements;
MCNUM nu = mccShutter_Guide_Insert_20_nu;
MCNUM phase = mccShutter_Guide_Insert_20_phase;
char* reflect = mccShutter_Guide_Insert_20_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 78069 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert_20=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[20]) fprintf(stderr, "Warning: No neutron could reach Component[20] Shutter_Guide_Insert_20\n");
    if (mcAbsorbProp[20]) fprintf(stderr, "Warning: %g events were removed in Component[20] Shutter_Guide_Insert_20=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[20]);
  /* User FINALLY code for component 'Shutter_Guide_Insert_21'. */
  SIG_MESSAGE("Shutter_Guide_Insert_21 (Finally)");
#define mccompcurname  Shutter_Guide_Insert_21
#define mccompcurtype  Guide_gravity
#define mccompcurindex 21
#define GVars mccShutter_Guide_Insert_21_GVars
#define pTable mccShutter_Guide_Insert_21_pTable
{   /* Declarations of Shutter_Guide_Insert_21=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_21_w1;
MCNUM h1 = mccShutter_Guide_Insert_21_h1;
MCNUM w2 = mccShutter_Guide_Insert_21_w2;
MCNUM h2 = mccShutter_Guide_Insert_21_h2;
MCNUM l = mccShutter_Guide_Insert_21_l;
MCNUM R0 = mccShutter_Guide_Insert_21_R0;
MCNUM Qc = mccShutter_Guide_Insert_21_Qc;
MCNUM alpha = mccShutter_Guide_Insert_21_alpha;
MCNUM m = mccShutter_Guide_Insert_21_m;
MCNUM W = mccShutter_Guide_Insert_21_W;
MCNUM nslit = mccShutter_Guide_Insert_21_nslit;
MCNUM d = mccShutter_Guide_Insert_21_d;
MCNUM mleft = mccShutter_Guide_Insert_21_mleft;
MCNUM mright = mccShutter_Guide_Insert_21_mright;
MCNUM mtop = mccShutter_Guide_Insert_21_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_21_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_21_nhslit;
MCNUM G = mccShutter_Guide_Insert_21_G;
MCNUM aleft = mccShutter_Guide_Insert_21_aleft;
MCNUM aright = mccShutter_Guide_Insert_21_aright;
MCNUM atop = mccShutter_Guide_Insert_21_atop;
MCNUM abottom = mccShutter_Guide_Insert_21_abottom;
MCNUM wavy = mccShutter_Guide_Insert_21_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_21_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_21_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_21_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_21_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_21_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_21_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_21_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_21_nelements;
MCNUM nu = mccShutter_Guide_Insert_21_nu;
MCNUM phase = mccShutter_Guide_Insert_21_phase;
char* reflect = mccShutter_Guide_Insert_21_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 78128 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert_21=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[21]) fprintf(stderr, "Warning: No neutron could reach Component[21] Shutter_Guide_Insert_21\n");
    if (mcAbsorbProp[21]) fprintf(stderr, "Warning: %g events were removed in Component[21] Shutter_Guide_Insert_21=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[21]);
  /* User FINALLY code for component 'Shutter_Guide_Insert_short'. */
  SIG_MESSAGE("Shutter_Guide_Insert_short (Finally)");
#define mccompcurname  Shutter_Guide_Insert_short
#define mccompcurtype  Guide_gravity
#define mccompcurindex 22
#define GVars mccShutter_Guide_Insert_short_GVars
#define pTable mccShutter_Guide_Insert_short_pTable
{   /* Declarations of Shutter_Guide_Insert_short=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_short_w1;
MCNUM h1 = mccShutter_Guide_Insert_short_h1;
MCNUM w2 = mccShutter_Guide_Insert_short_w2;
MCNUM h2 = mccShutter_Guide_Insert_short_h2;
MCNUM l = mccShutter_Guide_Insert_short_l;
MCNUM R0 = mccShutter_Guide_Insert_short_R0;
MCNUM Qc = mccShutter_Guide_Insert_short_Qc;
MCNUM alpha = mccShutter_Guide_Insert_short_alpha;
MCNUM m = mccShutter_Guide_Insert_short_m;
MCNUM W = mccShutter_Guide_Insert_short_W;
MCNUM nslit = mccShutter_Guide_Insert_short_nslit;
MCNUM d = mccShutter_Guide_Insert_short_d;
MCNUM mleft = mccShutter_Guide_Insert_short_mleft;
MCNUM mright = mccShutter_Guide_Insert_short_mright;
MCNUM mtop = mccShutter_Guide_Insert_short_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_short_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_short_nhslit;
MCNUM G = mccShutter_Guide_Insert_short_G;
MCNUM aleft = mccShutter_Guide_Insert_short_aleft;
MCNUM aright = mccShutter_Guide_Insert_short_aright;
MCNUM atop = mccShutter_Guide_Insert_short_atop;
MCNUM abottom = mccShutter_Guide_Insert_short_abottom;
MCNUM wavy = mccShutter_Guide_Insert_short_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_short_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_short_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_short_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_short_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_short_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_short_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_short_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_short_nelements;
MCNUM nu = mccShutter_Guide_Insert_short_nu;
MCNUM phase = mccShutter_Guide_Insert_short_phase;
char* reflect = mccShutter_Guide_Insert_short_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 78187 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert_short=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[22]) fprintf(stderr, "Warning: No neutron could reach Component[22] Shutter_Guide_Insert_short\n");
    if (mcAbsorbProp[22]) fprintf(stderr, "Warning: %g events were removed in Component[22] Shutter_Guide_Insert_short=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[22]);
    if (!mcNCounter[23]) fprintf(stderr, "Warning: No neutron could reach Component[23] Gap2_start\n");
    if (mcAbsorbProp[23]) fprintf(stderr, "Warning: %g events were removed in Component[23] Gap2_start=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[23]);
    if (!mcNCounter[24]) fprintf(stderr, "Warning: No neutron could reach Component[24] Gap2_start_Lam\n");
    if (mcAbsorbProp[24]) fprintf(stderr, "Warning: %g events were removed in Component[24] Gap2_start_Lam=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[24]);
  /* User FINALLY code for component 'Gap2_start_PSD'. */
  SIG_MESSAGE("Gap2_start_PSD (Finally)");
#define mccompcurname  Gap2_start_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 25
#define PSD_N mccGap2_start_PSD_PSD_N
#define PSD_p mccGap2_start_PSD_PSD_p
#define PSD_p2 mccGap2_start_PSD_PSD_p2
{   /* Declarations of Gap2_start_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap2_start_PSD_nx;
int ny = mccGap2_start_PSD_ny;
char* filename = mccGap2_start_PSD_filename;
MCNUM xmin = mccGap2_start_PSD_xmin;
MCNUM xmax = mccGap2_start_PSD_xmax;
MCNUM ymin = mccGap2_start_PSD_ymin;
MCNUM ymax = mccGap2_start_PSD_ymax;
MCNUM xwidth = mccGap2_start_PSD_xwidth;
MCNUM yheight = mccGap2_start_PSD_yheight;
MCNUM restore_neutron = mccGap2_start_PSD_restore_neutron;
#line 122 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  destroy_darr2d(PSD_N);
  destroy_darr2d(PSD_p);
  destroy_darr2d(PSD_p2);
}
#line 78226 "./SNS_BASIS.c"
}   /* End of Gap2_start_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[25]) fprintf(stderr, "Warning: No neutron could reach Component[25] Gap2_start_PSD\n");
    if (mcAbsorbProp[25]) fprintf(stderr, "Warning: %g events were removed in Component[25] Gap2_start_PSD=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[25]);
    if (!mcNCounter[26]) fprintf(stderr, "Warning: No neutron could reach Component[26] Gap2_end_Lam\n");
    if (mcAbsorbProp[26]) fprintf(stderr, "Warning: %g events were removed in Component[26] Gap2_end_Lam=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[26]);
  /* User FINALLY code for component 'Gap2_end_PSD'. */
  SIG_MESSAGE("Gap2_end_PSD (Finally)");
#define mccompcurname  Gap2_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 27
#define PSD_N mccGap2_end_PSD_PSD_N
#define PSD_p mccGap2_end_PSD_PSD_p
#define PSD_p2 mccGap2_end_PSD_PSD_p2
{   /* Declarations of Gap2_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap2_end_PSD_nx;
int ny = mccGap2_end_PSD_ny;
char* filename = mccGap2_end_PSD_filename;
MCNUM xmin = mccGap2_end_PSD_xmin;
MCNUM xmax = mccGap2_end_PSD_xmax;
MCNUM ymin = mccGap2_end_PSD_ymin;
MCNUM ymax = mccGap2_end_PSD_ymax;
MCNUM xwidth = mccGap2_end_PSD_xwidth;
MCNUM yheight = mccGap2_end_PSD_yheight;
MCNUM restore_neutron = mccGap2_end_PSD_restore_neutron;
#line 122 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  destroy_darr2d(PSD_N);
  destroy_darr2d(PSD_p);
  destroy_darr2d(PSD_p2);
}
#line 78264 "./SNS_BASIS.c"
}   /* End of Gap2_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[27]) fprintf(stderr, "Warning: No neutron could reach Component[27] Gap2_end_PSD\n");
    if (mcAbsorbProp[27]) fprintf(stderr, "Warning: %g events were removed in Component[27] Gap2_end_PSD=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[27]);
    if (!mcNCounter[28]) fprintf(stderr, "Warning: No neutron could reach Component[28] Gap2_end\n");
    if (mcAbsorbProp[28]) fprintf(stderr, "Warning: %g events were removed in Component[28] Gap2_end=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[28]);
  /* User FINALLY code for component 'Curved_Guide_Section_I'. */
  SIG_MESSAGE("Curved_Guide_Section_I (Finally)");
#define mccompcurname  Curved_Guide_Section_I
#define mccompcurtype  Guide_gravity
#define mccompcurindex 29
#define GVars mccCurved_Guide_Section_I_GVars
#define pTable mccCurved_Guide_Section_I_pTable
{   /* Declarations of Curved_Guide_Section_I=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_w1;
MCNUM h1 = mccCurved_Guide_Section_I_h1;
MCNUM w2 = mccCurved_Guide_Section_I_w2;
MCNUM h2 = mccCurved_Guide_Section_I_h2;
MCNUM l = mccCurved_Guide_Section_I_l;
MCNUM R0 = mccCurved_Guide_Section_I_R0;
MCNUM Qc = mccCurved_Guide_Section_I_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_alpha;
MCNUM m = mccCurved_Guide_Section_I_m;
MCNUM W = mccCurved_Guide_Section_I_W;
MCNUM nslit = mccCurved_Guide_Section_I_nslit;
MCNUM d = mccCurved_Guide_Section_I_d;
MCNUM mleft = mccCurved_Guide_Section_I_mleft;
MCNUM mright = mccCurved_Guide_Section_I_mright;
MCNUM mtop = mccCurved_Guide_Section_I_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_nhslit;
MCNUM G = mccCurved_Guide_Section_I_G;
MCNUM aleft = mccCurved_Guide_Section_I_aleft;
MCNUM aright = mccCurved_Guide_Section_I_aright;
MCNUM atop = mccCurved_Guide_Section_I_atop;
MCNUM abottom = mccCurved_Guide_Section_I_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_nelements;
MCNUM nu = mccCurved_Guide_Section_I_nu;
MCNUM phase = mccCurved_Guide_Section_I_phase;
char* reflect = mccCurved_Guide_Section_I_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 78326 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[29]) fprintf(stderr, "Warning: No neutron could reach Component[29] Curved_Guide_Section_I\n");
    if (mcAbsorbProp[29]) fprintf(stderr, "Warning: %g events were removed in Component[29] Curved_Guide_Section_I=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[29]);
  /* User FINALLY code for component 'Curved_Guide_Section_I_30'. */
  SIG_MESSAGE("Curved_Guide_Section_I_30 (Finally)");
#define mccompcurname  Curved_Guide_Section_I_30
#define mccompcurtype  Guide_gravity
#define mccompcurindex 30
#define GVars mccCurved_Guide_Section_I_30_GVars
#define pTable mccCurved_Guide_Section_I_30_pTable
{   /* Declarations of Curved_Guide_Section_I_30=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_30_w1;
MCNUM h1 = mccCurved_Guide_Section_I_30_h1;
MCNUM w2 = mccCurved_Guide_Section_I_30_w2;
MCNUM h2 = mccCurved_Guide_Section_I_30_h2;
MCNUM l = mccCurved_Guide_Section_I_30_l;
MCNUM R0 = mccCurved_Guide_Section_I_30_R0;
MCNUM Qc = mccCurved_Guide_Section_I_30_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_30_alpha;
MCNUM m = mccCurved_Guide_Section_I_30_m;
MCNUM W = mccCurved_Guide_Section_I_30_W;
MCNUM nslit = mccCurved_Guide_Section_I_30_nslit;
MCNUM d = mccCurved_Guide_Section_I_30_d;
MCNUM mleft = mccCurved_Guide_Section_I_30_mleft;
MCNUM mright = mccCurved_Guide_Section_I_30_mright;
MCNUM mtop = mccCurved_Guide_Section_I_30_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_30_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_30_nhslit;
MCNUM G = mccCurved_Guide_Section_I_30_G;
MCNUM aleft = mccCurved_Guide_Section_I_30_aleft;
MCNUM aright = mccCurved_Guide_Section_I_30_aright;
MCNUM atop = mccCurved_Guide_Section_I_30_atop;
MCNUM abottom = mccCurved_Guide_Section_I_30_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_30_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_30_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_30_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_30_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_30_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_30_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_30_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_30_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_30_nelements;
MCNUM nu = mccCurved_Guide_Section_I_30_nu;
MCNUM phase = mccCurved_Guide_Section_I_30_phase;
char* reflect = mccCurved_Guide_Section_I_30_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 78385 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_30=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[30]) fprintf(stderr, "Warning: No neutron could reach Component[30] Curved_Guide_Section_I_30\n");
    if (mcAbsorbProp[30]) fprintf(stderr, "Warning: %g events were removed in Component[30] Curved_Guide_Section_I_30=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[30]);
  /* User FINALLY code for component 'Curved_Guide_Section_I_31'. */
  SIG_MESSAGE("Curved_Guide_Section_I_31 (Finally)");
#define mccompcurname  Curved_Guide_Section_I_31
#define mccompcurtype  Guide_gravity
#define mccompcurindex 31
#define GVars mccCurved_Guide_Section_I_31_GVars
#define pTable mccCurved_Guide_Section_I_31_pTable
{   /* Declarations of Curved_Guide_Section_I_31=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_31_w1;
MCNUM h1 = mccCurved_Guide_Section_I_31_h1;
MCNUM w2 = mccCurved_Guide_Section_I_31_w2;
MCNUM h2 = mccCurved_Guide_Section_I_31_h2;
MCNUM l = mccCurved_Guide_Section_I_31_l;
MCNUM R0 = mccCurved_Guide_Section_I_31_R0;
MCNUM Qc = mccCurved_Guide_Section_I_31_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_31_alpha;
MCNUM m = mccCurved_Guide_Section_I_31_m;
MCNUM W = mccCurved_Guide_Section_I_31_W;
MCNUM nslit = mccCurved_Guide_Section_I_31_nslit;
MCNUM d = mccCurved_Guide_Section_I_31_d;
MCNUM mleft = mccCurved_Guide_Section_I_31_mleft;
MCNUM mright = mccCurved_Guide_Section_I_31_mright;
MCNUM mtop = mccCurved_Guide_Section_I_31_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_31_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_31_nhslit;
MCNUM G = mccCurved_Guide_Section_I_31_G;
MCNUM aleft = mccCurved_Guide_Section_I_31_aleft;
MCNUM aright = mccCurved_Guide_Section_I_31_aright;
MCNUM atop = mccCurved_Guide_Section_I_31_atop;
MCNUM abottom = mccCurved_Guide_Section_I_31_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_31_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_31_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_31_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_31_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_31_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_31_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_31_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_31_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_31_nelements;
MCNUM nu = mccCurved_Guide_Section_I_31_nu;
MCNUM phase = mccCurved_Guide_Section_I_31_phase;
char* reflect = mccCurved_Guide_Section_I_31_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 78444 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_31=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[31]) fprintf(stderr, "Warning: No neutron could reach Component[31] Curved_Guide_Section_I_31\n");
    if (mcAbsorbProp[31]) fprintf(stderr, "Warning: %g events were removed in Component[31] Curved_Guide_Section_I_31=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[31]);
  /* User FINALLY code for component 'Curved_Guide_Section_I_32'. */
  SIG_MESSAGE("Curved_Guide_Section_I_32 (Finally)");
#define mccompcurname  Curved_Guide_Section_I_32
#define mccompcurtype  Guide_gravity
#define mccompcurindex 32
#define GVars mccCurved_Guide_Section_I_32_GVars
#define pTable mccCurved_Guide_Section_I_32_pTable
{   /* Declarations of Curved_Guide_Section_I_32=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_32_w1;
MCNUM h1 = mccCurved_Guide_Section_I_32_h1;
MCNUM w2 = mccCurved_Guide_Section_I_32_w2;
MCNUM h2 = mccCurved_Guide_Section_I_32_h2;
MCNUM l = mccCurved_Guide_Section_I_32_l;
MCNUM R0 = mccCurved_Guide_Section_I_32_R0;
MCNUM Qc = mccCurved_Guide_Section_I_32_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_32_alpha;
MCNUM m = mccCurved_Guide_Section_I_32_m;
MCNUM W = mccCurved_Guide_Section_I_32_W;
MCNUM nslit = mccCurved_Guide_Section_I_32_nslit;
MCNUM d = mccCurved_Guide_Section_I_32_d;
MCNUM mleft = mccCurved_Guide_Section_I_32_mleft;
MCNUM mright = mccCurved_Guide_Section_I_32_mright;
MCNUM mtop = mccCurved_Guide_Section_I_32_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_32_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_32_nhslit;
MCNUM G = mccCurved_Guide_Section_I_32_G;
MCNUM aleft = mccCurved_Guide_Section_I_32_aleft;
MCNUM aright = mccCurved_Guide_Section_I_32_aright;
MCNUM atop = mccCurved_Guide_Section_I_32_atop;
MCNUM abottom = mccCurved_Guide_Section_I_32_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_32_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_32_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_32_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_32_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_32_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_32_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_32_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_32_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_32_nelements;
MCNUM nu = mccCurved_Guide_Section_I_32_nu;
MCNUM phase = mccCurved_Guide_Section_I_32_phase;
char* reflect = mccCurved_Guide_Section_I_32_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 78503 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_32=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[32]) fprintf(stderr, "Warning: No neutron could reach Component[32] Curved_Guide_Section_I_32\n");
    if (mcAbsorbProp[32]) fprintf(stderr, "Warning: %g events were removed in Component[32] Curved_Guide_Section_I_32=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[32]);
  /* User FINALLY code for component 'Curved_Guide_Section_I_33'. */
  SIG_MESSAGE("Curved_Guide_Section_I_33 (Finally)");
#define mccompcurname  Curved_Guide_Section_I_33
#define mccompcurtype  Guide_gravity
#define mccompcurindex 33
#define GVars mccCurved_Guide_Section_I_33_GVars
#define pTable mccCurved_Guide_Section_I_33_pTable
{   /* Declarations of Curved_Guide_Section_I_33=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_33_w1;
MCNUM h1 = mccCurved_Guide_Section_I_33_h1;
MCNUM w2 = mccCurved_Guide_Section_I_33_w2;
MCNUM h2 = mccCurved_Guide_Section_I_33_h2;
MCNUM l = mccCurved_Guide_Section_I_33_l;
MCNUM R0 = mccCurved_Guide_Section_I_33_R0;
MCNUM Qc = mccCurved_Guide_Section_I_33_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_33_alpha;
MCNUM m = mccCurved_Guide_Section_I_33_m;
MCNUM W = mccCurved_Guide_Section_I_33_W;
MCNUM nslit = mccCurved_Guide_Section_I_33_nslit;
MCNUM d = mccCurved_Guide_Section_I_33_d;
MCNUM mleft = mccCurved_Guide_Section_I_33_mleft;
MCNUM mright = mccCurved_Guide_Section_I_33_mright;
MCNUM mtop = mccCurved_Guide_Section_I_33_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_33_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_33_nhslit;
MCNUM G = mccCurved_Guide_Section_I_33_G;
MCNUM aleft = mccCurved_Guide_Section_I_33_aleft;
MCNUM aright = mccCurved_Guide_Section_I_33_aright;
MCNUM atop = mccCurved_Guide_Section_I_33_atop;
MCNUM abottom = mccCurved_Guide_Section_I_33_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_33_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_33_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_33_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_33_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_33_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_33_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_33_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_33_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_33_nelements;
MCNUM nu = mccCurved_Guide_Section_I_33_nu;
MCNUM phase = mccCurved_Guide_Section_I_33_phase;
char* reflect = mccCurved_Guide_Section_I_33_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 78562 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_33=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[33]) fprintf(stderr, "Warning: No neutron could reach Component[33] Curved_Guide_Section_I_33\n");
    if (mcAbsorbProp[33]) fprintf(stderr, "Warning: %g events were removed in Component[33] Curved_Guide_Section_I_33=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[33]);
  /* User FINALLY code for component 'Curved_Guide_Section_I_34'. */
  SIG_MESSAGE("Curved_Guide_Section_I_34 (Finally)");
#define mccompcurname  Curved_Guide_Section_I_34
#define mccompcurtype  Guide_gravity
#define mccompcurindex 34
#define GVars mccCurved_Guide_Section_I_34_GVars
#define pTable mccCurved_Guide_Section_I_34_pTable
{   /* Declarations of Curved_Guide_Section_I_34=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_34_w1;
MCNUM h1 = mccCurved_Guide_Section_I_34_h1;
MCNUM w2 = mccCurved_Guide_Section_I_34_w2;
MCNUM h2 = mccCurved_Guide_Section_I_34_h2;
MCNUM l = mccCurved_Guide_Section_I_34_l;
MCNUM R0 = mccCurved_Guide_Section_I_34_R0;
MCNUM Qc = mccCurved_Guide_Section_I_34_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_34_alpha;
MCNUM m = mccCurved_Guide_Section_I_34_m;
MCNUM W = mccCurved_Guide_Section_I_34_W;
MCNUM nslit = mccCurved_Guide_Section_I_34_nslit;
MCNUM d = mccCurved_Guide_Section_I_34_d;
MCNUM mleft = mccCurved_Guide_Section_I_34_mleft;
MCNUM mright = mccCurved_Guide_Section_I_34_mright;
MCNUM mtop = mccCurved_Guide_Section_I_34_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_34_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_34_nhslit;
MCNUM G = mccCurved_Guide_Section_I_34_G;
MCNUM aleft = mccCurved_Guide_Section_I_34_aleft;
MCNUM aright = mccCurved_Guide_Section_I_34_aright;
MCNUM atop = mccCurved_Guide_Section_I_34_atop;
MCNUM abottom = mccCurved_Guide_Section_I_34_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_34_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_34_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_34_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_34_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_34_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_34_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_34_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_34_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_34_nelements;
MCNUM nu = mccCurved_Guide_Section_I_34_nu;
MCNUM phase = mccCurved_Guide_Section_I_34_phase;
char* reflect = mccCurved_Guide_Section_I_34_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 78621 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_34=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[34]) fprintf(stderr, "Warning: No neutron could reach Component[34] Curved_Guide_Section_I_34\n");
    if (mcAbsorbProp[34]) fprintf(stderr, "Warning: %g events were removed in Component[34] Curved_Guide_Section_I_34=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[34]);
  /* User FINALLY code for component 'Curved_Guide_Section_I_35'. */
  SIG_MESSAGE("Curved_Guide_Section_I_35 (Finally)");
#define mccompcurname  Curved_Guide_Section_I_35
#define mccompcurtype  Guide_gravity
#define mccompcurindex 35
#define GVars mccCurved_Guide_Section_I_35_GVars
#define pTable mccCurved_Guide_Section_I_35_pTable
{   /* Declarations of Curved_Guide_Section_I_35=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_35_w1;
MCNUM h1 = mccCurved_Guide_Section_I_35_h1;
MCNUM w2 = mccCurved_Guide_Section_I_35_w2;
MCNUM h2 = mccCurved_Guide_Section_I_35_h2;
MCNUM l = mccCurved_Guide_Section_I_35_l;
MCNUM R0 = mccCurved_Guide_Section_I_35_R0;
MCNUM Qc = mccCurved_Guide_Section_I_35_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_35_alpha;
MCNUM m = mccCurved_Guide_Section_I_35_m;
MCNUM W = mccCurved_Guide_Section_I_35_W;
MCNUM nslit = mccCurved_Guide_Section_I_35_nslit;
MCNUM d = mccCurved_Guide_Section_I_35_d;
MCNUM mleft = mccCurved_Guide_Section_I_35_mleft;
MCNUM mright = mccCurved_Guide_Section_I_35_mright;
MCNUM mtop = mccCurved_Guide_Section_I_35_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_35_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_35_nhslit;
MCNUM G = mccCurved_Guide_Section_I_35_G;
MCNUM aleft = mccCurved_Guide_Section_I_35_aleft;
MCNUM aright = mccCurved_Guide_Section_I_35_aright;
MCNUM atop = mccCurved_Guide_Section_I_35_atop;
MCNUM abottom = mccCurved_Guide_Section_I_35_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_35_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_35_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_35_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_35_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_35_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_35_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_35_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_35_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_35_nelements;
MCNUM nu = mccCurved_Guide_Section_I_35_nu;
MCNUM phase = mccCurved_Guide_Section_I_35_phase;
char* reflect = mccCurved_Guide_Section_I_35_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 78680 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_35=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[35]) fprintf(stderr, "Warning: No neutron could reach Component[35] Curved_Guide_Section_I_35\n");
    if (mcAbsorbProp[35]) fprintf(stderr, "Warning: %g events were removed in Component[35] Curved_Guide_Section_I_35=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[35]);
  /* User FINALLY code for component 'Curved_Guide_Section_I_36'. */
  SIG_MESSAGE("Curved_Guide_Section_I_36 (Finally)");
#define mccompcurname  Curved_Guide_Section_I_36
#define mccompcurtype  Guide_gravity
#define mccompcurindex 36
#define GVars mccCurved_Guide_Section_I_36_GVars
#define pTable mccCurved_Guide_Section_I_36_pTable
{   /* Declarations of Curved_Guide_Section_I_36=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_36_w1;
MCNUM h1 = mccCurved_Guide_Section_I_36_h1;
MCNUM w2 = mccCurved_Guide_Section_I_36_w2;
MCNUM h2 = mccCurved_Guide_Section_I_36_h2;
MCNUM l = mccCurved_Guide_Section_I_36_l;
MCNUM R0 = mccCurved_Guide_Section_I_36_R0;
MCNUM Qc = mccCurved_Guide_Section_I_36_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_36_alpha;
MCNUM m = mccCurved_Guide_Section_I_36_m;
MCNUM W = mccCurved_Guide_Section_I_36_W;
MCNUM nslit = mccCurved_Guide_Section_I_36_nslit;
MCNUM d = mccCurved_Guide_Section_I_36_d;
MCNUM mleft = mccCurved_Guide_Section_I_36_mleft;
MCNUM mright = mccCurved_Guide_Section_I_36_mright;
MCNUM mtop = mccCurved_Guide_Section_I_36_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_36_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_36_nhslit;
MCNUM G = mccCurved_Guide_Section_I_36_G;
MCNUM aleft = mccCurved_Guide_Section_I_36_aleft;
MCNUM aright = mccCurved_Guide_Section_I_36_aright;
MCNUM atop = mccCurved_Guide_Section_I_36_atop;
MCNUM abottom = mccCurved_Guide_Section_I_36_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_36_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_36_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_36_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_36_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_36_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_36_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_36_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_36_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_36_nelements;
MCNUM nu = mccCurved_Guide_Section_I_36_nu;
MCNUM phase = mccCurved_Guide_Section_I_36_phase;
char* reflect = mccCurved_Guide_Section_I_36_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 78739 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_36=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[36]) fprintf(stderr, "Warning: No neutron could reach Component[36] Curved_Guide_Section_I_36\n");
    if (mcAbsorbProp[36]) fprintf(stderr, "Warning: %g events were removed in Component[36] Curved_Guide_Section_I_36=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[36]);
  /* User FINALLY code for component 'Curved_Guide_Section_I_37'. */
  SIG_MESSAGE("Curved_Guide_Section_I_37 (Finally)");
#define mccompcurname  Curved_Guide_Section_I_37
#define mccompcurtype  Guide_gravity
#define mccompcurindex 37
#define GVars mccCurved_Guide_Section_I_37_GVars
#define pTable mccCurved_Guide_Section_I_37_pTable
{   /* Declarations of Curved_Guide_Section_I_37=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_37_w1;
MCNUM h1 = mccCurved_Guide_Section_I_37_h1;
MCNUM w2 = mccCurved_Guide_Section_I_37_w2;
MCNUM h2 = mccCurved_Guide_Section_I_37_h2;
MCNUM l = mccCurved_Guide_Section_I_37_l;
MCNUM R0 = mccCurved_Guide_Section_I_37_R0;
MCNUM Qc = mccCurved_Guide_Section_I_37_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_37_alpha;
MCNUM m = mccCurved_Guide_Section_I_37_m;
MCNUM W = mccCurved_Guide_Section_I_37_W;
MCNUM nslit = mccCurved_Guide_Section_I_37_nslit;
MCNUM d = mccCurved_Guide_Section_I_37_d;
MCNUM mleft = mccCurved_Guide_Section_I_37_mleft;
MCNUM mright = mccCurved_Guide_Section_I_37_mright;
MCNUM mtop = mccCurved_Guide_Section_I_37_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_37_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_37_nhslit;
MCNUM G = mccCurved_Guide_Section_I_37_G;
MCNUM aleft = mccCurved_Guide_Section_I_37_aleft;
MCNUM aright = mccCurved_Guide_Section_I_37_aright;
MCNUM atop = mccCurved_Guide_Section_I_37_atop;
MCNUM abottom = mccCurved_Guide_Section_I_37_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_37_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_37_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_37_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_37_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_37_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_37_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_37_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_37_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_37_nelements;
MCNUM nu = mccCurved_Guide_Section_I_37_nu;
MCNUM phase = mccCurved_Guide_Section_I_37_phase;
char* reflect = mccCurved_Guide_Section_I_37_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 78798 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_37=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[37]) fprintf(stderr, "Warning: No neutron could reach Component[37] Curved_Guide_Section_I_37\n");
    if (mcAbsorbProp[37]) fprintf(stderr, "Warning: %g events were removed in Component[37] Curved_Guide_Section_I_37=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[37]);
  /* User FINALLY code for component 'Curved_Guide_Section_I_38'. */
  SIG_MESSAGE("Curved_Guide_Section_I_38 (Finally)");
#define mccompcurname  Curved_Guide_Section_I_38
#define mccompcurtype  Guide_gravity
#define mccompcurindex 38
#define GVars mccCurved_Guide_Section_I_38_GVars
#define pTable mccCurved_Guide_Section_I_38_pTable
{   /* Declarations of Curved_Guide_Section_I_38=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_38_w1;
MCNUM h1 = mccCurved_Guide_Section_I_38_h1;
MCNUM w2 = mccCurved_Guide_Section_I_38_w2;
MCNUM h2 = mccCurved_Guide_Section_I_38_h2;
MCNUM l = mccCurved_Guide_Section_I_38_l;
MCNUM R0 = mccCurved_Guide_Section_I_38_R0;
MCNUM Qc = mccCurved_Guide_Section_I_38_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_38_alpha;
MCNUM m = mccCurved_Guide_Section_I_38_m;
MCNUM W = mccCurved_Guide_Section_I_38_W;
MCNUM nslit = mccCurved_Guide_Section_I_38_nslit;
MCNUM d = mccCurved_Guide_Section_I_38_d;
MCNUM mleft = mccCurved_Guide_Section_I_38_mleft;
MCNUM mright = mccCurved_Guide_Section_I_38_mright;
MCNUM mtop = mccCurved_Guide_Section_I_38_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_38_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_38_nhslit;
MCNUM G = mccCurved_Guide_Section_I_38_G;
MCNUM aleft = mccCurved_Guide_Section_I_38_aleft;
MCNUM aright = mccCurved_Guide_Section_I_38_aright;
MCNUM atop = mccCurved_Guide_Section_I_38_atop;
MCNUM abottom = mccCurved_Guide_Section_I_38_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_38_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_38_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_38_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_38_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_38_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_38_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_38_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_38_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_38_nelements;
MCNUM nu = mccCurved_Guide_Section_I_38_nu;
MCNUM phase = mccCurved_Guide_Section_I_38_phase;
char* reflect = mccCurved_Guide_Section_I_38_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 78857 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_38=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[38]) fprintf(stderr, "Warning: No neutron could reach Component[38] Curved_Guide_Section_I_38\n");
    if (mcAbsorbProp[38]) fprintf(stderr, "Warning: %g events were removed in Component[38] Curved_Guide_Section_I_38=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[38]);
  /* User FINALLY code for component 'Curved_Guide_Section_I_short'. */
  SIG_MESSAGE("Curved_Guide_Section_I_short (Finally)");
#define mccompcurname  Curved_Guide_Section_I_short
#define mccompcurtype  Guide_gravity
#define mccompcurindex 39
#define GVars mccCurved_Guide_Section_I_short_GVars
#define pTable mccCurved_Guide_Section_I_short_pTable
{   /* Declarations of Curved_Guide_Section_I_short=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_short_w1;
MCNUM h1 = mccCurved_Guide_Section_I_short_h1;
MCNUM w2 = mccCurved_Guide_Section_I_short_w2;
MCNUM h2 = mccCurved_Guide_Section_I_short_h2;
MCNUM l = mccCurved_Guide_Section_I_short_l;
MCNUM R0 = mccCurved_Guide_Section_I_short_R0;
MCNUM Qc = mccCurved_Guide_Section_I_short_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_short_alpha;
MCNUM m = mccCurved_Guide_Section_I_short_m;
MCNUM W = mccCurved_Guide_Section_I_short_W;
MCNUM nslit = mccCurved_Guide_Section_I_short_nslit;
MCNUM d = mccCurved_Guide_Section_I_short_d;
MCNUM mleft = mccCurved_Guide_Section_I_short_mleft;
MCNUM mright = mccCurved_Guide_Section_I_short_mright;
MCNUM mtop = mccCurved_Guide_Section_I_short_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_short_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_short_nhslit;
MCNUM G = mccCurved_Guide_Section_I_short_G;
MCNUM aleft = mccCurved_Guide_Section_I_short_aleft;
MCNUM aright = mccCurved_Guide_Section_I_short_aright;
MCNUM atop = mccCurved_Guide_Section_I_short_atop;
MCNUM abottom = mccCurved_Guide_Section_I_short_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_short_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_short_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_short_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_short_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_short_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_short_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_short_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_short_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_short_nelements;
MCNUM nu = mccCurved_Guide_Section_I_short_nu;
MCNUM phase = mccCurved_Guide_Section_I_short_phase;
char* reflect = mccCurved_Guide_Section_I_short_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 78916 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_short=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[39]) fprintf(stderr, "Warning: No neutron could reach Component[39] Curved_Guide_Section_I_short\n");
    if (mcAbsorbProp[39]) fprintf(stderr, "Warning: %g events were removed in Component[39] Curved_Guide_Section_I_short=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[39]);
    if (!mcNCounter[40]) fprintf(stderr, "Warning: No neutron could reach Component[40] Gap3_start\n");
    if (mcAbsorbProp[40]) fprintf(stderr, "Warning: %g events were removed in Component[40] Gap3_start=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[40]);
    if (!mcNCounter[41]) fprintf(stderr, "Warning: No neutron could reach Component[41] Gap3_start_Lam\n");
    if (mcAbsorbProp[41]) fprintf(stderr, "Warning: %g events were removed in Component[41] Gap3_start_Lam=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[41]);
  /* User FINALLY code for component 'CGS1_end'. */
  SIG_MESSAGE("CGS1_end (Finally)");
#define mccompcurname  CGS1_end
#define mccompcurtype  PSD_monitor
#define mccompcurindex 42
#define PSD_N mccCGS1_end_PSD_N
#define PSD_p mccCGS1_end_PSD_p
#define PSD_p2 mccCGS1_end_PSD_p2
{   /* Declarations of CGS1_end=PSD_monitor() SETTING parameters. */
int nx = mccCGS1_end_nx;
int ny = mccCGS1_end_ny;
char* filename = mccCGS1_end_filename;
MCNUM xmin = mccCGS1_end_xmin;
MCNUM xmax = mccCGS1_end_xmax;
MCNUM ymin = mccCGS1_end_ymin;
MCNUM ymax = mccCGS1_end_ymax;
MCNUM xwidth = mccCGS1_end_xwidth;
MCNUM yheight = mccCGS1_end_yheight;
MCNUM restore_neutron = mccCGS1_end_restore_neutron;
#line 122 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  destroy_darr2d(PSD_N);
  destroy_darr2d(PSD_p);
  destroy_darr2d(PSD_p2);
}
#line 78955 "./SNS_BASIS.c"
}   /* End of CGS1_end=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[42]) fprintf(stderr, "Warning: No neutron could reach Component[42] CGS1_end\n");
    if (mcAbsorbProp[42]) fprintf(stderr, "Warning: %g events were removed in Component[42] CGS1_end=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[42]);
    if (!mcNCounter[43]) fprintf(stderr, "Warning: No neutron could reach Component[43] before_Chopper1_ToF\n");
    if (mcAbsorbProp[43]) fprintf(stderr, "Warning: %g events were removed in Component[43] before_Chopper1_ToF=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[43]);
    if (!mcNCounter[44]) fprintf(stderr, "Warning: No neutron could reach Component[44] before_Chopper1_ToF_Z\n");
    if (mcAbsorbProp[44]) fprintf(stderr, "Warning: %g events were removed in Component[44] before_Chopper1_ToF_Z=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[44]);
    if (!mcNCounter[45]) fprintf(stderr, "Warning: No neutron could reach Component[45] Chopper1\n");
    if (mcAbsorbProp[45]) fprintf(stderr, "Warning: %g events were removed in Component[45] Chopper1=DiskChopper()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[45]);
    if (!mcNCounter[46]) fprintf(stderr, "Warning: No neutron could reach Component[46] Chopper1_ToF\n");
    if (mcAbsorbProp[46]) fprintf(stderr, "Warning: %g events were removed in Component[46] Chopper1_ToF=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[46]);
    if (!mcNCounter[47]) fprintf(stderr, "Warning: No neutron could reach Component[47] Chopper1_ToF_Z\n");
    if (mcAbsorbProp[47]) fprintf(stderr, "Warning: %g events were removed in Component[47] Chopper1_ToF_Z=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[47]);
    if (!mcNCounter[48]) fprintf(stderr, "Warning: No neutron could reach Component[48] Gap3_end_Lam\n");
    if (mcAbsorbProp[48]) fprintf(stderr, "Warning: %g events were removed in Component[48] Gap3_end_Lam=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[48]);
  /* User FINALLY code for component 'Gap3_end_PSD'. */
  SIG_MESSAGE("Gap3_end_PSD (Finally)");
#define mccompcurname  Gap3_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 49
#define PSD_N mccGap3_end_PSD_PSD_N
#define PSD_p mccGap3_end_PSD_PSD_p
#define PSD_p2 mccGap3_end_PSD_PSD_p2
{   /* Declarations of Gap3_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap3_end_PSD_nx;
int ny = mccGap3_end_PSD_ny;
char* filename = mccGap3_end_PSD_filename;
MCNUM xmin = mccGap3_end_PSD_xmin;
MCNUM xmax = mccGap3_end_PSD_xmax;
MCNUM ymin = mccGap3_end_PSD_ymin;
MCNUM ymax = mccGap3_end_PSD_ymax;
MCNUM xwidth = mccGap3_end_PSD_xwidth;
MCNUM yheight = mccGap3_end_PSD_yheight;
MCNUM restore_neutron = mccGap3_end_PSD_restore_neutron;
#line 122 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  destroy_darr2d(PSD_N);
  destroy_darr2d(PSD_p);
  destroy_darr2d(PSD_p2);
}
#line 79003 "./SNS_BASIS.c"
}   /* End of Gap3_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[49]) fprintf(stderr, "Warning: No neutron could reach Component[49] Gap3_end_PSD\n");
    if (mcAbsorbProp[49]) fprintf(stderr, "Warning: %g events were removed in Component[49] Gap3_end_PSD=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[49]);
    if (!mcNCounter[50]) fprintf(stderr, "Warning: No neutron could reach Component[50] Gap3_end\n");
    if (mcAbsorbProp[50]) fprintf(stderr, "Warning: %g events were removed in Component[50] Gap3_end=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[50]);
  /* User FINALLY code for component 'Curved_Guide_Section_II'. */
  SIG_MESSAGE("Curved_Guide_Section_II (Finally)");
#define mccompcurname  Curved_Guide_Section_II
#define mccompcurtype  Guide_gravity
#define mccompcurindex 51
#define GVars mccCurved_Guide_Section_II_GVars
#define pTable mccCurved_Guide_Section_II_pTable
{   /* Declarations of Curved_Guide_Section_II=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_w1;
MCNUM h1 = mccCurved_Guide_Section_II_h1;
MCNUM w2 = mccCurved_Guide_Section_II_w2;
MCNUM h2 = mccCurved_Guide_Section_II_h2;
MCNUM l = mccCurved_Guide_Section_II_l;
MCNUM R0 = mccCurved_Guide_Section_II_R0;
MCNUM Qc = mccCurved_Guide_Section_II_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_alpha;
MCNUM m = mccCurved_Guide_Section_II_m;
MCNUM W = mccCurved_Guide_Section_II_W;
MCNUM nslit = mccCurved_Guide_Section_II_nslit;
MCNUM d = mccCurved_Guide_Section_II_d;
MCNUM mleft = mccCurved_Guide_Section_II_mleft;
MCNUM mright = mccCurved_Guide_Section_II_mright;
MCNUM mtop = mccCurved_Guide_Section_II_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_nhslit;
MCNUM G = mccCurved_Guide_Section_II_G;
MCNUM aleft = mccCurved_Guide_Section_II_aleft;
MCNUM aright = mccCurved_Guide_Section_II_aright;
MCNUM atop = mccCurved_Guide_Section_II_atop;
MCNUM abottom = mccCurved_Guide_Section_II_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_nelements;
MCNUM nu = mccCurved_Guide_Section_II_nu;
MCNUM phase = mccCurved_Guide_Section_II_phase;
char* reflect = mccCurved_Guide_Section_II_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 79065 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[51]) fprintf(stderr, "Warning: No neutron could reach Component[51] Curved_Guide_Section_II\n");
    if (mcAbsorbProp[51]) fprintf(stderr, "Warning: %g events were removed in Component[51] Curved_Guide_Section_II=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[51]);
  /* User FINALLY code for component 'Curved_Guide_Section_II_52'. */
  SIG_MESSAGE("Curved_Guide_Section_II_52 (Finally)");
#define mccompcurname  Curved_Guide_Section_II_52
#define mccompcurtype  Guide_gravity
#define mccompcurindex 52
#define GVars mccCurved_Guide_Section_II_52_GVars
#define pTable mccCurved_Guide_Section_II_52_pTable
{   /* Declarations of Curved_Guide_Section_II_52=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_52_w1;
MCNUM h1 = mccCurved_Guide_Section_II_52_h1;
MCNUM w2 = mccCurved_Guide_Section_II_52_w2;
MCNUM h2 = mccCurved_Guide_Section_II_52_h2;
MCNUM l = mccCurved_Guide_Section_II_52_l;
MCNUM R0 = mccCurved_Guide_Section_II_52_R0;
MCNUM Qc = mccCurved_Guide_Section_II_52_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_52_alpha;
MCNUM m = mccCurved_Guide_Section_II_52_m;
MCNUM W = mccCurved_Guide_Section_II_52_W;
MCNUM nslit = mccCurved_Guide_Section_II_52_nslit;
MCNUM d = mccCurved_Guide_Section_II_52_d;
MCNUM mleft = mccCurved_Guide_Section_II_52_mleft;
MCNUM mright = mccCurved_Guide_Section_II_52_mright;
MCNUM mtop = mccCurved_Guide_Section_II_52_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_52_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_52_nhslit;
MCNUM G = mccCurved_Guide_Section_II_52_G;
MCNUM aleft = mccCurved_Guide_Section_II_52_aleft;
MCNUM aright = mccCurved_Guide_Section_II_52_aright;
MCNUM atop = mccCurved_Guide_Section_II_52_atop;
MCNUM abottom = mccCurved_Guide_Section_II_52_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_52_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_52_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_52_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_52_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_52_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_52_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_52_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_52_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_52_nelements;
MCNUM nu = mccCurved_Guide_Section_II_52_nu;
MCNUM phase = mccCurved_Guide_Section_II_52_phase;
char* reflect = mccCurved_Guide_Section_II_52_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 79124 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II_52=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[52]) fprintf(stderr, "Warning: No neutron could reach Component[52] Curved_Guide_Section_II_52\n");
    if (mcAbsorbProp[52]) fprintf(stderr, "Warning: %g events were removed in Component[52] Curved_Guide_Section_II_52=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[52]);
  /* User FINALLY code for component 'Curved_Guide_Section_II_53'. */
  SIG_MESSAGE("Curved_Guide_Section_II_53 (Finally)");
#define mccompcurname  Curved_Guide_Section_II_53
#define mccompcurtype  Guide_gravity
#define mccompcurindex 53
#define GVars mccCurved_Guide_Section_II_53_GVars
#define pTable mccCurved_Guide_Section_II_53_pTable
{   /* Declarations of Curved_Guide_Section_II_53=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_53_w1;
MCNUM h1 = mccCurved_Guide_Section_II_53_h1;
MCNUM w2 = mccCurved_Guide_Section_II_53_w2;
MCNUM h2 = mccCurved_Guide_Section_II_53_h2;
MCNUM l = mccCurved_Guide_Section_II_53_l;
MCNUM R0 = mccCurved_Guide_Section_II_53_R0;
MCNUM Qc = mccCurved_Guide_Section_II_53_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_53_alpha;
MCNUM m = mccCurved_Guide_Section_II_53_m;
MCNUM W = mccCurved_Guide_Section_II_53_W;
MCNUM nslit = mccCurved_Guide_Section_II_53_nslit;
MCNUM d = mccCurved_Guide_Section_II_53_d;
MCNUM mleft = mccCurved_Guide_Section_II_53_mleft;
MCNUM mright = mccCurved_Guide_Section_II_53_mright;
MCNUM mtop = mccCurved_Guide_Section_II_53_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_53_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_53_nhslit;
MCNUM G = mccCurved_Guide_Section_II_53_G;
MCNUM aleft = mccCurved_Guide_Section_II_53_aleft;
MCNUM aright = mccCurved_Guide_Section_II_53_aright;
MCNUM atop = mccCurved_Guide_Section_II_53_atop;
MCNUM abottom = mccCurved_Guide_Section_II_53_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_53_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_53_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_53_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_53_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_53_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_53_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_53_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_53_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_53_nelements;
MCNUM nu = mccCurved_Guide_Section_II_53_nu;
MCNUM phase = mccCurved_Guide_Section_II_53_phase;
char* reflect = mccCurved_Guide_Section_II_53_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 79183 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II_53=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[53]) fprintf(stderr, "Warning: No neutron could reach Component[53] Curved_Guide_Section_II_53\n");
    if (mcAbsorbProp[53]) fprintf(stderr, "Warning: %g events were removed in Component[53] Curved_Guide_Section_II_53=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[53]);
  /* User FINALLY code for component 'Curved_Guide_Section_II_54'. */
  SIG_MESSAGE("Curved_Guide_Section_II_54 (Finally)");
#define mccompcurname  Curved_Guide_Section_II_54
#define mccompcurtype  Guide_gravity
#define mccompcurindex 54
#define GVars mccCurved_Guide_Section_II_54_GVars
#define pTable mccCurved_Guide_Section_II_54_pTable
{   /* Declarations of Curved_Guide_Section_II_54=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_54_w1;
MCNUM h1 = mccCurved_Guide_Section_II_54_h1;
MCNUM w2 = mccCurved_Guide_Section_II_54_w2;
MCNUM h2 = mccCurved_Guide_Section_II_54_h2;
MCNUM l = mccCurved_Guide_Section_II_54_l;
MCNUM R0 = mccCurved_Guide_Section_II_54_R0;
MCNUM Qc = mccCurved_Guide_Section_II_54_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_54_alpha;
MCNUM m = mccCurved_Guide_Section_II_54_m;
MCNUM W = mccCurved_Guide_Section_II_54_W;
MCNUM nslit = mccCurved_Guide_Section_II_54_nslit;
MCNUM d = mccCurved_Guide_Section_II_54_d;
MCNUM mleft = mccCurved_Guide_Section_II_54_mleft;
MCNUM mright = mccCurved_Guide_Section_II_54_mright;
MCNUM mtop = mccCurved_Guide_Section_II_54_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_54_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_54_nhslit;
MCNUM G = mccCurved_Guide_Section_II_54_G;
MCNUM aleft = mccCurved_Guide_Section_II_54_aleft;
MCNUM aright = mccCurved_Guide_Section_II_54_aright;
MCNUM atop = mccCurved_Guide_Section_II_54_atop;
MCNUM abottom = mccCurved_Guide_Section_II_54_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_54_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_54_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_54_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_54_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_54_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_54_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_54_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_54_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_54_nelements;
MCNUM nu = mccCurved_Guide_Section_II_54_nu;
MCNUM phase = mccCurved_Guide_Section_II_54_phase;
char* reflect = mccCurved_Guide_Section_II_54_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 79242 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II_54=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[54]) fprintf(stderr, "Warning: No neutron could reach Component[54] Curved_Guide_Section_II_54\n");
    if (mcAbsorbProp[54]) fprintf(stderr, "Warning: %g events were removed in Component[54] Curved_Guide_Section_II_54=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[54]);
  /* User FINALLY code for component 'Curved_Guide_Section_II_55'. */
  SIG_MESSAGE("Curved_Guide_Section_II_55 (Finally)");
#define mccompcurname  Curved_Guide_Section_II_55
#define mccompcurtype  Guide_gravity
#define mccompcurindex 55
#define GVars mccCurved_Guide_Section_II_55_GVars
#define pTable mccCurved_Guide_Section_II_55_pTable
{   /* Declarations of Curved_Guide_Section_II_55=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_55_w1;
MCNUM h1 = mccCurved_Guide_Section_II_55_h1;
MCNUM w2 = mccCurved_Guide_Section_II_55_w2;
MCNUM h2 = mccCurved_Guide_Section_II_55_h2;
MCNUM l = mccCurved_Guide_Section_II_55_l;
MCNUM R0 = mccCurved_Guide_Section_II_55_R0;
MCNUM Qc = mccCurved_Guide_Section_II_55_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_55_alpha;
MCNUM m = mccCurved_Guide_Section_II_55_m;
MCNUM W = mccCurved_Guide_Section_II_55_W;
MCNUM nslit = mccCurved_Guide_Section_II_55_nslit;
MCNUM d = mccCurved_Guide_Section_II_55_d;
MCNUM mleft = mccCurved_Guide_Section_II_55_mleft;
MCNUM mright = mccCurved_Guide_Section_II_55_mright;
MCNUM mtop = mccCurved_Guide_Section_II_55_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_55_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_55_nhslit;
MCNUM G = mccCurved_Guide_Section_II_55_G;
MCNUM aleft = mccCurved_Guide_Section_II_55_aleft;
MCNUM aright = mccCurved_Guide_Section_II_55_aright;
MCNUM atop = mccCurved_Guide_Section_II_55_atop;
MCNUM abottom = mccCurved_Guide_Section_II_55_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_55_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_55_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_55_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_55_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_55_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_55_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_55_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_55_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_55_nelements;
MCNUM nu = mccCurved_Guide_Section_II_55_nu;
MCNUM phase = mccCurved_Guide_Section_II_55_phase;
char* reflect = mccCurved_Guide_Section_II_55_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 79301 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II_55=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[55]) fprintf(stderr, "Warning: No neutron could reach Component[55] Curved_Guide_Section_II_55\n");
    if (mcAbsorbProp[55]) fprintf(stderr, "Warning: %g events were removed in Component[55] Curved_Guide_Section_II_55=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[55]);
  /* User FINALLY code for component 'Curved_Guide_Section_II_56'. */
  SIG_MESSAGE("Curved_Guide_Section_II_56 (Finally)");
#define mccompcurname  Curved_Guide_Section_II_56
#define mccompcurtype  Guide_gravity
#define mccompcurindex 56
#define GVars mccCurved_Guide_Section_II_56_GVars
#define pTable mccCurved_Guide_Section_II_56_pTable
{   /* Declarations of Curved_Guide_Section_II_56=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_56_w1;
MCNUM h1 = mccCurved_Guide_Section_II_56_h1;
MCNUM w2 = mccCurved_Guide_Section_II_56_w2;
MCNUM h2 = mccCurved_Guide_Section_II_56_h2;
MCNUM l = mccCurved_Guide_Section_II_56_l;
MCNUM R0 = mccCurved_Guide_Section_II_56_R0;
MCNUM Qc = mccCurved_Guide_Section_II_56_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_56_alpha;
MCNUM m = mccCurved_Guide_Section_II_56_m;
MCNUM W = mccCurved_Guide_Section_II_56_W;
MCNUM nslit = mccCurved_Guide_Section_II_56_nslit;
MCNUM d = mccCurved_Guide_Section_II_56_d;
MCNUM mleft = mccCurved_Guide_Section_II_56_mleft;
MCNUM mright = mccCurved_Guide_Section_II_56_mright;
MCNUM mtop = mccCurved_Guide_Section_II_56_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_56_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_56_nhslit;
MCNUM G = mccCurved_Guide_Section_II_56_G;
MCNUM aleft = mccCurved_Guide_Section_II_56_aleft;
MCNUM aright = mccCurved_Guide_Section_II_56_aright;
MCNUM atop = mccCurved_Guide_Section_II_56_atop;
MCNUM abottom = mccCurved_Guide_Section_II_56_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_56_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_56_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_56_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_56_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_56_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_56_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_56_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_56_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_56_nelements;
MCNUM nu = mccCurved_Guide_Section_II_56_nu;
MCNUM phase = mccCurved_Guide_Section_II_56_phase;
char* reflect = mccCurved_Guide_Section_II_56_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 79360 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II_56=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[56]) fprintf(stderr, "Warning: No neutron could reach Component[56] Curved_Guide_Section_II_56\n");
    if (mcAbsorbProp[56]) fprintf(stderr, "Warning: %g events were removed in Component[56] Curved_Guide_Section_II_56=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[56]);
  /* User FINALLY code for component 'Curved_Guide_Section_II_57'. */
  SIG_MESSAGE("Curved_Guide_Section_II_57 (Finally)");
#define mccompcurname  Curved_Guide_Section_II_57
#define mccompcurtype  Guide_gravity
#define mccompcurindex 57
#define GVars mccCurved_Guide_Section_II_57_GVars
#define pTable mccCurved_Guide_Section_II_57_pTable
{   /* Declarations of Curved_Guide_Section_II_57=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_57_w1;
MCNUM h1 = mccCurved_Guide_Section_II_57_h1;
MCNUM w2 = mccCurved_Guide_Section_II_57_w2;
MCNUM h2 = mccCurved_Guide_Section_II_57_h2;
MCNUM l = mccCurved_Guide_Section_II_57_l;
MCNUM R0 = mccCurved_Guide_Section_II_57_R0;
MCNUM Qc = mccCurved_Guide_Section_II_57_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_57_alpha;
MCNUM m = mccCurved_Guide_Section_II_57_m;
MCNUM W = mccCurved_Guide_Section_II_57_W;
MCNUM nslit = mccCurved_Guide_Section_II_57_nslit;
MCNUM d = mccCurved_Guide_Section_II_57_d;
MCNUM mleft = mccCurved_Guide_Section_II_57_mleft;
MCNUM mright = mccCurved_Guide_Section_II_57_mright;
MCNUM mtop = mccCurved_Guide_Section_II_57_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_57_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_57_nhslit;
MCNUM G = mccCurved_Guide_Section_II_57_G;
MCNUM aleft = mccCurved_Guide_Section_II_57_aleft;
MCNUM aright = mccCurved_Guide_Section_II_57_aright;
MCNUM atop = mccCurved_Guide_Section_II_57_atop;
MCNUM abottom = mccCurved_Guide_Section_II_57_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_57_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_57_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_57_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_57_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_57_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_57_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_57_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_57_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_57_nelements;
MCNUM nu = mccCurved_Guide_Section_II_57_nu;
MCNUM phase = mccCurved_Guide_Section_II_57_phase;
char* reflect = mccCurved_Guide_Section_II_57_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 79419 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II_57=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[57]) fprintf(stderr, "Warning: No neutron could reach Component[57] Curved_Guide_Section_II_57\n");
    if (mcAbsorbProp[57]) fprintf(stderr, "Warning: %g events were removed in Component[57] Curved_Guide_Section_II_57=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[57]);
  /* User FINALLY code for component 'Curved_Guide_Section_II_last'. */
  SIG_MESSAGE("Curved_Guide_Section_II_last (Finally)");
#define mccompcurname  Curved_Guide_Section_II_last
#define mccompcurtype  Guide_gravity
#define mccompcurindex 58
#define GVars mccCurved_Guide_Section_II_last_GVars
#define pTable mccCurved_Guide_Section_II_last_pTable
{   /* Declarations of Curved_Guide_Section_II_last=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_last_w1;
MCNUM h1 = mccCurved_Guide_Section_II_last_h1;
MCNUM w2 = mccCurved_Guide_Section_II_last_w2;
MCNUM h2 = mccCurved_Guide_Section_II_last_h2;
MCNUM l = mccCurved_Guide_Section_II_last_l;
MCNUM R0 = mccCurved_Guide_Section_II_last_R0;
MCNUM Qc = mccCurved_Guide_Section_II_last_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_last_alpha;
MCNUM m = mccCurved_Guide_Section_II_last_m;
MCNUM W = mccCurved_Guide_Section_II_last_W;
MCNUM nslit = mccCurved_Guide_Section_II_last_nslit;
MCNUM d = mccCurved_Guide_Section_II_last_d;
MCNUM mleft = mccCurved_Guide_Section_II_last_mleft;
MCNUM mright = mccCurved_Guide_Section_II_last_mright;
MCNUM mtop = mccCurved_Guide_Section_II_last_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_last_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_last_nhslit;
MCNUM G = mccCurved_Guide_Section_II_last_G;
MCNUM aleft = mccCurved_Guide_Section_II_last_aleft;
MCNUM aright = mccCurved_Guide_Section_II_last_aright;
MCNUM atop = mccCurved_Guide_Section_II_last_atop;
MCNUM abottom = mccCurved_Guide_Section_II_last_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_last_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_last_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_last_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_last_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_last_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_last_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_last_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_last_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_last_nelements;
MCNUM nu = mccCurved_Guide_Section_II_last_nu;
MCNUM phase = mccCurved_Guide_Section_II_last_phase;
char* reflect = mccCurved_Guide_Section_II_last_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 79478 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II_last=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[58]) fprintf(stderr, "Warning: No neutron could reach Component[58] Curved_Guide_Section_II_last\n");
    if (mcAbsorbProp[58]) fprintf(stderr, "Warning: %g events were removed in Component[58] Curved_Guide_Section_II_last=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[58]);
    if (!mcNCounter[59]) fprintf(stderr, "Warning: No neutron could reach Component[59] Gap4_start\n");
    if (mcAbsorbProp[59]) fprintf(stderr, "Warning: %g events were removed in Component[59] Gap4_start=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[59]);
    if (!mcNCounter[60]) fprintf(stderr, "Warning: No neutron could reach Component[60] Gap4_start_Lam\n");
    if (mcAbsorbProp[60]) fprintf(stderr, "Warning: %g events were removed in Component[60] Gap4_start_Lam=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[60]);
  /* User FINALLY code for component 'Gap4_start_PSD'. */
  SIG_MESSAGE("Gap4_start_PSD (Finally)");
#define mccompcurname  Gap4_start_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 61
#define PSD_N mccGap4_start_PSD_PSD_N
#define PSD_p mccGap4_start_PSD_PSD_p
#define PSD_p2 mccGap4_start_PSD_PSD_p2
{   /* Declarations of Gap4_start_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap4_start_PSD_nx;
int ny = mccGap4_start_PSD_ny;
char* filename = mccGap4_start_PSD_filename;
MCNUM xmin = mccGap4_start_PSD_xmin;
MCNUM xmax = mccGap4_start_PSD_xmax;
MCNUM ymin = mccGap4_start_PSD_ymin;
MCNUM ymax = mccGap4_start_PSD_ymax;
MCNUM xwidth = mccGap4_start_PSD_xwidth;
MCNUM yheight = mccGap4_start_PSD_yheight;
MCNUM restore_neutron = mccGap4_start_PSD_restore_neutron;
#line 122 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  destroy_darr2d(PSD_N);
  destroy_darr2d(PSD_p);
  destroy_darr2d(PSD_p2);
}
#line 79517 "./SNS_BASIS.c"
}   /* End of Gap4_start_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[61]) fprintf(stderr, "Warning: No neutron could reach Component[61] Gap4_start_PSD\n");
    if (mcAbsorbProp[61]) fprintf(stderr, "Warning: %g events were removed in Component[61] Gap4_start_PSD=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[61]);
    if (!mcNCounter[62]) fprintf(stderr, "Warning: No neutron could reach Component[62] before_Chopper2_ToF\n");
    if (mcAbsorbProp[62]) fprintf(stderr, "Warning: %g events were removed in Component[62] before_Chopper2_ToF=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[62]);
    if (!mcNCounter[63]) fprintf(stderr, "Warning: No neutron could reach Component[63] before_Chopper2_ToF_Z\n");
    if (mcAbsorbProp[63]) fprintf(stderr, "Warning: %g events were removed in Component[63] before_Chopper2_ToF_Z=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[63]);
    if (!mcNCounter[64]) fprintf(stderr, "Warning: No neutron could reach Component[64] Chopper2\n");
    if (mcAbsorbProp[64]) fprintf(stderr, "Warning: %g events were removed in Component[64] Chopper2=DiskChopper()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[64]);
    if (!mcNCounter[65]) fprintf(stderr, "Warning: No neutron could reach Component[65] Chopper2_ToF\n");
    if (mcAbsorbProp[65]) fprintf(stderr, "Warning: %g events were removed in Component[65] Chopper2_ToF=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[65]);
    if (!mcNCounter[66]) fprintf(stderr, "Warning: No neutron could reach Component[66] Chopper2_ToF_Z\n");
    if (mcAbsorbProp[66]) fprintf(stderr, "Warning: %g events were removed in Component[66] Chopper2_ToF_Z=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[66]);
    if (!mcNCounter[67]) fprintf(stderr, "Warning: No neutron could reach Component[67] Gap4_end_Lam\n");
    if (mcAbsorbProp[67]) fprintf(stderr, "Warning: %g events were removed in Component[67] Gap4_end_Lam=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[67]);
  /* User FINALLY code for component 'Gap4_end_PSD'. */
  SIG_MESSAGE("Gap4_end_PSD (Finally)");
#define mccompcurname  Gap4_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 68
#define PSD_N mccGap4_end_PSD_PSD_N
#define PSD_p mccGap4_end_PSD_PSD_p
#define PSD_p2 mccGap4_end_PSD_PSD_p2
{   /* Declarations of Gap4_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap4_end_PSD_nx;
int ny = mccGap4_end_PSD_ny;
char* filename = mccGap4_end_PSD_filename;
MCNUM xmin = mccGap4_end_PSD_xmin;
MCNUM xmax = mccGap4_end_PSD_xmax;
MCNUM ymin = mccGap4_end_PSD_ymin;
MCNUM ymax = mccGap4_end_PSD_ymax;
MCNUM xwidth = mccGap4_end_PSD_xwidth;
MCNUM yheight = mccGap4_end_PSD_yheight;
MCNUM restore_neutron = mccGap4_end_PSD_restore_neutron;
#line 122 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  destroy_darr2d(PSD_N);
  destroy_darr2d(PSD_p);
  destroy_darr2d(PSD_p2);
}
#line 79565 "./SNS_BASIS.c"
}   /* End of Gap4_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[68]) fprintf(stderr, "Warning: No neutron could reach Component[68] Gap4_end_PSD\n");
    if (mcAbsorbProp[68]) fprintf(stderr, "Warning: %g events were removed in Component[68] Gap4_end_PSD=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[68]);
    if (!mcNCounter[69]) fprintf(stderr, "Warning: No neutron could reach Component[69] Gap4_end\n");
    if (mcAbsorbProp[69]) fprintf(stderr, "Warning: %g events were removed in Component[69] Gap4_end=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[69]);
  /* User FINALLY code for component 'Curved_Guide_Section_III'. */
  SIG_MESSAGE("Curved_Guide_Section_III (Finally)");
#define mccompcurname  Curved_Guide_Section_III
#define mccompcurtype  Guide_gravity
#define mccompcurindex 70
#define GVars mccCurved_Guide_Section_III_GVars
#define pTable mccCurved_Guide_Section_III_pTable
{   /* Declarations of Curved_Guide_Section_III=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_w1;
MCNUM h1 = mccCurved_Guide_Section_III_h1;
MCNUM w2 = mccCurved_Guide_Section_III_w2;
MCNUM h2 = mccCurved_Guide_Section_III_h2;
MCNUM l = mccCurved_Guide_Section_III_l;
MCNUM R0 = mccCurved_Guide_Section_III_R0;
MCNUM Qc = mccCurved_Guide_Section_III_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_alpha;
MCNUM m = mccCurved_Guide_Section_III_m;
MCNUM W = mccCurved_Guide_Section_III_W;
MCNUM nslit = mccCurved_Guide_Section_III_nslit;
MCNUM d = mccCurved_Guide_Section_III_d;
MCNUM mleft = mccCurved_Guide_Section_III_mleft;
MCNUM mright = mccCurved_Guide_Section_III_mright;
MCNUM mtop = mccCurved_Guide_Section_III_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_nhslit;
MCNUM G = mccCurved_Guide_Section_III_G;
MCNUM aleft = mccCurved_Guide_Section_III_aleft;
MCNUM aright = mccCurved_Guide_Section_III_aright;
MCNUM atop = mccCurved_Guide_Section_III_atop;
MCNUM abottom = mccCurved_Guide_Section_III_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_nelements;
MCNUM nu = mccCurved_Guide_Section_III_nu;
MCNUM phase = mccCurved_Guide_Section_III_phase;
char* reflect = mccCurved_Guide_Section_III_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 79627 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[70]) fprintf(stderr, "Warning: No neutron could reach Component[70] Curved_Guide_Section_III\n");
    if (mcAbsorbProp[70]) fprintf(stderr, "Warning: %g events were removed in Component[70] Curved_Guide_Section_III=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[70]);
  /* User FINALLY code for component 'Curved_Guide_Section_III_71'. */
  SIG_MESSAGE("Curved_Guide_Section_III_71 (Finally)");
#define mccompcurname  Curved_Guide_Section_III_71
#define mccompcurtype  Guide_gravity
#define mccompcurindex 71
#define GVars mccCurved_Guide_Section_III_71_GVars
#define pTable mccCurved_Guide_Section_III_71_pTable
{   /* Declarations of Curved_Guide_Section_III_71=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_71_w1;
MCNUM h1 = mccCurved_Guide_Section_III_71_h1;
MCNUM w2 = mccCurved_Guide_Section_III_71_w2;
MCNUM h2 = mccCurved_Guide_Section_III_71_h2;
MCNUM l = mccCurved_Guide_Section_III_71_l;
MCNUM R0 = mccCurved_Guide_Section_III_71_R0;
MCNUM Qc = mccCurved_Guide_Section_III_71_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_71_alpha;
MCNUM m = mccCurved_Guide_Section_III_71_m;
MCNUM W = mccCurved_Guide_Section_III_71_W;
MCNUM nslit = mccCurved_Guide_Section_III_71_nslit;
MCNUM d = mccCurved_Guide_Section_III_71_d;
MCNUM mleft = mccCurved_Guide_Section_III_71_mleft;
MCNUM mright = mccCurved_Guide_Section_III_71_mright;
MCNUM mtop = mccCurved_Guide_Section_III_71_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_71_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_71_nhslit;
MCNUM G = mccCurved_Guide_Section_III_71_G;
MCNUM aleft = mccCurved_Guide_Section_III_71_aleft;
MCNUM aright = mccCurved_Guide_Section_III_71_aright;
MCNUM atop = mccCurved_Guide_Section_III_71_atop;
MCNUM abottom = mccCurved_Guide_Section_III_71_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_71_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_71_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_71_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_71_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_71_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_71_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_71_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_71_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_71_nelements;
MCNUM nu = mccCurved_Guide_Section_III_71_nu;
MCNUM phase = mccCurved_Guide_Section_III_71_phase;
char* reflect = mccCurved_Guide_Section_III_71_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 79686 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_71=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[71]) fprintf(stderr, "Warning: No neutron could reach Component[71] Curved_Guide_Section_III_71\n");
    if (mcAbsorbProp[71]) fprintf(stderr, "Warning: %g events were removed in Component[71] Curved_Guide_Section_III_71=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[71]);
  /* User FINALLY code for component 'Curved_Guide_Section_III_72'. */
  SIG_MESSAGE("Curved_Guide_Section_III_72 (Finally)");
#define mccompcurname  Curved_Guide_Section_III_72
#define mccompcurtype  Guide_gravity
#define mccompcurindex 72
#define GVars mccCurved_Guide_Section_III_72_GVars
#define pTable mccCurved_Guide_Section_III_72_pTable
{   /* Declarations of Curved_Guide_Section_III_72=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_72_w1;
MCNUM h1 = mccCurved_Guide_Section_III_72_h1;
MCNUM w2 = mccCurved_Guide_Section_III_72_w2;
MCNUM h2 = mccCurved_Guide_Section_III_72_h2;
MCNUM l = mccCurved_Guide_Section_III_72_l;
MCNUM R0 = mccCurved_Guide_Section_III_72_R0;
MCNUM Qc = mccCurved_Guide_Section_III_72_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_72_alpha;
MCNUM m = mccCurved_Guide_Section_III_72_m;
MCNUM W = mccCurved_Guide_Section_III_72_W;
MCNUM nslit = mccCurved_Guide_Section_III_72_nslit;
MCNUM d = mccCurved_Guide_Section_III_72_d;
MCNUM mleft = mccCurved_Guide_Section_III_72_mleft;
MCNUM mright = mccCurved_Guide_Section_III_72_mright;
MCNUM mtop = mccCurved_Guide_Section_III_72_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_72_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_72_nhslit;
MCNUM G = mccCurved_Guide_Section_III_72_G;
MCNUM aleft = mccCurved_Guide_Section_III_72_aleft;
MCNUM aright = mccCurved_Guide_Section_III_72_aright;
MCNUM atop = mccCurved_Guide_Section_III_72_atop;
MCNUM abottom = mccCurved_Guide_Section_III_72_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_72_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_72_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_72_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_72_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_72_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_72_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_72_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_72_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_72_nelements;
MCNUM nu = mccCurved_Guide_Section_III_72_nu;
MCNUM phase = mccCurved_Guide_Section_III_72_phase;
char* reflect = mccCurved_Guide_Section_III_72_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 79745 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_72=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[72]) fprintf(stderr, "Warning: No neutron could reach Component[72] Curved_Guide_Section_III_72\n");
    if (mcAbsorbProp[72]) fprintf(stderr, "Warning: %g events were removed in Component[72] Curved_Guide_Section_III_72=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[72]);
  /* User FINALLY code for component 'Curved_Guide_Section_III_73'. */
  SIG_MESSAGE("Curved_Guide_Section_III_73 (Finally)");
#define mccompcurname  Curved_Guide_Section_III_73
#define mccompcurtype  Guide_gravity
#define mccompcurindex 73
#define GVars mccCurved_Guide_Section_III_73_GVars
#define pTable mccCurved_Guide_Section_III_73_pTable
{   /* Declarations of Curved_Guide_Section_III_73=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_73_w1;
MCNUM h1 = mccCurved_Guide_Section_III_73_h1;
MCNUM w2 = mccCurved_Guide_Section_III_73_w2;
MCNUM h2 = mccCurved_Guide_Section_III_73_h2;
MCNUM l = mccCurved_Guide_Section_III_73_l;
MCNUM R0 = mccCurved_Guide_Section_III_73_R0;
MCNUM Qc = mccCurved_Guide_Section_III_73_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_73_alpha;
MCNUM m = mccCurved_Guide_Section_III_73_m;
MCNUM W = mccCurved_Guide_Section_III_73_W;
MCNUM nslit = mccCurved_Guide_Section_III_73_nslit;
MCNUM d = mccCurved_Guide_Section_III_73_d;
MCNUM mleft = mccCurved_Guide_Section_III_73_mleft;
MCNUM mright = mccCurved_Guide_Section_III_73_mright;
MCNUM mtop = mccCurved_Guide_Section_III_73_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_73_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_73_nhslit;
MCNUM G = mccCurved_Guide_Section_III_73_G;
MCNUM aleft = mccCurved_Guide_Section_III_73_aleft;
MCNUM aright = mccCurved_Guide_Section_III_73_aright;
MCNUM atop = mccCurved_Guide_Section_III_73_atop;
MCNUM abottom = mccCurved_Guide_Section_III_73_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_73_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_73_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_73_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_73_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_73_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_73_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_73_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_73_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_73_nelements;
MCNUM nu = mccCurved_Guide_Section_III_73_nu;
MCNUM phase = mccCurved_Guide_Section_III_73_phase;
char* reflect = mccCurved_Guide_Section_III_73_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 79804 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_73=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[73]) fprintf(stderr, "Warning: No neutron could reach Component[73] Curved_Guide_Section_III_73\n");
    if (mcAbsorbProp[73]) fprintf(stderr, "Warning: %g events were removed in Component[73] Curved_Guide_Section_III_73=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[73]);
  /* User FINALLY code for component 'Curved_Guide_Section_III_74'. */
  SIG_MESSAGE("Curved_Guide_Section_III_74 (Finally)");
#define mccompcurname  Curved_Guide_Section_III_74
#define mccompcurtype  Guide_gravity
#define mccompcurindex 74
#define GVars mccCurved_Guide_Section_III_74_GVars
#define pTable mccCurved_Guide_Section_III_74_pTable
{   /* Declarations of Curved_Guide_Section_III_74=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_74_w1;
MCNUM h1 = mccCurved_Guide_Section_III_74_h1;
MCNUM w2 = mccCurved_Guide_Section_III_74_w2;
MCNUM h2 = mccCurved_Guide_Section_III_74_h2;
MCNUM l = mccCurved_Guide_Section_III_74_l;
MCNUM R0 = mccCurved_Guide_Section_III_74_R0;
MCNUM Qc = mccCurved_Guide_Section_III_74_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_74_alpha;
MCNUM m = mccCurved_Guide_Section_III_74_m;
MCNUM W = mccCurved_Guide_Section_III_74_W;
MCNUM nslit = mccCurved_Guide_Section_III_74_nslit;
MCNUM d = mccCurved_Guide_Section_III_74_d;
MCNUM mleft = mccCurved_Guide_Section_III_74_mleft;
MCNUM mright = mccCurved_Guide_Section_III_74_mright;
MCNUM mtop = mccCurved_Guide_Section_III_74_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_74_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_74_nhslit;
MCNUM G = mccCurved_Guide_Section_III_74_G;
MCNUM aleft = mccCurved_Guide_Section_III_74_aleft;
MCNUM aright = mccCurved_Guide_Section_III_74_aright;
MCNUM atop = mccCurved_Guide_Section_III_74_atop;
MCNUM abottom = mccCurved_Guide_Section_III_74_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_74_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_74_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_74_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_74_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_74_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_74_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_74_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_74_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_74_nelements;
MCNUM nu = mccCurved_Guide_Section_III_74_nu;
MCNUM phase = mccCurved_Guide_Section_III_74_phase;
char* reflect = mccCurved_Guide_Section_III_74_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 79863 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_74=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[74]) fprintf(stderr, "Warning: No neutron could reach Component[74] Curved_Guide_Section_III_74\n");
    if (mcAbsorbProp[74]) fprintf(stderr, "Warning: %g events were removed in Component[74] Curved_Guide_Section_III_74=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[74]);
  /* User FINALLY code for component 'Curved_Guide_Section_III_75'. */
  SIG_MESSAGE("Curved_Guide_Section_III_75 (Finally)");
#define mccompcurname  Curved_Guide_Section_III_75
#define mccompcurtype  Guide_gravity
#define mccompcurindex 75
#define GVars mccCurved_Guide_Section_III_75_GVars
#define pTable mccCurved_Guide_Section_III_75_pTable
{   /* Declarations of Curved_Guide_Section_III_75=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_75_w1;
MCNUM h1 = mccCurved_Guide_Section_III_75_h1;
MCNUM w2 = mccCurved_Guide_Section_III_75_w2;
MCNUM h2 = mccCurved_Guide_Section_III_75_h2;
MCNUM l = mccCurved_Guide_Section_III_75_l;
MCNUM R0 = mccCurved_Guide_Section_III_75_R0;
MCNUM Qc = mccCurved_Guide_Section_III_75_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_75_alpha;
MCNUM m = mccCurved_Guide_Section_III_75_m;
MCNUM W = mccCurved_Guide_Section_III_75_W;
MCNUM nslit = mccCurved_Guide_Section_III_75_nslit;
MCNUM d = mccCurved_Guide_Section_III_75_d;
MCNUM mleft = mccCurved_Guide_Section_III_75_mleft;
MCNUM mright = mccCurved_Guide_Section_III_75_mright;
MCNUM mtop = mccCurved_Guide_Section_III_75_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_75_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_75_nhslit;
MCNUM G = mccCurved_Guide_Section_III_75_G;
MCNUM aleft = mccCurved_Guide_Section_III_75_aleft;
MCNUM aright = mccCurved_Guide_Section_III_75_aright;
MCNUM atop = mccCurved_Guide_Section_III_75_atop;
MCNUM abottom = mccCurved_Guide_Section_III_75_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_75_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_75_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_75_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_75_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_75_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_75_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_75_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_75_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_75_nelements;
MCNUM nu = mccCurved_Guide_Section_III_75_nu;
MCNUM phase = mccCurved_Guide_Section_III_75_phase;
char* reflect = mccCurved_Guide_Section_III_75_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 79922 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_75=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[75]) fprintf(stderr, "Warning: No neutron could reach Component[75] Curved_Guide_Section_III_75\n");
    if (mcAbsorbProp[75]) fprintf(stderr, "Warning: %g events were removed in Component[75] Curved_Guide_Section_III_75=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[75]);
  /* User FINALLY code for component 'Curved_Guide_Section_III_76'. */
  SIG_MESSAGE("Curved_Guide_Section_III_76 (Finally)");
#define mccompcurname  Curved_Guide_Section_III_76
#define mccompcurtype  Guide_gravity
#define mccompcurindex 76
#define GVars mccCurved_Guide_Section_III_76_GVars
#define pTable mccCurved_Guide_Section_III_76_pTable
{   /* Declarations of Curved_Guide_Section_III_76=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_76_w1;
MCNUM h1 = mccCurved_Guide_Section_III_76_h1;
MCNUM w2 = mccCurved_Guide_Section_III_76_w2;
MCNUM h2 = mccCurved_Guide_Section_III_76_h2;
MCNUM l = mccCurved_Guide_Section_III_76_l;
MCNUM R0 = mccCurved_Guide_Section_III_76_R0;
MCNUM Qc = mccCurved_Guide_Section_III_76_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_76_alpha;
MCNUM m = mccCurved_Guide_Section_III_76_m;
MCNUM W = mccCurved_Guide_Section_III_76_W;
MCNUM nslit = mccCurved_Guide_Section_III_76_nslit;
MCNUM d = mccCurved_Guide_Section_III_76_d;
MCNUM mleft = mccCurved_Guide_Section_III_76_mleft;
MCNUM mright = mccCurved_Guide_Section_III_76_mright;
MCNUM mtop = mccCurved_Guide_Section_III_76_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_76_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_76_nhslit;
MCNUM G = mccCurved_Guide_Section_III_76_G;
MCNUM aleft = mccCurved_Guide_Section_III_76_aleft;
MCNUM aright = mccCurved_Guide_Section_III_76_aright;
MCNUM atop = mccCurved_Guide_Section_III_76_atop;
MCNUM abottom = mccCurved_Guide_Section_III_76_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_76_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_76_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_76_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_76_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_76_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_76_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_76_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_76_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_76_nelements;
MCNUM nu = mccCurved_Guide_Section_III_76_nu;
MCNUM phase = mccCurved_Guide_Section_III_76_phase;
char* reflect = mccCurved_Guide_Section_III_76_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 79981 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_76=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[76]) fprintf(stderr, "Warning: No neutron could reach Component[76] Curved_Guide_Section_III_76\n");
    if (mcAbsorbProp[76]) fprintf(stderr, "Warning: %g events were removed in Component[76] Curved_Guide_Section_III_76=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[76]);
  /* User FINALLY code for component 'Curved_Guide_Section_III_77'. */
  SIG_MESSAGE("Curved_Guide_Section_III_77 (Finally)");
#define mccompcurname  Curved_Guide_Section_III_77
#define mccompcurtype  Guide_gravity
#define mccompcurindex 77
#define GVars mccCurved_Guide_Section_III_77_GVars
#define pTable mccCurved_Guide_Section_III_77_pTable
{   /* Declarations of Curved_Guide_Section_III_77=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_77_w1;
MCNUM h1 = mccCurved_Guide_Section_III_77_h1;
MCNUM w2 = mccCurved_Guide_Section_III_77_w2;
MCNUM h2 = mccCurved_Guide_Section_III_77_h2;
MCNUM l = mccCurved_Guide_Section_III_77_l;
MCNUM R0 = mccCurved_Guide_Section_III_77_R0;
MCNUM Qc = mccCurved_Guide_Section_III_77_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_77_alpha;
MCNUM m = mccCurved_Guide_Section_III_77_m;
MCNUM W = mccCurved_Guide_Section_III_77_W;
MCNUM nslit = mccCurved_Guide_Section_III_77_nslit;
MCNUM d = mccCurved_Guide_Section_III_77_d;
MCNUM mleft = mccCurved_Guide_Section_III_77_mleft;
MCNUM mright = mccCurved_Guide_Section_III_77_mright;
MCNUM mtop = mccCurved_Guide_Section_III_77_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_77_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_77_nhslit;
MCNUM G = mccCurved_Guide_Section_III_77_G;
MCNUM aleft = mccCurved_Guide_Section_III_77_aleft;
MCNUM aright = mccCurved_Guide_Section_III_77_aright;
MCNUM atop = mccCurved_Guide_Section_III_77_atop;
MCNUM abottom = mccCurved_Guide_Section_III_77_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_77_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_77_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_77_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_77_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_77_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_77_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_77_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_77_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_77_nelements;
MCNUM nu = mccCurved_Guide_Section_III_77_nu;
MCNUM phase = mccCurved_Guide_Section_III_77_phase;
char* reflect = mccCurved_Guide_Section_III_77_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 80040 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_77=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[77]) fprintf(stderr, "Warning: No neutron could reach Component[77] Curved_Guide_Section_III_77\n");
    if (mcAbsorbProp[77]) fprintf(stderr, "Warning: %g events were removed in Component[77] Curved_Guide_Section_III_77=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[77]);
  /* User FINALLY code for component 'Curved_Guide_Section_III_78'. */
  SIG_MESSAGE("Curved_Guide_Section_III_78 (Finally)");
#define mccompcurname  Curved_Guide_Section_III_78
#define mccompcurtype  Guide_gravity
#define mccompcurindex 78
#define GVars mccCurved_Guide_Section_III_78_GVars
#define pTable mccCurved_Guide_Section_III_78_pTable
{   /* Declarations of Curved_Guide_Section_III_78=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_78_w1;
MCNUM h1 = mccCurved_Guide_Section_III_78_h1;
MCNUM w2 = mccCurved_Guide_Section_III_78_w2;
MCNUM h2 = mccCurved_Guide_Section_III_78_h2;
MCNUM l = mccCurved_Guide_Section_III_78_l;
MCNUM R0 = mccCurved_Guide_Section_III_78_R0;
MCNUM Qc = mccCurved_Guide_Section_III_78_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_78_alpha;
MCNUM m = mccCurved_Guide_Section_III_78_m;
MCNUM W = mccCurved_Guide_Section_III_78_W;
MCNUM nslit = mccCurved_Guide_Section_III_78_nslit;
MCNUM d = mccCurved_Guide_Section_III_78_d;
MCNUM mleft = mccCurved_Guide_Section_III_78_mleft;
MCNUM mright = mccCurved_Guide_Section_III_78_mright;
MCNUM mtop = mccCurved_Guide_Section_III_78_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_78_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_78_nhslit;
MCNUM G = mccCurved_Guide_Section_III_78_G;
MCNUM aleft = mccCurved_Guide_Section_III_78_aleft;
MCNUM aright = mccCurved_Guide_Section_III_78_aright;
MCNUM atop = mccCurved_Guide_Section_III_78_atop;
MCNUM abottom = mccCurved_Guide_Section_III_78_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_78_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_78_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_78_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_78_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_78_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_78_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_78_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_78_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_78_nelements;
MCNUM nu = mccCurved_Guide_Section_III_78_nu;
MCNUM phase = mccCurved_Guide_Section_III_78_phase;
char* reflect = mccCurved_Guide_Section_III_78_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 80099 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_78=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[78]) fprintf(stderr, "Warning: No neutron could reach Component[78] Curved_Guide_Section_III_78\n");
    if (mcAbsorbProp[78]) fprintf(stderr, "Warning: %g events were removed in Component[78] Curved_Guide_Section_III_78=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[78]);
  /* User FINALLY code for component 'Curved_Guide_Section_III_79'. */
  SIG_MESSAGE("Curved_Guide_Section_III_79 (Finally)");
#define mccompcurname  Curved_Guide_Section_III_79
#define mccompcurtype  Guide_gravity
#define mccompcurindex 79
#define GVars mccCurved_Guide_Section_III_79_GVars
#define pTable mccCurved_Guide_Section_III_79_pTable
{   /* Declarations of Curved_Guide_Section_III_79=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_79_w1;
MCNUM h1 = mccCurved_Guide_Section_III_79_h1;
MCNUM w2 = mccCurved_Guide_Section_III_79_w2;
MCNUM h2 = mccCurved_Guide_Section_III_79_h2;
MCNUM l = mccCurved_Guide_Section_III_79_l;
MCNUM R0 = mccCurved_Guide_Section_III_79_R0;
MCNUM Qc = mccCurved_Guide_Section_III_79_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_79_alpha;
MCNUM m = mccCurved_Guide_Section_III_79_m;
MCNUM W = mccCurved_Guide_Section_III_79_W;
MCNUM nslit = mccCurved_Guide_Section_III_79_nslit;
MCNUM d = mccCurved_Guide_Section_III_79_d;
MCNUM mleft = mccCurved_Guide_Section_III_79_mleft;
MCNUM mright = mccCurved_Guide_Section_III_79_mright;
MCNUM mtop = mccCurved_Guide_Section_III_79_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_79_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_79_nhslit;
MCNUM G = mccCurved_Guide_Section_III_79_G;
MCNUM aleft = mccCurved_Guide_Section_III_79_aleft;
MCNUM aright = mccCurved_Guide_Section_III_79_aright;
MCNUM atop = mccCurved_Guide_Section_III_79_atop;
MCNUM abottom = mccCurved_Guide_Section_III_79_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_79_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_79_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_79_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_79_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_79_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_79_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_79_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_79_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_79_nelements;
MCNUM nu = mccCurved_Guide_Section_III_79_nu;
MCNUM phase = mccCurved_Guide_Section_III_79_phase;
char* reflect = mccCurved_Guide_Section_III_79_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 80158 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_79=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[79]) fprintf(stderr, "Warning: No neutron could reach Component[79] Curved_Guide_Section_III_79\n");
    if (mcAbsorbProp[79]) fprintf(stderr, "Warning: %g events were removed in Component[79] Curved_Guide_Section_III_79=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[79]);
  /* User FINALLY code for component 'Curved_Guide_Section_III_short'. */
  SIG_MESSAGE("Curved_Guide_Section_III_short (Finally)");
#define mccompcurname  Curved_Guide_Section_III_short
#define mccompcurtype  Guide_gravity
#define mccompcurindex 80
#define GVars mccCurved_Guide_Section_III_short_GVars
#define pTable mccCurved_Guide_Section_III_short_pTable
{   /* Declarations of Curved_Guide_Section_III_short=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_short_w1;
MCNUM h1 = mccCurved_Guide_Section_III_short_h1;
MCNUM w2 = mccCurved_Guide_Section_III_short_w2;
MCNUM h2 = mccCurved_Guide_Section_III_short_h2;
MCNUM l = mccCurved_Guide_Section_III_short_l;
MCNUM R0 = mccCurved_Guide_Section_III_short_R0;
MCNUM Qc = mccCurved_Guide_Section_III_short_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_short_alpha;
MCNUM m = mccCurved_Guide_Section_III_short_m;
MCNUM W = mccCurved_Guide_Section_III_short_W;
MCNUM nslit = mccCurved_Guide_Section_III_short_nslit;
MCNUM d = mccCurved_Guide_Section_III_short_d;
MCNUM mleft = mccCurved_Guide_Section_III_short_mleft;
MCNUM mright = mccCurved_Guide_Section_III_short_mright;
MCNUM mtop = mccCurved_Guide_Section_III_short_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_short_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_short_nhslit;
MCNUM G = mccCurved_Guide_Section_III_short_G;
MCNUM aleft = mccCurved_Guide_Section_III_short_aleft;
MCNUM aright = mccCurved_Guide_Section_III_short_aright;
MCNUM atop = mccCurved_Guide_Section_III_short_atop;
MCNUM abottom = mccCurved_Guide_Section_III_short_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_short_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_short_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_short_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_short_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_short_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_short_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_short_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_short_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_short_nelements;
MCNUM nu = mccCurved_Guide_Section_III_short_nu;
MCNUM phase = mccCurved_Guide_Section_III_short_phase;
char* reflect = mccCurved_Guide_Section_III_short_reflect;
#line 563 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 80217 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_short=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[80]) fprintf(stderr, "Warning: No neutron could reach Component[80] Curved_Guide_Section_III_short\n");
    if (mcAbsorbProp[80]) fprintf(stderr, "Warning: %g events were removed in Component[80] Curved_Guide_Section_III_short=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[80]);
    if (!mcNCounter[81]) fprintf(stderr, "Warning: No neutron could reach Component[81] CGS3_end_ToF\n");
    if (mcAbsorbProp[81]) fprintf(stderr, "Warning: %g events were removed in Component[81] CGS3_end_ToF=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[81]);
    if (!mcNCounter[82]) fprintf(stderr, "Warning: No neutron could reach Component[82] CGS3_end_ToF_Z\n");
    if (mcAbsorbProp[82]) fprintf(stderr, "Warning: %g events were removed in Component[82] CGS3_end_ToF_Z=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[82]);
    if (!mcNCounter[83]) fprintf(stderr, "Warning: No neutron could reach Component[83] CGS3_end_Lam\n");
    if (mcAbsorbProp[83]) fprintf(stderr, "Warning: %g events were removed in Component[83] CGS3_end_Lam=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[83]);
    if (!mcNCounter[84]) fprintf(stderr, "Warning: No neutron could reach Component[84] Straight_Guide_Section_I\n");
    if (mcAbsorbProp[84]) fprintf(stderr, "Warning: %g events were removed in Component[84] Straight_Guide_Section_I=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[84]);
    if (!mcNCounter[85]) fprintf(stderr, "Warning: No neutron could reach Component[85] Gap5_start\n");
    if (mcAbsorbProp[85]) fprintf(stderr, "Warning: %g events were removed in Component[85] Gap5_start=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[85]);
    if (!mcNCounter[86]) fprintf(stderr, "Warning: No neutron could reach Component[86] Gap5_start_ToF\n");
    if (mcAbsorbProp[86]) fprintf(stderr, "Warning: %g events were removed in Component[86] Gap5_start_ToF=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[86]);
    if (!mcNCounter[87]) fprintf(stderr, "Warning: No neutron could reach Component[87] Gap5_start_ToF_Z\n");
    if (mcAbsorbProp[87]) fprintf(stderr, "Warning: %g events were removed in Component[87] Gap5_start_ToF_Z=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[87]);
    if (!mcNCounter[88]) fprintf(stderr, "Warning: No neutron could reach Component[88] Gap5_start_Lam\n");
    if (mcAbsorbProp[88]) fprintf(stderr, "Warning: %g events were removed in Component[88] Gap5_start_Lam=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[88]);
  /* User FINALLY code for component 'Gap5_start_PSD'. */
  SIG_MESSAGE("Gap5_start_PSD (Finally)");
#define mccompcurname  Gap5_start_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 89
#define PSD_N mccGap5_start_PSD_PSD_N
#define PSD_p mccGap5_start_PSD_PSD_p
#define PSD_p2 mccGap5_start_PSD_PSD_p2
{   /* Declarations of Gap5_start_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap5_start_PSD_nx;
int ny = mccGap5_start_PSD_ny;
char* filename = mccGap5_start_PSD_filename;
MCNUM xmin = mccGap5_start_PSD_xmin;
MCNUM xmax = mccGap5_start_PSD_xmax;
MCNUM ymin = mccGap5_start_PSD_ymin;
MCNUM ymax = mccGap5_start_PSD_ymax;
MCNUM xwidth = mccGap5_start_PSD_xwidth;
MCNUM yheight = mccGap5_start_PSD_yheight;
MCNUM restore_neutron = mccGap5_start_PSD_restore_neutron;
#line 122 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  destroy_darr2d(PSD_N);
  destroy_darr2d(PSD_p);
  destroy_darr2d(PSD_p2);
}
#line 80268 "./SNS_BASIS.c"
}   /* End of Gap5_start_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[89]) fprintf(stderr, "Warning: No neutron could reach Component[89] Gap5_start_PSD\n");
    if (mcAbsorbProp[89]) fprintf(stderr, "Warning: %g events were removed in Component[89] Gap5_start_PSD=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[89]);
    if (!mcNCounter[90]) fprintf(stderr, "Warning: No neutron could reach Component[90] Chopper3\n");
    if (mcAbsorbProp[90]) fprintf(stderr, "Warning: %g events were removed in Component[90] Chopper3=DiskChopper()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[90]);
    if (!mcNCounter[91]) fprintf(stderr, "Warning: No neutron could reach Component[91] Chopper3_ToF\n");
    if (mcAbsorbProp[91]) fprintf(stderr, "Warning: %g events were removed in Component[91] Chopper3_ToF=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[91]);
    if (!mcNCounter[92]) fprintf(stderr, "Warning: No neutron could reach Component[92] Chopper3_ToF_Z\n");
    if (mcAbsorbProp[92]) fprintf(stderr, "Warning: %g events were removed in Component[92] Chopper3_ToF_Z=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[92]);
    if (!mcNCounter[93]) fprintf(stderr, "Warning: No neutron could reach Component[93] Gap5_end_Lam\n");
    if (mcAbsorbProp[93]) fprintf(stderr, "Warning: %g events were removed in Component[93] Gap5_end_Lam=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[93]);
  /* User FINALLY code for component 'Gap5_end_PSD'. */
  SIG_MESSAGE("Gap5_end_PSD (Finally)");
#define mccompcurname  Gap5_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 94
#define PSD_N mccGap5_end_PSD_PSD_N
#define PSD_p mccGap5_end_PSD_PSD_p
#define PSD_p2 mccGap5_end_PSD_PSD_p2
{   /* Declarations of Gap5_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap5_end_PSD_nx;
int ny = mccGap5_end_PSD_ny;
char* filename = mccGap5_end_PSD_filename;
MCNUM xmin = mccGap5_end_PSD_xmin;
MCNUM xmax = mccGap5_end_PSD_xmax;
MCNUM ymin = mccGap5_end_PSD_ymin;
MCNUM ymax = mccGap5_end_PSD_ymax;
MCNUM xwidth = mccGap5_end_PSD_xwidth;
MCNUM yheight = mccGap5_end_PSD_yheight;
MCNUM restore_neutron = mccGap5_end_PSD_restore_neutron;
#line 122 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  destroy_darr2d(PSD_N);
  destroy_darr2d(PSD_p);
  destroy_darr2d(PSD_p2);
}
#line 80312 "./SNS_BASIS.c"
}   /* End of Gap5_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[94]) fprintf(stderr, "Warning: No neutron could reach Component[94] Gap5_end_PSD\n");
    if (mcAbsorbProp[94]) fprintf(stderr, "Warning: %g events were removed in Component[94] Gap5_end_PSD=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[94]);
    if (!mcNCounter[95]) fprintf(stderr, "Warning: No neutron could reach Component[95] Gap5_end\n");
    if (mcAbsorbProp[95]) fprintf(stderr, "Warning: %g events were removed in Component[95] Gap5_end=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[95]);
    if (!mcNCounter[96]) fprintf(stderr, "Warning: No neutron could reach Component[96] Straight_Guide_Section_II\n");
    if (mcAbsorbProp[96]) fprintf(stderr, "Warning: %g events were removed in Component[96] Straight_Guide_Section_II=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[96]);
    if (!mcNCounter[97]) fprintf(stderr, "Warning: No neutron could reach Component[97] SGS2_end_Lam\n");
    if (mcAbsorbProp[97]) fprintf(stderr, "Warning: %g events were removed in Component[97] SGS2_end_Lam=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[97]);
  /* User FINALLY code for component 'SGS2_end_PSD'. */
  SIG_MESSAGE("SGS2_end_PSD (Finally)");
#define mccompcurname  SGS2_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 98
#define PSD_N mccSGS2_end_PSD_PSD_N
#define PSD_p mccSGS2_end_PSD_PSD_p
#define PSD_p2 mccSGS2_end_PSD_PSD_p2
{   /* Declarations of SGS2_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccSGS2_end_PSD_nx;
int ny = mccSGS2_end_PSD_ny;
char* filename = mccSGS2_end_PSD_filename;
MCNUM xmin = mccSGS2_end_PSD_xmin;
MCNUM xmax = mccSGS2_end_PSD_xmax;
MCNUM ymin = mccSGS2_end_PSD_ymin;
MCNUM ymax = mccSGS2_end_PSD_ymax;
MCNUM xwidth = mccSGS2_end_PSD_xwidth;
MCNUM yheight = mccSGS2_end_PSD_yheight;
MCNUM restore_neutron = mccSGS2_end_PSD_restore_neutron;
#line 122 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  destroy_darr2d(PSD_N);
  destroy_darr2d(PSD_p);
  destroy_darr2d(PSD_p2);
}
#line 80354 "./SNS_BASIS.c"
}   /* End of SGS2_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[98]) fprintf(stderr, "Warning: No neutron could reach Component[98] SGS2_end_PSD\n");
    if (mcAbsorbProp[98]) fprintf(stderr, "Warning: %g events were removed in Component[98] SGS2_end_PSD=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[98]);
    if (!mcNCounter[99]) fprintf(stderr, "Warning: No neutron could reach Component[99] Straight_Guide_Section_III\n");
    if (mcAbsorbProp[99]) fprintf(stderr, "Warning: %g events were removed in Component[99] Straight_Guide_Section_III=Guide()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[99]);
    if (!mcNCounter[100]) fprintf(stderr, "Warning: No neutron could reach Component[100] SG3_end_ToF\n");
    if (mcAbsorbProp[100]) fprintf(stderr, "Warning: %g events were removed in Component[100] SG3_end_ToF=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[100]);
    if (!mcNCounter[101]) fprintf(stderr, "Warning: No neutron could reach Component[101] SG3_end_ToF_Z\n");
    if (mcAbsorbProp[101]) fprintf(stderr, "Warning: %g events were removed in Component[101] SG3_end_ToF_Z=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[101]);
    if (!mcNCounter[102]) fprintf(stderr, "Warning: No neutron could reach Component[102] SG3_end_Lam\n");
    if (mcAbsorbProp[102]) fprintf(stderr, "Warning: %g events were removed in Component[102] SG3_end_Lam=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[102]);
  /* User FINALLY code for component 'SG3_end_PSD'. */
  SIG_MESSAGE("SG3_end_PSD (Finally)");
#define mccompcurname  SG3_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 103
#define PSD_N mccSG3_end_PSD_PSD_N
#define PSD_p mccSG3_end_PSD_PSD_p
#define PSD_p2 mccSG3_end_PSD_PSD_p2
{   /* Declarations of SG3_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccSG3_end_PSD_nx;
int ny = mccSG3_end_PSD_ny;
char* filename = mccSG3_end_PSD_filename;
MCNUM xmin = mccSG3_end_PSD_xmin;
MCNUM xmax = mccSG3_end_PSD_xmax;
MCNUM ymin = mccSG3_end_PSD_ymin;
MCNUM ymax = mccSG3_end_PSD_ymax;
MCNUM xwidth = mccSG3_end_PSD_xwidth;
MCNUM yheight = mccSG3_end_PSD_yheight;
MCNUM restore_neutron = mccSG3_end_PSD_restore_neutron;
#line 122 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  destroy_darr2d(PSD_N);
  destroy_darr2d(PSD_p);
  destroy_darr2d(PSD_p2);
}
#line 80398 "./SNS_BASIS.c"
}   /* End of SG3_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[103]) fprintf(stderr, "Warning: No neutron could reach Component[103] SG3_end_PSD\n");
    if (mcAbsorbProp[103]) fprintf(stderr, "Warning: %g events were removed in Component[103] SG3_end_PSD=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[103]);
    if (!mcNCounter[104]) fprintf(stderr, "Warning: No neutron could reach Component[104] Funnel_1\n");
    if (mcAbsorbProp[104]) fprintf(stderr, "Warning: %g events were removed in Component[104] Funnel_1=Guide_m()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[104]);
  /* User FINALLY code for component 'PSD_post_funnel1'. */
  SIG_MESSAGE("PSD_post_funnel1 (Finally)");
#define mccompcurname  PSD_post_funnel1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 105
#define PSD_N mccPSD_post_funnel1_PSD_N
#define PSD_p mccPSD_post_funnel1_PSD_p
#define PSD_p2 mccPSD_post_funnel1_PSD_p2
{   /* Declarations of PSD_post_funnel1=PSD_monitor() SETTING parameters. */
int nx = mccPSD_post_funnel1_nx;
int ny = mccPSD_post_funnel1_ny;
char* filename = mccPSD_post_funnel1_filename;
MCNUM xmin = mccPSD_post_funnel1_xmin;
MCNUM xmax = mccPSD_post_funnel1_xmax;
MCNUM ymin = mccPSD_post_funnel1_ymin;
MCNUM ymax = mccPSD_post_funnel1_ymax;
MCNUM xwidth = mccPSD_post_funnel1_xwidth;
MCNUM yheight = mccPSD_post_funnel1_yheight;
MCNUM restore_neutron = mccPSD_post_funnel1_restore_neutron;
#line 122 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  destroy_darr2d(PSD_N);
  destroy_darr2d(PSD_p);
  destroy_darr2d(PSD_p2);
}
#line 80436 "./SNS_BASIS.c"
}   /* End of PSD_post_funnel1=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[105]) fprintf(stderr, "Warning: No neutron could reach Component[105] PSD_post_funnel1\n");
    if (mcAbsorbProp[105]) fprintf(stderr, "Warning: %g events were removed in Component[105] PSD_post_funnel1=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[105]);
    if (!mcNCounter[106]) fprintf(stderr, "Warning: No neutron could reach Component[106] Funnel_2\n");
    if (mcAbsorbProp[106]) fprintf(stderr, "Warning: %g events were removed in Component[106] Funnel_2=Guide_m()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[106]);
  /* User FINALLY code for component 'PSD_post_funnel2'. */
  SIG_MESSAGE("PSD_post_funnel2 (Finally)");
#define mccompcurname  PSD_post_funnel2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 107
#define PSD_N mccPSD_post_funnel2_PSD_N
#define PSD_p mccPSD_post_funnel2_PSD_p
#define PSD_p2 mccPSD_post_funnel2_PSD_p2
{   /* Declarations of PSD_post_funnel2=PSD_monitor() SETTING parameters. */
int nx = mccPSD_post_funnel2_nx;
int ny = mccPSD_post_funnel2_ny;
char* filename = mccPSD_post_funnel2_filename;
MCNUM xmin = mccPSD_post_funnel2_xmin;
MCNUM xmax = mccPSD_post_funnel2_xmax;
MCNUM ymin = mccPSD_post_funnel2_ymin;
MCNUM ymax = mccPSD_post_funnel2_ymax;
MCNUM xwidth = mccPSD_post_funnel2_xwidth;
MCNUM yheight = mccPSD_post_funnel2_yheight;
MCNUM restore_neutron = mccPSD_post_funnel2_restore_neutron;
#line 122 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  destroy_darr2d(PSD_N);
  destroy_darr2d(PSD_p);
  destroy_darr2d(PSD_p2);
}
#line 80474 "./SNS_BASIS.c"
}   /* End of PSD_post_funnel2=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[107]) fprintf(stderr, "Warning: No neutron could reach Component[107] PSD_post_funnel2\n");
    if (mcAbsorbProp[107]) fprintf(stderr, "Warning: %g events were removed in Component[107] PSD_post_funnel2=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[107]);
    if (!mcNCounter[108]) fprintf(stderr, "Warning: No neutron could reach Component[108] Funnel_3\n");
    if (mcAbsorbProp[108]) fprintf(stderr, "Warning: %g events were removed in Component[108] Funnel_3=Guide_m()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[108]);
  /* User FINALLY code for component 'PSD_post_funnel3'. */
  SIG_MESSAGE("PSD_post_funnel3 (Finally)");
#define mccompcurname  PSD_post_funnel3
#define mccompcurtype  PSD_monitor
#define mccompcurindex 109
#define PSD_N mccPSD_post_funnel3_PSD_N
#define PSD_p mccPSD_post_funnel3_PSD_p
#define PSD_p2 mccPSD_post_funnel3_PSD_p2
{   /* Declarations of PSD_post_funnel3=PSD_monitor() SETTING parameters. */
int nx = mccPSD_post_funnel3_nx;
int ny = mccPSD_post_funnel3_ny;
char* filename = mccPSD_post_funnel3_filename;
MCNUM xmin = mccPSD_post_funnel3_xmin;
MCNUM xmax = mccPSD_post_funnel3_xmax;
MCNUM ymin = mccPSD_post_funnel3_ymin;
MCNUM ymax = mccPSD_post_funnel3_ymax;
MCNUM xwidth = mccPSD_post_funnel3_xwidth;
MCNUM yheight = mccPSD_post_funnel3_yheight;
MCNUM restore_neutron = mccPSD_post_funnel3_restore_neutron;
#line 122 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  destroy_darr2d(PSD_N);
  destroy_darr2d(PSD_p);
  destroy_darr2d(PSD_p2);
}
#line 80512 "./SNS_BASIS.c"
}   /* End of PSD_post_funnel3=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[109]) fprintf(stderr, "Warning: No neutron could reach Component[109] PSD_post_funnel3\n");
    if (mcAbsorbProp[109]) fprintf(stderr, "Warning: %g events were removed in Component[109] PSD_post_funnel3=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[109]);
    if (!mcNCounter[110]) fprintf(stderr, "Warning: No neutron could reach Component[110] Funnel_4\n");
    if (mcAbsorbProp[110]) fprintf(stderr, "Warning: %g events were removed in Component[110] Funnel_4=Guide_m()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[110]);
  /* User FINALLY code for component 'PSD_post_funnel4'. */
  SIG_MESSAGE("PSD_post_funnel4 (Finally)");
#define mccompcurname  PSD_post_funnel4
#define mccompcurtype  PSD_monitor
#define mccompcurindex 111
#define PSD_N mccPSD_post_funnel4_PSD_N
#define PSD_p mccPSD_post_funnel4_PSD_p
#define PSD_p2 mccPSD_post_funnel4_PSD_p2
{   /* Declarations of PSD_post_funnel4=PSD_monitor() SETTING parameters. */
int nx = mccPSD_post_funnel4_nx;
int ny = mccPSD_post_funnel4_ny;
char* filename = mccPSD_post_funnel4_filename;
MCNUM xmin = mccPSD_post_funnel4_xmin;
MCNUM xmax = mccPSD_post_funnel4_xmax;
MCNUM ymin = mccPSD_post_funnel4_ymin;
MCNUM ymax = mccPSD_post_funnel4_ymax;
MCNUM xwidth = mccPSD_post_funnel4_xwidth;
MCNUM yheight = mccPSD_post_funnel4_yheight;
MCNUM restore_neutron = mccPSD_post_funnel4_restore_neutron;
#line 122 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  destroy_darr2d(PSD_N);
  destroy_darr2d(PSD_p);
  destroy_darr2d(PSD_p2);
}
#line 80550 "./SNS_BASIS.c"
}   /* End of PSD_post_funnel4=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[111]) fprintf(stderr, "Warning: No neutron could reach Component[111] PSD_post_funnel4\n");
    if (mcAbsorbProp[111]) fprintf(stderr, "Warning: %g events were removed in Component[111] PSD_post_funnel4=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[111]);
    if (!mcNCounter[112]) fprintf(stderr, "Warning: No neutron could reach Component[112] Guide_End_ToF\n");
    if (mcAbsorbProp[112]) fprintf(stderr, "Warning: %g events were removed in Component[112] Guide_End_ToF=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[112]);
    if (!mcNCounter[113]) fprintf(stderr, "Warning: No neutron could reach Component[113] Guide_End_ToF_Z\n");
    if (mcAbsorbProp[113]) fprintf(stderr, "Warning: %g events were removed in Component[113] Guide_End_ToF_Z=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[113]);
    if (!mcNCounter[114]) fprintf(stderr, "Warning: No neutron could reach Component[114] Guide_end_Lam\n");
    if (mcAbsorbProp[114]) fprintf(stderr, "Warning: %g events were removed in Component[114] Guide_end_Lam=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[114]);
  /* User FINALLY code for component 'Guide_end_divx'. */
  SIG_MESSAGE("Guide_end_divx (Finally)");
#define mccompcurname  Guide_end_divx
#define mccompcurtype  Monitor_nD
#define mccompcurindex 115
#define user1 mccGuide_end_divx_user1
#define user2 mccGuide_end_divx_user2
#define user3 mccGuide_end_divx_user3
#define DEFS mccGuide_end_divx_DEFS
#define Vars mccGuide_end_divx_Vars
#define detector mccGuide_end_divx_detector
#define offdata mccGuide_end_divx_offdata
{   /* Declarations of Guide_end_divx=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccGuide_end_divx_xwidth;
MCNUM yheight = mccGuide_end_divx_yheight;
MCNUM zdepth = mccGuide_end_divx_zdepth;
MCNUM xmin = mccGuide_end_divx_xmin;
MCNUM xmax = mccGuide_end_divx_xmax;
MCNUM ymin = mccGuide_end_divx_ymin;
MCNUM ymax = mccGuide_end_divx_ymax;
MCNUM zmin = mccGuide_end_divx_zmin;
MCNUM zmax = mccGuide_end_divx_zmax;
MCNUM bins = mccGuide_end_divx_bins;
MCNUM min = mccGuide_end_divx_min;
MCNUM max = mccGuide_end_divx_max;
MCNUM restore_neutron = mccGuide_end_divx_restore_neutron;
MCNUM radius = mccGuide_end_divx_radius;
char* options = mccGuide_end_divx_options;
char* filename = mccGuide_end_divx_filename;
char* geometry = mccGuide_end_divx_geometry;
char* username1 = mccGuide_end_divx_username1;
char* username2 = mccGuide_end_divx_username2;
char* username3 = mccGuide_end_divx_username3;
int nowritefile = mccGuide_end_divx_nowritefile;
#line 489 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  /* free pointers */
  Monitor_nD_Finally(&DEFS, &Vars);
}
#line 80606 "./SNS_BASIS.c"
}   /* End of Guide_end_divx=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[115]) fprintf(stderr, "Warning: No neutron could reach Component[115] Guide_end_divx\n");
    if (mcAbsorbProp[115]) fprintf(stderr, "Warning: %g events were removed in Component[115] Guide_end_divx=Monitor_nD()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[115]);
  /* User FINALLY code for component 'Guide_end_divy'. */
  SIG_MESSAGE("Guide_end_divy (Finally)");
#define mccompcurname  Guide_end_divy
#define mccompcurtype  Monitor_nD
#define mccompcurindex 116
#define user1 mccGuide_end_divy_user1
#define user2 mccGuide_end_divy_user2
#define user3 mccGuide_end_divy_user3
#define DEFS mccGuide_end_divy_DEFS
#define Vars mccGuide_end_divy_Vars
#define detector mccGuide_end_divy_detector
#define offdata mccGuide_end_divy_offdata
{   /* Declarations of Guide_end_divy=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccGuide_end_divy_xwidth;
MCNUM yheight = mccGuide_end_divy_yheight;
MCNUM zdepth = mccGuide_end_divy_zdepth;
MCNUM xmin = mccGuide_end_divy_xmin;
MCNUM xmax = mccGuide_end_divy_xmax;
MCNUM ymin = mccGuide_end_divy_ymin;
MCNUM ymax = mccGuide_end_divy_ymax;
MCNUM zmin = mccGuide_end_divy_zmin;
MCNUM zmax = mccGuide_end_divy_zmax;
MCNUM bins = mccGuide_end_divy_bins;
MCNUM min = mccGuide_end_divy_min;
MCNUM max = mccGuide_end_divy_max;
MCNUM restore_neutron = mccGuide_end_divy_restore_neutron;
MCNUM radius = mccGuide_end_divy_radius;
char* options = mccGuide_end_divy_options;
char* filename = mccGuide_end_divy_filename;
char* geometry = mccGuide_end_divy_geometry;
char* username1 = mccGuide_end_divy_username1;
char* username2 = mccGuide_end_divy_username2;
char* username3 = mccGuide_end_divy_username3;
int nowritefile = mccGuide_end_divy_nowritefile;
#line 489 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  /* free pointers */
  Monitor_nD_Finally(&DEFS, &Vars);
}
#line 80660 "./SNS_BASIS.c"
}   /* End of Guide_end_divy=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[116]) fprintf(stderr, "Warning: No neutron could reach Component[116] Guide_end_divy\n");
    if (mcAbsorbProp[116]) fprintf(stderr, "Warning: %g events were removed in Component[116] Guide_end_divy=Monitor_nD()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[116]);
  /* User FINALLY code for component 'Guide_end_PSD'. */
  SIG_MESSAGE("Guide_end_PSD (Finally)");
#define mccompcurname  Guide_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 117
#define PSD_N mccGuide_end_PSD_PSD_N
#define PSD_p mccGuide_end_PSD_PSD_p
#define PSD_p2 mccGuide_end_PSD_PSD_p2
{   /* Declarations of Guide_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGuide_end_PSD_nx;
int ny = mccGuide_end_PSD_ny;
char* filename = mccGuide_end_PSD_filename;
MCNUM xmin = mccGuide_end_PSD_xmin;
MCNUM xmax = mccGuide_end_PSD_xmax;
MCNUM ymin = mccGuide_end_PSD_ymin;
MCNUM ymax = mccGuide_end_PSD_ymax;
MCNUM xwidth = mccGuide_end_PSD_xwidth;
MCNUM yheight = mccGuide_end_PSD_yheight;
MCNUM restore_neutron = mccGuide_end_PSD_restore_neutron;
#line 122 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  destroy_darr2d(PSD_N);
  destroy_darr2d(PSD_p);
  destroy_darr2d(PSD_p2);
}
#line 80700 "./SNS_BASIS.c"
}   /* End of Guide_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[117]) fprintf(stderr, "Warning: No neutron could reach Component[117] Guide_end_PSD\n");
    if (mcAbsorbProp[117]) fprintf(stderr, "Warning: %g events were removed in Component[117] Guide_end_PSD=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[117]);
    if (!mcNCounter[118]) fprintf(stderr, "Warning: No neutron could reach Component[118] Sample_split\n");
    if (mcAbsorbProp[118]) fprintf(stderr, "Warning: %g events were removed in Component[118] Sample_split=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[118]);
  /* User FINALLY code for component 'SamplePos'. */
  SIG_MESSAGE("SamplePos (Finally)");
#define mccompcurname  SamplePos
#define mccompcurtype  PSD_monitor
#define mccompcurindex 119
#define PSD_N mccSamplePos_PSD_N
#define PSD_p mccSamplePos_PSD_p
#define PSD_p2 mccSamplePos_PSD_p2
{   /* Declarations of SamplePos=PSD_monitor() SETTING parameters. */
int nx = mccSamplePos_nx;
int ny = mccSamplePos_ny;
char* filename = mccSamplePos_filename;
MCNUM xmin = mccSamplePos_xmin;
MCNUM xmax = mccSamplePos_xmax;
MCNUM ymin = mccSamplePos_ymin;
MCNUM ymax = mccSamplePos_ymax;
MCNUM xwidth = mccSamplePos_xwidth;
MCNUM yheight = mccSamplePos_yheight;
MCNUM restore_neutron = mccSamplePos_restore_neutron;
#line 122 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  destroy_darr2d(PSD_N);
  destroy_darr2d(PSD_p);
  destroy_darr2d(PSD_p2);
}
#line 80738 "./SNS_BASIS.c"
}   /* End of SamplePos=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[119]) fprintf(stderr, "Warning: No neutron could reach Component[119] SamplePos\n");
    if (mcAbsorbProp[119]) fprintf(stderr, "Warning: %g events were removed in Component[119] SamplePos=PSD_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[119]);
  /* User FINALLY code for component 'Sample'. */
  SIG_MESSAGE("Sample (Finally)");
#define mccompcurname  Sample
#define mccompcurtype  Isotropic_Sqw
#define mccompcurindex 120
#define powder_format mccSample_powder_format
#define VarSqw mccSample_VarSqw
#define columns mccSample_columns
#define offdata mccSample_offdata
{   /* Declarations of Sample=Isotropic_Sqw() SETTING parameters. */
char* Sqw_coh = mccSample_Sqw_coh;
char* Sqw_inc = mccSample_Sqw_inc;
char* geometry = mccSample_geometry;
MCNUM radius = mccSample_radius;
MCNUM thickness = mccSample_thickness;
MCNUM xwidth = mccSample_xwidth;
MCNUM yheight = mccSample_yheight;
MCNUM zdepth = mccSample_zdepth;
MCNUM threshold = mccSample_threshold;
int order = mccSample_order;
MCNUM T = mccSample_T;
MCNUM verbose = mccSample_verbose;
MCNUM d_phi = mccSample_d_phi;
int concentric = mccSample_concentric;
MCNUM rho = mccSample_rho;
MCNUM sigma_abs = mccSample_sigma_abs;
MCNUM sigma_coh = mccSample_sigma_coh;
MCNUM sigma_inc = mccSample_sigma_inc;
MCNUM classical = mccSample_classical;
MCNUM powder_Dd = mccSample_powder_Dd;
MCNUM powder_DW = mccSample_powder_DW;
MCNUM powder_Vc = mccSample_powder_Vc;
MCNUM density = mccSample_density;
MCNUM weight = mccSample_weight;
MCNUM p_interact = mccSample_p_interact;
MCNUM norm = mccSample_norm;
MCNUM powder_barns = mccSample_powder_barns;
char* quantum_correction = mccSample_quantum_correction;
#line 2701 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../samples/Isotropic_Sqw.comp"
{
  int  k;

  if (VarSqw.s_coh > 0 || VarSqw.s_inc > 0)
  for (k=0; k < 2; k++) {
    struct Sqw_Data_struct Data_sqw;

    Data_sqw =  (k == 0 ? VarSqw.Data_coh : VarSqw.Data_inc);
    /* Data_sqw->Sqw has already been freed at end of INIT */
    Table_Free(&(Data_sqw.iqSq));

    if (Data_sqw.SW)           free(Data_sqw.SW);
    if (Data_sqw.SQW)          free(Data_sqw.SQW);
    if (Data_sqw.SW_lookup)    free(Data_sqw.SW_lookup);
    if (Data_sqw.QW_lookup)    free(Data_sqw.QW_lookup);
  } /* end for */

#ifdef USE_MPI
  if (mpi_node_count > 1) {
    double tmp;
    tmp = (double)VarSqw.neutron_removed; mc_MPI_Sum(&tmp, 1); VarSqw.neutron_removed=(long)tmp;
    tmp = (double)VarSqw.neutron_exit;    mc_MPI_Sum(&tmp, 1); VarSqw.neutron_exit=(long)tmp;
    tmp = (double)VarSqw.neutron_pmult;   mc_MPI_Sum(&tmp, 1); VarSqw.neutron_pmult=(long)tmp;
    mc_MPI_Sum(&VarSqw.mean_scatt, 1);
    mc_MPI_Sum(&VarSqw.psum_scatt, 1);
    mc_MPI_Sum(&VarSqw.mean_abs, 1);
    mc_MPI_Sum(&VarSqw.single_coh, 1);
    mc_MPI_Sum(&VarSqw.single_inc, 1);
    mc_MPI_Sum(&VarSqw.multi, 1);
  }
#endif
  MPI_MASTER(
  if (VarSqw.neutron_removed)
    printf("Isotropic_Sqw: %s: %li neutron events (out of %li) that should have\n"
           "               scattered were transmitted because scattering conditions\n"
           "WARNING        could not be satisfied after %i tries.\n",
          NAME_CURRENT_COMP, VarSqw.neutron_removed,
          VarSqw.neutron_exit+VarSqw.neutron_removed, VarSqw.maxloop);
  if (VarSqw.neutron_pmult)
    printf("Isotropic_Sqw: %s: %li neutron events (out of %li) reached\n"
           "WARNING        unrealistic weight. The S(q,w) norm might be too high.\n",
          NAME_CURRENT_COMP, VarSqw.neutron_pmult, VarSqw.neutron_exit);

  if (VarSqw.verbose_output >= 1 && VarSqw.psum_scatt > 0) {
    printf("Isotropic_Sqw: %s: Scattering fraction=%g of incoming intensity\n"
           "               Absorption fraction           =%g\n",
           NAME_CURRENT_COMP,
           VarSqw.mean_scatt/VarSqw.psum_scatt, VarSqw.mean_abs/VarSqw.psum_scatt);
    printf("               Single   scattering intensity =%g (coh=%g inc=%g)\n"
           "               Multiple scattering intensity =%g\n",
           VarSqw.single_coh+VarSqw.single_inc, VarSqw.single_coh, VarSqw.single_inc, VarSqw.multi);
    );
  }

/* end FINALLY */
}
#line 80844 "./SNS_BASIS.c"
}   /* End of Sample=Isotropic_Sqw() SETTING parameter declarations. */
#undef offdata
#undef columns
#undef VarSqw
#undef powder_format
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[120]) fprintf(stderr, "Warning: No neutron could reach Component[120] Sample\n");
    if (mcAbsorbProp[120]) fprintf(stderr, "Warning: %g events were removed in Component[120] Sample=Isotropic_Sqw()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[120]);
    if (!mcNCounter[121]) fprintf(stderr, "Warning: No neutron could reach Component[121] An1_rot_axis\n");
    if (mcAbsorbProp[121]) fprintf(stderr, "Warning: %g events were removed in Component[121] An1_rot_axis=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[121]);
    if (!mcNCounter[122]) fprintf(stderr, "Warning: No neutron could reach Component[122] An2_rot_axis\n");
    if (mcAbsorbProp[122]) fprintf(stderr, "Warning: %g events were removed in Component[122] An2_rot_axis=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[122]);
    if (!mcNCounter[123]) fprintf(stderr, "Warning: No neutron could reach Component[123] An3_rot_axis\n");
    if (mcAbsorbProp[123]) fprintf(stderr, "Warning: %g events were removed in Component[123] An3_rot_axis=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[123]);
    if (!mcNCounter[124]) fprintf(stderr, "Warning: No neutron could reach Component[124] An1_ToF\n");
    if (mcAbsorbProp[124]) fprintf(stderr, "Warning: %g events were removed in Component[124] An1_ToF=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[124]);
    if (!mcNCounter[125]) fprintf(stderr, "Warning: No neutron could reach Component[125] An1_ToF_variable_range\n");
    if (mcAbsorbProp[125]) fprintf(stderr, "Warning: %g events were removed in Component[125] An1_ToF_variable_range=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[125]);
    if (!mcNCounter[126]) fprintf(stderr, "Warning: No neutron could reach Component[126] An1_Lam\n");
    if (mcAbsorbProp[126]) fprintf(stderr, "Warning: %g events were removed in Component[126] An1_Lam=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[126]);
    if (!mcNCounter[127]) fprintf(stderr, "Warning: No neutron could reach Component[127] An1_Lam_variable_range\n");
    if (mcAbsorbProp[127]) fprintf(stderr, "Warning: %g events were removed in Component[127] An1_Lam_variable_range=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[127]);
    if (!mcNCounter[128]) fprintf(stderr, "Warning: No neutron could reach Component[128] An1_E\n");
    if (mcAbsorbProp[128]) fprintf(stderr, "Warning: %g events were removed in Component[128] An1_E=E_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[128]);
    if (!mcNCounter[129]) fprintf(stderr, "Warning: No neutron could reach Component[129] An1_E_variable_range\n");
    if (mcAbsorbProp[129]) fprintf(stderr, "Warning: %g events were removed in Component[129] An1_E_variable_range=E_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[129]);
    if (!mcNCounter[130]) fprintf(stderr, "Warning: No neutron could reach Component[130] An1_rot_axis2\n");
    if (mcAbsorbProp[130]) fprintf(stderr, "Warning: %g events were removed in Component[130] An1_rot_axis2=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[130]);
    if (!mcNCounter[131]) fprintf(stderr, "Warning: No neutron could reach Component[131] An2_rot_axis2\n");
    if (mcAbsorbProp[131]) fprintf(stderr, "Warning: %g events were removed in Component[131] An2_rot_axis2=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[131]);
    if (!mcNCounter[132]) fprintf(stderr, "Warning: No neutron could reach Component[132] An3_rot_axis2\n");
    if (mcAbsorbProp[132]) fprintf(stderr, "Warning: %g events were removed in Component[132] An3_rot_axis2=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[132]);
    if (!mcNCounter[133]) fprintf(stderr, "Warning: No neutron could reach Component[133] An1\n");
    if (mcAbsorbProp[133]) fprintf(stderr, "Warning: %g events were removed in Component[133] An1=Spherical_Backscattering_Analyser()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[133]);
    if (!mcNCounter[134]) fprintf(stderr, "Warning: No neutron could reach Component[134] An2\n");
    if (mcAbsorbProp[134]) fprintf(stderr, "Warning: %g events were removed in Component[134] An2=Spherical_Backscattering_Analyser()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[134]);
    if (!mcNCounter[135]) fprintf(stderr, "Warning: No neutron could reach Component[135] An3\n");
    if (mcAbsorbProp[135]) fprintf(stderr, "Warning: %g events were removed in Component[135] An3=Spherical_Backscattering_Analyser()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[135]);
    if (!mcNCounter[136]) fprintf(stderr, "Warning: No neutron could reach Component[136] ArmForDet1\n");
    if (mcAbsorbProp[136]) fprintf(stderr, "Warning: %g events were removed in Component[136] ArmForDet1=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[136]);
    if (!mcNCounter[137]) fprintf(stderr, "Warning: No neutron could reach Component[137] Det1_E\n");
    if (mcAbsorbProp[137]) fprintf(stderr, "Warning: %g events were removed in Component[137] Det1_E=E_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[137]);
    if (!mcNCounter[138]) fprintf(stderr, "Warning: No neutron could reach Component[138] Det1_E_variable_range\n");
    if (mcAbsorbProp[138]) fprintf(stderr, "Warning: %g events were removed in Component[138] Det1_E_variable_range=E_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[138]);
    if (!mcNCounter[139]) fprintf(stderr, "Warning: No neutron could reach Component[139] Det1_Lam\n");
    if (mcAbsorbProp[139]) fprintf(stderr, "Warning: %g events were removed in Component[139] Det1_Lam=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[139]);
    if (!mcNCounter[140]) fprintf(stderr, "Warning: No neutron could reach Component[140] Det1_Lam_variable_range\n");
    if (mcAbsorbProp[140]) fprintf(stderr, "Warning: %g events were removed in Component[140] Det1_Lam_variable_range=L_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[140]);
    if (!mcNCounter[141]) fprintf(stderr, "Warning: No neutron could reach Component[141] Det1_ToF\n");
    if (mcAbsorbProp[141]) fprintf(stderr, "Warning: %g events were removed in Component[141] Det1_ToF=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[141]);
    if (!mcNCounter[142]) fprintf(stderr, "Warning: No neutron could reach Component[142] Det1_ToF_variable_range\n");
    if (mcAbsorbProp[142]) fprintf(stderr, "Warning: %g events were removed in Component[142] Det1_ToF_variable_range=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[142]);
    if (!mcNCounter[143]) fprintf(stderr, "Warning: No neutron could reach Component[143] Det1_ToF_variable_range_lessnL\n");
    if (mcAbsorbProp[143]) fprintf(stderr, "Warning: %g events were removed in Component[143] Det1_ToF_variable_range_lessnL=TOF_monitor()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[143]);
  /* User FINALLY code for component 'PSDcyl'. */
  SIG_MESSAGE("PSDcyl (Finally)");
#define mccompcurname  PSDcyl
#define mccompcurtype  Monitor_nD
#define mccompcurindex 144
#define user1 mccPSDcyl_user1
#define user2 mccPSDcyl_user2
#define user3 mccPSDcyl_user3
#define DEFS mccPSDcyl_DEFS
#define Vars mccPSDcyl_Vars
#define detector mccPSDcyl_detector
#define offdata mccPSDcyl_offdata
{   /* Declarations of PSDcyl=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccPSDcyl_xwidth;
MCNUM yheight = mccPSDcyl_yheight;
MCNUM zdepth = mccPSDcyl_zdepth;
MCNUM xmin = mccPSDcyl_xmin;
MCNUM xmax = mccPSDcyl_xmax;
MCNUM ymin = mccPSDcyl_ymin;
MCNUM ymax = mccPSDcyl_ymax;
MCNUM zmin = mccPSDcyl_zmin;
MCNUM zmax = mccPSDcyl_zmax;
MCNUM bins = mccPSDcyl_bins;
MCNUM min = mccPSDcyl_min;
MCNUM max = mccPSDcyl_max;
MCNUM restore_neutron = mccPSDcyl_restore_neutron;
MCNUM radius = mccPSDcyl_radius;
char* options = mccPSDcyl_options;
char* filename = mccPSDcyl_filename;
char* geometry = mccPSDcyl_geometry;
char* username1 = mccPSDcyl_username1;
char* username2 = mccPSDcyl_username2;
char* username3 = mccPSDcyl_username3;
int nowritefile = mccPSDcyl_nowritefile;
#line 489 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  /* free pointers */
  Monitor_nD_Finally(&DEFS, &Vars);
}
#line 80941 "./SNS_BASIS.c"
}   /* End of PSDcyl=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[144]) fprintf(stderr, "Warning: No neutron could reach Component[144] PSDcyl\n");
    if (mcAbsorbProp[144]) fprintf(stderr, "Warning: %g events were removed in Component[144] PSDcyl=Monitor_nD()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[144]);
  /* User FINALLY code for component 'TOFcyl'. */
  SIG_MESSAGE("TOFcyl (Finally)");
#define mccompcurname  TOFcyl
#define mccompcurtype  Monitor_nD
#define mccompcurindex 145
#define user1 mccTOFcyl_user1
#define user2 mccTOFcyl_user2
#define user3 mccTOFcyl_user3
#define DEFS mccTOFcyl_DEFS
#define Vars mccTOFcyl_Vars
#define detector mccTOFcyl_detector
#define offdata mccTOFcyl_offdata
{   /* Declarations of TOFcyl=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccTOFcyl_xwidth;
MCNUM yheight = mccTOFcyl_yheight;
MCNUM zdepth = mccTOFcyl_zdepth;
MCNUM xmin = mccTOFcyl_xmin;
MCNUM xmax = mccTOFcyl_xmax;
MCNUM ymin = mccTOFcyl_ymin;
MCNUM ymax = mccTOFcyl_ymax;
MCNUM zmin = mccTOFcyl_zmin;
MCNUM zmax = mccTOFcyl_zmax;
MCNUM bins = mccTOFcyl_bins;
MCNUM min = mccTOFcyl_min;
MCNUM max = mccTOFcyl_max;
MCNUM restore_neutron = mccTOFcyl_restore_neutron;
MCNUM radius = mccTOFcyl_radius;
char* options = mccTOFcyl_options;
char* filename = mccTOFcyl_filename;
char* geometry = mccTOFcyl_geometry;
char* username1 = mccTOFcyl_username1;
char* username2 = mccTOFcyl_username2;
char* username3 = mccTOFcyl_username3;
int nowritefile = mccTOFcyl_nowritefile;
#line 489 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  /* free pointers */
  Monitor_nD_Finally(&DEFS, &Vars);
}
#line 80995 "./SNS_BASIS.c"
}   /* End of TOFcyl=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[145]) fprintf(stderr, "Warning: No neutron could reach Component[145] TOFcyl\n");
    if (mcAbsorbProp[145]) fprintf(stderr, "Warning: %g events were removed in Component[145] TOFcyl=Monitor_nD()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[145]);
  mcsiminfo_close(); 
} /* end finally */
#define magnify mcdis_magnify
#define line mcdis_line
#define dashed_line mcdis_dashed_line
#define multiline mcdis_multiline
#define rectangle mcdis_rectangle
#define box mcdis_box
#define circle mcdis_circle
#define cylinder mcdis_cylinder
#define sphere mcdis_sphere
void mcdisplay(void) {
  printf("MCDISPLAY: start\n");
  /* Components MCDISPLAY code. */

  /* MCDISPLAY code for component 'Origin'. */
  SIG_MESSAGE("Origin (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Origin");
#define mccompcurname  Origin
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccOrigin_IntermediateCnts
#define StartTime mccOrigin_StartTime
#define EndTime mccOrigin_EndTime
#define CurrentTime mccOrigin_CurrentTime
{   /* Declarations of Origin=Progress_bar() SETTING parameters. */
char* profile = mccOrigin_profile;
MCNUM percent = mccOrigin_percent;
MCNUM flag_save = mccOrigin_flag_save;
MCNUM minutes = mccOrigin_minutes;
#line 147 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../misc/Progress_bar.comp"
{
  
}
#line 81044 "./SNS_BASIS.c"
}   /* End of Origin=Progress_bar() SETTING parameter declarations. */
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Source'. */
  SIG_MESSAGE("Source (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Source");
#define mccompcurname  Source
#define mccompcurtype  ESS_moderator_short
#define mccompcurindex 2
#define l_range mccSource_l_range
#define w_mult mccSource_w_mult
{   /* Declarations of Source=ESS_moderator_short() SETTING parameters. */
MCNUM size = mccSource_size;
MCNUM Lmin = mccSource_Lmin;
MCNUM Lmax = mccSource_Lmax;
MCNUM dist = mccSource_dist;
MCNUM focus_xw = mccSource_focus_xw;
MCNUM focus_yh = mccSource_focus_yh;
MCNUM nu = mccSource_nu;
MCNUM T = mccSource_T;
MCNUM tau = mccSource_tau;
MCNUM tau1 = mccSource_tau1;
MCNUM tau2 = mccSource_tau2;
MCNUM n = mccSource_n;
MCNUM n2 = mccSource_n2;
MCNUM chi2 = mccSource_chi2;
MCNUM I0 = mccSource_I0;
MCNUM I2 = mccSource_I2;
MCNUM branch1 = mccSource_branch1;
MCNUM branch2 = mccSource_branch2;
MCNUM branchframe = mccSource_branchframe;
int target_index = mccSource_target_index;
#line 227 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../obsolete/ESS_moderator_short.comp"
{
  
  rectangle("xy", 0, 0, 0, size, size);
  if (dist) {
    dashed_line(0,0,0, -focus_xw/2,-focus_yh/2,dist, 4);
    dashed_line(0,0,0,  focus_xw/2,-focus_yh/2,dist, 4);
    dashed_line(0,0,0,  focus_xw/2, focus_yh/2,dist, 4);
    dashed_line(0,0,0, -focus_xw/2, focus_yh/2,dist, 4);
  }
}
#line 81094 "./SNS_BASIS.c"
}   /* End of Source=ESS_moderator_short() SETTING parameter declarations. */
#undef w_mult
#undef l_range
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'tofSTART'. */
  SIG_MESSAGE("tofSTART (McDisplay)");
  printf("MCDISPLAY: component %s\n", "tofSTART");
#define mccompcurname  tofSTART
#define mccompcurtype  TOF_monitor
#define mccompcurindex 3
#define nt mcctofSTART_nt
#define TOF_N mcctofSTART_TOF_N
#define TOF_p mcctofSTART_TOF_p
#define TOF_p2 mcctofSTART_TOF_p2
#define t_min mcctofSTART_t_min
#define t_max mcctofSTART_t_max
#define delta_t mcctofSTART_delta_t
{   /* Declarations of tofSTART=TOF_monitor() SETTING parameters. */
char* filename = mcctofSTART_filename;
MCNUM xmin = mcctofSTART_xmin;
MCNUM xmax = mcctofSTART_xmax;
MCNUM ymin = mcctofSTART_ymin;
MCNUM ymax = mcctofSTART_ymax;
MCNUM xwidth = mcctofSTART_xwidth;
MCNUM yheight = mcctofSTART_yheight;
MCNUM tmin = mcctofSTART_tmin;
MCNUM tmax = mcctofSTART_tmax;
MCNUM dt = mcctofSTART_dt;
MCNUM restore_neutron = mcctofSTART_restore_neutron;
int nowritefile = mcctofSTART_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 81137 "./SNS_BASIS.c"
}   /* End of tofSTART=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Source_Lam'. */
  SIG_MESSAGE("Source_Lam (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Source_Lam");
#define mccompcurname  Source_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 4
#define nL mccSource_Lam_nL
#define L_N mccSource_Lam_L_N
#define L_p mccSource_Lam_L_p
#define L_p2 mccSource_Lam_L_p2
{   /* Declarations of Source_Lam=L_monitor() SETTING parameters. */
char* filename = mccSource_Lam_filename;
MCNUM xmin = mccSource_Lam_xmin;
MCNUM xmax = mccSource_Lam_xmax;
MCNUM ymin = mccSource_Lam_ymin;
MCNUM ymax = mccSource_Lam_ymax;
MCNUM xwidth = mccSource_Lam_xwidth;
MCNUM yheight = mccSource_Lam_yheight;
MCNUM Lmin = mccSource_Lam_Lmin;
MCNUM Lmax = mccSource_Lam_Lmax;
MCNUM restore_neutron = mccSource_Lam_restore_neutron;
int nowritefile = mccSource_Lam_nowritefile;
#line 120 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 81181 "./SNS_BASIS.c"
}   /* End of Source_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Source_En'. */
  SIG_MESSAGE("Source_En (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Source_En");
#define mccompcurname  Source_En
#define mccompcurtype  E_monitor
#define mccompcurindex 5
#define nE mccSource_En_nE
#define E_N mccSource_En_E_N
#define E_p mccSource_En_E_p
#define E_p2 mccSource_En_E_p2
#define S_p mccSource_En_S_p
#define S_pE mccSource_En_S_pE
#define S_pE2 mccSource_En_S_pE2
{   /* Declarations of Source_En=E_monitor() SETTING parameters. */
char* filename = mccSource_En_filename;
MCNUM xmin = mccSource_En_xmin;
MCNUM xmax = mccSource_En_xmax;
MCNUM ymin = mccSource_En_ymin;
MCNUM ymax = mccSource_En_ymax;
MCNUM xwidth = mccSource_En_xwidth;
MCNUM yheight = mccSource_En_yheight;
MCNUM Emin = mccSource_En_Emin;
MCNUM Emax = mccSource_En_Emax;
MCNUM restore_neutron = mccSource_En_restore_neutron;
int nowritefile = mccSource_En_nowritefile;
#line 132 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 81225 "./SNS_BASIS.c"
}   /* End of Source_En=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap0_start'. */
  SIG_MESSAGE("Gap0_start (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap0_start");
#define mccompcurname  Gap0_start
#define mccompcurtype  PSD_monitor
#define mccompcurindex 6
#define PSD_N mccGap0_start_PSD_N
#define PSD_p mccGap0_start_PSD_p
#define PSD_p2 mccGap0_start_PSD_p2
{   /* Declarations of Gap0_start=PSD_monitor() SETTING parameters. */
int nx = mccGap0_start_nx;
int ny = mccGap0_start_ny;
char* filename = mccGap0_start_filename;
MCNUM xmin = mccGap0_start_xmin;
MCNUM xmax = mccGap0_start_xmax;
MCNUM ymin = mccGap0_start_ymin;
MCNUM ymax = mccGap0_start_ymax;
MCNUM xwidth = mccGap0_start_xwidth;
MCNUM yheight = mccGap0_start_yheight;
MCNUM restore_neutron = mccGap0_start_restore_neutron;
#line 129 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  multiline(5,
    (double)xmin, (double)ymin, 0.0,
    (double)xmax, (double)ymin, 0.0,
    (double)xmax, (double)ymax, 0.0,
    (double)xmin, (double)ymax, 0.0,
    (double)xmin, (double)ymin, 0.0);
}
#line 81267 "./SNS_BASIS.c"
}   /* End of Gap0_start=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap0_end_Lam'. */
  SIG_MESSAGE("Gap0_end_Lam (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap0_end_Lam");
#define mccompcurname  Gap0_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 7
#define nL mccGap0_end_Lam_nL
#define L_N mccGap0_end_Lam_L_N
#define L_p mccGap0_end_Lam_L_p
#define L_p2 mccGap0_end_Lam_L_p2
{   /* Declarations of Gap0_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap0_end_Lam_filename;
MCNUM xmin = mccGap0_end_Lam_xmin;
MCNUM xmax = mccGap0_end_Lam_xmax;
MCNUM ymin = mccGap0_end_Lam_ymin;
MCNUM ymax = mccGap0_end_Lam_ymax;
MCNUM xwidth = mccGap0_end_Lam_xwidth;
MCNUM yheight = mccGap0_end_Lam_yheight;
MCNUM Lmin = mccGap0_end_Lam_Lmin;
MCNUM Lmax = mccGap0_end_Lam_Lmax;
MCNUM restore_neutron = mccGap0_end_Lam_restore_neutron;
int nowritefile = mccGap0_end_Lam_nowritefile;
#line 120 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 81307 "./SNS_BASIS.c"
}   /* End of Gap0_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap0_end_divx'. */
  SIG_MESSAGE("Gap0_end_divx (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap0_end_divx");
#define mccompcurname  Gap0_end_divx
#define mccompcurtype  Monitor_nD
#define mccompcurindex 8
#define user1 mccGap0_end_divx_user1
#define user2 mccGap0_end_divx_user2
#define user3 mccGap0_end_divx_user3
#define DEFS mccGap0_end_divx_DEFS
#define Vars mccGap0_end_divx_Vars
#define detector mccGap0_end_divx_detector
#define offdata mccGap0_end_divx_offdata
{   /* Declarations of Gap0_end_divx=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccGap0_end_divx_xwidth;
MCNUM yheight = mccGap0_end_divx_yheight;
MCNUM zdepth = mccGap0_end_divx_zdepth;
MCNUM xmin = mccGap0_end_divx_xmin;
MCNUM xmax = mccGap0_end_divx_xmax;
MCNUM ymin = mccGap0_end_divx_ymin;
MCNUM ymax = mccGap0_end_divx_ymax;
MCNUM zmin = mccGap0_end_divx_zmin;
MCNUM zmax = mccGap0_end_divx_zmax;
MCNUM bins = mccGap0_end_divx_bins;
MCNUM min = mccGap0_end_divx_min;
MCNUM max = mccGap0_end_divx_max;
MCNUM restore_neutron = mccGap0_end_divx_restore_neutron;
MCNUM radius = mccGap0_end_divx_radius;
char* options = mccGap0_end_divx_options;
char* filename = mccGap0_end_divx_filename;
char* geometry = mccGap0_end_divx_geometry;
char* username1 = mccGap0_end_divx_username1;
char* username2 = mccGap0_end_divx_username2;
char* username3 = mccGap0_end_divx_username3;
int nowritefile = mccGap0_end_divx_nowritefile;
#line 495 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    off_display(offdata);
  } else {
    Monitor_nD_McDisplay(&DEFS, &Vars);
  }
}
#line 81361 "./SNS_BASIS.c"
}   /* End of Gap0_end_divx=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap0_end_divy'. */
  SIG_MESSAGE("Gap0_end_divy (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap0_end_divy");
#define mccompcurname  Gap0_end_divy
#define mccompcurtype  Monitor_nD
#define mccompcurindex 9
#define user1 mccGap0_end_divy_user1
#define user2 mccGap0_end_divy_user2
#define user3 mccGap0_end_divy_user3
#define DEFS mccGap0_end_divy_DEFS
#define Vars mccGap0_end_divy_Vars
#define detector mccGap0_end_divy_detector
#define offdata mccGap0_end_divy_offdata
{   /* Declarations of Gap0_end_divy=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccGap0_end_divy_xwidth;
MCNUM yheight = mccGap0_end_divy_yheight;
MCNUM zdepth = mccGap0_end_divy_zdepth;
MCNUM xmin = mccGap0_end_divy_xmin;
MCNUM xmax = mccGap0_end_divy_xmax;
MCNUM ymin = mccGap0_end_divy_ymin;
MCNUM ymax = mccGap0_end_divy_ymax;
MCNUM zmin = mccGap0_end_divy_zmin;
MCNUM zmax = mccGap0_end_divy_zmax;
MCNUM bins = mccGap0_end_divy_bins;
MCNUM min = mccGap0_end_divy_min;
MCNUM max = mccGap0_end_divy_max;
MCNUM restore_neutron = mccGap0_end_divy_restore_neutron;
MCNUM radius = mccGap0_end_divy_radius;
char* options = mccGap0_end_divy_options;
char* filename = mccGap0_end_divy_filename;
char* geometry = mccGap0_end_divy_geometry;
char* username1 = mccGap0_end_divy_username1;
char* username2 = mccGap0_end_divy_username2;
char* username3 = mccGap0_end_divy_username3;
int nowritefile = mccGap0_end_divy_nowritefile;
#line 495 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    off_display(offdata);
  } else {
    Monitor_nD_McDisplay(&DEFS, &Vars);
  }
}
#line 81418 "./SNS_BASIS.c"
}   /* End of Gap0_end_divy=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Core_Vessel_Section'. */
  SIG_MESSAGE("Core_Vessel_Section (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Core_Vessel_Section");
#define mccompcurname  Core_Vessel_Section
#define mccompcurtype  Guide
#define mccompcurindex 10
#define pTable mccCore_Vessel_Section_pTable
{   /* Declarations of Core_Vessel_Section=Guide() SETTING parameters. */
char* reflect = mccCore_Vessel_Section_reflect;
MCNUM w1 = mccCore_Vessel_Section_w1;
MCNUM h1 = mccCore_Vessel_Section_h1;
MCNUM w2 = mccCore_Vessel_Section_w2;
MCNUM h2 = mccCore_Vessel_Section_h2;
MCNUM l = mccCore_Vessel_Section_l;
MCNUM R0 = mccCore_Vessel_Section_R0;
MCNUM Qc = mccCore_Vessel_Section_Qc;
MCNUM alpha = mccCore_Vessel_Section_alpha;
MCNUM m = mccCore_Vessel_Section_m;
MCNUM W = mccCore_Vessel_Section_W;
#line 202 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 81470 "./SNS_BASIS.c"
}   /* End of Core_Vessel_Section=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap1_start'. */
  SIG_MESSAGE("Gap1_start (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap1_start");
#define mccompcurname  Gap1_start
#define mccompcurtype  Arm
#define mccompcurindex 11
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 81491 "./SNS_BASIS.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap1_start_Lam'. */
  SIG_MESSAGE("Gap1_start_Lam (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap1_start_Lam");
#define mccompcurname  Gap1_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 12
#define nL mccGap1_start_Lam_nL
#define L_N mccGap1_start_Lam_L_N
#define L_p mccGap1_start_Lam_L_p
#define L_p2 mccGap1_start_Lam_L_p2
{   /* Declarations of Gap1_start_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap1_start_Lam_filename;
MCNUM xmin = mccGap1_start_Lam_xmin;
MCNUM xmax = mccGap1_start_Lam_xmax;
MCNUM ymin = mccGap1_start_Lam_ymin;
MCNUM ymax = mccGap1_start_Lam_ymax;
MCNUM xwidth = mccGap1_start_Lam_xwidth;
MCNUM yheight = mccGap1_start_Lam_yheight;
MCNUM Lmin = mccGap1_start_Lam_Lmin;
MCNUM Lmax = mccGap1_start_Lam_Lmax;
MCNUM restore_neutron = mccGap1_start_Lam_restore_neutron;
int nowritefile = mccGap1_start_Lam_nowritefile;
#line 120 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 81527 "./SNS_BASIS.c"
}   /* End of Gap1_start_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap1_end_Lam'. */
  SIG_MESSAGE("Gap1_end_Lam (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap1_end_Lam");
#define mccompcurname  Gap1_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 13
#define nL mccGap1_end_Lam_nL
#define L_N mccGap1_end_Lam_L_N
#define L_p mccGap1_end_Lam_L_p
#define L_p2 mccGap1_end_Lam_L_p2
{   /* Declarations of Gap1_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap1_end_Lam_filename;
MCNUM xmin = mccGap1_end_Lam_xmin;
MCNUM xmax = mccGap1_end_Lam_xmax;
MCNUM ymin = mccGap1_end_Lam_ymin;
MCNUM ymax = mccGap1_end_Lam_ymax;
MCNUM xwidth = mccGap1_end_Lam_xwidth;
MCNUM yheight = mccGap1_end_Lam_yheight;
MCNUM Lmin = mccGap1_end_Lam_Lmin;
MCNUM Lmax = mccGap1_end_Lam_Lmax;
MCNUM restore_neutron = mccGap1_end_Lam_restore_neutron;
int nowritefile = mccGap1_end_Lam_nowritefile;
#line 120 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 81568 "./SNS_BASIS.c"
}   /* End of Gap1_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap1_end'. */
  SIG_MESSAGE("Gap1_end (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap1_end");
#define mccompcurname  Gap1_end
#define mccompcurtype  Arm
#define mccompcurindex 14
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 81592 "./SNS_BASIS.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Shutter_Guide_Insert'. */
  SIG_MESSAGE("Shutter_Guide_Insert (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Shutter_Guide_Insert");
#define mccompcurname  Shutter_Guide_Insert
#define mccompcurtype  Guide_gravity
#define mccompcurindex 15
#define GVars mccShutter_Guide_Insert_GVars
#define pTable mccShutter_Guide_Insert_pTable
{   /* Declarations of Shutter_Guide_Insert=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_w1;
MCNUM h1 = mccShutter_Guide_Insert_h1;
MCNUM w2 = mccShutter_Guide_Insert_w2;
MCNUM h2 = mccShutter_Guide_Insert_h2;
MCNUM l = mccShutter_Guide_Insert_l;
MCNUM R0 = mccShutter_Guide_Insert_R0;
MCNUM Qc = mccShutter_Guide_Insert_Qc;
MCNUM alpha = mccShutter_Guide_Insert_alpha;
MCNUM m = mccShutter_Guide_Insert_m;
MCNUM W = mccShutter_Guide_Insert_W;
MCNUM nslit = mccShutter_Guide_Insert_nslit;
MCNUM d = mccShutter_Guide_Insert_d;
MCNUM mleft = mccShutter_Guide_Insert_mleft;
MCNUM mright = mccShutter_Guide_Insert_mright;
MCNUM mtop = mccShutter_Guide_Insert_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_nhslit;
MCNUM G = mccShutter_Guide_Insert_G;
MCNUM aleft = mccShutter_Guide_Insert_aleft;
MCNUM aright = mccShutter_Guide_Insert_aright;
MCNUM atop = mccShutter_Guide_Insert_atop;
MCNUM abottom = mccShutter_Guide_Insert_abottom;
MCNUM wavy = mccShutter_Guide_Insert_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_nelements;
MCNUM nu = mccShutter_Guide_Insert_nu;
MCNUM phase = mccShutter_Guide_Insert_phase;
char* reflect = mccShutter_Guide_Insert_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 81703 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Shutter_Guide_Insert_16'. */
  SIG_MESSAGE("Shutter_Guide_Insert_16 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Shutter_Guide_Insert_16");
#define mccompcurname  Shutter_Guide_Insert_16
#define mccompcurtype  Guide_gravity
#define mccompcurindex 16
#define GVars mccShutter_Guide_Insert_16_GVars
#define pTable mccShutter_Guide_Insert_16_pTable
{   /* Declarations of Shutter_Guide_Insert_16=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_16_w1;
MCNUM h1 = mccShutter_Guide_Insert_16_h1;
MCNUM w2 = mccShutter_Guide_Insert_16_w2;
MCNUM h2 = mccShutter_Guide_Insert_16_h2;
MCNUM l = mccShutter_Guide_Insert_16_l;
MCNUM R0 = mccShutter_Guide_Insert_16_R0;
MCNUM Qc = mccShutter_Guide_Insert_16_Qc;
MCNUM alpha = mccShutter_Guide_Insert_16_alpha;
MCNUM m = mccShutter_Guide_Insert_16_m;
MCNUM W = mccShutter_Guide_Insert_16_W;
MCNUM nslit = mccShutter_Guide_Insert_16_nslit;
MCNUM d = mccShutter_Guide_Insert_16_d;
MCNUM mleft = mccShutter_Guide_Insert_16_mleft;
MCNUM mright = mccShutter_Guide_Insert_16_mright;
MCNUM mtop = mccShutter_Guide_Insert_16_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_16_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_16_nhslit;
MCNUM G = mccShutter_Guide_Insert_16_G;
MCNUM aleft = mccShutter_Guide_Insert_16_aleft;
MCNUM aright = mccShutter_Guide_Insert_16_aright;
MCNUM atop = mccShutter_Guide_Insert_16_atop;
MCNUM abottom = mccShutter_Guide_Insert_16_abottom;
MCNUM wavy = mccShutter_Guide_Insert_16_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_16_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_16_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_16_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_16_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_16_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_16_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_16_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_16_nelements;
MCNUM nu = mccShutter_Guide_Insert_16_nu;
MCNUM phase = mccShutter_Guide_Insert_16_phase;
char* reflect = mccShutter_Guide_Insert_16_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 81817 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert_16=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Shutter_Guide_Insert_17'. */
  SIG_MESSAGE("Shutter_Guide_Insert_17 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Shutter_Guide_Insert_17");
#define mccompcurname  Shutter_Guide_Insert_17
#define mccompcurtype  Guide_gravity
#define mccompcurindex 17
#define GVars mccShutter_Guide_Insert_17_GVars
#define pTable mccShutter_Guide_Insert_17_pTable
{   /* Declarations of Shutter_Guide_Insert_17=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_17_w1;
MCNUM h1 = mccShutter_Guide_Insert_17_h1;
MCNUM w2 = mccShutter_Guide_Insert_17_w2;
MCNUM h2 = mccShutter_Guide_Insert_17_h2;
MCNUM l = mccShutter_Guide_Insert_17_l;
MCNUM R0 = mccShutter_Guide_Insert_17_R0;
MCNUM Qc = mccShutter_Guide_Insert_17_Qc;
MCNUM alpha = mccShutter_Guide_Insert_17_alpha;
MCNUM m = mccShutter_Guide_Insert_17_m;
MCNUM W = mccShutter_Guide_Insert_17_W;
MCNUM nslit = mccShutter_Guide_Insert_17_nslit;
MCNUM d = mccShutter_Guide_Insert_17_d;
MCNUM mleft = mccShutter_Guide_Insert_17_mleft;
MCNUM mright = mccShutter_Guide_Insert_17_mright;
MCNUM mtop = mccShutter_Guide_Insert_17_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_17_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_17_nhslit;
MCNUM G = mccShutter_Guide_Insert_17_G;
MCNUM aleft = mccShutter_Guide_Insert_17_aleft;
MCNUM aright = mccShutter_Guide_Insert_17_aright;
MCNUM atop = mccShutter_Guide_Insert_17_atop;
MCNUM abottom = mccShutter_Guide_Insert_17_abottom;
MCNUM wavy = mccShutter_Guide_Insert_17_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_17_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_17_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_17_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_17_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_17_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_17_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_17_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_17_nelements;
MCNUM nu = mccShutter_Guide_Insert_17_nu;
MCNUM phase = mccShutter_Guide_Insert_17_phase;
char* reflect = mccShutter_Guide_Insert_17_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 81931 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert_17=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Shutter_Guide_Insert_18'. */
  SIG_MESSAGE("Shutter_Guide_Insert_18 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Shutter_Guide_Insert_18");
#define mccompcurname  Shutter_Guide_Insert_18
#define mccompcurtype  Guide_gravity
#define mccompcurindex 18
#define GVars mccShutter_Guide_Insert_18_GVars
#define pTable mccShutter_Guide_Insert_18_pTable
{   /* Declarations of Shutter_Guide_Insert_18=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_18_w1;
MCNUM h1 = mccShutter_Guide_Insert_18_h1;
MCNUM w2 = mccShutter_Guide_Insert_18_w2;
MCNUM h2 = mccShutter_Guide_Insert_18_h2;
MCNUM l = mccShutter_Guide_Insert_18_l;
MCNUM R0 = mccShutter_Guide_Insert_18_R0;
MCNUM Qc = mccShutter_Guide_Insert_18_Qc;
MCNUM alpha = mccShutter_Guide_Insert_18_alpha;
MCNUM m = mccShutter_Guide_Insert_18_m;
MCNUM W = mccShutter_Guide_Insert_18_W;
MCNUM nslit = mccShutter_Guide_Insert_18_nslit;
MCNUM d = mccShutter_Guide_Insert_18_d;
MCNUM mleft = mccShutter_Guide_Insert_18_mleft;
MCNUM mright = mccShutter_Guide_Insert_18_mright;
MCNUM mtop = mccShutter_Guide_Insert_18_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_18_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_18_nhslit;
MCNUM G = mccShutter_Guide_Insert_18_G;
MCNUM aleft = mccShutter_Guide_Insert_18_aleft;
MCNUM aright = mccShutter_Guide_Insert_18_aright;
MCNUM atop = mccShutter_Guide_Insert_18_atop;
MCNUM abottom = mccShutter_Guide_Insert_18_abottom;
MCNUM wavy = mccShutter_Guide_Insert_18_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_18_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_18_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_18_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_18_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_18_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_18_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_18_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_18_nelements;
MCNUM nu = mccShutter_Guide_Insert_18_nu;
MCNUM phase = mccShutter_Guide_Insert_18_phase;
char* reflect = mccShutter_Guide_Insert_18_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82045 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert_18=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Shutter_Guide_Insert_19'. */
  SIG_MESSAGE("Shutter_Guide_Insert_19 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Shutter_Guide_Insert_19");
#define mccompcurname  Shutter_Guide_Insert_19
#define mccompcurtype  Guide_gravity
#define mccompcurindex 19
#define GVars mccShutter_Guide_Insert_19_GVars
#define pTable mccShutter_Guide_Insert_19_pTable
{   /* Declarations of Shutter_Guide_Insert_19=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_19_w1;
MCNUM h1 = mccShutter_Guide_Insert_19_h1;
MCNUM w2 = mccShutter_Guide_Insert_19_w2;
MCNUM h2 = mccShutter_Guide_Insert_19_h2;
MCNUM l = mccShutter_Guide_Insert_19_l;
MCNUM R0 = mccShutter_Guide_Insert_19_R0;
MCNUM Qc = mccShutter_Guide_Insert_19_Qc;
MCNUM alpha = mccShutter_Guide_Insert_19_alpha;
MCNUM m = mccShutter_Guide_Insert_19_m;
MCNUM W = mccShutter_Guide_Insert_19_W;
MCNUM nslit = mccShutter_Guide_Insert_19_nslit;
MCNUM d = mccShutter_Guide_Insert_19_d;
MCNUM mleft = mccShutter_Guide_Insert_19_mleft;
MCNUM mright = mccShutter_Guide_Insert_19_mright;
MCNUM mtop = mccShutter_Guide_Insert_19_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_19_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_19_nhslit;
MCNUM G = mccShutter_Guide_Insert_19_G;
MCNUM aleft = mccShutter_Guide_Insert_19_aleft;
MCNUM aright = mccShutter_Guide_Insert_19_aright;
MCNUM atop = mccShutter_Guide_Insert_19_atop;
MCNUM abottom = mccShutter_Guide_Insert_19_abottom;
MCNUM wavy = mccShutter_Guide_Insert_19_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_19_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_19_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_19_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_19_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_19_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_19_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_19_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_19_nelements;
MCNUM nu = mccShutter_Guide_Insert_19_nu;
MCNUM phase = mccShutter_Guide_Insert_19_phase;
char* reflect = mccShutter_Guide_Insert_19_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82159 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert_19=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Shutter_Guide_Insert_20'. */
  SIG_MESSAGE("Shutter_Guide_Insert_20 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Shutter_Guide_Insert_20");
#define mccompcurname  Shutter_Guide_Insert_20
#define mccompcurtype  Guide_gravity
#define mccompcurindex 20
#define GVars mccShutter_Guide_Insert_20_GVars
#define pTable mccShutter_Guide_Insert_20_pTable
{   /* Declarations of Shutter_Guide_Insert_20=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_20_w1;
MCNUM h1 = mccShutter_Guide_Insert_20_h1;
MCNUM w2 = mccShutter_Guide_Insert_20_w2;
MCNUM h2 = mccShutter_Guide_Insert_20_h2;
MCNUM l = mccShutter_Guide_Insert_20_l;
MCNUM R0 = mccShutter_Guide_Insert_20_R0;
MCNUM Qc = mccShutter_Guide_Insert_20_Qc;
MCNUM alpha = mccShutter_Guide_Insert_20_alpha;
MCNUM m = mccShutter_Guide_Insert_20_m;
MCNUM W = mccShutter_Guide_Insert_20_W;
MCNUM nslit = mccShutter_Guide_Insert_20_nslit;
MCNUM d = mccShutter_Guide_Insert_20_d;
MCNUM mleft = mccShutter_Guide_Insert_20_mleft;
MCNUM mright = mccShutter_Guide_Insert_20_mright;
MCNUM mtop = mccShutter_Guide_Insert_20_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_20_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_20_nhslit;
MCNUM G = mccShutter_Guide_Insert_20_G;
MCNUM aleft = mccShutter_Guide_Insert_20_aleft;
MCNUM aright = mccShutter_Guide_Insert_20_aright;
MCNUM atop = mccShutter_Guide_Insert_20_atop;
MCNUM abottom = mccShutter_Guide_Insert_20_abottom;
MCNUM wavy = mccShutter_Guide_Insert_20_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_20_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_20_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_20_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_20_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_20_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_20_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_20_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_20_nelements;
MCNUM nu = mccShutter_Guide_Insert_20_nu;
MCNUM phase = mccShutter_Guide_Insert_20_phase;
char* reflect = mccShutter_Guide_Insert_20_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82273 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert_20=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Shutter_Guide_Insert_21'. */
  SIG_MESSAGE("Shutter_Guide_Insert_21 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Shutter_Guide_Insert_21");
#define mccompcurname  Shutter_Guide_Insert_21
#define mccompcurtype  Guide_gravity
#define mccompcurindex 21
#define GVars mccShutter_Guide_Insert_21_GVars
#define pTable mccShutter_Guide_Insert_21_pTable
{   /* Declarations of Shutter_Guide_Insert_21=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_21_w1;
MCNUM h1 = mccShutter_Guide_Insert_21_h1;
MCNUM w2 = mccShutter_Guide_Insert_21_w2;
MCNUM h2 = mccShutter_Guide_Insert_21_h2;
MCNUM l = mccShutter_Guide_Insert_21_l;
MCNUM R0 = mccShutter_Guide_Insert_21_R0;
MCNUM Qc = mccShutter_Guide_Insert_21_Qc;
MCNUM alpha = mccShutter_Guide_Insert_21_alpha;
MCNUM m = mccShutter_Guide_Insert_21_m;
MCNUM W = mccShutter_Guide_Insert_21_W;
MCNUM nslit = mccShutter_Guide_Insert_21_nslit;
MCNUM d = mccShutter_Guide_Insert_21_d;
MCNUM mleft = mccShutter_Guide_Insert_21_mleft;
MCNUM mright = mccShutter_Guide_Insert_21_mright;
MCNUM mtop = mccShutter_Guide_Insert_21_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_21_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_21_nhslit;
MCNUM G = mccShutter_Guide_Insert_21_G;
MCNUM aleft = mccShutter_Guide_Insert_21_aleft;
MCNUM aright = mccShutter_Guide_Insert_21_aright;
MCNUM atop = mccShutter_Guide_Insert_21_atop;
MCNUM abottom = mccShutter_Guide_Insert_21_abottom;
MCNUM wavy = mccShutter_Guide_Insert_21_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_21_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_21_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_21_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_21_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_21_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_21_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_21_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_21_nelements;
MCNUM nu = mccShutter_Guide_Insert_21_nu;
MCNUM phase = mccShutter_Guide_Insert_21_phase;
char* reflect = mccShutter_Guide_Insert_21_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82387 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert_21=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Shutter_Guide_Insert_short'. */
  SIG_MESSAGE("Shutter_Guide_Insert_short (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Shutter_Guide_Insert_short");
#define mccompcurname  Shutter_Guide_Insert_short
#define mccompcurtype  Guide_gravity
#define mccompcurindex 22
#define GVars mccShutter_Guide_Insert_short_GVars
#define pTable mccShutter_Guide_Insert_short_pTable
{   /* Declarations of Shutter_Guide_Insert_short=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccShutter_Guide_Insert_short_w1;
MCNUM h1 = mccShutter_Guide_Insert_short_h1;
MCNUM w2 = mccShutter_Guide_Insert_short_w2;
MCNUM h2 = mccShutter_Guide_Insert_short_h2;
MCNUM l = mccShutter_Guide_Insert_short_l;
MCNUM R0 = mccShutter_Guide_Insert_short_R0;
MCNUM Qc = mccShutter_Guide_Insert_short_Qc;
MCNUM alpha = mccShutter_Guide_Insert_short_alpha;
MCNUM m = mccShutter_Guide_Insert_short_m;
MCNUM W = mccShutter_Guide_Insert_short_W;
MCNUM nslit = mccShutter_Guide_Insert_short_nslit;
MCNUM d = mccShutter_Guide_Insert_short_d;
MCNUM mleft = mccShutter_Guide_Insert_short_mleft;
MCNUM mright = mccShutter_Guide_Insert_short_mright;
MCNUM mtop = mccShutter_Guide_Insert_short_mtop;
MCNUM mbottom = mccShutter_Guide_Insert_short_mbottom;
MCNUM nhslit = mccShutter_Guide_Insert_short_nhslit;
MCNUM G = mccShutter_Guide_Insert_short_G;
MCNUM aleft = mccShutter_Guide_Insert_short_aleft;
MCNUM aright = mccShutter_Guide_Insert_short_aright;
MCNUM atop = mccShutter_Guide_Insert_short_atop;
MCNUM abottom = mccShutter_Guide_Insert_short_abottom;
MCNUM wavy = mccShutter_Guide_Insert_short_wavy;
MCNUM wavy_z = mccShutter_Guide_Insert_short_wavy_z;
MCNUM wavy_tb = mccShutter_Guide_Insert_short_wavy_tb;
MCNUM wavy_lr = mccShutter_Guide_Insert_short_wavy_lr;
MCNUM chamfers = mccShutter_Guide_Insert_short_chamfers;
MCNUM chamfers_z = mccShutter_Guide_Insert_short_chamfers_z;
MCNUM chamfers_lr = mccShutter_Guide_Insert_short_chamfers_lr;
MCNUM chamfers_tb = mccShutter_Guide_Insert_short_chamfers_tb;
MCNUM nelements = mccShutter_Guide_Insert_short_nelements;
MCNUM nu = mccShutter_Guide_Insert_short_nu;
MCNUM phase = mccShutter_Guide_Insert_short_phase;
char* reflect = mccShutter_Guide_Insert_short_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82501 "./SNS_BASIS.c"
}   /* End of Shutter_Guide_Insert_short=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap2_start'. */
  SIG_MESSAGE("Gap2_start (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap2_start");
#define mccompcurname  Gap2_start
#define mccompcurtype  Arm
#define mccompcurindex 23
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 82523 "./SNS_BASIS.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap2_start_Lam'. */
  SIG_MESSAGE("Gap2_start_Lam (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap2_start_Lam");
#define mccompcurname  Gap2_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 24
#define nL mccGap2_start_Lam_nL
#define L_N mccGap2_start_Lam_L_N
#define L_p mccGap2_start_Lam_L_p
#define L_p2 mccGap2_start_Lam_L_p2
{   /* Declarations of Gap2_start_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap2_start_Lam_filename;
MCNUM xmin = mccGap2_start_Lam_xmin;
MCNUM xmax = mccGap2_start_Lam_xmax;
MCNUM ymin = mccGap2_start_Lam_ymin;
MCNUM ymax = mccGap2_start_Lam_ymax;
MCNUM xwidth = mccGap2_start_Lam_xwidth;
MCNUM yheight = mccGap2_start_Lam_yheight;
MCNUM Lmin = mccGap2_start_Lam_Lmin;
MCNUM Lmax = mccGap2_start_Lam_Lmax;
MCNUM restore_neutron = mccGap2_start_Lam_restore_neutron;
int nowritefile = mccGap2_start_Lam_nowritefile;
#line 120 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 82559 "./SNS_BASIS.c"
}   /* End of Gap2_start_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap2_start_PSD'. */
  SIG_MESSAGE("Gap2_start_PSD (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap2_start_PSD");
#define mccompcurname  Gap2_start_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 25
#define PSD_N mccGap2_start_PSD_PSD_N
#define PSD_p mccGap2_start_PSD_PSD_p
#define PSD_p2 mccGap2_start_PSD_PSD_p2
{   /* Declarations of Gap2_start_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap2_start_PSD_nx;
int ny = mccGap2_start_PSD_ny;
char* filename = mccGap2_start_PSD_filename;
MCNUM xmin = mccGap2_start_PSD_xmin;
MCNUM xmax = mccGap2_start_PSD_xmax;
MCNUM ymin = mccGap2_start_PSD_ymin;
MCNUM ymax = mccGap2_start_PSD_ymax;
MCNUM xwidth = mccGap2_start_PSD_xwidth;
MCNUM yheight = mccGap2_start_PSD_yheight;
MCNUM restore_neutron = mccGap2_start_PSD_restore_neutron;
#line 129 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  multiline(5,
    (double)xmin, (double)ymin, 0.0,
    (double)xmax, (double)ymin, 0.0,
    (double)xmax, (double)ymax, 0.0,
    (double)xmin, (double)ymax, 0.0,
    (double)xmin, (double)ymin, 0.0);
}
#line 82598 "./SNS_BASIS.c"
}   /* End of Gap2_start_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap2_end_Lam'. */
  SIG_MESSAGE("Gap2_end_Lam (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap2_end_Lam");
#define mccompcurname  Gap2_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 26
#define nL mccGap2_end_Lam_nL
#define L_N mccGap2_end_Lam_L_N
#define L_p mccGap2_end_Lam_L_p
#define L_p2 mccGap2_end_Lam_L_p2
{   /* Declarations of Gap2_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap2_end_Lam_filename;
MCNUM xmin = mccGap2_end_Lam_xmin;
MCNUM xmax = mccGap2_end_Lam_xmax;
MCNUM ymin = mccGap2_end_Lam_ymin;
MCNUM ymax = mccGap2_end_Lam_ymax;
MCNUM xwidth = mccGap2_end_Lam_xwidth;
MCNUM yheight = mccGap2_end_Lam_yheight;
MCNUM Lmin = mccGap2_end_Lam_Lmin;
MCNUM Lmax = mccGap2_end_Lam_Lmax;
MCNUM restore_neutron = mccGap2_end_Lam_restore_neutron;
int nowritefile = mccGap2_end_Lam_nowritefile;
#line 120 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 82638 "./SNS_BASIS.c"
}   /* End of Gap2_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap2_end_PSD'. */
  SIG_MESSAGE("Gap2_end_PSD (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap2_end_PSD");
#define mccompcurname  Gap2_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 27
#define PSD_N mccGap2_end_PSD_PSD_N
#define PSD_p mccGap2_end_PSD_PSD_p
#define PSD_p2 mccGap2_end_PSD_PSD_p2
{   /* Declarations of Gap2_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap2_end_PSD_nx;
int ny = mccGap2_end_PSD_ny;
char* filename = mccGap2_end_PSD_filename;
MCNUM xmin = mccGap2_end_PSD_xmin;
MCNUM xmax = mccGap2_end_PSD_xmax;
MCNUM ymin = mccGap2_end_PSD_ymin;
MCNUM ymax = mccGap2_end_PSD_ymax;
MCNUM xwidth = mccGap2_end_PSD_xwidth;
MCNUM yheight = mccGap2_end_PSD_yheight;
MCNUM restore_neutron = mccGap2_end_PSD_restore_neutron;
#line 129 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  multiline(5,
    (double)xmin, (double)ymin, 0.0,
    (double)xmax, (double)ymin, 0.0,
    (double)xmax, (double)ymax, 0.0,
    (double)xmin, (double)ymax, 0.0,
    (double)xmin, (double)ymin, 0.0);
}
#line 82677 "./SNS_BASIS.c"
}   /* End of Gap2_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap2_end'. */
  SIG_MESSAGE("Gap2_end (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap2_end");
#define mccompcurname  Gap2_end
#define mccompcurtype  Arm
#define mccompcurindex 28
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 82700 "./SNS_BASIS.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_I'. */
  SIG_MESSAGE("Curved_Guide_Section_I (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_I");
#define mccompcurname  Curved_Guide_Section_I
#define mccompcurtype  Guide_gravity
#define mccompcurindex 29
#define GVars mccCurved_Guide_Section_I_GVars
#define pTable mccCurved_Guide_Section_I_pTable
{   /* Declarations of Curved_Guide_Section_I=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_w1;
MCNUM h1 = mccCurved_Guide_Section_I_h1;
MCNUM w2 = mccCurved_Guide_Section_I_w2;
MCNUM h2 = mccCurved_Guide_Section_I_h2;
MCNUM l = mccCurved_Guide_Section_I_l;
MCNUM R0 = mccCurved_Guide_Section_I_R0;
MCNUM Qc = mccCurved_Guide_Section_I_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_alpha;
MCNUM m = mccCurved_Guide_Section_I_m;
MCNUM W = mccCurved_Guide_Section_I_W;
MCNUM nslit = mccCurved_Guide_Section_I_nslit;
MCNUM d = mccCurved_Guide_Section_I_d;
MCNUM mleft = mccCurved_Guide_Section_I_mleft;
MCNUM mright = mccCurved_Guide_Section_I_mright;
MCNUM mtop = mccCurved_Guide_Section_I_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_nhslit;
MCNUM G = mccCurved_Guide_Section_I_G;
MCNUM aleft = mccCurved_Guide_Section_I_aleft;
MCNUM aright = mccCurved_Guide_Section_I_aright;
MCNUM atop = mccCurved_Guide_Section_I_atop;
MCNUM abottom = mccCurved_Guide_Section_I_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_nelements;
MCNUM nu = mccCurved_Guide_Section_I_nu;
MCNUM phase = mccCurved_Guide_Section_I_phase;
char* reflect = mccCurved_Guide_Section_I_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82811 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_I_30'. */
  SIG_MESSAGE("Curved_Guide_Section_I_30 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_I_30");
#define mccompcurname  Curved_Guide_Section_I_30
#define mccompcurtype  Guide_gravity
#define mccompcurindex 30
#define GVars mccCurved_Guide_Section_I_30_GVars
#define pTable mccCurved_Guide_Section_I_30_pTable
{   /* Declarations of Curved_Guide_Section_I_30=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_30_w1;
MCNUM h1 = mccCurved_Guide_Section_I_30_h1;
MCNUM w2 = mccCurved_Guide_Section_I_30_w2;
MCNUM h2 = mccCurved_Guide_Section_I_30_h2;
MCNUM l = mccCurved_Guide_Section_I_30_l;
MCNUM R0 = mccCurved_Guide_Section_I_30_R0;
MCNUM Qc = mccCurved_Guide_Section_I_30_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_30_alpha;
MCNUM m = mccCurved_Guide_Section_I_30_m;
MCNUM W = mccCurved_Guide_Section_I_30_W;
MCNUM nslit = mccCurved_Guide_Section_I_30_nslit;
MCNUM d = mccCurved_Guide_Section_I_30_d;
MCNUM mleft = mccCurved_Guide_Section_I_30_mleft;
MCNUM mright = mccCurved_Guide_Section_I_30_mright;
MCNUM mtop = mccCurved_Guide_Section_I_30_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_30_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_30_nhslit;
MCNUM G = mccCurved_Guide_Section_I_30_G;
MCNUM aleft = mccCurved_Guide_Section_I_30_aleft;
MCNUM aright = mccCurved_Guide_Section_I_30_aright;
MCNUM atop = mccCurved_Guide_Section_I_30_atop;
MCNUM abottom = mccCurved_Guide_Section_I_30_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_30_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_30_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_30_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_30_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_30_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_30_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_30_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_30_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_30_nelements;
MCNUM nu = mccCurved_Guide_Section_I_30_nu;
MCNUM phase = mccCurved_Guide_Section_I_30_phase;
char* reflect = mccCurved_Guide_Section_I_30_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82925 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_30=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_I_31'. */
  SIG_MESSAGE("Curved_Guide_Section_I_31 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_I_31");
#define mccompcurname  Curved_Guide_Section_I_31
#define mccompcurtype  Guide_gravity
#define mccompcurindex 31
#define GVars mccCurved_Guide_Section_I_31_GVars
#define pTable mccCurved_Guide_Section_I_31_pTable
{   /* Declarations of Curved_Guide_Section_I_31=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_31_w1;
MCNUM h1 = mccCurved_Guide_Section_I_31_h1;
MCNUM w2 = mccCurved_Guide_Section_I_31_w2;
MCNUM h2 = mccCurved_Guide_Section_I_31_h2;
MCNUM l = mccCurved_Guide_Section_I_31_l;
MCNUM R0 = mccCurved_Guide_Section_I_31_R0;
MCNUM Qc = mccCurved_Guide_Section_I_31_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_31_alpha;
MCNUM m = mccCurved_Guide_Section_I_31_m;
MCNUM W = mccCurved_Guide_Section_I_31_W;
MCNUM nslit = mccCurved_Guide_Section_I_31_nslit;
MCNUM d = mccCurved_Guide_Section_I_31_d;
MCNUM mleft = mccCurved_Guide_Section_I_31_mleft;
MCNUM mright = mccCurved_Guide_Section_I_31_mright;
MCNUM mtop = mccCurved_Guide_Section_I_31_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_31_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_31_nhslit;
MCNUM G = mccCurved_Guide_Section_I_31_G;
MCNUM aleft = mccCurved_Guide_Section_I_31_aleft;
MCNUM aright = mccCurved_Guide_Section_I_31_aright;
MCNUM atop = mccCurved_Guide_Section_I_31_atop;
MCNUM abottom = mccCurved_Guide_Section_I_31_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_31_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_31_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_31_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_31_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_31_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_31_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_31_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_31_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_31_nelements;
MCNUM nu = mccCurved_Guide_Section_I_31_nu;
MCNUM phase = mccCurved_Guide_Section_I_31_phase;
char* reflect = mccCurved_Guide_Section_I_31_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83039 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_31=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_I_32'. */
  SIG_MESSAGE("Curved_Guide_Section_I_32 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_I_32");
#define mccompcurname  Curved_Guide_Section_I_32
#define mccompcurtype  Guide_gravity
#define mccompcurindex 32
#define GVars mccCurved_Guide_Section_I_32_GVars
#define pTable mccCurved_Guide_Section_I_32_pTable
{   /* Declarations of Curved_Guide_Section_I_32=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_32_w1;
MCNUM h1 = mccCurved_Guide_Section_I_32_h1;
MCNUM w2 = mccCurved_Guide_Section_I_32_w2;
MCNUM h2 = mccCurved_Guide_Section_I_32_h2;
MCNUM l = mccCurved_Guide_Section_I_32_l;
MCNUM R0 = mccCurved_Guide_Section_I_32_R0;
MCNUM Qc = mccCurved_Guide_Section_I_32_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_32_alpha;
MCNUM m = mccCurved_Guide_Section_I_32_m;
MCNUM W = mccCurved_Guide_Section_I_32_W;
MCNUM nslit = mccCurved_Guide_Section_I_32_nslit;
MCNUM d = mccCurved_Guide_Section_I_32_d;
MCNUM mleft = mccCurved_Guide_Section_I_32_mleft;
MCNUM mright = mccCurved_Guide_Section_I_32_mright;
MCNUM mtop = mccCurved_Guide_Section_I_32_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_32_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_32_nhslit;
MCNUM G = mccCurved_Guide_Section_I_32_G;
MCNUM aleft = mccCurved_Guide_Section_I_32_aleft;
MCNUM aright = mccCurved_Guide_Section_I_32_aright;
MCNUM atop = mccCurved_Guide_Section_I_32_atop;
MCNUM abottom = mccCurved_Guide_Section_I_32_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_32_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_32_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_32_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_32_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_32_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_32_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_32_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_32_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_32_nelements;
MCNUM nu = mccCurved_Guide_Section_I_32_nu;
MCNUM phase = mccCurved_Guide_Section_I_32_phase;
char* reflect = mccCurved_Guide_Section_I_32_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83153 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_32=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_I_33'. */
  SIG_MESSAGE("Curved_Guide_Section_I_33 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_I_33");
#define mccompcurname  Curved_Guide_Section_I_33
#define mccompcurtype  Guide_gravity
#define mccompcurindex 33
#define GVars mccCurved_Guide_Section_I_33_GVars
#define pTable mccCurved_Guide_Section_I_33_pTable
{   /* Declarations of Curved_Guide_Section_I_33=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_33_w1;
MCNUM h1 = mccCurved_Guide_Section_I_33_h1;
MCNUM w2 = mccCurved_Guide_Section_I_33_w2;
MCNUM h2 = mccCurved_Guide_Section_I_33_h2;
MCNUM l = mccCurved_Guide_Section_I_33_l;
MCNUM R0 = mccCurved_Guide_Section_I_33_R0;
MCNUM Qc = mccCurved_Guide_Section_I_33_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_33_alpha;
MCNUM m = mccCurved_Guide_Section_I_33_m;
MCNUM W = mccCurved_Guide_Section_I_33_W;
MCNUM nslit = mccCurved_Guide_Section_I_33_nslit;
MCNUM d = mccCurved_Guide_Section_I_33_d;
MCNUM mleft = mccCurved_Guide_Section_I_33_mleft;
MCNUM mright = mccCurved_Guide_Section_I_33_mright;
MCNUM mtop = mccCurved_Guide_Section_I_33_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_33_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_33_nhslit;
MCNUM G = mccCurved_Guide_Section_I_33_G;
MCNUM aleft = mccCurved_Guide_Section_I_33_aleft;
MCNUM aright = mccCurved_Guide_Section_I_33_aright;
MCNUM atop = mccCurved_Guide_Section_I_33_atop;
MCNUM abottom = mccCurved_Guide_Section_I_33_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_33_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_33_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_33_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_33_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_33_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_33_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_33_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_33_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_33_nelements;
MCNUM nu = mccCurved_Guide_Section_I_33_nu;
MCNUM phase = mccCurved_Guide_Section_I_33_phase;
char* reflect = mccCurved_Guide_Section_I_33_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83267 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_33=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_I_34'. */
  SIG_MESSAGE("Curved_Guide_Section_I_34 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_I_34");
#define mccompcurname  Curved_Guide_Section_I_34
#define mccompcurtype  Guide_gravity
#define mccompcurindex 34
#define GVars mccCurved_Guide_Section_I_34_GVars
#define pTable mccCurved_Guide_Section_I_34_pTable
{   /* Declarations of Curved_Guide_Section_I_34=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_34_w1;
MCNUM h1 = mccCurved_Guide_Section_I_34_h1;
MCNUM w2 = mccCurved_Guide_Section_I_34_w2;
MCNUM h2 = mccCurved_Guide_Section_I_34_h2;
MCNUM l = mccCurved_Guide_Section_I_34_l;
MCNUM R0 = mccCurved_Guide_Section_I_34_R0;
MCNUM Qc = mccCurved_Guide_Section_I_34_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_34_alpha;
MCNUM m = mccCurved_Guide_Section_I_34_m;
MCNUM W = mccCurved_Guide_Section_I_34_W;
MCNUM nslit = mccCurved_Guide_Section_I_34_nslit;
MCNUM d = mccCurved_Guide_Section_I_34_d;
MCNUM mleft = mccCurved_Guide_Section_I_34_mleft;
MCNUM mright = mccCurved_Guide_Section_I_34_mright;
MCNUM mtop = mccCurved_Guide_Section_I_34_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_34_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_34_nhslit;
MCNUM G = mccCurved_Guide_Section_I_34_G;
MCNUM aleft = mccCurved_Guide_Section_I_34_aleft;
MCNUM aright = mccCurved_Guide_Section_I_34_aright;
MCNUM atop = mccCurved_Guide_Section_I_34_atop;
MCNUM abottom = mccCurved_Guide_Section_I_34_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_34_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_34_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_34_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_34_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_34_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_34_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_34_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_34_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_34_nelements;
MCNUM nu = mccCurved_Guide_Section_I_34_nu;
MCNUM phase = mccCurved_Guide_Section_I_34_phase;
char* reflect = mccCurved_Guide_Section_I_34_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83381 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_34=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_I_35'. */
  SIG_MESSAGE("Curved_Guide_Section_I_35 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_I_35");
#define mccompcurname  Curved_Guide_Section_I_35
#define mccompcurtype  Guide_gravity
#define mccompcurindex 35
#define GVars mccCurved_Guide_Section_I_35_GVars
#define pTable mccCurved_Guide_Section_I_35_pTable
{   /* Declarations of Curved_Guide_Section_I_35=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_35_w1;
MCNUM h1 = mccCurved_Guide_Section_I_35_h1;
MCNUM w2 = mccCurved_Guide_Section_I_35_w2;
MCNUM h2 = mccCurved_Guide_Section_I_35_h2;
MCNUM l = mccCurved_Guide_Section_I_35_l;
MCNUM R0 = mccCurved_Guide_Section_I_35_R0;
MCNUM Qc = mccCurved_Guide_Section_I_35_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_35_alpha;
MCNUM m = mccCurved_Guide_Section_I_35_m;
MCNUM W = mccCurved_Guide_Section_I_35_W;
MCNUM nslit = mccCurved_Guide_Section_I_35_nslit;
MCNUM d = mccCurved_Guide_Section_I_35_d;
MCNUM mleft = mccCurved_Guide_Section_I_35_mleft;
MCNUM mright = mccCurved_Guide_Section_I_35_mright;
MCNUM mtop = mccCurved_Guide_Section_I_35_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_35_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_35_nhslit;
MCNUM G = mccCurved_Guide_Section_I_35_G;
MCNUM aleft = mccCurved_Guide_Section_I_35_aleft;
MCNUM aright = mccCurved_Guide_Section_I_35_aright;
MCNUM atop = mccCurved_Guide_Section_I_35_atop;
MCNUM abottom = mccCurved_Guide_Section_I_35_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_35_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_35_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_35_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_35_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_35_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_35_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_35_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_35_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_35_nelements;
MCNUM nu = mccCurved_Guide_Section_I_35_nu;
MCNUM phase = mccCurved_Guide_Section_I_35_phase;
char* reflect = mccCurved_Guide_Section_I_35_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83495 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_35=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_I_36'. */
  SIG_MESSAGE("Curved_Guide_Section_I_36 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_I_36");
#define mccompcurname  Curved_Guide_Section_I_36
#define mccompcurtype  Guide_gravity
#define mccompcurindex 36
#define GVars mccCurved_Guide_Section_I_36_GVars
#define pTable mccCurved_Guide_Section_I_36_pTable
{   /* Declarations of Curved_Guide_Section_I_36=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_36_w1;
MCNUM h1 = mccCurved_Guide_Section_I_36_h1;
MCNUM w2 = mccCurved_Guide_Section_I_36_w2;
MCNUM h2 = mccCurved_Guide_Section_I_36_h2;
MCNUM l = mccCurved_Guide_Section_I_36_l;
MCNUM R0 = mccCurved_Guide_Section_I_36_R0;
MCNUM Qc = mccCurved_Guide_Section_I_36_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_36_alpha;
MCNUM m = mccCurved_Guide_Section_I_36_m;
MCNUM W = mccCurved_Guide_Section_I_36_W;
MCNUM nslit = mccCurved_Guide_Section_I_36_nslit;
MCNUM d = mccCurved_Guide_Section_I_36_d;
MCNUM mleft = mccCurved_Guide_Section_I_36_mleft;
MCNUM mright = mccCurved_Guide_Section_I_36_mright;
MCNUM mtop = mccCurved_Guide_Section_I_36_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_36_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_36_nhslit;
MCNUM G = mccCurved_Guide_Section_I_36_G;
MCNUM aleft = mccCurved_Guide_Section_I_36_aleft;
MCNUM aright = mccCurved_Guide_Section_I_36_aright;
MCNUM atop = mccCurved_Guide_Section_I_36_atop;
MCNUM abottom = mccCurved_Guide_Section_I_36_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_36_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_36_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_36_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_36_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_36_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_36_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_36_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_36_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_36_nelements;
MCNUM nu = mccCurved_Guide_Section_I_36_nu;
MCNUM phase = mccCurved_Guide_Section_I_36_phase;
char* reflect = mccCurved_Guide_Section_I_36_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83609 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_36=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_I_37'. */
  SIG_MESSAGE("Curved_Guide_Section_I_37 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_I_37");
#define mccompcurname  Curved_Guide_Section_I_37
#define mccompcurtype  Guide_gravity
#define mccompcurindex 37
#define GVars mccCurved_Guide_Section_I_37_GVars
#define pTable mccCurved_Guide_Section_I_37_pTable
{   /* Declarations of Curved_Guide_Section_I_37=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_37_w1;
MCNUM h1 = mccCurved_Guide_Section_I_37_h1;
MCNUM w2 = mccCurved_Guide_Section_I_37_w2;
MCNUM h2 = mccCurved_Guide_Section_I_37_h2;
MCNUM l = mccCurved_Guide_Section_I_37_l;
MCNUM R0 = mccCurved_Guide_Section_I_37_R0;
MCNUM Qc = mccCurved_Guide_Section_I_37_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_37_alpha;
MCNUM m = mccCurved_Guide_Section_I_37_m;
MCNUM W = mccCurved_Guide_Section_I_37_W;
MCNUM nslit = mccCurved_Guide_Section_I_37_nslit;
MCNUM d = mccCurved_Guide_Section_I_37_d;
MCNUM mleft = mccCurved_Guide_Section_I_37_mleft;
MCNUM mright = mccCurved_Guide_Section_I_37_mright;
MCNUM mtop = mccCurved_Guide_Section_I_37_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_37_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_37_nhslit;
MCNUM G = mccCurved_Guide_Section_I_37_G;
MCNUM aleft = mccCurved_Guide_Section_I_37_aleft;
MCNUM aright = mccCurved_Guide_Section_I_37_aright;
MCNUM atop = mccCurved_Guide_Section_I_37_atop;
MCNUM abottom = mccCurved_Guide_Section_I_37_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_37_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_37_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_37_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_37_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_37_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_37_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_37_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_37_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_37_nelements;
MCNUM nu = mccCurved_Guide_Section_I_37_nu;
MCNUM phase = mccCurved_Guide_Section_I_37_phase;
char* reflect = mccCurved_Guide_Section_I_37_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83723 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_37=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_I_38'. */
  SIG_MESSAGE("Curved_Guide_Section_I_38 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_I_38");
#define mccompcurname  Curved_Guide_Section_I_38
#define mccompcurtype  Guide_gravity
#define mccompcurindex 38
#define GVars mccCurved_Guide_Section_I_38_GVars
#define pTable mccCurved_Guide_Section_I_38_pTable
{   /* Declarations of Curved_Guide_Section_I_38=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_38_w1;
MCNUM h1 = mccCurved_Guide_Section_I_38_h1;
MCNUM w2 = mccCurved_Guide_Section_I_38_w2;
MCNUM h2 = mccCurved_Guide_Section_I_38_h2;
MCNUM l = mccCurved_Guide_Section_I_38_l;
MCNUM R0 = mccCurved_Guide_Section_I_38_R0;
MCNUM Qc = mccCurved_Guide_Section_I_38_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_38_alpha;
MCNUM m = mccCurved_Guide_Section_I_38_m;
MCNUM W = mccCurved_Guide_Section_I_38_W;
MCNUM nslit = mccCurved_Guide_Section_I_38_nslit;
MCNUM d = mccCurved_Guide_Section_I_38_d;
MCNUM mleft = mccCurved_Guide_Section_I_38_mleft;
MCNUM mright = mccCurved_Guide_Section_I_38_mright;
MCNUM mtop = mccCurved_Guide_Section_I_38_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_38_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_38_nhslit;
MCNUM G = mccCurved_Guide_Section_I_38_G;
MCNUM aleft = mccCurved_Guide_Section_I_38_aleft;
MCNUM aright = mccCurved_Guide_Section_I_38_aright;
MCNUM atop = mccCurved_Guide_Section_I_38_atop;
MCNUM abottom = mccCurved_Guide_Section_I_38_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_38_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_38_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_38_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_38_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_38_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_38_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_38_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_38_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_38_nelements;
MCNUM nu = mccCurved_Guide_Section_I_38_nu;
MCNUM phase = mccCurved_Guide_Section_I_38_phase;
char* reflect = mccCurved_Guide_Section_I_38_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83837 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_38=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_I_short'. */
  SIG_MESSAGE("Curved_Guide_Section_I_short (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_I_short");
#define mccompcurname  Curved_Guide_Section_I_short
#define mccompcurtype  Guide_gravity
#define mccompcurindex 39
#define GVars mccCurved_Guide_Section_I_short_GVars
#define pTable mccCurved_Guide_Section_I_short_pTable
{   /* Declarations of Curved_Guide_Section_I_short=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_I_short_w1;
MCNUM h1 = mccCurved_Guide_Section_I_short_h1;
MCNUM w2 = mccCurved_Guide_Section_I_short_w2;
MCNUM h2 = mccCurved_Guide_Section_I_short_h2;
MCNUM l = mccCurved_Guide_Section_I_short_l;
MCNUM R0 = mccCurved_Guide_Section_I_short_R0;
MCNUM Qc = mccCurved_Guide_Section_I_short_Qc;
MCNUM alpha = mccCurved_Guide_Section_I_short_alpha;
MCNUM m = mccCurved_Guide_Section_I_short_m;
MCNUM W = mccCurved_Guide_Section_I_short_W;
MCNUM nslit = mccCurved_Guide_Section_I_short_nslit;
MCNUM d = mccCurved_Guide_Section_I_short_d;
MCNUM mleft = mccCurved_Guide_Section_I_short_mleft;
MCNUM mright = mccCurved_Guide_Section_I_short_mright;
MCNUM mtop = mccCurved_Guide_Section_I_short_mtop;
MCNUM mbottom = mccCurved_Guide_Section_I_short_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_I_short_nhslit;
MCNUM G = mccCurved_Guide_Section_I_short_G;
MCNUM aleft = mccCurved_Guide_Section_I_short_aleft;
MCNUM aright = mccCurved_Guide_Section_I_short_aright;
MCNUM atop = mccCurved_Guide_Section_I_short_atop;
MCNUM abottom = mccCurved_Guide_Section_I_short_abottom;
MCNUM wavy = mccCurved_Guide_Section_I_short_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_I_short_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_I_short_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_I_short_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_I_short_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_I_short_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_I_short_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_I_short_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_I_short_nelements;
MCNUM nu = mccCurved_Guide_Section_I_short_nu;
MCNUM phase = mccCurved_Guide_Section_I_short_phase;
char* reflect = mccCurved_Guide_Section_I_short_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83951 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_I_short=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap3_start'. */
  SIG_MESSAGE("Gap3_start (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap3_start");
#define mccompcurname  Gap3_start
#define mccompcurtype  Arm
#define mccompcurindex 40
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 83973 "./SNS_BASIS.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap3_start_Lam'. */
  SIG_MESSAGE("Gap3_start_Lam (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap3_start_Lam");
#define mccompcurname  Gap3_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 41
#define nL mccGap3_start_Lam_nL
#define L_N mccGap3_start_Lam_L_N
#define L_p mccGap3_start_Lam_L_p
#define L_p2 mccGap3_start_Lam_L_p2
{   /* Declarations of Gap3_start_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap3_start_Lam_filename;
MCNUM xmin = mccGap3_start_Lam_xmin;
MCNUM xmax = mccGap3_start_Lam_xmax;
MCNUM ymin = mccGap3_start_Lam_ymin;
MCNUM ymax = mccGap3_start_Lam_ymax;
MCNUM xwidth = mccGap3_start_Lam_xwidth;
MCNUM yheight = mccGap3_start_Lam_yheight;
MCNUM Lmin = mccGap3_start_Lam_Lmin;
MCNUM Lmax = mccGap3_start_Lam_Lmax;
MCNUM restore_neutron = mccGap3_start_Lam_restore_neutron;
int nowritefile = mccGap3_start_Lam_nowritefile;
#line 120 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 84009 "./SNS_BASIS.c"
}   /* End of Gap3_start_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'CGS1_end'. */
  SIG_MESSAGE("CGS1_end (McDisplay)");
  printf("MCDISPLAY: component %s\n", "CGS1_end");
#define mccompcurname  CGS1_end
#define mccompcurtype  PSD_monitor
#define mccompcurindex 42
#define PSD_N mccCGS1_end_PSD_N
#define PSD_p mccCGS1_end_PSD_p
#define PSD_p2 mccCGS1_end_PSD_p2
{   /* Declarations of CGS1_end=PSD_monitor() SETTING parameters. */
int nx = mccCGS1_end_nx;
int ny = mccCGS1_end_ny;
char* filename = mccCGS1_end_filename;
MCNUM xmin = mccCGS1_end_xmin;
MCNUM xmax = mccCGS1_end_xmax;
MCNUM ymin = mccCGS1_end_ymin;
MCNUM ymax = mccCGS1_end_ymax;
MCNUM xwidth = mccCGS1_end_xwidth;
MCNUM yheight = mccCGS1_end_yheight;
MCNUM restore_neutron = mccCGS1_end_restore_neutron;
#line 129 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  multiline(5,
    (double)xmin, (double)ymin, 0.0,
    (double)xmax, (double)ymin, 0.0,
    (double)xmax, (double)ymax, 0.0,
    (double)xmin, (double)ymax, 0.0,
    (double)xmin, (double)ymin, 0.0);
}
#line 84048 "./SNS_BASIS.c"
}   /* End of CGS1_end=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'before_Chopper1_ToF'. */
  SIG_MESSAGE("before_Chopper1_ToF (McDisplay)");
  printf("MCDISPLAY: component %s\n", "before_Chopper1_ToF");
#define mccompcurname  before_Chopper1_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 43
#define nt mccbefore_Chopper1_ToF_nt
#define TOF_N mccbefore_Chopper1_ToF_TOF_N
#define TOF_p mccbefore_Chopper1_ToF_TOF_p
#define TOF_p2 mccbefore_Chopper1_ToF_TOF_p2
#define t_min mccbefore_Chopper1_ToF_t_min
#define t_max mccbefore_Chopper1_ToF_t_max
#define delta_t mccbefore_Chopper1_ToF_delta_t
{   /* Declarations of before_Chopper1_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccbefore_Chopper1_ToF_filename;
MCNUM xmin = mccbefore_Chopper1_ToF_xmin;
MCNUM xmax = mccbefore_Chopper1_ToF_xmax;
MCNUM ymin = mccbefore_Chopper1_ToF_ymin;
MCNUM ymax = mccbefore_Chopper1_ToF_ymax;
MCNUM xwidth = mccbefore_Chopper1_ToF_xwidth;
MCNUM yheight = mccbefore_Chopper1_ToF_yheight;
MCNUM tmin = mccbefore_Chopper1_ToF_tmin;
MCNUM tmax = mccbefore_Chopper1_ToF_tmax;
MCNUM dt = mccbefore_Chopper1_ToF_dt;
MCNUM restore_neutron = mccbefore_Chopper1_ToF_restore_neutron;
int nowritefile = mccbefore_Chopper1_ToF_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 84092 "./SNS_BASIS.c"
}   /* End of before_Chopper1_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'before_Chopper1_ToF_Z'. */
  SIG_MESSAGE("before_Chopper1_ToF_Z (McDisplay)");
  printf("MCDISPLAY: component %s\n", "before_Chopper1_ToF_Z");
#define mccompcurname  before_Chopper1_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 44
#define nt mccbefore_Chopper1_ToF_Z_nt
#define TOF_N mccbefore_Chopper1_ToF_Z_TOF_N
#define TOF_p mccbefore_Chopper1_ToF_Z_TOF_p
#define TOF_p2 mccbefore_Chopper1_ToF_Z_TOF_p2
#define t_min mccbefore_Chopper1_ToF_Z_t_min
#define t_max mccbefore_Chopper1_ToF_Z_t_max
#define delta_t mccbefore_Chopper1_ToF_Z_delta_t
{   /* Declarations of before_Chopper1_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccbefore_Chopper1_ToF_Z_filename;
MCNUM xmin = mccbefore_Chopper1_ToF_Z_xmin;
MCNUM xmax = mccbefore_Chopper1_ToF_Z_xmax;
MCNUM ymin = mccbefore_Chopper1_ToF_Z_ymin;
MCNUM ymax = mccbefore_Chopper1_ToF_Z_ymax;
MCNUM xwidth = mccbefore_Chopper1_ToF_Z_xwidth;
MCNUM yheight = mccbefore_Chopper1_ToF_Z_yheight;
MCNUM tmin = mccbefore_Chopper1_ToF_Z_tmin;
MCNUM tmax = mccbefore_Chopper1_ToF_Z_tmax;
MCNUM dt = mccbefore_Chopper1_ToF_Z_dt;
MCNUM restore_neutron = mccbefore_Chopper1_ToF_Z_restore_neutron;
int nowritefile = mccbefore_Chopper1_ToF_Z_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 84140 "./SNS_BASIS.c"
}   /* End of before_Chopper1_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Chopper1'. */
  SIG_MESSAGE("Chopper1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Chopper1");
#define mccompcurname  Chopper1
#define mccompcurtype  DiskChopper
#define mccompcurindex 45
#define Tg mccChopper1_Tg
#define To mccChopper1_To
#define delta_y mccChopper1_delta_y
#define height mccChopper1_height
#define omega mccChopper1_omega
{   /* Declarations of Chopper1=DiskChopper() SETTING parameters. */
MCNUM theta_0 = mccChopper1_theta_0;
MCNUM radius = mccChopper1_radius;
MCNUM yheight = mccChopper1_yheight;
MCNUM nu = mccChopper1_nu;
MCNUM nslit = mccChopper1_nslit;
MCNUM jitter = mccChopper1_jitter;
MCNUM delay = mccChopper1_delay;
MCNUM isfirst = mccChopper1_isfirst;
MCNUM n_pulse = mccChopper1_n_pulse;
MCNUM abs_out = mccChopper1_abs_out;
MCNUM phase = mccChopper1_phase;
MCNUM xwidth = mccChopper1_xwidth;
MCNUM verbose = mccChopper1_verbose;
#line 168 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/DiskChopper.comp"
{

  int j;
  /* Arrays for storing geometry of slit/beamstop */
  
  circle("xy", 0, -delta_y, 0, radius);

  /* Drawing the slit(s) */
  for (j=0; j<nslit; j++) {
    /* Angular start/end of slit */
    double tmin = j*(2.0*PI/nslit) - theta_0/2.0 + phase;
    double tmax = tmin+theta_0;
    /* Draw lines for each slit. */

    line(
      radius*sin(tmin),          radius*cos(tmin)-delta_y,          0,
      (radius-height)*sin(tmin), (radius-height)*cos(tmin)-delta_y, 0
      );
    line(
      (radius-height)*sin(tmin), (radius-height)*cos(tmin)-delta_y, 0,
      (radius-height)*sin(tmax), (radius-height)*cos(tmax)-delta_y, 0);
    line(
      (radius-height)*sin(tmax), (radius-height)*cos(tmax)-delta_y, 0,
      radius*sin(tmax),          radius*cos(tmax)-delta_y,          0);
  }
}
#line 84205 "./SNS_BASIS.c"
}   /* End of Chopper1=DiskChopper() SETTING parameter declarations. */
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Chopper1_ToF'. */
  SIG_MESSAGE("Chopper1_ToF (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Chopper1_ToF");
#define mccompcurname  Chopper1_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 46
#define nt mccChopper1_ToF_nt
#define TOF_N mccChopper1_ToF_TOF_N
#define TOF_p mccChopper1_ToF_TOF_p
#define TOF_p2 mccChopper1_ToF_TOF_p2
#define t_min mccChopper1_ToF_t_min
#define t_max mccChopper1_ToF_t_max
#define delta_t mccChopper1_ToF_delta_t
{   /* Declarations of Chopper1_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccChopper1_ToF_filename;
MCNUM xmin = mccChopper1_ToF_xmin;
MCNUM xmax = mccChopper1_ToF_xmax;
MCNUM ymin = mccChopper1_ToF_ymin;
MCNUM ymax = mccChopper1_ToF_ymax;
MCNUM xwidth = mccChopper1_ToF_xwidth;
MCNUM yheight = mccChopper1_ToF_yheight;
MCNUM tmin = mccChopper1_ToF_tmin;
MCNUM tmax = mccChopper1_ToF_tmax;
MCNUM dt = mccChopper1_ToF_dt;
MCNUM restore_neutron = mccChopper1_ToF_restore_neutron;
int nowritefile = mccChopper1_ToF_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 84251 "./SNS_BASIS.c"
}   /* End of Chopper1_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Chopper1_ToF_Z'. */
  SIG_MESSAGE("Chopper1_ToF_Z (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Chopper1_ToF_Z");
#define mccompcurname  Chopper1_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 47
#define nt mccChopper1_ToF_Z_nt
#define TOF_N mccChopper1_ToF_Z_TOF_N
#define TOF_p mccChopper1_ToF_Z_TOF_p
#define TOF_p2 mccChopper1_ToF_Z_TOF_p2
#define t_min mccChopper1_ToF_Z_t_min
#define t_max mccChopper1_ToF_Z_t_max
#define delta_t mccChopper1_ToF_Z_delta_t
{   /* Declarations of Chopper1_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccChopper1_ToF_Z_filename;
MCNUM xmin = mccChopper1_ToF_Z_xmin;
MCNUM xmax = mccChopper1_ToF_Z_xmax;
MCNUM ymin = mccChopper1_ToF_Z_ymin;
MCNUM ymax = mccChopper1_ToF_Z_ymax;
MCNUM xwidth = mccChopper1_ToF_Z_xwidth;
MCNUM yheight = mccChopper1_ToF_Z_yheight;
MCNUM tmin = mccChopper1_ToF_Z_tmin;
MCNUM tmax = mccChopper1_ToF_Z_tmax;
MCNUM dt = mccChopper1_ToF_Z_dt;
MCNUM restore_neutron = mccChopper1_ToF_Z_restore_neutron;
int nowritefile = mccChopper1_ToF_Z_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 84299 "./SNS_BASIS.c"
}   /* End of Chopper1_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap3_end_Lam'. */
  SIG_MESSAGE("Gap3_end_Lam (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap3_end_Lam");
#define mccompcurname  Gap3_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 48
#define nL mccGap3_end_Lam_nL
#define L_N mccGap3_end_Lam_L_N
#define L_p mccGap3_end_Lam_L_p
#define L_p2 mccGap3_end_Lam_L_p2
{   /* Declarations of Gap3_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap3_end_Lam_filename;
MCNUM xmin = mccGap3_end_Lam_xmin;
MCNUM xmax = mccGap3_end_Lam_xmax;
MCNUM ymin = mccGap3_end_Lam_ymin;
MCNUM ymax = mccGap3_end_Lam_ymax;
MCNUM xwidth = mccGap3_end_Lam_xwidth;
MCNUM yheight = mccGap3_end_Lam_yheight;
MCNUM Lmin = mccGap3_end_Lam_Lmin;
MCNUM Lmax = mccGap3_end_Lam_Lmax;
MCNUM restore_neutron = mccGap3_end_Lam_restore_neutron;
int nowritefile = mccGap3_end_Lam_nowritefile;
#line 120 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 84343 "./SNS_BASIS.c"
}   /* End of Gap3_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap3_end_PSD'. */
  SIG_MESSAGE("Gap3_end_PSD (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap3_end_PSD");
#define mccompcurname  Gap3_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 49
#define PSD_N mccGap3_end_PSD_PSD_N
#define PSD_p mccGap3_end_PSD_PSD_p
#define PSD_p2 mccGap3_end_PSD_PSD_p2
{   /* Declarations of Gap3_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap3_end_PSD_nx;
int ny = mccGap3_end_PSD_ny;
char* filename = mccGap3_end_PSD_filename;
MCNUM xmin = mccGap3_end_PSD_xmin;
MCNUM xmax = mccGap3_end_PSD_xmax;
MCNUM ymin = mccGap3_end_PSD_ymin;
MCNUM ymax = mccGap3_end_PSD_ymax;
MCNUM xwidth = mccGap3_end_PSD_xwidth;
MCNUM yheight = mccGap3_end_PSD_yheight;
MCNUM restore_neutron = mccGap3_end_PSD_restore_neutron;
#line 129 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  multiline(5,
    (double)xmin, (double)ymin, 0.0,
    (double)xmax, (double)ymin, 0.0,
    (double)xmax, (double)ymax, 0.0,
    (double)xmin, (double)ymax, 0.0,
    (double)xmin, (double)ymin, 0.0);
}
#line 84382 "./SNS_BASIS.c"
}   /* End of Gap3_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap3_end'. */
  SIG_MESSAGE("Gap3_end (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap3_end");
#define mccompcurname  Gap3_end
#define mccompcurtype  Arm
#define mccompcurindex 50
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 84405 "./SNS_BASIS.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_II'. */
  SIG_MESSAGE("Curved_Guide_Section_II (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_II");
#define mccompcurname  Curved_Guide_Section_II
#define mccompcurtype  Guide_gravity
#define mccompcurindex 51
#define GVars mccCurved_Guide_Section_II_GVars
#define pTable mccCurved_Guide_Section_II_pTable
{   /* Declarations of Curved_Guide_Section_II=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_w1;
MCNUM h1 = mccCurved_Guide_Section_II_h1;
MCNUM w2 = mccCurved_Guide_Section_II_w2;
MCNUM h2 = mccCurved_Guide_Section_II_h2;
MCNUM l = mccCurved_Guide_Section_II_l;
MCNUM R0 = mccCurved_Guide_Section_II_R0;
MCNUM Qc = mccCurved_Guide_Section_II_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_alpha;
MCNUM m = mccCurved_Guide_Section_II_m;
MCNUM W = mccCurved_Guide_Section_II_W;
MCNUM nslit = mccCurved_Guide_Section_II_nslit;
MCNUM d = mccCurved_Guide_Section_II_d;
MCNUM mleft = mccCurved_Guide_Section_II_mleft;
MCNUM mright = mccCurved_Guide_Section_II_mright;
MCNUM mtop = mccCurved_Guide_Section_II_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_nhslit;
MCNUM G = mccCurved_Guide_Section_II_G;
MCNUM aleft = mccCurved_Guide_Section_II_aleft;
MCNUM aright = mccCurved_Guide_Section_II_aright;
MCNUM atop = mccCurved_Guide_Section_II_atop;
MCNUM abottom = mccCurved_Guide_Section_II_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_nelements;
MCNUM nu = mccCurved_Guide_Section_II_nu;
MCNUM phase = mccCurved_Guide_Section_II_phase;
char* reflect = mccCurved_Guide_Section_II_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 84516 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_II_52'. */
  SIG_MESSAGE("Curved_Guide_Section_II_52 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_II_52");
#define mccompcurname  Curved_Guide_Section_II_52
#define mccompcurtype  Guide_gravity
#define mccompcurindex 52
#define GVars mccCurved_Guide_Section_II_52_GVars
#define pTable mccCurved_Guide_Section_II_52_pTable
{   /* Declarations of Curved_Guide_Section_II_52=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_52_w1;
MCNUM h1 = mccCurved_Guide_Section_II_52_h1;
MCNUM w2 = mccCurved_Guide_Section_II_52_w2;
MCNUM h2 = mccCurved_Guide_Section_II_52_h2;
MCNUM l = mccCurved_Guide_Section_II_52_l;
MCNUM R0 = mccCurved_Guide_Section_II_52_R0;
MCNUM Qc = mccCurved_Guide_Section_II_52_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_52_alpha;
MCNUM m = mccCurved_Guide_Section_II_52_m;
MCNUM W = mccCurved_Guide_Section_II_52_W;
MCNUM nslit = mccCurved_Guide_Section_II_52_nslit;
MCNUM d = mccCurved_Guide_Section_II_52_d;
MCNUM mleft = mccCurved_Guide_Section_II_52_mleft;
MCNUM mright = mccCurved_Guide_Section_II_52_mright;
MCNUM mtop = mccCurved_Guide_Section_II_52_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_52_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_52_nhslit;
MCNUM G = mccCurved_Guide_Section_II_52_G;
MCNUM aleft = mccCurved_Guide_Section_II_52_aleft;
MCNUM aright = mccCurved_Guide_Section_II_52_aright;
MCNUM atop = mccCurved_Guide_Section_II_52_atop;
MCNUM abottom = mccCurved_Guide_Section_II_52_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_52_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_52_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_52_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_52_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_52_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_52_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_52_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_52_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_52_nelements;
MCNUM nu = mccCurved_Guide_Section_II_52_nu;
MCNUM phase = mccCurved_Guide_Section_II_52_phase;
char* reflect = mccCurved_Guide_Section_II_52_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 84630 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II_52=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_II_53'. */
  SIG_MESSAGE("Curved_Guide_Section_II_53 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_II_53");
#define mccompcurname  Curved_Guide_Section_II_53
#define mccompcurtype  Guide_gravity
#define mccompcurindex 53
#define GVars mccCurved_Guide_Section_II_53_GVars
#define pTable mccCurved_Guide_Section_II_53_pTable
{   /* Declarations of Curved_Guide_Section_II_53=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_53_w1;
MCNUM h1 = mccCurved_Guide_Section_II_53_h1;
MCNUM w2 = mccCurved_Guide_Section_II_53_w2;
MCNUM h2 = mccCurved_Guide_Section_II_53_h2;
MCNUM l = mccCurved_Guide_Section_II_53_l;
MCNUM R0 = mccCurved_Guide_Section_II_53_R0;
MCNUM Qc = mccCurved_Guide_Section_II_53_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_53_alpha;
MCNUM m = mccCurved_Guide_Section_II_53_m;
MCNUM W = mccCurved_Guide_Section_II_53_W;
MCNUM nslit = mccCurved_Guide_Section_II_53_nslit;
MCNUM d = mccCurved_Guide_Section_II_53_d;
MCNUM mleft = mccCurved_Guide_Section_II_53_mleft;
MCNUM mright = mccCurved_Guide_Section_II_53_mright;
MCNUM mtop = mccCurved_Guide_Section_II_53_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_53_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_53_nhslit;
MCNUM G = mccCurved_Guide_Section_II_53_G;
MCNUM aleft = mccCurved_Guide_Section_II_53_aleft;
MCNUM aright = mccCurved_Guide_Section_II_53_aright;
MCNUM atop = mccCurved_Guide_Section_II_53_atop;
MCNUM abottom = mccCurved_Guide_Section_II_53_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_53_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_53_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_53_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_53_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_53_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_53_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_53_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_53_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_53_nelements;
MCNUM nu = mccCurved_Guide_Section_II_53_nu;
MCNUM phase = mccCurved_Guide_Section_II_53_phase;
char* reflect = mccCurved_Guide_Section_II_53_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 84744 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II_53=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_II_54'. */
  SIG_MESSAGE("Curved_Guide_Section_II_54 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_II_54");
#define mccompcurname  Curved_Guide_Section_II_54
#define mccompcurtype  Guide_gravity
#define mccompcurindex 54
#define GVars mccCurved_Guide_Section_II_54_GVars
#define pTable mccCurved_Guide_Section_II_54_pTable
{   /* Declarations of Curved_Guide_Section_II_54=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_54_w1;
MCNUM h1 = mccCurved_Guide_Section_II_54_h1;
MCNUM w2 = mccCurved_Guide_Section_II_54_w2;
MCNUM h2 = mccCurved_Guide_Section_II_54_h2;
MCNUM l = mccCurved_Guide_Section_II_54_l;
MCNUM R0 = mccCurved_Guide_Section_II_54_R0;
MCNUM Qc = mccCurved_Guide_Section_II_54_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_54_alpha;
MCNUM m = mccCurved_Guide_Section_II_54_m;
MCNUM W = mccCurved_Guide_Section_II_54_W;
MCNUM nslit = mccCurved_Guide_Section_II_54_nslit;
MCNUM d = mccCurved_Guide_Section_II_54_d;
MCNUM mleft = mccCurved_Guide_Section_II_54_mleft;
MCNUM mright = mccCurved_Guide_Section_II_54_mright;
MCNUM mtop = mccCurved_Guide_Section_II_54_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_54_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_54_nhslit;
MCNUM G = mccCurved_Guide_Section_II_54_G;
MCNUM aleft = mccCurved_Guide_Section_II_54_aleft;
MCNUM aright = mccCurved_Guide_Section_II_54_aright;
MCNUM atop = mccCurved_Guide_Section_II_54_atop;
MCNUM abottom = mccCurved_Guide_Section_II_54_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_54_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_54_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_54_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_54_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_54_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_54_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_54_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_54_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_54_nelements;
MCNUM nu = mccCurved_Guide_Section_II_54_nu;
MCNUM phase = mccCurved_Guide_Section_II_54_phase;
char* reflect = mccCurved_Guide_Section_II_54_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 84858 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II_54=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_II_55'. */
  SIG_MESSAGE("Curved_Guide_Section_II_55 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_II_55");
#define mccompcurname  Curved_Guide_Section_II_55
#define mccompcurtype  Guide_gravity
#define mccompcurindex 55
#define GVars mccCurved_Guide_Section_II_55_GVars
#define pTable mccCurved_Guide_Section_II_55_pTable
{   /* Declarations of Curved_Guide_Section_II_55=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_55_w1;
MCNUM h1 = mccCurved_Guide_Section_II_55_h1;
MCNUM w2 = mccCurved_Guide_Section_II_55_w2;
MCNUM h2 = mccCurved_Guide_Section_II_55_h2;
MCNUM l = mccCurved_Guide_Section_II_55_l;
MCNUM R0 = mccCurved_Guide_Section_II_55_R0;
MCNUM Qc = mccCurved_Guide_Section_II_55_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_55_alpha;
MCNUM m = mccCurved_Guide_Section_II_55_m;
MCNUM W = mccCurved_Guide_Section_II_55_W;
MCNUM nslit = mccCurved_Guide_Section_II_55_nslit;
MCNUM d = mccCurved_Guide_Section_II_55_d;
MCNUM mleft = mccCurved_Guide_Section_II_55_mleft;
MCNUM mright = mccCurved_Guide_Section_II_55_mright;
MCNUM mtop = mccCurved_Guide_Section_II_55_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_55_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_55_nhslit;
MCNUM G = mccCurved_Guide_Section_II_55_G;
MCNUM aleft = mccCurved_Guide_Section_II_55_aleft;
MCNUM aright = mccCurved_Guide_Section_II_55_aright;
MCNUM atop = mccCurved_Guide_Section_II_55_atop;
MCNUM abottom = mccCurved_Guide_Section_II_55_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_55_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_55_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_55_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_55_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_55_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_55_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_55_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_55_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_55_nelements;
MCNUM nu = mccCurved_Guide_Section_II_55_nu;
MCNUM phase = mccCurved_Guide_Section_II_55_phase;
char* reflect = mccCurved_Guide_Section_II_55_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 84972 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II_55=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_II_56'. */
  SIG_MESSAGE("Curved_Guide_Section_II_56 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_II_56");
#define mccompcurname  Curved_Guide_Section_II_56
#define mccompcurtype  Guide_gravity
#define mccompcurindex 56
#define GVars mccCurved_Guide_Section_II_56_GVars
#define pTable mccCurved_Guide_Section_II_56_pTable
{   /* Declarations of Curved_Guide_Section_II_56=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_56_w1;
MCNUM h1 = mccCurved_Guide_Section_II_56_h1;
MCNUM w2 = mccCurved_Guide_Section_II_56_w2;
MCNUM h2 = mccCurved_Guide_Section_II_56_h2;
MCNUM l = mccCurved_Guide_Section_II_56_l;
MCNUM R0 = mccCurved_Guide_Section_II_56_R0;
MCNUM Qc = mccCurved_Guide_Section_II_56_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_56_alpha;
MCNUM m = mccCurved_Guide_Section_II_56_m;
MCNUM W = mccCurved_Guide_Section_II_56_W;
MCNUM nslit = mccCurved_Guide_Section_II_56_nslit;
MCNUM d = mccCurved_Guide_Section_II_56_d;
MCNUM mleft = mccCurved_Guide_Section_II_56_mleft;
MCNUM mright = mccCurved_Guide_Section_II_56_mright;
MCNUM mtop = mccCurved_Guide_Section_II_56_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_56_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_56_nhslit;
MCNUM G = mccCurved_Guide_Section_II_56_G;
MCNUM aleft = mccCurved_Guide_Section_II_56_aleft;
MCNUM aright = mccCurved_Guide_Section_II_56_aright;
MCNUM atop = mccCurved_Guide_Section_II_56_atop;
MCNUM abottom = mccCurved_Guide_Section_II_56_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_56_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_56_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_56_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_56_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_56_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_56_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_56_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_56_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_56_nelements;
MCNUM nu = mccCurved_Guide_Section_II_56_nu;
MCNUM phase = mccCurved_Guide_Section_II_56_phase;
char* reflect = mccCurved_Guide_Section_II_56_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 85086 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II_56=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_II_57'. */
  SIG_MESSAGE("Curved_Guide_Section_II_57 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_II_57");
#define mccompcurname  Curved_Guide_Section_II_57
#define mccompcurtype  Guide_gravity
#define mccompcurindex 57
#define GVars mccCurved_Guide_Section_II_57_GVars
#define pTable mccCurved_Guide_Section_II_57_pTable
{   /* Declarations of Curved_Guide_Section_II_57=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_57_w1;
MCNUM h1 = mccCurved_Guide_Section_II_57_h1;
MCNUM w2 = mccCurved_Guide_Section_II_57_w2;
MCNUM h2 = mccCurved_Guide_Section_II_57_h2;
MCNUM l = mccCurved_Guide_Section_II_57_l;
MCNUM R0 = mccCurved_Guide_Section_II_57_R0;
MCNUM Qc = mccCurved_Guide_Section_II_57_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_57_alpha;
MCNUM m = mccCurved_Guide_Section_II_57_m;
MCNUM W = mccCurved_Guide_Section_II_57_W;
MCNUM nslit = mccCurved_Guide_Section_II_57_nslit;
MCNUM d = mccCurved_Guide_Section_II_57_d;
MCNUM mleft = mccCurved_Guide_Section_II_57_mleft;
MCNUM mright = mccCurved_Guide_Section_II_57_mright;
MCNUM mtop = mccCurved_Guide_Section_II_57_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_57_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_57_nhslit;
MCNUM G = mccCurved_Guide_Section_II_57_G;
MCNUM aleft = mccCurved_Guide_Section_II_57_aleft;
MCNUM aright = mccCurved_Guide_Section_II_57_aright;
MCNUM atop = mccCurved_Guide_Section_II_57_atop;
MCNUM abottom = mccCurved_Guide_Section_II_57_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_57_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_57_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_57_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_57_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_57_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_57_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_57_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_57_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_57_nelements;
MCNUM nu = mccCurved_Guide_Section_II_57_nu;
MCNUM phase = mccCurved_Guide_Section_II_57_phase;
char* reflect = mccCurved_Guide_Section_II_57_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 85200 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II_57=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_II_last'. */
  SIG_MESSAGE("Curved_Guide_Section_II_last (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_II_last");
#define mccompcurname  Curved_Guide_Section_II_last
#define mccompcurtype  Guide_gravity
#define mccompcurindex 58
#define GVars mccCurved_Guide_Section_II_last_GVars
#define pTable mccCurved_Guide_Section_II_last_pTable
{   /* Declarations of Curved_Guide_Section_II_last=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_II_last_w1;
MCNUM h1 = mccCurved_Guide_Section_II_last_h1;
MCNUM w2 = mccCurved_Guide_Section_II_last_w2;
MCNUM h2 = mccCurved_Guide_Section_II_last_h2;
MCNUM l = mccCurved_Guide_Section_II_last_l;
MCNUM R0 = mccCurved_Guide_Section_II_last_R0;
MCNUM Qc = mccCurved_Guide_Section_II_last_Qc;
MCNUM alpha = mccCurved_Guide_Section_II_last_alpha;
MCNUM m = mccCurved_Guide_Section_II_last_m;
MCNUM W = mccCurved_Guide_Section_II_last_W;
MCNUM nslit = mccCurved_Guide_Section_II_last_nslit;
MCNUM d = mccCurved_Guide_Section_II_last_d;
MCNUM mleft = mccCurved_Guide_Section_II_last_mleft;
MCNUM mright = mccCurved_Guide_Section_II_last_mright;
MCNUM mtop = mccCurved_Guide_Section_II_last_mtop;
MCNUM mbottom = mccCurved_Guide_Section_II_last_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_II_last_nhslit;
MCNUM G = mccCurved_Guide_Section_II_last_G;
MCNUM aleft = mccCurved_Guide_Section_II_last_aleft;
MCNUM aright = mccCurved_Guide_Section_II_last_aright;
MCNUM atop = mccCurved_Guide_Section_II_last_atop;
MCNUM abottom = mccCurved_Guide_Section_II_last_abottom;
MCNUM wavy = mccCurved_Guide_Section_II_last_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_II_last_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_II_last_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_II_last_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_II_last_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_II_last_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_II_last_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_II_last_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_II_last_nelements;
MCNUM nu = mccCurved_Guide_Section_II_last_nu;
MCNUM phase = mccCurved_Guide_Section_II_last_phase;
char* reflect = mccCurved_Guide_Section_II_last_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 85314 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_II_last=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap4_start'. */
  SIG_MESSAGE("Gap4_start (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap4_start");
#define mccompcurname  Gap4_start
#define mccompcurtype  Arm
#define mccompcurindex 59
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 85336 "./SNS_BASIS.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap4_start_Lam'. */
  SIG_MESSAGE("Gap4_start_Lam (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap4_start_Lam");
#define mccompcurname  Gap4_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 60
#define nL mccGap4_start_Lam_nL
#define L_N mccGap4_start_Lam_L_N
#define L_p mccGap4_start_Lam_L_p
#define L_p2 mccGap4_start_Lam_L_p2
{   /* Declarations of Gap4_start_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap4_start_Lam_filename;
MCNUM xmin = mccGap4_start_Lam_xmin;
MCNUM xmax = mccGap4_start_Lam_xmax;
MCNUM ymin = mccGap4_start_Lam_ymin;
MCNUM ymax = mccGap4_start_Lam_ymax;
MCNUM xwidth = mccGap4_start_Lam_xwidth;
MCNUM yheight = mccGap4_start_Lam_yheight;
MCNUM Lmin = mccGap4_start_Lam_Lmin;
MCNUM Lmax = mccGap4_start_Lam_Lmax;
MCNUM restore_neutron = mccGap4_start_Lam_restore_neutron;
int nowritefile = mccGap4_start_Lam_nowritefile;
#line 120 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 85372 "./SNS_BASIS.c"
}   /* End of Gap4_start_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap4_start_PSD'. */
  SIG_MESSAGE("Gap4_start_PSD (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap4_start_PSD");
#define mccompcurname  Gap4_start_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 61
#define PSD_N mccGap4_start_PSD_PSD_N
#define PSD_p mccGap4_start_PSD_PSD_p
#define PSD_p2 mccGap4_start_PSD_PSD_p2
{   /* Declarations of Gap4_start_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap4_start_PSD_nx;
int ny = mccGap4_start_PSD_ny;
char* filename = mccGap4_start_PSD_filename;
MCNUM xmin = mccGap4_start_PSD_xmin;
MCNUM xmax = mccGap4_start_PSD_xmax;
MCNUM ymin = mccGap4_start_PSD_ymin;
MCNUM ymax = mccGap4_start_PSD_ymax;
MCNUM xwidth = mccGap4_start_PSD_xwidth;
MCNUM yheight = mccGap4_start_PSD_yheight;
MCNUM restore_neutron = mccGap4_start_PSD_restore_neutron;
#line 129 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  multiline(5,
    (double)xmin, (double)ymin, 0.0,
    (double)xmax, (double)ymin, 0.0,
    (double)xmax, (double)ymax, 0.0,
    (double)xmin, (double)ymax, 0.0,
    (double)xmin, (double)ymin, 0.0);
}
#line 85411 "./SNS_BASIS.c"
}   /* End of Gap4_start_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'before_Chopper2_ToF'. */
  SIG_MESSAGE("before_Chopper2_ToF (McDisplay)");
  printf("MCDISPLAY: component %s\n", "before_Chopper2_ToF");
#define mccompcurname  before_Chopper2_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 62
#define nt mccbefore_Chopper2_ToF_nt
#define TOF_N mccbefore_Chopper2_ToF_TOF_N
#define TOF_p mccbefore_Chopper2_ToF_TOF_p
#define TOF_p2 mccbefore_Chopper2_ToF_TOF_p2
#define t_min mccbefore_Chopper2_ToF_t_min
#define t_max mccbefore_Chopper2_ToF_t_max
#define delta_t mccbefore_Chopper2_ToF_delta_t
{   /* Declarations of before_Chopper2_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccbefore_Chopper2_ToF_filename;
MCNUM xmin = mccbefore_Chopper2_ToF_xmin;
MCNUM xmax = mccbefore_Chopper2_ToF_xmax;
MCNUM ymin = mccbefore_Chopper2_ToF_ymin;
MCNUM ymax = mccbefore_Chopper2_ToF_ymax;
MCNUM xwidth = mccbefore_Chopper2_ToF_xwidth;
MCNUM yheight = mccbefore_Chopper2_ToF_yheight;
MCNUM tmin = mccbefore_Chopper2_ToF_tmin;
MCNUM tmax = mccbefore_Chopper2_ToF_tmax;
MCNUM dt = mccbefore_Chopper2_ToF_dt;
MCNUM restore_neutron = mccbefore_Chopper2_ToF_restore_neutron;
int nowritefile = mccbefore_Chopper2_ToF_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 85455 "./SNS_BASIS.c"
}   /* End of before_Chopper2_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'before_Chopper2_ToF_Z'. */
  SIG_MESSAGE("before_Chopper2_ToF_Z (McDisplay)");
  printf("MCDISPLAY: component %s\n", "before_Chopper2_ToF_Z");
#define mccompcurname  before_Chopper2_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 63
#define nt mccbefore_Chopper2_ToF_Z_nt
#define TOF_N mccbefore_Chopper2_ToF_Z_TOF_N
#define TOF_p mccbefore_Chopper2_ToF_Z_TOF_p
#define TOF_p2 mccbefore_Chopper2_ToF_Z_TOF_p2
#define t_min mccbefore_Chopper2_ToF_Z_t_min
#define t_max mccbefore_Chopper2_ToF_Z_t_max
#define delta_t mccbefore_Chopper2_ToF_Z_delta_t
{   /* Declarations of before_Chopper2_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccbefore_Chopper2_ToF_Z_filename;
MCNUM xmin = mccbefore_Chopper2_ToF_Z_xmin;
MCNUM xmax = mccbefore_Chopper2_ToF_Z_xmax;
MCNUM ymin = mccbefore_Chopper2_ToF_Z_ymin;
MCNUM ymax = mccbefore_Chopper2_ToF_Z_ymax;
MCNUM xwidth = mccbefore_Chopper2_ToF_Z_xwidth;
MCNUM yheight = mccbefore_Chopper2_ToF_Z_yheight;
MCNUM tmin = mccbefore_Chopper2_ToF_Z_tmin;
MCNUM tmax = mccbefore_Chopper2_ToF_Z_tmax;
MCNUM dt = mccbefore_Chopper2_ToF_Z_dt;
MCNUM restore_neutron = mccbefore_Chopper2_ToF_Z_restore_neutron;
int nowritefile = mccbefore_Chopper2_ToF_Z_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 85503 "./SNS_BASIS.c"
}   /* End of before_Chopper2_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Chopper2'. */
  SIG_MESSAGE("Chopper2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Chopper2");
#define mccompcurname  Chopper2
#define mccompcurtype  DiskChopper
#define mccompcurindex 64
#define Tg mccChopper2_Tg
#define To mccChopper2_To
#define delta_y mccChopper2_delta_y
#define height mccChopper2_height
#define omega mccChopper2_omega
{   /* Declarations of Chopper2=DiskChopper() SETTING parameters. */
MCNUM theta_0 = mccChopper2_theta_0;
MCNUM radius = mccChopper2_radius;
MCNUM yheight = mccChopper2_yheight;
MCNUM nu = mccChopper2_nu;
MCNUM nslit = mccChopper2_nslit;
MCNUM jitter = mccChopper2_jitter;
MCNUM delay = mccChopper2_delay;
MCNUM isfirst = mccChopper2_isfirst;
MCNUM n_pulse = mccChopper2_n_pulse;
MCNUM abs_out = mccChopper2_abs_out;
MCNUM phase = mccChopper2_phase;
MCNUM xwidth = mccChopper2_xwidth;
MCNUM verbose = mccChopper2_verbose;
#line 168 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/DiskChopper.comp"
{

  int j;
  /* Arrays for storing geometry of slit/beamstop */
  
  circle("xy", 0, -delta_y, 0, radius);

  /* Drawing the slit(s) */
  for (j=0; j<nslit; j++) {
    /* Angular start/end of slit */
    double tmin = j*(2.0*PI/nslit) - theta_0/2.0 + phase;
    double tmax = tmin+theta_0;
    /* Draw lines for each slit. */

    line(
      radius*sin(tmin),          radius*cos(tmin)-delta_y,          0,
      (radius-height)*sin(tmin), (radius-height)*cos(tmin)-delta_y, 0
      );
    line(
      (radius-height)*sin(tmin), (radius-height)*cos(tmin)-delta_y, 0,
      (radius-height)*sin(tmax), (radius-height)*cos(tmax)-delta_y, 0);
    line(
      (radius-height)*sin(tmax), (radius-height)*cos(tmax)-delta_y, 0,
      radius*sin(tmax),          radius*cos(tmax)-delta_y,          0);
  }
}
#line 85568 "./SNS_BASIS.c"
}   /* End of Chopper2=DiskChopper() SETTING parameter declarations. */
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Chopper2_ToF'. */
  SIG_MESSAGE("Chopper2_ToF (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Chopper2_ToF");
#define mccompcurname  Chopper2_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 65
#define nt mccChopper2_ToF_nt
#define TOF_N mccChopper2_ToF_TOF_N
#define TOF_p mccChopper2_ToF_TOF_p
#define TOF_p2 mccChopper2_ToF_TOF_p2
#define t_min mccChopper2_ToF_t_min
#define t_max mccChopper2_ToF_t_max
#define delta_t mccChopper2_ToF_delta_t
{   /* Declarations of Chopper2_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccChopper2_ToF_filename;
MCNUM xmin = mccChopper2_ToF_xmin;
MCNUM xmax = mccChopper2_ToF_xmax;
MCNUM ymin = mccChopper2_ToF_ymin;
MCNUM ymax = mccChopper2_ToF_ymax;
MCNUM xwidth = mccChopper2_ToF_xwidth;
MCNUM yheight = mccChopper2_ToF_yheight;
MCNUM tmin = mccChopper2_ToF_tmin;
MCNUM tmax = mccChopper2_ToF_tmax;
MCNUM dt = mccChopper2_ToF_dt;
MCNUM restore_neutron = mccChopper2_ToF_restore_neutron;
int nowritefile = mccChopper2_ToF_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 85614 "./SNS_BASIS.c"
}   /* End of Chopper2_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Chopper2_ToF_Z'. */
  SIG_MESSAGE("Chopper2_ToF_Z (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Chopper2_ToF_Z");
#define mccompcurname  Chopper2_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 66
#define nt mccChopper2_ToF_Z_nt
#define TOF_N mccChopper2_ToF_Z_TOF_N
#define TOF_p mccChopper2_ToF_Z_TOF_p
#define TOF_p2 mccChopper2_ToF_Z_TOF_p2
#define t_min mccChopper2_ToF_Z_t_min
#define t_max mccChopper2_ToF_Z_t_max
#define delta_t mccChopper2_ToF_Z_delta_t
{   /* Declarations of Chopper2_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccChopper2_ToF_Z_filename;
MCNUM xmin = mccChopper2_ToF_Z_xmin;
MCNUM xmax = mccChopper2_ToF_Z_xmax;
MCNUM ymin = mccChopper2_ToF_Z_ymin;
MCNUM ymax = mccChopper2_ToF_Z_ymax;
MCNUM xwidth = mccChopper2_ToF_Z_xwidth;
MCNUM yheight = mccChopper2_ToF_Z_yheight;
MCNUM tmin = mccChopper2_ToF_Z_tmin;
MCNUM tmax = mccChopper2_ToF_Z_tmax;
MCNUM dt = mccChopper2_ToF_Z_dt;
MCNUM restore_neutron = mccChopper2_ToF_Z_restore_neutron;
int nowritefile = mccChopper2_ToF_Z_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 85662 "./SNS_BASIS.c"
}   /* End of Chopper2_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap4_end_Lam'. */
  SIG_MESSAGE("Gap4_end_Lam (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap4_end_Lam");
#define mccompcurname  Gap4_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 67
#define nL mccGap4_end_Lam_nL
#define L_N mccGap4_end_Lam_L_N
#define L_p mccGap4_end_Lam_L_p
#define L_p2 mccGap4_end_Lam_L_p2
{   /* Declarations of Gap4_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap4_end_Lam_filename;
MCNUM xmin = mccGap4_end_Lam_xmin;
MCNUM xmax = mccGap4_end_Lam_xmax;
MCNUM ymin = mccGap4_end_Lam_ymin;
MCNUM ymax = mccGap4_end_Lam_ymax;
MCNUM xwidth = mccGap4_end_Lam_xwidth;
MCNUM yheight = mccGap4_end_Lam_yheight;
MCNUM Lmin = mccGap4_end_Lam_Lmin;
MCNUM Lmax = mccGap4_end_Lam_Lmax;
MCNUM restore_neutron = mccGap4_end_Lam_restore_neutron;
int nowritefile = mccGap4_end_Lam_nowritefile;
#line 120 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 85706 "./SNS_BASIS.c"
}   /* End of Gap4_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap4_end_PSD'. */
  SIG_MESSAGE("Gap4_end_PSD (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap4_end_PSD");
#define mccompcurname  Gap4_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 68
#define PSD_N mccGap4_end_PSD_PSD_N
#define PSD_p mccGap4_end_PSD_PSD_p
#define PSD_p2 mccGap4_end_PSD_PSD_p2
{   /* Declarations of Gap4_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap4_end_PSD_nx;
int ny = mccGap4_end_PSD_ny;
char* filename = mccGap4_end_PSD_filename;
MCNUM xmin = mccGap4_end_PSD_xmin;
MCNUM xmax = mccGap4_end_PSD_xmax;
MCNUM ymin = mccGap4_end_PSD_ymin;
MCNUM ymax = mccGap4_end_PSD_ymax;
MCNUM xwidth = mccGap4_end_PSD_xwidth;
MCNUM yheight = mccGap4_end_PSD_yheight;
MCNUM restore_neutron = mccGap4_end_PSD_restore_neutron;
#line 129 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  multiline(5,
    (double)xmin, (double)ymin, 0.0,
    (double)xmax, (double)ymin, 0.0,
    (double)xmax, (double)ymax, 0.0,
    (double)xmin, (double)ymax, 0.0,
    (double)xmin, (double)ymin, 0.0);
}
#line 85745 "./SNS_BASIS.c"
}   /* End of Gap4_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap4_end'. */
  SIG_MESSAGE("Gap4_end (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap4_end");
#define mccompcurname  Gap4_end
#define mccompcurtype  Arm
#define mccompcurindex 69
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 85768 "./SNS_BASIS.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_III'. */
  SIG_MESSAGE("Curved_Guide_Section_III (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_III");
#define mccompcurname  Curved_Guide_Section_III
#define mccompcurtype  Guide_gravity
#define mccompcurindex 70
#define GVars mccCurved_Guide_Section_III_GVars
#define pTable mccCurved_Guide_Section_III_pTable
{   /* Declarations of Curved_Guide_Section_III=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_w1;
MCNUM h1 = mccCurved_Guide_Section_III_h1;
MCNUM w2 = mccCurved_Guide_Section_III_w2;
MCNUM h2 = mccCurved_Guide_Section_III_h2;
MCNUM l = mccCurved_Guide_Section_III_l;
MCNUM R0 = mccCurved_Guide_Section_III_R0;
MCNUM Qc = mccCurved_Guide_Section_III_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_alpha;
MCNUM m = mccCurved_Guide_Section_III_m;
MCNUM W = mccCurved_Guide_Section_III_W;
MCNUM nslit = mccCurved_Guide_Section_III_nslit;
MCNUM d = mccCurved_Guide_Section_III_d;
MCNUM mleft = mccCurved_Guide_Section_III_mleft;
MCNUM mright = mccCurved_Guide_Section_III_mright;
MCNUM mtop = mccCurved_Guide_Section_III_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_nhslit;
MCNUM G = mccCurved_Guide_Section_III_G;
MCNUM aleft = mccCurved_Guide_Section_III_aleft;
MCNUM aright = mccCurved_Guide_Section_III_aright;
MCNUM atop = mccCurved_Guide_Section_III_atop;
MCNUM abottom = mccCurved_Guide_Section_III_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_nelements;
MCNUM nu = mccCurved_Guide_Section_III_nu;
MCNUM phase = mccCurved_Guide_Section_III_phase;
char* reflect = mccCurved_Guide_Section_III_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 85879 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_III_71'. */
  SIG_MESSAGE("Curved_Guide_Section_III_71 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_III_71");
#define mccompcurname  Curved_Guide_Section_III_71
#define mccompcurtype  Guide_gravity
#define mccompcurindex 71
#define GVars mccCurved_Guide_Section_III_71_GVars
#define pTable mccCurved_Guide_Section_III_71_pTable
{   /* Declarations of Curved_Guide_Section_III_71=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_71_w1;
MCNUM h1 = mccCurved_Guide_Section_III_71_h1;
MCNUM w2 = mccCurved_Guide_Section_III_71_w2;
MCNUM h2 = mccCurved_Guide_Section_III_71_h2;
MCNUM l = mccCurved_Guide_Section_III_71_l;
MCNUM R0 = mccCurved_Guide_Section_III_71_R0;
MCNUM Qc = mccCurved_Guide_Section_III_71_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_71_alpha;
MCNUM m = mccCurved_Guide_Section_III_71_m;
MCNUM W = mccCurved_Guide_Section_III_71_W;
MCNUM nslit = mccCurved_Guide_Section_III_71_nslit;
MCNUM d = mccCurved_Guide_Section_III_71_d;
MCNUM mleft = mccCurved_Guide_Section_III_71_mleft;
MCNUM mright = mccCurved_Guide_Section_III_71_mright;
MCNUM mtop = mccCurved_Guide_Section_III_71_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_71_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_71_nhslit;
MCNUM G = mccCurved_Guide_Section_III_71_G;
MCNUM aleft = mccCurved_Guide_Section_III_71_aleft;
MCNUM aright = mccCurved_Guide_Section_III_71_aright;
MCNUM atop = mccCurved_Guide_Section_III_71_atop;
MCNUM abottom = mccCurved_Guide_Section_III_71_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_71_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_71_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_71_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_71_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_71_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_71_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_71_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_71_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_71_nelements;
MCNUM nu = mccCurved_Guide_Section_III_71_nu;
MCNUM phase = mccCurved_Guide_Section_III_71_phase;
char* reflect = mccCurved_Guide_Section_III_71_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 85993 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_71=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_III_72'. */
  SIG_MESSAGE("Curved_Guide_Section_III_72 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_III_72");
#define mccompcurname  Curved_Guide_Section_III_72
#define mccompcurtype  Guide_gravity
#define mccompcurindex 72
#define GVars mccCurved_Guide_Section_III_72_GVars
#define pTable mccCurved_Guide_Section_III_72_pTable
{   /* Declarations of Curved_Guide_Section_III_72=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_72_w1;
MCNUM h1 = mccCurved_Guide_Section_III_72_h1;
MCNUM w2 = mccCurved_Guide_Section_III_72_w2;
MCNUM h2 = mccCurved_Guide_Section_III_72_h2;
MCNUM l = mccCurved_Guide_Section_III_72_l;
MCNUM R0 = mccCurved_Guide_Section_III_72_R0;
MCNUM Qc = mccCurved_Guide_Section_III_72_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_72_alpha;
MCNUM m = mccCurved_Guide_Section_III_72_m;
MCNUM W = mccCurved_Guide_Section_III_72_W;
MCNUM nslit = mccCurved_Guide_Section_III_72_nslit;
MCNUM d = mccCurved_Guide_Section_III_72_d;
MCNUM mleft = mccCurved_Guide_Section_III_72_mleft;
MCNUM mright = mccCurved_Guide_Section_III_72_mright;
MCNUM mtop = mccCurved_Guide_Section_III_72_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_72_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_72_nhslit;
MCNUM G = mccCurved_Guide_Section_III_72_G;
MCNUM aleft = mccCurved_Guide_Section_III_72_aleft;
MCNUM aright = mccCurved_Guide_Section_III_72_aright;
MCNUM atop = mccCurved_Guide_Section_III_72_atop;
MCNUM abottom = mccCurved_Guide_Section_III_72_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_72_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_72_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_72_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_72_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_72_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_72_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_72_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_72_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_72_nelements;
MCNUM nu = mccCurved_Guide_Section_III_72_nu;
MCNUM phase = mccCurved_Guide_Section_III_72_phase;
char* reflect = mccCurved_Guide_Section_III_72_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 86107 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_72=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_III_73'. */
  SIG_MESSAGE("Curved_Guide_Section_III_73 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_III_73");
#define mccompcurname  Curved_Guide_Section_III_73
#define mccompcurtype  Guide_gravity
#define mccompcurindex 73
#define GVars mccCurved_Guide_Section_III_73_GVars
#define pTable mccCurved_Guide_Section_III_73_pTable
{   /* Declarations of Curved_Guide_Section_III_73=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_73_w1;
MCNUM h1 = mccCurved_Guide_Section_III_73_h1;
MCNUM w2 = mccCurved_Guide_Section_III_73_w2;
MCNUM h2 = mccCurved_Guide_Section_III_73_h2;
MCNUM l = mccCurved_Guide_Section_III_73_l;
MCNUM R0 = mccCurved_Guide_Section_III_73_R0;
MCNUM Qc = mccCurved_Guide_Section_III_73_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_73_alpha;
MCNUM m = mccCurved_Guide_Section_III_73_m;
MCNUM W = mccCurved_Guide_Section_III_73_W;
MCNUM nslit = mccCurved_Guide_Section_III_73_nslit;
MCNUM d = mccCurved_Guide_Section_III_73_d;
MCNUM mleft = mccCurved_Guide_Section_III_73_mleft;
MCNUM mright = mccCurved_Guide_Section_III_73_mright;
MCNUM mtop = mccCurved_Guide_Section_III_73_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_73_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_73_nhslit;
MCNUM G = mccCurved_Guide_Section_III_73_G;
MCNUM aleft = mccCurved_Guide_Section_III_73_aleft;
MCNUM aright = mccCurved_Guide_Section_III_73_aright;
MCNUM atop = mccCurved_Guide_Section_III_73_atop;
MCNUM abottom = mccCurved_Guide_Section_III_73_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_73_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_73_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_73_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_73_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_73_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_73_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_73_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_73_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_73_nelements;
MCNUM nu = mccCurved_Guide_Section_III_73_nu;
MCNUM phase = mccCurved_Guide_Section_III_73_phase;
char* reflect = mccCurved_Guide_Section_III_73_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 86221 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_73=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_III_74'. */
  SIG_MESSAGE("Curved_Guide_Section_III_74 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_III_74");
#define mccompcurname  Curved_Guide_Section_III_74
#define mccompcurtype  Guide_gravity
#define mccompcurindex 74
#define GVars mccCurved_Guide_Section_III_74_GVars
#define pTable mccCurved_Guide_Section_III_74_pTable
{   /* Declarations of Curved_Guide_Section_III_74=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_74_w1;
MCNUM h1 = mccCurved_Guide_Section_III_74_h1;
MCNUM w2 = mccCurved_Guide_Section_III_74_w2;
MCNUM h2 = mccCurved_Guide_Section_III_74_h2;
MCNUM l = mccCurved_Guide_Section_III_74_l;
MCNUM R0 = mccCurved_Guide_Section_III_74_R0;
MCNUM Qc = mccCurved_Guide_Section_III_74_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_74_alpha;
MCNUM m = mccCurved_Guide_Section_III_74_m;
MCNUM W = mccCurved_Guide_Section_III_74_W;
MCNUM nslit = mccCurved_Guide_Section_III_74_nslit;
MCNUM d = mccCurved_Guide_Section_III_74_d;
MCNUM mleft = mccCurved_Guide_Section_III_74_mleft;
MCNUM mright = mccCurved_Guide_Section_III_74_mright;
MCNUM mtop = mccCurved_Guide_Section_III_74_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_74_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_74_nhslit;
MCNUM G = mccCurved_Guide_Section_III_74_G;
MCNUM aleft = mccCurved_Guide_Section_III_74_aleft;
MCNUM aright = mccCurved_Guide_Section_III_74_aright;
MCNUM atop = mccCurved_Guide_Section_III_74_atop;
MCNUM abottom = mccCurved_Guide_Section_III_74_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_74_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_74_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_74_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_74_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_74_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_74_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_74_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_74_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_74_nelements;
MCNUM nu = mccCurved_Guide_Section_III_74_nu;
MCNUM phase = mccCurved_Guide_Section_III_74_phase;
char* reflect = mccCurved_Guide_Section_III_74_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 86335 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_74=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_III_75'. */
  SIG_MESSAGE("Curved_Guide_Section_III_75 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_III_75");
#define mccompcurname  Curved_Guide_Section_III_75
#define mccompcurtype  Guide_gravity
#define mccompcurindex 75
#define GVars mccCurved_Guide_Section_III_75_GVars
#define pTable mccCurved_Guide_Section_III_75_pTable
{   /* Declarations of Curved_Guide_Section_III_75=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_75_w1;
MCNUM h1 = mccCurved_Guide_Section_III_75_h1;
MCNUM w2 = mccCurved_Guide_Section_III_75_w2;
MCNUM h2 = mccCurved_Guide_Section_III_75_h2;
MCNUM l = mccCurved_Guide_Section_III_75_l;
MCNUM R0 = mccCurved_Guide_Section_III_75_R0;
MCNUM Qc = mccCurved_Guide_Section_III_75_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_75_alpha;
MCNUM m = mccCurved_Guide_Section_III_75_m;
MCNUM W = mccCurved_Guide_Section_III_75_W;
MCNUM nslit = mccCurved_Guide_Section_III_75_nslit;
MCNUM d = mccCurved_Guide_Section_III_75_d;
MCNUM mleft = mccCurved_Guide_Section_III_75_mleft;
MCNUM mright = mccCurved_Guide_Section_III_75_mright;
MCNUM mtop = mccCurved_Guide_Section_III_75_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_75_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_75_nhslit;
MCNUM G = mccCurved_Guide_Section_III_75_G;
MCNUM aleft = mccCurved_Guide_Section_III_75_aleft;
MCNUM aright = mccCurved_Guide_Section_III_75_aright;
MCNUM atop = mccCurved_Guide_Section_III_75_atop;
MCNUM abottom = mccCurved_Guide_Section_III_75_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_75_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_75_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_75_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_75_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_75_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_75_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_75_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_75_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_75_nelements;
MCNUM nu = mccCurved_Guide_Section_III_75_nu;
MCNUM phase = mccCurved_Guide_Section_III_75_phase;
char* reflect = mccCurved_Guide_Section_III_75_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 86449 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_75=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_III_76'. */
  SIG_MESSAGE("Curved_Guide_Section_III_76 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_III_76");
#define mccompcurname  Curved_Guide_Section_III_76
#define mccompcurtype  Guide_gravity
#define mccompcurindex 76
#define GVars mccCurved_Guide_Section_III_76_GVars
#define pTable mccCurved_Guide_Section_III_76_pTable
{   /* Declarations of Curved_Guide_Section_III_76=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_76_w1;
MCNUM h1 = mccCurved_Guide_Section_III_76_h1;
MCNUM w2 = mccCurved_Guide_Section_III_76_w2;
MCNUM h2 = mccCurved_Guide_Section_III_76_h2;
MCNUM l = mccCurved_Guide_Section_III_76_l;
MCNUM R0 = mccCurved_Guide_Section_III_76_R0;
MCNUM Qc = mccCurved_Guide_Section_III_76_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_76_alpha;
MCNUM m = mccCurved_Guide_Section_III_76_m;
MCNUM W = mccCurved_Guide_Section_III_76_W;
MCNUM nslit = mccCurved_Guide_Section_III_76_nslit;
MCNUM d = mccCurved_Guide_Section_III_76_d;
MCNUM mleft = mccCurved_Guide_Section_III_76_mleft;
MCNUM mright = mccCurved_Guide_Section_III_76_mright;
MCNUM mtop = mccCurved_Guide_Section_III_76_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_76_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_76_nhslit;
MCNUM G = mccCurved_Guide_Section_III_76_G;
MCNUM aleft = mccCurved_Guide_Section_III_76_aleft;
MCNUM aright = mccCurved_Guide_Section_III_76_aright;
MCNUM atop = mccCurved_Guide_Section_III_76_atop;
MCNUM abottom = mccCurved_Guide_Section_III_76_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_76_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_76_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_76_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_76_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_76_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_76_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_76_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_76_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_76_nelements;
MCNUM nu = mccCurved_Guide_Section_III_76_nu;
MCNUM phase = mccCurved_Guide_Section_III_76_phase;
char* reflect = mccCurved_Guide_Section_III_76_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 86563 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_76=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_III_77'. */
  SIG_MESSAGE("Curved_Guide_Section_III_77 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_III_77");
#define mccompcurname  Curved_Guide_Section_III_77
#define mccompcurtype  Guide_gravity
#define mccompcurindex 77
#define GVars mccCurved_Guide_Section_III_77_GVars
#define pTable mccCurved_Guide_Section_III_77_pTable
{   /* Declarations of Curved_Guide_Section_III_77=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_77_w1;
MCNUM h1 = mccCurved_Guide_Section_III_77_h1;
MCNUM w2 = mccCurved_Guide_Section_III_77_w2;
MCNUM h2 = mccCurved_Guide_Section_III_77_h2;
MCNUM l = mccCurved_Guide_Section_III_77_l;
MCNUM R0 = mccCurved_Guide_Section_III_77_R0;
MCNUM Qc = mccCurved_Guide_Section_III_77_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_77_alpha;
MCNUM m = mccCurved_Guide_Section_III_77_m;
MCNUM W = mccCurved_Guide_Section_III_77_W;
MCNUM nslit = mccCurved_Guide_Section_III_77_nslit;
MCNUM d = mccCurved_Guide_Section_III_77_d;
MCNUM mleft = mccCurved_Guide_Section_III_77_mleft;
MCNUM mright = mccCurved_Guide_Section_III_77_mright;
MCNUM mtop = mccCurved_Guide_Section_III_77_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_77_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_77_nhslit;
MCNUM G = mccCurved_Guide_Section_III_77_G;
MCNUM aleft = mccCurved_Guide_Section_III_77_aleft;
MCNUM aright = mccCurved_Guide_Section_III_77_aright;
MCNUM atop = mccCurved_Guide_Section_III_77_atop;
MCNUM abottom = mccCurved_Guide_Section_III_77_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_77_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_77_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_77_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_77_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_77_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_77_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_77_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_77_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_77_nelements;
MCNUM nu = mccCurved_Guide_Section_III_77_nu;
MCNUM phase = mccCurved_Guide_Section_III_77_phase;
char* reflect = mccCurved_Guide_Section_III_77_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 86677 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_77=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_III_78'. */
  SIG_MESSAGE("Curved_Guide_Section_III_78 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_III_78");
#define mccompcurname  Curved_Guide_Section_III_78
#define mccompcurtype  Guide_gravity
#define mccompcurindex 78
#define GVars mccCurved_Guide_Section_III_78_GVars
#define pTable mccCurved_Guide_Section_III_78_pTable
{   /* Declarations of Curved_Guide_Section_III_78=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_78_w1;
MCNUM h1 = mccCurved_Guide_Section_III_78_h1;
MCNUM w2 = mccCurved_Guide_Section_III_78_w2;
MCNUM h2 = mccCurved_Guide_Section_III_78_h2;
MCNUM l = mccCurved_Guide_Section_III_78_l;
MCNUM R0 = mccCurved_Guide_Section_III_78_R0;
MCNUM Qc = mccCurved_Guide_Section_III_78_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_78_alpha;
MCNUM m = mccCurved_Guide_Section_III_78_m;
MCNUM W = mccCurved_Guide_Section_III_78_W;
MCNUM nslit = mccCurved_Guide_Section_III_78_nslit;
MCNUM d = mccCurved_Guide_Section_III_78_d;
MCNUM mleft = mccCurved_Guide_Section_III_78_mleft;
MCNUM mright = mccCurved_Guide_Section_III_78_mright;
MCNUM mtop = mccCurved_Guide_Section_III_78_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_78_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_78_nhslit;
MCNUM G = mccCurved_Guide_Section_III_78_G;
MCNUM aleft = mccCurved_Guide_Section_III_78_aleft;
MCNUM aright = mccCurved_Guide_Section_III_78_aright;
MCNUM atop = mccCurved_Guide_Section_III_78_atop;
MCNUM abottom = mccCurved_Guide_Section_III_78_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_78_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_78_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_78_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_78_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_78_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_78_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_78_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_78_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_78_nelements;
MCNUM nu = mccCurved_Guide_Section_III_78_nu;
MCNUM phase = mccCurved_Guide_Section_III_78_phase;
char* reflect = mccCurved_Guide_Section_III_78_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 86791 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_78=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_III_79'. */
  SIG_MESSAGE("Curved_Guide_Section_III_79 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_III_79");
#define mccompcurname  Curved_Guide_Section_III_79
#define mccompcurtype  Guide_gravity
#define mccompcurindex 79
#define GVars mccCurved_Guide_Section_III_79_GVars
#define pTable mccCurved_Guide_Section_III_79_pTable
{   /* Declarations of Curved_Guide_Section_III_79=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_79_w1;
MCNUM h1 = mccCurved_Guide_Section_III_79_h1;
MCNUM w2 = mccCurved_Guide_Section_III_79_w2;
MCNUM h2 = mccCurved_Guide_Section_III_79_h2;
MCNUM l = mccCurved_Guide_Section_III_79_l;
MCNUM R0 = mccCurved_Guide_Section_III_79_R0;
MCNUM Qc = mccCurved_Guide_Section_III_79_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_79_alpha;
MCNUM m = mccCurved_Guide_Section_III_79_m;
MCNUM W = mccCurved_Guide_Section_III_79_W;
MCNUM nslit = mccCurved_Guide_Section_III_79_nslit;
MCNUM d = mccCurved_Guide_Section_III_79_d;
MCNUM mleft = mccCurved_Guide_Section_III_79_mleft;
MCNUM mright = mccCurved_Guide_Section_III_79_mright;
MCNUM mtop = mccCurved_Guide_Section_III_79_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_79_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_79_nhslit;
MCNUM G = mccCurved_Guide_Section_III_79_G;
MCNUM aleft = mccCurved_Guide_Section_III_79_aleft;
MCNUM aright = mccCurved_Guide_Section_III_79_aright;
MCNUM atop = mccCurved_Guide_Section_III_79_atop;
MCNUM abottom = mccCurved_Guide_Section_III_79_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_79_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_79_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_79_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_79_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_79_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_79_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_79_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_79_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_79_nelements;
MCNUM nu = mccCurved_Guide_Section_III_79_nu;
MCNUM phase = mccCurved_Guide_Section_III_79_phase;
char* reflect = mccCurved_Guide_Section_III_79_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 86905 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_79=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Curved_Guide_Section_III_short'. */
  SIG_MESSAGE("Curved_Guide_Section_III_short (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Curved_Guide_Section_III_short");
#define mccompcurname  Curved_Guide_Section_III_short
#define mccompcurtype  Guide_gravity
#define mccompcurindex 80
#define GVars mccCurved_Guide_Section_III_short_GVars
#define pTable mccCurved_Guide_Section_III_short_pTable
{   /* Declarations of Curved_Guide_Section_III_short=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccCurved_Guide_Section_III_short_w1;
MCNUM h1 = mccCurved_Guide_Section_III_short_h1;
MCNUM w2 = mccCurved_Guide_Section_III_short_w2;
MCNUM h2 = mccCurved_Guide_Section_III_short_h2;
MCNUM l = mccCurved_Guide_Section_III_short_l;
MCNUM R0 = mccCurved_Guide_Section_III_short_R0;
MCNUM Qc = mccCurved_Guide_Section_III_short_Qc;
MCNUM alpha = mccCurved_Guide_Section_III_short_alpha;
MCNUM m = mccCurved_Guide_Section_III_short_m;
MCNUM W = mccCurved_Guide_Section_III_short_W;
MCNUM nslit = mccCurved_Guide_Section_III_short_nslit;
MCNUM d = mccCurved_Guide_Section_III_short_d;
MCNUM mleft = mccCurved_Guide_Section_III_short_mleft;
MCNUM mright = mccCurved_Guide_Section_III_short_mright;
MCNUM mtop = mccCurved_Guide_Section_III_short_mtop;
MCNUM mbottom = mccCurved_Guide_Section_III_short_mbottom;
MCNUM nhslit = mccCurved_Guide_Section_III_short_nhslit;
MCNUM G = mccCurved_Guide_Section_III_short_G;
MCNUM aleft = mccCurved_Guide_Section_III_short_aleft;
MCNUM aright = mccCurved_Guide_Section_III_short_aright;
MCNUM atop = mccCurved_Guide_Section_III_short_atop;
MCNUM abottom = mccCurved_Guide_Section_III_short_abottom;
MCNUM wavy = mccCurved_Guide_Section_III_short_wavy;
MCNUM wavy_z = mccCurved_Guide_Section_III_short_wavy_z;
MCNUM wavy_tb = mccCurved_Guide_Section_III_short_wavy_tb;
MCNUM wavy_lr = mccCurved_Guide_Section_III_short_wavy_lr;
MCNUM chamfers = mccCurved_Guide_Section_III_short_chamfers;
MCNUM chamfers_z = mccCurved_Guide_Section_III_short_chamfers_z;
MCNUM chamfers_lr = mccCurved_Guide_Section_III_short_chamfers_lr;
MCNUM chamfers_tb = mccCurved_Guide_Section_III_short_chamfers_tb;
MCNUM nelements = mccCurved_Guide_Section_III_short_nelements;
MCNUM nu = mccCurved_Guide_Section_III_short_nu;
MCNUM phase = mccCurved_Guide_Section_III_short_phase;
char* reflect = mccCurved_Guide_Section_III_short_reflect;
#line 572 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 87019 "./SNS_BASIS.c"
}   /* End of Curved_Guide_Section_III_short=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'CGS3_end_ToF'. */
  SIG_MESSAGE("CGS3_end_ToF (McDisplay)");
  printf("MCDISPLAY: component %s\n", "CGS3_end_ToF");
#define mccompcurname  CGS3_end_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 81
#define nt mccCGS3_end_ToF_nt
#define TOF_N mccCGS3_end_ToF_TOF_N
#define TOF_p mccCGS3_end_ToF_TOF_p
#define TOF_p2 mccCGS3_end_ToF_TOF_p2
#define t_min mccCGS3_end_ToF_t_min
#define t_max mccCGS3_end_ToF_t_max
#define delta_t mccCGS3_end_ToF_delta_t
{   /* Declarations of CGS3_end_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccCGS3_end_ToF_filename;
MCNUM xmin = mccCGS3_end_ToF_xmin;
MCNUM xmax = mccCGS3_end_ToF_xmax;
MCNUM ymin = mccCGS3_end_ToF_ymin;
MCNUM ymax = mccCGS3_end_ToF_ymax;
MCNUM xwidth = mccCGS3_end_ToF_xwidth;
MCNUM yheight = mccCGS3_end_ToF_yheight;
MCNUM tmin = mccCGS3_end_ToF_tmin;
MCNUM tmax = mccCGS3_end_ToF_tmax;
MCNUM dt = mccCGS3_end_ToF_dt;
MCNUM restore_neutron = mccCGS3_end_ToF_restore_neutron;
int nowritefile = mccCGS3_end_ToF_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 87062 "./SNS_BASIS.c"
}   /* End of CGS3_end_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'CGS3_end_ToF_Z'. */
  SIG_MESSAGE("CGS3_end_ToF_Z (McDisplay)");
  printf("MCDISPLAY: component %s\n", "CGS3_end_ToF_Z");
#define mccompcurname  CGS3_end_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 82
#define nt mccCGS3_end_ToF_Z_nt
#define TOF_N mccCGS3_end_ToF_Z_TOF_N
#define TOF_p mccCGS3_end_ToF_Z_TOF_p
#define TOF_p2 mccCGS3_end_ToF_Z_TOF_p2
#define t_min mccCGS3_end_ToF_Z_t_min
#define t_max mccCGS3_end_ToF_Z_t_max
#define delta_t mccCGS3_end_ToF_Z_delta_t
{   /* Declarations of CGS3_end_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccCGS3_end_ToF_Z_filename;
MCNUM xmin = mccCGS3_end_ToF_Z_xmin;
MCNUM xmax = mccCGS3_end_ToF_Z_xmax;
MCNUM ymin = mccCGS3_end_ToF_Z_ymin;
MCNUM ymax = mccCGS3_end_ToF_Z_ymax;
MCNUM xwidth = mccCGS3_end_ToF_Z_xwidth;
MCNUM yheight = mccCGS3_end_ToF_Z_yheight;
MCNUM tmin = mccCGS3_end_ToF_Z_tmin;
MCNUM tmax = mccCGS3_end_ToF_Z_tmax;
MCNUM dt = mccCGS3_end_ToF_Z_dt;
MCNUM restore_neutron = mccCGS3_end_ToF_Z_restore_neutron;
int nowritefile = mccCGS3_end_ToF_Z_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 87110 "./SNS_BASIS.c"
}   /* End of CGS3_end_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'CGS3_end_Lam'. */
  SIG_MESSAGE("CGS3_end_Lam (McDisplay)");
  printf("MCDISPLAY: component %s\n", "CGS3_end_Lam");
#define mccompcurname  CGS3_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 83
#define nL mccCGS3_end_Lam_nL
#define L_N mccCGS3_end_Lam_L_N
#define L_p mccCGS3_end_Lam_L_p
#define L_p2 mccCGS3_end_Lam_L_p2
{   /* Declarations of CGS3_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccCGS3_end_Lam_filename;
MCNUM xmin = mccCGS3_end_Lam_xmin;
MCNUM xmax = mccCGS3_end_Lam_xmax;
MCNUM ymin = mccCGS3_end_Lam_ymin;
MCNUM ymax = mccCGS3_end_Lam_ymax;
MCNUM xwidth = mccCGS3_end_Lam_xwidth;
MCNUM yheight = mccCGS3_end_Lam_yheight;
MCNUM Lmin = mccCGS3_end_Lam_Lmin;
MCNUM Lmax = mccCGS3_end_Lam_Lmax;
MCNUM restore_neutron = mccCGS3_end_Lam_restore_neutron;
int nowritefile = mccCGS3_end_Lam_nowritefile;
#line 120 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 87154 "./SNS_BASIS.c"
}   /* End of CGS3_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Straight_Guide_Section_I'. */
  SIG_MESSAGE("Straight_Guide_Section_I (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Straight_Guide_Section_I");
#define mccompcurname  Straight_Guide_Section_I
#define mccompcurtype  Guide
#define mccompcurindex 84
#define pTable mccStraight_Guide_Section_I_pTable
{   /* Declarations of Straight_Guide_Section_I=Guide() SETTING parameters. */
char* reflect = mccStraight_Guide_Section_I_reflect;
MCNUM w1 = mccStraight_Guide_Section_I_w1;
MCNUM h1 = mccStraight_Guide_Section_I_h1;
MCNUM w2 = mccStraight_Guide_Section_I_w2;
MCNUM h2 = mccStraight_Guide_Section_I_h2;
MCNUM l = mccStraight_Guide_Section_I_l;
MCNUM R0 = mccStraight_Guide_Section_I_R0;
MCNUM Qc = mccStraight_Guide_Section_I_Qc;
MCNUM alpha = mccStraight_Guide_Section_I_alpha;
MCNUM m = mccStraight_Guide_Section_I_m;
MCNUM W = mccStraight_Guide_Section_I_W;
#line 202 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 87203 "./SNS_BASIS.c"
}   /* End of Straight_Guide_Section_I=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap5_start'. */
  SIG_MESSAGE("Gap5_start (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap5_start");
#define mccompcurname  Gap5_start
#define mccompcurtype  Arm
#define mccompcurindex 85
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 87224 "./SNS_BASIS.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap5_start_ToF'. */
  SIG_MESSAGE("Gap5_start_ToF (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap5_start_ToF");
#define mccompcurname  Gap5_start_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 86
#define nt mccGap5_start_ToF_nt
#define TOF_N mccGap5_start_ToF_TOF_N
#define TOF_p mccGap5_start_ToF_TOF_p
#define TOF_p2 mccGap5_start_ToF_TOF_p2
#define t_min mccGap5_start_ToF_t_min
#define t_max mccGap5_start_ToF_t_max
#define delta_t mccGap5_start_ToF_delta_t
{   /* Declarations of Gap5_start_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccGap5_start_ToF_filename;
MCNUM xmin = mccGap5_start_ToF_xmin;
MCNUM xmax = mccGap5_start_ToF_xmax;
MCNUM ymin = mccGap5_start_ToF_ymin;
MCNUM ymax = mccGap5_start_ToF_ymax;
MCNUM xwidth = mccGap5_start_ToF_xwidth;
MCNUM yheight = mccGap5_start_ToF_yheight;
MCNUM tmin = mccGap5_start_ToF_tmin;
MCNUM tmax = mccGap5_start_ToF_tmax;
MCNUM dt = mccGap5_start_ToF_dt;
MCNUM restore_neutron = mccGap5_start_ToF_restore_neutron;
int nowritefile = mccGap5_start_ToF_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 87264 "./SNS_BASIS.c"
}   /* End of Gap5_start_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap5_start_ToF_Z'. */
  SIG_MESSAGE("Gap5_start_ToF_Z (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap5_start_ToF_Z");
#define mccompcurname  Gap5_start_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 87
#define nt mccGap5_start_ToF_Z_nt
#define TOF_N mccGap5_start_ToF_Z_TOF_N
#define TOF_p mccGap5_start_ToF_Z_TOF_p
#define TOF_p2 mccGap5_start_ToF_Z_TOF_p2
#define t_min mccGap5_start_ToF_Z_t_min
#define t_max mccGap5_start_ToF_Z_t_max
#define delta_t mccGap5_start_ToF_Z_delta_t
{   /* Declarations of Gap5_start_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccGap5_start_ToF_Z_filename;
MCNUM xmin = mccGap5_start_ToF_Z_xmin;
MCNUM xmax = mccGap5_start_ToF_Z_xmax;
MCNUM ymin = mccGap5_start_ToF_Z_ymin;
MCNUM ymax = mccGap5_start_ToF_Z_ymax;
MCNUM xwidth = mccGap5_start_ToF_Z_xwidth;
MCNUM yheight = mccGap5_start_ToF_Z_yheight;
MCNUM tmin = mccGap5_start_ToF_Z_tmin;
MCNUM tmax = mccGap5_start_ToF_Z_tmax;
MCNUM dt = mccGap5_start_ToF_Z_dt;
MCNUM restore_neutron = mccGap5_start_ToF_Z_restore_neutron;
int nowritefile = mccGap5_start_ToF_Z_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 87312 "./SNS_BASIS.c"
}   /* End of Gap5_start_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap5_start_Lam'. */
  SIG_MESSAGE("Gap5_start_Lam (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap5_start_Lam");
#define mccompcurname  Gap5_start_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 88
#define nL mccGap5_start_Lam_nL
#define L_N mccGap5_start_Lam_L_N
#define L_p mccGap5_start_Lam_L_p
#define L_p2 mccGap5_start_Lam_L_p2
{   /* Declarations of Gap5_start_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap5_start_Lam_filename;
MCNUM xmin = mccGap5_start_Lam_xmin;
MCNUM xmax = mccGap5_start_Lam_xmax;
MCNUM ymin = mccGap5_start_Lam_ymin;
MCNUM ymax = mccGap5_start_Lam_ymax;
MCNUM xwidth = mccGap5_start_Lam_xwidth;
MCNUM yheight = mccGap5_start_Lam_yheight;
MCNUM Lmin = mccGap5_start_Lam_Lmin;
MCNUM Lmax = mccGap5_start_Lam_Lmax;
MCNUM restore_neutron = mccGap5_start_Lam_restore_neutron;
int nowritefile = mccGap5_start_Lam_nowritefile;
#line 120 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 87356 "./SNS_BASIS.c"
}   /* End of Gap5_start_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap5_start_PSD'. */
  SIG_MESSAGE("Gap5_start_PSD (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap5_start_PSD");
#define mccompcurname  Gap5_start_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 89
#define PSD_N mccGap5_start_PSD_PSD_N
#define PSD_p mccGap5_start_PSD_PSD_p
#define PSD_p2 mccGap5_start_PSD_PSD_p2
{   /* Declarations of Gap5_start_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap5_start_PSD_nx;
int ny = mccGap5_start_PSD_ny;
char* filename = mccGap5_start_PSD_filename;
MCNUM xmin = mccGap5_start_PSD_xmin;
MCNUM xmax = mccGap5_start_PSD_xmax;
MCNUM ymin = mccGap5_start_PSD_ymin;
MCNUM ymax = mccGap5_start_PSD_ymax;
MCNUM xwidth = mccGap5_start_PSD_xwidth;
MCNUM yheight = mccGap5_start_PSD_yheight;
MCNUM restore_neutron = mccGap5_start_PSD_restore_neutron;
#line 129 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  multiline(5,
    (double)xmin, (double)ymin, 0.0,
    (double)xmax, (double)ymin, 0.0,
    (double)xmax, (double)ymax, 0.0,
    (double)xmin, (double)ymax, 0.0,
    (double)xmin, (double)ymin, 0.0);
}
#line 87395 "./SNS_BASIS.c"
}   /* End of Gap5_start_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Chopper3'. */
  SIG_MESSAGE("Chopper3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Chopper3");
#define mccompcurname  Chopper3
#define mccompcurtype  DiskChopper
#define mccompcurindex 90
#define Tg mccChopper3_Tg
#define To mccChopper3_To
#define delta_y mccChopper3_delta_y
#define height mccChopper3_height
#define omega mccChopper3_omega
{   /* Declarations of Chopper3=DiskChopper() SETTING parameters. */
MCNUM theta_0 = mccChopper3_theta_0;
MCNUM radius = mccChopper3_radius;
MCNUM yheight = mccChopper3_yheight;
MCNUM nu = mccChopper3_nu;
MCNUM nslit = mccChopper3_nslit;
MCNUM jitter = mccChopper3_jitter;
MCNUM delay = mccChopper3_delay;
MCNUM isfirst = mccChopper3_isfirst;
MCNUM n_pulse = mccChopper3_n_pulse;
MCNUM abs_out = mccChopper3_abs_out;
MCNUM phase = mccChopper3_phase;
MCNUM xwidth = mccChopper3_xwidth;
MCNUM verbose = mccChopper3_verbose;
#line 168 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/DiskChopper.comp"
{

  int j;
  /* Arrays for storing geometry of slit/beamstop */
  
  circle("xy", 0, -delta_y, 0, radius);

  /* Drawing the slit(s) */
  for (j=0; j<nslit; j++) {
    /* Angular start/end of slit */
    double tmin = j*(2.0*PI/nslit) - theta_0/2.0 + phase;
    double tmax = tmin+theta_0;
    /* Draw lines for each slit. */

    line(
      radius*sin(tmin),          radius*cos(tmin)-delta_y,          0,
      (radius-height)*sin(tmin), (radius-height)*cos(tmin)-delta_y, 0
      );
    line(
      (radius-height)*sin(tmin), (radius-height)*cos(tmin)-delta_y, 0,
      (radius-height)*sin(tmax), (radius-height)*cos(tmax)-delta_y, 0);
    line(
      (radius-height)*sin(tmax), (radius-height)*cos(tmax)-delta_y, 0,
      radius*sin(tmax),          radius*cos(tmax)-delta_y,          0);
  }
}
#line 87456 "./SNS_BASIS.c"
}   /* End of Chopper3=DiskChopper() SETTING parameter declarations. */
#undef omega
#undef height
#undef delta_y
#undef To
#undef Tg
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Chopper3_ToF'. */
  SIG_MESSAGE("Chopper3_ToF (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Chopper3_ToF");
#define mccompcurname  Chopper3_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 91
#define nt mccChopper3_ToF_nt
#define TOF_N mccChopper3_ToF_TOF_N
#define TOF_p mccChopper3_ToF_TOF_p
#define TOF_p2 mccChopper3_ToF_TOF_p2
#define t_min mccChopper3_ToF_t_min
#define t_max mccChopper3_ToF_t_max
#define delta_t mccChopper3_ToF_delta_t
{   /* Declarations of Chopper3_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccChopper3_ToF_filename;
MCNUM xmin = mccChopper3_ToF_xmin;
MCNUM xmax = mccChopper3_ToF_xmax;
MCNUM ymin = mccChopper3_ToF_ymin;
MCNUM ymax = mccChopper3_ToF_ymax;
MCNUM xwidth = mccChopper3_ToF_xwidth;
MCNUM yheight = mccChopper3_ToF_yheight;
MCNUM tmin = mccChopper3_ToF_tmin;
MCNUM tmax = mccChopper3_ToF_tmax;
MCNUM dt = mccChopper3_ToF_dt;
MCNUM restore_neutron = mccChopper3_ToF_restore_neutron;
int nowritefile = mccChopper3_ToF_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 87502 "./SNS_BASIS.c"
}   /* End of Chopper3_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Chopper3_ToF_Z'. */
  SIG_MESSAGE("Chopper3_ToF_Z (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Chopper3_ToF_Z");
#define mccompcurname  Chopper3_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 92
#define nt mccChopper3_ToF_Z_nt
#define TOF_N mccChopper3_ToF_Z_TOF_N
#define TOF_p mccChopper3_ToF_Z_TOF_p
#define TOF_p2 mccChopper3_ToF_Z_TOF_p2
#define t_min mccChopper3_ToF_Z_t_min
#define t_max mccChopper3_ToF_Z_t_max
#define delta_t mccChopper3_ToF_Z_delta_t
{   /* Declarations of Chopper3_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccChopper3_ToF_Z_filename;
MCNUM xmin = mccChopper3_ToF_Z_xmin;
MCNUM xmax = mccChopper3_ToF_Z_xmax;
MCNUM ymin = mccChopper3_ToF_Z_ymin;
MCNUM ymax = mccChopper3_ToF_Z_ymax;
MCNUM xwidth = mccChopper3_ToF_Z_xwidth;
MCNUM yheight = mccChopper3_ToF_Z_yheight;
MCNUM tmin = mccChopper3_ToF_Z_tmin;
MCNUM tmax = mccChopper3_ToF_Z_tmax;
MCNUM dt = mccChopper3_ToF_Z_dt;
MCNUM restore_neutron = mccChopper3_ToF_Z_restore_neutron;
int nowritefile = mccChopper3_ToF_Z_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 87550 "./SNS_BASIS.c"
}   /* End of Chopper3_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap5_end_Lam'. */
  SIG_MESSAGE("Gap5_end_Lam (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap5_end_Lam");
#define mccompcurname  Gap5_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 93
#define nL mccGap5_end_Lam_nL
#define L_N mccGap5_end_Lam_L_N
#define L_p mccGap5_end_Lam_L_p
#define L_p2 mccGap5_end_Lam_L_p2
{   /* Declarations of Gap5_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccGap5_end_Lam_filename;
MCNUM xmin = mccGap5_end_Lam_xmin;
MCNUM xmax = mccGap5_end_Lam_xmax;
MCNUM ymin = mccGap5_end_Lam_ymin;
MCNUM ymax = mccGap5_end_Lam_ymax;
MCNUM xwidth = mccGap5_end_Lam_xwidth;
MCNUM yheight = mccGap5_end_Lam_yheight;
MCNUM Lmin = mccGap5_end_Lam_Lmin;
MCNUM Lmax = mccGap5_end_Lam_Lmax;
MCNUM restore_neutron = mccGap5_end_Lam_restore_neutron;
int nowritefile = mccGap5_end_Lam_nowritefile;
#line 120 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 87594 "./SNS_BASIS.c"
}   /* End of Gap5_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap5_end_PSD'. */
  SIG_MESSAGE("Gap5_end_PSD (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap5_end_PSD");
#define mccompcurname  Gap5_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 94
#define PSD_N mccGap5_end_PSD_PSD_N
#define PSD_p mccGap5_end_PSD_PSD_p
#define PSD_p2 mccGap5_end_PSD_PSD_p2
{   /* Declarations of Gap5_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGap5_end_PSD_nx;
int ny = mccGap5_end_PSD_ny;
char* filename = mccGap5_end_PSD_filename;
MCNUM xmin = mccGap5_end_PSD_xmin;
MCNUM xmax = mccGap5_end_PSD_xmax;
MCNUM ymin = mccGap5_end_PSD_ymin;
MCNUM ymax = mccGap5_end_PSD_ymax;
MCNUM xwidth = mccGap5_end_PSD_xwidth;
MCNUM yheight = mccGap5_end_PSD_yheight;
MCNUM restore_neutron = mccGap5_end_PSD_restore_neutron;
#line 129 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  multiline(5,
    (double)xmin, (double)ymin, 0.0,
    (double)xmax, (double)ymin, 0.0,
    (double)xmax, (double)ymax, 0.0,
    (double)xmin, (double)ymax, 0.0,
    (double)xmin, (double)ymin, 0.0);
}
#line 87633 "./SNS_BASIS.c"
}   /* End of Gap5_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Gap5_end'. */
  SIG_MESSAGE("Gap5_end (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Gap5_end");
#define mccompcurname  Gap5_end
#define mccompcurtype  Arm
#define mccompcurindex 95
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 87656 "./SNS_BASIS.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Straight_Guide_Section_II'. */
  SIG_MESSAGE("Straight_Guide_Section_II (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Straight_Guide_Section_II");
#define mccompcurname  Straight_Guide_Section_II
#define mccompcurtype  Guide
#define mccompcurindex 96
#define pTable mccStraight_Guide_Section_II_pTable
{   /* Declarations of Straight_Guide_Section_II=Guide() SETTING parameters. */
char* reflect = mccStraight_Guide_Section_II_reflect;
MCNUM w1 = mccStraight_Guide_Section_II_w1;
MCNUM h1 = mccStraight_Guide_Section_II_h1;
MCNUM w2 = mccStraight_Guide_Section_II_w2;
MCNUM h2 = mccStraight_Guide_Section_II_h2;
MCNUM l = mccStraight_Guide_Section_II_l;
MCNUM R0 = mccStraight_Guide_Section_II_R0;
MCNUM Qc = mccStraight_Guide_Section_II_Qc;
MCNUM alpha = mccStraight_Guide_Section_II_alpha;
MCNUM m = mccStraight_Guide_Section_II_m;
MCNUM W = mccStraight_Guide_Section_II_W;
#line 202 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 87700 "./SNS_BASIS.c"
}   /* End of Straight_Guide_Section_II=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'SGS2_end_Lam'. */
  SIG_MESSAGE("SGS2_end_Lam (McDisplay)");
  printf("MCDISPLAY: component %s\n", "SGS2_end_Lam");
#define mccompcurname  SGS2_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 97
#define nL mccSGS2_end_Lam_nL
#define L_N mccSGS2_end_Lam_L_N
#define L_p mccSGS2_end_Lam_L_p
#define L_p2 mccSGS2_end_Lam_L_p2
{   /* Declarations of SGS2_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccSGS2_end_Lam_filename;
MCNUM xmin = mccSGS2_end_Lam_xmin;
MCNUM xmax = mccSGS2_end_Lam_xmax;
MCNUM ymin = mccSGS2_end_Lam_ymin;
MCNUM ymax = mccSGS2_end_Lam_ymax;
MCNUM xwidth = mccSGS2_end_Lam_xwidth;
MCNUM yheight = mccSGS2_end_Lam_yheight;
MCNUM Lmin = mccSGS2_end_Lam_Lmin;
MCNUM Lmax = mccSGS2_end_Lam_Lmax;
MCNUM restore_neutron = mccSGS2_end_Lam_restore_neutron;
int nowritefile = mccSGS2_end_Lam_nowritefile;
#line 120 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 87738 "./SNS_BASIS.c"
}   /* End of SGS2_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'SGS2_end_PSD'. */
  SIG_MESSAGE("SGS2_end_PSD (McDisplay)");
  printf("MCDISPLAY: component %s\n", "SGS2_end_PSD");
#define mccompcurname  SGS2_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 98
#define PSD_N mccSGS2_end_PSD_PSD_N
#define PSD_p mccSGS2_end_PSD_PSD_p
#define PSD_p2 mccSGS2_end_PSD_PSD_p2
{   /* Declarations of SGS2_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccSGS2_end_PSD_nx;
int ny = mccSGS2_end_PSD_ny;
char* filename = mccSGS2_end_PSD_filename;
MCNUM xmin = mccSGS2_end_PSD_xmin;
MCNUM xmax = mccSGS2_end_PSD_xmax;
MCNUM ymin = mccSGS2_end_PSD_ymin;
MCNUM ymax = mccSGS2_end_PSD_ymax;
MCNUM xwidth = mccSGS2_end_PSD_xwidth;
MCNUM yheight = mccSGS2_end_PSD_yheight;
MCNUM restore_neutron = mccSGS2_end_PSD_restore_neutron;
#line 129 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  multiline(5,
    (double)xmin, (double)ymin, 0.0,
    (double)xmax, (double)ymin, 0.0,
    (double)xmax, (double)ymax, 0.0,
    (double)xmin, (double)ymax, 0.0,
    (double)xmin, (double)ymin, 0.0);
}
#line 87777 "./SNS_BASIS.c"
}   /* End of SGS2_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Straight_Guide_Section_III'. */
  SIG_MESSAGE("Straight_Guide_Section_III (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Straight_Guide_Section_III");
#define mccompcurname  Straight_Guide_Section_III
#define mccompcurtype  Guide
#define mccompcurindex 99
#define pTable mccStraight_Guide_Section_III_pTable
{   /* Declarations of Straight_Guide_Section_III=Guide() SETTING parameters. */
char* reflect = mccStraight_Guide_Section_III_reflect;
MCNUM w1 = mccStraight_Guide_Section_III_w1;
MCNUM h1 = mccStraight_Guide_Section_III_h1;
MCNUM w2 = mccStraight_Guide_Section_III_w2;
MCNUM h2 = mccStraight_Guide_Section_III_h2;
MCNUM l = mccStraight_Guide_Section_III_l;
MCNUM R0 = mccStraight_Guide_Section_III_R0;
MCNUM Qc = mccStraight_Guide_Section_III_Qc;
MCNUM alpha = mccStraight_Guide_Section_III_alpha;
MCNUM m = mccStraight_Guide_Section_III_m;
MCNUM W = mccStraight_Guide_Section_III_W;
#line 202 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Guide.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 87825 "./SNS_BASIS.c"
}   /* End of Straight_Guide_Section_III=Guide() SETTING parameter declarations. */
#undef pTable
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'SG3_end_ToF'. */
  SIG_MESSAGE("SG3_end_ToF (McDisplay)");
  printf("MCDISPLAY: component %s\n", "SG3_end_ToF");
#define mccompcurname  SG3_end_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 100
#define nt mccSG3_end_ToF_nt
#define TOF_N mccSG3_end_ToF_TOF_N
#define TOF_p mccSG3_end_ToF_TOF_p
#define TOF_p2 mccSG3_end_ToF_TOF_p2
#define t_min mccSG3_end_ToF_t_min
#define t_max mccSG3_end_ToF_t_max
#define delta_t mccSG3_end_ToF_delta_t
{   /* Declarations of SG3_end_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccSG3_end_ToF_filename;
MCNUM xmin = mccSG3_end_ToF_xmin;
MCNUM xmax = mccSG3_end_ToF_xmax;
MCNUM ymin = mccSG3_end_ToF_ymin;
MCNUM ymax = mccSG3_end_ToF_ymax;
MCNUM xwidth = mccSG3_end_ToF_xwidth;
MCNUM yheight = mccSG3_end_ToF_yheight;
MCNUM tmin = mccSG3_end_ToF_tmin;
MCNUM tmax = mccSG3_end_ToF_tmax;
MCNUM dt = mccSG3_end_ToF_dt;
MCNUM restore_neutron = mccSG3_end_ToF_restore_neutron;
int nowritefile = mccSG3_end_ToF_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 87867 "./SNS_BASIS.c"
}   /* End of SG3_end_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'SG3_end_ToF_Z'. */
  SIG_MESSAGE("SG3_end_ToF_Z (McDisplay)");
  printf("MCDISPLAY: component %s\n", "SG3_end_ToF_Z");
#define mccompcurname  SG3_end_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 101
#define nt mccSG3_end_ToF_Z_nt
#define TOF_N mccSG3_end_ToF_Z_TOF_N
#define TOF_p mccSG3_end_ToF_Z_TOF_p
#define TOF_p2 mccSG3_end_ToF_Z_TOF_p2
#define t_min mccSG3_end_ToF_Z_t_min
#define t_max mccSG3_end_ToF_Z_t_max
#define delta_t mccSG3_end_ToF_Z_delta_t
{   /* Declarations of SG3_end_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccSG3_end_ToF_Z_filename;
MCNUM xmin = mccSG3_end_ToF_Z_xmin;
MCNUM xmax = mccSG3_end_ToF_Z_xmax;
MCNUM ymin = mccSG3_end_ToF_Z_ymin;
MCNUM ymax = mccSG3_end_ToF_Z_ymax;
MCNUM xwidth = mccSG3_end_ToF_Z_xwidth;
MCNUM yheight = mccSG3_end_ToF_Z_yheight;
MCNUM tmin = mccSG3_end_ToF_Z_tmin;
MCNUM tmax = mccSG3_end_ToF_Z_tmax;
MCNUM dt = mccSG3_end_ToF_Z_dt;
MCNUM restore_neutron = mccSG3_end_ToF_Z_restore_neutron;
int nowritefile = mccSG3_end_ToF_Z_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 87915 "./SNS_BASIS.c"
}   /* End of SG3_end_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'SG3_end_Lam'. */
  SIG_MESSAGE("SG3_end_Lam (McDisplay)");
  printf("MCDISPLAY: component %s\n", "SG3_end_Lam");
#define mccompcurname  SG3_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 102
#define nL mccSG3_end_Lam_nL
#define L_N mccSG3_end_Lam_L_N
#define L_p mccSG3_end_Lam_L_p
#define L_p2 mccSG3_end_Lam_L_p2
{   /* Declarations of SG3_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccSG3_end_Lam_filename;
MCNUM xmin = mccSG3_end_Lam_xmin;
MCNUM xmax = mccSG3_end_Lam_xmax;
MCNUM ymin = mccSG3_end_Lam_ymin;
MCNUM ymax = mccSG3_end_Lam_ymax;
MCNUM xwidth = mccSG3_end_Lam_xwidth;
MCNUM yheight = mccSG3_end_Lam_yheight;
MCNUM Lmin = mccSG3_end_Lam_Lmin;
MCNUM Lmax = mccSG3_end_Lam_Lmax;
MCNUM restore_neutron = mccSG3_end_Lam_restore_neutron;
int nowritefile = mccSG3_end_Lam_nowritefile;
#line 120 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 87959 "./SNS_BASIS.c"
}   /* End of SG3_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'SG3_end_PSD'. */
  SIG_MESSAGE("SG3_end_PSD (McDisplay)");
  printf("MCDISPLAY: component %s\n", "SG3_end_PSD");
#define mccompcurname  SG3_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 103
#define PSD_N mccSG3_end_PSD_PSD_N
#define PSD_p mccSG3_end_PSD_PSD_p
#define PSD_p2 mccSG3_end_PSD_PSD_p2
{   /* Declarations of SG3_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccSG3_end_PSD_nx;
int ny = mccSG3_end_PSD_ny;
char* filename = mccSG3_end_PSD_filename;
MCNUM xmin = mccSG3_end_PSD_xmin;
MCNUM xmax = mccSG3_end_PSD_xmax;
MCNUM ymin = mccSG3_end_PSD_ymin;
MCNUM ymax = mccSG3_end_PSD_ymax;
MCNUM xwidth = mccSG3_end_PSD_xwidth;
MCNUM yheight = mccSG3_end_PSD_yheight;
MCNUM restore_neutron = mccSG3_end_PSD_restore_neutron;
#line 129 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  multiline(5,
    (double)xmin, (double)ymin, 0.0,
    (double)xmax, (double)ymin, 0.0,
    (double)xmax, (double)ymax, 0.0,
    (double)xmin, (double)ymax, 0.0,
    (double)xmin, (double)ymin, 0.0);
}
#line 87998 "./SNS_BASIS.c"
}   /* End of SG3_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Funnel_1'. */
  SIG_MESSAGE("Funnel_1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Funnel_1");
#define mccompcurname  Funnel_1
#define mccompcurtype  Guide_m
#define mccompcurindex 104
#define reflect mccFunnel_1_reflect
#define pTable mccFunnel_1_pTable
#define m mccFunnel_1_m
#define alpha mccFunnel_1_alpha
#define Qc mccFunnel_1_Qc
#define R0 mccFunnel_1_R0
#define W mccFunnel_1_W
{   /* Declarations of Funnel_1=Guide_m() SETTING parameters. */
MCNUM w1 = mccFunnel_1_w1;
MCNUM h1 = mccFunnel_1_h1;
MCNUM w2 = mccFunnel_1_w2;
MCNUM h2 = mccFunnel_1_h2;
MCNUM l = mccFunnel_1_l;
MCNUM R0_left = mccFunnel_1_R0_left;
MCNUM R0_right = mccFunnel_1_R0_right;
MCNUM R0_top = mccFunnel_1_R0_top;
MCNUM R0_bottom = mccFunnel_1_R0_bottom;
MCNUM Qc_left = mccFunnel_1_Qc_left;
MCNUM Qc_right = mccFunnel_1_Qc_right;
MCNUM Qc_top = mccFunnel_1_Qc_top;
MCNUM Qc_bottom = mccFunnel_1_Qc_bottom;
MCNUM alpha_left = mccFunnel_1_alpha_left;
MCNUM alpha_right = mccFunnel_1_alpha_right;
MCNUM alpha_top = mccFunnel_1_alpha_top;
MCNUM alpha_bottom = mccFunnel_1_alpha_bottom;
MCNUM m_left = mccFunnel_1_m_left;
MCNUM m_right = mccFunnel_1_m_right;
MCNUM m_top = mccFunnel_1_m_top;
MCNUM m_bottom = mccFunnel_1_m_bottom;
MCNUM W_left = mccFunnel_1_W_left;
MCNUM W_right = mccFunnel_1_W_right;
MCNUM W_top = mccFunnel_1_W_top;
MCNUM W_bottom = mccFunnel_1_W_bottom;
#line 254 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_m.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 88066 "./SNS_BASIS.c"
}   /* End of Funnel_1=Guide_m() SETTING parameter declarations. */
#undef W
#undef R0
#undef Qc
#undef alpha
#undef m
#undef pTable
#undef reflect
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PSD_post_funnel1'. */
  SIG_MESSAGE("PSD_post_funnel1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PSD_post_funnel1");
#define mccompcurname  PSD_post_funnel1
#define mccompcurtype  PSD_monitor
#define mccompcurindex 105
#define PSD_N mccPSD_post_funnel1_PSD_N
#define PSD_p mccPSD_post_funnel1_PSD_p
#define PSD_p2 mccPSD_post_funnel1_PSD_p2
{   /* Declarations of PSD_post_funnel1=PSD_monitor() SETTING parameters. */
int nx = mccPSD_post_funnel1_nx;
int ny = mccPSD_post_funnel1_ny;
char* filename = mccPSD_post_funnel1_filename;
MCNUM xmin = mccPSD_post_funnel1_xmin;
MCNUM xmax = mccPSD_post_funnel1_xmax;
MCNUM ymin = mccPSD_post_funnel1_ymin;
MCNUM ymax = mccPSD_post_funnel1_ymax;
MCNUM xwidth = mccPSD_post_funnel1_xwidth;
MCNUM yheight = mccPSD_post_funnel1_yheight;
MCNUM restore_neutron = mccPSD_post_funnel1_restore_neutron;
#line 129 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  multiline(5,
    (double)xmin, (double)ymin, 0.0,
    (double)xmax, (double)ymin, 0.0,
    (double)xmax, (double)ymax, 0.0,
    (double)xmin, (double)ymax, 0.0,
    (double)xmin, (double)ymin, 0.0);
}
#line 88108 "./SNS_BASIS.c"
}   /* End of PSD_post_funnel1=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Funnel_2'. */
  SIG_MESSAGE("Funnel_2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Funnel_2");
#define mccompcurname  Funnel_2
#define mccompcurtype  Guide_m
#define mccompcurindex 106
#define reflect mccFunnel_2_reflect
#define pTable mccFunnel_2_pTable
#define m mccFunnel_2_m
#define alpha mccFunnel_2_alpha
#define Qc mccFunnel_2_Qc
#define R0 mccFunnel_2_R0
#define W mccFunnel_2_W
{   /* Declarations of Funnel_2=Guide_m() SETTING parameters. */
MCNUM w1 = mccFunnel_2_w1;
MCNUM h1 = mccFunnel_2_h1;
MCNUM w2 = mccFunnel_2_w2;
MCNUM h2 = mccFunnel_2_h2;
MCNUM l = mccFunnel_2_l;
MCNUM R0_left = mccFunnel_2_R0_left;
MCNUM R0_right = mccFunnel_2_R0_right;
MCNUM R0_top = mccFunnel_2_R0_top;
MCNUM R0_bottom = mccFunnel_2_R0_bottom;
MCNUM Qc_left = mccFunnel_2_Qc_left;
MCNUM Qc_right = mccFunnel_2_Qc_right;
MCNUM Qc_top = mccFunnel_2_Qc_top;
MCNUM Qc_bottom = mccFunnel_2_Qc_bottom;
MCNUM alpha_left = mccFunnel_2_alpha_left;
MCNUM alpha_right = mccFunnel_2_alpha_right;
MCNUM alpha_top = mccFunnel_2_alpha_top;
MCNUM alpha_bottom = mccFunnel_2_alpha_bottom;
MCNUM m_left = mccFunnel_2_m_left;
MCNUM m_right = mccFunnel_2_m_right;
MCNUM m_top = mccFunnel_2_m_top;
MCNUM m_bottom = mccFunnel_2_m_bottom;
MCNUM W_left = mccFunnel_2_W_left;
MCNUM W_right = mccFunnel_2_W_right;
MCNUM W_top = mccFunnel_2_W_top;
MCNUM W_bottom = mccFunnel_2_W_bottom;
#line 254 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_m.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 88176 "./SNS_BASIS.c"
}   /* End of Funnel_2=Guide_m() SETTING parameter declarations. */
#undef W
#undef R0
#undef Qc
#undef alpha
#undef m
#undef pTable
#undef reflect
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PSD_post_funnel2'. */
  SIG_MESSAGE("PSD_post_funnel2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PSD_post_funnel2");
#define mccompcurname  PSD_post_funnel2
#define mccompcurtype  PSD_monitor
#define mccompcurindex 107
#define PSD_N mccPSD_post_funnel2_PSD_N
#define PSD_p mccPSD_post_funnel2_PSD_p
#define PSD_p2 mccPSD_post_funnel2_PSD_p2
{   /* Declarations of PSD_post_funnel2=PSD_monitor() SETTING parameters. */
int nx = mccPSD_post_funnel2_nx;
int ny = mccPSD_post_funnel2_ny;
char* filename = mccPSD_post_funnel2_filename;
MCNUM xmin = mccPSD_post_funnel2_xmin;
MCNUM xmax = mccPSD_post_funnel2_xmax;
MCNUM ymin = mccPSD_post_funnel2_ymin;
MCNUM ymax = mccPSD_post_funnel2_ymax;
MCNUM xwidth = mccPSD_post_funnel2_xwidth;
MCNUM yheight = mccPSD_post_funnel2_yheight;
MCNUM restore_neutron = mccPSD_post_funnel2_restore_neutron;
#line 129 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  multiline(5,
    (double)xmin, (double)ymin, 0.0,
    (double)xmax, (double)ymin, 0.0,
    (double)xmax, (double)ymax, 0.0,
    (double)xmin, (double)ymax, 0.0,
    (double)xmin, (double)ymin, 0.0);
}
#line 88218 "./SNS_BASIS.c"
}   /* End of PSD_post_funnel2=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Funnel_3'. */
  SIG_MESSAGE("Funnel_3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Funnel_3");
#define mccompcurname  Funnel_3
#define mccompcurtype  Guide_m
#define mccompcurindex 108
#define reflect mccFunnel_3_reflect
#define pTable mccFunnel_3_pTable
#define m mccFunnel_3_m
#define alpha mccFunnel_3_alpha
#define Qc mccFunnel_3_Qc
#define R0 mccFunnel_3_R0
#define W mccFunnel_3_W
{   /* Declarations of Funnel_3=Guide_m() SETTING parameters. */
MCNUM w1 = mccFunnel_3_w1;
MCNUM h1 = mccFunnel_3_h1;
MCNUM w2 = mccFunnel_3_w2;
MCNUM h2 = mccFunnel_3_h2;
MCNUM l = mccFunnel_3_l;
MCNUM R0_left = mccFunnel_3_R0_left;
MCNUM R0_right = mccFunnel_3_R0_right;
MCNUM R0_top = mccFunnel_3_R0_top;
MCNUM R0_bottom = mccFunnel_3_R0_bottom;
MCNUM Qc_left = mccFunnel_3_Qc_left;
MCNUM Qc_right = mccFunnel_3_Qc_right;
MCNUM Qc_top = mccFunnel_3_Qc_top;
MCNUM Qc_bottom = mccFunnel_3_Qc_bottom;
MCNUM alpha_left = mccFunnel_3_alpha_left;
MCNUM alpha_right = mccFunnel_3_alpha_right;
MCNUM alpha_top = mccFunnel_3_alpha_top;
MCNUM alpha_bottom = mccFunnel_3_alpha_bottom;
MCNUM m_left = mccFunnel_3_m_left;
MCNUM m_right = mccFunnel_3_m_right;
MCNUM m_top = mccFunnel_3_m_top;
MCNUM m_bottom = mccFunnel_3_m_bottom;
MCNUM W_left = mccFunnel_3_W_left;
MCNUM W_right = mccFunnel_3_W_right;
MCNUM W_top = mccFunnel_3_W_top;
MCNUM W_bottom = mccFunnel_3_W_bottom;
#line 254 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_m.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 88286 "./SNS_BASIS.c"
}   /* End of Funnel_3=Guide_m() SETTING parameter declarations. */
#undef W
#undef R0
#undef Qc
#undef alpha
#undef m
#undef pTable
#undef reflect
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PSD_post_funnel3'. */
  SIG_MESSAGE("PSD_post_funnel3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PSD_post_funnel3");
#define mccompcurname  PSD_post_funnel3
#define mccompcurtype  PSD_monitor
#define mccompcurindex 109
#define PSD_N mccPSD_post_funnel3_PSD_N
#define PSD_p mccPSD_post_funnel3_PSD_p
#define PSD_p2 mccPSD_post_funnel3_PSD_p2
{   /* Declarations of PSD_post_funnel3=PSD_monitor() SETTING parameters. */
int nx = mccPSD_post_funnel3_nx;
int ny = mccPSD_post_funnel3_ny;
char* filename = mccPSD_post_funnel3_filename;
MCNUM xmin = mccPSD_post_funnel3_xmin;
MCNUM xmax = mccPSD_post_funnel3_xmax;
MCNUM ymin = mccPSD_post_funnel3_ymin;
MCNUM ymax = mccPSD_post_funnel3_ymax;
MCNUM xwidth = mccPSD_post_funnel3_xwidth;
MCNUM yheight = mccPSD_post_funnel3_yheight;
MCNUM restore_neutron = mccPSD_post_funnel3_restore_neutron;
#line 129 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  multiline(5,
    (double)xmin, (double)ymin, 0.0,
    (double)xmax, (double)ymin, 0.0,
    (double)xmax, (double)ymax, 0.0,
    (double)xmin, (double)ymax, 0.0,
    (double)xmin, (double)ymin, 0.0);
}
#line 88328 "./SNS_BASIS.c"
}   /* End of PSD_post_funnel3=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Funnel_4'. */
  SIG_MESSAGE("Funnel_4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Funnel_4");
#define mccompcurname  Funnel_4
#define mccompcurtype  Guide_m
#define mccompcurindex 110
#define reflect mccFunnel_4_reflect
#define pTable mccFunnel_4_pTable
#define m mccFunnel_4_m
#define alpha mccFunnel_4_alpha
#define Qc mccFunnel_4_Qc
#define R0 mccFunnel_4_R0
#define W mccFunnel_4_W
{   /* Declarations of Funnel_4=Guide_m() SETTING parameters. */
MCNUM w1 = mccFunnel_4_w1;
MCNUM h1 = mccFunnel_4_h1;
MCNUM w2 = mccFunnel_4_w2;
MCNUM h2 = mccFunnel_4_h2;
MCNUM l = mccFunnel_4_l;
MCNUM R0_left = mccFunnel_4_R0_left;
MCNUM R0_right = mccFunnel_4_R0_right;
MCNUM R0_top = mccFunnel_4_R0_top;
MCNUM R0_bottom = mccFunnel_4_R0_bottom;
MCNUM Qc_left = mccFunnel_4_Qc_left;
MCNUM Qc_right = mccFunnel_4_Qc_right;
MCNUM Qc_top = mccFunnel_4_Qc_top;
MCNUM Qc_bottom = mccFunnel_4_Qc_bottom;
MCNUM alpha_left = mccFunnel_4_alpha_left;
MCNUM alpha_right = mccFunnel_4_alpha_right;
MCNUM alpha_top = mccFunnel_4_alpha_top;
MCNUM alpha_bottom = mccFunnel_4_alpha_bottom;
MCNUM m_left = mccFunnel_4_m_left;
MCNUM m_right = mccFunnel_4_m_right;
MCNUM m_top = mccFunnel_4_m_top;
MCNUM m_bottom = mccFunnel_4_m_bottom;
MCNUM W_left = mccFunnel_4_W_left;
MCNUM W_right = mccFunnel_4_W_right;
MCNUM W_top = mccFunnel_4_W_top;
MCNUM W_bottom = mccFunnel_4_W_bottom;
#line 254 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Guide_m.comp"
{
  
  multiline(5,
            -w1/2.0, -h1/2.0, 0.0,
             w1/2.0, -h1/2.0, 0.0,
             w1/2.0,  h1/2.0, 0.0,
            -w1/2.0,  h1/2.0, 0.0,
            -w1/2.0, -h1/2.0, 0.0);
  multiline(5,
            -w2/2.0, -h2/2.0, (double)l,
             w2/2.0, -h2/2.0, (double)l,
             w2/2.0,  h2/2.0, (double)l,
            -w2/2.0,  h2/2.0, (double)l,
            -w2/2.0, -h2/2.0, (double)l);
  line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0, -h1/2.0, 0,  w2/2.0, -h2/2.0, (double)l);
  line( w1/2.0,  h1/2.0, 0,  w2/2.0,  h2/2.0, (double)l);
  line(-w1/2.0,  h1/2.0, 0, -w2/2.0,  h2/2.0, (double)l);
}
#line 88396 "./SNS_BASIS.c"
}   /* End of Funnel_4=Guide_m() SETTING parameter declarations. */
#undef W
#undef R0
#undef Qc
#undef alpha
#undef m
#undef pTable
#undef reflect
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PSD_post_funnel4'. */
  SIG_MESSAGE("PSD_post_funnel4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PSD_post_funnel4");
#define mccompcurname  PSD_post_funnel4
#define mccompcurtype  PSD_monitor
#define mccompcurindex 111
#define PSD_N mccPSD_post_funnel4_PSD_N
#define PSD_p mccPSD_post_funnel4_PSD_p
#define PSD_p2 mccPSD_post_funnel4_PSD_p2
{   /* Declarations of PSD_post_funnel4=PSD_monitor() SETTING parameters. */
int nx = mccPSD_post_funnel4_nx;
int ny = mccPSD_post_funnel4_ny;
char* filename = mccPSD_post_funnel4_filename;
MCNUM xmin = mccPSD_post_funnel4_xmin;
MCNUM xmax = mccPSD_post_funnel4_xmax;
MCNUM ymin = mccPSD_post_funnel4_ymin;
MCNUM ymax = mccPSD_post_funnel4_ymax;
MCNUM xwidth = mccPSD_post_funnel4_xwidth;
MCNUM yheight = mccPSD_post_funnel4_yheight;
MCNUM restore_neutron = mccPSD_post_funnel4_restore_neutron;
#line 129 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  multiline(5,
    (double)xmin, (double)ymin, 0.0,
    (double)xmax, (double)ymin, 0.0,
    (double)xmax, (double)ymax, 0.0,
    (double)xmin, (double)ymax, 0.0,
    (double)xmin, (double)ymin, 0.0);
}
#line 88438 "./SNS_BASIS.c"
}   /* End of PSD_post_funnel4=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Guide_End_ToF'. */
  SIG_MESSAGE("Guide_End_ToF (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Guide_End_ToF");
#define mccompcurname  Guide_End_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 112
#define nt mccGuide_End_ToF_nt
#define TOF_N mccGuide_End_ToF_TOF_N
#define TOF_p mccGuide_End_ToF_TOF_p
#define TOF_p2 mccGuide_End_ToF_TOF_p2
#define t_min mccGuide_End_ToF_t_min
#define t_max mccGuide_End_ToF_t_max
#define delta_t mccGuide_End_ToF_delta_t
{   /* Declarations of Guide_End_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccGuide_End_ToF_filename;
MCNUM xmin = mccGuide_End_ToF_xmin;
MCNUM xmax = mccGuide_End_ToF_xmax;
MCNUM ymin = mccGuide_End_ToF_ymin;
MCNUM ymax = mccGuide_End_ToF_ymax;
MCNUM xwidth = mccGuide_End_ToF_xwidth;
MCNUM yheight = mccGuide_End_ToF_yheight;
MCNUM tmin = mccGuide_End_ToF_tmin;
MCNUM tmax = mccGuide_End_ToF_tmax;
MCNUM dt = mccGuide_End_ToF_dt;
MCNUM restore_neutron = mccGuide_End_ToF_restore_neutron;
int nowritefile = mccGuide_End_ToF_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 88482 "./SNS_BASIS.c"
}   /* End of Guide_End_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Guide_End_ToF_Z'. */
  SIG_MESSAGE("Guide_End_ToF_Z (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Guide_End_ToF_Z");
#define mccompcurname  Guide_End_ToF_Z
#define mccompcurtype  TOF_monitor
#define mccompcurindex 113
#define nt mccGuide_End_ToF_Z_nt
#define TOF_N mccGuide_End_ToF_Z_TOF_N
#define TOF_p mccGuide_End_ToF_Z_TOF_p
#define TOF_p2 mccGuide_End_ToF_Z_TOF_p2
#define t_min mccGuide_End_ToF_Z_t_min
#define t_max mccGuide_End_ToF_Z_t_max
#define delta_t mccGuide_End_ToF_Z_delta_t
{   /* Declarations of Guide_End_ToF_Z=TOF_monitor() SETTING parameters. */
char* filename = mccGuide_End_ToF_Z_filename;
MCNUM xmin = mccGuide_End_ToF_Z_xmin;
MCNUM xmax = mccGuide_End_ToF_Z_xmax;
MCNUM ymin = mccGuide_End_ToF_Z_ymin;
MCNUM ymax = mccGuide_End_ToF_Z_ymax;
MCNUM xwidth = mccGuide_End_ToF_Z_xwidth;
MCNUM yheight = mccGuide_End_ToF_Z_yheight;
MCNUM tmin = mccGuide_End_ToF_Z_tmin;
MCNUM tmax = mccGuide_End_ToF_Z_tmax;
MCNUM dt = mccGuide_End_ToF_Z_dt;
MCNUM restore_neutron = mccGuide_End_ToF_Z_restore_neutron;
int nowritefile = mccGuide_End_ToF_Z_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 88530 "./SNS_BASIS.c"
}   /* End of Guide_End_ToF_Z=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Guide_end_Lam'. */
  SIG_MESSAGE("Guide_end_Lam (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Guide_end_Lam");
#define mccompcurname  Guide_end_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 114
#define nL mccGuide_end_Lam_nL
#define L_N mccGuide_end_Lam_L_N
#define L_p mccGuide_end_Lam_L_p
#define L_p2 mccGuide_end_Lam_L_p2
{   /* Declarations of Guide_end_Lam=L_monitor() SETTING parameters. */
char* filename = mccGuide_end_Lam_filename;
MCNUM xmin = mccGuide_end_Lam_xmin;
MCNUM xmax = mccGuide_end_Lam_xmax;
MCNUM ymin = mccGuide_end_Lam_ymin;
MCNUM ymax = mccGuide_end_Lam_ymax;
MCNUM xwidth = mccGuide_end_Lam_xwidth;
MCNUM yheight = mccGuide_end_Lam_yheight;
MCNUM Lmin = mccGuide_end_Lam_Lmin;
MCNUM Lmax = mccGuide_end_Lam_Lmax;
MCNUM restore_neutron = mccGuide_end_Lam_restore_neutron;
int nowritefile = mccGuide_end_Lam_nowritefile;
#line 120 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 88574 "./SNS_BASIS.c"
}   /* End of Guide_end_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Guide_end_divx'. */
  SIG_MESSAGE("Guide_end_divx (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Guide_end_divx");
#define mccompcurname  Guide_end_divx
#define mccompcurtype  Monitor_nD
#define mccompcurindex 115
#define user1 mccGuide_end_divx_user1
#define user2 mccGuide_end_divx_user2
#define user3 mccGuide_end_divx_user3
#define DEFS mccGuide_end_divx_DEFS
#define Vars mccGuide_end_divx_Vars
#define detector mccGuide_end_divx_detector
#define offdata mccGuide_end_divx_offdata
{   /* Declarations of Guide_end_divx=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccGuide_end_divx_xwidth;
MCNUM yheight = mccGuide_end_divx_yheight;
MCNUM zdepth = mccGuide_end_divx_zdepth;
MCNUM xmin = mccGuide_end_divx_xmin;
MCNUM xmax = mccGuide_end_divx_xmax;
MCNUM ymin = mccGuide_end_divx_ymin;
MCNUM ymax = mccGuide_end_divx_ymax;
MCNUM zmin = mccGuide_end_divx_zmin;
MCNUM zmax = mccGuide_end_divx_zmax;
MCNUM bins = mccGuide_end_divx_bins;
MCNUM min = mccGuide_end_divx_min;
MCNUM max = mccGuide_end_divx_max;
MCNUM restore_neutron = mccGuide_end_divx_restore_neutron;
MCNUM radius = mccGuide_end_divx_radius;
char* options = mccGuide_end_divx_options;
char* filename = mccGuide_end_divx_filename;
char* geometry = mccGuide_end_divx_geometry;
char* username1 = mccGuide_end_divx_username1;
char* username2 = mccGuide_end_divx_username2;
char* username3 = mccGuide_end_divx_username3;
int nowritefile = mccGuide_end_divx_nowritefile;
#line 495 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    off_display(offdata);
  } else {
    Monitor_nD_McDisplay(&DEFS, &Vars);
  }
}
#line 88628 "./SNS_BASIS.c"
}   /* End of Guide_end_divx=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Guide_end_divy'. */
  SIG_MESSAGE("Guide_end_divy (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Guide_end_divy");
#define mccompcurname  Guide_end_divy
#define mccompcurtype  Monitor_nD
#define mccompcurindex 116
#define user1 mccGuide_end_divy_user1
#define user2 mccGuide_end_divy_user2
#define user3 mccGuide_end_divy_user3
#define DEFS mccGuide_end_divy_DEFS
#define Vars mccGuide_end_divy_Vars
#define detector mccGuide_end_divy_detector
#define offdata mccGuide_end_divy_offdata
{   /* Declarations of Guide_end_divy=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccGuide_end_divy_xwidth;
MCNUM yheight = mccGuide_end_divy_yheight;
MCNUM zdepth = mccGuide_end_divy_zdepth;
MCNUM xmin = mccGuide_end_divy_xmin;
MCNUM xmax = mccGuide_end_divy_xmax;
MCNUM ymin = mccGuide_end_divy_ymin;
MCNUM ymax = mccGuide_end_divy_ymax;
MCNUM zmin = mccGuide_end_divy_zmin;
MCNUM zmax = mccGuide_end_divy_zmax;
MCNUM bins = mccGuide_end_divy_bins;
MCNUM min = mccGuide_end_divy_min;
MCNUM max = mccGuide_end_divy_max;
MCNUM restore_neutron = mccGuide_end_divy_restore_neutron;
MCNUM radius = mccGuide_end_divy_radius;
char* options = mccGuide_end_divy_options;
char* filename = mccGuide_end_divy_filename;
char* geometry = mccGuide_end_divy_geometry;
char* username1 = mccGuide_end_divy_username1;
char* username2 = mccGuide_end_divy_username2;
char* username3 = mccGuide_end_divy_username3;
int nowritefile = mccGuide_end_divy_nowritefile;
#line 495 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    off_display(offdata);
  } else {
    Monitor_nD_McDisplay(&DEFS, &Vars);
  }
}
#line 88685 "./SNS_BASIS.c"
}   /* End of Guide_end_divy=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Guide_end_PSD'. */
  SIG_MESSAGE("Guide_end_PSD (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Guide_end_PSD");
#define mccompcurname  Guide_end_PSD
#define mccompcurtype  PSD_monitor
#define mccompcurindex 117
#define PSD_N mccGuide_end_PSD_PSD_N
#define PSD_p mccGuide_end_PSD_PSD_p
#define PSD_p2 mccGuide_end_PSD_PSD_p2
{   /* Declarations of Guide_end_PSD=PSD_monitor() SETTING parameters. */
int nx = mccGuide_end_PSD_nx;
int ny = mccGuide_end_PSD_ny;
char* filename = mccGuide_end_PSD_filename;
MCNUM xmin = mccGuide_end_PSD_xmin;
MCNUM xmax = mccGuide_end_PSD_xmax;
MCNUM ymin = mccGuide_end_PSD_ymin;
MCNUM ymax = mccGuide_end_PSD_ymax;
MCNUM xwidth = mccGuide_end_PSD_xwidth;
MCNUM yheight = mccGuide_end_PSD_yheight;
MCNUM restore_neutron = mccGuide_end_PSD_restore_neutron;
#line 129 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  multiline(5,
    (double)xmin, (double)ymin, 0.0,
    (double)xmax, (double)ymin, 0.0,
    (double)xmax, (double)ymax, 0.0,
    (double)xmin, (double)ymax, 0.0,
    (double)xmin, (double)ymin, 0.0);
}
#line 88727 "./SNS_BASIS.c"
}   /* End of Guide_end_PSD=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Sample_split'. */
  SIG_MESSAGE("Sample_split (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Sample_split");
#define mccompcurname  Sample_split
#define mccompcurtype  Arm
#define mccompcurindex 118
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 88750 "./SNS_BASIS.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'SamplePos'. */
  SIG_MESSAGE("SamplePos (McDisplay)");
  printf("MCDISPLAY: component %s\n", "SamplePos");
#define mccompcurname  SamplePos
#define mccompcurtype  PSD_monitor
#define mccompcurindex 119
#define PSD_N mccSamplePos_PSD_N
#define PSD_p mccSamplePos_PSD_p
#define PSD_p2 mccSamplePos_PSD_p2
{   /* Declarations of SamplePos=PSD_monitor() SETTING parameters. */
int nx = mccSamplePos_nx;
int ny = mccSamplePos_ny;
char* filename = mccSamplePos_filename;
MCNUM xmin = mccSamplePos_xmin;
MCNUM xmax = mccSamplePos_xmax;
MCNUM ymin = mccSamplePos_ymin;
MCNUM ymax = mccSamplePos_ymax;
MCNUM xwidth = mccSamplePos_xwidth;
MCNUM yheight = mccSamplePos_yheight;
MCNUM restore_neutron = mccSamplePos_restore_neutron;
#line 129 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/PSD_monitor.comp"
{
  multiline(5,
    (double)xmin, (double)ymin, 0.0,
    (double)xmax, (double)ymin, 0.0,
    (double)xmax, (double)ymax, 0.0,
    (double)xmin, (double)ymax, 0.0,
    (double)xmin, (double)ymin, 0.0);
}
#line 88784 "./SNS_BASIS.c"
}   /* End of SamplePos=PSD_monitor() SETTING parameter declarations. */
#undef PSD_p2
#undef PSD_p
#undef PSD_N
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Sample'. */
  SIG_MESSAGE("Sample (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Sample");
#define mccompcurname  Sample
#define mccompcurtype  Isotropic_Sqw
#define mccompcurindex 120
#define powder_format mccSample_powder_format
#define VarSqw mccSample_VarSqw
#define columns mccSample_columns
#define offdata mccSample_offdata
{   /* Declarations of Sample=Isotropic_Sqw() SETTING parameters. */
char* Sqw_coh = mccSample_Sqw_coh;
char* Sqw_inc = mccSample_Sqw_inc;
char* geometry = mccSample_geometry;
MCNUM radius = mccSample_radius;
MCNUM thickness = mccSample_thickness;
MCNUM xwidth = mccSample_xwidth;
MCNUM yheight = mccSample_yheight;
MCNUM zdepth = mccSample_zdepth;
MCNUM threshold = mccSample_threshold;
int order = mccSample_order;
MCNUM T = mccSample_T;
MCNUM verbose = mccSample_verbose;
MCNUM d_phi = mccSample_d_phi;
int concentric = mccSample_concentric;
MCNUM rho = mccSample_rho;
MCNUM sigma_abs = mccSample_sigma_abs;
MCNUM sigma_coh = mccSample_sigma_coh;
MCNUM sigma_inc = mccSample_sigma_inc;
MCNUM classical = mccSample_classical;
MCNUM powder_Dd = mccSample_powder_Dd;
MCNUM powder_DW = mccSample_powder_DW;
MCNUM powder_Vc = mccSample_powder_Vc;
MCNUM density = mccSample_density;
MCNUM weight = mccSample_weight;
MCNUM p_interact = mccSample_p_interact;
MCNUM norm = mccSample_norm;
MCNUM powder_barns = mccSample_powder_barns;
char* quantum_correction = mccSample_quantum_correction;
#line 2761 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../samples/Isotropic_Sqw.comp"
{
  if (VarSqw.s_coh > 0 || VarSqw.s_inc > 0) {
    
    if(VarSqw.shape==1)
    {
      double xmin = -0.5*xwidth;
      double xmax =  0.5*xwidth;
      double ymin = -0.5*yheight;
      double ymax =  0.5*yheight;
      double zmin = -0.5*zdepth;
      double zmax =  0.5*zdepth;
      multiline(5, xmin, ymin, zmin,
                  xmax, ymin, zmin,
                  xmax, ymax, zmin,
                  xmin, ymax, zmin,
                  xmin, ymin, zmin);
      multiline(5, xmin, ymin, zmax,
                  xmax, ymin, zmax,
                  xmax, ymax, zmax,
                  xmin, ymax, zmax,
                  xmin, ymin, zmax);
      line(xmin, ymin, zmin, xmin, ymin, zmax);
      line(xmax, ymin, zmin, xmax, ymin, zmax);
      line(xmin, ymax, zmin, xmin, ymax, zmax);
      line(xmax, ymax, zmin, xmax, ymax, zmax);

      if (thickness) {
        xmin = -0.5*xwidth+thickness;
        xmax = -xmin;
        ymin = -0.5*yheight+thickness;
        ymax = -ymin;
        zmin = -0.5*zdepth+thickness;
        zmax = -zmin;
        multiline(5, xmin, ymin, zmin,
                    xmax, ymin, zmin,
                    xmax, ymax, zmin,
                    xmin, ymax, zmin,
                    xmin, ymin, zmin);
        multiline(5, xmin, ymin, zmax,
                    xmax, ymin, zmax,
                    xmax, ymax, zmax,
                    xmin, ymax, zmax,
                    xmin, ymin, zmax);
        line(xmin, ymin, zmin, xmin, ymin, zmax);
        line(xmax, ymin, zmin, xmax, ymin, zmax);
        line(xmin, ymax, zmin, xmin, ymax, zmax);
        line(xmax, ymax, zmin, xmax, ymax, zmax);
      }
    }
    else if(VarSqw.shape==0)
    {
      circle("xz", 0,  yheight/2.0, 0, radius);
      circle("xz", 0, -yheight/2.0, 0, radius);
      line(-radius, -yheight/2.0, 0, -radius, +yheight/2.0, 0);
      line(+radius, -yheight/2.0, 0, +radius, +yheight/2.0, 0);
      line(0, -yheight/2.0, -radius, 0, +yheight/2.0, -radius);
      line(0, -yheight/2.0, +radius, 0, +yheight/2.0, +radius);
      if (thickness) {
        double radius_i=radius-thickness;
        circle("xz", 0,  yheight/2.0, 0, radius_i);
        circle("xz", 0, -yheight/2.0, 0, radius_i);
        line(-radius_i, -yheight/2.0, 0, -radius_i, +yheight/2.0, 0);
        line(+radius_i, -yheight/2.0, 0, +radius_i, +yheight/2.0, 0);
        line(0, -yheight/2.0, -radius_i, 0, +yheight/2.0, -radius_i);
        line(0, -yheight/2.0, +radius_i, 0, +yheight/2.0, +radius_i);
      }
    } else if(VarSqw.shape==2) {
      if (thickness) {
        double radius_i=radius-thickness;
        circle("xy",0,0,0,radius_i);
        circle("xz",0,0,0,radius_i);
        circle("yz",0,0,0,radius_i);
      }
      circle("xy",0,0,0,radius);
      circle("xz",0,0,0,radius);
      circle("yz",0,0,0,radius);
    } else if (VarSqw.shape == 3) {	/* OFF file */
      off_display(offdata);
    }
  }
/* end MCDISPLAY */
}
#line 88915 "./SNS_BASIS.c"
}   /* End of Sample=Isotropic_Sqw() SETTING parameter declarations. */
#undef offdata
#undef columns
#undef VarSqw
#undef powder_format
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'An1_rot_axis'. */
  SIG_MESSAGE("An1_rot_axis (McDisplay)");
  printf("MCDISPLAY: component %s\n", "An1_rot_axis");
#define mccompcurname  An1_rot_axis
#define mccompcurtype  Arm
#define mccompcurindex 121
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 88939 "./SNS_BASIS.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'An2_rot_axis'. */
  SIG_MESSAGE("An2_rot_axis (McDisplay)");
  printf("MCDISPLAY: component %s\n", "An2_rot_axis");
#define mccompcurname  An2_rot_axis
#define mccompcurtype  Arm
#define mccompcurindex 122
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 88958 "./SNS_BASIS.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'An3_rot_axis'. */
  SIG_MESSAGE("An3_rot_axis (McDisplay)");
  printf("MCDISPLAY: component %s\n", "An3_rot_axis");
#define mccompcurname  An3_rot_axis
#define mccompcurtype  Arm
#define mccompcurindex 123
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 88977 "./SNS_BASIS.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'An1_ToF'. */
  SIG_MESSAGE("An1_ToF (McDisplay)");
  printf("MCDISPLAY: component %s\n", "An1_ToF");
#define mccompcurname  An1_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 124
#define nt mccAn1_ToF_nt
#define TOF_N mccAn1_ToF_TOF_N
#define TOF_p mccAn1_ToF_TOF_p
#define TOF_p2 mccAn1_ToF_TOF_p2
#define t_min mccAn1_ToF_t_min
#define t_max mccAn1_ToF_t_max
#define delta_t mccAn1_ToF_delta_t
{   /* Declarations of An1_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccAn1_ToF_filename;
MCNUM xmin = mccAn1_ToF_xmin;
MCNUM xmax = mccAn1_ToF_xmax;
MCNUM ymin = mccAn1_ToF_ymin;
MCNUM ymax = mccAn1_ToF_ymax;
MCNUM xwidth = mccAn1_ToF_xwidth;
MCNUM yheight = mccAn1_ToF_yheight;
MCNUM tmin = mccAn1_ToF_tmin;
MCNUM tmax = mccAn1_ToF_tmax;
MCNUM dt = mccAn1_ToF_dt;
MCNUM restore_neutron = mccAn1_ToF_restore_neutron;
int nowritefile = mccAn1_ToF_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 89017 "./SNS_BASIS.c"
}   /* End of An1_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'An1_ToF_variable_range'. */
  SIG_MESSAGE("An1_ToF_variable_range (McDisplay)");
  printf("MCDISPLAY: component %s\n", "An1_ToF_variable_range");
#define mccompcurname  An1_ToF_variable_range
#define mccompcurtype  TOF_monitor
#define mccompcurindex 125
#define nt mccAn1_ToF_variable_range_nt
#define TOF_N mccAn1_ToF_variable_range_TOF_N
#define TOF_p mccAn1_ToF_variable_range_TOF_p
#define TOF_p2 mccAn1_ToF_variable_range_TOF_p2
#define t_min mccAn1_ToF_variable_range_t_min
#define t_max mccAn1_ToF_variable_range_t_max
#define delta_t mccAn1_ToF_variable_range_delta_t
{   /* Declarations of An1_ToF_variable_range=TOF_monitor() SETTING parameters. */
char* filename = mccAn1_ToF_variable_range_filename;
MCNUM xmin = mccAn1_ToF_variable_range_xmin;
MCNUM xmax = mccAn1_ToF_variable_range_xmax;
MCNUM ymin = mccAn1_ToF_variable_range_ymin;
MCNUM ymax = mccAn1_ToF_variable_range_ymax;
MCNUM xwidth = mccAn1_ToF_variable_range_xwidth;
MCNUM yheight = mccAn1_ToF_variable_range_yheight;
MCNUM tmin = mccAn1_ToF_variable_range_tmin;
MCNUM tmax = mccAn1_ToF_variable_range_tmax;
MCNUM dt = mccAn1_ToF_variable_range_dt;
MCNUM restore_neutron = mccAn1_ToF_variable_range_restore_neutron;
int nowritefile = mccAn1_ToF_variable_range_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 89065 "./SNS_BASIS.c"
}   /* End of An1_ToF_variable_range=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'An1_Lam'. */
  SIG_MESSAGE("An1_Lam (McDisplay)");
  printf("MCDISPLAY: component %s\n", "An1_Lam");
#define mccompcurname  An1_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 126
#define nL mccAn1_Lam_nL
#define L_N mccAn1_Lam_L_N
#define L_p mccAn1_Lam_L_p
#define L_p2 mccAn1_Lam_L_p2
{   /* Declarations of An1_Lam=L_monitor() SETTING parameters. */
char* filename = mccAn1_Lam_filename;
MCNUM xmin = mccAn1_Lam_xmin;
MCNUM xmax = mccAn1_Lam_xmax;
MCNUM ymin = mccAn1_Lam_ymin;
MCNUM ymax = mccAn1_Lam_ymax;
MCNUM xwidth = mccAn1_Lam_xwidth;
MCNUM yheight = mccAn1_Lam_yheight;
MCNUM Lmin = mccAn1_Lam_Lmin;
MCNUM Lmax = mccAn1_Lam_Lmax;
MCNUM restore_neutron = mccAn1_Lam_restore_neutron;
int nowritefile = mccAn1_Lam_nowritefile;
#line 120 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 89109 "./SNS_BASIS.c"
}   /* End of An1_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'An1_Lam_variable_range'. */
  SIG_MESSAGE("An1_Lam_variable_range (McDisplay)");
  printf("MCDISPLAY: component %s\n", "An1_Lam_variable_range");
#define mccompcurname  An1_Lam_variable_range
#define mccompcurtype  L_monitor
#define mccompcurindex 127
#define nL mccAn1_Lam_variable_range_nL
#define L_N mccAn1_Lam_variable_range_L_N
#define L_p mccAn1_Lam_variable_range_L_p
#define L_p2 mccAn1_Lam_variable_range_L_p2
{   /* Declarations of An1_Lam_variable_range=L_monitor() SETTING parameters. */
char* filename = mccAn1_Lam_variable_range_filename;
MCNUM xmin = mccAn1_Lam_variable_range_xmin;
MCNUM xmax = mccAn1_Lam_variable_range_xmax;
MCNUM ymin = mccAn1_Lam_variable_range_ymin;
MCNUM ymax = mccAn1_Lam_variable_range_ymax;
MCNUM xwidth = mccAn1_Lam_variable_range_xwidth;
MCNUM yheight = mccAn1_Lam_variable_range_yheight;
MCNUM Lmin = mccAn1_Lam_variable_range_Lmin;
MCNUM Lmax = mccAn1_Lam_variable_range_Lmax;
MCNUM restore_neutron = mccAn1_Lam_variable_range_restore_neutron;
int nowritefile = mccAn1_Lam_variable_range_nowritefile;
#line 120 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 89150 "./SNS_BASIS.c"
}   /* End of An1_Lam_variable_range=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'An1_E'. */
  SIG_MESSAGE("An1_E (McDisplay)");
  printf("MCDISPLAY: component %s\n", "An1_E");
#define mccompcurname  An1_E
#define mccompcurtype  E_monitor
#define mccompcurindex 128
#define nE mccAn1_E_nE
#define E_N mccAn1_E_E_N
#define E_p mccAn1_E_E_p
#define E_p2 mccAn1_E_E_p2
#define S_p mccAn1_E_S_p
#define S_pE mccAn1_E_S_pE
#define S_pE2 mccAn1_E_S_pE2
{   /* Declarations of An1_E=E_monitor() SETTING parameters. */
char* filename = mccAn1_E_filename;
MCNUM xmin = mccAn1_E_xmin;
MCNUM xmax = mccAn1_E_xmax;
MCNUM ymin = mccAn1_E_ymin;
MCNUM ymax = mccAn1_E_ymax;
MCNUM xwidth = mccAn1_E_xwidth;
MCNUM yheight = mccAn1_E_yheight;
MCNUM Emin = mccAn1_E_Emin;
MCNUM Emax = mccAn1_E_Emax;
MCNUM restore_neutron = mccAn1_E_restore_neutron;
int nowritefile = mccAn1_E_nowritefile;
#line 132 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 89194 "./SNS_BASIS.c"
}   /* End of An1_E=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'An1_E_variable_range'. */
  SIG_MESSAGE("An1_E_variable_range (McDisplay)");
  printf("MCDISPLAY: component %s\n", "An1_E_variable_range");
#define mccompcurname  An1_E_variable_range
#define mccompcurtype  E_monitor
#define mccompcurindex 129
#define nE mccAn1_E_variable_range_nE
#define E_N mccAn1_E_variable_range_E_N
#define E_p mccAn1_E_variable_range_E_p
#define E_p2 mccAn1_E_variable_range_E_p2
#define S_p mccAn1_E_variable_range_S_p
#define S_pE mccAn1_E_variable_range_S_pE
#define S_pE2 mccAn1_E_variable_range_S_pE2
{   /* Declarations of An1_E_variable_range=E_monitor() SETTING parameters. */
char* filename = mccAn1_E_variable_range_filename;
MCNUM xmin = mccAn1_E_variable_range_xmin;
MCNUM xmax = mccAn1_E_variable_range_xmax;
MCNUM ymin = mccAn1_E_variable_range_ymin;
MCNUM ymax = mccAn1_E_variable_range_ymax;
MCNUM xwidth = mccAn1_E_variable_range_xwidth;
MCNUM yheight = mccAn1_E_variable_range_yheight;
MCNUM Emin = mccAn1_E_variable_range_Emin;
MCNUM Emax = mccAn1_E_variable_range_Emax;
MCNUM restore_neutron = mccAn1_E_variable_range_restore_neutron;
int nowritefile = mccAn1_E_variable_range_nowritefile;
#line 132 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 89241 "./SNS_BASIS.c"
}   /* End of An1_E_variable_range=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'An1_rot_axis2'. */
  SIG_MESSAGE("An1_rot_axis2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "An1_rot_axis2");
#define mccompcurname  An1_rot_axis2
#define mccompcurtype  Arm
#define mccompcurindex 130
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 89268 "./SNS_BASIS.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'An2_rot_axis2'. */
  SIG_MESSAGE("An2_rot_axis2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "An2_rot_axis2");
#define mccompcurname  An2_rot_axis2
#define mccompcurtype  Arm
#define mccompcurindex 131
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 89287 "./SNS_BASIS.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'An3_rot_axis2'. */
  SIG_MESSAGE("An3_rot_axis2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "An3_rot_axis2");
#define mccompcurname  An3_rot_axis2
#define mccompcurtype  Arm
#define mccompcurindex 132
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 89306 "./SNS_BASIS.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'An1'. */
  SIG_MESSAGE("An1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "An1");
#define mccompcurname  An1
#define mccompcurtype  Spherical_Backscattering_Analyser
#define mccompcurindex 133
#define d_rms mccAn1_d_rms
#define mos_rms mccAn1_mos_rms
#define mono_Q mccAn1_mono_Q
{   /* Declarations of An1=Spherical_Backscattering_Analyser() SETTING parameters. */
MCNUM xmin = mccAn1_xmin;
MCNUM xmax = mccAn1_xmax;
MCNUM ymin = mccAn1_ymin;
MCNUM ymax = mccAn1_ymax;
MCNUM mosaic = mccAn1_mosaic;
MCNUM dspread = mccAn1_dspread;
MCNUM Q = mccAn1_Q;
MCNUM DM = mccAn1_DM;
MCNUM radius = mccAn1_radius;
MCNUM f_doppler = mccAn1_f_doppler;
MCNUM A_doppler = mccAn1_A_doppler;
MCNUM R0 = mccAn1_R0;
MCNUM debug = mccAn1_debug;
#line 177 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Spherical_Backscattering_Analyser.comp"
{

  /*  dashed_line(xmin,ymin,0,xmin,ymax,0,5);
  dashed_line(xmin,ymax,0,xmax,ymax,0,5);
  dashed_line(xmax,ymax,0,xmax,ymin,0,5);
  dashed_line(xmax,ymin,0,xmin,ymin,0,5);*/

/* Step across the sphere in 11x11 steps to show the analyzer geometry */
  int i,j,N;
  double yv1,yv2,zv1,zv2;
  double xh1,xh2,zh1,zh2;
  double xd1,xd2,yd1,yd2,xd3,xd4,yd3,yd4,zd1,zd2,zd3,zd4;
  double dx,dy,dd;
  N=11;
  dx = (xmax-xmin)/(N-1);
  dy = (ymax-ymin)/(N-1);
  /* Horizontal, vertical, diagonal lines... */
  xh1=xmin;
  yv1=ymin;
  xd1=xmin;
  yd1=ymin;
  xd3=xmin;
  yd3=ymax;
  for (i=0; i<N-1; i++) {
    /* Calculate z-coordinates of 1st line-point(s)*/
    zh1=z_sphere(xh1,ymin,radius);
    zv1=z_sphere(xmin,yv1,radius);
    zd1=z_sphere(xd1,yd1,radius);
    zd3=z_sphere(xd3,yd3,radius);
    /* 2nd point x-y values */
    xh2=xh1+dx;
    yv2=yv1+dy;

    xd2=xd1+dx;
    yd2=yd1+dy;

    xd4=xd3+dx;
    yd4=yd3-dy;
    /* Calculate z-coordinates of 2nd set of line-point(s)*/
    zh2=z_sphere(xh1,ymin,radius);
    zv2=z_sphere(xmin,yv2,radius);
    zd2=z_sphere(xd2,yd2,radius);
    zd4=z_sphere(xd4,yd4,radius);
    /* Horizontal: */
    line(xh1,ymin,zh1,xh2,ymin,zh2);
    line(xh1,ymax,zh1,xh2,ymax,zh2);
    /* Vertical: */
    line(xmin,yv1,zv1,xmin,yv2,zv2);
    line(xmax,yv1,zv1,xmax,yv2,zv2);
    /* Diagonal: */
    line(xd1,yd1,zd1,xd2,yd2,zd2);
    line(xd3,yd3,zd3,xd4,yd4,zd4);
    /* Shift to next set of points ... */
    xh1=xh2; yv1=yv2; xd1=xd2; yd1=yd2; xd3=xd4; yd3=yd4;
  }
  
}
#line 89392 "./SNS_BASIS.c"
}   /* End of An1=Spherical_Backscattering_Analyser() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms
#undef d_rms
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'An2'. */
  SIG_MESSAGE("An2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "An2");
#define mccompcurname  An2
#define mccompcurtype  Spherical_Backscattering_Analyser
#define mccompcurindex 134
#define d_rms mccAn2_d_rms
#define mos_rms mccAn2_mos_rms
#define mono_Q mccAn2_mono_Q
{   /* Declarations of An2=Spherical_Backscattering_Analyser() SETTING parameters. */
MCNUM xmin = mccAn2_xmin;
MCNUM xmax = mccAn2_xmax;
MCNUM ymin = mccAn2_ymin;
MCNUM ymax = mccAn2_ymax;
MCNUM mosaic = mccAn2_mosaic;
MCNUM dspread = mccAn2_dspread;
MCNUM Q = mccAn2_Q;
MCNUM DM = mccAn2_DM;
MCNUM radius = mccAn2_radius;
MCNUM f_doppler = mccAn2_f_doppler;
MCNUM A_doppler = mccAn2_A_doppler;
MCNUM R0 = mccAn2_R0;
MCNUM debug = mccAn2_debug;
#line 177 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Spherical_Backscattering_Analyser.comp"
{

  /*  dashed_line(xmin,ymin,0,xmin,ymax,0,5);
  dashed_line(xmin,ymax,0,xmax,ymax,0,5);
  dashed_line(xmax,ymax,0,xmax,ymin,0,5);
  dashed_line(xmax,ymin,0,xmin,ymin,0,5);*/

/* Step across the sphere in 11x11 steps to show the analyzer geometry */
  int i,j,N;
  double yv1,yv2,zv1,zv2;
  double xh1,xh2,zh1,zh2;
  double xd1,xd2,yd1,yd2,xd3,xd4,yd3,yd4,zd1,zd2,zd3,zd4;
  double dx,dy,dd;
  N=11;
  dx = (xmax-xmin)/(N-1);
  dy = (ymax-ymin)/(N-1);
  /* Horizontal, vertical, diagonal lines... */
  xh1=xmin;
  yv1=ymin;
  xd1=xmin;
  yd1=ymin;
  xd3=xmin;
  yd3=ymax;
  for (i=0; i<N-1; i++) {
    /* Calculate z-coordinates of 1st line-point(s)*/
    zh1=z_sphere(xh1,ymin,radius);
    zv1=z_sphere(xmin,yv1,radius);
    zd1=z_sphere(xd1,yd1,radius);
    zd3=z_sphere(xd3,yd3,radius);
    /* 2nd point x-y values */
    xh2=xh1+dx;
    yv2=yv1+dy;

    xd2=xd1+dx;
    yd2=yd1+dy;

    xd4=xd3+dx;
    yd4=yd3-dy;
    /* Calculate z-coordinates of 2nd set of line-point(s)*/
    zh2=z_sphere(xh1,ymin,radius);
    zv2=z_sphere(xmin,yv2,radius);
    zd2=z_sphere(xd2,yd2,radius);
    zd4=z_sphere(xd4,yd4,radius);
    /* Horizontal: */
    line(xh1,ymin,zh1,xh2,ymin,zh2);
    line(xh1,ymax,zh1,xh2,ymax,zh2);
    /* Vertical: */
    line(xmin,yv1,zv1,xmin,yv2,zv2);
    line(xmax,yv1,zv1,xmax,yv2,zv2);
    /* Diagonal: */
    line(xd1,yd1,zd1,xd2,yd2,zd2);
    line(xd3,yd3,zd3,xd4,yd4,zd4);
    /* Shift to next set of points ... */
    xh1=xh2; yv1=yv2; xd1=xd2; yd1=yd2; xd3=xd4; yd3=yd4;
  }
  
}
#line 89482 "./SNS_BASIS.c"
}   /* End of An2=Spherical_Backscattering_Analyser() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms
#undef d_rms
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'An3'. */
  SIG_MESSAGE("An3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "An3");
#define mccompcurname  An3
#define mccompcurtype  Spherical_Backscattering_Analyser
#define mccompcurindex 135
#define d_rms mccAn3_d_rms
#define mos_rms mccAn3_mos_rms
#define mono_Q mccAn3_mono_Q
{   /* Declarations of An3=Spherical_Backscattering_Analyser() SETTING parameters. */
MCNUM xmin = mccAn3_xmin;
MCNUM xmax = mccAn3_xmax;
MCNUM ymin = mccAn3_ymin;
MCNUM ymax = mccAn3_ymax;
MCNUM mosaic = mccAn3_mosaic;
MCNUM dspread = mccAn3_dspread;
MCNUM Q = mccAn3_Q;
MCNUM DM = mccAn3_DM;
MCNUM radius = mccAn3_radius;
MCNUM f_doppler = mccAn3_f_doppler;
MCNUM A_doppler = mccAn3_A_doppler;
MCNUM R0 = mccAn3_R0;
MCNUM debug = mccAn3_debug;
#line 177 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../contrib/Spherical_Backscattering_Analyser.comp"
{

  /*  dashed_line(xmin,ymin,0,xmin,ymax,0,5);
  dashed_line(xmin,ymax,0,xmax,ymax,0,5);
  dashed_line(xmax,ymax,0,xmax,ymin,0,5);
  dashed_line(xmax,ymin,0,xmin,ymin,0,5);*/

/* Step across the sphere in 11x11 steps to show the analyzer geometry */
  int i,j,N;
  double yv1,yv2,zv1,zv2;
  double xh1,xh2,zh1,zh2;
  double xd1,xd2,yd1,yd2,xd3,xd4,yd3,yd4,zd1,zd2,zd3,zd4;
  double dx,dy,dd;
  N=11;
  dx = (xmax-xmin)/(N-1);
  dy = (ymax-ymin)/(N-1);
  /* Horizontal, vertical, diagonal lines... */
  xh1=xmin;
  yv1=ymin;
  xd1=xmin;
  yd1=ymin;
  xd3=xmin;
  yd3=ymax;
  for (i=0; i<N-1; i++) {
    /* Calculate z-coordinates of 1st line-point(s)*/
    zh1=z_sphere(xh1,ymin,radius);
    zv1=z_sphere(xmin,yv1,radius);
    zd1=z_sphere(xd1,yd1,radius);
    zd3=z_sphere(xd3,yd3,radius);
    /* 2nd point x-y values */
    xh2=xh1+dx;
    yv2=yv1+dy;

    xd2=xd1+dx;
    yd2=yd1+dy;

    xd4=xd3+dx;
    yd4=yd3-dy;
    /* Calculate z-coordinates of 2nd set of line-point(s)*/
    zh2=z_sphere(xh1,ymin,radius);
    zv2=z_sphere(xmin,yv2,radius);
    zd2=z_sphere(xd2,yd2,radius);
    zd4=z_sphere(xd4,yd4,radius);
    /* Horizontal: */
    line(xh1,ymin,zh1,xh2,ymin,zh2);
    line(xh1,ymax,zh1,xh2,ymax,zh2);
    /* Vertical: */
    line(xmin,yv1,zv1,xmin,yv2,zv2);
    line(xmax,yv1,zv1,xmax,yv2,zv2);
    /* Diagonal: */
    line(xd1,yd1,zd1,xd2,yd2,zd2);
    line(xd3,yd3,zd3,xd4,yd4,zd4);
    /* Shift to next set of points ... */
    xh1=xh2; yv1=yv2; xd1=xd2; yd1=yd2; xd3=xd4; yd3=yd4;
  }
  
}
#line 89572 "./SNS_BASIS.c"
}   /* End of An3=Spherical_Backscattering_Analyser() SETTING parameter declarations. */
#undef mono_Q
#undef mos_rms
#undef d_rms
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'ArmForDet1'. */
  SIG_MESSAGE("ArmForDet1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "ArmForDet1");
#define mccompcurname  ArmForDet1
#define mccompcurtype  Arm
#define mccompcurindex 136
#line 40 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 89595 "./SNS_BASIS.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Det1_E'. */
  SIG_MESSAGE("Det1_E (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Det1_E");
#define mccompcurname  Det1_E
#define mccompcurtype  E_monitor
#define mccompcurindex 137
#define nE mccDet1_E_nE
#define E_N mccDet1_E_E_N
#define E_p mccDet1_E_E_p
#define E_p2 mccDet1_E_E_p2
#define S_p mccDet1_E_S_p
#define S_pE mccDet1_E_S_pE
#define S_pE2 mccDet1_E_S_pE2
{   /* Declarations of Det1_E=E_monitor() SETTING parameters. */
char* filename = mccDet1_E_filename;
MCNUM xmin = mccDet1_E_xmin;
MCNUM xmax = mccDet1_E_xmax;
MCNUM ymin = mccDet1_E_ymin;
MCNUM ymax = mccDet1_E_ymax;
MCNUM xwidth = mccDet1_E_xwidth;
MCNUM yheight = mccDet1_E_yheight;
MCNUM Emin = mccDet1_E_Emin;
MCNUM Emax = mccDet1_E_Emax;
MCNUM restore_neutron = mccDet1_E_restore_neutron;
int nowritefile = mccDet1_E_nowritefile;
#line 132 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 89634 "./SNS_BASIS.c"
}   /* End of Det1_E=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Det1_E_variable_range'. */
  SIG_MESSAGE("Det1_E_variable_range (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Det1_E_variable_range");
#define mccompcurname  Det1_E_variable_range
#define mccompcurtype  E_monitor
#define mccompcurindex 138
#define nE mccDet1_E_variable_range_nE
#define E_N mccDet1_E_variable_range_E_N
#define E_p mccDet1_E_variable_range_E_p
#define E_p2 mccDet1_E_variable_range_E_p2
#define S_p mccDet1_E_variable_range_S_p
#define S_pE mccDet1_E_variable_range_S_pE
#define S_pE2 mccDet1_E_variable_range_S_pE2
{   /* Declarations of Det1_E_variable_range=E_monitor() SETTING parameters. */
char* filename = mccDet1_E_variable_range_filename;
MCNUM xmin = mccDet1_E_variable_range_xmin;
MCNUM xmax = mccDet1_E_variable_range_xmax;
MCNUM ymin = mccDet1_E_variable_range_ymin;
MCNUM ymax = mccDet1_E_variable_range_ymax;
MCNUM xwidth = mccDet1_E_variable_range_xwidth;
MCNUM yheight = mccDet1_E_variable_range_yheight;
MCNUM Emin = mccDet1_E_variable_range_Emin;
MCNUM Emax = mccDet1_E_variable_range_Emax;
MCNUM restore_neutron = mccDet1_E_variable_range_restore_neutron;
int nowritefile = mccDet1_E_variable_range_nowritefile;
#line 132 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/E_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 89681 "./SNS_BASIS.c"
}   /* End of Det1_E_variable_range=E_monitor() SETTING parameter declarations. */
#undef S_pE2
#undef S_pE
#undef S_p
#undef E_p2
#undef E_p
#undef E_N
#undef nE
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Det1_Lam'. */
  SIG_MESSAGE("Det1_Lam (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Det1_Lam");
#define mccompcurname  Det1_Lam
#define mccompcurtype  L_monitor
#define mccompcurindex 139
#define nL mccDet1_Lam_nL
#define L_N mccDet1_Lam_L_N
#define L_p mccDet1_Lam_L_p
#define L_p2 mccDet1_Lam_L_p2
{   /* Declarations of Det1_Lam=L_monitor() SETTING parameters. */
char* filename = mccDet1_Lam_filename;
MCNUM xmin = mccDet1_Lam_xmin;
MCNUM xmax = mccDet1_Lam_xmax;
MCNUM ymin = mccDet1_Lam_ymin;
MCNUM ymax = mccDet1_Lam_ymax;
MCNUM xwidth = mccDet1_Lam_xwidth;
MCNUM yheight = mccDet1_Lam_yheight;
MCNUM Lmin = mccDet1_Lam_Lmin;
MCNUM Lmax = mccDet1_Lam_Lmax;
MCNUM restore_neutron = mccDet1_Lam_restore_neutron;
int nowritefile = mccDet1_Lam_nowritefile;
#line 120 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 89725 "./SNS_BASIS.c"
}   /* End of Det1_Lam=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Det1_Lam_variable_range'. */
  SIG_MESSAGE("Det1_Lam_variable_range (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Det1_Lam_variable_range");
#define mccompcurname  Det1_Lam_variable_range
#define mccompcurtype  L_monitor
#define mccompcurindex 140
#define nL mccDet1_Lam_variable_range_nL
#define L_N mccDet1_Lam_variable_range_L_N
#define L_p mccDet1_Lam_variable_range_L_p
#define L_p2 mccDet1_Lam_variable_range_L_p2
{   /* Declarations of Det1_Lam_variable_range=L_monitor() SETTING parameters. */
char* filename = mccDet1_Lam_variable_range_filename;
MCNUM xmin = mccDet1_Lam_variable_range_xmin;
MCNUM xmax = mccDet1_Lam_variable_range_xmax;
MCNUM ymin = mccDet1_Lam_variable_range_ymin;
MCNUM ymax = mccDet1_Lam_variable_range_ymax;
MCNUM xwidth = mccDet1_Lam_variable_range_xwidth;
MCNUM yheight = mccDet1_Lam_variable_range_yheight;
MCNUM Lmin = mccDet1_Lam_variable_range_Lmin;
MCNUM Lmax = mccDet1_Lam_variable_range_Lmax;
MCNUM restore_neutron = mccDet1_Lam_variable_range_restore_neutron;
int nowritefile = mccDet1_Lam_variable_range_nowritefile;
#line 120 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/L_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 89766 "./SNS_BASIS.c"
}   /* End of Det1_Lam_variable_range=L_monitor() SETTING parameter declarations. */
#undef L_p2
#undef L_p
#undef L_N
#undef nL
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Det1_ToF'. */
  SIG_MESSAGE("Det1_ToF (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Det1_ToF");
#define mccompcurname  Det1_ToF
#define mccompcurtype  TOF_monitor
#define mccompcurindex 141
#define nt mccDet1_ToF_nt
#define TOF_N mccDet1_ToF_TOF_N
#define TOF_p mccDet1_ToF_TOF_p
#define TOF_p2 mccDet1_ToF_TOF_p2
#define t_min mccDet1_ToF_t_min
#define t_max mccDet1_ToF_t_max
#define delta_t mccDet1_ToF_delta_t
{   /* Declarations of Det1_ToF=TOF_monitor() SETTING parameters. */
char* filename = mccDet1_ToF_filename;
MCNUM xmin = mccDet1_ToF_xmin;
MCNUM xmax = mccDet1_ToF_xmax;
MCNUM ymin = mccDet1_ToF_ymin;
MCNUM ymax = mccDet1_ToF_ymax;
MCNUM xwidth = mccDet1_ToF_xwidth;
MCNUM yheight = mccDet1_ToF_yheight;
MCNUM tmin = mccDet1_ToF_tmin;
MCNUM tmax = mccDet1_ToF_tmax;
MCNUM dt = mccDet1_ToF_dt;
MCNUM restore_neutron = mccDet1_ToF_restore_neutron;
int nowritefile = mccDet1_ToF_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 89811 "./SNS_BASIS.c"
}   /* End of Det1_ToF=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Det1_ToF_variable_range'. */
  SIG_MESSAGE("Det1_ToF_variable_range (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Det1_ToF_variable_range");
#define mccompcurname  Det1_ToF_variable_range
#define mccompcurtype  TOF_monitor
#define mccompcurindex 142
#define nt mccDet1_ToF_variable_range_nt
#define TOF_N mccDet1_ToF_variable_range_TOF_N
#define TOF_p mccDet1_ToF_variable_range_TOF_p
#define TOF_p2 mccDet1_ToF_variable_range_TOF_p2
#define t_min mccDet1_ToF_variable_range_t_min
#define t_max mccDet1_ToF_variable_range_t_max
#define delta_t mccDet1_ToF_variable_range_delta_t
{   /* Declarations of Det1_ToF_variable_range=TOF_monitor() SETTING parameters. */
char* filename = mccDet1_ToF_variable_range_filename;
MCNUM xmin = mccDet1_ToF_variable_range_xmin;
MCNUM xmax = mccDet1_ToF_variable_range_xmax;
MCNUM ymin = mccDet1_ToF_variable_range_ymin;
MCNUM ymax = mccDet1_ToF_variable_range_ymax;
MCNUM xwidth = mccDet1_ToF_variable_range_xwidth;
MCNUM yheight = mccDet1_ToF_variable_range_yheight;
MCNUM tmin = mccDet1_ToF_variable_range_tmin;
MCNUM tmax = mccDet1_ToF_variable_range_tmax;
MCNUM dt = mccDet1_ToF_variable_range_dt;
MCNUM restore_neutron = mccDet1_ToF_variable_range_restore_neutron;
int nowritefile = mccDet1_ToF_variable_range_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 89859 "./SNS_BASIS.c"
}   /* End of Det1_ToF_variable_range=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Det1_ToF_variable_range_lessnL'. */
  SIG_MESSAGE("Det1_ToF_variable_range_lessnL (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Det1_ToF_variable_range_lessnL");
#define mccompcurname  Det1_ToF_variable_range_lessnL
#define mccompcurtype  TOF_monitor
#define mccompcurindex 143
#define nt mccDet1_ToF_variable_range_lessnL_nt
#define TOF_N mccDet1_ToF_variable_range_lessnL_TOF_N
#define TOF_p mccDet1_ToF_variable_range_lessnL_TOF_p
#define TOF_p2 mccDet1_ToF_variable_range_lessnL_TOF_p2
#define t_min mccDet1_ToF_variable_range_lessnL_t_min
#define t_max mccDet1_ToF_variable_range_lessnL_t_max
#define delta_t mccDet1_ToF_variable_range_lessnL_delta_t
{   /* Declarations of Det1_ToF_variable_range_lessnL=TOF_monitor() SETTING parameters. */
char* filename = mccDet1_ToF_variable_range_lessnL_filename;
MCNUM xmin = mccDet1_ToF_variable_range_lessnL_xmin;
MCNUM xmax = mccDet1_ToF_variable_range_lessnL_xmax;
MCNUM ymin = mccDet1_ToF_variable_range_lessnL_ymin;
MCNUM ymax = mccDet1_ToF_variable_range_lessnL_ymax;
MCNUM xwidth = mccDet1_ToF_variable_range_lessnL_xwidth;
MCNUM yheight = mccDet1_ToF_variable_range_lessnL_yheight;
MCNUM tmin = mccDet1_ToF_variable_range_lessnL_tmin;
MCNUM tmax = mccDet1_ToF_variable_range_lessnL_tmax;
MCNUM dt = mccDet1_ToF_variable_range_lessnL_dt;
MCNUM restore_neutron = mccDet1_ToF_variable_range_lessnL_restore_neutron;
int nowritefile = mccDet1_ToF_variable_range_lessnL_nowritefile;
#line 128 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/TOF_monitor.comp"
{
  
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
}
#line 89907 "./SNS_BASIS.c"
}   /* End of Det1_ToF_variable_range_lessnL=TOF_monitor() SETTING parameter declarations. */
#undef delta_t
#undef t_max
#undef t_min
#undef TOF_p2
#undef TOF_p
#undef TOF_N
#undef nt
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PSDcyl'. */
  SIG_MESSAGE("PSDcyl (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PSDcyl");
#define mccompcurname  PSDcyl
#define mccompcurtype  Monitor_nD
#define mccompcurindex 144
#define user1 mccPSDcyl_user1
#define user2 mccPSDcyl_user2
#define user3 mccPSDcyl_user3
#define DEFS mccPSDcyl_DEFS
#define Vars mccPSDcyl_Vars
#define detector mccPSDcyl_detector
#define offdata mccPSDcyl_offdata
{   /* Declarations of PSDcyl=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccPSDcyl_xwidth;
MCNUM yheight = mccPSDcyl_yheight;
MCNUM zdepth = mccPSDcyl_zdepth;
MCNUM xmin = mccPSDcyl_xmin;
MCNUM xmax = mccPSDcyl_xmax;
MCNUM ymin = mccPSDcyl_ymin;
MCNUM ymax = mccPSDcyl_ymax;
MCNUM zmin = mccPSDcyl_zmin;
MCNUM zmax = mccPSDcyl_zmax;
MCNUM bins = mccPSDcyl_bins;
MCNUM min = mccPSDcyl_min;
MCNUM max = mccPSDcyl_max;
MCNUM restore_neutron = mccPSDcyl_restore_neutron;
MCNUM radius = mccPSDcyl_radius;
char* options = mccPSDcyl_options;
char* filename = mccPSDcyl_filename;
char* geometry = mccPSDcyl_geometry;
char* username1 = mccPSDcyl_username1;
char* username2 = mccPSDcyl_username2;
char* username3 = mccPSDcyl_username3;
int nowritefile = mccPSDcyl_nowritefile;
#line 495 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    off_display(offdata);
  } else {
    Monitor_nD_McDisplay(&DEFS, &Vars);
  }
}
#line 89964 "./SNS_BASIS.c"
}   /* End of PSDcyl=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'TOFcyl'. */
  SIG_MESSAGE("TOFcyl (McDisplay)");
  printf("MCDISPLAY: component %s\n", "TOFcyl");
#define mccompcurname  TOFcyl
#define mccompcurtype  Monitor_nD
#define mccompcurindex 145
#define user1 mccTOFcyl_user1
#define user2 mccTOFcyl_user2
#define user3 mccTOFcyl_user3
#define DEFS mccTOFcyl_DEFS
#define Vars mccTOFcyl_Vars
#define detector mccTOFcyl_detector
#define offdata mccTOFcyl_offdata
{   /* Declarations of TOFcyl=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccTOFcyl_xwidth;
MCNUM yheight = mccTOFcyl_yheight;
MCNUM zdepth = mccTOFcyl_zdepth;
MCNUM xmin = mccTOFcyl_xmin;
MCNUM xmax = mccTOFcyl_xmax;
MCNUM ymin = mccTOFcyl_ymin;
MCNUM ymax = mccTOFcyl_ymax;
MCNUM zmin = mccTOFcyl_zmin;
MCNUM zmax = mccTOFcyl_zmax;
MCNUM bins = mccTOFcyl_bins;
MCNUM min = mccTOFcyl_min;
MCNUM max = mccTOFcyl_max;
MCNUM restore_neutron = mccTOFcyl_restore_neutron;
MCNUM radius = mccTOFcyl_radius;
char* options = mccTOFcyl_options;
char* filename = mccTOFcyl_filename;
char* geometry = mccTOFcyl_geometry;
char* username1 = mccTOFcyl_username1;
char* username2 = mccTOFcyl_username2;
char* username3 = mccTOFcyl_username3;
int nowritefile = mccTOFcyl_nowritefile;
#line 495 "/zhome/89/0/38697/McStas/mcstas/2.5/tools/Python/mcrun/../mccodelib/../../../monitors/Monitor_nD.comp"
{
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    off_display(offdata);
  } else {
    Monitor_nD_McDisplay(&DEFS, &Vars);
  }
}
#line 90021 "./SNS_BASIS.c"
}   /* End of TOFcyl=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  printf("MCDISPLAY: end\n");
} /* end display */
#undef magnify
#undef line
#undef dashed_line
#undef multiline
#undef rectangle
#undef box
#undef circle
#undef cylinder
#undef sphere
/* end of generated C code ./SNS_BASIS.c */
