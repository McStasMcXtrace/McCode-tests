/* Automatically generated file. Do not edit. 
 * Format:     ANSI C source code
 * Creator:    McStas <http://www.mcstas.org>
 * Instrument: ILL_H15_D11.instr (ILL_H15_D11)
 * Date:       Sat Oct 12 09:42:26 2019
 * File:       ILL_H15_D11.c
 * Compile:    cc -o ILL_H15_D11.out ILL_H15_D11.c 
 * CFLAGS=
 */


#define MCCODE_STRING "McStas 2.6rc1 - Oct. 12, 2019"
#define FLAVOR "mcstas"
#define FLAVOR_UPPER "MCSTAS"
#define MC_USE_DEFAULT_MAIN
#define MC_TRACE_ENABLED
#define MC_EMBEDDED_RUNTIME

#line 1 "mccode-r.h"
/*******************************************************************************
*
* McCode, neutron/xray ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mccode-r.h
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McStas 2.6rc1
* Version: $Revision$
*
* Runtime system header for McStas/McXtrace.
*
* In order to use this library as an external library, the following variables
* and macros must be declared (see details in the code)
*
*   struct mcinputtable_struct mcinputtable[];
*   int mcnumipar;
*   char mcinstrument_name[], mcinstrument_source[];
*   int mctraceenabled, mcdefaultmain;
*   extern MCNUM  mccomp_storein[];
*   extern MCNUM  mcAbsorbProp[];
*   extern MCNUM  mcScattered;
*   #define MCCODE_STRING "the McStas/McXtrace version"
*
* Usage: Automatically embbeded in the c code.
*
* $Id$
*
*******************************************************************************/

#ifndef MCCODE_R_H
#define MCCODE_R_H "$Revision$"

#include <math.h>
#include <string.h>
#include <strings.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <limits.h>
#include <errno.h>
#include <time.h>
#include <float.h>
#include <inttypes.h>

/* If the runtime is embedded in the simulation program, some definitions can
   be made static. */

#ifdef MC_EMBEDDED_RUNTIME
#define mcstatic static
#else
#define mcstatic
#endif

#ifdef __dest_os
#if (__dest_os == __mac_os)
#define MAC
#endif
#endif

#ifdef __FreeBSD__
#define NEED_STAT_H
#endif

#if defined(__APPLE__) && defined(__GNUC__)
#define NEED_STAT_H
#endif

#ifdef NEED_STAT_H
#include <sys/stat.h>
#endif

#ifndef MC_PATHSEP_C
#ifdef WIN32
#define MC_PATHSEP_C '\\'
#define MC_PATHSEP_S "\\"
#else  /* !WIN32 */
#define MC_PATHSEP_C '/'
#define MC_PATHSEP_S "/"
#endif /* !WIN32 */
#endif /* MC_PATHSEP_C */

#ifndef WIN32
#ifndef _POSIX_SOURCE
#define _POSIX_SOURCE 1
#endif
#endif

/* the version string is replaced when building distribution with mkdist */
#ifndef MCCODE_STRING
#define MCCODE_STRING "McStas 2.6rc1 - Oct. 12, 2019"
#endif

#ifndef MCCODE_DATE
#define MCCODE_DATE "Oct. 12, 2019"
#endif

#ifndef MCCODE_VERSION
#define MCCODE_VERSION "2.6rc1"
#endif

#ifndef MCCODE_NAME
#define MCCODE_NAME "McStas"
#endif

#ifndef MCCODE_PARTICLE
#define MCCODE_PARTICLE "neutron"
#endif

#ifndef MCCODE_LIBENV
#define MCCODE_LIBENV "MCSTAS"
#endif

#ifndef FLAVOR_UPPER
#define FLAVOR_UPPER MCCODE_NAME
#endif

#ifdef MC_PORTABLE
#ifndef NOSIGNALS
#define NOSIGNALS 1
#endif
#endif

#ifdef MAC
#ifndef NOSIGNALS
#define NOSIGNALS 1
#endif
#endif

#if (USE_MPI == 0)
#undef USE_MPI
#endif

#ifdef USE_MPI  /* default is to disable signals with MPI, as MPICH uses them to communicate */
#ifndef NOSIGNALS
#define NOSIGNALS 1
#endif
#endif

#if (NOSIGNALS == 0)
#undef NOSIGNALS
#endif

/* Note: the enum instr_formal_types definition MUST be kept
   synchronized with the one in mccode.h and with the
   instr_formal_type_names array in cogen.c. */
enum instr_formal_types
  {
    instr_type_double, instr_type_int, instr_type_string
  };
struct mcinputtable_struct { /* defines instrument parameters */
  char *name; /* name of parameter */
  void *par;  /* pointer to instrument parameter (variable) */
  enum instr_formal_types type;
  char *val;  /* default value */
};

typedef double MCNUM;
typedef struct {MCNUM x, y, z;} Coords;
typedef MCNUM Rotation[3][3];

/* the following variables are defined in the McStas generated C code
   but should be defined externally in case of independent library usage */
#ifndef DANSE
extern struct mcinputtable_struct mcinputtable[]; /* list of instrument parameters */
extern int    mcnumipar;                          /* number of instrument parameters */
extern char   mcinstrument_name[], mcinstrument_source[]; /* instrument name and filename */
extern char  *mcinstrument_exe;                           /* executable path = argv[0] or NULL */
extern MCNUM  mccomp_storein[]; /* 11 coords * number of components in instrument */
extern MCNUM  mcAbsorbProp[];
extern MCNUM  mcScattered;      /* number of SCATTER calls in current component */
extern MCNUM  mcRestore;        /* Flag to indicate if neutron needs to be restored */
#ifndef MC_ANCIENT_COMPATIBILITY
extern int mctraceenabled, mcdefaultmain;
#endif
#endif


/* Useful macros ============================================================ */

/* MPI stuff */

#ifdef USE_MPI
#include "mpi.h"

#ifdef OMPI_MPI_H  /* openmpi does not use signals: we may install our sighandler */
#undef NOSIGNALS
#endif

/*
 * MPI_MASTER(i):
 * execution of i only on master node
 */
#define MPI_MASTER(statement) { \
  if(mpi_node_rank == mpi_node_root)\
  { statement; } \
}

#ifndef MPI_REDUCE_BLOCKSIZE
#define MPI_REDUCE_BLOCKSIZE 1000
#endif

int mc_MPI_Sum(double* buf, long count);
int mc_MPI_Send(void *sbuf, long count, MPI_Datatype dtype, int dest);
int mc_MPI_Recv(void *rbuf, long count, MPI_Datatype dtype, int source);

/* MPI_Finalize exits gracefully and should be preferred to MPI_Abort */
#define exit(code) do {                                   \
    MPI_Finalize();                                       \
    exit(code);                                           \
  } while(0)

#else /* !USE_MPI */
#define MPI_MASTER(instr) instr
#endif /* USE_MPI */

#ifdef USE_MPI
static int mpi_node_count;
#endif

#ifdef USE_THREADS  /* user want threads */
#error Threading (USE_THREADS) support has been removed for very poor efficiency. Use MPI/SSH grid instead.
#endif


void   mcset_ncount(unsigned long long count);    /* wrapper to get mcncount */
unsigned long long int mcget_ncount(void);            /* wrapper to set mcncount */
unsigned long long mcget_run_num(void);           /* wrapper to get mcrun_num=0:mcncount */


/* Following part is only embedded when not redundant with mccode.h ========= */

#ifndef MCCODE_H

#ifndef NOSIGNALS
#include <signal.h>
#define SIG_MESSAGE(msg) strcpy(mcsig_message, msg);
#else
#define SIG_MESSAGE(msg)
#endif /* !NOSIGNALS */

/* Useful macros and constants ============================================== */

#ifndef FLT_MAX
#define FLT_MAX         3.40282347E+38F /* max decimal value of a "float" */
#endif

#ifndef MIN
#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
#endif
#ifndef SQR
#define SQR(x) ( (x) * (x) )
#endif
#ifndef SIGN
#define SIGN(x) (((x)>0.0)?(1):(-1))
#endif

#ifndef PI
# ifdef M_PI
#  define PI M_PI
# else
/* When using c99 in the CFLAGS, some of these consts
   are lost... Perhaps we should in fact include everything from
   https://www.gnu.org/software/libc/manual/html_node/Mathematical-Constants.html
*/
#  define PI 3.14159265358979323846
#  define M_PI PI
#  define M_PI_2 M_PI/2.0
#  define M_PI_4 M_PI/4.0
#  define M_1_PI 1.0/M_PI
#  define M_2_PI 2*M_1_PI
#  define M_2_SQRTPI 2/sqrt(M_PI)
#  define M_SQRT2 sqrt(2)
#  define M_SQRT1_2 sqrt(1/2)
# endif
#endif

#define RAD2MIN  ((180*60)/PI)
#define MIN2RAD  (PI/(180*60))
#define DEG2RAD  (PI/180)
#define RAD2DEG  (180/PI)
#define FWHM2RMS 0.424660900144    /* Convert between full-width-half-max and */
#define RMS2FWHM 2.35482004503     /* root-mean-square (standard deviation) */
#define HBAR     1.05457168e-34    /* [Js] h bar Planck constant CODATA 2002 */
#define MNEUTRON 1.67492728e-27    /* [kg] mass of neutron CODATA 2002 */
#define GRAVITY  9.81              /* [m/s^2] gravitational acceleration */
#define NA       6.02214179e23     /* [#atoms/g .mole] Avogadro's number*/


/* wrapper to get absolute and relative position of comp */
/* mccomp_posa and mccomp_posr are defined in McStas generated C code */
#define POS_A_COMP_INDEX(index) \
    (mccomp_posa[index])
#define POS_R_COMP_INDEX(index) \
    (mccomp_posr[index])
/* number of SCATTER calls in current comp: mcScattered defined in generated C code */
#define SCATTERED mcScattered
/* Flag to indicate if neutron needs to be restored: mcRestore defined in generated C code */
#define RESTORE mcRestore


/* Retrieve component information from the kernel */
/* Name, position and orientation (both absolute and relative)  */
/* Any component: For "redundancy", see comment by KN */
#define tmp_name_comp(comp) #comp
#define NAME_COMP(comp) tmp_name_comp(comp)
#define tmp_pos_a_comp(comp) (mcposa ## comp)
#define POS_A_COMP(comp) tmp_pos_a_comp(comp)
#define tmp_pos_r_comp(comp) (mcposr ## comp)
#define POS_R_COMP(comp) tmp_pos_r_comp(comp)
#define tmp_rot_a_comp(comp) (mcrota ## comp)
#define ROT_A_COMP(comp) tmp_rot_a_comp(comp)
#define tmp_rot_r_comp(comp) (mcrotr ## comp)
#define ROT_R_COMP(comp) tmp_rot_r_comp(comp)

/* Current component name, index, position and orientation */
#define NAME_CURRENT_COMP  NAME_COMP(mccompcurname)
#define INDEX_CURRENT_COMP mccompcurindex
#define POS_A_CURRENT_COMP POS_A_COMP(mccompcurname)
#define POS_R_CURRENT_COMP POS_R_COMP(mccompcurname)
#define ROT_A_CURRENT_COMP ROT_A_COMP(mccompcurname)
#define ROT_R_CURRENT_COMP ROT_R_COMP(mccompcurname)

/* Note: The two-stage approach to MC_GETPAR is NOT redundant; without it,
* after #define C sample, MC_GETPAR(C,x) would refer to component C, not to
* component sample. Such are the joys of ANSI C.

* Anyway the usage of MCGETPAR requires that we use sometimes bare names...
*/
#define MC_GETPAR2(comp, par) (mcc ## comp ## _ ## par)
#define MC_GETPAR(comp, par) MC_GETPAR2(comp,par)

/* MCDISPLAY/trace and debugging message sent to stdout */
#ifdef MC_TRACE_ENABLED
#define DEBUG
#endif

#ifdef DEBUG
#define mcDEBUG_INSTR() if(!mcdotrace); else { printf("\nINSTRUMENT:\n"); printf("Instrument '%s' (%s)\n", mcinstrument_name, mcinstrument_source); }
#define mcDEBUG_COMPONENT(name,c,t) if(!mcdotrace); else {\
  printf("COMPONENT: \"%s\"\n" \
         "POS: %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", \
         name, c.x, c.y, c.z, t[0][0], t[0][1], t[0][2], \
         t[1][0], t[1][1], t[1][2], t[2][0], t[2][1], t[2][2]); \
  mcAccumulatedILength += coords_len(coords_sub(mcLastComp,c)); \
  printf("Component %30s AT (%g,%g,%g)    %g m from origin\n", name, c.x, c.y, c.z, mcAccumulatedILength); \
  mcLastComp=c;\
  }
#define mcDEBUG_INSTR_END() if(!mcdotrace); else printf("INSTRUMENT END:\n");
#define mcDEBUG_ENTER() if(!mcdotrace); else printf("ENTER:\n");
#define mcDEBUG_COMP(c) if(!mcdotrace); else printf("COMP: \"%s\"\n", c);
#define mcDEBUG_LEAVE() if(!mcdotrace); else printf("LEAVE:\n");
#define mcDEBUG_ABSORB() if(!mcdotrace); else printf("ABSORB:\n");
#else
#define mcDEBUG_INSTR()
#define mcDEBUG_COMPONENT(name,c,t)
#define mcDEBUG_INSTR_END()
#define mcDEBUG_ENTER()
#define mcDEBUG_COMP(c)
#define mcDEBUG_LEAVE()
#define mcDEBUG_ABSORB()
#endif

// mcDEBUG_STATE and mcDEBUG_SCATTER are defined by mcstas-r.h and mcxtrace-r.h



#ifdef TEST
#define test_printf printf
#else
#define test_printf while(0) printf
#endif

/* send MCDISPLAY message to stdout to show gemoetry */
void mcdis_magnify(char *what);
void mcdis_line(double x1, double y1, double z1,
                double x2, double y2, double z2);
void mcdis_dashed_linemcdis_dashed_line(double x1, double y1, double z1,
		       double x2, double y2, double z2, int n);
void mcdis_multiline(int count, ...);
void mcdis_rectangle(char* plane, double x, double y, double z,
		     double width, double height);
void mcdis_box(double x, double y, double z,
	       double width, double height, double length);
void mcdis_circle(char *plane, double x, double y, double z, double r);
void mcdis_Circle(double x, double y, double z, double r, double nx, double ny, double nz);
void mcdis_cylinder( double x, double y, double z,
        double r, double height, int N, double nx, double ny, double nz);
void mcdis_sphere(double x, double y, double z, double r, int N);

/* selection of random number generator. default is MT */
#ifndef MC_RAND_ALG
#define MC_RAND_ALG 1
#endif

#if MC_RAND_ALG == 0
   /* Use system random() (not recommended). */
#  define MC_RAND_MAX RAND_MAX
#elif MC_RAND_ALG == 1
   /* "Mersenne Twister", by Makoto Matsumoto and Takuji Nishimura. */
#  define MC_RAND_MAX ((unsigned long)0xffffffff)
#  define random mt_random
#  define srandom mt_srandom
#elif MC_RAND_ALG == 2
   /* Algorithm used in McStas CVS-080208 and earlier (not recommended). */
#  define MC_RAND_MAX 0x7fffffff
#  define random mc_random
#  define srandom mc_srandom
#else
#  error "Bad value for random number generator choice."
#endif

typedef int mc_int32_t;
mc_int32_t mc_random(void);
void mc_srandom (unsigned int x);
unsigned long mt_random(void);
void mt_srandom (unsigned long x);

double rand01();
double randpm1();
double rand0max(double max);
double randminmax(double min, double max);

double randnorm(void);
double randtriangle(void);

#ifndef DANSE
void mcinit(void);
void mcraytrace(void);
void mcsave(FILE *);
void mcfinally(void);
void mcdisplay(void);
#endif

/* simple vector algebra ==================================================== */
#define vec_prod(x, y, z, x1, y1, z1, x2, y2, z2) \
	vec_prod_func(&x, &y, &z, x1, y1, z1, x2, y2, z2)
mcstatic void vec_prod_func(double *x, double *y, double *z,
		double x1, double y1, double z1, double x2, double y2, double z2);

mcstatic double scalar_prod(
		double x1, double y1, double z1, double x2, double y2, double z2);

#define NORM(x,y,z) \
	norm_func(&x, &y, &z)
mcstatic void norm_func(double *x, double *y, double *z) {
	double temp = (*x * *x) + (*y * *y) + (*z * *z);
	if (temp != 0) {
		temp = sqrt(temp);
		*x /= temp;
		*y /= temp;
		*z /= temp;
	}
}
#define normal_vec(nx, ny, nz, x, y, z) \
    normal_vec_func(&(nx), &(ny), &(nz), x, y, z)
mcstatic void normal_vec_func(double *nx, double *ny, double *nz,
    double x, double y, double z);

/**
 * Rotate the vector vx,vy,vz psi radians around the vector ax,ay,az
 * and put the result in x,y,z.
 */
#define rotate(x, y, z, vx, vy, vz, phi, ax, ay, az) \
  do { \
    double mcrt_tmpx = (ax), mcrt_tmpy = (ay), mcrt_tmpz = (az); \
    double mcrt_vp, mcrt_vpx, mcrt_vpy, mcrt_vpz; \
    double mcrt_vnx, mcrt_vny, mcrt_vnz, mcrt_vn1x, mcrt_vn1y, mcrt_vn1z; \
    double mcrt_bx, mcrt_by, mcrt_bz; \
    double mcrt_cos, mcrt_sin; \
    NORM(mcrt_tmpx, mcrt_tmpy, mcrt_tmpz); \
    mcrt_vp = scalar_prod((vx), (vy), (vz), mcrt_tmpx, mcrt_tmpy, mcrt_tmpz); \
    mcrt_vpx = mcrt_vp*mcrt_tmpx; \
    mcrt_vpy = mcrt_vp*mcrt_tmpy; \
    mcrt_vpz = mcrt_vp*mcrt_tmpz; \
    mcrt_vnx = (vx) - mcrt_vpx; \
    mcrt_vny = (vy) - mcrt_vpy; \
    mcrt_vnz = (vz) - mcrt_vpz; \
    vec_prod(mcrt_bx, mcrt_by, mcrt_bz, \
             mcrt_tmpx, mcrt_tmpy, mcrt_tmpz, mcrt_vnx, mcrt_vny, mcrt_vnz); \
    mcrt_cos = cos((phi)); mcrt_sin = sin((phi)); \
    mcrt_vn1x = mcrt_vnx*mcrt_cos + mcrt_bx*mcrt_sin; \
    mcrt_vn1y = mcrt_vny*mcrt_cos + mcrt_by*mcrt_sin; \
    mcrt_vn1z = mcrt_vnz*mcrt_cos + mcrt_bz*mcrt_sin; \
    (x) = mcrt_vpx + mcrt_vn1x; \
    (y) = mcrt_vpy + mcrt_vn1y; \
    (z) = mcrt_vpz + mcrt_vn1z; \
  } while(0)

/**
 * Mirror (xyz) in the plane given by the point (rx,ry,rz) and normal (nx,ny,nz)
 *
 * TODO: This define is seemingly never used...
 */
#define mirror(x,y,z,rx,ry,rz,nx,ny,nz) \
  do { \
    double mcrt_tmpx= (nx), mcrt_tmpy = (ny), mcrt_tmpz = (nz); \
    double mcrt_tmpt; \
    NORM(mcrt_tmpx, mcrt_tmpy, mcrt_tmpz); \
    mcrt_tmpt=scalar_prod((rx),(ry),(rz),mcrt_tmpx,mcrt_tmpy,mcrt_tmpz); \
    (x) = rx -2 * mcrt_tmpt*mcrt_rmpx; \
    (y) = ry -2 * mcrt_tmpt*mcrt_rmpy; \
    (z) = rz -2 * mcrt_tmpt*mcrt_rmpz; \
  } while (0)

Coords coords_set(MCNUM x, MCNUM y, MCNUM z);
Coords coords_get(Coords a, MCNUM *x, MCNUM *y, MCNUM *z);
Coords coords_add(Coords a, Coords b);
Coords coords_sub(Coords a, Coords b);
Coords coords_neg(Coords a);
Coords coords_scale(Coords b, double scale);
double coords_sp(Coords a, Coords b);
Coords coords_xp(Coords b, Coords c);
double coords_len(Coords a);
void   coords_print(Coords a);
mcstatic void coords_norm(Coords* c);

void rot_set_rotation(Rotation t, double phx, double phy, double phz);
int  rot_test_identity(Rotation t);
void rot_mul(Rotation t1, Rotation t2, Rotation t3);
void rot_copy(Rotation dest, Rotation src);
void rot_transpose(Rotation src, Rotation dst);
Coords rot_apply(Rotation t, Coords a);

void mccoordschange(Coords a, Rotation t, double *x, double *y, double *z,
    double *vx, double *vy, double *vz, double *sx, double *sy, double *sz);
void
mccoordschange_polarisation(Rotation t, double *sx, double *sy, double *sz);

double mcestimate_error(double N, double p1, double p2);
void mcreadparams(void);

/* this is now in mcstas-r.h and mcxtrace-r.h as the number of state parameters is no longer equal*/
/* void mcsetstate(double x, double y, double z, double vx, double vy, double vz,
                double t, double sx, double sy, double sz, double p);
*/
void mcgenstate(void);

/* trajectory/shape intersection routines */
int inside_rectangle(double, double, double, double);
int box_intersect(double *dt_in, double *dt_out, double x, double y, double z,
    double vx, double vy, double vz, double dx, double dy, double dz);
int cylinder_intersect(double *t0, double *t1, double x, double y, double z,
    double vx, double vy, double vz, double r, double h);
int sphere_intersect(double *t0, double *t1, double x, double y, double z,
                 double vx, double vy, double vz, double r);
/* second order equation roots */
int solve_2nd_order(double *t1, double *t2,
    double A,  double B,  double C);

/* random vector generation to shape */
void randvec_target_circle(double *xo, double *yo, double *zo,
    double *solid_angle, double xi, double yi, double zi, double radius);
#define randvec_target_sphere randvec_target_circle
void randvec_target_rect_angular(double *xo, double *yo, double *zo,
    double *solid_angle,
               double xi, double yi, double zi, double height, double width, Rotation A);
#define randvec_target_rect(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9)  randvec_target_rect_real(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,0,0,0,1)
void randvec_target_rect_real(double *xo, double *yo, double *zo,
    double *solid_angle,
	       double xi, double yi, double zi, double height, double width, Rotation A,
			 double lx, double ly, double lz, int order);

/* this is the main() */
int mccode_main(int argc, char *argv[]);


#endif /* !MCCODE_H */

#ifndef MCCODE_R_IO_H
#define MCCODE_R_IO_H "$Revision$"

#if (USE_NEXUS == 0)
#undef USE_NEXUS
#endif

#ifndef CHAR_BUF_LENGTH
#define CHAR_BUF_LENGTH 1024
#endif

/* I/O section part ========================================================= */

/* ========================================================================== */

/*                               MCCODE_R_IO_C                                */

/* ========================================================================== */


/* main DETECTOR structure which stores most information to write to data files */
struct mcdetector_struct {
  char   filename[CHAR_BUF_LENGTH];   /* file name of monitor */
  char   position[CHAR_BUF_LENGTH];   /* position of detector component */
  char   component[CHAR_BUF_LENGTH];  /* component instance name */
  char   instrument[CHAR_BUF_LENGTH]; /* instrument name */
  char   type[CHAR_BUF_LENGTH];       /* data type, e.g. 0d, 1d, 2d, 3d */
  char   user[CHAR_BUF_LENGTH];       /* user name, e.g. HOME */
  char   date[CHAR_BUF_LENGTH];       /* date of simulation end/write time */
  char   title[CHAR_BUF_LENGTH];      /* title of detector */
  char   xlabel[CHAR_BUF_LENGTH];     /* X axis label */
  char   ylabel[CHAR_BUF_LENGTH];     /* Y axis label */
  char   zlabel[CHAR_BUF_LENGTH];     /* Z axis label */
  char   xvar[CHAR_BUF_LENGTH];       /* X variable name */
  char   yvar[CHAR_BUF_LENGTH];       /* Y variable name */
  char   zvar[CHAR_BUF_LENGTH];       /* Z variable name */
  char   ncount[CHAR_BUF_LENGTH];     /* number of events initially generated */
  char   limits[CHAR_BUF_LENGTH];     /* X Y Z limits, e.g. [xmin xmax ymin ymax zmin zmax] */
  char   variables[CHAR_BUF_LENGTH];  /* variables written into data block */
  char   statistics[CHAR_BUF_LENGTH]; /* center, mean and half width along axis */
  char   signal[CHAR_BUF_LENGTH];     /* min max and mean of signal (data block) */
  char   values[CHAR_BUF_LENGTH];     /* integrated values e.g. [I I_err N] */
  double xmin,xmax;                   /* min max of axes */
  double ymin,ymax;
  double zmin,zmax;
  double intensity;                   /* integrated values for data block */
  double error;
  double events;
  double min;                         /* statistics for data block */
  double max;
  double mean;
  double centerX;                     /* statistics for axes */
  double halfwidthX;
  double centerY;
  double halfwidthY;
  int    rank;                        /* dimensionaly of monitor, e.g. 0 1 2 3 */
  char   istransposed;                /* flag to transpose matrix for some formats */

  long   m,n,p;                       /* dimensions of data block and along axes */
  long   date_l;                      /* same as date, but in sec since 1970 */

  double *p0, *p1, *p2;               /* pointers to saved data, NULL when freed */
  char   format[CHAR_BUF_LENGTH];    /* format for file generation */
};

typedef struct mcdetector_struct MCDETECTOR;

static   char *mcdirname             = NULL;      /* name of output directory */
static   char *mcsiminfo_name        = "mccode";  /* default output sim file name */
char    *mcformat                    = NULL;      /* NULL (default) or a specific format */

/* file I/O definitions and function prototypes */

#ifndef MC_EMBEDDED_RUNTIME /* the mcstatic variables (from mccode-r.c) */
extern FILE * mcsiminfo_file;     /* handle to the output siminfo file */
extern int    mcgravitation;      /* flag to enable gravitation */
extern int    mcdotrace;          /* flag to print MCDISPLAY messages */
#else
mcstatic FILE *mcsiminfo_file        = NULL;
#endif

/* I/O function prototypes ================================================== */

/* output functions */
MCDETECTOR mcdetector_out_0D(char *t, double p0, double p1, double p2, char *c, Coords pos);
MCDETECTOR mcdetector_out_1D(char *t, char *xl, char *yl,
                  char *xvar, double x1, double x2, long n,
                  double *p0, double *p1, double *p2, char *f, char *c, Coords pos);
MCDETECTOR mcdetector_out_2D(char *t, char *xl, char *yl,
                  double x1, double x2, double y1, double y2, long m,
                  long n, double *p0, double *p1, double *p2, char *f,
                  char *c, Coords pos);
MCDETECTOR mcdetector_out_list(char *t, char *xl, char *yl,
                  long m, long n,
                  double *p1, char *f,
                  char *c, Coords posa);

/* wrappers to output functions, that automatically set NAME and POSITION */
#define DETECTOR_OUT(p0,p1,p2) mcdetector_out_0D(NAME_CURRENT_COMP,p0,p1,p2,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)
#define DETECTOR_OUT_0D(t,p0,p1,p2) mcdetector_out_0D(t,p0,p1,p2,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)
#define DETECTOR_OUT_1D(t,xl,yl,xvar,x1,x2,n,p0,p1,p2,f) \
     mcdetector_out_1D(t,xl,yl,xvar,x1,x2,n,p0,p1,p2,f,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)
#define DETECTOR_OUT_2D(t,xl,yl,x1,x2,y1,y2,m,n,p0,p1,p2,f) \
     mcdetector_out_2D(t,xl,yl,x1,x2,y1,y2,m,n,p0,p1,p2,f,NAME_CURRENT_COMP,POS_A_CURRENT_COMP)

#ifdef USE_NEXUS
#include "napi.h"
NXhandle nxhandle;
#endif

#endif /* ndef MCCODE_R_IO_H */

#endif /* MCCODE_R_H */
/* End of file "mccode-r.h". */

#line 712 "ILL_H15_D11.c"

#line 1 "mcstas-r.h"
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mcstas-r.h
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McStas X.Y
* Version: $Revision$
*
* Runtime system header for McStas.
*
* In order to use this library as an external library, the following variables
* and macros must be declared (see details in the code)
*
*   struct mcinputtable_struct mcinputtable[];
*   int mcnumipar;
*   char mcinstrument_name[], mcinstrument_source[];
*   int mctraceenabled, mcdefaultmain;
*   extern MCNUM  mccomp_storein[];
*   extern MCNUM  mcAbsorbProp[];
*   extern MCNUM  mcScattered;
*   #define MCCODE_STRING "the McStas version"
*
* Usage: Automatically embbeded in the c code.
*
* $Id$
*
*******************************************************************************/

#ifndef MCSTAS_R_H
#define MCSTAS_R_H "$Revision$"

/* Following part is only embedded when not redundent with mcstas.h ========= */

#ifndef MCCODE_H

#define AA2MS    629.622368        /* Convert k[1/AA] to v[m/s] */
#define MS2AA    1.58825361e-3     /* Convert v[m/s] to k[1/AA] */
#define K2V      AA2MS
#define V2K      MS2AA
#define Q2V      AA2MS
#define V2Q      MS2AA
#define SE2V     437.393377        /* Convert sqrt(E)[meV] to v[m/s] */
#define VS2E     5.22703725e-6     /* Convert (v[m/s])**2 to E[meV] */

#define SCATTER do {mcDEBUG_SCATTER(mcnlx, mcnly, mcnlz, mcnlvx, mcnlvy, mcnlvz, \
        mcnlt,mcnlsx,mcnlsy,mcnlsz, mcnlp); mcScattered++;} while(0)
#define ABSORB do {mcDEBUG_STATE(mcnlx, mcnly, mcnlz, mcnlvx, mcnlvy, mcnlvz, \
        mcnlt,mcnlsx,mcnlsy,mcnlsz, mcnlp); mcDEBUG_ABSORB(); MAGNET_OFF; goto mcabsorb;} while(0)

#define STORE_NEUTRON(index, x, y, z, vx, vy, vz, t, sx, sy, sz, p) \
  mcstore_neutron(mccomp_storein,index, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
#define RESTORE_NEUTRON(index, x, y, z, vx, vy, vz, t, sx, sy, sz, p) \
  mcrestore_neutron(mccomp_storein,index, &x, &y, &z, &vx, &vy, &vz, &t, &sx, &sy, &sz, &p);

#define MAGNET_ON \
  do { \
    mcMagnet = 1; \
  } while(0)

#define MAGNET_OFF \
  do { \
    mcMagnet = 0; \
  } while(0)

#define ALLOW_BACKPROP \
  do { \
    mcallowbackprop = 1; \
  } while(0)

#define DISALLOW_BACKPROP \
  do { \
    mcallowbackprop = 0; \
  } while(0)

#define PROP_MAGNET(dt) \
  do { \
  }while (0)
    /* change coordinates from local system to magnet system */
/*    Rotation rotLM, rotTemp; \
      Coords   posLM = coords_sub(POS_A_CURRENT_COMP, mcMagnetPos); \
      rot_transpose(ROT_A_CURRENT_COMP, rotTemp); \
      rot_mul(rotTemp, mcMagnetRot, rotLM); \
      mcMagnetPrecession(mcnlx, mcnly, mcnlz, mcnlt, mcnlvx, mcnlvy, mcnlvz, \
               &mcnlsx, &mcnlsy, &mcnlsz, dt, posLM, rotLM); \
      } while(0)
*/

#define mcPROP_DT(dt) \
  do { \
    if (mcMagnet && dt > 0) PROP_MAGNET(dt);\
    mcnlx += mcnlvx*(dt); \
    mcnly += mcnlvy*(dt); \
    mcnlz += mcnlvz*(dt); \
    mcnlt += (dt); \
    if (isnan(p) || isinf(p)) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }\
  } while(0)

/* ADD: E. Farhi, Aug 6th, 2001 PROP_GRAV_DT propagation with acceleration */
#define PROP_GRAV_DT(dt, Ax, Ay, Az) \
  do { \
    if(dt < 0 && mcallowbackprop == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }\
    if (mcMagnet) printf("Spin precession gravity\n"); \
    mcnlx  += mcnlvx*(dt) + (Ax)*(dt)*(dt)/2; \
    mcnly  += mcnlvy*(dt) + (Ay)*(dt)*(dt)/2; \
    mcnlz  += mcnlvz*(dt) + (Az)*(dt)*(dt)/2; \
    mcnlvx += (Ax)*(dt); \
    mcnlvy += (Ay)*(dt); \
    mcnlvz += (Az)*(dt); \
    mcnlt  += (dt); \
    DISALLOW_BACKPROP;\
  } while(0)


#define PROP_DT(dt) \
  do { \
    if(dt < 0) { RESTORE=1; goto mcabsorbComp; }; \
    if (mcgravitation) { Coords mcLocG; double mc_gx, mc_gy, mc_gz; \
    mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,-GRAVITY,0)); \
    coords_get(mcLocG, &mc_gx, &mc_gy, &mc_gz); \
    PROP_GRAV_DT(dt, mc_gx, mc_gy, mc_gz); } \
    else mcPROP_DT(dt); \
    DISALLOW_BACKPROP;\
  } while(0)


#define PROP_Z0 \
  do { \
    if (mcgravitation) { Coords mcLocG; int mc_ret; \
    double mc_dt, mc_gx, mc_gy, mc_gz; \
    mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,-GRAVITY,0)); \
    coords_get(mcLocG, &mc_gx, &mc_gy, &mc_gz); \
    mc_ret = solve_2nd_order(&mc_dt, NULL, -mc_gz/2, -mcnlvz, -mcnlz); \
    if (mc_ret && mc_dt>=0) {PROP_GRAV_DT(mc_dt, mc_gx, mc_gy, mc_gz); mcnlz=0;}\
    else { if (mcallowbackprop ==0) {mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }}; }\
    else mcPROP_Z0; \
    DISALLOW_BACKPROP;\
  } while(0)

#define mcPROP_Z0 \
  do { \
    double mc_dt; \
    if(mcnlvz == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mc_dt = -mcnlz/mcnlvz; \
    if(mc_dt < 0 && mcallowbackprop == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mcPROP_DT(mc_dt); \
    mcnlz = 0; \
    DISALLOW_BACKPROP;\
  } while(0)

#define PROP_X0 \
  do { \
    if (mcgravitation) { Coords mcLocG; int mc_ret; \
    double mc_dt, mc_gx, mc_gy, mc_gz; \
    mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,-GRAVITY,0)); \
    coords_get(mcLocG, &mc_gx, &mc_gy, &mc_gz); \
    mc_ret = solve_2nd_order(&mc_dt, NULL, -mc_gx/2, -mcnlvx, -mcnlx); \
    if (mc_ret && mc_dt>=0) PROP_GRAV_DT(mc_dt, mc_gx, mc_gy, mc_gz); \
    else { if (mcallowbackprop ==0) {mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }}; }\
    else mcPROP_X0; \
    DISALLOW_BACKPROP;\
  } while(0)

#define mcPROP_X0 \
  do { \
    double mc_dt; \
    if(mcnlvx == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mc_dt = -mcnlx/mcnlvx; \
    if(mc_dt < 0 && mcallowbackprop == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mcPROP_DT(mc_dt); \
    mcnlx = 0; \
    DISALLOW_BACKPROP;\
  } while(0)

#define PROP_Y0 \
  do { \
    if (mcgravitation) { Coords mcLocG; int mc_ret; \
    double mc_dt, mc_gx, mc_gy, mc_gz; \
    mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,-GRAVITY,0)); \
    coords_get(mcLocG, &mc_gx, &mc_gy, &mc_gz); \
    mc_ret = solve_2nd_order(&mc_dt, NULL, -mc_gy/2, -mcnlvy, -mcnly); \
    if (mc_ret && mc_dt>=0) PROP_GRAV_DT(mc_dt, mc_gx, mc_gy, mc_gz); \
    else { if (mcallowbackprop ==0) {mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }}; }\
    else mcPROP_Y0; \
    DISALLOW_BACKPROP;\
  } while(0)


#define mcPROP_Y0 \
  do { \
    double mc_dt; \
    if(mcnlvy == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mc_dt = -mcnly/mcnlvy; \
    if(mc_dt < 0 && mcallowbackprop == 0) { mcAbsorbProp[INDEX_CURRENT_COMP]++; ABSORB; }; \
    mcPROP_DT(mc_dt); \
    mcnly = 0; \
    DISALLOW_BACKPROP; \
  } while(0)

/*moved from mccode-r.h*/
void mcsetstate(double x, double y, double z, double vx, double vy, double vz,
                double t, double sx, double sy, double sz, double p);

#ifdef DEBUG

#define mcDEBUG_STATE(x,y,z,vx,vy,vz,t,sx,sy,sz,p) if(!mcdotrace); else \
  printf("STATE: %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", \
         x,y,z,vx,vy,vz,t,sx,sy,sz,p);
#define mcDEBUG_SCATTER(x,y,z,vx,vy,vz,t,sx,sy,sz,p) if(!mcdotrace); else \
  printf("SCATTER: %g, %g, %g, %g, %g, %g, %g, %g, %g, %g, %g\n", \
         x,y,z,vx,vy,vz,t,sx,sy,sz,p);

#else

#define mcDEBUG_STATE(x,y,z,vx,vy,vz,t,sx,sy,sz,p)
#define mcDEBUG_SCATTER(x,y,z,vx,vy,vz,t,sx,sy,sz,p)

#endif

#endif /* !MCCODE_H */

#endif /* MCSTAS_R_H */
/* End of file "mcstas-r.h". */

#line 945 "ILL_H15_D11.c"

#line 1 "mccode-r.c"
/*******************************************************************************
*
* McCode, neutron/xray ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mccode-r.c
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McStas X.Y/McXtrace X.Y
* Version: $Revision$
*
* Runtime system for McStas and McXtrace.
* Embedded within instrument in runtime mode.
* Contains SECTIONS:
*   MPI handling (sum, send, recv)
*   format definitions
*   I/O
*   mcdisplay support
*   random numbers
*   coordinates handling
*   vectors math (solve 2nd order, normals, randvec...)
*   parameter handling
*   signal and main handlers
*
* Usage: Automatically embbeded in the c code whenever required.
*
* $Id$
*
*******************************************************************************/

/*******************************************************************************
* The I/O format definitions and functions
*******************************************************************************/


/** Include header files to avoid implicit declarations (not allowed on LLVM) */
#include <ctype.h>
#include <sys/types.h>

// UNIX specific headers (non-Windows)
#if defined(__unix__) || defined(__APPLE__)
#include <unistd.h>
#endif

#include <sys/stat.h>

#ifdef _WIN32 
#include <direct.h>
# define  mkdir( D, M )   _mkdir( D ) 
#endif 

#ifndef DANSE
#ifdef MC_ANCIENT_COMPATIBILITY
int mctraceenabled = 0;
int mcdefaultmain  = 0;
#endif
/* else defined directly in the McCode generated C code */

static   long mcseed                 = 0; /* seed for random generator */
static   long mcstartdate            = 0; /* start simulation time */
static   int  mcdisable_output_files = 0; /* --no-output-files */
mcstatic int  mcgravitation          = 0; /* use gravitation flag, for PROP macros */
int      mcMagnet                    = 0; /* magnet stack flag */
mcstatic int  mcdotrace              = 0; /* flag for --trace and messages for DISPLAY */
int      mcallowbackprop             = 0;         /* flag to enable negative/backprop */

/* Number of particle histories to simulate. */
#ifdef NEUTRONICS
mcstatic unsigned long long int mcncount             = 1;
mcstatic unsigned long long int mcrun_num            = 0;
#else
mcstatic unsigned long long int mcncount             = 1000000;
mcstatic unsigned long long int mcrun_num            = 0;
#endif /* NEUTRONICS */

#else
#include "mcstas-globals.h"
#endif /* !DANSE */

/* SECTION: MPI handling ==================================================== */

#ifdef USE_MPI
/* MPI rank */
static int mpi_node_rank;
static int mpi_node_root = 0;


/*******************************************************************************
* mc_MPI_Reduce: Gathers arrays from MPI nodes using Reduce function.
*******************************************************************************/
int mc_MPI_Sum(double *sbuf, long count)
{
  if (!sbuf || count <= 0) return(MPI_SUCCESS); /* nothing to reduce */
  else {
    /* we must cut the buffer into blocks not exceeding the MPI max buffer size of 32000 */
    long   offset=0;
    double *rbuf=NULL;
    int    length=MPI_REDUCE_BLOCKSIZE; /* defined in mccode-r.h */
    int    i=0;
    rbuf = calloc(count, sizeof(double));
    if (!rbuf)
      exit(-fprintf(stderr, "Error: Out of memory %li (mc_MPI_Sum)\n", count*sizeof(double)));
    while (offset < count) {
      if (!length || offset+length > count-1) length=count-offset;
      else length=MPI_REDUCE_BLOCKSIZE;
      if (MPI_Reduce((double*)(sbuf+offset), (double*)(rbuf+offset),
              length, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD) != MPI_SUCCESS)
        return MPI_ERR_COUNT;
      offset += length;
    }

    for (i=0; i<count; i++) sbuf[i] = rbuf[i];
    free(rbuf);
  }
  return MPI_SUCCESS;
} /* mc_MPI_Sum */

/*******************************************************************************
* mc_MPI_Send: Send array to MPI node by blocks to avoid buffer limit
*******************************************************************************/
int mc_MPI_Send(void *sbuf,
                  long count, MPI_Datatype dtype,
                  int dest)
{
  int dsize;
  long offset=0;
  int  tag=1;
  int  length=MPI_REDUCE_BLOCKSIZE; /* defined in mccode-r.h */

  if (!sbuf || count <= 0) return(MPI_SUCCESS); /* nothing to send */
  MPI_Type_size(dtype, &dsize);

  while (offset < count) {
    if (offset+length > count-1) length=count-offset;
    else length=MPI_REDUCE_BLOCKSIZE;
    if (MPI_Send((void*)(sbuf+offset*dsize), length, dtype, dest, tag++, MPI_COMM_WORLD) != MPI_SUCCESS)
      return MPI_ERR_COUNT;
    offset += length;
  }

  return MPI_SUCCESS;
} /* mc_MPI_Send */

/*******************************************************************************
* mc_MPI_Recv: Receives arrays from MPI nodes by blocks to avoid buffer limit
*             the buffer must have been allocated previously.
*******************************************************************************/
int mc_MPI_Recv(void *sbuf,
                  long count, MPI_Datatype dtype,
                  int source)
{
  int dsize;
  long offset=0;
  int  tag=1;
  int  length=MPI_REDUCE_BLOCKSIZE; /* defined in mccode-r.h */

  if (!sbuf || count <= 0) return(MPI_SUCCESS); /* nothing to recv */
  MPI_Type_size(dtype, &dsize);

  while (offset < count) {
    if (offset+length > count-1) length=count-offset;
    else length=MPI_REDUCE_BLOCKSIZE;
    if (MPI_Recv((void*)(sbuf+offset*dsize), length, dtype, source, tag++,
            MPI_COMM_WORLD, MPI_STATUS_IGNORE) != MPI_SUCCESS)
      return MPI_ERR_COUNT;
    offset += length;
  }

  return MPI_SUCCESS;
} /* mc_MPI_Recv */

#endif /* USE_MPI */

/* SECTION: parameters handling ============================================= */

/* Instrument input parameter type handling. */
/*******************************************************************************
* mcparm_double: extract double value from 's' into 'vptr'
*******************************************************************************/
static int
mcparm_double(char *s, void *vptr)
{
  char *p;
  double *v = (double *)vptr;

  if (!s) { *v = 0; return(1); }
  *v = strtod(s, &p);
  if(*s == '\0' || (p != NULL && *p != '\0') || errno == ERANGE)
    return 0;                        /* Failed */
  else
    return 1;                        /* Success */
}

/*******************************************************************************
* mcparminfo_double: display parameter type double
*******************************************************************************/
static char *
mcparminfo_double(char *parmname)
{
  return "double";
}

/*******************************************************************************
* mcparmerror_double: display error message when failed extract double
*******************************************************************************/
static void
mcparmerror_double(char *parm, char *val)
{
  fprintf(stderr, "Error: Invalid value '%s' for floating point parameter %s (mcparmerror_double)\n",
          val, parm);
}

/*******************************************************************************
* mcparmprinter_double: convert double to string
*******************************************************************************/
static void
mcparmprinter_double(char *f, void *vptr)
{
  double *v = (double *)vptr;
  sprintf(f, "%g", *v);
}

/*******************************************************************************
* mcparm_int: extract int value from 's' into 'vptr'
*******************************************************************************/
static int
mcparm_int(char *s, void *vptr)
{
  char *p;
  int *v = (int *)vptr;
  long x;

  if (!s) { *v = 0; return(1); }
  *v = 0;
  x = strtol(s, &p, 10);
  if(x < INT_MIN || x > INT_MAX)
    return 0;                        /* Under/overflow */
  *v = x;
  if(*s == '\0' || (p != NULL && *p != '\0') || errno == ERANGE)
    return 0;                        /* Failed */
  else
    return 1;                        /* Success */
}

/*******************************************************************************
* mcparminfo_int: display parameter type int
*******************************************************************************/
static char *
mcparminfo_int(char *parmname)
{
  return "int";
}

/*******************************************************************************
* mcparmerror_int: display error message when failed extract int
*******************************************************************************/
static void
mcparmerror_int(char *parm, char *val)
{
  fprintf(stderr, "Error: Invalid value '%s' for integer parameter %s (mcparmerror_int)\n",
          val, parm);
}

/*******************************************************************************
* mcparmprinter_int: convert int to string
*******************************************************************************/
static void
mcparmprinter_int(char *f, void *vptr)
{
  int *v = (int *)vptr;
  sprintf(f, "%d", *v);
}

/*******************************************************************************
* mcparm_string: extract char* value from 's' into 'vptr' (copy)
*******************************************************************************/
static int
mcparm_string(char *s, void *vptr)
{
  char **v = (char **)vptr;
  if (!s) { *v = NULL; return(1); }
  *v = (char *)malloc(strlen(s) + 1);
  if(*v == NULL)
  {
    exit(-fprintf(stderr, "Error: Out of memory %li (mcparm_string).\n", (long)strlen(s) + 1));
  }
  strcpy(*v, s);
  return 1;                        /* Success */
}

/*******************************************************************************
* mcparminfo_string: display parameter type string
*******************************************************************************/
static char *
mcparminfo_string(char *parmname)
{
  return "string";
}

/*******************************************************************************
* mcparmerror_string: display error message when failed extract string
*******************************************************************************/
static void
mcparmerror_string(char *parm, char *val)
{
  fprintf(stderr, "Error: Invalid value '%s' for string parameter %s (mcparmerror_string)\n",
          val, parm);
}

/*******************************************************************************
* mcparmprinter_string: convert string to string (including esc chars)
*******************************************************************************/
static void
mcparmprinter_string(char *f, void *vptr)
{
  char **v = (char **)vptr;
  char *p;

  if (!*v) { *f='\0'; return; }
  strcpy(f, "");
  for(p = *v; *p != '\0'; p++)
  {
    switch(*p)
    {
      case '\n':
        strcat(f, "\\n");
        break;
      case '\r':
        strcat(f, "\\r");
        break;
      case '"':
        strcat(f, "\\\"");
        break;
      case '\\':
        strcat(f, "\\\\");
        break;
      default:
        strncat(f, p, 1);
    }
  }
  /* strcat(f, "\""); */
} /* mcparmprinter_string */

/* now we may define the parameter structure, using previous functions */
static struct
  {
    int (*getparm)(char *, void *);
    char * (*parminfo)(char *);
    void (*error)(char *, char *);
    void (*printer)(char *, void *);
} mcinputtypes[] = {
  {
    mcparm_double, mcparminfo_double, mcparmerror_double,
    mcparmprinter_double
  }, {
    mcparm_int, mcparminfo_int, mcparmerror_int,
    mcparmprinter_int
  }, {
    mcparm_string, mcparminfo_string, mcparmerror_string,
    mcparmprinter_string
  }
};

/*******************************************************************************
* mcestimate_error: compute sigma from N,p,p2 in Gaussian large numbers approx
*******************************************************************************/
double mcestimate_error(double N, double p1, double p2)
{
  double pmean, n1;
  if(N <= 1)
    return p1;
  pmean = p1 / N;
  n1 = N - 1;
  /* Note: underflow may cause p2 to become zero; the fabs() below guards
     against this. */
  return sqrt((N/n1)*fabs(p2 - pmean*pmean));
}

double (*mcestimate_error_p)
  (double V2, double psum, double p2sum)=mcestimate_error;

/* ========================================================================== */

/*                               MCCODE_R_IO_C                                */

/* ========================================================================== */

#ifndef MCCODE_R_IO_C
#define MCCODE_R_IO_C "$Revision$"

/* SECTION: file i/o handling ================================================ */

#ifndef HAVE_STRCASESTR
// from msysgit: https://code.google.com/p/msysgit/source/browse/compat/strcasestr.c
char *strcasestr(const char *haystack, const char *needle)
{
  int nlen = strlen(needle);
  int hlen = strlen(haystack) - nlen + 1;
  int i;

  for (i = 0; i < hlen; i++) {
    int j;
    for (j = 0; j < nlen; j++) {
            unsigned char c1 = haystack[i+j];
            unsigned char c2 = needle[j];
            if (toupper(c1) != toupper(c2))
                    goto next;
    }
    return (char *) haystack + i;
  next:
    ;
  }
  return NULL;
}


#endif
#ifndef HAVE_STRCASECMP
int strcasecmp( const char *s1, const char *s2 )
{
  int c1, c2;
  do {
    c1 = tolower( (unsigned char) *s1++ );
    c2 = tolower( (unsigned char) *s2++ );
  } while (c1 == c2 && c1 != 0);
  return c2 > c1 ? -1 : c1 > c2;
}
#endif

/*******************************************************************************
* mcfull_file: allocates a full file name=mcdirname+file. Catenate extension if missing.
*******************************************************************************/
char *mcfull_file(char *name, char *ext)
{
  int   dirlen=0;
  char *mem   =NULL;

  dirlen = mcdirname ? strlen(mcdirname) : 0;
  mem = (char*)malloc(dirlen + strlen(name) + CHAR_BUF_LENGTH);
  if(!mem) {
    exit(-fprintf(stderr, "Error: Out of memory %li (mcfull_file)\n", (long)(dirlen + strlen(name) + 256)));
  }
  strcpy(mem, "");

  /* prepend directory name to path if name does not contain a path */
  if (dirlen > 0 && !strchr(name, MC_PATHSEP_C)) {
    strcat(mem, mcdirname);
    strcat(mem, MC_PATHSEP_S);
  } /* dirlen */

  strcat(mem, name);
  if (!strchr(name, '.') && ext && strlen(ext))
  { /* add extension if not in file name already */
    strcat(mem, ".");
    strcat(mem, ext);
  }
  return(mem);
} /* mcfull_file */

/*******************************************************************************
* mcnew_file: opens a new file within mcdirname if non NULL
*             the file is opened in "a" (append, create if does not exist)
*             the extension 'ext' is added if the file name does not include one.
*             the last argument is set to 0 if file did not exist, else to 1.
*******************************************************************************/
FILE *mcnew_file(char *name, char *ext, int *exists)
{
  char *mem;
  FILE *file=NULL;

  if (!name || strlen(name) == 0 || mcdisable_output_files) return(NULL);
  
  mem  = mcfull_file(name, ext); /* create mcdirname/name.ext */
  
  /* check for existence */
  file = fopen(mem, "r"); /* for reading -> fails if does not exist */
  if (file) {
    fclose(file);
    *exists=1;
  } else
    *exists=0;
  
  /* open the file for writing/appending */
#ifdef USE_NEXUS
  if (mcformat && strcasestr(mcformat, "NeXus")) {
    /* NXhandle nxhandle is defined in the .h with USE_NEXUS */
    NXaccess mode = (*exists ? NXACC_CREATE5 | NXACC_RDWR : NXACC_CREATE5);
      
    if (NXopen(mem, mode, &nxhandle) != NX_OK)
      file = NULL;
    else
      file = (FILE*)&nxhandle; /* to make it non NULL */
  } else
#endif
    file = fopen(mem, "a+"); 
    
  if(!file)
    fprintf(stderr, "Warning: could not open output file '%s' for %s (mcnew_file)\n", 
      mem, *exists ? "append" : "create");
  free(mem);

  return file;
} /* mcnew_file */

/*******************************************************************************
* mcdetector_statistics: compute detector statistics, error bars, [x I I_err N] 1D
* RETURN:            updated detector structure
* Used by: mcdetector_import
*******************************************************************************/
MCDETECTOR mcdetector_statistics(
  MCDETECTOR detector)
{

  if (!detector.p1 || !detector.m || detector.filename[0] == '\0')
    return(detector);
  
  /* compute statistics and update MCDETECTOR structure ===================== */
  double sum_z  = 0, min_z  = 0, max_z  = 0;
  double fmon_x =0,  smon_x = 0, fmon_y =0, smon_y=0, mean_z=0;
  double Nsum=0, P2sum=0;

  double sum_xz = 0, sum_yz = 0, sum_x = 0, sum_y = 0, sum_x2z = 0, sum_y2z = 0;
  int    i,j;
  char   hasnan=0, hasinf=0;
  char   israw = ((char*)strcasestr(detector.format,"raw") != NULL);
  double *this_p1=NULL; /* new 1D McCode array [x I E N]. Freed after writing data */

  /* if McCode/PGPLOT and rank==1 we create a new m*4 data block=[x I E N] */
  if (detector.rank == 1 && strcasestr(detector.format,"McCode")) {
    this_p1 = (double *)calloc(detector.m*detector.n*detector.p*4, sizeof(double));
    if (!this_p1)
      exit(-fprintf(stderr, "Error: Out of memory creating %li 1D " MCCODE_STRING " data set for file '%s' (mcdetector_import)\n",
        detector.m*detector.n*detector.p*4*sizeof(double*), detector.filename));
  }

  max_z = min_z = detector.p1[0];
  
  /* compute sum and moments (not for lists) */
  if (!strcasestr(detector.format,"list") && detector.m)
  for(j = 0; j < detector.n*detector.p; j++)
  {
    for(i = 0; i < detector.m; i++)
    {
      double x,y,z;
      double N, E;
      long   index= !detector.istransposed ? i*detector.n*detector.p + j : i+j*detector.m;
      char   hasnaninf=0;

      if (detector.m) 
        x = detector.xmin + (i + 0.5)/detector.m*(detector.xmax - detector.xmin); 
      else x = 0;
      if (detector.n && detector.p) 
        y = detector.ymin + (j + 0.5)/detector.n/detector.p*(detector.ymax - detector.ymin); 
      else y = 0;
      z = detector.p1[index];
      N = detector.p0 ? detector.p0[index] : 1;
      E = detector.p2 ? detector.p2[index] : 0;
      if (detector.p2 && !israw) 
        detector.p2[index] = (*mcestimate_error_p)(detector.p0[index],detector.p1[index],detector.p2[index]); /* set sigma */
      
      if (detector.rank == 1 && this_p1 && strcasestr(detector.format,"McCode")) {
        /* fill-in 1D McCode array [x I E N] */
        this_p1[index*4]   = x;
        this_p1[index*4+1] = z;
        this_p1[index*4+2] = detector.p2 ? detector.p2[index] : 0;
        this_p1[index*4+3] = N;
      }
      
      if (isnan(z) || isnan(E) || isnan(N)) hasnaninf=hasnan=1;
      if (isinf(z) || isinf(E) || isinf(N)) hasnaninf=hasinf=1;

      /* compute stats integrals */
      if (!hasnaninf) {
        sum_xz += x*z;
        sum_yz += y*z;
        sum_x  += x;
        sum_y  += y;
        sum_z  += z;
        sum_x2z += x*x*z;
        sum_y2z += y*y*z;
        if (z > max_z) max_z = z;
        if (z < min_z) min_z = z;

        Nsum += N;
        P2sum += E;
      }

    }
  } /* for j */

  /* compute 1st and 2nd moments. For lists, sum_z=0 so this is skipped. */
  if (sum_z && detector.n*detector.m*detector.p)
  {
    fmon_x = sum_xz/sum_z;
    fmon_y = sum_yz/sum_z;
    smon_x = sum_x2z/sum_z-fmon_x*fmon_x; smon_x = smon_x > 0 ? sqrt(smon_x) : 0;
    smon_y = sum_y2z/sum_z-fmon_y*fmon_y; smon_y = smon_y > 0 ? sqrt(smon_y) : 0;
    mean_z = sum_z/detector.n/detector.m/detector.p;
  }
  /* store statistics into detector */
  detector.intensity = sum_z;
  detector.error     = Nsum ? (*mcestimate_error_p)(Nsum, sum_z, P2sum) : 0;
  detector.events    = Nsum;
  detector.min       = min_z;
  detector.max       = max_z;
  detector.mean      = mean_z;
  detector.centerX   = fmon_x;
  detector.halfwidthX= smon_x;
  detector.centerY   = fmon_y;
  detector.halfwidthY= smon_y;

  /* if McCode/PGPLOT and rank==1 replace p1 with new m*4 1D McCode and clear others */
  if (detector.rank == 1 && this_p1 && strcasestr(detector.format,"McCode")) {
    
    detector.p1 = this_p1;
    detector.n  = detector.m; detector.m  = 4;
    detector.p0 = detector.p2 = NULL;
    detector.istransposed = 1;
  }

  if (detector.n*detector.m*detector.p > 1)
    snprintf(detector.signal, CHAR_BUF_LENGTH, 
      "Min=%g; Max=%g; Mean=%g;", detector.min, detector.max, detector.mean);
  else
    strcpy(detector.signal, "None");
  snprintf(detector.values, CHAR_BUF_LENGTH,
    "%g %g %g", detector.intensity, detector.error, detector.events);

  switch (detector.rank) {
    case 1:  snprintf(detector.statistics, CHAR_BUF_LENGTH, "X0=%g; dX=%g;",
      detector.centerX, detector.halfwidthX); break;
    case 2:
    case 3:  snprintf(detector.statistics, CHAR_BUF_LENGTH, "X0=%g; dX=%g; Y0=%g; dY=%g;",
      detector.centerX, detector.halfwidthX, detector.centerY, detector.halfwidthY);
      break;
    default: strcpy(detector.statistics, "None");
  }
  
  if (hasnan)
    printf("WARNING: Nan detected in component/file %s %s\n", 
      detector.component, strlen(detector.filename) ? detector.filename : "");
  if (hasinf)
    printf("WARNING: Inf detected in component/file %s %s\n", 
      detector.component, strlen(detector.filename) ? detector.filename : "");
  
  return(detector);
  
} /* mcdetector_statistics */

/*******************************************************************************
* mcdetector_import: build detector structure, merge non-lists from MPI
*                    compute basic stat, write "Detector:" line
* RETURN:            detector structure. Invalid data if detector.p1 == NULL
*                    Invalid detector sets m=0 and filename=""
*                    Simulation data  sets m=0 and filename=mcsiminfo_name
* This function is equivalent to the old 'mcdetector_out', returning a structure
*******************************************************************************/
MCDETECTOR mcdetector_import(
  char *format,
  char *component, char *title,
  long m, long n,  long p,
  char *xlabel, char *ylabel, char *zlabel,
  char *xvar, char *yvar, char *zvar,
  double x1, double x2, double y1, double y2, double z1, double z2,
  char *filename,
  double *p0, double *p1, double *p2,
  Coords position)
{
  time_t t;       /* for detector.date */
  long   date_l;  /* date as a long number */
  char   istransposed=0;
  char   c[CHAR_BUF_LENGTH]; /* temp var for signal label */

  MCDETECTOR detector;

  /* build MCDETECTOR structure ============================================= */
  /* make sure we do not have NULL for char fields */

  /* these also apply to simfile */
  strncpy (detector.filename,  filename ? filename : "",        CHAR_BUF_LENGTH);
  strncpy (detector.format,    format   ? format   : "McCode" , CHAR_BUF_LENGTH);
  /* add extension if missing */
  if (strlen(detector.filename) && !strchr(detector.filename, '.'))
  { /* add extension if not in file name already */
    strcat(detector.filename, ".dat");
  }
  strncpy (detector.component, component ? component : MCCODE_STRING " component", CHAR_BUF_LENGTH);

  snprintf(detector.instrument, CHAR_BUF_LENGTH, "%s (%s)", mcinstrument_name, mcinstrument_source);
  snprintf(detector.user, CHAR_BUF_LENGTH,      "%s on %s",
        getenv("USER") ? getenv("USER") : MCCODE_NAME,
        getenv("HOST") ? getenv("HOST") : "localhost");
  time(&t);         /* get current write time */
  date_l = (long)t; /* same but as a long */
  snprintf(detector.date, CHAR_BUF_LENGTH, "%s", ctime(&t));
  if (strlen(detector.date))   detector.date[strlen(detector.date)-1] = '\0'; /* remove last \n in date */
  detector.date_l = date_l;

  if (!mcget_run_num() || mcget_run_num() >= mcget_ncount())
    snprintf(detector.ncount, CHAR_BUF_LENGTH, "%llu", mcget_ncount()
#ifdef USE_MPI
*mpi_node_count
#endif
  );
  else
    snprintf(detector.ncount, CHAR_BUF_LENGTH, "%g/%g", (double)mcget_run_num(), (double)mcget_ncount());

  detector.p0         = p0;
  detector.p1         = p1;
  detector.p2         = p2;

  /* handle transposition (not for NeXus) */
  if (!strcasestr(detector.format, "NeXus")) {
    if (m<0 || n<0 || p<0)             istransposed = !istransposed;
    if (strcasestr(detector.format, "transpose")) istransposed = !istransposed;
    if (istransposed) { /* do the swap once for all */
      long i=m; m=n; n=i;
    }
  }

  m=labs(m); n=labs(n); p=labs(p); /* make sure dimensions are positive */
  detector.istransposed = istransposed;

  /* determine detector rank (dimensionality) */
  if (!m || !n || !p || !p1) detector.rank = 4; /* invalid: exit with m=0 filename="" */
  else if (m*n*p == 1)       detector.rank = 0; /* 0D */
  else if (n == 1 || m == 1) detector.rank = 1; /* 1D */
  else if (p == 1)           detector.rank = 2; /* 2D */
  else                       detector.rank = 3; /* 3D */

  /* from rank, set type */
  switch (detector.rank) {
    case 0:  strcpy(detector.type,  "array_0d"); m=n=p=1; break;
    case 1:  snprintf(detector.type, CHAR_BUF_LENGTH, "array_1d(%ld)", m*n*p); m *= n*p; n=p=1; break;
    case 2:  snprintf(detector.type, CHAR_BUF_LENGTH, "array_2d(%ld, %ld)", m, n*p); n *= p; p=1; break;
    case 3:  snprintf(detector.type, CHAR_BUF_LENGTH, "array_3d(%ld, %ld, %ld)", m, n, p); break;
    default: m=0; strcpy(detector.type, ""); strcpy(detector.filename, "");/* invalid */
  }

  detector.m    = m;
  detector.n    = n;
  detector.p    = p;

  /* these only apply to detector files ===================================== */

  snprintf(detector.position, CHAR_BUF_LENGTH, "%g %g %g", position.x, position.y, position.z);
  /* may also store actual detector orientation in the future */

  strncpy(detector.title,      title && strlen(title) ? title : component,       CHAR_BUF_LENGTH);
  strncpy(detector.xlabel,     xlabel && strlen(xlabel) ? xlabel : "X", CHAR_BUF_LENGTH); /* axis labels */
  strncpy(detector.ylabel,     ylabel && strlen(ylabel) ? ylabel : "Y", CHAR_BUF_LENGTH);
  strncpy(detector.zlabel,     zlabel && strlen(zlabel) ? zlabel : "Z", CHAR_BUF_LENGTH);
  strncpy(detector.xvar,       xvar && strlen(xvar) ? xvar :       "x", CHAR_BUF_LENGTH); /* axis variables */
  strncpy(detector.yvar,       yvar && strlen(yvar) ? yvar :       detector.xvar, CHAR_BUF_LENGTH);
  strncpy(detector.zvar,       zvar && strlen(zvar) ? zvar :       detector.yvar, CHAR_BUF_LENGTH);

  /* set "variables" as e.g. "I I_err N" */
  strcpy(c, "I ");
  if (strlen(detector.zvar))      strncpy(c, detector.zvar,32);
  else if (strlen(detector.yvar)) strncpy(c, detector.yvar,32);
  else if (strlen(detector.xvar)) strncpy(c, detector.xvar,32);

  if (detector.rank == 1)
    snprintf(detector.variables, CHAR_BUF_LENGTH, "%s %s %s_err N", detector.xvar, c, c);
  else
    snprintf(detector.variables, CHAR_BUF_LENGTH, "%s %s_err N", c, c);

  /* limits */
  detector.xmin = x1;
  detector.xmax = x2;
  detector.ymin = y1;
  detector.ymax = y2;
  detector.zmin = z1;
  detector.zmax = z2;
  if (abs(detector.rank) == 1)
    snprintf(detector.limits, CHAR_BUF_LENGTH, "%g %g", x1, x2);
  else if (detector.rank == 2)
    snprintf(detector.limits, CHAR_BUF_LENGTH, "%g %g %g %g", x1, x2, y1, y2);
  else
    snprintf(detector.limits, CHAR_BUF_LENGTH, "%g %g %g %g %g %g", x1, x2, y1, y2, z1, z2);

  /* if MPI and nodes_nb > 1: reduce data sets when using MPI =============== */
#ifdef USE_MPI
  if (!strcasestr(detector.format,"list") && mpi_node_count > 1 && m) {
    /* we save additive data: reduce everything into mpi_node_root */
    if (p0) mc_MPI_Sum(p0, m*n*p);
    if (p1) mc_MPI_Sum(p1, m*n*p);
    if (p2) mc_MPI_Sum(p2, m*n*p);
    if (!p0) {  /* additive signal must be then divided by the number of nodes */
      int i;
      for (i=0; i<m*n*p; i++) {
        p1[i] /= mpi_node_count;
        if (p2) p2[i] /= mpi_node_count;
      }
    }
  }
#endif /* USE_MPI */

  /* compute statistics, Nsum, intensity, Error bars */
  detector = mcdetector_statistics(detector);

#ifdef USE_MPI
  /* slaves are done */
  if(mpi_node_rank != mpi_node_root) {
    return detector;
  }
#endif

  /* output "Detector:" line ================================================ */
  /* when this is a detector written by a component (not the SAVE from instrument),
     not an event lists */
  if (!m) return(detector);
  if (!strcasestr(detector.format,"list")) {
    if (!strcmp(detector.component, mcinstrument_name)) {
      if (strlen(detector.filename))  /* we name it from its filename, or from its title */
        strncpy(c, detector.filename, CHAR_BUF_LENGTH);
      else
        snprintf(c, CHAR_BUF_LENGTH, "%s", mcinstrument_name);
    } else
      strncpy(c, detector.component, CHAR_BUF_LENGTH);  /* usual detectors written by components */

    printf("Detector: %s_I=%g %s_ERR=%g %s_N=%g",
           c, detector.intensity,
           c, detector.error,
           c, detector.events);
    printf(" \"%s\"\n", strlen(detector.filename) ? detector.filename : detector.component);
  }
  

  return(detector);
} /* mcdetector_import */

/* end MCDETECTOR import section ============================================ */

















/* ========================================================================== */

/*                               ASCII output                                 */
/*     The SIM file is YAML based, the data files have '#' headers            */

/* ========================================================================== */


/*******************************************************************************
* mcinfo_out: output instrument tags/info (only in SIM)
* Used in: mcsiminfo_init (ascii), mcinfo(stdout)
*******************************************************************************/
static void mcinfo_out(char *pre, FILE *f)
{
  char Parameters[CHAR_BUF_LENGTH] = "";
  int  i;

  if (!f || mcdisable_output_files) return;

  /* create parameter string ================================================ */
  for(i = 0; i < mcnumipar; i++)
  {
    char ThisParam[CHAR_BUF_LENGTH];
    if (strlen(mcinputtable[i].name) > CHAR_BUF_LENGTH) break;
    snprintf(ThisParam, CHAR_BUF_LENGTH, " %s(%s)", mcinputtable[i].name,
            (*mcinputtypes[mcinputtable[i].type].parminfo)
                (mcinputtable[i].name));
    strcat(Parameters, ThisParam);
    if (strlen(Parameters) >= CHAR_BUF_LENGTH-64) break;
  }

  /* output data ============================================================ */
  if (f != stdout)
    fprintf(f, "%sFile: %s%c%s\n",    pre, mcdirname, MC_PATHSEP_C, mcsiminfo_name);
  else
    fprintf(f, "%sCreator: %s\n",     pre, MCCODE_STRING);

  fprintf(f, "%sSource: %s\n",   pre, mcinstrument_source);
  fprintf(f, "%sParameters: %s\n",    pre, Parameters);
  
  fprintf(f, "%sTrace_enabled: %s\n", pre, mctraceenabled ? "yes" : "no");
  fprintf(f, "%sDefault_main: %s\n",  pre, mcdefaultmain ?  "yes" : "no");
  fprintf(f, "%sEmbedded_runtime: %s\n", pre, 
#ifdef MC_EMBEDDED_RUNTIME
         "yes"
#else
         "no"
#endif
         );

  fflush(f);
} /* mcinfo_out */

/*******************************************************************************
* mcruninfo_out_backend: output simulation tags/info (both in SIM and data files)
* Used in: mcsiminfo_init (ascii case), mcdetector_out_xD_ascii, mcinfo(stdout)
*******************************************************************************/
static void mcruninfo_out_backend(char *pre, FILE *f, int info)
{
  int i;
  char Parameters[CHAR_BUF_LENGTH];

  if (!f || mcdisable_output_files) return;

  fprintf(f, "%sFormat: %s%s\n",      pre, 
    mcformat && strlen(mcformat) ? mcformat : MCCODE_NAME,
    mcformat && strcasestr(mcformat,"McCode") ? " with text headers" : "");
  fprintf(f, "%sURL: %s\n",         pre, "http://www.mccode.org");
  fprintf(f, "%sCreator: %s\n",     pre, MCCODE_STRING);
  fprintf(f, "%sInstrument: %s\n", pre, mcinstrument_source);
  fprintf(f, "%sNcount: %llu\n",        pre, mcget_ncount());
  fprintf(f, "%sTrace: %s\n",       pre, mcdotrace ? "yes" : "no");
  fprintf(f, "%sGravitation: %s\n", pre, mcgravitation ? "yes" : "no");
  snprintf(Parameters, CHAR_BUF_LENGTH, "%ld", mcseed);
  fprintf(f, "%sSeed: %s\n",        pre, Parameters);
  fprintf(f, "%sDirectory: %s\n",        pre, mcdirname ? mcdirname : ".");
#ifdef USE_MPI
  if (mpi_node_count > 1)
    fprintf(f, "%sNodes: %i\n",        pre, mpi_node_count);
#endif

  /* output parameter string ================================================ */
  for(i = 0; i < mcnumipar; i++) {
      if (!info){
          (*mcinputtypes[mcinputtable[i].type].printer)(Parameters, mcinputtable[i].par);
          fprintf(f, "%sParam: %s=%s\n", pre, mcinputtable[i].name, Parameters);
      }else{
        /*if an info run, some variables might not have values. Flag these by "NULL"*/
	if(mcinputtable[i].val && strlen(mcinputtable[i].val)){
            /* ... those with defautl values*/
            (*mcinputtypes[mcinputtable[i].type].printer)(Parameters, mcinputtable[i].par);
            fprintf(f, "%sParam: %s=%s\n", pre, mcinputtable[i].name, Parameters);
        }else{
            /* ... and those without */
            fprintf(f, "%sParam: %s=NULL\n", pre, mcinputtable[i].name);
	}
      }
  }
} /* mcruninfo_out_backend */

/************************
* wrapper function to mcruninfo_out_backend
*  Regular runs use this whereas the single call from mcinfo is directly to the backend
*************************/
static void mcruninfo_out(char *pre, FILE *f){
    mcruninfo_out_backend(pre,f,0);
}

/*******************************************************************************
* mcsiminfo_out:    wrapper to fprintf(mcsiminfo_file)
*******************************************************************************/
void mcsiminfo_out(char *format, ...)
{
  va_list ap;

  if(mcsiminfo_file && !mcdisable_output_files)
  {
    va_start(ap, format);
    vfprintf(mcsiminfo_file, format, ap);
    va_end(ap);
  }
} /* mcsiminfo_out */


/*******************************************************************************
* mcdatainfo_out: output detector header
*   mcdatainfo_out(prefix, file_handle, detector) writes info to data file
*******************************************************************************/
static void
mcdatainfo_out(char *pre, FILE *f, MCDETECTOR detector)
{
  if (!f || !detector.m || mcdisable_output_files) return;
  
  /* output data ============================================================ */
  fprintf(f, "%sDate: %s (%li)\n",       pre, detector.date, detector.date_l);
  fprintf(f, "%stype: %s\n",       pre, detector.type);
  fprintf(f, "%sSource: %s\n",     pre, detector.instrument);
  fprintf(f, "%scomponent: %s\n",  pre, detector.component);
  fprintf(f, "%sposition: %s\n",   pre, detector.position);

  fprintf(f, "%stitle: %s\n",      pre, detector.title);
  fprintf(f, !mcget_run_num() || mcget_run_num() >= mcget_ncount() ?
             "%sNcount: %s\n" : 
             "%sratio: %s\n",  pre, detector.ncount);

  if (strlen(detector.filename)) {
    fprintf(f, "%sfilename: %s\n", pre, detector.filename);
  }

  fprintf(f, "%sstatistics: %s\n", pre, detector.statistics);
  fprintf(f, "%ssignal: %s\n",     pre, detector.signal);
  fprintf(f, "%svalues: %s\n",     pre, detector.values);

  if (detector.rank >= 1)
  {
    fprintf(f, "%sxvar: %s\n",     pre, detector.xvar);
    fprintf(f, "%syvar: %s\n",     pre, detector.yvar);
    fprintf(f, "%sxlabel: %s\n",   pre, detector.xlabel);
    fprintf(f, "%sylabel: %s\n",   pre, detector.ylabel);
    if (detector.rank > 1) {
      fprintf(f, "%szvar: %s\n",   pre, detector.zvar);
      fprintf(f, "%szlabel: %s\n", pre, detector.zlabel);
    }
  }

  fprintf(f, 
    abs(detector.rank)==1 ?
             "%sxlimits: %s\n" : 
             "%sxylimits: %s\n", pre, detector.limits);
  fprintf(f, "%svariables: %s\n", pre, 
    strcasestr(detector.format, "list") ? detector.ylabel : detector.variables);
    
  fflush(f);

} /* mcdatainfo_out */

/* mcdetector_out_array_ascii: output a single array to a file
 *   m: columns
 *   n: rows
 *   p: array
 *   f: file handle (already opened)
 */
static void mcdetector_out_array_ascii(long m, long n, double *p, FILE *f, char istransposed)
{
  if(f)
  {
    int i,j;
    for(j = 0; j < n; j++)
    {
      for(i = 0; i < m; i++)
      {
          fprintf(f, "%.10g ", p[!istransposed ? i*n + j : j*m+i]);
      }
      fprintf(f,"\n");
    }
  }
} /* mcdetector_out_array_ascii */

/*******************************************************************************
* mcdetector_out_0D_ascii: called by mcdetector_out_0D for ascii output
*******************************************************************************/
MCDETECTOR mcdetector_out_0D_ascii(MCDETECTOR detector)
{
  int exists=0;
  FILE *outfile = NULL;
  
  /* Write data set information to simulation description file. */
  MPI_MASTER(
    mcsiminfo_out("\nbegin data\n"); // detector.component
    mcdatainfo_out("  ", mcsiminfo_file, detector);
    mcsiminfo_out("end data\n");
    /* Don't write if filename is NULL: mcnew_file handles this (return NULL) */
    outfile = mcnew_file(detector.component, "dat", &exists);
    if(outfile)
    {
      /* write data file header and entry in simulation description file */
      mcruninfo_out( "# ", outfile);
      mcdatainfo_out("# ", outfile, detector);
      /* write I I_err N */
      fprintf(outfile, "%g %g %g\n", 
        detector.intensity, detector.error, detector.events);
      fclose(outfile);
    }
  ); /* MPI_MASTER */
  return(detector);
} /* mcdetector_out_0D_ascii */

/*******************************************************************************
* mcdetector_out_1D_ascii: called by mcdetector_out_1D for ascii output
*******************************************************************************/
MCDETECTOR mcdetector_out_1D_ascii(MCDETECTOR detector)
{
  int exists=0;
  FILE *outfile = NULL;

  MPI_MASTER(
    /* Write data set information to simulation description file. */
    mcsiminfo_out("\nbegin data\n"); // detector.filename
    mcdatainfo_out("  ", mcsiminfo_file, detector);
    mcsiminfo_out("end data\n");
    /* Loop over array elements, writing to file. */
    /* Don't write if filename is NULL: mcnew_file handles this (return NULL) */
    outfile = mcnew_file(detector.filename, "dat", &exists);
    if(outfile)
    {
      /* write data file header and entry in simulation description file */
      mcruninfo_out( "# ", outfile);
      mcdatainfo_out("# ", outfile, detector);
      /* output the 1D array columns */
      mcdetector_out_array_ascii(detector.m, detector.n, detector.p1, outfile, detector.istransposed);
      
      fclose(outfile);
    }
  ); /* MPI_MASTER */
  return(detector);
  
}  /* mcdetector_out_1D_ascii */

/*******************************************************************************
* mcdetector_out_2D_ascii: called by mcdetector_out_2D for ascii output
*******************************************************************************/
MCDETECTOR mcdetector_out_2D_ascii(MCDETECTOR detector)
{
  int exists=0;
  FILE *outfile = NULL;
  
  MPI_MASTER(
    /* Loop over array elements, writing to file. */
    /* Don't write if filename is NULL: mcnew_file handles this (return NULL) */
    outfile = mcnew_file(detector.filename, "dat", &exists);
    if(outfile)
    {
      /* write header only if file has just been created (not appending) */
      if (!exists) {
        /* Write data set information to simulation description file. */
        mcsiminfo_out("\nbegin data\n"); // detector.filename
        mcdatainfo_out("  ", mcsiminfo_file, detector);
        mcsiminfo_out("end data\n");
      
        mcruninfo_out( "# ", outfile);
        mcdatainfo_out("# ", outfile,   detector);
        fprintf(outfile, "# Data [%s/%s] %s:\n", detector.component, detector.filename, detector.zvar);
      }
      mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p1, 
        outfile, detector.istransposed);
      if (detector.p2) {
        fprintf(outfile, "# Errors [%s/%s] %s_err:\n", detector.component, detector.filename, detector.zvar);
        mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p2, 
          outfile, detector.istransposed);
      }
      if (detector.p0) {
        fprintf(outfile, "# Events [%s/%s] N:\n", detector.component, detector.filename);
        mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p0, 
          outfile, detector.istransposed);
      }
      fclose(outfile);
      
      if (!exists) {
        if (strcasestr(detector.format, "list"))
          printf("Events:   \"%s\"\n",  
            strlen(detector.filename) ? detector.filename : detector.component);
      }
    } /* if outfile */
  ); /* MPI_MASTER */
#ifdef USE_MPI
  if (strcasestr(detector.format, "list") && mpi_node_count > 1) {
    int node_i=0;
    /* loop along MPI nodes to write sequentially */
    for(node_i=0; node_i<mpi_node_count; node_i++) {
      /* MPI: slaves wait for the master to write its block, then append theirs */
      MPI_Barrier(MPI_COMM_WORLD);
      if (node_i != mpi_node_root && node_i == mpi_node_rank) {
        if(strlen(detector.filename) && !mcdisable_output_files)	/* Don't write if filename is NULL */
          outfile = mcnew_file(detector.filename, "dat", &exists);
        if (!exists)
          fprintf(stderr, "Warning: [MPI node %i] file '%s' does not exist yet, "
                          "MASTER should have opened it before.\n",
            mpi_node_rank, detector.filename);
        if(outfile) {
          mcdetector_out_array_ascii(detector.m, detector.n*detector.p, detector.p1, 
            outfile, detector.istransposed);
          fclose(outfile);
        }
      }
    }
  } /* if strcasestr list */
#endif
  return(detector);
} /* mcdetector_out_2D_ascii */

/*******************************************************************************
* strcpy_valid: makes a valid string for variable names.
*   copy 'original' into 'valid', replacing invalid characters by '_'
*   char arrays must be pre-allocated
*******************************************************************************/
static char *strcpy_valid(char *valid, char *original)
{
  long i;
  int  n=32; /* max length of valid names */

  if (original == NULL || !strlen(original)) return(NULL);

  if (n > strlen(original)) n = strlen(original);
  else original += strlen(original)-n;
  strncpy(valid, original, n);

  for (i=0; i < n; i++)
  {
    if ( (valid[i] > 122)
      || (valid[i] < 32)
      || (strchr("!\"#$%&'()*+,-.:;<=>?@[\\]^`/ \n\r\t", valid[i]) != NULL) )
    {
      if (i) valid[i] = '_'; else valid[i] = 'm';
    }
  }
  valid[i] = '\0';

  return(valid);
} /* strcpy_valid */

/* end ascii output section ================================================= */







#ifdef USE_NEXUS

/* ========================================================================== */

/*                               NeXus output                                 */

/* ========================================================================== */

#define nxprintf(...)    nxstr('d', __VA_ARGS__)
#define nxprintattr(...) nxstr('a', __VA_ARGS__)

/*******************************************************************************
* nxstr: output a tag=value data set (char) in NeXus/current group
*   when 'format' is larger that 1024 chars it is used as value for the 'tag'
*   else the value is assembled with format and following arguments.
*   type='d' -> data set
*        'a' -> attribute for current data set
*******************************************************************************/
static int nxstr(char type, NXhandle *f, char *tag, char *format, ...)
{
  va_list ap;
  char value[CHAR_BUF_LENGTH];
  int  i;
  int  ret=NX_OK;
  
  if (!tag || !format || !strlen(tag) || !strlen(format)) return(NX_OK);
  
  /* assemble the value string */
  if (strlen(format) < CHAR_BUF_LENGTH) {
    va_start(ap, format);
    ret = vsnprintf(value, CHAR_BUF_LENGTH, format, ap);
    va_end(ap);
  
    i = strlen(value);
  } else {
    i = strlen(format);
  }

  if (type == 'd') {
    /* open/put/close data set */
    if (NXmakedata (f, tag, NX_CHAR, 1, &i) != NX_OK) return(NX_ERROR);
    NXopendata (f, tag);
    if (strlen(format) < CHAR_BUF_LENGTH)
      ret = NXputdata  (f, value);
    else
      ret = NXputdata  (f, format);
    NXclosedata(f);
  } else {
    if (strlen(format) < CHAR_BUF_LENGTH)
      ret = NXputattr  (f, tag, value, strlen(value), NX_CHAR);
    else
      ret = NXputattr  (f, tag, format, strlen(format), NX_CHAR);
  }
  
  return(ret);
  
} /* nxstr */

/*******************************************************************************
* mcinfo_readfile: read a full file into a string buffer which is allocated
*   Think to free the buffer after use.
* Used in: mcinfo_out_nexus (nexus)
*******************************************************************************/
char *mcinfo_readfile(char *filename)
{
  FILE *f = fopen(filename, "rb");
  if (!f) return(NULL);
  fseek(f, 0, SEEK_END);
  long fsize = ftell(f);
  rewind(f);
  char *string = malloc(fsize + 1);
  if (string) {
    int n = fread(string, fsize, 1, f);
    fclose(f);

    string[fsize] = 0;
  }
  return(string);
}

/*******************************************************************************
* mcinfo_out: output instrument/simulation groups in NeXus file
* Used in: mcsiminfo_init (nexus)
*******************************************************************************/
static void mcinfo_out_nexus(NXhandle f)
{
  FILE  *fid;     /* for intrument source code/C/IDF */
  char  *buffer=NULL;
  time_t t     =time(NULL); /* for date */
  char   entry0[CHAR_BUF_LENGTH];
  int    count=0;
  char   name[CHAR_BUF_LENGTH];
  char   class[CHAR_BUF_LENGTH];
  
  if (!f || mcdisable_output_files) return;
  
  /* write NeXus NXroot attributes */
  /* automatically added: file_name, HDF5_Version, file_time, NeXus_version */ 
  nxprintattr(f, "creator",   "%s generated with " MCCODE_STRING, mcinstrument_name);
  
  /* count the number of existing NXentry and create the next one */
  NXgetgroupinfo(f, &count, name, class);
  sprintf(entry0, "entry%i", count+1);

  /* create the main NXentry (mandatory in NeXus) */
  if (NXmakegroup(f, entry0, "NXentry") == NX_OK) 
  if (NXopengroup(f, entry0, "NXentry") == NX_OK) {
    
    nxprintf(nxhandle, "program_name", MCCODE_STRING);
    nxprintf(f, "start_time", ctime(&t));
    nxprintf(f, "title", "%s%s%s simulation generated by instrument %s", 
      mcdirname && strlen(mcdirname) ? mcdirname : ".", MC_PATHSEP_S, mcsiminfo_name,
      mcinstrument_name);
    nxprintattr(f, "program_name", MCCODE_STRING);
    nxprintattr(f, "instrument",   mcinstrument_name);
    nxprintattr(f, "simulation",   "%s%s%s",
        mcdirname && strlen(mcdirname) ? mcdirname : ".", MC_PATHSEP_S, mcsiminfo_name);

    /* write NeXus instrument group */
    if (NXmakegroup(f, "instrument", "NXinstrument") == NX_OK)
    if (NXopengroup(f, "instrument", "NXinstrument") == NX_OK) {
      int   i;
      char *string=NULL;

      /* write NeXus parameters(types) data =================================== */
      string = (char*)malloc(CHAR_BUF_LENGTH);
      if (string) {
        strcpy(string, "");
        for(i = 0; i < mcnumipar; i++)
        {
          char ThisParam[CHAR_BUF_LENGTH];
          snprintf(ThisParam, CHAR_BUF_LENGTH, " %s(%s)", mcinputtable[i].name,
                  (*mcinputtypes[mcinputtable[i].type].parminfo)
                      (mcinputtable[i].name));
          if (strlen(string) + strlen(ThisParam) < CHAR_BUF_LENGTH)
            strcat(string, ThisParam);
        }
        nxprintattr(f, "Parameters",    string);
        free(string);
      }
        
      nxprintattr(f, "name",          mcinstrument_name);
      nxprintf   (f, "name",          mcinstrument_name);
      nxprintattr(f, "Source",        mcinstrument_source);
      
      nxprintattr(f, "Trace_enabled", mctraceenabled ? "yes" : "no");
      nxprintattr(f, "Default_main",  mcdefaultmain ?  "yes" : "no");
      nxprintattr(f, "Embedded_runtime",  
  #ifdef MC_EMBEDDED_RUNTIME
           "yes"
  #else
           "no"
  #endif
           );
           
      /* add instrument source code when available */
      buffer = mcinfo_readfile(mcinstrument_source);
      if (buffer && strlen(buffer)) {
        long length=strlen(buffer);
        nxprintf (f, "description", buffer);
        NXopendata(f,"description");
        nxprintattr(f, "file_name", mcinstrument_source);
        nxprintattr(f, "file_size", "%li", length);
        nxprintattr(f, "MCCODE_STRING", MCCODE_STRING);
        NXclosedata(f);
        nxprintf (f,"instrument_source", "%s " MCCODE_NAME " " MCCODE_PARTICLE " Monte Carlo simulation", mcinstrument_name);
        free(buffer);
      } else
        nxprintf (f, "description", "File %s not found (instrument description %s is missing)", 
          mcinstrument_source, mcinstrument_name);
      
      /* add Mantid/IDF.xml when available */
      char *IDFfile=NULL;
      IDFfile = (char*)malloc(CHAR_BUF_LENGTH);
      sprintf(IDFfile,"%s%s",mcinstrument_source,".xml");
      buffer = mcinfo_readfile(IDFfile);
      if (buffer && strlen(buffer)) {
        NXmakegroup (nxhandle, "instrument_xml", "NXnote");
        NXopengroup (nxhandle, "instrument_xml", "NXnote");
        nxprintf(f, "data", buffer);
        nxprintf(f, "description", "IDF.xml file found with instrument %s", mcinstrument_source);
        nxprintf(f, "type", "text/xml");
        NXclosegroup(f); /* instrument_xml */
        free(buffer);
      }
      free(IDFfile);
      NXclosegroup(f); /* instrument */
    } /* NXinstrument */

    /* write NeXus simulation group */
    if (NXmakegroup(f, "simulation", "NXnote") == NX_OK)
    if (NXopengroup(f, "simulation", "NXnote") == NX_OK) {

      nxprintattr(f, "name",   "%s%s%s",
        mcdirname && strlen(mcdirname) ? mcdirname : ".", MC_PATHSEP_S, mcsiminfo_name);
      
      nxprintf   (f, "name",      "%s",     mcsiminfo_name);
      nxprintattr(f, "Format",    mcformat && strlen(mcformat) ? mcformat : MCCODE_NAME);
      nxprintattr(f, "URL",       "http://www.mccode.org");
      nxprintattr(f, "program",   MCCODE_STRING);
      nxprintattr(f, "Instrument",mcinstrument_source);
      nxprintattr(f, "Trace",     mcdotrace ?     "yes" : "no");
      nxprintattr(f, "Gravitation",mcgravitation ? "yes" : "no");
      nxprintattr(f, "Seed",      "%li", mcseed);
      nxprintattr(f, "Directory", mcdirname);
    #ifdef USE_MPI
      if (mpi_node_count > 1)
        nxprintf(f, "Nodes", "%i",        mpi_node_count);
    #endif
    
      /* output parameter string ================================================ */
      if (NXmakegroup(f, "Param", "NXparameters") == NX_OK)
      if (NXopengroup(f, "Param", "NXparameters") == NX_OK) {
        int i;
        char string[CHAR_BUF_LENGTH];
        for(i = 0; i < mcnumipar; i++) {
          if (mcget_run_num() || (mcinputtable[i].val && strlen(mcinputtable[i].val))) {
            if (mcinputtable[i].par == NULL)
              strncpy(string, (mcinputtable[i].val ? mcinputtable[i].val : ""), CHAR_BUF_LENGTH);
            else
              (*mcinputtypes[mcinputtable[i].type].printer)(string, mcinputtable[i].par);

            nxprintf(f,  mcinputtable[i].name, "%s", string);
            nxprintattr(f, mcinputtable[i].name, string);
          }
        }
        NXclosegroup(f); /* Param */
      } /* NXparameters */
      
      NXclosegroup(f); /* simulation */
    } /* NXsimulation */
    
    /* create a group to hold all monitors */
    NXmakegroup(f, "data", "NXdetector");

    /* leave the NXentry opened (closed at exit) */
  } /* NXentry */
} /* mcinfo_out_nexus */

/*******************************************************************************
* mcdatainfo_out_nexus: output detector header
*   mcdatainfo_out_nexus(detector) create group and write info to NeXus data file
*   open data:NXdetector then filename:NXdata and write headers/attributes
*   requires: NXentry to be opened
*******************************************************************************/
static void
mcdatainfo_out_nexus(NXhandle f, MCDETECTOR detector)
{
  char data_name[32];
  if (!f || !detector.m || mcdisable_output_files) return;
  
  strcpy_valid(data_name, 
    detector.filename && strlen(detector.filename) ? 
      detector.filename : detector.component);

  /* the NXdetector group has been created in mcinfo_out_nexus (mcsiminfo_init) */
  if (NXopengroup(f, "data", "NXdetector") == NX_OK) {

    /* create and open the data group */
    /* this may fail when appending to list -> ignore/skip */
    NXMDisableErrorReporting(); /* unactivate NeXus error messages, as creation may fail */
    
    if (NXmakegroup(f, data_name, "NXdata") == NX_OK)
    if (NXopengroup(f, data_name, "NXdata") == NX_OK) {
    
      /* output metadata (as attributes) ======================================== */
      nxprintattr(f, "Date",       detector.date);
      nxprintattr(f, "type",       detector.type);
      nxprintattr(f, "Source",     detector.instrument);
      nxprintattr(f, "component",  detector.component);
      nxprintattr(f, "position",   detector.position);

      nxprintattr(f, "title",      detector.title);
      nxprintattr(f, !mcget_run_num() || mcget_run_num() >= mcget_ncount() ?
                 "Ncount" : 
                 "ratio",  detector.ncount);

      if (strlen(detector.filename)) {
        nxprintattr(f, "filename", detector.filename);
      }

      nxprintattr(f, "statistics", detector.statistics);
      nxprintattr(f, "signal",     detector.signal);
      nxprintattr(f, "values",     detector.values);

      if (detector.rank >= 1)
      {
        nxprintattr(f, "xvar",     detector.xvar);
        nxprintattr(f, "yvar",     detector.yvar);
        nxprintattr(f, "xlabel",   detector.xlabel);
        nxprintattr(f, "ylabel",   detector.ylabel);
        if (detector.rank > 1) {
          nxprintattr(f, "zvar",   detector.zvar);
          nxprintattr(f, "zlabel", detector.zlabel);
        }
      }

      nxprintattr(f, abs(detector.rank)==1 ?
                 "xlimits" : 
                 "xylimits", detector.limits);
      nxprintattr(f, "variables", 
        strcasestr(detector.format, "list") ? detector.ylabel : detector.variables);
      nxprintf(f, "distance", detector.position);
      nxprintf(f, "acquisition_mode",
        strcasestr(detector.format, "list") ? "event" : "summed");
        
      NXclosegroup(f);
    } /* NXdata (filename) */
    NXMEnableErrorReporting();  /* re-enable NeXus error messages */
    NXclosegroup(f);
  } /* NXdetector (data) */
  
} /* mcdatainfo_out_nexus */

/*******************************************************************************
* mcdetector_out_axis_nexus: write detector axis into current NXdata
*   requires: NXdata to be opened
*******************************************************************************/
int mcdetector_out_axis_nexus(NXhandle f, char *label, char *var, int rank, long length, double min, double max)
{
  if (!f || length <= 1 || mcdisable_output_files || max == min) return(NX_OK);
  else {
    double axis[length];
    char valid[32];
    int dim=(int)length;
    int i;
    int nprimary=1;
    /* create an axis from [min:max] */
    for(i = 0; i < length; i++)
      axis[i] = min+(max-min)*(i+0.5)/length;
    /* create the data set */
    strcpy_valid(valid, label);
    NXcompmakedata(f, valid, NX_FLOAT64, 1, &dim, NX_COMP_LZW, &dim);
    /* open it */
    if (NXopendata(f, valid) != NX_OK) {
      fprintf(stderr, "Warning: could not open axis rank %i '%s' (NeXus)\n",
        rank, valid);
      return(NX_ERROR);
    }
    /* put the axis and its attributes */
    NXputdata  (f, axis);
    nxprintattr(f, "long_name",  label);
    nxprintattr(f, "short_name", var);
    NXputattr  (f, "axis",       &rank,     1, NX_INT32);
    nxprintattr(f, "units",      var);
    NXputattr  (f, "primary",    &nprimary, 1, NX_INT32);
    NXclosedata(f);
    
    return(NX_OK);
  }
} /* mcdetector_out_axis_nexus */

/*******************************************************************************
* mcdetector_out_array_nexus: write detector array into current NXdata (1D,2D)
*   requires: NXdata to be opened
*******************************************************************************/
int mcdetector_out_array_nexus(NXhandle f, char *part, double *data, MCDETECTOR detector)
{
  
  int dims[3]={detector.m,detector.n,detector.p};  /* number of elements to write */
  int signal=1;
  int exists=0;
  int current_dims[3]={0,0,0};
  int ret=NX_OK;
  
  if (!f || !data || !detector.m || mcdisable_output_files) return(NX_OK);
  
  /* when this is a list, we set 1st dimension to NX_UNLIMITED for creation */
  if (strcasestr(detector.format, "list")) dims[0] = NX_UNLIMITED;
  
  /* create the data set in NXdata group */
  NXMDisableErrorReporting(); /* unactivate NeXus error messages, as creation may fail */
  /* NXcompmakedata fails with NX_UNLIMITED */
  if (strcasestr(detector.format, "list"))
    ret = NXmakedata(    f, part, NX_FLOAT64, detector.rank, dims);
  else
    ret = NXcompmakedata(f, part, NX_FLOAT64, detector.rank, dims, NX_COMP_LZW, dims);
  if (ret != NX_OK) {
    /* failed: data set already exists */
    int datatype=0;
    int rank=0;
    exists=1;
    /* inquire current size of data set (nb of events stored) */
    NXopendata(f, part);
    NXgetinfo(f, &rank, current_dims, &datatype);
    NXclosedata(f);
  }
  NXMEnableErrorReporting();  /* re-enable NeXus error messages */
  dims[0] = detector.m; /* restore actual dimension from data writing */
  
  /* open the data set */
  if (NXopendata(f, part) == NX_ERROR) {
    fprintf(stderr, "Warning: could not open DataSet %s '%s' (NeXus)\n",
      part, detector.title);
    return(NX_ERROR);
  }
  if (strcasestr(detector.format, "list")) {
    current_dims[1] = current_dims[2] = 0; /* set starting location for writing slab */
    NXputslab(f, data, current_dims, dims);
    if (!exists)
      printf("Events:   \"%s\"\n",  
        strlen(detector.filename) ? detector.filename : detector.component);
  } else {
    NXputdata (f, data);
  }
  
  if (strstr(part,"data") || strstr(part, "events")) {
    NXputattr(f, "signal", &signal, 1, NX_INT32);
    nxprintattr(f, "short_name", detector.filename && strlen(detector.filename) ? 
      detector.filename : detector.component);
  }
  nxprintattr(f, "long_name", "%s '%s'", part, detector.title);
  NXclosedata(f);
  
  return(NX_OK);
} /* mcdetector_out_array_nexus */

/*******************************************************************************
* mcdetector_out_data_nexus: write detector axes+data into current NXdata
*   The data:NXdetector is opened, then filename:NXdata
*   requires: NXentry to be opened
*******************************************************************************/
int mcdetector_out_data_nexus(NXhandle f, MCDETECTOR detector)
{
  char data_name[32];
  
  if (!f || !detector.m || mcdisable_output_files) return(NX_OK);
  
  strcpy_valid(data_name, 
    detector.filename && strlen(detector.filename) ? 
      detector.filename : detector.component);

  /* the NXdetector group has been created in mcinfo_out_nexus (mcsiminfo_init) */
  if (NXopengroup(f, "data", "NXdetector") == NX_OK) {

    /* the NXdata group has been created in mcdatainfo_out_nexus */
    if (NXopengroup(f, data_name, "NXdata") == NX_OK) {
  
      /* write axes, for histogram data sets, not for lists */
      if (!strcasestr(detector.format, "list")) {
        mcdetector_out_axis_nexus(f, detector.xlabel, detector.xvar, 
          1, detector.m, detector.xmin, detector.xmax);
          
        mcdetector_out_axis_nexus(f, detector.ylabel, detector.yvar, 
          2, detector.n, detector.ymin, detector.ymax);
          
        mcdetector_out_axis_nexus(f, detector.zlabel, detector.zvar, 
          3, detector.p, detector.zmin, detector.zmax);

      } /* !list */
      
      /* write the actual data (appended if already exists) */
      if (!strcasestr(detector.format, "list")) {
        mcdetector_out_array_nexus(f, "data", detector.p1, detector);
        mcdetector_out_array_nexus(f, "errors", detector.p2, detector);
        mcdetector_out_array_nexus(f, "ncount", detector.p0, detector);
      } else
        mcdetector_out_array_nexus(  f, "events", detector.p1, detector);
      
      NXclosegroup(f);
    } /* NXdata */
    NXclosegroup(f);
  } /* NXdetector */
  
  return(NX_OK);
} /* mcdetector_out_array_nexus */

#ifdef USE_MPI
/*******************************************************************************
* mcdetector_out_list_slaves: slaves send their list data to master which writes
*   requires: NXentry to be opened
* WARNING: this method has a flaw: it requires all nodes to flush the lists
*   the same number of times. In case one node is just below the buffer size
*   when finishing (e.g. monitor_nd), it may not trigger save but others may. 
*   Then the number of recv/send is not constant along nodes, and simulation stalls.  
*******************************************************************************/
MCDETECTOR mcdetector_out_list_slaves(MCDETECTOR detector)
{
  int     node_i=0;
  MPI_MASTER(
	     printf("\n** MPI master gathering slave node list data ** \n");
  );
  
  if (mpi_node_rank != mpi_node_root) {
    /* MPI slave: slaves send their data to master: 2 MPI_Send calls */
    /* m, n, p must be sent first, since all slaves do not have the same number of events */
    int mnp[3]={detector.m,detector.n,detector.p};

    if (mc_MPI_Send(mnp, 3, MPI_INT, mpi_node_root)!= MPI_SUCCESS)
      fprintf(stderr, "Warning: proc %i to master: MPI_Send mnp list error (mcdetector_out_list_slaves)\n", mpi_node_rank);
    if (!detector.p1
     || mc_MPI_Send(detector.p1, mnp[0]*mnp[1]*mnp[2], MPI_DOUBLE, mpi_node_root) != MPI_SUCCESS)
      fprintf(stderr, "Warning: proc %i to master: MPI_Send p1 list error: mnp=%i (mcdetector_out_list_slaves)\n", mpi_node_rank, abs(mnp[0]*mnp[1]*mnp[2]));
    /* slaves are done: sent mnp and p1 */
    return (detector);
  } /* end slaves */

  /* MPI master: receive data from slaves sequentially: 2 MPI_Recv calls */

  if (mpi_node_rank == mpi_node_root) {
    for(node_i=0; node_i<mpi_node_count; node_i++) {
      double *this_p1=NULL;                               /* buffer to hold the list from slaves */
      int     mnp[3]={0,0,0};  /* size of this buffer */
      if (node_i != mpi_node_root) { /* get data from slaves */
	if (mc_MPI_Recv(mnp, 3, MPI_INT, node_i) != MPI_SUCCESS)
	  fprintf(stderr, "Warning: master from proc %i: "
		  "MPI_Recv mnp list error (mcdetector_write_data)\n", node_i);
	if (mnp[0]*mnp[1]*mnp[2]) {
	  this_p1 = (double *)calloc(mnp[0]*mnp[1]*mnp[2], sizeof(double));
	  if (!this_p1 || mc_MPI_Recv(this_p1, abs(mnp[0]*mnp[1]*mnp[2]), MPI_DOUBLE, node_i)!= MPI_SUCCESS)
	    fprintf(stderr, "Warning: master from proc %i: "
		    "MPI_Recv p1 list error: mnp=%i (mcdetector_write_data)\n", node_i, mnp[0]*mnp[1]*mnp[2]);
	  else {
	    printf(". MPI master writing data for slave node %i\n",node_i);
	    detector.p1 = this_p1;
	    detector.m  = mnp[0]; detector.n  = mnp[1]; detector.p  = mnp[2];
	    
	    mcdetector_out_data_nexus(nxhandle, detector);
	  }
	}
      } /* if not master */
    } /* for */
  MPI_MASTER(
	     printf("\n** Done ** \n");
  );   
  }
}
#endif

MCDETECTOR mcdetector_out_0D_nexus(MCDETECTOR detector)
{
  /* Write data set information to NeXus file. */
  MPI_MASTER(
    mcdatainfo_out_nexus(nxhandle, detector);
  );
  
  return(detector);
} /* mcdetector_out_0D_ascii */

MCDETECTOR mcdetector_out_1D_nexus(MCDETECTOR detector_inc)
{
  MCDETECTOR detector = detector_inc;
  MPI_MASTER(
  mcdatainfo_out_nexus(nxhandle, detector);
  mcdetector_out_data_nexus(nxhandle, detector);
  );
  return(detector);
} /* mcdetector_out_1D_ascii */

MCDETECTOR mcdetector_out_2D_nexus(MCDETECTOR detector_inc)
{
  MCDETECTOR detector = detector_inc;
  MPI_MASTER(
  mcdatainfo_out_nexus(nxhandle, detector);
  mcdetector_out_data_nexus(nxhandle, detector);
  );
  
#ifdef USE_MPI // and USE_NEXUS
  /* NeXus: slave nodes have master write their lists */
  if (strcasestr(detector.format, "list") && mpi_node_count > 1) {
    mcdetector_out_list_slaves(detector);
  }
#endif /* USE_MPI */

  return(detector);
} /* mcdetector_out_2D_nexus */

#endif /* USE_NEXUS*/








/* ========================================================================== */

/*                            Main input functions                            */
/*            DETECTOR_OUT_xD function calls -> ascii or NeXus                */

/* ========================================================================== */

/*******************************************************************************
* mcsiminfo_init:   open SIM and write header
*******************************************************************************/
FILE *mcsiminfo_init(FILE *f)
{
  int exists=0;
  int index;
  
  /* check format */      
  if (!mcformat || !strlen(mcformat) 
   || !strcasecmp(mcformat, "MCSTAS") || !strcasecmp(mcformat, "MCXTRACE") 
   || !strcasecmp(mcformat, "PGPLOT") || !strcasecmp(mcformat, "GNUPLOT") || !strcasecmp(mcformat, "MCCODE")
   || !strcasecmp(mcformat, "MATLAB")) {
    mcformat="McCode";
#ifdef USE_NEXUS
  } else if (strcasestr(mcformat, "NeXus")) {
    /* Do nothing */
#endif
  } else {
    fprintf(stderr,
	    "Warning: You have requested the output format %s which is unsupported by this binary. Resetting to standard %s format.\n",mcformat ,"McCode");
    mcformat="McCode";
  }
  
  /* open the SIM file if not defined yet */
  if (mcsiminfo_file || mcdisable_output_files) 
    return (mcsiminfo_file);
    
#ifdef USE_NEXUS
  /* only master writes NeXus header: calls NXopen(nxhandle) */
  if (mcformat && strcasestr(mcformat, "NeXus")) {
	  MPI_MASTER(
	  mcsiminfo_file = mcnew_file(mcsiminfo_name, "h5", &exists);
    if(!mcsiminfo_file)
      fprintf(stderr,
	      "Warning: could not open simulation description file '%s'\n",
	      mcsiminfo_name);
	  else
	    mcinfo_out_nexus(nxhandle);
	  );
    return(mcsiminfo_file); /* points to nxhandle */
  }
#endif
  
  /* write main description file (only MASTER) */
  MPI_MASTER(

  mcsiminfo_file = mcnew_file(mcsiminfo_name, "sim", &exists);
  if(!mcsiminfo_file)
    fprintf(stderr,
	    "Warning: could not open simulation description file '%s'\n",
	    mcsiminfo_name);
  else
  {
    /* write SIM header */
    time_t t=time(NULL);
    mcsiminfo_out("%s simulation description file for %s.\n", 
      MCCODE_NAME, mcinstrument_name);
    mcsiminfo_out("Date:    %s", ctime(&t)); /* includes \n */
    mcsiminfo_out("Program: %s\n\n", MCCODE_STRING);
    
    mcsiminfo_out("begin instrument: %s\n", mcinstrument_name);
    mcinfo_out(   "  ", mcsiminfo_file);
    mcsiminfo_out("end instrument\n");

    mcsiminfo_out("\nbegin simulation: %s\n", mcdirname);
    mcruninfo_out("  ", mcsiminfo_file);
    mcsiminfo_out("end simulation\n");

  }
  return (mcsiminfo_file);
  
  ); /* MPI_MASTER */
  
} /* mcsiminfo_init */

/*******************************************************************************
*   mcsiminfo_close:  close SIM
*******************************************************************************/
void mcsiminfo_close()
{
  MPI_MASTER(
  if(mcsiminfo_file && !mcdisable_output_files) {
#ifdef USE_NEXUS
    if (mcformat && strcasestr(mcformat, "NeXus")) {
      time_t t=time(NULL);
      nxprintf(nxhandle, "end_time", ctime(&t));
      nxprintf(nxhandle, "duration", "%li", (long)t-mcstartdate);
      NXclosegroup(nxhandle); /* NXentry */
      NXclose(&nxhandle);
    } else
#endif
      fclose(mcsiminfo_file);
    );
    mcsiminfo_file = NULL;
  }
} /* mcsiminfo_close */

/*******************************************************************************
* mcdetector_out_0D: wrapper for 0D (single value).
*   Output single detector/monitor data (p0, p1, p2).
*   Title is t, component name is c.
*******************************************************************************/
MCDETECTOR mcdetector_out_0D(char *t, double p0, double p1, double p2,
                         char *c, Coords posa)
{
  /* import and perform basic detector analysis (and handle MPI reduce) */
  MCDETECTOR detector = mcdetector_import(mcformat,
    c, (t ? t : MCCODE_STRING " data"),
    1, 1, 1,
    "I", "", "",
    "I", "", "",
    0, 0, 0, 0, 0, 0, "",
    &p0, &p1, &p2, posa); /* write Detector: line */

#ifdef USE_NEXUS
  if (strcasestr(detector.format, "NeXus"))
    return(mcdetector_out_0D_nexus(detector));
  else
#endif
    return(mcdetector_out_0D_ascii(detector));
    
} /* mcdetector_out_0D */



/*******************************************************************************
* mcdetector_out_1D: wrapper for 1D.
*   Output 1d detector data (p0, p1, p2) for n bins linearly
*   distributed across the range x1..x2 (x1 is lower limit of first
*   bin, x2 is upper limit of last bin). Title is t, axis labels are xl
*   and yl. File name is f, component name is c.
*******************************************************************************/
MCDETECTOR mcdetector_out_1D(char *t, char *xl, char *yl,
        char *xvar, double x1, double x2,
        long n,
        double *p0, double *p1, double *p2, char *f,
        char *c, Coords posa)
{
  /* import and perform basic detector analysis (and handle MPI_Reduce) */
  MCDETECTOR detector = mcdetector_import(mcformat,
    c, (t ? t : MCCODE_STRING " 1D data"),
    n, 1, 1,
    xl, yl, (n > 1 ? "Signal per bin" : " Signal"),
    xvar, "(I,I_err)", "I",
    x1, x2, 0, 0, 0, 0, f,
    p0, p1, p2, posa); /* write Detector: line */
  if (!detector.p1 || !detector.m) return(detector);

#ifdef USE_NEXUS
  if (strcasestr(detector.format, "NeXus"))
    return(mcdetector_out_1D_nexus(detector));
  else
#endif
    return(mcdetector_out_1D_ascii(detector));
  
} /* mcdetector_out_1D */

/*******************************************************************************
* mcdetector_out_2D: wrapper for 2D.
*   special case for list: master creates file first, then slaves append their blocks without header
*******************************************************************************/
MCDETECTOR mcdetector_out_2D(char *t, char *xl, char *yl,
                  double x1, double x2, double y1, double y2,
                  long m, long n,
                  double *p0, double *p1, double *p2, char *f,
                  char *c, Coords posa)
{
  char xvar[CHAR_BUF_LENGTH];
  char yvar[CHAR_BUF_LENGTH];
  
  /* create short axes labels */
  if (xl && strlen(xl)) { strncpy(xvar, xl, CHAR_BUF_LENGTH); xvar[strcspn(xvar,"\n\r ")]='\0'; }
  else strcpy(xvar, "x");
  if (yl && strlen(yl)) { strncpy(yvar, yl, CHAR_BUF_LENGTH); yvar[strcspn(yvar,"\n\r ")]='\0'; }
  else strcpy(yvar, "y");

  MCDETECTOR detector;

  /* import and perform basic detector analysis (and handle MPI_Reduce) */
  if (labs(m) == 1) {/* n>1 on Y, m==1 on X: 1D, no X axis*/
    detector = mcdetector_import(mcformat,
      c, (t ? t : MCCODE_STRING " 1D data"),
      n, 1, 1,
      yl, "", "Signal per bin",
      yvar, "(I,Ierr)", "I",
      y1, y2, x1, x2, 0, 0, f,
      p0, p1, p2, posa); /* write Detector: line */
  } else if (labs(n)==1) {/* m>1 on X, n==1 on Y: 1D, no Y axis*/
    detector = mcdetector_import(mcformat,
      c, (t ? t : MCCODE_STRING " 1D data"),
      m, 1, 1,
      xl, "", "Signal per bin",
      xvar, "(I,Ierr)", "I",
      x1, x2, y1, y2, 0, 0, f,
      p0, p1, p2, posa); /* write Detector: line */
  }else {
    detector = mcdetector_import(mcformat,
      c, (t ? t : MCCODE_STRING " 2D data"),
      m, n, 1,
      xl, yl, "Signal per bin",
      xvar, yvar, "I",
      x1, x2, y1, y2, 0, 0, f,
      p0, p1, p2, posa); /* write Detector: line */
  }

  if (!detector.p1 || !detector.m) return(detector);

#ifdef USE_NEXUS
  if (strcasestr(detector.format, "NeXus"))
    return(mcdetector_out_2D_nexus(detector));
  else
#endif
    return(mcdetector_out_2D_ascii(detector));
  
} /* mcdetector_out_2D */

/*******************************************************************************
* mcdetector_out_list: wrapper for list output (calls out_2D with mcformat+"list").
*   m=number of events, n=size of each event
*******************************************************************************/
MCDETECTOR mcdetector_out_list(char *t, char *xl, char *yl,
                  long m, long n,
                  double *p1, char *f,
                  char *c, Coords posa)
{
  char       format_new[CHAR_BUF_LENGTH];
  char      *format_org;
  MCDETECTOR detector;
  
  format_org = mcformat;
  strcpy(format_new, mcformat);
  strcat(format_new, " list");
  mcformat = format_new;

  detector = mcdetector_out_2D(t, xl, yl,
                  1,labs(m),1,labs(n),
                  m,n,
                  NULL, p1, NULL, f,
                  c, posa);
  
  mcformat = format_org;
  return(detector);
}

/*******************************************************************************
 * mcuse_dir: set data/sim storage directory and create it,
 * or exit with error if exists
 ******************************************************************************/
static void
mcuse_dir(char *dir)
{
  if (!dir || !strlen(dir)) return;
#ifdef MC_PORTABLE
  fprintf(stderr, "Error: "
          "Directory output cannot be used with portable simulation (mcuse_dir)\n");
  exit(1);
#else  /* !MC_PORTABLE */
  /* handle file://directory URL type */
  if (strncmp(dir, "file://", strlen("file://")))
    mcdirname = dir;
  else
    mcdirname = dir+strlen("file://");
  
  
  
  MPI_MASTER(
    if(mkdir(mcdirname, 0777)) {
#ifndef DANSE
      fprintf(stderr, "Error: unable to create directory '%s' (mcuse_dir)\n", dir);
      fprintf(stderr, "(Maybe the directory already exists?)\n");
#endif
#ifdef USE_MPI
    MPI_Abort(MPI_COMM_WORLD, -1);
#endif
    exit(-1);
    }
  ); /* MPI_MASTER */
  
  /* remove trailing PATHSEP (if any) */
  while (strlen(mcdirname) && mcdirname[strlen(mcdirname) - 1] == MC_PATHSEP_C)
    mcdirname[strlen(mcdirname) - 1]='\0';
#endif /* !MC_PORTABLE */
} /* mcuse_dir */

/*******************************************************************************
* mcinfo: display instrument simulation info to stdout and exit
*******************************************************************************/
static void
mcinfo(void)
{
  fprintf(stdout, "begin instrument: %s\n", mcinstrument_name);
  mcinfo_out("  ", stdout);
  fprintf(stdout, "end instrument\n");
  fprintf(stdout, "begin simulation: %s\n", mcdirname ? mcdirname : ".");
  mcruninfo_out_backend("  ", stdout,1);
  fprintf(stdout, "end simulation\n");
  exit(0); /* includes MPI_Finalize in MPI mode */
} /* mcinfo */

#endif /* ndef MCCODE_R_IO_C */

/* end of the I/O section =================================================== */







/*******************************************************************************
* mcset_ncount: set total number of rays to generate
*******************************************************************************/
void mcset_ncount(unsigned long long int count)
{
  mcncount = count;
}

/* mcget_ncount: get total number of rays to generate */
unsigned long long int mcget_ncount(void)
{
  return mcncount;
}

/* mcget_run_num: get curent number of rays in TRACE */
unsigned long long int mcget_run_num(void)
{
  return mcrun_num;
}

/* mcsetn_arg: get ncount from a string argument */
static void
mcsetn_arg(char *arg)
{
  mcset_ncount((long long int) strtod(arg, NULL));
}

/* mcsetseed: set the random generator seed from a string argument */
static void
mcsetseed(char *arg)
{
  mcseed = atol(arg);
  if(mcseed) {
    srandom(mcseed);
  } else {
    fprintf(stderr, "Error: seed must not be zero (mcsetseed)\n");
    exit(1);
  }
}

/* Following part is only embedded when not redundent with mccode-r.h ========= */

#ifndef MCCODE_H

/* SECTION: MCDISPLAY support. =============================================== */

/*******************************************************************************
* Just output MCDISPLAY keywords to be caught by an external plotter client.
*******************************************************************************/

void mcdis_magnify(char *what){
  // Do nothing here, better use interactive zoom from the tools
}

void mcdis_line(double x1, double y1, double z1,
                double x2, double y2, double z2){
  printf("MCDISPLAY: multiline(2,%g,%g,%g,%g,%g,%g)\n",
         x1,y1,z1,x2,y2,z2);
}

void mcdis_dashed_line(double x1, double y1, double z1,
		       double x2, double y2, double z2, int n){
  int i;
  const double dx = (x2-x1)/(2*n+1);
  const double dy = (y2-y1)/(2*n+1);
  const double dz = (z2-z1)/(2*n+1);

  for(i = 0; i < n+1; i++)
    mcdis_line(x1 + 2*i*dx,     y1 + 2*i*dy,     z1 + 2*i*dz,
	       x1 + (2*i+1)*dx, y1 + (2*i+1)*dy, z1 + (2*i+1)*dz);
}

void mcdis_multiline(int count, ...){
  va_list ap;
  double x,y,z;

  printf("MCDISPLAY: multiline(%d", count);
  va_start(ap, count);
  while(count--)
    {
    x = va_arg(ap, double);
    y = va_arg(ap, double);
    z = va_arg(ap, double);
    printf(",%g,%g,%g", x, y, z);
    }
  va_end(ap);
  printf(")\n");
}

void mcdis_rectangle(char* plane, double x, double y, double z,
		     double width, double height){
  /* draws a rectangle in the plane           */
  /* x is ALWAYS width and y is ALWAYS height */
  if (strcmp("xy", plane)==0) {
    mcdis_multiline(5,
		    x - width/2, y - height/2, z,
		    x + width/2, y - height/2, z,
		    x + width/2, y + height/2, z,
		    x - width/2, y + height/2, z,
		    x - width/2, y - height/2, z);
  } else if (strcmp("xz", plane)==0) {
    mcdis_multiline(5,
		    x - width/2, y, z - height/2,
		    x + width/2, y, z - height/2,
		    x + width/2, y, z + height/2,
		    x - width/2, y, z + height/2,
		    x - width/2, y, z - height/2);
  } else if (strcmp("yz", plane)==0) {
    mcdis_multiline(5,
		    x, y - height/2, z - width/2,
		    x, y - height/2, z + width/2,
		    x, y + height/2, z + width/2,
		    x, y + height/2, z - width/2,
		    x, y - height/2, z - width/2);
  } else {

    fprintf(stderr, "Error: Definition of plane %s unknown\n", plane);
    exit(1);
  }
}

/*  draws a box with center at (x, y, z) and
    width (deltax), height (deltay), length (deltaz) */
void mcdis_box(double x, double y, double z,
	       double width, double height, double length){

  mcdis_rectangle("xy", x, y, z-length/2, width, height);
  mcdis_rectangle("xy", x, y, z+length/2, width, height);
  mcdis_line(x-width/2, y-height/2, z-length/2,
	     x-width/2, y-height/2, z+length/2);
  mcdis_line(x-width/2, y+height/2, z-length/2,
	     x-width/2, y+height/2, z+length/2);
  mcdis_line(x+width/2, y-height/2, z-length/2,
	     x+width/2, y-height/2, z+length/2);
  mcdis_line(x+width/2, y+height/2, z-length/2,
	     x+width/2, y+height/2, z+length/2);
}

void mcdis_circle(char *plane, double x, double y, double z, double r){
  printf("MCDISPLAY: circle('%s',%g,%g,%g,%g)\n", plane, x, y, z, r);
}

/* Draws a circle with center (x,y,z), radius (r), and in the plane
 * with normal (nx,ny,nz)*/
void mcdis_Circle(double x, double y, double z, double r, double nx, double ny, double nz){
    int i;
    if(nx==0 && ny && nz==0){
        for (i=0;i<24; i++){
            mcdis_line(x+r*sin(i*2*M_PI/24),y,z+r*cos(i*2*M_PI/24),
                    x+r*sin((i+1)*2*M_PI/24),y,z+r*cos((i+1)*2*M_PI/24));
        }
    }else{
        double mx,my,mz;
        /*generate perpendicular vector using (nx,ny,nz) and (0,1,0)*/
        vec_prod(mx,my,mz, 0,1,0, nx,ny,nz);
        NORM(mx,my,mz);
        /*draw circle*/
        for (i=0;i<24; i++){
            double ux,uy,uz;
            double wx,wy,wz;
            rotate(ux,uy,uz, mx,my,mz, i*2*M_PI/24, nx,ny,nz);
            rotate(wx,wy,wz, mx,my,mz, (i+1)*2*M_PI/24, nx,ny,nz);
            mcdis_line(x+ux*r,y+uy*r,z+uz*r,
                    x+wx*r,y+wy*r,z+wz*r);
        }
    }
}

/* Draws a cylinder with center at (x,y,z) with extent (r,height).
 * The cylinder axis is along the vector nx,ny,nz.
 * N determines how many vertical lines are drawn.*/
void mcdis_cylinder( double x, double y, double z,
        double r, double height, int N, double nx, double ny, double nz){
    int i;
    /*no lines make little sense - so trigger the default*/
    if(N<=0) N=5;

    NORM(nx,ny,nz);
    double h_2=height/2.0;
    mcdis_Circle(x+nx*h_2,y+ny*h_2,z+nz*h_2,r,nx,ny,nz);
    mcdis_Circle(x-nx*h_2,y-ny*h_2,z-nz*h_2,r,nx,ny,nz);

    double mx,my,mz;
    /*generate perpendicular vector using (nx,ny,nz) and (0,1,0)*/
    if(nx==0 && ny && nz==0){
        mx=my=0;mz=1;
    }else{
        vec_prod(mx,my,mz, 0,1,0, nx,ny,nz);
        NORM(mx,my,mz);
    }
    /*draw circle*/
    for (i=0; i<24; i++){
        double ux,uy,uz;
        rotate(ux,uy,uz, mx,my,mz, i*2*M_PI/24, nx,ny,nz);
        mcdis_line(x+nx*h_2+ux*r, y+ny*h_2+uy*r, z+nz*h_2+uz*r,
                 x-nx*h_2+ux*r, y-ny*h_2+uy*r, z-nz*h_2+uz*r);
    }
}

/* draws a sphere with center at (x,y,z) with extent (r)
 * The sphere is drawn using N longitudes and N latitudes.*/
void mcdis_sphere(double x, double y, double z, double r, int N){
    double nx,ny,nz;
    int i;
    /*no lines make little sense - so trigger the default*/
    if(N<=0) N=5;

    nx=0;ny=0;nz=1;
    mcdis_Circle(x,y,z,r,nx,ny,nz);
    for (i=1;i<N;i++){
        rotate(nx,ny,nz, nx,ny,nz, M_PI/N, 0,1,0);
        mcdis_Circle(x,y,z,r,nx,ny,nz);
    }
    /*lastly draw a great circle perpendicular to all N circles*/
    //mcdis_Circle(x,y,z,radius,1,0,0);

    for (i=1;i<=N;i++){
        double yy=-r+ 2*r*((double)i/(N+1));
        mcdis_Circle(x,y+yy ,z,  sqrt(r*r-yy*yy) ,0,1,0);
    }
}

/* SECTION: coordinates handling ============================================ */

/*******************************************************************************
* Since we use a lot of geometric calculations using Cartesian coordinates,
* we collect some useful routines here. However, it is also permissible to
* work directly on the underlying struct coords whenever that is most
* convenient (that is, the type Coords is not abstract).
*
* Coordinates are also used to store rotation angles around x/y/z axis.
*
* Since coordinates are used much like a basic type (such as double), the
* structure itself is passed and returned, rather than a pointer.
*
* At compile-time, the values of the coordinates may be unknown (for example
* a motor position). Hence coordinates are general expressions and not simple
* numbers. For this we used the type Coords_exp which has three CExp
* fields. For runtime (or calculations possible at compile time), we use
* Coords which contains three double fields.
*******************************************************************************/

/* coords_set: Assign coordinates. */
Coords
coords_set(MCNUM x, MCNUM y, MCNUM z)
{
  Coords a;

  a.x = x;
  a.y = y;
  a.z = z;
  return a;
}

/* coords_get: get coordinates. Required when 'x','y','z' are #defined as ray pars */
Coords
coords_get(Coords a, MCNUM *x, MCNUM *y, MCNUM *z)
{
  *x = a.x;
  *y = a.y;
  *z = a.z;
  return a;
}

/* coords_add: Add two coordinates. */
Coords
coords_add(Coords a, Coords b)
{
  Coords c;

  c.x = a.x + b.x;
  c.y = a.y + b.y;
  c.z = a.z + b.z;
  if (fabs(c.z) < 1e-14) c.z=0.0;
  return c;
}

/* coords_sub: Subtract two coordinates. */
Coords
coords_sub(Coords a, Coords b)
{
  Coords c;

  c.x = a.x - b.x;
  c.y = a.y - b.y;
  c.z = a.z - b.z;
  if (fabs(c.z) < 1e-14) c.z=0.0;
  return c;
}

/* coords_neg: Negate coordinates. */
Coords
coords_neg(Coords a)
{
  Coords b;

  b.x = -a.x;
  b.y = -a.y;
  b.z = -a.z;
  return b;
}

/* coords_scale: Scale a vector. */
Coords coords_scale(Coords b, double scale) {
  Coords a;

  a.x = b.x*scale;
  a.y = b.y*scale;
  a.z = b.z*scale;
  return a;
}

/* coords_sp: Scalar product: a . b */
double coords_sp(Coords a, Coords b) {
  double value;

  value = a.x*b.x + a.y*b.y + a.z*b.z;
  return value;
}

/* coords_xp: Cross product: a = b x c. */
Coords coords_xp(Coords b, Coords c) {
  Coords a;

  a.x = b.y*c.z - c.y*b.z;
  a.y = b.z*c.x - c.z*b.x;
  a.z = b.x*c.y - c.x*b.y;
  return a;
}

/* coords_len: Gives length of coords set. */
double coords_len(Coords a) {
  return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);
}

/* coords_mirror: Mirror a in plane (through the origin) defined by normal n*/
Coords coords_mirror(Coords a, Coords n) {
  double t = scalar_prod(n.x, n.y, n.z, n.x, n.y, n.z);
  Coords b;
  if (t!=1) {
    t = sqrt(t);
    n.x /= t;
    n.y /= t;
    n.z /= t;
  }
  t=scalar_prod(a.x, a.y, a.z, n.x, n.y, n.z);
  b.x = a.x-2*t*n.x;
  b.y = a.y-2*t*n.y;
  b.z = a.z-2*t*n.z;
  return b;
}

/* coords_print: Print out vector values. */
void coords_print(Coords a) {

  fprintf(stdout, "(%f, %f, %f)\n", a.x, a.y, a.z);
  return;
}

mcstatic void coords_norm(Coords* c) {
	double temp = coords_sp(*c,*c);

	// Skip if we will end dividing by zero
	if (temp == 0) return;

	temp = sqrt(temp);

	c->x /= temp;
	c->y /= temp;
	c->z /= temp;
}

/*******************************************************************************
* The Rotation type implements a rotation transformation of a coordinate
* system in the form of a double[3][3] matrix.
*
* Contrary to the Coords type in coords.c, rotations are passed by
* reference. Functions that yield new rotations do so by writing to an
* explicit result parameter; rotations are not returned from functions. The
* reason for this is that arrays cannot by returned from functions (though
* structures can; thus an alternative would have been to wrap the
* double[3][3] array up in a struct). Such are the ways of C programming.
*
* A rotation represents the tranformation of the coordinates of a vector when
* changing between coordinate systems that are rotated with respect to each
* other. For example, suppose that coordinate system Q is rotated 45 degrees
* around the Z axis with respect to coordinate system P. Let T be the
* rotation transformation representing a 45 degree rotation around Z. Then to
* get the coordinates of a vector r in system Q, apply T to the coordinates
* of r in P. If r=(1,0,0) in P, it will be (sqrt(1/2),-sqrt(1/2),0) in
* Q. Thus we should be careful when interpreting the sign of rotation angles:
* they represent the rotation of the coordinate systems, not of the
* coordinates (which has opposite sign).
*******************************************************************************/

/*******************************************************************************
* rot_set_rotation: Get transformation for rotation first phx around x axis,
* then phy around y, then phz around z.
*******************************************************************************/
void
rot_set_rotation(Rotation t, double phx, double phy, double phz)
{
  if ((phx == 0) && (phy == 0) && (phz == 0)) {
    t[0][0] = 1.0;
    t[0][1] = 0.0;
    t[0][2] = 0.0;
    t[1][0] = 0.0;
    t[1][1] = 1.0;
    t[1][2] = 0.0;
    t[2][0] = 0.0;
    t[2][1] = 0.0;
    t[2][2] = 1.0;
  } else {
    double cx = cos(phx);
    double sx = sin(phx);
    double cy = cos(phy);
    double sy = sin(phy);
    double cz = cos(phz);
    double sz = sin(phz);

    t[0][0] = cy*cz;
    t[0][1] = sx*sy*cz + cx*sz;
    t[0][2] = sx*sz - cx*sy*cz;
    t[1][0] = -cy*sz;
    t[1][1] = cx*cz - sx*sy*sz;
    t[1][2] = sx*cz + cx*sy*sz;
    t[2][0] = sy;
    t[2][1] = -sx*cy;
    t[2][2] = cx*cy;
  }
}

/*******************************************************************************
* rot_test_identity: Test if rotation is identity
*******************************************************************************/
int
rot_test_identity(Rotation t)
{
  return (t[0][0] + t[1][1] + t[2][2] == 3);
}

/*******************************************************************************
* rot_mul: Matrix multiplication of transformations (this corresponds to
* combining transformations). After rot_mul(T1, T2, T3), doing T3 is
* equal to doing first T2, then T1.
* Note that T3 must not alias (use the same array as) T1 or T2.
*******************************************************************************/
void
rot_mul(Rotation t1, Rotation t2, Rotation t3)
{
  if (rot_test_identity(t1)) {
    rot_copy(t3, t2);
  } else if (rot_test_identity(t2)) {
    rot_copy(t3, t1);
  } else {
    int i,j;
    for(i = 0; i < 3; i++)
      for(j = 0; j < 3; j++)
	t3[i][j] = t1[i][0]*t2[0][j] + t1[i][1]*t2[1][j] + t1[i][2]*t2[2][j];
  }
}

/*******************************************************************************
* rot_copy: Copy a rotation transformation (arrays cannot be assigned in C).
*******************************************************************************/
void
rot_copy(Rotation dest, Rotation src)
{
  int i,j;
  for(i = 0; i < 3; i++)
    for(j = 0; j < 3; j++)
      dest[i][j] = src[i][j];
}

/*******************************************************************************
* rot_transpose: Matrix transposition, which is inversion for Rotation matrices
*******************************************************************************/
void
rot_transpose(Rotation src, Rotation dst)
{
  dst[0][0] = src[0][0];
  dst[0][1] = src[1][0];
  dst[0][2] = src[2][0];
  dst[1][0] = src[0][1];
  dst[1][1] = src[1][1];
  dst[1][2] = src[2][1];
  dst[2][0] = src[0][2];
  dst[2][1] = src[1][2];
  dst[2][2] = src[2][2];
}

/*******************************************************************************
* rot_apply: returns t*a
*******************************************************************************/
Coords
rot_apply(Rotation t, Coords a)
{
  Coords b;
  if (rot_test_identity(t)) {
    return a;
  } else {
    b.x = t[0][0]*a.x + t[0][1]*a.y + t[0][2]*a.z;
    b.y = t[1][0]*a.x + t[1][1]*a.y + t[1][2]*a.z;
    b.z = t[2][0]*a.x + t[2][1]*a.y + t[2][2]*a.z;
    return b;
  }
}

/**
 * Pretty-printing of rotation matrices.
 */
void rot_print(Rotation rot) {
	printf("[ %4.2f %4.2f %4.2f ]\n",
			rot[0][0], rot[0][1], rot[0][2]);
	printf("[ %4.2f %4.2f %4.2f ]\n",
			rot[1][0], rot[1][1], rot[1][2]);
	printf("[ %4.2f %4.2f %4.2f ]\n\n",
			rot[2][0], rot[2][1], rot[2][2]);
}

/**
 * Vector product: used by vec_prod (mccode-r.h). Use coords_xp for Coords.
 */
mcstatic void vec_prod_func(double *x, double *y, double *z,
		double x1, double y1, double z1,
		double x2, double y2, double z2) {
    *x = (y1)*(z2) - (y2)*(z1);
    *y = (z1)*(x2) - (z2)*(x1);
    *z = (x1)*(y2) - (x2)*(y1);
}

/**
 * Scalar product: use coords_sp for Coords.
 */
mcstatic double scalar_prod(
		double x1, double y1, double z1,
		double x2, double y2, double z2) {
	return ((x1 * x2) + (y1 * y2) + (z1 * z2));
}

/*******************************************************************************
* mccoordschange: applies rotation to (x y z) and (vx vy vz) and Spin (sx,sy,sz)
*******************************************************************************/
void
mccoordschange(Coords a, Rotation t, double *x, double *y, double *z,
               double *vx, double *vy, double *vz, double *sx, double *sy, double *sz)
{
  Coords b, c;

  b.x = *x;
  b.y = *y;
  b.z = *z;
  c = rot_apply(t, b);
  b = coords_add(c, a);
  *x = b.x;
  *y = b.y;
  *z = b.z;

  if ( (vz && vy  && vx) && (*vz != 0.0 || *vx != 0.0 || *vy != 0.0) ) mccoordschange_polarisation(t, vx, vy, vz);

  if ( (sz && sy  && sx) && (*sz != 0.0 || *sx != 0.0 || *sy != 0.0) ) mccoordschange_polarisation(t, sx, sy, sz);

}

/*******************************************************************************
* mccoordschange_polarisation: applies rotation to vector (sx sy sz)
*******************************************************************************/
void
mccoordschange_polarisation(Rotation t, double *sx, double *sy, double *sz)
{
  Coords b, c;

  b.x = *sx;
  b.y = *sy;
  b.z = *sz;
  c = rot_apply(t, b);
  *sx = c.x;
  *sy = c.y;
  *sz = c.z;
}

/* SECTION: vector math  ==================================================== */

/* normal_vec_func: Compute normal vector to (x,y,z). */
mcstatic void normal_vec_func(double *nx, double *ny, double *nz,
                double x, double y, double z)
{
  double ax = fabs(x);
  double ay = fabs(y);
  double az = fabs(z);
  double l;
  if(x == 0 && y == 0 && z == 0)
  {
    *nx = 0;
    *ny = 0;
    *nz = 0;
    return;
  }
  if(ax < ay)
  {
    if(ax < az)
    {                           /* Use X axis */
      l = sqrt(z*z + y*y);
      *nx = 0;
      *ny = z/l;
      *nz = -y/l;
      return;
    }
  }
  else
  {
    if(ay < az)
    {                           /* Use Y axis */
      l = sqrt(z*z + x*x);
      *nx = z/l;
      *ny = 0;
      *nz = -x/l;
      return;
    }
  }
  /* Use Z axis */
  l = sqrt(y*y + x*x);
  *nx = y/l;
  *ny = -x/l;
  *nz = 0;
} /* normal_vec */

/*******************************************************************************
 * solve_2nd_order: second order equation solve: A*t^2 + B*t + C = 0
 * solve_2nd_order(&t1, NULL, A,B,C)
 *   returns 0 if no solution was found, or set 't1' to the smallest positive
 *   solution.
 * solve_2nd_order(&t1, &t2, A,B,C)
 *   same as with &t2=NULL, but also returns the second solution.
 * EXAMPLE usage for intersection of a trajectory with a plane in gravitation
 * field (gx,gy,gz):
 * The neutron starts at point r=(x,y,z) with velocityv=(vx vy vz). The plane
 * has a normal vector n=(nx,ny,nz) and contains the point W=(wx,wy,wz).
 * The problem consists in solving the 2nd order equation:
 *      1/2.n.g.t^2 + n.v.t + n.(r-W) = 0
 * so that A = 0.5 n.g; B = n.v; C = n.(r-W);
 * Without acceleration, t=-n.(r-W)/n.v
 ******************************************************************************/
int solve_2nd_order(double *t1, double *t2,
                  double A,  double B,  double C)
{
  int ret=0;

  if (!t1) return 0;
  *t1 = 0;
  if (t2) *t2=0;

  if (fabs(A) < 1E-10) /* approximate to linear equation: A ~ 0 */
  {
    if (B) {  *t1 = -C/B; ret=1; if (t2) *t2=*t1; }
    /* else no intersection: A=B=0 ret=0 */
  }
  else
  {
    double D;
    D = B*B - 4*A*C;
    if (D >= 0) /* Delta > 0: two solutions */
    {
      double sD, dt1, dt2;
      sD = sqrt(D);
      dt1 = (-B + sD)/2/A;
      dt2 = (-B - sD)/2/A;
      /* we identify very small values with zero */
      if (fabs(dt1) < 1e-10) dt1=0.0;
      if (fabs(dt2) < 1e-10) dt2=0.0;

      /* now we choose the smallest positive solution */
      if      (dt1<=0.0 && dt2>0.0) ret=2; /* dt2 positive */
      else if (dt2<=0.0 && dt1>0.0) ret=1; /* dt1 positive */
      else if (dt1> 0.0 && dt2>0.0)
      {  if (dt1 < dt2) ret=1; else ret=2; } /* all positive: min(dt1,dt2) */
      /* else two solutions are negative. ret=-1 */
      if (ret==1) { *t1 = dt1;  if (t2) *t2=dt2; }
      else        { *t1 = dt2;  if (t2) *t2=dt1; }
      ret=2;  /* found 2 solutions and t1 is the positive one */
    } /* else Delta <0: no intersection. ret=0 */
  }
  return(ret);
} /* solve_2nd_order */

/*******************************************************************************
 * randvec_target_circle: Choose random direction towards target at (x,y,z)
 * with given radius.
 * If radius is zero, choose random direction in full 4PI, no target.
 ******************************************************************************/
void
randvec_target_circle(double *xo, double *yo, double *zo, double *solid_angle,
               double xi, double yi, double zi, double radius)
{
  double l2, phi, theta, nx, ny, nz, xt, yt, zt, xu, yu, zu;

  if(radius == 0.0)
  {
    /* No target, choose uniformly a direction in full 4PI solid angle. */
    theta = acos (1 - rand0max(2));
    phi = rand0max(2 * PI);
    if(solid_angle)
      *solid_angle = 4*PI;
    nx = 1;
    ny = 0;
    nz = 0;
    yi = sqrt(xi*xi+yi*yi+zi*zi);
    zi = 0;
    xi = 0;
  }
  else
  {
    double costheta0;
    l2 = xi*xi + yi*yi + zi*zi; /* sqr Distance to target. */
    costheta0 = sqrt(l2/(radius*radius+l2));
    if (radius < 0) costheta0 *= -1;
    if(solid_angle)
    {
      /* Compute solid angle of target as seen from origin. */
        *solid_angle = 2*PI*(1 - costheta0);
    }

    /* Now choose point uniformly on circle surface within angle theta0 */
    theta = acos (1 - rand0max(1 - costheta0)); /* radius on circle */
    phi = rand0max(2 * PI); /* rotation on circle at given radius */
    /* Now, to obtain the desired vector rotate (xi,yi,zi) angle theta around a
       perpendicular axis u=i x n and then angle phi around i. */
    if(xi == 0 && zi == 0)
    {
      nx = 1;
      ny = 0;
      nz = 0;
    }
    else
    {
      nx = -zi;
      nz = xi;
      ny = 0;
    }
  }

  /* [xyz]u = [xyz]i x n[xyz] (usually vertical) */
  vec_prod(xu,  yu,  zu, xi, yi, zi,        nx, ny, nz);
  /* [xyz]t = [xyz]i rotated theta around [xyz]u */
  rotate  (xt,  yt,  zt, xi, yi, zi, theta, xu, yu, zu);
  /* [xyz]o = [xyz]t rotated phi around n[xyz] */
  rotate (*xo, *yo, *zo, xt, yt, zt, phi, xi, yi, zi);
} /* randvec_target_circle */

/*******************************************************************************
 * randvec_target_rect_angular: Choose random direction towards target at
 * (xi,yi,zi) with given ANGULAR dimension height x width. height=phi_x=[0,PI],
 * width=phi_y=[0,2*PI] (radians)
 * If height or width is zero, choose random direction in full 4PI, no target.
 *******************************************************************************/
void
randvec_target_rect_angular(double *xo, double *yo, double *zo, double *solid_angle,
               double xi, double yi, double zi, double width, double height, Rotation A)
{
  double theta, phi, nx, ny, nz, xt, yt, zt, xu, yu, zu;
  Coords tmp;
  Rotation Ainverse;

  rot_transpose(A, Ainverse);

  if(height == 0.0 || width == 0.0)
  {
    randvec_target_circle(xo, yo, zo, solid_angle,
               xi, yi, zi, 0);
    return;
  }
  else
  {
    if(solid_angle)
    {
      /* Compute solid angle of target as seen from origin. */
      *solid_angle = 2*fabs(width*sin(height/2));
    }

    /* Go to global coordinate system */

    tmp = coords_set(xi, yi, zi);
    tmp = rot_apply(Ainverse, tmp);
    coords_get(tmp, &xi, &yi, &zi);

    /* Now choose point uniformly on the unit sphere segment with angle theta/phi */
    phi   = width*randpm1()/2.0;
    theta = asin(randpm1()*sin(height/2.0));
    /* Now, to obtain the desired vector rotate (xi,yi,zi) angle theta around
       n, and then phi around u. */
    if(xi == 0 && zi == 0)
    {
      nx = 1;
      ny = 0;
      nz = 0;
    }
    else
    {
      nx = -zi;
      nz = xi;
      ny = 0;
    }
  }

  /* [xyz]u = [xyz]i x n[xyz] (usually vertical) */
  vec_prod(xu,  yu,  zu, xi, yi, zi,        nx, ny, nz);
  /* [xyz]t = [xyz]i rotated theta around [xyz]u */
  rotate  (xt,  yt,  zt, xi, yi, zi, theta, nx, ny, nz);
  /* [xyz]o = [xyz]t rotated phi around n[xyz] */
  rotate (*xo, *yo, *zo, xt, yt, zt, phi, xu,  yu,  zu);

  /* Go back to local coordinate system */
  tmp = coords_set(*xo, *yo, *zo);
  tmp = rot_apply(A, tmp);
  coords_get(tmp, &*xo, &*yo, &*zo);

} /* randvec_target_rect_angular */

/*******************************************************************************
 * randvec_target_rect_real: Choose random direction towards target at (xi,yi,zi)
 * with given dimension height x width (in meters !).
 *
 * Local emission coordinate is taken into account and corrected for 'order' times.
 * (See remarks posted to mcstas-users by George Apostolopoulus <gapost@ipta.demokritos.gr>)
 *
 * If height or width is zero, choose random direction in full 4PI, no target.
 *
 * Traditionally, this routine had the name randvec_target_rect - this is now a
 * a define (see mcstas-r.h) pointing here. If you use the old rouine, you are NOT
 * taking the local emmission coordinate into account.
*******************************************************************************/

void
randvec_target_rect_real(double *xo, double *yo, double *zo, double *solid_angle,
               double xi, double yi, double zi,
               double width, double height, Rotation A,
               double lx, double ly, double lz, int order)
{
  double dx, dy, dist, dist_p, nx, ny, nz, mx, my, mz, n_norm, m_norm;
  double cos_theta;
  Coords tmp;
  Rotation Ainverse;

  rot_transpose(A, Ainverse);

  if(height == 0.0 || width == 0.0)
  {
    randvec_target_circle(xo, yo, zo, solid_angle,
               xi, yi, zi, 0);
    return;
  }
  else
  {

    /* Now choose point uniformly on rectangle within width x height */
    dx = width*randpm1()/2.0;
    dy = height*randpm1()/2.0;

    /* Determine distance to target plane*/
    dist = sqrt(xi*xi + yi*yi + zi*zi);
    /* Go to global coordinate system */

    tmp = coords_set(xi, yi, zi);
    tmp = rot_apply(Ainverse, tmp);
    coords_get(tmp, &xi, &yi, &zi);

    /* Determine vector normal to trajectory axis (z) and gravity [0 1 0] */
    vec_prod(nx, ny, nz, xi, yi, zi, 0, 1, 0);

    /* This now defines the x-axis, normalize: */
    n_norm=sqrt(nx*nx + ny*ny + nz*nz);
    nx = nx/n_norm;
    ny = ny/n_norm;
    nz = nz/n_norm;

    /* Now, determine our y-axis (vertical in many cases...) */
    vec_prod(mx, my, mz, xi, yi, zi, nx, ny, nz);
    m_norm=sqrt(mx*mx + my*my + mz*mz);
    mx = mx/m_norm;
    my = my/m_norm;
    mz = mz/m_norm;

    /* Our output, random vector can now be defined by linear combination: */

    *xo = xi + dx * nx + dy * mx;
    *yo = yi + dx * ny + dy * my;
    *zo = zi + dx * nz + dy * mz;

    /* Go back to local coordinate system */
    tmp = coords_set(*xo, *yo, *zo);
    tmp = rot_apply(A, tmp);
    coords_get(tmp, &*xo, &*yo, &*zo);

    /* Go back to local coordinate system */
    tmp = coords_set(xi, yi, zi);
    tmp = rot_apply(A, tmp);
    coords_get(tmp, &xi, &yi, &zi);

    if (solid_angle) {
      /* Calculate vector from local point to remote random point */
      lx = *xo - lx;
      ly = *yo - ly;
      lz = *zo - lz;
      dist_p = sqrt(lx*lx + ly*ly + lz*lz);

      /* Adjust the 'solid angle' */
      /* 1/r^2 to the chosen point times cos(\theta) between the normal */
      /* vector of the target rectangle and direction vector of the chosen point. */
      cos_theta = (xi * lx + yi * ly + zi * lz) / (dist * dist_p);
      *solid_angle = width * height / (dist_p * dist_p);
      int counter;
      for (counter = 0; counter < order; counter++) {
	*solid_angle = *solid_angle * cos_theta;
      }
    }
  }
} /* randvec_target_rect_real */

/* SECTION: random numbers ================================================== */

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

/*
 * This is derived from the Berkeley source:
 *        @(#)random.c        5.5 (Berkeley) 7/6/88
 * It was reworked for the GNU C Library by Roland McGrath.
 * Rewritten to use reentrant functions by Ulrich Drepper, 1995.
 */

/*******************************************************************************
* Modified for McStas from glibc 2.0.7pre1 stdlib/random.c and
* stdlib/random_r.c.
*
* This way random() is more than four times faster compared to calling
* standard glibc random() on ix86 Linux, probably due to multithread support,
* ELF shared library overhead, etc. It also makes McStas generated
* simulations more portable (more likely to behave identically across
* platforms, important for parrallel computations).
*******************************************************************************/


#define        TYPE_3                3
#define        BREAK_3                128
#define        DEG_3                31
#define        SEP_3                3

static mc_int32_t randtbl[DEG_3 + 1] =
  {
    TYPE_3,

    -1726662223, 379960547, 1735697613, 1040273694, 1313901226,
    1627687941, -179304937, -2073333483, 1780058412, -1989503057,
    -615974602, 344556628, 939512070, -1249116260, 1507946756,
    -812545463, 154635395, 1388815473, -1926676823, 525320961,
    -1009028674, 968117788, -123449607, 1284210865, 435012392,
    -2017506339, -911064859, -370259173, 1132637927, 1398500161,
    -205601318,
  };

static mc_int32_t *fptr = &randtbl[SEP_3 + 1];
static mc_int32_t *rptr = &randtbl[1];
static mc_int32_t *state = &randtbl[1];
#define rand_deg DEG_3
#define rand_sep SEP_3
static mc_int32_t *end_ptr = &randtbl[sizeof (randtbl) / sizeof (randtbl[0])];

mc_int32_t
mc_random (void)
{
  mc_int32_t result;

  *fptr += *rptr;
  /* Chucking least random bit.  */
  result = (*fptr >> 1) & 0x7fffffff;
  ++fptr;
  if (fptr >= end_ptr)
  {
    fptr = state;
    ++rptr;
  }
  else
  {
    ++rptr;
    if (rptr >= end_ptr)
      rptr = state;
  }
  return result;
}

void
mc_srandom (unsigned int x)
{
  /* We must make sure the seed is not 0.  Take arbitrarily 1 in this case.  */
  state[0] = x ? x : 1;
  {
    long int i;
    for (i = 1; i < rand_deg; ++i)
    {
      /* This does:
         state[i] = (16807 * state[i - 1]) % 2147483647;
         but avoids overflowing 31 bits.  */
      long int hi = state[i - 1] / 127773;
      long int lo = state[i - 1] % 127773;
      long int test = 16807 * lo - 2836 * hi;
      state[i] = test + (test < 0 ? 2147483647 : 0);
    }
    fptr = &state[rand_sep];
    rptr = &state[0];
    for (i = 0; i < 10 * rand_deg; ++i)
      random ();
  }
}

/* "Mersenne Twister", by Makoto Matsumoto and Takuji Nishimura. */
/* See http://www.math.keio.ac.jp/~matumoto/emt.html for original source. */


/*
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using mt_srandom(seed)
   or init_by_array(init_key, key_length).

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote
        products derived from this software without specific prior written
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   Any feedback is very welcome.
   http://www.math.keio.ac.jp/matumoto/emt.html
   email: matumoto@math.keio.ac.jp
*/

#include <stdio.h>

/* Period parameters */
#define N 624
#define M 397
#define MATRIX_A 0x9908b0dfUL   /* constant vector a */
#define UPPER_MASK 0x80000000UL /* most significant w-r bits */
#define LOWER_MASK 0x7fffffffUL /* least significant r bits */

static unsigned long mt[N]; /* the array for the state vector  */
static int mti=N+1; /* mti==N+1 means mt[N] is not initialized */

/* initializes mt[N] with a seed */
void mt_srandom(unsigned long s)
{
    mt[0]= s & 0xffffffffUL;
    for (mti=1; mti<N; mti++) {
        mt[mti] =
            (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);
        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
        /* In the previous versions, MSBs of the seed affect   */
        /* only MSBs of the array mt[].                        */
        /* 2002/01/09 modified by Makoto Matsumoto             */
        mt[mti] &= 0xffffffffUL;
        /* for >32 bit machines */
    }
}

/* initialize by an array with array-length */
/* init_key is the array for initializing keys */
/* key_length is its length */
void init_by_array(unsigned long init_key[], unsigned long key_length)
{
    int i, j, k;
    mt_srandom(19650218UL);
    i=1; j=0;
    k = (N>key_length ? N : key_length);
    for (; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))
          + init_key[j] + j; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++; j++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
        if (j>=key_length) j=0;
    }
    for (k=N-1; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL))
          - i; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
    }

    mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */
}

/* generates a random number on [0,0xffffffff]-interval */
unsigned long mt_random(void)
{
    unsigned long y;
    static unsigned long mag01[2]={0x0UL, MATRIX_A};
    /* mag01[x] = x * MATRIX_A  for x=0,1 */

    if (mti >= N) { /* generate N words at one time */
        int kk;

        if (mti == N+1)   /* if mt_srandom() has not been called, */
            mt_srandom(5489UL); /* a default initial seed is used */

        for (kk=0;kk<N-M;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        for (;kk<N-1;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];

        mti = 0;
    }

    y = mt[mti++];

    /* Tempering */
    y ^= (y >> 11);
    y ^= (y << 7) & 0x9d2c5680UL;
    y ^= (y << 15) & 0xefc60000UL;
    y ^= (y >> 18);

    return y;
}

#undef N
#undef M
#undef MATRIX_A
#undef UPPER_MASK
#undef LOWER_MASK

/* End of "Mersenne Twister". */

/* End of McCode random number routine. */

/* randnorm: generate a random number from normal law */
double
randnorm(void)
{
  static double v1, v2, s;
  static int phase = 0;
  double X, u1, u2;

  if(phase == 0)
  {
    do
    {
      u1 = rand01();
      u2 = rand01();
      v1 = 2*u1 - 1;
      v2 = 2*u2 - 1;
      s = v1*v1 + v2*v2;
    } while(s >= 1 || s == 0);

    X = v1*sqrt(-2*log(s)/s);
  }
  else
  {
    X = v2*sqrt(-2*log(s)/s);
  }

  phase = 1 - phase;
  return X;
}

/**
 * Generate a random number from -1 to 1 with triangle distribution
 */
double randtriangle(void) {
	double randnum = rand01();
	if (randnum>0.5) return(1-sqrt(2*(randnum-0.5)));
	else return(sqrt(2*randnum)-1);
}

/**
 * Random number between 0.0 and 1.0 (including?)
 */
double rand01() {
	double randnum;
	randnum = (double) random();
	randnum /= (double) MC_RAND_MAX + 1;
	return randnum;
}

/**
 * Return a random number between 1 and -1
 */
double randpm1() {
	double randnum;
	randnum = (double) random();
	randnum /= ((double) MC_RAND_MAX + 1) / 2;
	randnum -= 1;
	return randnum;
}

/**
 * Return a random number between 0 and max.
 */
double rand0max(double max) {
	double randnum;
	randnum = (double) random();
	randnum /= ((double) MC_RAND_MAX + 1) / max;
	return randnum;
}

/**
 * Return a random number between min and max.
 */
double randminmax(double min, double max) {
	return rand0max(max - min) + max;
}

/* SECTION: main and signal handlers ======================================== */

/*******************************************************************************
* mchelp: displays instrument executable help with possible options
*******************************************************************************/
static void
mchelp(char *pgmname)
{
  int i;

  fprintf(stderr, "%s (%s) instrument simulation, generated with " MCCODE_STRING " (" MCCODE_DATE ")\n", mcinstrument_name, mcinstrument_source);
  fprintf(stderr, "Usage: %s [options] [parm=value ...]\n", pgmname);
  fprintf(stderr,
"Options are:\n"
"  -s SEED   --seed=SEED      Set random seed (must be != 0)\n"
"  -n COUNT  --ncount=COUNT   Set number of " MCCODE_PARTICLE "s to simulate.\n"
"  -d DIR    --dir=DIR        Put all data files in directory DIR.\n"
"  -t        --trace          Enable trace of " MCCODE_PARTICLE "s through instrument.\n"
"  -g        --gravitation    Enable gravitation for all trajectories.\n"
"  --no-output-files          Do not write any data files.\n"
"  -h        --help           Show this help message.\n"
"  -i        --info           Detailed instrument information.\n"
"  --format=FORMAT            Output data files using FORMAT="
   FLAVOR_UPPER
#ifdef USE_NEXUS
   " NEXUS"
#endif
"\n\n"
);
#ifdef USE_MPI
  fprintf(stderr,
  "This instrument has been compiled with MPI support.\n  Use 'mpirun %s [options] [parm=value ...]'.\n", pgmname);
#endif
  if(mcnumipar > 0)
  {
    fprintf(stderr, "Instrument parameters are:\n");
    for(i = 0; i < mcnumipar; i++)
      if (mcinputtable[i].val && strlen(mcinputtable[i].val))
        fprintf(stderr, "  %-16s(%s) [default='%s']\n", mcinputtable[i].name,
        (*mcinputtypes[mcinputtable[i].type].parminfo)(mcinputtable[i].name),
        mcinputtable[i].val);
      else
        fprintf(stderr, "  %-16s(%s)\n", mcinputtable[i].name,
        (*mcinputtypes[mcinputtable[i].type].parminfo)(mcinputtable[i].name));
  }

#ifndef NOSIGNALS
  fprintf(stderr, "Known signals are: "
#ifdef SIGUSR1
  "USR1 (status) "
#endif
#ifdef SIGUSR2
  "USR2 (save) "
#endif
#ifdef SIGBREAK
  "BREAK (save) "
#endif
#ifdef SIGTERM
  "TERM (save and exit)"
#endif
  "\n");
#endif /* !NOSIGNALS */
} /* mchelp */


/* mcshowhelp: show help and exit with 0 */
static void
mcshowhelp(char *pgmname)
{
  mchelp(pgmname);
  exit(0);
}

/* mcusage: display usage when error in input arguments and exit with 1 */
static void
mcusage(char *pgmname)
{
  fprintf(stderr, "Error: incorrect command line arguments\n");
  mchelp(pgmname);
  exit(1);
}

/* mcenabletrace: enable trace/mcdisplay or error if requires recompile */
static void
mcenabletrace(void)
{
 if(mctraceenabled)
  mcdotrace = 1;
 else
 {
   fprintf(stderr,
           "Error: trace not enabled (mcenabletrace)\n"
           "Please re-run the " MCCODE_NAME " compiler "
                   "with the --trace option, or rerun the\n"
           "C compiler with the MC_TRACE_ENABLED macro defined.\n");
   exit(1);
 }
}

/*******************************************************************************
* mcreadparams: request parameters from the prompt (or use default)
*******************************************************************************/
void
mcreadparams(void)
{
  int i,j,status;
  static char buf[CHAR_BUF_LENGTH];
  char *p;
  int len;

  MPI_MASTER(printf("Instrument parameters for %s (%s)\n",
                    mcinstrument_name, mcinstrument_source));

  for(i = 0; mcinputtable[i].name != 0; i++)
  {
    do
    {
      MPI_MASTER(
                 if (mcinputtable[i].val && strlen(mcinputtable[i].val))
                   printf("Set value of instrument parameter %s (%s) [default='%s']:\n",
                          mcinputtable[i].name,
                          (*mcinputtypes[mcinputtable[i].type].parminfo)
                          (mcinputtable[i].name), mcinputtable[i].val);
                 else
                   printf("Set value of instrument parameter %s (%s):\n",
                          mcinputtable[i].name,
                          (*mcinputtypes[mcinputtable[i].type].parminfo)
                          (mcinputtable[i].name));
                 fflush(stdout);
                 );
#ifdef USE_MPI
      if(mpi_node_rank == mpi_node_root)
        {
          p = fgets(buf, CHAR_BUF_LENGTH, stdin);
          if(p == NULL)
            {
              fprintf(stderr, "Error: empty input for paramater %s (mcreadparams)\n", mcinputtable[i].name);
              exit(1);
            }
        }
      else
        p = buf;
      MPI_Bcast(buf, CHAR_BUF_LENGTH, MPI_CHAR, mpi_node_root, MPI_COMM_WORLD);
#else /* !USE_MPI */
      p = fgets(buf, CHAR_BUF_LENGTH, stdin);
      if(p == NULL)
        {
          fprintf(stderr, "Error: empty input for paramater %s (mcreadparams)\n", mcinputtable[i].name);
          exit(1);
        }
#endif /* USE_MPI */
      len = strlen(buf);
      if (!len || (len == 1 && (buf[0] == '\n' || buf[0] == '\r')))
      {
        if (mcinputtable[i].val && strlen(mcinputtable[i].val)) {
          strncpy(buf, mcinputtable[i].val, CHAR_BUF_LENGTH);  /* use default value */
          len = strlen(buf);
        }
      }
      for(j = 0; j < 2; j++)
      {
        if(len > 0 && (buf[len - 1] == '\n' || buf[len - 1] == '\r'))
        {
          len--;
          buf[len] = '\0';
        }
      }

      status = (*mcinputtypes[mcinputtable[i].type].getparm)
                   (buf, mcinputtable[i].par);
      if(!status)
      {
        (*mcinputtypes[mcinputtable[i].type].error)(mcinputtable[i].name, buf);
        if (!mcinputtable[i].val || strlen(mcinputtable[i].val)) {
          fprintf(stderr, "       Change %s default value in instrument definition.\n", mcinputtable[i].name);
          exit(1);
        }
      }
    } while(!status);
  }
} /* mcreadparams */

/*******************************************************************************
* mcparseoptions: parse command line arguments (options, parameters)
*******************************************************************************/
void
mcparseoptions(int argc, char *argv[])
{
  int i, j;
  char *p;
  int paramset = 0, *paramsetarray;
  char *usedir=NULL;

  /* Add one to mcnumipar to avoid allocating zero size memory block. */
  paramsetarray = (int*)malloc((mcnumipar + 1)*sizeof(*paramsetarray));
  if(paramsetarray == NULL)
  {
    fprintf(stderr, "Error: insufficient memory (mcparseoptions)\n");
    exit(1);
  }
  for(j = 0; j < mcnumipar; j++)
    {
      paramsetarray[j] = 0;
      if (mcinputtable[j].val != NULL && strlen(mcinputtable[j].val))
      {
        int  status;
        char buf[CHAR_BUF_LENGTH];
        strncpy(buf, mcinputtable[j].val, CHAR_BUF_LENGTH);
        status = (*mcinputtypes[mcinputtable[j].type].getparm)
                   (buf, mcinputtable[j].par);
        if(!status) fprintf(stderr, "Invalid '%s' default value %s in instrument definition (mcparseoptions)\n", mcinputtable[j].name, buf);
        else paramsetarray[j] = 1;
      } else {
        (*mcinputtypes[mcinputtable[j].type].getparm)
          (NULL, mcinputtable[j].par);
        paramsetarray[j] = 0;
      }
    }
  for(i = 1; i < argc; i++)
  {
    if(!strcmp("-s", argv[i]) && (i + 1) < argc)
      mcsetseed(argv[++i]);
    else if(!strncmp("-s", argv[i], 2))
      mcsetseed(&argv[i][2]);
    else if(!strcmp("--seed", argv[i]) && (i + 1) < argc)
      mcsetseed(argv[++i]);
    else if(!strncmp("--seed=", argv[i], 7))
      mcsetseed(&argv[i][7]);
    else if(!strcmp("-n", argv[i]) && (i + 1) < argc)
      mcsetn_arg(argv[++i]);
    else if(!strncmp("-n", argv[i], 2))
      mcsetn_arg(&argv[i][2]);
    else if(!strcmp("--ncount", argv[i]) && (i + 1) < argc)
      mcsetn_arg(argv[++i]);
    else if(!strncmp("--ncount=", argv[i], 9))
      mcsetn_arg(&argv[i][9]);
    else if(!strcmp("-d", argv[i]) && (i + 1) < argc)
      usedir=argv[++i];  /* will create directory after parsing all arguments (end of this function) */
    else if(!strncmp("-d", argv[i], 2))
      usedir=&argv[i][2];
    else if(!strcmp("--dir", argv[i]) && (i + 1) < argc)
      usedir=argv[++i];
    else if(!strncmp("--dir=", argv[i], 6))
      usedir=&argv[i][6];
    else if(!strcmp("-h", argv[i]))
      mcshowhelp(argv[0]);
    else if(!strcmp("--help", argv[i]))
      mcshowhelp(argv[0]);
    else if(!strcmp("-i", argv[i])) {
      mcformat=FLAVOR_UPPER;
      mcinfo();
    }
    else if(!strcmp("--info", argv[i]))
      mcinfo();
    else if(!strcmp("-t", argv[i]))
      mcenabletrace();
    else if(!strcmp("--trace", argv[i]))
      mcenabletrace();
    else if(!strcmp("--gravitation", argv[i]))
      mcgravitation = 1;
    else if(!strcmp("-g", argv[i]))
      mcgravitation = 1;
    else if(!strncmp("--format=", argv[i], 9)) {
      mcformat=&argv[i][9];
    }
    else if(!strcmp("--format", argv[i]) && (i + 1) < argc) {
      mcformat=argv[++i];
    }
    else if(!strcmp("--no-output-files", argv[i]))
      mcdisable_output_files = 1;
    else if(argv[i][0] != '-' && (p = strchr(argv[i], '=')) != NULL)
    {
      *p++ = '\0';

      for(j = 0; j < mcnumipar; j++)
        if(!strcmp(mcinputtable[j].name, argv[i]))
        {
          int status;
          status = (*mcinputtypes[mcinputtable[j].type].getparm)(p,
                        mcinputtable[j].par);
          if(!status || !strlen(p))
          {
            (*mcinputtypes[mcinputtable[j].type].error)
              (mcinputtable[j].name, p);
            exit(1);
          }
          paramsetarray[j] = 1;
          paramset = 1;
          break;
        }
      if(j == mcnumipar)
      {                                /* Unrecognized parameter name */
        fprintf(stderr, "Error: unrecognized parameter %s (mcparseoptions)\n", argv[i]);
        exit(1);
      }
    }
    else if(argv[i][0] == '-') {
      fprintf(stderr, "Error: unrecognized option argument %s (mcparseoptions). Ignored.\n", argv[i++]);
    }
    else {
      fprintf(stderr, "Error: unrecognized argument %s (mcparseoptions). Aborting.\n", argv[i]);
      mcusage(argv[0]);
    }
  }
  if(!paramset)
    mcreadparams();                /* Prompt for parameters if not specified. */
  else
  {
    for(j = 0; j < mcnumipar; j++)
      if(!paramsetarray[j])
      {
        fprintf(stderr, "Error: Instrument parameter %s left unset (mcparseoptions)\n",
                mcinputtable[j].name);
        exit(1);
      }
  }
  free(paramsetarray);
#ifdef USE_MPI
  if (mcdotrace) mpi_node_count=1; /* disable threading when in trace mode */
#endif
  if (usedir && strlen(usedir) && !mcdisable_output_files) mcuse_dir(usedir);
} /* mcparseoptions */

#ifndef NOSIGNALS
mcstatic char  mcsig_message[256];


/*******************************************************************************
* sighandler: signal handler that makes simulation stop, and save results
*******************************************************************************/
void sighandler(int sig)
{
  /* MOD: E. Farhi, Sep 20th 2001: give more info */
  time_t t1, t0;
#define SIG_SAVE 0
#define SIG_TERM 1
#define SIG_STAT 2
#define SIG_ABRT 3

  printf("\n# " MCCODE_STRING ": [pid %i] Signal %i detected", getpid(), sig);
#ifdef USE_MPI
  printf(" [proc %i]", mpi_node_rank);
#endif
#if defined(SIGUSR1) && defined(SIGUSR2) && defined(SIGKILL)
  if (!strcmp(mcsig_message, "sighandler") && (sig != SIGUSR1) && (sig != SIGUSR2))
  {
    printf("\n# Fatal : unrecoverable loop ! Suicide (naughty boy).\n");
    kill(0, SIGKILL); /* kill myself if error occurs within sighandler: loops */
  }
#endif
  switch (sig) {
#ifdef SIGINT
    case SIGINT : printf(" SIGINT (interrupt from terminal, Ctrl-C)"); sig = SIG_TERM; break;
#endif
#ifdef SIGILL
    case SIGILL  : printf(" SIGILL (Illegal instruction)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGFPE
    case SIGFPE  : printf(" SIGFPE (Math Error)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGSEGV
    case SIGSEGV : printf(" SIGSEGV (Mem Error)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGTERM
    case SIGTERM : printf(" SIGTERM (Termination)"); sig = SIG_TERM; break;
#endif
#ifdef SIGABRT
    case SIGABRT : printf(" SIGABRT (Abort)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGQUIT
    case SIGQUIT : printf(" SIGQUIT (Quit from terminal)"); sig = SIG_TERM; break;
#endif
#ifdef SIGTRAP
    case SIGTRAP : printf(" SIGTRAP (Trace trap)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGPIPE
    case SIGPIPE : printf(" SIGPIPE (Broken pipe)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGUSR1
    case SIGUSR1 : printf(" SIGUSR1 (Display info)"); sig = SIG_STAT; break;
#endif
#ifdef SIGUSR2
    case SIGUSR2 : printf(" SIGUSR2 (Save simulation)"); sig = SIG_SAVE; break;
#endif
#ifdef SIGHUP
    case SIGHUP  : printf(" SIGHUP (Hangup/update)"); sig = SIG_SAVE; break;
#endif
#ifdef SIGBUS
    case SIGBUS  : printf(" SIGBUS (Bus error)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGURG
    case SIGURG  : printf(" SIGURG (Urgent socket condition)"); sig = SIG_ABRT; break;
#endif
#ifdef SIGBREAK
    case SIGBREAK: printf(" SIGBREAK (Break signal, Ctrl-Break)"); sig = SIG_SAVE; break;
#endif
    default : printf(" (look at signal list for signification)"); sig = SIG_ABRT; break;
  }
  printf("\n");
  printf("# Simulation: %s (%s) \n", mcinstrument_name, mcinstrument_source);
  printf("# Breakpoint: %s ", mcsig_message);
  if (strstr(mcsig_message, "Save") && (sig == SIG_SAVE))
    sig = SIG_STAT;
  SIG_MESSAGE("sighandler");
  if (mcget_ncount() == 0)
    printf("(0 %%)\n" );
  else
  {
    printf("%.2f %% (%10.1f/%10.1f)\n", 100.0*mcget_run_num()/mcget_ncount(), 1.0*mcget_run_num(), 1.0*mcget_ncount());
  }
  t0 = (time_t)mcstartdate;
  t1 = time(NULL);
  printf("# Date:      %s", ctime(&t1));
  printf("# Started:   %s", ctime(&t0));

  if (sig == SIG_STAT)
  {
    printf("# " MCCODE_STRING ": Resuming simulation (continue)\n");
    fflush(stdout);
    return;
  }
  else
  if (sig == SIG_SAVE)
  {
    printf("# " MCCODE_STRING ": Saving data and resume simulation (continue)\n");
    mcsave(NULL);
    fflush(stdout);
    return;
  }
  else
  if (sig == SIG_TERM)
  {
    printf("# " MCCODE_STRING ": Finishing simulation (save results and exit)\n");
    mcfinally();
    exit(0);
  }
  else
  {
    fflush(stdout);
    perror("# Last I/O Error");
    printf("# " MCCODE_STRING ": Simulation stop (abort).\n");
// This portion of the signal handling only works on UNIX
#if defined(__unix__) || defined(__APPLE__)
    signal(sig, SIG_DFL); /* force to use default sighandler now */
    kill(getpid(), sig);  /* and trigger it with the current signal */
#endif
    exit(-1);
  }
#undef SIG_SAVE
#undef SIG_TERM
#undef SIG_STAT
#undef SIG_ABRT

} /* sighandler */
#endif /* !NOSIGNALS */

/*******************************************************************************
* mccode_main: McCode main() function.
*******************************************************************************/
int mccode_main(int argc, char *argv[])
{
/*  double run_num = 0; */
  time_t  t;
#ifdef USE_MPI
  char mpi_node_name[MPI_MAX_PROCESSOR_NAME];
  int  mpi_node_name_len;
#endif /* USE_MPI */

#ifdef MAC
  argc = ccommand(&argv);
#endif

#ifdef USE_MPI
  MPI_Init(&argc,&argv);
  MPI_Comm_size(MPI_COMM_WORLD, &mpi_node_count); /* get number of nodes */
  MPI_Comm_rank(MPI_COMM_WORLD, &mpi_node_rank);
  MPI_Comm_set_name(MPI_COMM_WORLD, mcinstrument_name);
  MPI_Get_processor_name(mpi_node_name, &mpi_node_name_len);
#endif /* USE_MPI */

t = time(NULL);
mcseed = (long)t+(long)getpid();

#ifdef USE_MPI
/* *** print number of nodes *********************************************** */
  if (mpi_node_count > 1) {
    MPI_MASTER(
    printf("Simulation '%s' (%s): running on %i nodes (master is '%s', MPI version %i.%i).\n",
      mcinstrument_name, mcinstrument_source, mpi_node_count, mpi_node_name, MPI_VERSION, MPI_SUBVERSION);
    );
  }
#endif /* USE_MPI */
  
  mcstartdate = (long)t;  /* set start date before parsing options and creating sim file */

/* *** parse options ******************************************************* */
  SIG_MESSAGE("main (Start)");
  mcformat=getenv(FLAVOR_UPPER "_FORMAT") ?
           getenv(FLAVOR_UPPER "_FORMAT") : FLAVOR_UPPER;
  mcinstrument_exe = argv[0]; /* store the executable path */
  /* read simulation parameters and options */
  mcparseoptions(argc, argv); /* sets output dir and format */
  
#ifdef USE_MPI
  if (mpi_node_count > 1) {
    /* share the same seed, then adapt random seed for each node */
    MPI_Bcast(&mcseed, 1, MPI_LONG, 0, MPI_COMM_WORLD); /* root sends its seed to slaves */
    mcseed += mpi_node_rank; /* make sure we use different seeds per node */
  }
#endif
  srandom(mcseed);

/* *** install sig handler, but only once !! after parameters parsing ******* */
#ifndef NOSIGNALS
#ifdef SIGQUIT
  if (signal( SIGQUIT ,sighandler) == SIG_IGN)
    signal( SIGQUIT,SIG_IGN);   /* quit (ASCII FS) */
#endif
#ifdef SIGABRT
  if (signal( SIGABRT ,sighandler) == SIG_IGN)
    signal( SIGABRT,SIG_IGN);   /* used by abort, replace SIGIOT in the future */
#endif
#ifdef SIGTERM
  if (signal( SIGTERM ,sighandler) == SIG_IGN)
    signal( SIGTERM,SIG_IGN);   /* software termination signal from kill */
#endif
#ifdef SIGUSR1
  if (signal( SIGUSR1 ,sighandler) == SIG_IGN)
    signal( SIGUSR1,SIG_IGN);   /* display simulation status */
#endif
#ifdef SIGUSR2
  if (signal( SIGUSR2 ,sighandler) == SIG_IGN)
    signal( SIGUSR2,SIG_IGN);
#endif
#ifdef SIGHUP
  if (signal( SIGHUP ,sighandler) == SIG_IGN)
    signal( SIGHUP,SIG_IGN);
#endif
#ifdef SIGILL
  if (signal( SIGILL ,sighandler) == SIG_IGN)
    signal( SIGILL,SIG_IGN);    /* illegal instruction (not reset when caught) */
#endif
#ifdef SIGFPE
  if (signal( SIGFPE ,sighandler) == SIG_IGN)
    signal( SIGSEGV,SIG_IGN);    /* floating point exception */
#endif
#ifdef SIGBUS
  if (signal( SIGBUS ,sighandler) == SIG_IGN)
    signal( SIGSEGV,SIG_IGN);    /* bus error */
#endif
#ifdef SIGSEGV
  if (signal( SIGSEGV ,sighandler) == SIG_IGN)
    signal( SIGSEGV,SIG_IGN);   /* segmentation violation */
#endif
#endif /* !NOSIGNALS */
  mcsiminfo_init(NULL); /* open SIM */
  SIG_MESSAGE("main (Init)");
  mcinit();
#ifndef NOSIGNALS
#ifdef SIGINT
  if (signal( SIGINT ,sighandler) == SIG_IGN)
    signal( SIGINT,SIG_IGN);    /* interrupt (rubout) only after INIT */
#endif
#endif /* !NOSIGNALS */

/* ================ main particle generation/propagation loop ================ */
#if defined (USE_MPI)
  /* sliced Ncount on each MPI node */
  mcncount = mpi_node_count > 1 ?
    floor(mcncount / mpi_node_count) :
    mcncount; /* number of rays per node */
#endif

/* main particle event loop */
while(mcrun_num < mcncount || mcrun_num < mcget_ncount())
  {
#ifndef NEUTRONICS
    mcgenstate();
#endif
    /* old init: mcsetstate(0, 0, 0, 0, 0, 1, 0, sx=0, sy=1, sz=0, 1); */
    mcraytrace();
    mcrun_num++;
  }

#ifdef USE_MPI
 /* merge run_num from MPI nodes */
  if (mpi_node_count > 1) {
  double mcrun_num_double = (double)mcrun_num;
  mc_MPI_Sum(&mcrun_num_double, 1);
  mcrun_num = (unsigned long long)mcrun_num_double;
  }
#endif

/* save/finally executed by master node/thread */
  mcfinally();

#ifdef USE_MPI
  MPI_Finalize();
#endif /* USE_MPI */

  return 0;
} /* mccode_main */

#ifdef NEUTRONICS
/*Main neutronics function steers the McStas calls, initializes parameters etc */
/* Only called in case NEUTRONICS = TRUE */
void neutronics_main_(float *inx, float *iny, float *inz, float *invx, float *invy, float *invz, float *intime, float *insx, float *insy, float *insz, float *inw, float *outx, float *outy, float *outz, float *outvx, float *outvy, float *outvz, float *outtime, float *outsx, float *outsy, float *outsz, float *outwgt)
{

  extern double mcnx, mcny, mcnz, mcnvx, mcnvy, mcnvz;
  extern double mcnt, mcnsx, mcnsy, mcnsz, mcnp;

  /* External code governs iteration - McStas is iterated once per call to neutronics_main. I.e. below counter must be initiancated for each call to neutronics_main*/
  mcrun_num=0;

  time_t t;
  t = (time_t)mcstartdate;
  mcstartdate = t;  /* set start date before parsing options and creating sim file */
  mcinit();

  /* *** parse options *** */
  SIG_MESSAGE("main (Start)");
  mcformat=getenv(FLAVOR_UPPER "_FORMAT") ?
           getenv(FLAVOR_UPPER "_FORMAT") : FLAVOR_UPPER;

  /* Set neutron state based on input from neutronics code */
  mcsetstate(*inx,*iny,*inz,*invx,*invy,*invz,*intime,*insx,*insy,*insz,*inw);

  /* main neutron event loop - runs only one iteration */

  //mcstas_raytrace(&mcncount); /* prior to McStas 1.12 */

  mcallowbackprop = 1; //avoid absorbtion from negative dt
  int argc=1;
  char *argv[0];
  int dummy = mccode_main(argc, argv);

  *outx =  mcnx;
  *outy =  mcny;
  *outz =  mcnz;
  *outvx =  mcnvx;
  *outvy =  mcnvy;
  *outvz =  mcnvz;
  *outtime =  mcnt;
  *outsx =  mcnsx;
  *outsy =  mcnsy;
  *outsz =  mcnsz;
  *outwgt =  mcnp;

  return;
} /* neutronics_main */

#endif /*NEUTRONICS*/

#endif /* !MCCODE_H */
/* End of file "mccode-r.c". */
/* End of file "mccode-r.c". */

#line 4977 "ILL_H15_D11.c"

#line 1 "mcstas-r.c"
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/mcstas-r.c
*
* %Identification
* Written by: KN
* Date:    Aug 29, 1997
* Release: McStas X.Y
* Version: $Revision$
*
* Runtime system for McStas.
* Embedded within instrument in runtime mode.
*
* Usage: Automatically embbeded in the c code whenever required.
*
* $Id$
*
*******************************************************************************/

#ifndef MCSTAS_R_H
#include "mcstas-r.h"
#endif
#ifdef DANSE
#include "mcstas-globals.h"
#endif

/*******************************************************************************
* The I/O format definitions and functions
*******************************************************************************/

/*the magnet stack*/
#ifdef MC_POL_COMPAT
void (*mcMagnetPrecession) (double, double, double, double, double, double,
    double, double*, double*, double*, double, Coords, Rotation)=NULL;
Coords   mcMagnetPos;
Rotation mcMagnetRot;
double*  mcMagnetData                = NULL;
/* mcMagneticField(x, y, z, t, Bx, By, Bz) */
int (*mcMagneticField) (double, double, double, double,
    double*, double*, double*, void *) = NULL;
#endif

#ifndef MCSTAS_H

/*******************************************************************************
* mcstore_neutron: stores neutron coodinates into global array (per component)
*******************************************************************************/
void
mcstore_neutron(MCNUM *s, int index, double x, double y, double z,
               double vx, double vy, double vz, double t,
               double sx, double sy, double sz, double p)
{
    double *dptr = &s[11*index];
    *dptr++  = x;
    *dptr++  = y ;
    *dptr++  = z ;
    *dptr++  = vx;
    *dptr++  = vy;
    *dptr++  = vz;
    *dptr++  = t ;
    *dptr++  = sx;
    *dptr++  = sy;
    *dptr++  = sz;
    *dptr    = p ;
} /* mcstore_neutron */

/*******************************************************************************
* mcrestore_neutron: restores neutron coodinates from global array
*******************************************************************************/
void
mcrestore_neutron(MCNUM *s, int index, double *x, double *y, double *z,
               double *vx, double *vy, double *vz, double *t,
               double *sx, double *sy, double *sz, double *p)
{
    double *dptr = &s[11*index];
    *x  =  *dptr++;
    *y  =  *dptr++;
    *z  =  *dptr++;
    *vx =  *dptr++;
    *vy =  *dptr++;
    *vz =  *dptr++;
    *t  =  *dptr++;
    *sx =  *dptr++;
    *sy =  *dptr++;
    *sz =  *dptr++;
    *p  =  *dptr;
} /* mcrestore_neutron */

/*******************************************************************************
* mcsetstate: transfer parameters into global McStas variables 
*******************************************************************************/
void
mcsetstate(double x, double y, double z, double vx, double vy, double vz,
           double t, double sx, double sy, double sz, double p)
{
  extern double mcnx, mcny, mcnz, mcnvx, mcnvy, mcnvz;
  extern double mcnt, mcnsx, mcnsy, mcnsz, mcnp;

  mcnx = x;
  mcny = y;
  mcnz = z;
  mcnvx = vx;
  mcnvy = vy;
  mcnvz = vz;
  mcnt = t;
  mcnsx = sx;
  mcnsy = sy;
  mcnsz = sz;
  mcnp = p;
} /* mcsetstate */

/*******************************************************************************
* mcgenstate: set default neutron parameters 
*******************************************************************************/
void
mcgenstate(void)
{
  mcsetstate(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
  /* old initialisation: mcsetstate(0, 0, 0, 0, 0, 1, 0, sx=0, sy=1, sz=0, 1); */
}

/* intersection routines ==================================================== */

/*******************************************************************************
* inside_rectangle: Check if (x,y) is inside rectangle (xwidth, yheight) 
* return 0 if outside and 1 if inside 
*******************************************************************************/
int inside_rectangle(double x, double y, double xwidth, double yheight)
{
  if (x>-xwidth/2 && x<xwidth/2 && y>-yheight/2 && y<yheight/2)
    return 1;
  else
    return 0;
}

/*******************************************************************************
 * box_intersect: compute time intersection with a box
 * returns 0 when no intersection is found
 *      or 1 in case of intersection with resulting times dt_in and dt_out
 * This function written by Stine Nyborg, 1999. 
 *******************************************************************************/
int box_intersect(double *dt_in, double *dt_out,
                  double x, double y, double z,
                  double vx, double vy, double vz,
                  double dx, double dy, double dz)
{
  double x_in, y_in, z_in, tt, t[6], a, b;
  int i, count, s;

      /* Calculate intersection time for each of the six box surface planes
       *  If the box surface plane is not hit, the result is zero.*/

  if(vx != 0)
   {
    tt = -(dx/2 + x)/vx;
    y_in = y + tt*vy;
    z_in = z + tt*vz;
    if( y_in > -dy/2 && y_in < dy/2 && z_in > -dz/2 && z_in < dz/2)
      t[0] = tt;
    else
      t[0] = 0;

    tt = (dx/2 - x)/vx;
    y_in = y + tt*vy;
    z_in = z + tt*vz;
    if( y_in > -dy/2 && y_in < dy/2 && z_in > -dz/2 && z_in < dz/2)
      t[1] = tt;
    else
      t[1] = 0;
   }
  else
    t[0] = t[1] = 0;

  if(vy != 0)
   {
    tt = -(dy/2 + y)/vy;
    x_in = x + tt*vx;
    z_in = z + tt*vz;
    if( x_in > -dx/2 && x_in < dx/2 && z_in > -dz/2 && z_in < dz/2)
      t[2] = tt;
    else
      t[2] = 0;

    tt = (dy/2 - y)/vy;
    x_in = x + tt*vx;
    z_in = z + tt*vz;
    if( x_in > -dx/2 && x_in < dx/2 && z_in > -dz/2 && z_in < dz/2)
      t[3] = tt;
    else
      t[3] = 0;
   }
  else
    t[2] = t[3] = 0;

  if(vz != 0)
   {
    tt = -(dz/2 + z)/vz;
    x_in = x + tt*vx;
    y_in = y + tt*vy;
    if( x_in > -dx/2 && x_in < dx/2 && y_in > -dy/2 && y_in < dy/2)
      t[4] = tt;
    else
      t[4] = 0;

    tt = (dz/2 - z)/vz;
    x_in = x + tt*vx;
    y_in = y + tt*vy;
    if( x_in > -dx/2 && x_in < dx/2 && y_in > -dy/2 && y_in < dy/2)
      t[5] = tt;
    else
      t[5] = 0;
   }
  else
    t[4] = t[5] = 0;

  /* The intersection is evaluated and *dt_in and *dt_out are assigned */

  a = b = s = 0;
  count = 0;

  for( i = 0; i < 6; i = i + 1 )
    if( t[i] == 0 )
      s = s+1;
    else if( count == 0 )
    {
      a = t[i];
      count = 1;
    }
    else
    {
      b = t[i];
      count = 2;
    }

  if ( a == 0 && b == 0 )
    return 0;
  else if( a < b )
  {
    *dt_in = a;
    *dt_out = b;
    return 1;
  }
  else
  {
    *dt_in = b;
    *dt_out = a;
    return 1;
  }

} /* box_intersect */

/*******************************************************************************
 * cylinder_intersect: compute intersection with a cylinder
 * returns 0 when no intersection is found
 *      or 2/4/8/16 bits depending on intersection,
 *     and resulting times t0 and t1
 * Written by: EM,NB,ABA 4.2.98 
  *******************************************************************************/
int
cylinder_intersect(double *t0, double *t1, double x, double y, double z,
                   double vx, double vy, double vz, double r, double h)
{
  double D, t_in, t_out, y_in, y_out;
  int ret=1;

  D = (2*vx*x + 2*vz*z)*(2*vx*x + 2*vz*z)
    - 4*(vx*vx + vz*vz)*(x*x + z*z - r*r);

  if (D>=0)
  {
    if (vz*vz + vx*vx) {
      t_in  = (-(2*vz*z + 2*vx*x) - sqrt(D))/(2*(vz*vz + vx*vx));
      t_out = (-(2*vz*z + 2*vx*x) + sqrt(D))/(2*(vz*vz + vx*vx));
    } else if (vy) { /* trajectory parallel to cylinder axis */
      t_in = (-h/2-y)/vy;
      t_out = (h/2-y)/vy;
      if (t_in>t_out){
        double tmp=t_in;
        t_in=t_out;t_out=tmp;
      }
    } else return 0;
    y_in = vy*t_in + y;
    y_out =vy*t_out + y;

    if ( (y_in > h/2 && y_out > h/2) || (y_in < -h/2 && y_out < -h/2) )
      return 0;
    else
    {
      if (y_in > h/2)
        { t_in = ((h/2)-y)/vy; ret += 2; }
      else if (y_in < -h/2)
        { t_in = ((-h/2)-y)/vy; ret += 4; }
      if (y_out > h/2)
        { t_out = ((h/2)-y)/vy; ret += 8; }
      else if (y_out < -h/2)
        { t_out = ((-h/2)-y)/vy; ret += 16; }
    }
    *t0 = t_in;
    *t1 = t_out;
    return ret;
  }
  else
  {
    *t0 = *t1 = 0;
    return 0;
  }
} /* cylinder_intersect */


/*******************************************************************************
 * sphere_intersect: Calculate intersection between a line and a sphere.
 * returns 0 when no intersection is found
 *      or 1 in case of intersection with resulting times t0 and t1 
 *******************************************************************************/
int
sphere_intersect(double *t0, double *t1, double x, double y, double z,
                 double vx, double vy, double vz, double r)
{
  double A, B, C, D, v;

  v = sqrt(vx*vx + vy*vy + vz*vz);
  A = v*v;
  B = 2*(x*vx + y*vy + z*vz);
  C = x*x + y*y + z*z - r*r;
  D = B*B - 4*A*C;
  if(D < 0)
    return 0;
  D = sqrt(D);
  *t0 = (-B - D) / (2*A);
  *t1 = (-B + D) / (2*A);
  return 1;
} /* sphere_intersect */

/*******************************************************************************
 * plane_intersect: Calculate intersection between a plane and a line.
 * returns 0 when no intersection is found (i.e. line is parallel to the plane)
 * returns 1 or -1 when intersection time is positive and negative respectively
 *******************************************************************************/
int
plane_intersect(double *t, double x, double y, double z,
                 double vx, double vy, double vz, double nx, double ny, double nz, double wx, double wy, double wz)
{
  double s;
  if (fabs(s=scalar_prod(nx,ny,nz,vx,vy,vz))<FLT_EPSILON) return 0;
  *t = - scalar_prod(nx,ny,nz,x-wx,y-wy,z-wz)/s;
  if (*t<0) return -1;
  else return 1;
} /* plane_intersect */

#endif /* !MCSTAS_H */
/* End of file "mcstas-r.c". */

#line 5337 "ILL_H15_D11.c"
#ifdef MC_TRACE_ENABLED
int mctraceenabled = 1;
#else
int mctraceenabled = 0;
#endif
#define MCSTAS "/usr/share/mcstas/2.6rc1/"
int mcdefaultmain = 1;
char mcinstrument_name[] = "ILL_H15_D11";
char mcinstrument_source[] = "ILL_H15_D11.instr";
char *mcinstrument_exe=NULL; /* will be set to argv[0] in main */
int main(int argc, char *argv[]){return mccode_main(argc, argv);}
void mcinit(void);
void mcraytrace(void);
void mcsave(FILE *);
void mcfinally(void);
void mcdisplay(void);

/* Shared user declarations for all components 'Source_gen'. */
#line 140 "/usr/share/mcstas/2.6rc1/sources/Source_gen.comp"
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/read_table-lib.h
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas 1.6
* Version: $Revision$
*
* This file is to be imported by components that may read data from table files
* It handles some shared functions.
*
* This library may be used directly as an external library. It has no dependency
*
* Usage: within SHARE
* %include "read_table-lib"
*
*******************************************************************************/

#ifndef READ_TABLE_LIB_H
#define READ_TABLE_LIB_H "$Revision$"

#define READ_TABLE_STEPTOL  0.04 /* tolerancy for constant step approx */

#ifndef MC_PATHSEP_C
#ifdef WIN32
#define MC_PATHSEP_C '\\'
#define MC_PATHSEP_S "\\"
#else  /* !WIN32 */
#ifdef MAC
#define MC_PATHSEP_C ':'
#define MC_PATHSEP_S ":"
#else  /* !MAC */
#define MC_PATHSEP_C '/'
#define MC_PATHSEP_S "/"
#endif /* !MAC */
#endif /* !WIN32 */
#endif /* !MC_PATHSEP_C */

#ifndef MCSTAS
#ifdef WIN32
#define MCSTAS "C:\\mcstas\\lib"
#else  /* !WIN32 */
#ifdef MAC
#define MCSTAS ":mcstas:lib" /* ToDo: What to put here? */
#else  /* !MAC */
#define MCSTAS "/usr/local/lib/mcstas"
#endif /* !MAC */
#endif /* !WIN32 */
#endif /* !MCSTAS */

#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>

  typedef struct struct_table
  {
    char    filename[1024];
    long    filesize;
    char   *header;  /* text header, e.g. comments */
    double *data;    /* vector { x[0], y[0], ... x[n-1], y[n-1]... } */
    double  min_x;   /* min value of first column */
    double  max_x;   /* max value of first column */
    double  step_x;  /* minimal step value of first column */
    long    rows;    /* number of rows in matrix block */
    long    columns; /* number of columns in matrix block */

    long    begin;   /* start fseek index of block */
    long    end;     /* stop  fseek index of block */
    long    block_number;  /* block index. 0 is catenation of all */
    long    array_length;  /* number of elements in the t_Table array */
    char    monotonic;     /* true when 1st column/vector data is monotonic */
    char    constantstep;  /* true when 1st column/vector data has constant step */
    char    method[32];    /* interpolation method: nearest, linear */
  } t_Table;

/*maximum number of rows to rebin a table = 1M*/
enum { mcread_table_rebin_maxsize = 1000000 };

typedef struct t_Read_table_file_item {
    int ref_count;
    t_Table *table_ref;
} t_Read_table_file_item;

typedef enum enum_Read_table_file_actions {STORE,FIND,GC}  t_Read_table_file_actions;

/* read_table-lib function prototypes */
/* ========================================================================= */

/* 'public' functions */
long     Table_Read              (t_Table *Table, char *File, long block_number);
long     Table_Read_Offset       (t_Table *Table, char *File, long block_number,
                                  long *offset, long max_lines);
long     Table_Read_Offset_Binary(t_Table *Table, char *File, char *Type,
                                  long *Offset, long Rows, long Columns);
long     Table_Rebin(t_Table *Table); /* rebin table with regular 1st column and interpolate all columns 2:end */
long     Table_Info (t_Table Table);
double   Table_Index(t_Table Table,   long i, long j); /* get indexed value */
double   Table_Value(t_Table Table, double X, long j); /* search X in 1st column and return interpolated value in j-column */
t_Table *Table_Read_Array(char *File, long *blocks);
void     Table_Free_Array(t_Table *Table);
long     Table_Info_Array(t_Table *Table);
int      Table_SetElement(t_Table *Table, long i, long j, double value);
long     Table_Init(t_Table *Table, long rows, long columns); /* create a Table */
double   Table_Value2d(t_Table Table, double X, double Y);    /* same as Table_Index with non-integer indices and 2d interpolation */
MCDETECTOR Table_Write(t_Table Table, char*file, char*xl, char*yl, 
           double x1, double x2, double y1, double y2); /* write Table to disk */
void * Table_File_List_Handler(t_Read_table_file_actions action, void *item, void *item_modifier);
t_Table *Table_File_List_find(char *name, int block, int offset);
int Table_File_List_gc(t_Table *tab);
void *Table_File_List_store(t_Table *tab);

#define Table_ParseHeader(header, ...) \
  Table_ParseHeader_backend(header,__VA_ARGS__,NULL);

char **Table_ParseHeader_backend(char *header, ...);

/* private functions */
void Table_Free(t_Table *Table);
long Table_Read_Handle(t_Table *Table, FILE *fid, long block_number, long max_lines, char *name);
static void Table_Stat(t_Table *Table);
double Table_Interp1d(double x, double x1, double y1, double x2, double y2);
double Table_Interp1d_nearest(double x, double x1, double y1, double x2, double y2);
double Table_Interp2d(double x, double y, double x1, double y1, double x2, double y2,
double z11, double z12, double z21, double z22);

#endif

/* end of read_table-lib.h */
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/read_table-lib.c
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas CVS_090504
* Version: $Revision: 5052 $
*
* This file is to be imported by components that may read data from table files
* It handles some shared functions. Embedded within instrument in runtime mode.
*
* Usage: within SHARE
* %include "read_table-lib"
*
*******************************************************************************/

#ifndef READ_TABLE_LIB_H
#include "read_table-lib.h"
#endif


/*******************************************************************************
 * void *Table_File_List_Handler(action, item, item_modifier)
 *   ACTION: handle file entries in the read_table-lib file list. If a file is read - it is supposed to be
 *   stored in a list such that we can avoid reading the same file many times.
 *   input  action: FIND, STORE, GC. check if file exists in the list, store an item in the list, or check if it can be garbage collected.
 *   input item: depends on the action.
 *    FIND)  item is a filename, and item_modifier is the block number
 *    STORE) item is the Table to store - item_modifier is ignored
 *    GC)    item is the Table to check. If it has a ref_count >1 then this is simply decremented.
 *   return  depends on the action
 *    FIND)  return a reference to a table+ref_count item if found - NULL otherwise. I.e. NULL means the file has not been read before and must be read again.
 *    STORE) return NULL always
 *    GC)    return NULL if no garbage collection is needed, return an adress to the t_Table which should be garbage collected. 0x1 is returned if
 *           the item is not found in the list
*******************************************************************************/
void * Table_File_List_Handler(t_Read_table_file_actions action, void *item, void *item_modifier){

    /* logic here is Read_Table should include a call to FIND. If found the return value should just be used as
     * if the table had been read from disk. If not found then read the table and STORE.
     * Table_Free should include a call to GC. If this returns non-NULL then we should proceed with freeing the memory
     * associated with the table item - otherwise only decrement the reference counter since there are more references
     * that may need it.*/

    static t_Read_table_file_item read_table_file_list[1024];  
    static int read_table_file_count=0;

    t_Read_table_file_item *tr;
    switch(action){
        case FIND:
            /*interpret data item as a filename, if it is found return a pointer to the table and increment refcount.
             * if not found return the item itself*/
            tr=read_table_file_list;
            while ( tr->table_ref!=NULL ){
                int i=*((int*) item_modifier);
                int j=*( ((int*) item_modifier)+1);
                if ( !strcmp(tr->table_ref->filename,(char *) item) &&
                        tr->table_ref->block_number==i && tr->table_ref->begin==j ){
                    tr->ref_count++;
                    return (void *) tr;
                }
                tr++;
            }
            return NULL;
        case STORE:
            /*find an available slot and store references to table there*/
            tr=&(read_table_file_list[read_table_file_count++]);
            tr->table_ref = ((t_Table *) item);
            tr->ref_count++;
            return NULL;
        case GC:
            /* Should this item be garbage collected (freed) - if so scratch the entry and return the address of the item - 
             * else decrement ref_count and return NULL.
             * A non-NULL return expects the item to actually be freed afterwards.*/
            tr=read_table_file_list;
            while ( tr->table_ref!=NULL ){
                if ( tr->table_ref->data ==((t_Table *)item)->data && 
                        tr->table_ref->block_number == ((t_Table *)item)->block_number){
                    /*matching item found*/
                    if (tr->ref_count>1){
                        /*the item is found and no garbage collection needed*/
                        tr->ref_count--;
                        return NULL;
                    }else{
                        /* The item is found and the reference counter is 1.
                         * This means we should garbage collect. Move remaining list items up one slot,
                         * and return the table for garbage collection by caller*/
                        while (tr->table_ref!=NULL){
                            *tr=*(tr+1);
                            tr++;
                        }
                        read_table_file_count--;
                        return (t_Table *) item;
                    }
                }
                tr++;
            }
            /* item not found, and so should be garbage collected. This could be the case if freeing a
             * Table that has been constructed from code - not read from file. Return 0x1 to flag it for
             * collection.*/
            return (void *) 0x1 ;
    }
}

/* Access functions to the handler*/

/********************************************
 * t_Table *Table_File_List_find(char *name, int block, int offset)
 * input name: filename to search for in the file list
 * input block: data block in the file as each file may contain more than 1 data block.
 * return a ref. to a table if it is found (you may use this pointer and skip reading the file), NULL otherwise (i.e. go ahead and read the file)
*********************************************/
t_Table *Table_File_List_find(char *name, int block, int offset){
    int vars[2]={block,offset};
    t_Read_table_file_item *item = Table_File_List_Handler(FIND,name, vars);
    if (item == NULL){
        return NULL;
    }else{
        return item->table_ref;
    }
}
/********************************************
 * int Table_File_List_gc(t_Table *tab)
 * input tab: the table to check for references.
 * return 0: no garbage collection needed
 *        1: Table's data and header (at least) should be freed.
*********************************************/
int Table_File_List_gc(t_Table *tab){
    void *rval=Table_File_List_Handler(GC,tab,0);
    if (rval==NULL) return 0;
    else return 1;
}


/*****************************************************************************
 * void *Table_File_List_store(t_Table *tab)
 * input tab: pointer to table to store.
 * return None. 
*******************************************************************************/
void *Table_File_List_store(t_Table *tab){
    return Table_File_List_Handler(STORE,tab,0);
}


/*******************************************************************************
* FILE *Open_File(char *name, char *Mode, char *path)
*   ACTION: search for a file and open it. Optionally return the opened path.
*   input   name:  file name from which table should be extracted
*           mode: "r", "w", "a" or any valid fopen mode
*           path:  NULL or a pointer to at least 1024 allocated chars
*   return  initialized file handle or NULL in case of error
*******************************************************************************/

  FILE *Open_File(char *File, const char *Mode, char *Path)
  {
    char path[1024];
    FILE *hfile = NULL;
    
    if (!File || File[0]=='\0')                     return(NULL);
    if (!strcmp(File,"NULL") || !strcmp(File,"0"))  return(NULL);
    
    /* search in current or full path */
    strncpy(path, File, 1024);
    hfile = fopen(path, Mode);
    if(!hfile)
    {
      char dir[1024];

      if (!hfile && mcinstrument_source[0] != '\0' && strlen(mcinstrument_source)) /* search in instrument source location */
      {
        char *path_pos   = NULL;
        /* extract path: searches for last file separator */
        path_pos    = strrchr(mcinstrument_source, MC_PATHSEP_C);  /* last PATHSEP */
        if (path_pos) {
          long path_length = path_pos +1 - mcinstrument_source;  /* from start to path+sep */
          if (path_length) {
            strncpy(dir, mcinstrument_source, path_length);
            dir[path_length] = '\0';
            snprintf(path, 1024, "%s%c%s", dir, MC_PATHSEP_C, File);
            hfile = fopen(path, Mode);
          }
        }
      }
      if (!hfile && mcinstrument_exe[0] != '\0' && strlen(mcinstrument_exe)) /* search in PWD instrument executable location */
      {
        char *path_pos   = NULL;
        /* extract path: searches for last file separator */
        path_pos    = strrchr(mcinstrument_exe, MC_PATHSEP_C);  /* last PATHSEP */
        if (path_pos) {
          long path_length = path_pos +1 - mcinstrument_exe;  /* from start to path+sep */
          if (path_length) {
            strncpy(dir, mcinstrument_exe, path_length);
            dir[path_length] = '\0';
            snprintf(path, 1024, "%s%c%s", dir, MC_PATHSEP_C, File);
            hfile = fopen(path, Mode);
          }
        }
      }
      if (!hfile) /* search in HOME or . */
      {
        strcpy(dir, getenv("HOME") ? getenv("HOME") : ".");
        snprintf(path, 1024, "%s%c%s", dir, MC_PATHSEP_C, File);
        hfile = fopen(path, Mode);
      }
      if (!hfile) /* search in MCSTAS/data */
      {
        strcpy(dir, getenv(FLAVOR_UPPER) ? getenv(FLAVOR_UPPER) : MCSTAS);
        snprintf(path, 1024, "%s%c%s%c%s", dir, MC_PATHSEP_C, "data", MC_PATHSEP_C, File);
        hfile = fopen(path, Mode);
      }
      if (!hfile) /* search in MVCSTAS/contrib */
      {
        strcpy(dir, getenv(FLAVOR_UPPER) ? getenv(FLAVOR_UPPER) : MCSTAS);
        snprintf(path, 1024, "%s%c%s%c%s", dir, MC_PATHSEP_C, "contrib", MC_PATHSEP_C, File);
        hfile = fopen(path, Mode);
      }
      if(!hfile)
      {
        fprintf(stderr, "Error: Could not open input file '%s' (Open_File)\n", File);
        return (NULL);
      }
    }
    if (Path) strncpy(Path, path, 1024);
    return(hfile);
  } /* end Open_File */

/*******************************************************************************
* long Read_Table(t_Table *Table, char *name, int block_number)
*   ACTION: read a single Table from a text file
*   input   Table: pointer to a t_Table structure
*           name:  file name from which table should be extracted
*           block_number: if the file does contain more than one
*                 data block, then indicates which one to get (from index 1)
*                 a 0 value means append/catenate all
*   return  initialized single Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
* The routine stores any line starting with '#', '%' and ';' into the header
* File is opened, read and closed
* Other lines are interpreted as numerical data, and stored.
* Data block should be a rectangular matrix or vector.
* Data block may be rebinned with Table_Rebin (also sort in ascending order)
*******************************************************************************/
  long Table_Read(t_Table *Table, char *File, long block_number)
  { /* reads all or a single data block from 'file' and returns a Table structure  */
    return(Table_Read_Offset(Table, File, block_number, NULL, 0));
  } /* end Table_Read */

/*******************************************************************************
* long Table_Read_Offset(t_Table *Table, char *name, int block_number, long *offset
*                        long max_rows)
*   ACTION: read a single Table from a text file, starting at offset
*     Same as Table_Read(..) except:
*   input   offset:    pointer to an offset (*offset should be 0 at start)
*           max_rows: max number of data rows to read from file (0 means all)
*   return  initialized single Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
*           updated *offset position (where end of reading occured)
*******************************************************************************/
  long Table_Read_Offset(t_Table *Table, char *File,
                         long block_number, long *offset,
                         long max_rows)
  { /* reads all/a data block in 'file' and returns a Table structure  */
    FILE *hfile;
    long  nelements=0;
    long  begin=0;
    long  filesize=0;
    char  name[1024];
    char  path[1024];
    struct stat stfile;

    /*Need to be able to store the pointer*/
    if (!Table) return(-1);
    
    //if (offset && *offset) snprintf(name, 1024, "%s@%li", File, *offset);
    //else                   
    strncpy(name, File, 1024);
    if(offset && *offset){
        begin=*offset;
    }
    /* Check if the table has already been read from file.
     * If so just reuse the table, if not (this is flagged by returning NULL
     * set up a new table and read the data into it */
    t_Table *tab_p= Table_File_List_find(name,block_number,begin);
    if ( tab_p!=NULL ){
        /*table was found in the Table_File_List*/
        // printf("Reusing input file '%s' (Table_Read_Offset)\n", name);
        *Table=*tab_p;
        return Table->rows*Table->columns;
    }

    /* open the file */
    hfile = Open_File(File, "r", path);
    if (!hfile) return(-1);
    else {
      MPI_MASTER(
      printf("Opening input file '%s' (Table_Read_Offset)\n", path);
      );
    }
    
    /* read file state */
    stat(path,&stfile); filesize = stfile.st_size;
    if (offset && *offset) fseek(hfile, *offset, SEEK_SET);
    begin     = ftell(hfile);
    
    Table_Init(Table, 0, 0);

    /* read file content and set the Table */
    nelements = Table_Read_Handle(Table, hfile, block_number, max_rows, name);
    Table->begin = begin;
    Table->end   = ftell(hfile);
    Table->filesize = (filesize>0 ? filesize : 0);
    Table_Stat(Table);
    
    Table_File_List_store(Table);

    if (offset) *offset=Table->end;
    fclose(hfile);
    return(nelements);

  } /* end Table_Read_Offset */

/*******************************************************************************
* long Table_Read_Offset_Binary(t_Table *Table, char *File, char *type,
*                               long *offset, long rows, long columns)
*   ACTION: read a single Table from a binary file, starting at offset
*     Same as Table_Read_Offset(..) except that it handles binary files.
*   input   type: may be "float"/NULL or "double"
*           offset: pointer to an offset (*offset should be 0 at start)
*           rows   : number of rows (0 means read all)
*           columns: number of columns
*   return  initialized single Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
*           updated *offset position (where end of reading occured)
*******************************************************************************/
  long Table_Read_Offset_Binary(t_Table *Table, char *File, char *type,
                                long *offset, long rows, long columns)
  { /* reads all/a data block in binary 'file' and returns a Table structure  */
    long    nelements, sizeofelement;
    long    filesize;
    FILE   *hfile;
    char    path[1024];
    struct stat stfile;
    double *data;
    long    i;
    long    begin;

    if (!Table) return(-1);

    Table_Init(Table, 0, 0);
    
    /* open the file */
    hfile = Open_File(File, "r", path);
    if (!hfile) return(-1);
    else {
      MPI_MASTER(
      printf("Opening input file '%s' (Table_Read, Binary)\n", path);
      );
    }
    
    /* read file state */
    stat(File,&stfile);
    filesize = stfile.st_size;
    Table->filesize=filesize;
    
    /* read file content */
    if (type && !strcmp(type,"double")) sizeofelement = sizeof(double);
    else  sizeofelement = sizeof(float);
    if (offset && *offset) fseek(hfile, *offset, SEEK_SET);
    begin     = ftell(hfile);
    if (rows && filesize > sizeofelement*columns*rows)
      nelements = columns*rows;
    else nelements = (long)(filesize/sizeofelement);
    if (!nelements || filesize <= *offset) return(0);
    data    = (double*)malloc(nelements*sizeofelement);
    if (!data) {
      fprintf(stderr,"Error: allocating %ld elements for %s file '%s'. Too big (Table_Read_Offset_Binary).\n", nelements, type, File);
      exit(-1);
    }
    nelements = fread(data, sizeofelement, nelements, hfile);

    if (!data || !nelements)
    {
      fprintf(stderr,"Error: reading %ld elements from %s file '%s' (Table_Read_Offset_Binary)\n", nelements, type, File);
      exit(-1);
    }
    Table->begin   = begin;
    Table->end     = ftell(hfile);
    if (offset) *offset=Table->end;
    fclose(hfile);
    data = (double*)realloc(data, (double)nelements*sizeofelement);
    /* copy file data into Table */
    if (type && !strcmp(type,"double")) Table->data = data;
    else {
      float  *s;
      double *dataf;
      s     = (float*)data;
      dataf = (double*)malloc(sizeof(double)*nelements);
      for (i=0; i<nelements; i++)
        dataf[i]=s[i];
      free(data);
      Table->data = dataf;
    }
    strncpy(Table->filename, File, 1024);
    Table->rows    = nelements/columns;
    Table->columns = columns;
    Table->array_length = 1;
    Table->block_number = 1;

    Table_Stat(Table);

    return(nelements);
  } /* end Table_Read_Offset_Binary */

/*******************************************************************************
* long Table_Read_Handle(t_Table *Table, FILE *fid, int block_number, long max_rows, char *name)
*   ACTION: read a single Table from a text file handle (private)
*   input   Table:pointer to a t_Table structure
*           fid:  pointer to FILE handle
*           block_number: if the file does contain more than one
*                 data block, then indicates which one to get (from index 1)
*                 a 0 value means append/catenate all
*           max_rows: if non 0, only reads that number of lines
*   return  initialized single Table t_Table structure containing data, header, ...
*           modified Table t_Table structure containing data, header, ...
*           number of read elements (-1: error, 0:header only)
* The routine stores any line starting with '#', '%' and ';' into the header
* Other lines are interpreted as numerical data, and stored.
* Data block should be a rectangular matrix or vector.
* Data block may be rebined with Table_Rebin (also sort in ascending order)
*******************************************************************************/
  long Table_Read_Handle(t_Table *Table, FILE *hfile,
                         long block_number, long max_rows, char *name)
  { /* reads all/a data block from 'file' handle and returns a Table structure  */
    double *Data;
    char *Header              = NULL;
    long  malloc_size         = CHAR_BUF_LENGTH;
    long  malloc_size_h       = 4096;
    long  Rows = 0,   Columns = 0;
    long  count_in_array      = 0;
    long  count_in_header     = 0;
    long  block_Current_index = 0;
    char  flag_End_row_loop   = 0;

    if (!Table) return(-1);
    Table_Init(Table, 0, 0);
    if (name && name[0]!='\0') strncpy(Table->filename, name, 1024);

    if(!hfile) {
       fprintf(stderr, "Error: File handle is NULL (Table_Read_Handle).\n");
       return (-1);
    }
    Header = (char*)  calloc(malloc_size_h, sizeof(char));
    Data   = (double*)calloc(malloc_size,   sizeof(double));
    if ((Header == NULL) || (Data == NULL)) {
       fprintf(stderr, "Error: Could not allocate Table and Header (Table_Read_Handle).\n");
       return (-1);
    }

    int flag_In_array = 0;
    do { /* while (!flag_End_row_loop) */
      char  line[1024*CHAR_BUF_LENGTH];
      long  back_pos=0;   /* ftell start of line */

      back_pos = ftell(hfile);
      if (fgets(line, 1024*CHAR_BUF_LENGTH, hfile) != NULL) { /* analyse line */
        /* first skip blank and tabulation characters */
        int i = strspn(line, " \t");

        /* handle comments: stored in header */
        if (NULL != strchr("#%;/", line[i]))
        { /* line is a comment */
          count_in_header += strlen(line);
          if (count_in_header >= malloc_size_h) {
            /* if succeed and in array : add (and realloc if necessary) */
            malloc_size_h = count_in_header+4096;
            Header        = (char*)realloc(Header, malloc_size_h*sizeof(char));
          }
          strncat(Header, line, 4096);
          flag_In_array=0;
          /* exit line and file if passed desired block */
          if (block_number > 0 && block_number == block_Current_index) {
            flag_End_row_loop = 1;
          }

          /* Continue with next line */
          continue;
        }

        /* get the number of columns splitting line with strtok */
        char  *lexeme;
        char  flag_End_Line = 0;
        long  block_Num_Columns = 0;
        const char seps[] = " ,;\t\n\r";

        lexeme = strtok(line, seps);
        while (!flag_End_Line) {
          if ((lexeme != NULL) && (lexeme[0] != '\0')) {
            /* reading line: the token is not empty */
            double X;
            int    count=1;
            /* test if we have 'NaN','Inf' */
            if (!strncasecmp(lexeme,"NaN",3))
              X = 0;
            else if (!strncasecmp(lexeme,"Inf",3) || !strncasecmp(lexeme,"+Inf",4))
              X = FLT_MAX;
            else if (!strncasecmp(lexeme,"-Inf",4))
              X = -FLT_MAX;
            else
              count = sscanf(lexeme,"%lg",&X);
            if (count == 1) {
              /* reading line: the token is a number in the line */
              if (!flag_In_array) {
                /* reading num: not already in a block: starts a new data block */
                block_Current_index++;
                flag_In_array    = 1;
                block_Num_Columns= 0;
                if (block_number > 0) {
                  /* initialise a new data block */
                  Rows = 0;
                  count_in_array = 0;
                } /* else append */
              }
              /* reading num: all blocks or selected block */
              if (flag_In_array && (block_number == 0 ||
                  block_number == block_Current_index)) {
                /* starting block: already the desired number of rows ? */
                if (block_Num_Columns == 0 &&
                    max_rows > 0 && Rows >= max_rows) {
                  flag_End_Line      = 1;
                  flag_End_row_loop  = 1;
                  flag_In_array      = 0;
                  /* reposition to begining of line (ignore line) */
                  fseek(hfile, back_pos, SEEK_SET);
                } else { /* store into data array */
                  if (count_in_array >= malloc_size) {
                    /* realloc data buffer if necessary */
                    malloc_size = count_in_array*1.5;
                    Data = (double*) realloc(Data, malloc_size*sizeof(double));
                    if (Data == NULL) {
                      fprintf(stderr, "Error: Can not re-allocate memory %li (Table_Read_Handle).\n",
                              malloc_size*sizeof(double));
                      return (-1);
                    }
                  }
                  if (0 == block_Num_Columns) Rows++;
                  Data[count_in_array] = X;
                  count_in_array++;
                  block_Num_Columns++;
                }
              } /* reading num: end if flag_In_array */
            } /* end reading num: end if sscanf lexeme -> numerical */
            else {
              /* reading line: the token is not numerical in that line. end block */
              if (block_Current_index == block_number) {
                flag_End_Line = 1;
                flag_End_row_loop = 1;
              } else {
                flag_In_array = 0;
                flag_End_Line = 1;
              }
            }
          }
          else {
            /* no more tokens in line */
            flag_End_Line = 1;
            if (block_Num_Columns > 0) Columns = block_Num_Columns;
          }

          // parse next token
          lexeme = strtok(NULL, seps);

        } /* while (!flag_End_Line) */
      } /* end: if fgets */
      else flag_End_row_loop = 1; /* else fgets : end of file */

    } while (!flag_End_row_loop); /* end while flag_End_row_loop */

    Table->block_number = block_number;
    Table->array_length = 1;

    // shrink header to actual size (plus terminating 0-byte)
    if (count_in_header) {
      Header = (char*)realloc(Header, count_in_header*sizeof(char) + 1);
    }
    Table->header = Header;

    if (count_in_array*Rows*Columns == 0)
    {
      Table->rows         = 0;
      Table->columns      = 0;
      free(Data);
      return (0);
    }
    if (Rows * Columns != count_in_array)
    {
      fprintf(stderr, "Warning: Read_Table :%s %s Data has %li values that should be %li x %li\n",
        (Table->filename[0] != '\0' ? Table->filename : ""),
        (!block_number ? " catenated" : ""),
        count_in_array, Rows, Columns);
      Columns = count_in_array; Rows = 1;
    }
    Data     = (double*)realloc(Data, count_in_array*sizeof(double));
    Table->data         = Data;
    Table->rows         = Rows;
    Table->columns      = Columns;

    return (count_in_array);

  } /* end Table_Read_Handle */

/*******************************************************************************
* long Table_Rebin(t_Table *Table)
*   ACTION: rebin a single Table, sorting 1st column in ascending order
*   input   Table: single table containing data.
*                  The data block is reallocated in this process
*   return  updated Table with increasing, evenly spaced first column (index 0)
*           number of data elements (-1: error, 0:empty data)
*******************************************************************************/
  long Table_Rebin(t_Table *Table)
  {
    double new_step=0;
    long   i;
    /* performs linear interpolation on X axis (0-th column) */

    if (!Table) return(-1);
    if (!Table->data 
    || Table->rows*Table->columns == 0 || !Table->step_x)
      return(0);
    Table_Stat(Table); /* recompute statitstics and minimal step */
    new_step = Table->step_x; /* minimal step in 1st column */

    if (!(Table->constantstep)) /* not already evenly spaced */
    {
      long Length_Table;
      double *New_Table;

      Length_Table = ceil(fabs(Table->max_x - Table->min_x)/new_step)+1;
      /*return early if the rebinned table will become too large*/
      if (Length_Table > mcread_table_rebin_maxsize){
        fprintf(stderr,"WARNING: (Table_Rebin): Rebinning table from %s would exceed 1M rows. Skipping.\n", Table->filename); 
        return(Table->rows*Table->columns);
      }
      New_Table    = (double*)malloc(Length_Table*Table->columns*sizeof(double));

      for (i=0; i < Length_Table; i++)
      {
        long   j;
        double X;
        X = Table->min_x + i*new_step;
        New_Table[i*Table->columns] = X;
        for (j=1; j < Table->columns; j++)
          New_Table[i*Table->columns+j]
                = Table_Value(*Table, X, j);
      } /* end for i */

      Table->rows = Length_Table;
      Table->step_x = new_step;
      Table->max_x = Table->min_x + (Length_Table-1)*new_step; 
      /*max might not be the same anymore
       * Use Length_Table -1 since the first and laset rows are the limits of the defined interval.*/
      free(Table->data);
      Table->data = New_Table;
      Table->constantstep=1;
    } /* end else (!constantstep) */
    return (Table->rows*Table->columns);
  } /* end Table_Rebin */

/*******************************************************************************
* double Table_Index(t_Table Table, long i, long j)
*   ACTION: read an element [i,j] of a single Table
*   input   Table: table containing data
*           i : index of row      (0:Rows-1)
*           j : index of column   (0:Columns-1)
*   return  Value = data[i][j]
* Returns Value from the i-th row, j-th column of Table
* Tests are performed on indexes i,j to avoid errors
*******************************************************************************/

#ifndef MIN
#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
#endif

double Table_Index(t_Table Table, long i, long j)
{
  long AbsIndex;

  if (Table.rows == 1 || Table.columns == 1) {
    /* vector */
    j = MIN(MAX(0, i+j), Table.columns*Table.rows - 1);
    i = 0;
  } else {
    /* matrix */
    i = MIN(MAX(0, i), Table.rows - 1);
    j = MIN(MAX(0, j), Table.columns - 1);
  }

  /* handle vectors specifically */
  AbsIndex = i*(Table.columns)+j;

  if (Table.data != NULL)
    return (Table.data[AbsIndex]);
  else
    return 0;
} /* end Table_Index */

/*******************************************************************************
* void Table_SetElement(t_Table *Table, long i, long j, double value)
*   ACTION: set an element [i,j] of a single Table
*   input   Table: table containing data
*           i : index of row      (0:Rows-1)
*           j : index of column   (0:Columns-1)
*           value = data[i][j]
* Returns 0 in case of error
* Tests are performed on indexes i,j to avoid errors
*******************************************************************************/
int Table_SetElement(t_Table *Table, long i, long j,
                     double value)
{
  long AbsIndex;

  if (Table->rows == 1 || Table->columns == 1) {
    /* vector */
    j = MIN(MAX(0, i+j), Table->columns*Table->rows - 1); i=0;
  } else {
    /* matrix */
    i = MIN(MAX(0, i), Table->rows - 1);
    j = MIN(MAX(0, j), Table->columns - 1);
  }

  AbsIndex = i*(Table->columns)+j;
  if (Table->data != NULL) {
    Table->data[AbsIndex] = value;
    return 1;
  }

  return 0;
} /* end Table_SetElement */

/*******************************************************************************
* double Table_Value(t_Table Table, double X, long j)
*   ACTION: read column [j] of a single Table at row which 1st column is X
*   input   Table: table containing data.
*           X : data value in the first column (index 0)
*           j : index of column from which is extracted the Value (0:Columns-1)
*   return  Value = data[index for X][j] with linear interpolation
* Returns Value from the j-th column of Table corresponding to the
* X value for the 1st column (index 0)
* Tests are performed (within Table_Index) on indexes i,j to avoid errors
* NOTE: data should rather be monotonic, and evenly sampled.
*******************************************************************************/
double Table_Value(t_Table Table, double X, long j)
{
  long   Index = -1;
  double X1=0, Y1=0, X2=0, Y2=0;
  double ret=0;

  if (X > Table.max_x) return Table_Index(Table,Table.rows-1  ,j);
  if (X < Table.min_x) return Table_Index(Table,0  ,j);

  // Use constant-time lookup when possible
  if(Table.constantstep) {
    Index = (long)floor(
              (X - Table.min_x) / (Table.max_x - Table.min_x) * (Table.rows-1));
    X1 = Table_Index(Table,Index  ,0);
    X2 = Table_Index(Table,Index+1,0);
  }
  // Use binary search on large, monotonic tables
  else if(Table.monotonic && Table.rows > 100) {
    long left = Table.min_x;
    long right = Table.max_x;

    while (!((X1 <= X) && (X < X2)) && (right - left > 1)) {
      Index = (left + right) / 2;

      X1 = Table_Index(Table, Index-1, 0);
      X2 = Table_Index(Table, Index,   0);

      if (X < X1) {
        right = Index;
      } else {
        left  = Index;
      }
    }
  }

  // Fall back to linear search, if no-one else has set X1, X2 correctly
  if (!((X1 <= X) && (X < X2))) {
    /* look for index surrounding X in the table -> Index */
    for (Index=1; Index <= Table.rows-1; Index++) {
        X1 = Table_Index(Table, Index-1,0);
        X2 = Table_Index(Table, Index  ,0);
        if ((X1 <= X) && (X < X2)) break;
      } /* end for Index */
  }

  Y1 = Table_Index(Table,Index-1,j);
  Y2 = Table_Index(Table,Index  ,j);

  if (!strcmp(Table.method,"linear")) {
    ret = Table_Interp1d(X, X1,Y1, X2,Y2);
  }
  else if (!strcmp(Table.method,"nearest")) {
    ret = Table_Interp1d_nearest(X, X1,Y1, X2,Y2);
  }

  return ret;
} /* end Table_Value */

/*******************************************************************************
* double Table_Value2d(t_Table Table, double X, double Y)
*   ACTION: read element [X,Y] of a matrix Table
*   input   Table: table containing data.
*           X : row index, may be non integer
*           Y : column index, may be non integer
*   return  Value = data[index X][index Y] with bi-linear interpolation
* Returns Value for the indices [X,Y]
* Tests are performed (within Table_Index) on indexes i,j to avoid errors
* NOTE: data should rather be monotonic, and evenly sampled.
*******************************************************************************/
  double Table_Value2d(t_Table Table, double X, double Y)
  {
    long   x1,x2,y1,y2;
    double z11,z12,z21,z22;
    double ret=0;

    x1 = (long)floor(X);
    y1 = (long)floor(Y);

    if (x1 > Table.rows-1 || x1 < 0) {
      x2 = x1;
    } else {
      x2 = x1 + 1;
    }

    if (y1 > Table.columns-1 || y1 < 0) {
      y2 = y1;
    } else {
      y2 = y1 + 1;
    }

    z11 = Table_Index(Table, x1, y1);

    if (y2 != y1) z12=Table_Index(Table, x1, y2); else z12 = z11;
    if (x2 != x1) z21=Table_Index(Table, x2, y1); else z21 = z11;
    if (y2 != y1) z22=Table_Index(Table, x2, y2); else z22 = z21;

    if (!strcmp(Table.method,"linear"))
      ret = Table_Interp2d(X,Y, x1,y1,x2,y2, z11,z12,z21,z22);
    else {
      if (fabs(X-x1) < fabs(X-x2)) {
        if (fabs(Y-y1) < fabs(Y-y2)) ret = z11; else ret = z12;
      } else {
        if (fabs(Y-y1) < fabs(Y-y2)) ret = z21; else ret = z22;
      }
    }
    return ret;
  } /* end Table_Value2d */


/*******************************************************************************
* void Table_Free(t_Table *Table)
*   ACTION: free a single Table. First Call Table_File_list_gc. If this returns
*   non-zero it means there are more refernces to the table, and so the table
*   should not bee freed.
*   return: empty Table
*******************************************************************************/
  void Table_Free(t_Table *Table)
  {
    if( !Table_File_List_gc(Table) ){
       return;
    } 
    if (!Table) return;
    if (Table->data   != NULL) free(Table->data);
    if (Table->header != NULL) free(Table->header);
    Table->data   = NULL;
    Table->header = NULL;
  } /* end Table_Free */

/******************************************************************************
* void Table_Info(t_Table Table)
*    ACTION: print informations about a single Table
*******************************************************************************/
  long Table_Info(t_Table Table)
  {
    char buffer[256];
    long ret=0;

    if (!Table.block_number) strcpy(buffer, "catenated");
    else sprintf(buffer, "block %li", Table.block_number);
    printf("Table from file '%s' (%s)",
      Table.filename[0] != '\0' ? Table.filename : "", buffer);
    if ((Table.data != NULL) && (Table.rows*Table.columns))
    {
      printf(" is %li x %li ", Table.rows, Table.columns);
      if (Table.rows*Table.columns > 1)
        printf("(x=%g:%g)", Table.min_x, Table.max_x);
      else printf("(x=%g) ", Table.min_x);
      ret = Table.rows*Table.columns;
      if (Table.monotonic)    printf(", monotonic");
      if (Table.constantstep) printf(", constant step");
      printf(". interpolation: %s\n", Table.method);
    }
    else printf(" is empty.\n");

    if (Table.header && strlen(Table.header)) {
      char *header;
      int  i;
      header = malloc(80);
      if (!header) return(ret);
      for (i=0; i<80; header[i++]=0);
      strncpy(header, Table.header, 75);
      if (strlen(Table.header) > 75) {
        strcat( header, " ...");
      }
      for (i=0; i<strlen(header); i++)
        if (header[i] == '\n' || header[i] == '\r') header[i] = ';';
      printf("  '%s'\n", header);
      free(header);
    }

    return(ret);
  } /* end Table_Info */

/******************************************************************************
* long Table_Init(t_Table *Table, m, n)
*   ACTION: initialise a Table to empty m by n table
*   return: empty Table
******************************************************************************/
long Table_Init(t_Table *Table, long rows, long columns)
{
  double *data=NULL;
  long   i;

  if (!Table) return(0);

  Table->header  = NULL;
  Table->filename[0]= '\0';
  Table->filesize= 0;
  Table->min_x   = 0;
  Table->max_x   = 0;
  Table->step_x  = 0;
  Table->block_number = 0;
  Table->array_length = 0;
  Table->monotonic    = 0;
  Table->constantstep = 0;
  Table->begin   = 0;
  Table->end     = 0;
  strcpy(Table->method,"linear");

  if (rows*columns >= 1) {
    data    = (double*)malloc(rows*columns*sizeof(double));
    if (data) for (i=0; i < rows*columns; data[i++]=0);
    else {
      fprintf(stderr,"Error: allocating %ld double elements."
                     "Too big (Table_Init).\n", rows*columns);
      rows = columns = 0;
    }
  }
  Table->rows    = (rows >= 1 ? rows : 0);
  Table->columns = (columns >= 1 ? columns : 0);
  Table->data    = data;
  return(Table->rows*Table->columns);
} /* end Table_Init */

/******************************************************************************
* long Table_Write(t_Table Table, char *file, x1,x2, y1,y2)
*   ACTION: write a Table to disk (ascii).
*     when x1=x2=0 or y1=y2=0, the table default limits are used.
*   return: 0=all is fine, non-0: error
*******************************************************************************/
MCDETECTOR Table_Write(t_Table Table, char *file, char *xl, char *yl, 
  double x1, double x2, double y1, double y2)
{
  long    i =0;
  MCDETECTOR detector;

  if ((Table.data == NULL) && (Table.rows*Table.columns)) {
    detector.m = 0;
    return(detector); /* Table is empty - nothing to do */
  }
  if (!x1 && !x2) {
    x1 = Table.min_x;
    x2 = Table.max_x;
  }
  if (!y1 && !y2) {
    y1 = 1;
    y2 = Table.columns;
  }

  /* transfer content of the Table into a 2D detector */
  Coords coords = { 0, 0, 0};

  if (Table.rows == 1 || Table.columns == 1) {
    detector = mcdetector_out_1D(Table.filename,
                      xl ? xl : "", yl ? yl : "",
                      "x", x1, x2,
                      Table.rows * Table.columns,
                      NULL, Table.data, NULL,
                      file, file, coords);
  } else {
    detector = mcdetector_out_2D(Table.filename,
                      xl ? xl : "", yl ? yl : "",
                      x1, x2, y1, y2,
                      Table.rows, Table.columns,
                      NULL, Table.data, NULL,
                      file, file, coords);
  }
  return(detector);
}

/******************************************************************************
* void Table_Stat(t_Table *Table)
*   ACTION: computes min/max/mean step of 1st column for a single table (private)
*   return: updated Table
*******************************************************************************/
  static void Table_Stat(t_Table *Table)
  {
    long   i;
    double max_x, min_x;
    double row=1;
    char   monotonic=1;
    char   constantstep=1;
    double step=0;
    long n;

    if (!Table) return;
    if (!Table->rows || !Table->columns) return;
    if (Table->rows == 1) row=0; // single row
    max_x = -FLT_MAX;
    min_x =  FLT_MAX;
    n     = (row ? Table->rows : Table->columns);
    /* get min and max of first column/vector */
    for (i=0; i < n; i++)
    {
      double X;
      X = (row ? Table_Index(*Table,i  ,0)
                               : Table_Index(*Table,0, i));
      if (X < min_x) min_x = X;
      if (X > max_x) max_x = X;
    } /* for */
    
    /* test for monotonicity and constant step if the table is an XY or single vector */
    if (n > 1) {
      /* mean step */
      step = (max_x - min_x)/(n-1);
      /* now test if table is monotonic on first column, and get minimal step size */
      for (i=0; i < n-1; i++) {
        double X, diff;;
        X    = (row ? Table_Index(*Table,i  ,0)
                    : Table_Index(*Table,0,  i));
        diff = (row ? Table_Index(*Table,i+1,0)
                    : Table_Index(*Table,0,  i+1)) - X;
        if (diff && fabs(diff) < fabs(step)) step = diff;
        /* change sign ? */
        if ((max_x - min_x)*diff < 0 && monotonic)
          monotonic = 0;
      } /* end for */
      
      /* now test if steps are constant within READ_TABLE_STEPTOL */
      if(!step){
        /*means there's a disconitnuity -> not constantstep*/
        constantstep=0;
      }else if (monotonic) {
        for (i=0; i < n-1; i++) {
          double X, diff;
          X    = (row ? Table_Index(*Table,i  ,0)
              : Table_Index(*Table,0,  i));
          diff = (row ? Table_Index(*Table,i+1,0)
              : Table_Index(*Table,0,  i+1)) - X;
          if ( fabs(step)*(1+READ_TABLE_STEPTOL) < fabs(diff) ||
                fabs(diff) < fabs(step)*(1-READ_TABLE_STEPTOL) )
          { constantstep = 0; break; }
        }
      }

    }
    Table->step_x= step;
    Table->max_x = max_x;
    Table->min_x = min_x;
    Table->monotonic = monotonic;
    Table->constantstep = constantstep;
  } /* end Table_Stat */

/******************************************************************************
* t_Table *Table_Read_Array(char *File, long *blocks)
*   ACTION: read as many data blocks as available, iteratively from file
*   return: initialized t_Table array, last element is an empty Table.
*           the number of extracted blocks in non NULL pointer *blocks
*******************************************************************************/
  t_Table *Table_Read_Array(char *File, long *blocks)
  {
    t_Table *Table_Array=NULL;
    long offset=0;
    long block_number=0;
    long allocated=256;
    long nelements=1;

    /* first allocate an initial empty t_Table array */
    Table_Array = (t_Table *)malloc(allocated*sizeof(t_Table));
    if (!Table_Array) {
      fprintf(stderr, "Error: Can not allocate memory %li (Table_Read_Array).\n",
         allocated*sizeof(t_Table));
      *blocks = 0;
      return (NULL);
    }

    while (nelements > 0)
    {
      t_Table Table;

      /* if ok, set t_Table block number else exit loop */
      block_number++;
      Table.block_number = block_number;
      
      /* access file at offset and get following block. Block number is from the set offset
       * hence the hardcoded 1 - i.e. the next block counted from offset.*/
      nelements = Table_Read_Offset(&Table, File, 1, &offset,0);
      /*if the block is empty - don't store it*/
      if (nelements>0){
          /* if t_Table array is not long enough, expand and realocate */
          if (block_number >= allocated-1) {
              allocated += 256;
              Table_Array = (t_Table *)realloc(Table_Array,
                      allocated*sizeof(t_Table));
              if (!Table_Array) {
                  fprintf(stderr, "Error: Can not re-allocate memory %li (Table_Read_Array).\n",
                          allocated*sizeof(t_Table));
                  *blocks = 0;
                  return (NULL);
              }
          }
          /* store it into t_Table array */
          //snprintf(Table.filename, 1024, "%s#%li", File, block_number-1);
          Table_Array[block_number-1] = Table;
      }
      /* continues until we find an empty block */
    }
    /* send back number of extracted blocks */
    if (blocks) *blocks = block_number-1;

    /* now store total number of elements in Table array */
    for (offset=0; offset < block_number;
      Table_Array[offset++].array_length = block_number-1);

    return(Table_Array);
  } /* end Table_Read_Array */
/*******************************************************************************
* void Table_Free_Array(t_Table *Table)
*   ACTION: free a Table array
*******************************************************************************/
  void Table_Free_Array(t_Table *Table)
  {
    long index;
    if (!Table) return;
    for (index=0;index < Table[0].array_length; index++){
            Table_Free(&Table[index]);
    }
    free(Table);
  } /* end Table_Free_Array */

/******************************************************************************
* long Table_Info_Array(t_Table *Table)
*    ACTION: print informations about a Table array
*    return: number of elements in the Table array
*******************************************************************************/
  long Table_Info_Array(t_Table *Table)
  {
    long index=0;

    if (!Table) return(-1);
    while (index < Table[index].array_length
       && (Table[index].data || Table[index].header)
       && (Table[index].rows*Table[index].columns) ) {
      Table_Info(Table[index]);
      index++;
    }
    printf("This Table array contains %li elements\n", index);
    return(index);
  } /* end Table_Info_Array */

/******************************************************************************
* char **Table_ParseHeader(char *header, symbol1, symbol2, ..., NULL)
*    ACTION: search for char* symbols in header and return their value or NULL
*            the search is not case sensitive.
*            Last argument MUST be NULL
*    return: array of char* with line following each symbol, or NULL if not found
*******************************************************************************/
#ifndef MyNL_ARGMAX
#define MyNL_ARGMAX 50
#endif

char **Table_ParseHeader_backend(char *header, ...){
  va_list ap;
  char exit_flag=0;
  int counter   =0;
  char **ret    =NULL;
  if (!header || header[0]=='\0') return(NULL);

  ret = (char**)calloc(MyNL_ARGMAX, sizeof(char*));
  if (!ret) {
    printf("Table_ParseHeader: Cannot allocate %i values array for Parser (Table_ParseHeader).\n",
      MyNL_ARGMAX);
    return(NULL);
  }
  for (counter=0; counter < MyNL_ARGMAX; ret[counter++] = NULL);
  counter=0;

  va_start(ap, header);
  while(!exit_flag && counter < MyNL_ARGMAX-1)
  {
    char *arg_char=NULL;
    char *pos     =NULL;
    /* get variable argument value as a char */
    arg_char = va_arg(ap, char *);
    if (!arg_char || arg_char[0]=='\0'){
      exit_flag = 1; break;
    }
    /* search for the symbol in the header */
    pos = (char*)strcasestr(header, arg_char);
    if (pos) {
      char *eol_pos;
      eol_pos = strchr(pos+strlen(arg_char), '\n');
      if (!eol_pos)
        eol_pos = strchr(pos+strlen(arg_char), '\r');
      if (!eol_pos)
        eol_pos = pos+strlen(pos)-1;
      ret[counter] = (char*)malloc(eol_pos - pos);
      if (!ret[counter]) {
        printf("Table_ParseHeader: Cannot allocate value[%i] array for Parser searching for %s (Table_ParseHeader).\n",
          counter, arg_char);
        exit_flag = 1; break;
      }
      strncpy(ret[counter], pos+strlen(arg_char), eol_pos - pos - strlen(arg_char));
      ret[counter][eol_pos - pos - strlen(arg_char)]='\0';
    }
    counter++;
  }
  va_end(ap);
  return(ret);
} /* Table_ParseHeader */

/******************************************************************************
* double Table_Interp1d(x, x1, y1, x2, y2)
*    ACTION: interpolates linearly at x between y1=f(x1) and y2=f(x2)
*    return: y=f(x) value
*******************************************************************************/
double Table_Interp1d(double x,
  double x1, double y1,
  double x2, double y2)
{
  double slope;
  if (x2 == x1) return (y1+y2)/2;
  if (y1 == y2) return  y1;
  slope = (y2 - y1)/(x2 - x1);
  return y1+slope*(x - x1);
} /* Table_Interp1d */

/******************************************************************************
* double Table_Interp1d_nearest(x, x1, y1, x2, y2)
*    ACTION: table lookup with nearest method at x between y1=f(x1) and y2=f(x2)
*    return: y=f(x) value
*******************************************************************************/
double Table_Interp1d_nearest(double x,
  double x1, double y1,
  double x2, double y2)
{
  if (fabs(x-x1) < fabs(x-x2)) return (y1);
  else return(y2);
} /* Table_Interp1d_nearest */

/******************************************************************************
* double Table_Interp2d(x,y, x1,y1, x2,y2, z11,z12,z21,z22)
*    ACTION: interpolates bi-linearly at (x,y) between z1=f(x1,y1) and z2=f(x2,y2)
*    return: z=f(x,y) value
*    x,y |   x1   x2
*    ----------------
*     y1 |   z11  z21
*     y2 |   z12  z22
*******************************************************************************/
double Table_Interp2d(double x, double y,
  double x1, double y1,
  double x2, double y2,
  double z11, double z12, double z21, double z22)
{
  double ratio_x, ratio_y;
  if (x2 == x1) return Table_Interp1d(y, y1,z11, y2,z12);
  if (y1 == y2) return Table_Interp1d(x, x1,z11, x2,z21);

  ratio_y = (y - y1)/(y2 - y1);
  ratio_x = (x - x1)/(x2 - x1);
  return (1-ratio_x)*(1-ratio_y)*z11 + ratio_x*(1-ratio_y)*z21
    + ratio_x*ratio_y*z22         + (1-ratio_x)*ratio_y*z12;
} /* Table_Interp2d */

/* end of read_table-lib.c */


#ifndef SOURCE_GEN_DEF
#define SOURCE_GEN_DEF
/*******************************************************************************
* str_dup_numeric: replaces non 'valid name' chars with spaces
*******************************************************************************/
char *str_dup_numeric(char *orig)
  {
    long i;

    if (!orig || !strlen(orig)) return(NULL);

    for (i=0; i < strlen(orig); i++)
    {
      if ( (orig[i] > 122)
        || (orig[i] < 32)
        || (strchr("!\"#$%&'()*,:;<=>?@[\\]^`/ ", orig[i]) != NULL) )
      {
        orig[i] = ' ';
      }
    }
    orig[i] = '\0';
    /* now skip spaces */
    for (i=0; i < strlen(orig); i++) {
      if (*orig == ' ') orig++;
      else break;
    }

    return(orig);
  } /* str_dup_numeric */

  /* A normalised Maxwellian distribution : Integral over all l = 1 */
  double SG_Maxwell(double l, double temp)
  {
    double a=949.0/temp;
    return 2*a*a*exp(-a/(l*l))/(l*l*l*l*l);
  }
#endif

#line 6839 "ILL_H15_D11.c"

/* Shared user declarations for all components 'Al_window'. */
#line 47 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
/* ToDo: Should be component local names. */
#ifndef AL_WINDOW
#define avogadro 6.022 /* 10E23 Atoms per mole (mol-1) */
#define Al_sigma_a .231 /* Absorption cross section per atom (barns) at 2200m/s */
#define Al_sigma_i .0082 /* Incoherent scattering cross section per atom (barns) */
#define Al_rho 2.7 /* density (gcm-3) */
#define Al_mmol 27 /* molar mass Al (gmol-1) */
#define Al_my_s (Al_rho / Al_mmol * Al_sigma_i * avogadro * 10) /* inc. XS (barn) */
#define Al_my_a_v (Al_rho / Al_mmol * Al_sigma_a * avogadro * 10 * 2200 )
/* Define Constants for Polynomial Fit of
  sigma_tot(lambda)=A+B1*X+B2*X^2+B3*X^3+B4*X^4+... */
#define Al_pf_A 1.34722
#define Al_pf_B1 .12409
#define Al_pf_B2 .01078
#define Al_pf_B3 -3.25895e-5
#define Al_pf_B4 3.74731e-6
#define AL_WINDOW
#endif
#line 6861 "ILL_H15_D11.c"

/* Shared user declarations for all components 'Guide_gravity'. */
#line 124 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
/*****************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2006, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/ref-lib.h
*
* %Identification
* Written by: Peter Christiansen
* Date: August, 2006
* Origin: RISOE
* Release: McStas 1.10
* Version: $Revision$
*
* Commonly used reflection functions are declared in this file which
* are used by some guide and mirror components.
*
* Depends on read_table-lib
*
* Usage: within SHARE
* %include "ref-lib"
*
****************************************************************************/


#ifndef REF_LIB_H
#define REF_LIB_H "$Revision$"

void StdReflecFunc(double, double*, double*);
void TableReflecFunc(double, t_Table*, double*);

#endif

/* end of ref-lib.h */
/****************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2006, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/ref-lib.c
*
* %Identification
* Written by: Peter Christiansen
* Date: August, 2006
* Origin: RISOE
* Release: McStas 1.10
* Version: $Revision$
*
* Commonly used reflection functions are declared in this file which
* are used by some guide and mirror components.
*
* Variable names have prefix 'mc_ref_' for 'McStas Reflection' 
* to avoid conflicts
*
* Usage: within SHARE
* %include "ref-lib"
*
****************************************************************************/

#ifndef REF_LIB_H
#include "ref-lib.h"
#endif

#ifndef READ_TABLE_LIB_H
#include "read_table-lib.h"
#include "read_table-lib.c"
#endif

/****************************************************************************
* void StdReflecFunc(double q, double *par, double *r)
* 
* The McStas standard analytic parametrization of the reflectivity.
* The parameters are:
* R0:      [1]    Low-angle reflectivity
* Qc:      [AA-1] Critical scattering vector
* alpha:   [AA]   Slope of reflectivity
* m:       [1]    m-value of material. Zero means completely absorbing.
* W:       [AA-1] Width of supermirror cut-off
*****************************************************************************/
void StdReflecFunc(double mc_pol_q, double *mc_pol_par, double *mc_pol_r) {
    double R0    = mc_pol_par[0];
    double Qc    = mc_pol_par[1];
    double alpha = mc_pol_par[2];
    double m     = mc_pol_par[3];
    double W     = mc_pol_par[4];
    double beta  = 0;
    mc_pol_q     = fabs(mc_pol_q);
    double arg;
        
    /* Simpler parametrization from Henrik Jacobsen uses these values that depend on m only.
       double m_value=m*0.9853+0.1978;
       double W=-0.0002*m_value+0.0022;
       double alpha=0.2304*m_value+5.0944;
       double beta=-7.6251*m_value+68.1137; 
       If W and alpha are set to 0, use Henrik's approach for estimating these parameters
       and apply the formulation:
       arg = R0*0.5*(1-tanh(arg))*(1-alpha*(q-Qc)+beta*(q-Qc)*(q-Qc));
    */  
    if (W==0 && alpha==0) {
      m=m*0.9853+0.1978;
      W=-0.0002*m+0.0022;
      alpha=0.2304*m+5.0944;
      beta=-7.6251*m+68.1137;
      if (m<=3) {
	alpha=m;
	beta=0;
      }
    }
    
    arg = W > 0 ? (mc_pol_q - m*Qc)/W : 11;

    if (arg > 10 || m <= 0 || Qc <=0 || R0 <= 0) {
      *mc_pol_r = 0;
      return;
    }
    
    if (m < 1) { Qc *= m; m=1; }
    
    if(mc_pol_q <= Qc) {      
      *mc_pol_r = R0;
      return;
    }
    
    
    *mc_pol_r = R0*0.5*(1 - tanh(arg))*(1 - alpha*(mc_pol_q - Qc) + beta*(mc_pol_q - Qc)*(mc_pol_q - Qc));
    
    return;
  }

/****************************************************************************
* void TableReflecFunc(double q, t_Table *par, double *r) {
* 
* Looks up the reflectivity in a table using the routines in read_table-lib.
*****************************************************************************/
void TableReflecFunc(double mc_pol_q, t_Table *mc_pol_par, double *mc_pol_r) {
    
  *mc_pol_r = Table_Value(*mc_pol_par, mc_pol_q, 1);
  if(*mc_pol_r>1)
    *mc_pol_r = 1;
  return;
}

/* end of ref-lib.c */

#ifndef Gravity_guide_Version
#define Gravity_guide_Version "$Revision$"

#ifndef PROP_GRAV_DT
#error McStas : You need PROP_GRAV_DT (McStas >= 1.4.3) to run this component
#endif

/*
* G:       (m/s^2) Gravitation acceleration along y axis [-9.81]
* Gx:      (m/s^2) Gravitation acceleration along x axis [0]
* Gy:      (m/s^2) Gravitation acceleration along y axis [-9.81]
* Gz:      (m/s^2) Gravitation acceleration along z axis [0]
* mh:      (1)    m-value of material for left/right vert. mirrors
* mv:      (1)    m-value of material for top/bottom horz. mirrors
* mx:      (1)    m-value of material for left/right vert. mirrors
* my:      (1)    m-value of material for top/bottom horz. mirrors
*/

  typedef struct Gravity_guide_Vars
  {
    double gx;
    double gy;
    double gz;
    double nx[6], ny[6], nz[6];
    double wx[6], wy[6], wz[6];
    double A[6], norm_n2[6], norm_n[6];
    long   N_reflection[7];
    double w1c, h1c;
    double w2c, h2c;
    double M[5];
    double Alpha[5];
    double nzC[5], norm_n2xy[5], Axy[5];
    double wav_lr, wav_tb, wav_z;
    double chamfer_z, chamfer_lr, chamfer_tb;
    char   compcurname[256];
    double fc_freq, fc_phase;
    double warnings;
  } Gravity_guide_Vars_type;

  void Gravity_guide_Init(Gravity_guide_Vars_type *aVars,
    MCNUM a_w1, MCNUM a_h1, MCNUM a_w2, MCNUM a_h2, MCNUM a_l, MCNUM a_R0,
    MCNUM a_Qc, MCNUM a_alpha, MCNUM a_m, MCNUM a_W, MCNUM a_nslit, MCNUM a_d,
    MCNUM a_Gx, MCNUM a_Gy, MCNUM a_Gz,
    MCNUM a_mleft, MCNUM a_mright, MCNUM a_mtop, MCNUM a_mbottom, MCNUM a_nhslit,
    MCNUM a_wavy_lr, MCNUM a_wavy_tb, MCNUM a_wavy_z, MCNUM a_wavy,
    MCNUM a_chamfers_z, MCNUM a_chamfers_lr, MCNUM a_chamfers_tb, MCNUM a_chamfers,
    MCNUM a_nu, MCNUM a_phase, MCNUM a_aleft, MCNUM a_aright, MCNUM a_atop, MCNUM a_abottom)
  {
    int i;

    for (i=0; i<7; aVars->N_reflection[i++] = 0);
    for (i=0; i<5; aVars->M[i++] = 0);
    for (i=0; i<5; aVars->Alpha[i++] = 0);

    aVars->gx = a_Gx; /* The gravitation vector in the current component axis system */
    aVars->gy = a_Gy;
    aVars->gz = a_Gz;
    aVars->warnings=0;

    if (a_nslit <= 0 || a_nhslit <= 0) { fprintf(stderr,"%s: Fatal: no channel in this guide (nhslit or nslit=0).\n", aVars->compcurname); exit(-1); }
    if (a_d < 0) { fprintf(stderr,"%s: Fatal: subdividing walls have negative thickness in this guide (d<0).\n", aVars->compcurname); exit(-1); }
    aVars->w1c = (a_w1 - (a_nslit-1) *a_d)/(double)a_nslit;
    aVars->w2c = (a_w2 - (a_nslit-1) *a_d)/(double)a_nslit;
    aVars->h1c = (a_h1 - (a_nhslit-1)*a_d)/(double)a_nhslit;
    aVars->h2c = (a_h2 - (a_nhslit-1)*a_d)/(double)a_nhslit;

    for (i=0; i <= 4;   aVars->M[i++]=a_m);
    for (i=0; i <= 4;   aVars->Alpha[i++]=a_alpha);
    if (a_mleft   >= 0) aVars->M[1] =a_mleft  ;
    if (a_mright  >= 0) aVars->M[2] =a_mright ;
    if (a_mtop    >= 0) aVars->M[3] =a_mtop   ;
    if (a_mbottom >= 0) aVars->M[4] =a_mbottom;
    if (a_aleft   >= 0) aVars->Alpha[1] =a_aleft  ;
    if (a_aright  >= 0) aVars->Alpha[2] =a_aright ;
    if (a_atop    >= 0) aVars->Alpha[3] =a_atop   ;
    if (a_abottom >= 0) aVars->Alpha[4] =a_abottom;

    /* n: normal vectors to surfaces */
    aVars->nx[1] =  a_l; aVars->ny[1] =  0;   aVars->nz[1] =  0.5*(aVars->w2c-aVars->w1c);  /* 1:+X left       */
    aVars->nx[2] = -a_l; aVars->ny[2] =  0;   aVars->nz[2] = -aVars->nz[1];             /* 2:-X right      */
    aVars->nx[3] =  0;   aVars->ny[3] =  a_l; aVars->nz[3] =  0.5*(aVars->h2c-aVars->h1c);  /* 3:+Y top        */
    aVars->nx[4] =  0;   aVars->ny[4] = -a_l; aVars->nz[4] = -aVars->nz[3];             /* 4:-Y bottom     */
    aVars->nx[5] =  0;   aVars->ny[5] =  0;   aVars->nz[5] =  a_l;                      /* 5:+Z exit       */
    aVars->nx[0] =  0;   aVars->ny[0] =  0;   aVars->nz[0] = -a_l;                      /* 0:Z0 input      */
    /* w: a point on these surfaces */
    aVars->wx[1] = +(aVars->w1c)/2; aVars->wy[1] =  0;              aVars->wz[1] = 0;   /* 1:+X left       */
    aVars->wx[2] = -(aVars->w1c)/2; aVars->wy[2] =  0;              aVars->wz[2] = 0;   /* 2:-X right      */
    aVars->wx[3] =  0;              aVars->wy[3] = +(aVars->h1c)/2; aVars->wz[3] = 0;   /* 3:+Y top        */
    aVars->wx[4] =  0;              aVars->wy[4] = -(aVars->h1c)/2; aVars->wz[4] = 0;   /* 4:-Y bottom     */
    aVars->wx[5] =  0;              aVars->wy[5] =  0;              aVars->wz[5] = a_l; /* 5:+Z exit       */
    aVars->wx[0] =  0;              aVars->wy[0] =  0;              aVars->wz[0] = 0;   /* 0:Z0 input      */

    for (i=0; i <= 5; i++)
    {
      aVars->A[i] = scalar_prod(aVars->nx[i], aVars->ny[i], aVars->nz[i], aVars->gx, aVars->gy, aVars->gz)/2;
      aVars->norm_n2[i] = aVars->nx[i]*aVars->nx[i] + aVars->ny[i]*aVars->ny[i] + aVars->nz[i]*aVars->nz[i];
      if (aVars->norm_n2[i] <= 0)
        { fprintf(stderr,"%s: Fatal: normal vector norm %i is null/negative ! check guide dimensions.\n", aVars->compcurname, i); exit(-1); } /* should never occur */
      else
        aVars->norm_n[i] = sqrt(aVars->norm_n2[i]);
    }
    /* partial computations for l/r/t/b sides, to save computing time */
    for (i=1; i <= 4; i++)
    { /* stores nz that changes in case non box element (focus/defocus) */
      aVars->nzC[i]      =  aVars->nz[i]; /* partial xy terms */
      aVars->norm_n2xy[i]=  aVars->nx[i]*aVars->nx[i] + aVars->ny[i]*aVars->ny[i];
      aVars->Axy[i]      = (aVars->nx[i]*aVars->gx    + aVars->ny[i]*aVars->gy)/2;
    }
    /* handle waviness init */
    if (a_wavy && (!a_wavy_tb && !a_wavy_lr && !a_wavy_z))
    { aVars->wav_tb=aVars->wav_lr=aVars->wav_z=a_wavy; }
    else
    { aVars->wav_tb=a_wavy_tb; aVars->wav_lr=a_wavy_lr; aVars->wav_z=a_wavy_z; }
    aVars->wav_tb *= DEG2RAD/(sqrt(8*log(2)));   /* Convert from deg FWHM to rad Gaussian sigma */
    aVars->wav_lr *= DEG2RAD/(sqrt(8*log(2)));
    aVars->wav_z  *= DEG2RAD/(sqrt(8*log(2)));
    /* handle chamfers init */
    if (a_chamfers && (!a_chamfers_z && !a_chamfers_lr && !a_chamfers_tb))
    { aVars->chamfer_z=aVars->chamfer_lr=aVars->chamfer_tb=a_chamfers; }
    else
    {
      aVars->chamfer_z=a_chamfers_z;
      aVars->chamfer_lr=a_chamfers_lr;
      aVars->chamfer_tb=a_chamfers_tb;
    }

    aVars->fc_freq  = a_nu;
    aVars->fc_phase = a_phase;
  }

  int Gravity_guide_Trace(double *dt,
        Gravity_guide_Vars_type *aVars,
        double cx, double cy, double cz,
        double cvx, double cvy, double cvz,
        double cxnum, double cxk, double cynum, double cyk,
        double *cnx, double *cny,double *cnz)
  {
    double B, C;
    int    ret=0;
    int    side=0;
    double n1;
    double dt0, dt_min=0;
    int    i;
    double loc_num, loc_nslit;
    int    i_slope=3;

    /* look if there is a previous intersection with guide sides */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 5=+Z side: n=(0, 0, -l) ; W = (0, 0, l) (at z=l, guide exit)*/
    B = aVars->nz[5]*cvz; C = aVars->nz[5]*(cz - aVars->wz[5]);
    ret = solve_2nd_order(&dt0, NULL, aVars->A[5], B, C);
    if (ret && dt0>1e-10) { dt_min = dt0; side=5; }

    loc_num = cynum; loc_nslit = cyk;
    for (i=4; i>0; i--)
    {
      if (i == 2) { i_slope=1; loc_num = cxnum; loc_nslit = cxk; }

      if (aVars->nzC[i_slope] != 0) {
        n1 = loc_nslit - 2*(loc_num);  /* slope of l/r/u/d sides depends on the channel ! */
        loc_num++; /* use partial computations to alter nz and A */
        aVars->nz[i]= aVars->nzC[i]*n1;
        aVars->A[i] = aVars->Axy[i] + aVars->nz[i]*aVars->gz/2;
      }
      if (i < 3)
      {      B = aVars->nx[i]*cvx + aVars->nz[i]*cvz; C = aVars->nx[i]*(cx-aVars->wx[i]) + aVars->nz[i]*cz; }
      else { B = aVars->ny[i]*cvy + aVars->nz[i]*cvz; C = aVars->ny[i]*(cy-aVars->wy[i]) + aVars->nz[i]*cz; }
      ret = solve_2nd_order(&dt0, NULL, aVars->A[i], B, C);
      if (ret && dt0>1e-10 && (dt0<dt_min || !dt_min))
      { dt_min = dt0; side=i;
        if (aVars->nzC[i] != 0)
        { aVars->norm_n2[i] = aVars->norm_n2xy[i] + aVars->nz[i]*aVars->nz[i];
          aVars->norm_n[i]  = sqrt(aVars->norm_n2[i]); }
      }
     }

    *dt = dt_min;
    /* handles waviness: rotate n vector */
    if (side > 0 && side < 5 && (aVars->wav_z || aVars->wav_lr || aVars->wav_tb))
    {
      double nt_x, nt_y, nt_z;  /* transverse vector */
      double nn_x, nn_y, nn_z;  /* normal vector (tmp) */
      double phi;
      /* normal vector n_z = [ 0,0,1], n_t = n x n_z; */
      vec_prod(nt_x,nt_y,nt_z, aVars->nx[side],aVars->ny[side],aVars->nz[side], 0,0,1);
      /* rotate n with angle wavy_z around n_t -> nn */
      if (aVars->wav_z) {
        phi = aVars->wav_z;
        rotate(nn_x,nn_y,nn_z, aVars->nx[side],aVars->ny[side],aVars->nz[side], aVars->wav_z*randnorm(), nt_x,nt_y,nt_z);
      } else { nn_x=aVars->nx[side]; nn_y=aVars->ny[side]; nn_z=aVars->nz[side]; }
      /* rotate n with angle wavy_{x|y} around n_z -> nt */
      phi = (side <=2) ? aVars->wav_lr : aVars->wav_tb;
      if (phi) {
        rotate(nt_x,nt_y,nt_z, nn_x,nn_y,nn_z, phi*randnorm(), 0,0,1);
      } else { nt_x=nn_x; nt_y=nn_y; nt_z=nn_z; }
      *cnx=nt_x; *cny=nt_y; *cnz=nt_z;
    } else
    { *cnx=aVars->nx[side]; *cny=aVars->ny[side]; *cnz=aVars->nz[side]; }
    return (side);
  }



#endif
#line 7217 "ILL_H15_D11.c"

/* Shared user declarations for all components 'Monitor_nD'. */
#line 216 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/monitor_nd-lib.h
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas 1.6
* Version: $Revision$
*
* This file is to be imported by the monitor_nd related components
* It handles some shared functions.
*
* Usage: within SHARE
* %include "monitor_nd-lib"
*
*******************************************************************************/

#ifndef MONITOR_ND_LIB_H

#define MONITOR_ND_LIB_H "$Revision$"
#define MONnD_COORD_NMAX  30  /* max number of variables to record */

  typedef struct MonitornD_Defines
  {
    int COORD_NONE  ;
    int COORD_X     ;
    int COORD_Y     ;
    int COORD_Z     ;
    int COORD_RADIUS; 
    int COORD_VX    ;
    int COORD_VY    ;
    int COORD_VZ    ;
    int COORD_V     ;
    int COORD_T     ;
    int COORD_P     ;
    int COORD_SX    ;
    int COORD_SY    ;
    int COORD_SZ    ;
    int COORD_KX    ;
    int COORD_KY    ;
    int COORD_KZ    ;
    int COORD_K     ;
    int COORD_ENERGY;
    int COORD_LAMBDA;
    int COORD_KXY   ;
    int COORD_KYZ   ;
    int COORD_KXZ   ;
    int COORD_VXY   ;
    int COORD_VYZ   ;
    int COORD_VXZ   ;
    int COORD_HDIV  ;
    int COORD_VDIV  ;
    int COORD_ANGLE ;
    int COORD_NCOUNT;
    int COORD_THETA ;
    int COORD_PHI   ;
    int COORD_USER1 ;
    int COORD_USER2 ;
    int COORD_USER3 ;
    int COORD_XY    ;
    int COORD_XZ    ;
    int COORD_YZ    ;
    int COORD_PIXELID;

    /* token modifiers */
    int COORD_VAR   ; /* next token should be a variable or normal option */
    int COORD_MIN   ; /* next token is a min value */
    int COORD_MAX   ; /* next token is a max value */
    int COORD_DIM   ; /* next token is a bin value */
    int COORD_FIL   ; /* next token is a filename */
    int COORD_EVNT  ; /* next token is a buffer size value */
    int COORD_3HE   ; /* next token is a 3He pressure value */
    int COORD_LOG   ; /* next variable will be in log scale */
    int COORD_ABS   ; /* next variable will be in abs scale */
    int COORD_SIGNAL; /* next variable will be the signal var */
    int COORD_AUTO  ; /* set auto limits */

    char TOKEN_DEL[32]; /* token separators */

    char SHAPE_SQUARE; /* shape of the monitor */
    char SHAPE_DISK  ;
    char SHAPE_SPHERE;
    char SHAPE_CYLIND;
    char SHAPE_BANANA; /* cylinder without top/bottom, on restricted angular area */
    char SHAPE_BOX   ;
    char SHAPE_PREVIOUS;
    char SHAPE_OFF;

  } MonitornD_Defines_type;

  typedef struct MonitornD_Variables
  {
    double area;
    double Sphere_Radius     ;
    double Cylinder_Height   ;
    char   Flag_With_Borders ;   /* 2 means xy borders too */
    char   Flag_List         ;   /* 1 store 1 buffer, 2 is list all, 3 list all+append */
    char   Flag_Multiple     ;   /* 1 when n1D, 0 for 2D */
    char   Flag_Verbose      ;
    int    Flag_Shape        ;
    char   Flag_Auto_Limits  ;   /* get limits from first Buffer */
    char   Flag_Absorb       ;   /* monitor is also a slit */
    char   Flag_per_cm2      ;   /* flux is per cm2 */
    char   Flag_log          ;   /* log10 of the flux */
    char   Flag_parallel     ;   /* set neutron state back after detection (parallel components) */
    char   Flag_Binary_List  ;
    char   Flag_capture      ;   /* lambda monitor with lambda/lambda(2200m/s = 1.7985 Angs) weightening */
    int    Flag_signal       ;   /* 0:monitor p, else monitor a mean value */
    int    Flag_mantid       ;   /* 0:normal monitor, else do mantid-event specifics */
    int    Flag_OFF          ;   /* Flag to indicate external geometry from OFF file */
    unsigned long OFF_polyidx;   /* When intersection is done externally by off_intersect, this gives the 
				    polygon number, i.e. pixel index */

    unsigned long Coord_Number      ;   /* total number of variables to monitor, plus intensity (0) */
    unsigned long Coord_NumberNoPixel;  /* same but without counting PixelID */
    unsigned long Buffer_Block      ;   /* Buffer size for list or auto limits */
    unsigned long Neutron_Counter   ;   /* event counter, simulation total counts is mcget_ncount() */
    unsigned long Buffer_Counter    ;   /* index in Buffer size (for realloc) */
    unsigned long Buffer_Size       ;
    int    Coord_Type[MONnD_COORD_NMAX];      /* type of variable */
    char   Coord_Label[MONnD_COORD_NMAX][30]; /* label of variable */
    char   Coord_Var[MONnD_COORD_NMAX][30];   /* short id of variable */
    long   Coord_Bin[MONnD_COORD_NMAX];       /* bins of variable array */
    long   Coord_BinProd[MONnD_COORD_NMAX];   /* product of bins of variable array */
    double Coord_Min[MONnD_COORD_NMAX];
    double Coord_Max[MONnD_COORD_NMAX];
    char   Monitor_Label[MONnD_COORD_NMAX*30];/* Label for monitor */
    char   Mon_File[128];                     /* output file name */

    double cx,cy,cz;
    double cvx, cvy, cvz;
    double ckx, cky, ckz;
    double csx, csy, csz;
    double cEx, cEy, cEz;
    double cs1, cs2, ct, cphi, cp;
    double He3_pressure;
    char   Flag_UsePreMonitor    ;   /* use a previously stored neutron parameter set */
    char   UserName1[128];
    char   UserName2[128];
    char   UserName3[128];
    double UserVariable1;
    double UserVariable2;
    double UserVariable3;
    char   option[CHAR_BUF_LENGTH];

    long long int Nsum;
    double psum, p2sum;
    double **Mon2D_N;
    double **Mon2D_p;
    double **Mon2D_p2;
    double *Mon2D_Buffer;
    unsigned long PixelID;

    double mxmin,mxmax,mymin,mymax,mzmin,mzmax;
    double mean_dx, mean_dy, min_x, min_y, max_x, max_y, mean_p;

    char   compcurname[128];
    Coords compcurpos;

  } MonitornD_Variables_type;

/* monitor_nd-lib function prototypes */
/* ========================================================================= */

void Monitor_nD_Init(MonitornD_Defines_type *, MonitornD_Variables_type *, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, MCNUM, int);
int Monitor_nD_Trace(MonitornD_Defines_type *, MonitornD_Variables_type *);
MCDETECTOR Monitor_nD_Save(MonitornD_Defines_type *, MonitornD_Variables_type *);
void Monitor_nD_Finally(MonitornD_Defines_type *, MonitornD_Variables_type *);
void Monitor_nD_McDisplay(MonitornD_Defines_type *,
 MonitornD_Variables_type *);

#define MONND_DECLARE(monname) \
  struct MonitornD_Variables *mcmonnd ## monname;
#define MONND_USER_TITLE(monname, num, title) \
  { mcmonnd ## monname = &(MC_GETPAR(monname, Vars)); \
    strcpy(mcmonnd ## monname->UserName ## num, title); }
#define MONND_USER_VALUE(monname, num, value) \
  { mcmonnd ## monname = &(MC_GETPAR(monname, Vars)); \
    mcmonnd ## monname->UserVariable ## num = (value); }

#endif

/* end of monitor_nd-lib.h */
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Library: share/monitor_nd-lib.c
*
* %Identification
* Written by: EF
* Date: Aug 28, 2002
* Origin: ILL
* Release: McStas 1.6
* Version: $Revision$
*
* This file is to be imported by the monitor_nd related components
* It handles some shared functions. Embedded within instrument in runtime mode.
*
* Usage: within SHARE
* %include "monitor_nd-lib"
*
*******************************************************************************/

#ifndef MONITOR_ND_LIB_H
#error McStas : please import this library with %include "monitor_nd-lib"
#endif

/* ========================================================================= */
/* Monitor_nD_Init: this routine is used to parse options                    */
/* ========================================================================= */

void Monitor_nD_Init(MonitornD_Defines_type *DEFS,
  MonitornD_Variables_type *Vars,
  MCNUM xwidth,
  MCNUM yheight,
  MCNUM zdepth,
  MCNUM xmin,
  MCNUM xmax,
  MCNUM ymin,
  MCNUM ymax,
  MCNUM zmin,
  MCNUM zmax,
  int offflag)
  {
    long carg = 1;
    char *option_copy, *token;
    char Flag_New_token = 1;
    char Flag_End       = 1;
    char Flag_All       = 0;
    char Flag_No        = 0;
    char Flag_abs       = 0;
    int  Flag_auto      = 0;  /* -1: all, 1: the current variable */
    int  Set_Vars_Coord_Type;
    char Set_Vars_Coord_Label[64];
    char Set_Vars_Coord_Var[64];
    char Short_Label[MONnD_COORD_NMAX][64];
    int  Set_Coord_Mode;
    long i=0, j=0;
    double lmin, lmax, XY=0;
    long t;


    t = (long)time(NULL);

/* initialize DEFS */
/* Variables to monitor */
    DEFS->COORD_NONE   =0;
    DEFS->COORD_X      =1;
    DEFS->COORD_Y      =2;
    DEFS->COORD_Z      =3;
    DEFS->COORD_RADIUS =19;
    DEFS->COORD_VX     =4;
    DEFS->COORD_VY     =5;
    DEFS->COORD_VZ     =6;
    DEFS->COORD_V      =16;
    DEFS->COORD_T      =7;
    DEFS->COORD_P      =8;
    DEFS->COORD_SX     =9;
    DEFS->COORD_SY     =10;
    DEFS->COORD_SZ     =11;
    DEFS->COORD_KX     =12;
    DEFS->COORD_KY     =13;
    DEFS->COORD_KZ     =14;
    DEFS->COORD_K      =15;
    DEFS->COORD_ENERGY =17;
    DEFS->COORD_LAMBDA =18;
    DEFS->COORD_HDIV   =20;
    DEFS->COORD_VDIV   =21;
    DEFS->COORD_ANGLE  =22;
    DEFS->COORD_NCOUNT =23;
    DEFS->COORD_THETA  =24;
    DEFS->COORD_PHI    =25;
    DEFS->COORD_USER1  =26;
    DEFS->COORD_USER2  =27;
    DEFS->COORD_USER3  =28;
    DEFS->COORD_XY     =37;
    DEFS->COORD_YZ     =31;
    DEFS->COORD_XZ     =32;
    DEFS->COORD_VXY    =30;
    DEFS->COORD_VYZ    =34;
    DEFS->COORD_VXZ    =36;
    DEFS->COORD_KXY    =29;
    DEFS->COORD_KYZ    =33;
    DEFS->COORD_KXZ    =35;
    DEFS->COORD_PIXELID=38;

/* token modifiers */
    DEFS->COORD_VAR    =0;    /* next token should be a variable or normal option */
    DEFS->COORD_MIN    =1;    /* next token is a min value */
    DEFS->COORD_MAX    =2;    /* next token is a max value */
    DEFS->COORD_DIM    =3;    /* next token is a bin value */
    DEFS->COORD_FIL    =4;    /* next token is a filename */
    DEFS->COORD_EVNT   =5;    /* next token is a buffer size value */
    DEFS->COORD_3HE    =6;    /* next token is a 3He pressure value */
    DEFS->COORD_LOG    =64;   /* next variable will be in log scale */
    DEFS->COORD_ABS    =128;  /* next variable will be in abs scale */
    DEFS->COORD_SIGNAL =256;  /* next variable will be the signal var */
    DEFS->COORD_AUTO   =512;  /* set auto limits */

    strcpy(DEFS->TOKEN_DEL, " =,;[](){}:");  /* token separators */

    DEFS->SHAPE_SQUARE =0;    /* shape of the monitor */
    DEFS->SHAPE_DISK   =1;
    DEFS->SHAPE_SPHERE =2;
    DEFS->SHAPE_CYLIND =3;
    DEFS->SHAPE_BANANA =4;
    DEFS->SHAPE_BOX    =5;
    DEFS->SHAPE_PREVIOUS=6;
    DEFS->SHAPE_OFF=7;

    Vars->Sphere_Radius     = 0;
    Vars->Cylinder_Height   = 0;
    Vars->Flag_With_Borders = 0;   /* 2 means xy borders too */
    Vars->Flag_List         = 0;   /* 1=store 1 buffer, 2=list all, 3=re-use buffer */
    Vars->Flag_Multiple     = 0;   /* 1 when n1D, 0 for 2D */
    Vars->Flag_Verbose      = 0;
    Vars->Flag_Shape        = DEFS->SHAPE_SQUARE;
    Vars->Flag_Auto_Limits  = 0;   /* get limits from first Buffer */
    Vars->Flag_Absorb       = 0;   /* monitor is also a slit */
    Vars->Flag_per_cm2      = 0;   /* flux is per cm2 */
    Vars->Flag_log          = 0;   /* log10 of the flux */
    Vars->Flag_parallel     = 0;   /* set neutron state back after detection (parallel components) */
    Vars->Flag_Binary_List  = 0;   /* save list as a binary file (smaller) */
    Vars->Coord_Number      = 0;   /* total number of variables to monitor, plus intensity (0) */
    Vars->Coord_NumberNoPixel=0;   /* same but without counting PixelID */

/* Allow to specify size of Monitor_nD buffer via a define*/
#ifndef MONND_BUFSIZ
    Vars->Buffer_Block      = 100000;     /* Buffer size for list or auto limits */
#else
	Vars->Buffer_Block      = MONND_BUFSIZ;     /* Buffer size for list or auto limits */	
#endif
    Vars->Neutron_Counter   = 0;   /* event counter, simulation total counts is mcget_ncount() */
    Vars->Buffer_Counter    = 0;   /* index in Buffer size (for realloc) */
    Vars->Buffer_Size       = 0;
    Vars->UserVariable1     = 0;
    Vars->UserVariable2     = 0;
    Vars->He3_pressure      = 0;
    Vars->Flag_capture      = 0;
    Vars->Flag_signal       = DEFS->COORD_P;
    Vars->Flag_mantid       = 0;
    Vars->Flag_OFF          = offflag;
    Vars->OFF_polyidx       = -1;
    Vars->mean_dx=Vars->mean_dy=0;
    Vars->min_x = Vars->max_x  =0;
    Vars->min_y = Vars->max_y  =0;

    Set_Vars_Coord_Type = DEFS->COORD_NONE;
    Set_Coord_Mode = DEFS->COORD_VAR;

    /* handle size parameters */
    /* normal use is with xwidth, yheight, zdepth */
    /* if xmin,xmax,ymin,ymax,zmin,zmax are non 0, use them */
    if (fabs(xmin-xmax) == 0)
      { Vars->mxmin = -fabs(xwidth)/2; Vars->mxmax = fabs(xwidth)/2; }
    else
      { if (xmin < xmax) {Vars->mxmin = xmin; Vars->mxmax = xmax;}
        else {Vars->mxmin = xmax; Vars->mxmax = xmin;}
      }
    if (fabs(ymin-ymax) == 0)
      { Vars->mymin = -fabs(yheight)/2; Vars->mymax = fabs(yheight)/2; }
    else
      { if (ymin < ymax) {Vars->mymin = ymin; Vars->mymax = ymax;}
        else {Vars->mymin = ymax; Vars->mymax = ymin;}
      }
    if (fabs(zmin-zmax) == 0)
      { Vars->mzmin = -fabs(zdepth)/2; Vars->mzmax = fabs(zdepth)/2; }
    else
      { if (zmin < zmax) {Vars->mzmin = zmin; Vars->mzmax = zmax; }
        else {Vars->mzmin = zmax; Vars->mzmax = zmin; }
      }

    if (fabs(Vars->mzmax-Vars->mzmin) == 0)
      Vars->Flag_Shape        = DEFS->SHAPE_SQUARE;
    else
      Vars->Flag_Shape        = DEFS->SHAPE_BOX;

    if (Vars->Flag_OFF) {
      Vars->Flag_Shape        = DEFS->SHAPE_OFF;
    }
    
    /* parse option string */

    option_copy = (char*)malloc(strlen(Vars->option)+1);
    if (option_copy == NULL)
    {
      fprintf(stderr,"Monitor_nD: %s cannot allocate 'options' copy (%li). Fatal.\n", Vars->compcurname, (long)strlen(Vars->option));
      exit(-1);
    }

    if (strlen(Vars->option))
    {
      Flag_End = 0;
      strcpy(option_copy, Vars->option);
    }

    if (strstr(Vars->option, "cm2") || strstr(Vars->option, "cm^2")) Vars->Flag_per_cm2 = 1;

    if (strstr(Vars->option, "binary") || strstr(Vars->option, "float"))
      Vars->Flag_Binary_List  = 1;
    if (strstr(Vars->option, "double"))
      Vars->Flag_Binary_List  = 2;

    strcpy(Vars->Coord_Label[0],"Intensity");
    strncpy(Vars->Coord_Var[0],"p",30);
    Vars->Coord_Type[0] = DEFS->COORD_P;
    Vars->Coord_Bin[0] = 1;
    Vars->Coord_Min[0] = 0;
    Vars->Coord_Max[0] = FLT_MAX;

    /* default file name is comp_name+dateID */
    sprintf(Vars->Mon_File, "%s_%li", Vars->compcurname, t);

    carg = 1;
    while((Flag_End == 0) && (carg < 128))
    {

      if (Flag_New_token) /* retain previous token or get a new one */
      {
        if (carg == 1) token=(char *)strtok(option_copy,DEFS->TOKEN_DEL);
        else token=(char *)strtok(NULL,DEFS->TOKEN_DEL);
        if (token == NULL) Flag_End=1;
      }
      Flag_New_token = 1;
      if ((token != NULL) && (strlen(token) != 0))
      {
        char iskeyword=0; /* left at 0 when variables are processed, 1 for modifiers */
        int  old_Mode;
        /* change token to lower case */
        for (i=0; i<strlen(token); i++) token[i]=tolower(token[i]);
        /* first handle option values from preceeding keyword token detected */
        old_Mode = Set_Coord_Mode;
        if (Set_Coord_Mode == DEFS->COORD_MAX)  /* max=%i */
        {
          if (!Flag_All)
            Vars->Coord_Max[Vars->Coord_Number] = atof(token);
          else
            for (i = 0; i <= Vars->Coord_Number; Vars->Coord_Max[i++] = atof(token));
          Set_Coord_Mode = DEFS->COORD_VAR; Flag_All = 0;
        }
        if (Set_Coord_Mode == DEFS->COORD_MIN)  /* min=%i */
        {
          if (!Flag_All)
            Vars->Coord_Min[Vars->Coord_Number] = atof(token);
          else
            for (i = 0; i <= Vars->Coord_Number; Vars->Coord_Min[i++] = atof(token));
          Set_Coord_Mode = DEFS->COORD_MAX;
        }
        if (Set_Coord_Mode == DEFS->COORD_DIM)  /* bins=%i */
        {
          if (!Flag_All)
            Vars->Coord_Bin[Vars->Coord_Number] = atoi(token);
          else
            for (i = 0; i <= Vars->Coord_Number; Vars->Coord_Bin[i++] = atoi(token));
          Set_Coord_Mode = DEFS->COORD_VAR; Flag_All = 0;
        }
        if (Set_Coord_Mode == DEFS->COORD_FIL)  /* file=%s */
        {
          if (!Flag_No) strncpy(Vars->Mon_File,token,128);
          else { strcpy(Vars->Mon_File,""); Vars->Coord_Number = 0; Flag_End = 1;}
          Set_Coord_Mode = DEFS->COORD_VAR;
        }
        if (Set_Coord_Mode == DEFS->COORD_EVNT) /* list=%i */
        {
          if (!strcmp(token, "all") || Flag_All) Vars->Flag_List = 2;
          else { i = (long)ceil(atof(token)); if (i) Vars->Buffer_Block = i;
            Vars->Flag_List = 1; }
          Set_Coord_Mode = DEFS->COORD_VAR; Flag_All = 0;
        }
        if (Set_Coord_Mode == DEFS->COORD_3HE)  /* pressure=%g */
        {
            Vars->He3_pressure = atof(token);
            Set_Coord_Mode = DEFS->COORD_VAR; Flag_All = 0;
        }

        /* now look for general option keywords */
        if (!strcmp(token, "borders"))  {Vars->Flag_With_Borders = 1; iskeyword=1; }
        if (!strcmp(token, "verbose"))  {Vars->Flag_Verbose      = 1; iskeyword=1; }
        if (!strcmp(token, "log"))      {Vars->Flag_log          = 1; iskeyword=1; }
        if (!strcmp(token, "abs"))      {Flag_abs                = 1; iskeyword=1; }
        if (!strcmp(token, "multiple")) {Vars->Flag_Multiple     = 1; iskeyword=1; }
        if (!strcmp(token, "list") || !strcmp(token, "events")) {
          Vars->Flag_List = 1; Set_Coord_Mode = DEFS->COORD_EVNT;  }
        if (!strcmp(token, "limits") || !strcmp(token, "min"))
          Set_Coord_Mode = DEFS->COORD_MIN;
        if (!strcmp(token, "slit") || !strcmp(token, "absorb")) {
          Vars->Flag_Absorb = 1;  iskeyword=1; }
        if (!strcmp(token, "max"))  Set_Coord_Mode = DEFS->COORD_MAX;
        if (!strcmp(token, "bins") || !strcmp(token, "dim")) Set_Coord_Mode = DEFS->COORD_DIM;
        if (!strcmp(token, "file") || !strcmp(token, "filename")) {
          Set_Coord_Mode = DEFS->COORD_FIL;
          if (Flag_No) { strcpy(Vars->Mon_File,""); Vars->Coord_Number = 0; Flag_End = 1; }
        }
        if (!strcmp(token, "unactivate")) {
          Flag_End = 1; Vars->Coord_Number = 0; iskeyword=1; }
        if (!strcmp(token, "all"))    { Flag_All = 1;  iskeyword=1; }
        if (!strcmp(token, "sphere")) { Vars->Flag_Shape = DEFS->SHAPE_SPHERE; iskeyword=1; }
        if (!strcmp(token, "cylinder")) { Vars->Flag_Shape = DEFS->SHAPE_CYLIND; iskeyword=1; }
        if (!strcmp(token, "banana")) { Vars->Flag_Shape = DEFS->SHAPE_BANANA; iskeyword=1; }
        if (!strcmp(token, "square")) { Vars->Flag_Shape = DEFS->SHAPE_SQUARE; iskeyword=1; }
        if (!strcmp(token, "disk"))   { Vars->Flag_Shape = DEFS->SHAPE_DISK; iskeyword=1; }
        if (!strcmp(token, "box"))     { Vars->Flag_Shape = DEFS->SHAPE_BOX; iskeyword=1; }
        if (!strcmp(token, "previous")) { Vars->Flag_Shape = DEFS->SHAPE_PREVIOUS; iskeyword=1; }
        if (!strcmp(token, "parallel")){ Vars->Flag_parallel = 1; iskeyword=1; }
        if (!strcmp(token, "capture")) { Vars->Flag_capture = 1; iskeyword=1; }
        if (!strcmp(token, "auto") && (Flag_auto != -1)) {
          Vars->Flag_Auto_Limits = 1;
          if (Flag_All) Flag_auto = -1;
          else          Flag_auto = 1;
          iskeyword=1; Flag_All=0; }
        if (!strcmp(token, "premonitor")) {
          Vars->Flag_UsePreMonitor = 1; iskeyword=1; }
        if (!strcmp(token, "3He_pressure") || !strcmp(token, "pressure")) {
          Vars->He3_pressure = 3; iskeyword=1; }
        if (!strcmp(token, "no") || !strcmp(token, "not")) { Flag_No = 1;  iskeyword=1; }
        if (!strcmp(token, "signal")) Set_Coord_Mode = DEFS->COORD_SIGNAL;
        if (!strcmp(token, "mantid")) { Vars->Flag_mantid = 1; iskeyword=1; }

        /* Mode has changed: this was a keyword or value  ? */
        if (Set_Coord_Mode != old_Mode) iskeyword=1;

        /* now look for variable names to monitor */
        Set_Vars_Coord_Type = DEFS->COORD_NONE; lmin = 0; lmax = 0;

        if (!strcmp(token, "x"))
          { Set_Vars_Coord_Type = DEFS->COORD_X; strcpy(Set_Vars_Coord_Label,"x [m]"); strcpy(Set_Vars_Coord_Var,"x");
          lmin = Vars->mxmin; lmax = Vars->mxmax;
          Vars->Coord_Min[Vars->Coord_Number+1] = Vars->mxmin;
          Vars->Coord_Max[Vars->Coord_Number+1] = Vars->mxmax;}
        if (!strcmp(token, "y"))
          { Set_Vars_Coord_Type = DEFS->COORD_Y; strcpy(Set_Vars_Coord_Label,"y [m]"); strcpy(Set_Vars_Coord_Var,"y");
          lmin = Vars->mymin; lmax = Vars->mymax;
          Vars->Coord_Min[Vars->Coord_Number+1] = Vars->mymin;
          Vars->Coord_Max[Vars->Coord_Number+1] = Vars->mymax;}
        if (!strcmp(token, "z"))
          { Set_Vars_Coord_Type = DEFS->COORD_Z; strcpy(Set_Vars_Coord_Label,"z [m]"); strcpy(Set_Vars_Coord_Var,"z"); lmin = Vars->mzmin; lmax = Vars->mzmax; }
        if (!strcmp(token, "k") || !strcmp(token, "wavevector"))
          { Set_Vars_Coord_Type = DEFS->COORD_K; strcpy(Set_Vars_Coord_Label,"|k| [Angs-1]"); strcpy(Set_Vars_Coord_Var,"k"); lmin = 0; lmax = 10; }
        if (!strcmp(token, "v"))
          { Set_Vars_Coord_Type = DEFS->COORD_V; strcpy(Set_Vars_Coord_Label,"Velocity [m/s]"); strcpy(Set_Vars_Coord_Var,"v"); lmin = 0; lmax = 1000000; }
        if (!strcmp(token, "t") || !strcmp(token, "time") || !strcmp(token, "tof"))
          { Set_Vars_Coord_Type = DEFS->COORD_T; strcpy(Set_Vars_Coord_Label,"TOF [s]"); strcpy(Set_Vars_Coord_Var,"t"); lmin = 0; lmax = .1; }
        if ((!strcmp(token, "p") || !strcmp(token, "i") || !strcmp(token, "intensity") || !strcmp(token, "flux")))
          { Set_Vars_Coord_Type = DEFS->COORD_P;
            strcpy(Set_Vars_Coord_Label,"Intensity");
            strncat(Set_Vars_Coord_Label, " [n/s", 30);
            if (Vars->Flag_per_cm2) strncat(Set_Vars_Coord_Label, "/cm2", 30);
            if (XY > 1 && Vars->Coord_Number)
              strncat(Set_Vars_Coord_Label, "/bin", 30);
            strncat(Set_Vars_Coord_Label, "]", 30);
            strcpy(Set_Vars_Coord_Var,"I");
            lmin = 0; lmax = FLT_MAX;
            if (Flag_auto>0) Flag_auto=0;
          }

        if (!strcmp(token, "vx"))
          { Set_Vars_Coord_Type = DEFS->COORD_VX; strcpy(Set_Vars_Coord_Label,"vx [m/s]"); strcpy(Set_Vars_Coord_Var,"vx"); lmin = -1000; lmax = 1000; }
        if (!strcmp(token, "vy"))
          { Set_Vars_Coord_Type = DEFS->COORD_VY; strcpy(Set_Vars_Coord_Label,"vy [m/s]"); strcpy(Set_Vars_Coord_Var,"vy"); lmin = -1000; lmax = 1000; }
        if (!strcmp(token, "vz"))
          { Set_Vars_Coord_Type = DEFS->COORD_VZ; strcpy(Set_Vars_Coord_Label,"vz [m/s]"); strcpy(Set_Vars_Coord_Var,"vz"); lmin = -10000; lmax = 10000; }
        if (!strcmp(token, "kx"))
          { Set_Vars_Coord_Type = DEFS->COORD_KX; strcpy(Set_Vars_Coord_Label,"kx [Angs-1]"); strcpy(Set_Vars_Coord_Var,"kx"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "ky"))
          { Set_Vars_Coord_Type = DEFS->COORD_KY; strcpy(Set_Vars_Coord_Label,"ky [Angs-1]"); strcpy(Set_Vars_Coord_Var,"ky"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "kz"))
          { Set_Vars_Coord_Type = DEFS->COORD_KZ; strcpy(Set_Vars_Coord_Label,"kz [Angs-1]"); strcpy(Set_Vars_Coord_Var,"kz"); lmin = -10; lmax = 10; }
        if (!strcmp(token, "sx"))
          { Set_Vars_Coord_Type = DEFS->COORD_SX; strcpy(Set_Vars_Coord_Label,"sx [1]"); strcpy(Set_Vars_Coord_Var,"sx"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "sy"))
          { Set_Vars_Coord_Type = DEFS->COORD_SY; strcpy(Set_Vars_Coord_Label,"sy [1]"); strcpy(Set_Vars_Coord_Var,"sy"); lmin = -1; lmax = 1; }
        if (!strcmp(token, "sz"))
          { Set_Vars_Coord_Type = DEFS->COORD_SZ; strcpy(Set_Vars_Coord_Label,"sz [1]"); strcpy(Set_Vars_Coord_Var,"sz"); lmin = -1; lmax = 1; }

        if (!strcmp(token, "energy") || !strcmp(token, "omega") || !strcmp(token, "e"))
          { Set_Vars_Coord_Type = DEFS->COORD_ENERGY; strcpy(Set_Vars_Coord_Label,"Energy [meV]"); strcpy(Set_Vars_Coord_Var,"E"); lmin = 0; lmax = 100; }
        if (!strcmp(token, "lambda") || !strcmp(token, "wavelength") || !strcmp(token, "l"))
          { Set_Vars_Coord_Type = DEFS->COORD_LAMBDA; strcpy(Set_Vars_Coord_Label,"Wavelength [Angs]"); strcpy(Set_Vars_Coord_Var,"L"); lmin = 0; lmax = 100; }
        if (!strcmp(token, "radius") || !strcmp(token, "r"))
          { Set_Vars_Coord_Type = DEFS->COORD_RADIUS; strcpy(Set_Vars_Coord_Label,"Radius [m]"); strcpy(Set_Vars_Coord_Var,"xy"); lmin = 0; lmax = xmax; }
        if (!strcmp(token, "xy"))
          { Set_Vars_Coord_Type = DEFS->COORD_XY; strcpy(Set_Vars_Coord_Label,"Radius (xy) [m]"); strcpy(Set_Vars_Coord_Var,"xy"); lmin = 0; lmax = xmax; }
        if (!strcmp(token, "yz"))
          { Set_Vars_Coord_Type = DEFS->COORD_YZ; strcpy(Set_Vars_Coord_Label,"Radius (yz) [m]"); strcpy(Set_Vars_Coord_Var,"yz"); lmin = 0; lmax = xmax; }
        if (!strcmp(token, "xz"))
          { Set_Vars_Coord_Type = DEFS->COORD_XZ; strcpy(Set_Vars_Coord_Label,"Radius (xz) [m]"); strcpy(Set_Vars_Coord_Var,"xz"); lmin = 0; lmax = xmax; }
        if (!strcmp(token, "vxy"))
          { Set_Vars_Coord_Type = DEFS->COORD_VXY; strcpy(Set_Vars_Coord_Label,"Radial Velocity (xy) [m]"); strcpy(Set_Vars_Coord_Var,"Vxy"); lmin = 0; lmax = 2000; }
        if (!strcmp(token, "kxy"))
          { Set_Vars_Coord_Type = DEFS->COORD_KXY; strcpy(Set_Vars_Coord_Label,"Radial Wavevector (xy) [Angs-1]"); strcpy(Set_Vars_Coord_Var,"Kxy"); lmin = 0; lmax = 2; }
        if (!strcmp(token, "vyz"))
          { Set_Vars_Coord_Type = DEFS->COORD_VYZ; strcpy(Set_Vars_Coord_Label,"Radial Velocity (yz) [m]"); strcpy(Set_Vars_Coord_Var,"Vyz"); lmin = 0; lmax = 2000; }
        if (!strcmp(token, "kyz"))
          { Set_Vars_Coord_Type = DEFS->COORD_KYZ; strcpy(Set_Vars_Coord_Label,"Radial Wavevector (yz) [Angs-1]"); strcpy(Set_Vars_Coord_Var,"Kyz"); lmin = 0; lmax = 2; }
        if (!strcmp(token, "vxz"))
          { Set_Vars_Coord_Type = DEFS->COORD_VXZ; strcpy(Set_Vars_Coord_Label,"Radial Velocity (xz) [m]"); strcpy(Set_Vars_Coord_Var,"Vxz"); lmin = 0; lmax = 2000; }
        if (!strcmp(token, "kxz"))
          { Set_Vars_Coord_Type = DEFS->COORD_KXZ; strcpy(Set_Vars_Coord_Label,"Radial Wavevector (xz) [Angs-1]"); strcpy(Set_Vars_Coord_Var,"Kxz"); lmin = 0; lmax = 2; }
        if (!strcmp(token, "angle") || !strcmp(token, "a"))
          { Set_Vars_Coord_Type = DEFS->COORD_ANGLE; strcpy(Set_Vars_Coord_Label,"Angle [deg]"); strcpy(Set_Vars_Coord_Var,"A"); lmin = -50; lmax = 50; }
        if (!strcmp(token, "hdiv")|| !strcmp(token, "divergence") || !strcmp(token, "xdiv") || !strcmp(token, "hd") || !strcmp(token, "dx"))
          { Set_Vars_Coord_Type = DEFS->COORD_HDIV; strcpy(Set_Vars_Coord_Label,"Hor. Divergence [deg]"); strcpy(Set_Vars_Coord_Var,"hd"); lmin = -5; lmax = 5; }
        if (!strcmp(token, "vdiv") || !strcmp(token, "ydiv") || !strcmp(token, "vd") || !strcmp(token, "dy"))
          { Set_Vars_Coord_Type = DEFS->COORD_VDIV; strcpy(Set_Vars_Coord_Label,"Vert. Divergence [deg]"); strcpy(Set_Vars_Coord_Var,"vd"); lmin = -5; lmax = 5; }
        if (!strcmp(token, "theta") || !strcmp(token, "longitude") || !strcmp(token, "th"))
          { Set_Vars_Coord_Type = DEFS->COORD_THETA; strcpy(Set_Vars_Coord_Label,"Longitude [deg]"); strcpy(Set_Vars_Coord_Var,"th"); lmin = -180; lmax = 180; }
        if (!strcmp(token, "phi") || !strcmp(token, "lattitude") || !strcmp(token, "ph"))
          { Set_Vars_Coord_Type = DEFS->COORD_PHI; strcpy(Set_Vars_Coord_Label,"Lattitude [deg]"); strcpy(Set_Vars_Coord_Var,"ph"); lmin = -180; lmax = 180; }
        if (!strcmp(token, "ncounts") || !strcmp(token, "n") || !strcmp(token, "neutron"))
          { Set_Vars_Coord_Type = DEFS->COORD_NCOUNT; strcpy(Set_Vars_Coord_Label,"Neutron ID [1]"); strcpy(Set_Vars_Coord_Var,"n"); lmin = 0; lmax = mcget_ncount(); if (Flag_auto>0) Flag_auto=0; }
        if (!strcmp(token, "id") || !strcmp(token, "pixel"))
          { Set_Vars_Coord_Type = DEFS->COORD_PIXELID; 
            strcpy(Set_Vars_Coord_Label,"Pixel ID [1]"); 
            strcpy(Set_Vars_Coord_Var,"id"); lmin = 0; lmax = FLT_MAX; 
            if (Flag_auto>0) Flag_auto=0;
            Vars->Flag_List = 1; }
        if (!strcmp(token, "user") || !strcmp(token, "user1") || !strcmp(token, "u1"))
          { Set_Vars_Coord_Type = DEFS->COORD_USER1; strncpy(Set_Vars_Coord_Label,Vars->UserName1,30); strcpy(Set_Vars_Coord_Var,"U1"); lmin = -1e10; lmax = 1e10; }
        if (!strcmp(token, "user2") || !strcmp(token, "u2"))
          { Set_Vars_Coord_Type = DEFS->COORD_USER2; strncpy(Set_Vars_Coord_Label,Vars->UserName2,30); strcpy(Set_Vars_Coord_Var,"U2"); lmin = -1e10; lmax = 1e10; }
        if (!strcmp(token, "user3") || !strcmp(token, "u3"))
          { Set_Vars_Coord_Type = DEFS->COORD_USER3; strncpy(Set_Vars_Coord_Label,Vars->UserName3,30); strcpy(Set_Vars_Coord_Var,"U3"); lmin = -1e10; lmax = 1e10; }

        /* now stores variable keywords detected, if any */
        if (Set_Vars_Coord_Type != DEFS->COORD_NONE)
        {
          int Coord_Number = Vars->Coord_Number;
          if (Vars->Flag_log) { Set_Vars_Coord_Type |= DEFS->COORD_LOG; Vars->Flag_log = 0; }
          if (Flag_abs) { Set_Vars_Coord_Type |= DEFS->COORD_ABS; Flag_abs = 0; }
          if (Flag_auto != 0) { Set_Vars_Coord_Type |= DEFS->COORD_AUTO; 
            if (Flag_auto > 0) Flag_auto = 0; }
          if (Set_Coord_Mode == DEFS->COORD_SIGNAL)
          {
            Coord_Number = 0;
            Vars->Flag_signal = Set_Vars_Coord_Type;
          }
          else
          {
            if (Coord_Number < MONnD_COORD_NMAX)
            { Coord_Number++;
              Vars->Coord_Number = Coord_Number; 
              if (Set_Vars_Coord_Type != DEFS->COORD_PIXELID)
                Vars->Coord_NumberNoPixel++;
            }
            else if (Vars->Flag_Verbose) printf("Monitor_nD: %s reached max number of variables (%i).\n", Vars->compcurname, MONnD_COORD_NMAX);
          }
          Vars->Coord_Type[Coord_Number] = Set_Vars_Coord_Type;
          strncpy(Vars->Coord_Label[Coord_Number], Set_Vars_Coord_Label,30);
          strncpy(Vars->Coord_Var[Coord_Number], Set_Vars_Coord_Var,30);
          if (lmin > lmax) { XY = lmin; lmin=lmax; lmax = XY; }
          Vars->Coord_Min[Coord_Number] = lmin;
          Vars->Coord_Max[Coord_Number] = lmax;
          if (Set_Vars_Coord_Type == DEFS->COORD_NCOUNT || Set_Vars_Coord_Type == DEFS->COORD_PIXELID || Set_Vars_Coord_Type == DEFS->COORD_SIGNAL)
            Vars->Coord_Bin[Coord_Number] = 1;
          else
            Vars->Coord_Bin[Coord_Number] = 20;
          Set_Coord_Mode = DEFS->COORD_VAR;
          Flag_All = 0;
          Flag_No  = 0;
        } else {
          /* no variable name could be read from options */
          if (!iskeyword) {
            if (strcmp(token, "cm2") && strcmp(token, "incoming")
             && strcmp(token, "outgoing") && strcmp(token, "cm2")
             && strcmp(token, "cm^2") && strcmp(token, "float")
             && strcmp(token, "double") && strcmp(token, "binary")
             && strcmp(token, "steradian") && Vars->Flag_Verbose)
              printf("Monitor_nD: %s: unknown '%s' keyword in 'options'. Ignoring.\n", Vars->compcurname, token);
          }
        }
      carg++;
      } /* end if token */
    } /* end while carg */
    free(option_copy);
    if (carg == 128) printf("Monitor_nD: %s reached max number of tokens (%i). Skipping.\n", Vars->compcurname, 128);

    if ((Vars->Flag_Shape == DEFS->SHAPE_BOX) && (fabs(Vars->mzmax - Vars->mzmin) == 0)) Vars->Flag_Shape = DEFS->SHAPE_SQUARE;

    if (Vars->Flag_log == 1) Vars->Coord_Type[0] |= DEFS->COORD_LOG;
    if (Vars->Coord_Number == 0)
    { Vars->Flag_Auto_Limits=0; Vars->Flag_Multiple=0; Vars->Flag_List=0; }

    /* now setting Monitor Name from variable labels */
    strcpy(Vars->Monitor_Label,"");
    XY = 1; /* will contain total bin number */
    for (i = 0; i <= Vars->Coord_Number; i++)
    {
      if (Flag_auto != 0) Vars->Coord_Type[i] |= DEFS->COORD_AUTO;
      Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
      if ((Set_Vars_Coord_Type == DEFS->COORD_X)
       || (Set_Vars_Coord_Type == DEFS->COORD_Y)
       || (Set_Vars_Coord_Type == DEFS->COORD_Z))
       strcpy(Short_Label[i],"Position");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_THETA)
       || (Set_Vars_Coord_Type == DEFS->COORD_PHI)
       || (Set_Vars_Coord_Type == DEFS->COORD_ANGLE))
       strcpy(Short_Label[i],"Angle");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_XY)
       || (Set_Vars_Coord_Type == DEFS->COORD_XZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_YZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_RADIUS))
       strcpy(Short_Label[i],"Radius");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_VX)
       || (Set_Vars_Coord_Type == DEFS->COORD_VY)
       || (Set_Vars_Coord_Type == DEFS->COORD_VZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_V)
       || (Set_Vars_Coord_Type == DEFS->COORD_VXY)
       || (Set_Vars_Coord_Type == DEFS->COORD_VYZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_VXZ))
       strcpy(Short_Label[i],"Velocity");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_KX)
       || (Set_Vars_Coord_Type == DEFS->COORD_KY)
       || (Set_Vars_Coord_Type == DEFS->COORD_KZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_KXY)
       || (Set_Vars_Coord_Type == DEFS->COORD_KYZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_KXZ)
       || (Set_Vars_Coord_Type == DEFS->COORD_K))
       strcpy(Short_Label[i],"Wavevector");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_SX)
       || (Set_Vars_Coord_Type == DEFS->COORD_SY)
       || (Set_Vars_Coord_Type == DEFS->COORD_SZ))
       strcpy(Short_Label[i],"Spin");
      else
      if ((Set_Vars_Coord_Type == DEFS->COORD_HDIV)
       || (Set_Vars_Coord_Type == DEFS->COORD_VDIV))
       strcpy(Short_Label[i],"Divergence");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_ENERGY)
       strcpy(Short_Label[i],"Energy");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_LAMBDA)
       strcpy(Short_Label[i],"Wavelength");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_NCOUNT)
       strcpy(Short_Label[i],"Neutron_ID");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_PIXELID)
       strcpy(Short_Label[i],"Pixel_ID");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_T)
          strcpy(Short_Label[i],"Time_Of_Flight");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_P)
          strcpy(Short_Label[i],"Intensity");
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_USER1)
          strncpy(Short_Label[i],Vars->UserName1,30);
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_USER2)
          strncpy(Short_Label[i],Vars->UserName2,30);
      else
      if (Set_Vars_Coord_Type == DEFS->COORD_USER3)
          strncpy(Short_Label[i],Vars->UserName3,30);
      else
          strcpy(Short_Label[i],"Unknown");

      if (Vars->Coord_Type[i] & DEFS->COORD_ABS)
      { strcat(Vars->Coord_Label[i]," (abs)"); }

      if (Vars->Coord_Type[i] & DEFS->COORD_LOG)
      { strcat(Vars->Coord_Label[i]," (log)"); }

      strcat(Vars->Monitor_Label, " ");
      strcat(Vars->Monitor_Label, Short_Label[i]);
      XY *= Vars->Coord_Bin[i];

    } /* end for Short_Label */

    if ((Vars->Coord_Type[0] & (DEFS->COORD_LOG-1)) == DEFS->COORD_P) {
      strncat(Vars->Coord_Label[0], " [n/s", 30);
      if (Vars->Flag_per_cm2) strncat(Vars->Coord_Label[0], "/cm2", 30);

      if (XY > 1 && Vars->Coord_Number)
        strncat(Vars->Coord_Label[0], "/bin", 30);
      strncat(Vars->Coord_Label[0], "]", 30);
    }

    /* update label 'signal per bin' if more than 1 bin */
    if (XY > 1 && Vars->Coord_Number) {
      if (Vars->Flag_capture)
        printf("Monitor_nD: %s: Using capture flux weightening on %ld bins.\n"
               "WARNING     Use binned data with caution, and prefer monitor integral value (I,Ierr).\n", Vars->compcurname, (long)XY);
    }

    strcat(Vars->Monitor_Label, " Monitor");
    if (Vars->Flag_Shape == DEFS->SHAPE_SQUARE) strcat(Vars->Monitor_Label, " (Square)");
    if (Vars->Flag_Shape == DEFS->SHAPE_DISK)   strcat(Vars->Monitor_Label, " (Disk)");
    if (Vars->Flag_Shape == DEFS->SHAPE_SPHERE) strcat(Vars->Monitor_Label, " (Sphere)");
    if (Vars->Flag_Shape == DEFS->SHAPE_CYLIND) strcat(Vars->Monitor_Label, " (Cylinder)");
    if (Vars->Flag_Shape == DEFS->SHAPE_BANANA) strcat(Vars->Monitor_Label, " (Banana)");
    if (Vars->Flag_Shape == DEFS->SHAPE_BOX)    strcat(Vars->Monitor_Label, " (Box)");
    if (Vars->Flag_Shape == DEFS->SHAPE_PREVIOUS) strcat(Vars->Monitor_Label, " (on PREVIOUS)");
    if (Vars->Flag_Shape == DEFS->SHAPE_OFF) strcat(Vars->Monitor_Label, " (OFF geometry)");
    if ((Vars->Flag_Shape == DEFS->SHAPE_CYLIND) || (Vars->Flag_Shape == DEFS->SHAPE_BANANA) || (Vars->Flag_Shape == DEFS->SHAPE_SPHERE) || (Vars->Flag_Shape == DEFS->SHAPE_BOX))
    {
      if (strstr(Vars->option, "incoming"))
      {
        Vars->Flag_Shape = abs(Vars->Flag_Shape);
        strcat(Vars->Monitor_Label, " [in]");
      }
      else /* if strstr(Vars->option, "outgoing")) */
      {
        Vars->Flag_Shape = -abs(Vars->Flag_Shape);
        strcat(Vars->Monitor_Label, " [out]");
      }
    }
    if (Vars->Flag_UsePreMonitor == 1)
    {
        strcat(Vars->Monitor_Label, " at ");
        strncat(Vars->Monitor_Label, Vars->UserName1,30);
    }
    if (Vars->Flag_log == 1) strcat(Vars->Monitor_Label, " [log] ");

    /* now allocate memory to store variables in TRACE */

    /* Vars->Coord_Number  0   : intensity or signal
     * Vars->Coord_Number  1:n : detector variables */

    if ((Vars->Coord_NumberNoPixel != 2) && !Vars->Flag_Multiple && !Vars->Flag_List)
    { Vars->Flag_Multiple = 1; /* default is n1D */
      if (Vars->Coord_Number != Vars->Coord_NumberNoPixel) Vars->Flag_List = 1; }

    /* list and auto limits case : Vars->Flag_List or Vars->Flag_Auto_Limits
     * -> Buffer to flush and suppress after Vars->Flag_Auto_Limits
     */
    if ((Vars->Flag_Auto_Limits || Vars->Flag_List) && Vars->Coord_Number)
    { /* Dim : (Vars->Coord_Number+1)*Vars->Buffer_Block matrix (for p, dp) */
      Vars->Mon2D_Buffer = (double *)malloc((Vars->Coord_Number+1)*Vars->Buffer_Block*sizeof(double));
      if (Vars->Mon2D_Buffer == NULL)
      { printf("Monitor_nD: %s cannot allocate Vars->Mon2D_Buffer (%li). No list and auto limits.\n", Vars->compcurname, Vars->Buffer_Block*(Vars->Coord_Number+1)*sizeof(double)); Vars->Flag_List = 0; Vars->Flag_Auto_Limits = 0; }
      else
      {
        for (i=0; i < (Vars->Coord_Number+1)*Vars->Buffer_Block; Vars->Mon2D_Buffer[i++] = (double)0);
      }
      Vars->Buffer_Size = Vars->Buffer_Block;
    }

    /* 1D and n1D case : Vars->Flag_Multiple */
    if (Vars->Flag_Multiple && Vars->Coord_NumberNoPixel)
    { /* Dim : Vars->Coord_Number*Vars->Coord_Bin[i] vectors */
      Vars->Mon2D_N  = (double **)malloc((Vars->Coord_Number)*sizeof(double *));
      Vars->Mon2D_p  = (double **)malloc((Vars->Coord_Number)*sizeof(double *));
      Vars->Mon2D_p2 = (double **)malloc((Vars->Coord_Number)*sizeof(double *));
      if ((Vars->Mon2D_N == NULL) || (Vars->Mon2D_p == NULL) || (Vars->Mon2D_p2 == NULL))
      { fprintf(stderr,"Monitor_nD: %s n1D cannot allocate Vars->Mon2D_N/p/p2 (%li). Fatal.\n", Vars->compcurname, (Vars->Coord_Number)*sizeof(double *)); exit(-1); }
      for (i= 1; i <= Vars->Coord_Number; i++)
      {
        Vars->Mon2D_N[i-1]  = (double *)malloc(Vars->Coord_Bin[i]*sizeof(double));
        Vars->Mon2D_p[i-1]  = (double *)malloc(Vars->Coord_Bin[i]*sizeof(double));
        Vars->Mon2D_p2[i-1] = (double *)malloc(Vars->Coord_Bin[i]*sizeof(double));
        if ((Vars->Mon2D_N == NULL) || (Vars->Mon2D_p == NULL) || (Vars->Mon2D_p2 == NULL))
        { fprintf(stderr,"Monitor_nD: %s n1D cannot allocate %s Vars->Mon2D_N/p/p2[%li] (%li). Fatal.\n", Vars->compcurname, Vars->Coord_Var[i], i, (Vars->Coord_Bin[i])*sizeof(double *)); exit(-1); }
        else
        {
          for (j=0; j < Vars->Coord_Bin[i]; j++ )
          { Vars->Mon2D_N[i-1][j] = (double)0; Vars->Mon2D_p[i-1][j] = (double)0; Vars->Mon2D_p2[i-1][j] = (double)0; }
        }
      }
    }
    else /* 2D case : Vars->Coord_Number==2 and !Vars->Flag_Multiple and !Vars->Flag_List */
    if ((Vars->Coord_NumberNoPixel == 2) && !Vars->Flag_Multiple)
    { /* Dim : Vars->Coord_Bin[1]*Vars->Coord_Bin[2] matrix */
      Vars->Mon2D_N  = (double **)malloc((Vars->Coord_Bin[1])*sizeof(double *));
      Vars->Mon2D_p  = (double **)malloc((Vars->Coord_Bin[1])*sizeof(double *));
      Vars->Mon2D_p2 = (double **)malloc((Vars->Coord_Bin[1])*sizeof(double *));
      if ((Vars->Mon2D_N == NULL) || (Vars->Mon2D_p == NULL) || (Vars->Mon2D_p2 == NULL))
      { fprintf(stderr,"Monitor_nD: %s 2D cannot allocate %s Vars->Mon2D_N/p/p2 (%li). Fatal.\n", Vars->compcurname, Vars->Coord_Var[1], (Vars->Coord_Bin[1])*sizeof(double *)); exit(-1); }
      for (i= 0; i < Vars->Coord_Bin[1]; i++)
      {
        Vars->Mon2D_N[i]  = (double *)malloc(Vars->Coord_Bin[2]*sizeof(double));
        Vars->Mon2D_p[i]  = (double *)malloc(Vars->Coord_Bin[2]*sizeof(double));
        Vars->Mon2D_p2[i] = (double *)malloc(Vars->Coord_Bin[2]*sizeof(double));
        if ((Vars->Mon2D_N == NULL) || (Vars->Mon2D_p == NULL) || (Vars->Mon2D_p2 == NULL))
        { fprintf(stderr,"Monitor_nD: %s 2D cannot allocate %s Vars->Mon2D_N/p/p2[%li] (%li). Fatal.\n", Vars->compcurname, Vars->Coord_Var[1], i, (Vars->Coord_Bin[2])*sizeof(double *)); exit(-1); }
        else
        {
          for (j=0; j < Vars->Coord_Bin[2]; j++ )
          { Vars->Mon2D_N[i][j] = (double)0; Vars->Mon2D_p[i][j] = (double)0; Vars->Mon2D_p2[i][j] = (double)0; }
        }
      }
    }
    else {
      Vars->Mon2D_N = Vars->Mon2D_p = Vars->Mon2D_p2 = NULL;
    }
      /* no Mon2D allocated for
       * (Vars->Coord_Number != 2) && !Vars->Flag_Multiple && Vars->Flag_List */

    Vars->psum  = 0;
    Vars->p2sum = 0;
    Vars->Nsum  = 0;

    Vars->area  = fabs(Vars->mxmax - Vars->mxmin)*fabs(Vars->mymax - Vars->mymin)*1E4; /* in cm**2 for square and box shapes */
    Vars->Sphere_Radius = fabs(Vars->mxmax - Vars->mxmin)/2;
    if ((abs(Vars->Flag_Shape) == DEFS->SHAPE_DISK) || (abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE))
    {
      Vars->area = PI*Vars->Sphere_Radius*Vars->Sphere_Radius*1E4; /* disk shapes */
    }


    if (Vars->area == 0 && abs(Vars->Flag_Shape) != DEFS->SHAPE_PREVIOUS ) {
      if (abs(Vars->Flag_Shape) != DEFS->SHAPE_OFF) {  
	Vars->Coord_Number = 0;
      }
    }
    if (Vars->Coord_Number == 0 && Vars->Flag_Verbose)
      printf("Monitor_nD: %s is unactivated (0D)\n", Vars->compcurname);
    Vars->Cylinder_Height = fabs(Vars->mymax - Vars->mymin);

    if (Vars->Flag_Verbose)
    {
      printf("Monitor_nD: %s is a %s.\n", Vars->compcurname, Vars->Monitor_Label);
      printf("Monitor_nD: version %s with options=%s\n", MONITOR_ND_LIB_H, Vars->option);
    }
    
    /* compute the product of bin dimensions for PixelID */
    Vars->Coord_BinProd[0]=1;
    for (i = 1; i <= Vars->Coord_Number; i++)
      Vars->Coord_BinProd[i]=Vars->Coord_Bin[i]*Vars->Coord_BinProd[i-1];
  } /* end Monitor_nD_Init */

/* ========================================================================= */
/* Monitor_nD_Trace: this routine is used to monitor one propagating neutron */
/* return values: 0=neutron was absorbed, -1=neutron was outside bounds, 1=neutron was measured*/
/* ========================================================================= */

int Monitor_nD_Trace(MonitornD_Defines_type *DEFS, MonitornD_Variables_type *Vars)
{

  double  XY=0, pp=0;
  int     retval;
  long    i =0, j =0;
  double  Coord[MONnD_COORD_NMAX];
  long    Coord_Index[MONnD_COORD_NMAX];
  char    While_End   =0;
  long    While_Buffer=0;
  char    Set_Vars_Coord_Type = DEFS->COORD_NONE;
  
  /* the logic below depends mainly on:
       Flag_List:        1=store 1 buffer, 2=list all, 3=re-use buffer 
       Flag_Auto_Limits: 0 (no auto limits/list), 1 (store events into Buffer), 2 (re-emit store events)
   */

  /* Vars->Flag_Auto_Limits=1: buffer full, we read the Buffer, and determine min and max bounds */
  if ((Vars->Buffer_Counter >= Vars->Buffer_Block) && (Vars->Flag_Auto_Limits == 1) && (Vars->Coord_Number > 0))
  {
    /* auto limits case : get limits in Buffer for each variable */
          /* Dim : (Vars->Coord_Number+1)*Vars->Buffer_Block matrix (for p, dp) */
    if (Vars->Flag_Verbose) printf("Monitor_nD: %s getting %li Auto Limits from List (%li events) in TRACE.\n", Vars->compcurname, Vars->Coord_Number, Vars->Buffer_Counter);
    for (i = 1; i <= Vars->Coord_Number; i++)
    {
      if (Vars->Coord_Type[i] & DEFS->COORD_AUTO)
      {
        Vars->Coord_Min[i] =  FLT_MAX;
        Vars->Coord_Max[i] = -FLT_MAX;
        for (j = 0; j < Vars->Buffer_Counter; j++)
        {
          XY = Vars->Mon2D_Buffer[i+j*(Vars->Coord_Number+1)];  /* scanning variables in Buffer */
          if (XY < Vars->Coord_Min[i]) Vars->Coord_Min[i] = XY;
          if (XY > Vars->Coord_Max[i]) Vars->Coord_Max[i] = XY;
        }
        if  (Vars->Flag_Verbose)  
          printf("  %s: min=%g max=%g\n", Vars->Coord_Var[i], Vars->Coord_Min[i], Vars->Coord_Max[i]);
      }
    }
    Vars->Flag_Auto_Limits = 2;  /* pass to 2nd auto limits step (read Buffer and generate new events to store in histograms) */
  } /* end if Flag_Auto_Limits == 1 */

  /* manage realloc for 'list all' if Buffer size exceeded: flush Buffer to file */
  if ((Vars->Buffer_Counter >= Vars->Buffer_Block) && (Vars->Flag_List >= 2))
  {
    if (Vars->Buffer_Size >= 1000000 || Vars->Flag_List == 3)
    { /* save current (possibly append) and re-use Buffer */
      Monitor_nD_Save(DEFS, Vars);
      Vars->Flag_List = 3;
      Vars->Buffer_Block = Vars->Buffer_Size;
      Vars->Buffer_Counter  = 0;
      Vars->Neutron_Counter = 0;
    }
    else
    {
      Vars->Mon2D_Buffer  = (double *)realloc(Vars->Mon2D_Buffer, (Vars->Coord_Number+1)*(Vars->Neutron_Counter+Vars->Buffer_Block)*sizeof(double));
      if (Vars->Mon2D_Buffer == NULL)
            { printf("Monitor_nD: %s cannot reallocate Vars->Mon2D_Buffer[%li] (%li). Skipping.\n", Vars->compcurname, i, (Vars->Neutron_Counter+Vars->Buffer_Block)*sizeof(double)); Vars->Flag_List = 1; }
      else { Vars->Buffer_Counter = 0; Vars->Buffer_Size = Vars->Neutron_Counter+Vars->Buffer_Block; }
    }
  } /* end if Buffer realloc */

  char    outsidebounds=0;
  while (!While_End)
  { /* we generate Coord[] and Coord_index[] from Buffer (auto limits) or passing neutron */
    if ((Vars->Flag_Auto_Limits == 2) && (Vars->Coord_Number > 0))
    { /* Vars->Flag_Auto_Limits == 2: read back from Buffer (Buffer is filled or auto limits have been computed) */
      if (While_Buffer < Vars->Buffer_Block)
      {
        /* first while loop (While_Buffer) */
        /* auto limits case : scan Buffer within limits and store in Mon2D */
        Coord[0] = pp = Vars->Mon2D_Buffer[While_Buffer*(Vars->Coord_Number+1)];

        for (i = 1; i <= Vars->Coord_Number; i++)
        {
          /* scanning variables in Buffer */
          if (Vars->Coord_Bin[i] <= 1) continue;
          XY = (Vars->Coord_Max[i]-Vars->Coord_Min[i]);

          Coord[i] = Vars->Mon2D_Buffer[i+While_Buffer*(Vars->Coord_Number+1)];
          if (XY > 0) Coord_Index[i] = floor((Coord[i]-Vars->Coord_Min[i])*Vars->Coord_Bin[i]/XY);
          else        Coord_Index[i] = 0;
          if (Vars->Flag_With_Borders)
          {
            if (Coord_Index[i] < 0)                   Coord_Index[i] = 0;
            if (Coord_Index[i] >= Vars->Coord_Bin[i]) Coord_Index[i] = Vars->Coord_Bin[i] - 1;
          }
        } /* end for */
        
        /* update the PixelID, we compute it from the previous variables index */
        if (Vars->Coord_NumberNoPixel < Vars->Coord_Number) /* there is a Pixel variable */
        for (i = 1; i <= Vars->Coord_Number; i++) {
          char Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
          if (Set_Vars_Coord_Type == DEFS->COORD_PIXELID) {
            char flag_outside=0;
            Coord_Index[i] = Coord[i] = 0;
            for (j= 1; j < i; j++) {
              /* not for 1D variables with Bin=1 such as PixelID, NCOUNT, Intensity */
              if (Vars->Coord_Bin[j] == 1) continue; 
              if (0 > Coord_Index[j] || Coord_Index[j] >= Vars->Coord_Bin[j]) {
                flag_outside=1;
                Coord[i] = 0;
                break;
              }
              Coord[i] += Coord_Index[j]*Vars->Coord_BinProd[j-1];
            }
            if (!flag_outside) {
              Vars->Mon2D_Buffer[i+While_Buffer*(Vars->Coord_Number+1)] = Coord[i];
            }
          } /* end if PixelID */
        }
        While_Buffer++;
      } /* end if in Buffer */
      else /* (While_Buffer >= Vars->Buffer_Block) && (Vars->Flag_Auto_Limits == 2) */
      {
        Vars->Flag_Auto_Limits = 0;
        if (!Vars->Flag_List) /* free Buffer not needed anymore (no list to output) */
        { /* Dim : (Vars->Coord_Number+1)*Vars->Buffer_Block matrix (for p, p2) */
          free(Vars->Mon2D_Buffer); Vars->Mon2D_Buffer = NULL;
        }
        if (Vars->Flag_Verbose) printf("Monitor_nD: %s flushed %li Auto Limits from List (%li) in TRACE.\n", Vars->compcurname, Vars->Coord_Number, Vars->Buffer_Counter);
      }
    } /* if Vars->Flag_Auto_Limits == 2 */
    
    if (Vars->Flag_Auto_Limits != 2 || !Vars->Coord_Number) /* Vars->Flag_Auto_Limits == 0 (no auto limits/list) or 1 (store events into Buffer) */
    {
      /* automatically compute area and steradian solid angle when in AUTO mode */
      /* compute the steradian solid angle incoming on the monitor */
      double v;
      v=sqrt(Vars->cvx*Vars->cvx
            +Vars->cvy*Vars->cvy
            +Vars->cvz*Vars->cvz);
      if (Vars->min_x > Vars->cx) Vars->min_x = Vars->cx;
      if (Vars->max_x < Vars->cx) Vars->max_x = Vars->cx;
      if (Vars->min_y > Vars->cy) Vars->min_y = Vars->cy;
      if (Vars->max_y < Vars->cy) Vars->max_y = Vars->cy;
      Vars->mean_p  += Vars->cp;
      if (v) {
        Vars->mean_dx += Vars->cp*fabs(Vars->cvx/v);
        Vars->mean_dy += Vars->cp*fabs(Vars->cvy/v);
      }

      for (i = 0; i <= Vars->Coord_Number; i++)
      { /* handle current neutron : last while */
        XY = 0;
        Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
        /* get values for variables to monitor */
        if (Set_Vars_Coord_Type == DEFS->COORD_X) XY = Vars->cx;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_Y) XY = Vars->cy;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_Z) XY = Vars->cz;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VX) XY = Vars->cvx;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VY) XY = Vars->cvy;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VZ) XY = Vars->cvz;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KX) XY = V2K*Vars->cvx;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KY) XY = V2K*Vars->cvy;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KZ) XY = V2K*Vars->cvz;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_SX) XY = Vars->csx;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_SY) XY = Vars->csy;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_SZ) XY = Vars->csz;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_T) XY = Vars->ct;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_P) XY = Vars->cp;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_HDIV) XY = RAD2DEG*atan2(Vars->cvx,Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VDIV) XY = RAD2DEG*atan2(Vars->cvy,Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_V) XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_RADIUS)
          XY = sqrt(Vars->cx*Vars->cx+Vars->cy*Vars->cy+Vars->cz*Vars->cz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_XY)
          XY = sqrt(Vars->cx*Vars->cx+Vars->cy*Vars->cy)*(Vars->cx > 0 ? 1 : -1);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_YZ) XY = sqrt(Vars->cy*Vars->cy+Vars->cz*Vars->cz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_XZ)
          XY = sqrt(Vars->cx*Vars->cx+Vars->cz*Vars->cz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VXY) XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VXZ) XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvz*Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_VYZ) XY = sqrt(Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_K) { XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);  XY *= V2K; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KXY) { XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy);  XY *= V2K; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KXZ) { XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvz*Vars->cvz);  XY *= V2K; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_KYZ) { XY = sqrt(Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);  XY *= V2K; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_ENERGY) { XY = Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz;  XY *= VS2E; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_LAMBDA) { XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy+Vars->cvz*Vars->cvz);  XY *= V2K; if (XY != 0) XY = 2*PI/XY; }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_NCOUNT) XY = Vars->Neutron_Counter;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_ANGLE)
        {  XY = sqrt(Vars->cvx*Vars->cvx+Vars->cvy*Vars->cvy);
           if (Vars->cvz != 0)
                XY = RAD2DEG*atan2(XY,Vars->cvz)*(Vars->cx > 0 ? 1 : -1);
           else XY = 0;
        }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_THETA)  { if (Vars->cz != 0) XY = RAD2DEG*atan2(Vars->cx,Vars->cz); }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_PHI) { if (Vars->cz != 0) XY = RAD2DEG*asin(Vars->cy/Vars->cz); }
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_USER1) XY = Vars->UserVariable1;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_USER2) XY = Vars->UserVariable2;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_USER3) XY = Vars->UserVariable3;
        else
        if (Set_Vars_Coord_Type == DEFS->COORD_PIXELID && !Vars->Flag_Auto_Limits) {
          /* compute the PixelID from previous coordinates 
             the PixelID is the product of Coord_Index[i] in the detector geometry 
             pixelID = sum( Coord_Index[j]*prod(Vars->Coord_Bin[1:(j-1)]) )
             
             this does not apply when we store events in the buffer as Coord_Index
             is not set. Then the pixelID will be re-computed during SAVE.
          */
          char flag_outside=0;
          for (j= 1; j < i; j++) {
            /* not for 1D variables with Bin=1 such as PixelID, NCOUNT, Intensity */
            if (Vars->Coord_Bin[j] <= 1) continue; 
            if (0 > Coord_Index[j] || Coord_Index[j] >= Vars->Coord_Bin[j]) { 
              flag_outside=1; XY=0; break;
            }
            XY += Coord_Index[j]*Vars->Coord_BinProd[j-1];
          }
	  if (Vars->Flag_mantid && Vars->Flag_OFF && Vars->OFF_polyidx >=0) XY=Vars->OFF_polyidx;
          if (!flag_outside) XY += Vars->Coord_Min[i];
        }
        
        /* handle 'abs' and 'log' keywords */
        if (Vars->Coord_Type[i] & DEFS->COORD_ABS) XY=fabs(XY);

        if (Vars->Coord_Type[i] & DEFS->COORD_LOG) /* compute log of variable if requested */
        {  if (XY > 0) XY = log(XY)/log(10);
           else        XY = -100; }

        Coord[i] = XY; Coord_Index[i] = 0;
        if (i == 0) { pp = XY; Coord_Index[i] = 0; }
        else {
        /* check bounds for variables which have no automatic limits */
          if ((!Vars->Flag_Auto_Limits || !(Vars->Coord_Type[i] & DEFS->COORD_AUTO)) && Vars->Coord_Bin[i]>1)
          { /* compute index in histograms for each variable to monitor */
            XY = (Vars->Coord_Max[i]-Vars->Coord_Min[i]);
            if (XY > 0) Coord_Index[i] = floor((Coord[i]-Vars->Coord_Min[i])*Vars->Coord_Bin[i]/XY);
            if (Vars->Flag_With_Borders)
            {
              if (Coord_Index[i] >= Vars->Coord_Bin[i]) Coord_Index[i] = Vars->Coord_Bin[i] - 1;
              if (Coord_Index[i] < 0) Coord_Index[i] = 0;
            }
            //if (0 > Coord_Index[i] || Coord_Index[i] >= Vars->Coord_Bin[i])
            //  outsidebounds=1;
          } /* else will get Index later from Buffer when Flag_Auto_Limits == 2 */
        }
        
      } /* end for i */
      While_End = 1;
    }/* end else if Vars->Flag_Auto_Limits == 2 */
    
    /* ====================================================================== */
    /* store n1d/2d neutron from Buffer (Auto_Limits == 2) or current neutron in while */
    if (Vars->Flag_Auto_Limits != 1) /* not when storing auto limits Buffer */
    {
      /* apply per cm2 */
      if (Vars->Flag_per_cm2 && Vars->area != 0)
        pp /= Vars->area;

      /* 2D case : Vars->Coord_Number==2 and !Vars->Flag_Multiple and !Vars->Flag_List */
      if ( Vars->Coord_NumberNoPixel == 2 && !Vars->Flag_Multiple)
      { /* Dim : Vars->Coord_Bin[1]*Vars->Coord_Bin[2] matrix */
        
        i = Coord_Index[1];
        j = Coord_Index[2];
        if (i >= 0 && i < Vars->Coord_Bin[1] && j >= 0 && j < Vars->Coord_Bin[2])
        {
          if (Vars->Mon2D_N) { 
            Vars->Mon2D_N[i][j]++;
            Vars->Mon2D_p[i][j] += pp;
            Vars->Mon2D_p2[i][j] += pp*pp;
          }
        } else {
          outsidebounds=1; 
        }
      } else {
        /* 1D and n1D case : Vars->Flag_Multiple */
        /* Dim : Vars->Coord_Number*Vars->Coord_Bin[i] vectors (intensity is not included) */
          
        for (i= 1; i <= Vars->Coord_Number; i++) {
          j = Coord_Index[i];
          if (j >= 0 && j < Vars->Coord_Bin[i]) {
            if  (Vars->Flag_Multiple && Vars->Mon2D_N) {
              Vars->Mon2D_N[i-1][j]++;
              Vars->Mon2D_p[i-1][j]  += pp;
              Vars->Mon2D_p2[i-1][j] += pp*pp;
            }
          } else { 
            outsidebounds=1;
            break;
          }
        }
      }
    } /* end (Vars->Flag_Auto_Limits != 1) */
    
    if (Vars->Flag_Auto_Limits != 2 && !outsidebounds) /* not when reading auto limits Buffer */
    { /* now store Coord into Buffer (no index needed) if necessary (list or auto limits) */
      if ((Vars->Buffer_Counter < Vars->Buffer_Block) && ((Vars->Flag_List) || (Vars->Flag_Auto_Limits == 1)))
      {
          
        for (i = 0; i <= Vars->Coord_Number; i++)
        {
          Vars->Mon2D_Buffer[i + Vars->Neutron_Counter*(Vars->Coord_Number+1)] = Coord[i];
        }
        Vars->Buffer_Counter++;
        if (Vars->Flag_Verbose && (Vars->Buffer_Counter >= Vars->Buffer_Block) && (Vars->Flag_List == 1)) 
          printf("Monitor_nD: %s %li neutrons stored in List.\n", Vars->compcurname, Vars->Buffer_Counter);
      }
      Vars->Neutron_Counter++;
    } /* end (Vars->Flag_Auto_Limits != 2) */
    
  } /* end while */
  Vars->Nsum++;
  Vars->psum  += pp;
  Vars->p2sum += pp*pp;

  /*determine return value: 1:neutron was in bounds and measured, -1: outside bounds, 0: outside bounds, should be absorbed.*/
  if(outsidebounds){
      if(Vars->Flag_Absorb){
          return 0;
      }else{
          return -1;
      }
  }
  return 1;
} /* end Monitor_nD_Trace */

/* ========================================================================= */
/* Monitor_nD_Save: this routine is used to save data files                  */
/* ========================================================================= */

MCDETECTOR Monitor_nD_Save(MonitornD_Defines_type *DEFS, MonitornD_Variables_type *Vars)
  {
    char   *fname;
    long    i,j;
    double *p0m = NULL;
    double *p1m = NULL;
    double *p2m = NULL;
    char    Coord_X_Label[CHAR_BUF_LENGTH];
    double  min1d, max1d;
    double  min2d, max2d;
    long    bin1d, bin2d;
    char    While_End = 0;
    long    While_Buffer = 0;
    double  XY=0, pp=0;
    double  Coord[MONnD_COORD_NMAX];
    long    Coord_Index[MONnD_COORD_NMAX];
    char    label[CHAR_BUF_LENGTH];
    double  ratio;

    MCDETECTOR detector;

    ratio = 100.0*mcget_run_num()/mcget_ncount();
    if (Vars->Flag_Verbose && Vars->Flag_per_cm2) {
      printf("Monitor_nD: %s: active flat detector area is %g [cm^2], total area is %g [cm^2]\n",
        Vars->compcurname, (Vars->max_x-Vars->min_x)
                          *(Vars->max_y-Vars->min_y)*1E4, Vars->area);
      printf("Monitor_nD: %s: beam solid angle is %g [st] (%g x %g [deg^2])\n",
        Vars->compcurname,
        2*fabs(2*atan(Vars->mean_dx/Vars->mean_p)
         *sin(2*atan(Vars->mean_dy/Vars->mean_p)/2)),
        atan(Vars->mean_dx/Vars->mean_p)*RAD2DEG,
        atan(Vars->mean_dy/Vars->mean_p)*RAD2DEG);
    }

    /* check Buffer flush when end of simulation reached */
    if ((Vars->Buffer_Counter <= Vars->Buffer_Block) && Vars->Flag_Auto_Limits && Vars->Mon2D_Buffer && Vars->Buffer_Counter)
    {
      /* Get Auto Limits */
      if (Vars->Flag_Verbose) printf("Monitor_nD: %s getting %li Auto Limits from List (%li events).\n", Vars->compcurname, Vars->Coord_Number, Vars->Buffer_Counter);

      for (i = 1; i <= Vars->Coord_Number; i++)
      {
        if ((Vars->Coord_Type[i] & DEFS->COORD_AUTO) && Vars->Coord_Bin[i] > 1)
        {
          Vars->Coord_Min[i] = FLT_MAX;
          Vars->Coord_Max[i] = -FLT_MAX;
          for (j = 0; j < Vars->Buffer_Counter; j++)
          {
            XY = Vars->Mon2D_Buffer[i+j*(Vars->Coord_Number+1)];  /* scanning variables in Buffer */
            if (XY < Vars->Coord_Min[i]) Vars->Coord_Min[i] = XY;
            if (XY > Vars->Coord_Max[i]) Vars->Coord_Max[i] = XY;
          }
          if  (Vars->Flag_Verbose)  
            printf("  %s: min=%g max=%g in %li bins\n", Vars->Coord_Var[i], Vars->Coord_Min[i], Vars->Coord_Max[i], Vars->Coord_Bin[i]);
        }
      }
      Vars->Flag_Auto_Limits = 2;  /* pass to 2nd auto limits step */
      Vars->Buffer_Block = Vars->Buffer_Counter;

      while (!While_End)
      { /* we generate Coord[] and Coord_index[] from Buffer (auto limits) */
        /* simulation ended before Buffer was filled. Limits have to be computed, and stored events must be sent into histograms */
        
        if (While_Buffer < Vars->Buffer_Block)
        {
          /* first while loops (While_Buffer) */
          Coord[0] = Vars->Mon2D_Buffer[While_Buffer*(Vars->Coord_Number+1)];

          /* auto limits case : scan Buffer within limits and store in Mon2D */
          for (i = 1; i <= Vars->Coord_Number; i++)
          {
            /* scanning variables in Buffer */
            if (Vars->Coord_Bin[i] <= 1) Coord_Index[i] = 0;
            else {
              XY = (Vars->Coord_Max[i]-Vars->Coord_Min[i]);
              Coord[i] = Vars->Mon2D_Buffer[i+While_Buffer*(Vars->Coord_Number+1)];
              if (XY > 0) Coord_Index[i] = floor((Coord[i]-Vars->Coord_Min[i])*Vars->Coord_Bin[i]/XY);
              else Coord_Index[i] = 0;
              if (Vars->Flag_With_Borders)
              {
                if (Coord_Index[i] < 0) Coord_Index[i] = 0;
                if (Coord_Index[i] >= Vars->Coord_Bin[i]) Coord_Index[i] = Vars->Coord_Bin[i] - 1;
              }
            }
          } /* end for */

          /* update the PixelID, we compute it from the previous variables index */
          for (i = 1; i <= Vars->Coord_Number; i++) {
            char Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
            if (Set_Vars_Coord_Type == DEFS->COORD_PIXELID) {
              char outsidebounds=0;
              Coord_Index[i] = Coord[i] = 0;
              for (j= 1; j < i; j++) {
                /* not for 1D variables with Bin=1 such as PixelID, NCOUNT, Intensity */
                if (Vars->Coord_Bin[j] == 1) continue; 
                if (0 > Coord_Index[j] || Coord_Index[j] >= Vars->Coord_Bin[j]) {
                  outsidebounds=1;
                  Coord[i] = 0;
                  break;
                }
                Coord[i] += Coord_Index[j]*Vars->Coord_BinProd[j-1];
              }
              if (!outsidebounds) {
                Vars->Mon2D_Buffer[i+While_Buffer*(Vars->Coord_Number+1)] = Coord[i];
              }
            } /* end if PixelID */
          }
          While_Buffer++;
        } /* end if in Buffer */
        else /* (While_Buffer >= Vars->Buffer_Block) && (Vars->Flag_Auto_Limits == 2) */
        {
          Vars->Flag_Auto_Limits = 0;
          While_End = 1;
          if (Vars->Flag_Verbose) printf("Monitor_nD: %s flushed %li Auto Limits from List (%li).\n", Vars->compcurname, Vars->Coord_Number, Vars->Buffer_Counter);
        }

        /* store n1d/2d section from Buffer */

        pp = Coord[0];
        /* apply per cm2 or per st */
        if (Vars->Flag_per_cm2 && Vars->area      != 0)
          pp /= Vars->area;
        
        /* 2D case : Vars->Coord_Number==2 and !Vars->Flag_Multiple and !Vars->Flag_List */
        if (!Vars->Flag_Multiple && Vars->Coord_NumberNoPixel == 2)
        { /* Dim : Vars->Coord_Bin[1]*Vars->Coord_Bin[2] matrix */
          i = Coord_Index[1];
          j = Coord_Index[2];
          if (i >= 0 && i < Vars->Coord_Bin[1] && j >= 0 && j < Vars->Coord_Bin[2])
          {
            if (Vars->Mon2D_N) {
              Vars->Mon2D_N[i][j]++;
              Vars->Mon2D_p[i][j] += pp;
              Vars->Mon2D_p2[i][j] += pp*pp;
            }
          } else if (Vars->Flag_Absorb) pp=0;
        }
        else
        /* 1D and n1D case : Vars->Flag_Multiple */
        { /* Dim : Vars->Coord_Number*Vars->Coord_Bin[i] vectors (intensity is not included) */
          for (i= 1; i <= Vars->Coord_Number; i++)
          {
            j = Coord_Index[i];
            if (j >= 0 && j < Vars->Coord_Bin[i])
            {
              if (Vars->Flag_Multiple && Vars->Mon2D_N) {
                Vars->Mon2D_N[i-1][j]++;
                Vars->Mon2D_p[i-1][j] += pp;
                Vars->Mon2D_p2[i-1][j] += pp*pp;
              }
            } else if (Vars->Flag_Absorb) {
              pp=0; break;
            }
          }
        } /* end store 2D/1D */
        
      } /* end while */
    } /* end Force Get Limits */

    /* write output files (sent to file as p[i*n + j] vectors) */
    if (Vars->Coord_Number == 0)
    {
      double Nsum;
      double psum, p2sum;
      Nsum = Vars->Nsum;
      psum = Vars->psum;
      p2sum= Vars->p2sum;
      if (Vars->Flag_signal != DEFS->COORD_P && Nsum > 0)
      { psum /=Nsum; p2sum /= Nsum*Nsum; }
      /* DETECTOR_OUT_0D(Vars->Monitor_Label, Vars->Nsum, Vars->psum, Vars->p2sum); */
      detector = mcdetector_out_0D(Vars->Monitor_Label, Nsum, psum, p2sum, Vars->compcurname, Vars->compcurpos);
    }
    else
    if (strlen(Vars->Mon_File) > 0)
    {
      fname = (char*)malloc(strlen(Vars->Mon_File)+10*Vars->Coord_Number);
      if (Vars->Flag_List && Vars->Mon2D_Buffer) /* List: DETECTOR_OUT_2D */
      {
       
        if (Vars->Flag_List >= 2) Vars->Buffer_Size = Vars->Neutron_Counter;
        if (Vars->Buffer_Size >= Vars->Neutron_Counter)
          Vars->Buffer_Size = Vars->Neutron_Counter;
        strcpy(fname,Vars->Mon_File);
        if (strchr(Vars->Mon_File,'.') == NULL) strcat(fname, "_list");

        strcpy(Coord_X_Label,"");
        for (i= 0; i <= Vars->Coord_Number; i++)
        {
          strcat(Coord_X_Label, Vars->Coord_Var[i]);
          strcat(Coord_X_Label, " ");
          if (strchr(Vars->Mon_File,'.') == NULL)
          { strcat(fname, "."); strcat(fname, Vars->Coord_Var[i]); }
        }
        if (Vars->Flag_Verbose) printf("Monitor_nD: %s write monitor file %s List (%lix%li).\n", Vars->compcurname, fname,bin2d,bin1d);

        /* handle the type of list output */
        strcpy(label, Vars->Monitor_Label);
        
        detector = mcdetector_out_list(
              label, "List of neutron events", Coord_X_Label,
              -Vars->Buffer_Size, Vars->Coord_Number+1,
              Vars->Mon2D_Buffer,
              fname, Vars->compcurname, Vars->compcurpos);
      }
      if (Vars->Flag_Multiple) /* n1D: DETECTOR_OUT_1D */
      {
        for (i= 0; i < Vars->Coord_Number; i++)
        {

          strcpy(fname,Vars->Mon_File);
          if (strchr(Vars->Mon_File,'.') == NULL)
          { strcat(fname, "."); strcat(fname, Vars->Coord_Var[i+1]); }
          sprintf(Coord_X_Label, "%s monitor", Vars->Coord_Label[i+1]);
          strcpy(label, Coord_X_Label);
          if (Vars->Coord_Bin[i+1] > 0) { /* 1D monitor */
            if (Vars->Flag_Verbose) printf("Monitor_nD: %s write monitor file %s 1D (%li).\n", Vars->compcurname, fname, Vars->Coord_Bin[i+1]);
            min1d = Vars->Coord_Min[i+1];
            max1d = Vars->Coord_Max[i+1];
            if (min1d == max1d) max1d = min1d+1e-6;
            p1m = (double *)malloc(Vars->Coord_Bin[i+1]*sizeof(double));
            p2m = (double *)malloc(Vars->Coord_Bin[i+1]*sizeof(double));
            if (p2m == NULL) /* use Raw Buffer line output */
            {
              if (Vars->Flag_Verbose) printf("Monitor_nD: %s cannot allocate memory for output. Using raw data.\n", Vars->compcurname);
              if (p1m != NULL) free(p1m);
              detector = mcdetector_out_1D(
              label,
              Vars->Coord_Label[i+1],
              Vars->Coord_Label[0],
              Vars->Coord_Var[i+1],
              min1d, max1d,
              Vars->Coord_Bin[i+1],
              Vars->Mon2D_N[i],Vars->Mon2D_p[i],Vars->Mon2D_p2[i],
              fname, Vars->compcurname, Vars->compcurpos);
            } /* if (p2m == NULL) */
            else
            {
              if (Vars->Flag_log != 0)
              {
                XY = FLT_MAX;
                for (j=0; j < Vars->Coord_Bin[i+1]; j++) /* search min of signal */
                  if ((XY > Vars->Mon2D_p[i][j]) && (Vars->Mon2D_p[i][j] > 0)) XY = Vars->Mon2D_p[i][j];
                if (XY <= 0) XY = -log(FLT_MAX)/log(10); else XY = log(XY)/log(10)-1;
              } /* if */

              for (j=0; j < Vars->Coord_Bin[i+1]; j++)
              {
                p1m[j] = Vars->Mon2D_p[i][j];
                p2m[j] = Vars->Mon2D_p2[i][j];
                if (Vars->Flag_signal != DEFS->COORD_P && Vars->Mon2D_N[i][j] > 0)
                { /* normalize mean signal to the number of events */
                  p1m[j] /= Vars->Mon2D_N[i][j];
                  p2m[j] /= Vars->Mon2D_N[i][j]*Vars->Mon2D_N[i][j];
                }
                if (Vars->Flag_log != 0)
                {
                  if ((p1m[j] > 0) && (p2m[j] > 0))
                  {
                    p2m[j] /= p1m[j]*p1m[j];
                    p1m[j] = log(p1m[j])/log(10);
                  }
                  else
                  {
                    p1m[j] = XY;
                    p2m[j] = 0;
                  }
                }
              } /* for */
              detector = mcdetector_out_1D(
                label,
                Vars->Coord_Label[i+1],
                Vars->Coord_Label[0],
                Vars->Coord_Var[i+1],
                min1d, max1d,
                Vars->Coord_Bin[i+1],
                Vars->Mon2D_N[i],p1m,p2m,
                fname, Vars->compcurname, Vars->compcurpos);

            } /* else */
            /* comment out 'free memory' lines to avoid loosing arrays if
               'detector' structure is used by other instrument parts
            if (p1m != NULL) free(p1m); p1m=NULL;
            if (p2m != NULL) free(p2m); p2m=NULL;
            */
          } else { /* 0d monitor */
            detector = mcdetector_out_0D(label, Vars->Mon2D_p[i][0], Vars->Mon2D_p2[i][0], Vars->Mon2D_N[i][0], Vars->compcurname, Vars->compcurpos);
          }


        } /* for */
      } /* if 1D */
      else
      if (Vars->Coord_NumberNoPixel == 2)  /* 2D: DETECTOR_OUT_2D */
      {
        strcpy(fname,Vars->Mon_File);

        p0m = (double *)malloc(Vars->Coord_Bin[1]*Vars->Coord_Bin[2]*sizeof(double));
        p1m = (double *)malloc(Vars->Coord_Bin[1]*Vars->Coord_Bin[2]*sizeof(double));
        p2m = (double *)malloc(Vars->Coord_Bin[1]*Vars->Coord_Bin[2]*sizeof(double));
        if (p2m == NULL)
        {
          if (Vars->Flag_Verbose) printf("Monitor_nD: %s cannot allocate memory for 2D array (%li). Skipping.\n", Vars->compcurname, 3*Vars->Coord_Bin[1]*Vars->Coord_Bin[2]*sizeof(double));
          /* comment out 'free memory' lines to avoid loosing arrays if
               'detector' structure is used by other instrument parts
          if (p0m != NULL) free(p0m);
          if (p1m != NULL) free(p1m);
          */
        }
        else
        {
          if (Vars->Flag_log != 0)
          {
            XY = FLT_MAX;
            for (i= 0; i < Vars->Coord_Bin[1]; i++)
              for (j= 0; j < Vars->Coord_Bin[2]; j++) /* search min of signal */
                if ((XY > Vars->Mon2D_p[i][j]) && (Vars->Mon2D_p[i][j]>0)) XY = Vars->Mon2D_p[i][j];
            if (XY <= 0) XY = -log(FLT_MAX)/log(10); else XY = log(XY)/log(10)-1;
          }
          for (i= 0; i < Vars->Coord_Bin[1]; i++)
          {
            for (j= 0; j < Vars->Coord_Bin[2]; j++)
            {
              long index;
              index = j + i*Vars->Coord_Bin[2];
              p0m[index] = Vars->Mon2D_N[i][j];
              p1m[index] = Vars->Mon2D_p[i][j];
              p2m[index] = Vars->Mon2D_p2[i][j];
              if (Vars->Flag_signal != DEFS->COORD_P && p0m[index] > 0)
              {
                  p1m[index] /= p0m[index];
                  p2m[index] /= p0m[index]*p0m[index];
              }

              if (Vars->Flag_log != 0)
              {
                if ((p1m[index] > 0) && (p2m[index] > 0))
                {
                  p2m[index] /= (p1m[index]*p1m[index]);
                  p1m[index] = log(p1m[index])/log(10);

                }
                else
                {
                  p1m[index] = XY;
                  p2m[index] = 0;
                }
              }
            }
          }
          if (strchr(Vars->Mon_File,'.') == NULL)
          { strcat(fname, "."); strcat(fname, Vars->Coord_Var[1]);
              strcat(fname, "_"); strcat(fname, Vars->Coord_Var[2]); }
          if (Vars->Flag_Verbose) printf("Monitor_nD: %s write monitor file %s 2D (%lix%li).\n", Vars->compcurname, fname, Vars->Coord_Bin[1], Vars->Coord_Bin[2]);

          min1d = Vars->Coord_Min[1];
          max1d = Vars->Coord_Max[1];
          if (min1d == max1d) max1d = min1d+1e-6;
          min2d = Vars->Coord_Min[2];
          max2d = Vars->Coord_Max[2];
          if (min2d == max2d) max2d = min2d+1e-6;
          strcpy(label, Vars->Monitor_Label);
          if (Vars->Coord_Bin[1]*Vars->Coord_Bin[2] > 1
           && Vars->Flag_signal == DEFS->COORD_P)
            strcat(label, " per bin");

          detector = mcdetector_out_2D(
            label,
            Vars->Coord_Label[1],
            Vars->Coord_Label[2],
            min1d, max1d,
            min2d, max2d,
            Vars->Coord_Bin[1],
            Vars->Coord_Bin[2],
            p0m,p1m,p2m,
            fname, Vars->compcurname, Vars->compcurpos);

          /* comment out 'free memory' lines to avoid loosing arrays if
               'detector' structure is used by other instrument parts
          if (p0m != NULL) free(p0m);
          if (p1m != NULL) free(p1m);
          if (p2m != NULL) free(p2m);
          */
        }
      }
      free(fname);
    }
    return(detector);
  } /* end Monitor_nD_Save */

/* ========================================================================= */
/* Monitor_nD_Finally: this routine is used to free memory                   */
/* ========================================================================= */

void Monitor_nD_Finally(MonitornD_Defines_type *DEFS,
  MonitornD_Variables_type *Vars)
  {
    int i;

    /* Now Free memory Mon2D.. */
    if ((Vars->Flag_Auto_Limits || Vars->Flag_List) && Vars->Coord_Number)
    { /* Dim : (Vars->Coord_Number+1)*Vars->Buffer_Block matrix (for p, dp) */
      if (Vars->Mon2D_Buffer != NULL) free(Vars->Mon2D_Buffer);
    }

    /* 1D and n1D case : Vars->Flag_Multiple */
    if (Vars->Flag_Multiple && Vars->Coord_Number)
    { /* Dim : Vars->Coord_Number*Vars->Coord_Bin[i] vectors */
      for (i= 0; i < Vars->Coord_Number; i++)
      {
        free(Vars->Mon2D_N[i]);
        free(Vars->Mon2D_p[i]);
        free(Vars->Mon2D_p2[i]);
      }
      free(Vars->Mon2D_N);
      free(Vars->Mon2D_p);
      free(Vars->Mon2D_p2);
    }


    /* 2D case : Vars->Coord_Number==2 and !Vars->Flag_Multiple and !Vars->Flag_List */
    if ((Vars->Coord_NumberNoPixel == 2) && !Vars->Flag_Multiple)
    { /* Dim : Vars->Coord_Bin[1]*Vars->Coord_Bin[2] matrix */
      for (i= 0; i < Vars->Coord_Bin[1]; i++)
      {
        free(Vars->Mon2D_N[i]);
        free(Vars->Mon2D_p[i]);
        free(Vars->Mon2D_p2[i]);
      }
      free(Vars->Mon2D_N);
      free(Vars->Mon2D_p);
      free(Vars->Mon2D_p2);
    }
  } /* end Monitor_nD_Finally */

/* ========================================================================= */
/* Monitor_nD_McDisplay: this routine is used to display component           */
/* ========================================================================= */

void Monitor_nD_McDisplay(MonitornD_Defines_type *DEFS,
  MonitornD_Variables_type *Vars)
  {
    double radius, h;
    double xmin;
    double xmax;
    double ymin;
    double ymax;
    double zmin;
    double zmax;
    int    i;
    double hdiv_min=-180, hdiv_max=180, vdiv_min=-90, vdiv_max=90;
    char   restricted = 0;

    radius = Vars->Sphere_Radius;
    h = Vars->Cylinder_Height;
    xmin = Vars->mxmin;
    xmax = Vars->mxmax;
    ymin = Vars->mymin;
    ymax = Vars->mymax;
    zmin = Vars->mzmin;
    zmax = Vars->mzmax;

    /* determine if there are angular limits set at start (no auto) in coord_types
     * cylinder/banana: look for hdiv
     * sphere: look for angle, radius (->atan2(val,radius)), hdiv, vdiv
     * this activates a 'restricted' flag, to draw a region as blades on cylinder/sphere
     */
    for (i= 0; i <= Vars->Coord_Number; i++)
    {
      int Set_Vars_Coord_Type;
      Set_Vars_Coord_Type = (Vars->Coord_Type[i] & (DEFS->COORD_LOG-1));
      if (Set_Vars_Coord_Type == DEFS->COORD_HDIV || Set_Vars_Coord_Type == DEFS->COORD_THETA)
      { hdiv_min = Vars->Coord_Min[i]; hdiv_max = Vars->Coord_Max[i]; restricted = 1; }
      else if (Set_Vars_Coord_Type == DEFS->COORD_VDIV || Set_Vars_Coord_Type == DEFS->COORD_PHI)
      { vdiv_min = Vars->Coord_Min[i]; vdiv_max = Vars->Coord_Max[i];restricted = 1;  }
      else if (Set_Vars_Coord_Type == DEFS->COORD_ANGLE)
      { hdiv_min = vdiv_min = Vars->Coord_Min[i];
        hdiv_max = vdiv_max = Vars->Coord_Max[i];
        restricted = 1; }
      else if (Set_Vars_Coord_Type == DEFS->COORD_RADIUS)
      { double angle;
        angle = RAD2DEG*atan2(Vars->Coord_Max[i], radius);
        hdiv_min = vdiv_min = angle;
        hdiv_max = vdiv_max = angle;
        restricted = 1; }
      else if (Set_Vars_Coord_Type == DEFS->COORD_Y && abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE)
      {
        vdiv_min = atan2(ymin,radius)*RAD2DEG;
        vdiv_max = atan2(ymax,radius)*RAD2DEG;
        restricted = 1;
      }
    }
    /* full sphere */
    if ((!restricted && (abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE))
    || abs(Vars->Flag_Shape) == DEFS->SHAPE_PREVIOUS)
    {
      mcdis_magnify("");
      mcdis_circle("xy",0,0,0,radius);
      mcdis_circle("xz",0,0,0,radius);
      mcdis_circle("yz",0,0,0,radius);
    }
    /* banana/cylinder/sphere portion */
    else
    if (restricted && ((abs(Vars->Flag_Shape) == DEFS->SHAPE_CYLIND)
                    || (abs(Vars->Flag_Shape) == DEFS->SHAPE_BANANA)
                    || (abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE)))
    {
      int NH=24, NV=24;
      int ih, iv;
      double width, height;
      int issphere;
      issphere = (abs(Vars->Flag_Shape) == DEFS->SHAPE_SPHERE);
      width = (hdiv_max-hdiv_min)/NH;
      if (!issphere) NV=1; /* cylinder has vertical axis */
      else height= (vdiv_max-vdiv_min)/NV;
      
      /* check width and height of elements (sphere) to make sure the nb
         of plates remains limited */
      if (width < 10  && NH > 1) { width = 10;  NH=(hdiv_max-hdiv_min)/width; width=(hdiv_max-hdiv_min)/NH; }
      if (height < 10 && NV > 1) { height = 10; NV=(vdiv_max-vdiv_min)/height; height= (vdiv_max-vdiv_min)/NV; }
      
      mcdis_magnify("xyz");
      for(ih = 0; ih < NH; ih++)
        for(iv = 0; iv < NV; iv++)
        {
          double theta0, phi0, theta1, phi1;          /* angles in spherical coordinates */
          double x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3; /* vertices at plate edges */
          phi0 = (hdiv_min+ width*ih-90)*DEG2RAD;        /* in xz plane */
          phi1 = (hdiv_min+ width*(ih+1)-90)*DEG2RAD;
          if (issphere)
          {
            theta0= (vdiv_min+height* iv + 90)   *DEG2RAD; /* in vertical plane */
            theta1= (vdiv_min+height*(iv+1) + 90)*DEG2RAD;
            if (y0 < ymin) y0=ymin; 
            if (y0 > ymax) y0=ymax;
            if (y1 < ymin) y1=ymin; 
            if (y1 > ymax) y1=ymax;
            
            y0 = -radius*cos(theta0);            /* z with Z vertical */
            y1 = -radius*cos(theta1);
            if (y0 < ymin) y0=ymin;
            if (y0 > ymax) y0=ymax;
            if (y1 < ymin) y1=ymin;
            if (y1 > ymax) y1=ymax;
          } else {
            y0 = ymin;
            y1 = ymax;
            theta0=theta1=90*DEG2RAD;
          }

          x0 = radius*sin(theta0)*cos(phi0); /* x with Z vertical */
          z0 =-radius*sin(theta0)*sin(phi0); /* y with Z vertical */
          x1 = radius*sin(theta1)*cos(phi0); 
          z1 =-radius*sin(theta1)*sin(phi0);
          x2 = radius*sin(theta1)*cos(phi1); 
          z2 =-radius*sin(theta1)*sin(phi1);
          x3 = radius*sin(theta0)*cos(phi1); 
          z3 =-radius*sin(theta0)*sin(phi1);
          y2 = y1; y3 = y0;

          mcdis_multiline(5,
            x0,y0,z0,
            x1,y1,z1,
            x2,y2,z2,
            x3,y3,z3,
            x0,y0,z0);
        }
      if (Vars->Flag_mantid) {
	/* First define the base pixel type */
	double dt, dy;
	dt = (Vars->Coord_Max[1]-Vars->Coord_Min[1])/Vars->Coord_Bin[1];
	dy = (Vars->Coord_Max[2]-Vars->Coord_Min[2])/Vars->Coord_Bin[2];
	printf("MANTID_BANANA_DET:  %g, %g, %g, %g, %g, %li, %li, %g\n", radius, 
	       Vars->Coord_Min[1],Vars->Coord_Max[1], Vars->Coord_Min[2],Vars->Coord_Max[2], Vars->Coord_Bin[1], Vars->Coord_Bin[2], Vars->Coord_Min[4]); 
      }
    }
    /* disk (circle) */
    else
    if (abs(Vars->Flag_Shape) == DEFS->SHAPE_DISK)
    {
      mcdis_magnify("");
      mcdis_circle("xy",0,0,0,radius);
    }
    /* rectangle (square) */
    else
    if (abs(Vars->Flag_Shape) == DEFS->SHAPE_SQUARE)
    {
      mcdis_magnify("xy");
      mcdis_multiline(5, (double)xmin, (double)ymin, 0.0,
             (double)xmax, (double)ymin, 0.0,
             (double)xmax, (double)ymax, 0.0,
             (double)xmin, (double)ymax, 0.0,
             (double)xmin, (double)ymin, 0.0);
      
      if (Vars->Flag_mantid) {
	/* First define the base pixel type */
	double dx, dy;
	dx = (Vars->Coord_Max[1]-Vars->Coord_Min[1])/Vars->Coord_Bin[1];
	dy = (Vars->Coord_Max[2]-Vars->Coord_Min[2])/Vars->Coord_Bin[2];
	printf("MANTID_RECTANGULAR_DET:  %g, %g, %g, %g, %li, %li, %g\n", 
	       Vars->Coord_Min[1],Vars->Coord_Max[1], Vars->Coord_Min[2],Vars->Coord_Max[2], Vars->Coord_Bin[1], Vars->Coord_Bin[2], Vars->Coord_Min[4]);
      }
    }
    /* full cylinder/banana */
    else
    if (!restricted && ((abs(Vars->Flag_Shape) == DEFS->SHAPE_CYLIND) || (abs(Vars->Flag_Shape) == DEFS->SHAPE_BANANA)))
    {
      mcdis_magnify("xyz");
      mcdis_circle("xz", 0,  h/2.0, 0, radius);
      mcdis_circle("xz", 0, -h/2.0, 0, radius);
      mcdis_line(-radius, -h/2.0, 0, -radius, +h/2.0, 0);
      mcdis_line(+radius, -h/2.0, 0, +radius, +h/2.0, 0);
      mcdis_line(0, -h/2.0, -radius, 0, +h/2.0, -radius);
      mcdis_line(0, -h/2.0, +radius, 0, +h/2.0, +radius);
    }
    else
    /* box */
    if (abs(Vars->Flag_Shape) == DEFS->SHAPE_BOX)
    {
      mcdis_magnify("xyz");
      mcdis_multiline(5, xmin, ymin, zmin,
                   xmax, ymin, zmin,
                   xmax, ymax, zmin,
                   xmin, ymax, zmin,
                   xmin, ymin, zmin);
      mcdis_multiline(5, xmin, ymin, zmax,
                   xmax, ymin, zmax,
                   xmax, ymax, zmax,
                   xmin, ymax, zmax,
                   xmin, ymin, zmax);
      mcdis_line(xmin, ymin, zmin, xmin, ymin, zmax);
      mcdis_line(xmax, ymin, zmin, xmax, ymin, zmax);
      mcdis_line(xmin, ymax, zmin, xmin, ymax, zmax);
      mcdis_line(xmax, ymax, zmin, xmax, ymax, zmax);
    }
  } /* end Monitor_nD_McDisplay */

/* end of monitor_nd-lib.c */


/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2008, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/interoff.h
*
* %Identification
* Written by: Reynald Arnerin
* Date:    Jun 12, 2008
* Release: 
* Version: 
*
* Object File Format intersection header for McStas. Requires the qsort function.
*
* Such files may be obtained with e.g.
*   qhull < points.xyz Qx Qv Tv o > points.off
* where points.xyz has format:
*   3
*   <nb_points>
*   <x> <y> <z>
*   ...
* The resulting file should have its first line being changed from '3' into 'OFF'.
* It can then be displayed with geomview.
* A similar, but somewhat older solution is to use 'powercrust' with e.g.
*   powercrust -i points.xyz
* which will generate a 'pc.off' file to be renamed as suited.
*
*******************************************************************************/

#ifndef INTEROFF_LIB_H
#define INTEROFF_LIB_H "$Revision$"

#ifndef EPSILON
#define EPSILON 1e-13
#endif

#define OFF_INTERSECT_MAX 100

//#include <float.h>

#define N_VERTEX_DISPLAYED    200000

typedef struct intersection {
	MCNUM time;  	  //time of the intersection
	Coords v;	      //intersection point
	Coords normal;  //normal vector of the surface intersected
	short in_out;	  //1 if the ray enters the volume, -1 otherwise
	short edge;	    //1 if the intersection is on the boundary of the polygon, and error is possible
	unsigned long index; // index of the face
} intersection;

typedef struct polygon {
  MCNUM* p;       //vertices of the polygon in adjacent order, this way : x1 | y1 | z1 | x2 | y2 | z2 ...
  int npol;       //number of vertices
  Coords normal;
} polygon;

typedef struct off_struct {
    long vtxSize;
    long polySize;
    long faceSize;
    Coords* vtxArray;
    Coords* normalArray;
    unsigned long* faceArray;
    char *filename;
    int mantidflag;
    long mantidoffset;
    intersection intersects[OFF_INTERSECT_MAX]; // After a call to off_intersect_all contains the list of intersections.
    int nextintersect;                 // 'Next' intersection (first t>0) solution after call to off_intersect_all
    int numintersect;               // Number of intersections after call to off_intersect_all
} off_struct;

/*******************************************************************************
* long off_init(  char *offfile, double xwidth, double yheight, double zdepth, off_struct* data)
* ACTION: read an OFF file, optionally center object and rescale, initialize OFF data structure
* INPUT: 'offfile' OFF file to read
*        'xwidth,yheight,zdepth' if given as non-zero, apply bounding box. 
*           Specifying only one of these will also use the same ratio on all axes
*        'notcenter' center the object to the (0,0,0) position in local frame when set to zero
* RETURN: number of polyhedra and 'data' OFF structure 
*******************************************************************************/
long off_init(  char *offfile, double xwidth, double yheight, double zdepth, 
                int notcenter, off_struct* data);

/*******************************************************************************
* int off_intersect_all(double* t0, double* t3, 
     Coords *n0, Coords *n3,
     double x, double y, double z, 
     double vx, double vy, double vz, 
     off_struct *data )
* ACTION: computes intersection of neutron trajectory with an object. 
* INPUT:  x,y,z and vx,vy,vz are the position and velocity of the neutron
*         data points to the OFF data structure
* RETURN: the number of polyhedra which trajectory intersects
*         t0 and t3 are the smallest incoming and outgoing intersection times
*         n0 and n3 are the corresponding normal vectors to the surface
*         data is the full OFF structure, including a list intersection type
*******************************************************************************/
int off_intersect_all(double* t0, double* t3, 
     Coords *n0, Coords *n3,
     double x, double y, double z, 
     double vx, double vy, double vz, 
     off_struct *data );

/*******************************************************************************
* int off_intersect(double* t0, double* t3, 
     Coords *n0, Coords *n3,
     double x, double y, double z, 
     double vx, double vy, double vz, 
     off_struct data )
* ACTION: computes intersection of neutron trajectory with an object. 
* INPUT:  x,y,z and vx,vy,vz are the position and velocity of the neutron
*         data points to the OFF data structure
* RETURN: the number of polyhedra which trajectory intersects
*         t0 and t3 are the smallest incoming and outgoing intersection times
*         n0 and n3 are the corresponding normal vectors to the surface
*******************************************************************************/
int off_intersect(double* t0, double* t3, 
     Coords *n0, Coords *n3,
     double x, double y, double z, 
     double vx, double vy, double vz, 
     off_struct data );

/*****************************************************************************
* int off_intersectx(double* l0, double* l3, 
     Coords *n0, Coords *n3,
     double x, double y, double z, 
     double kx, double ky, double kz, 
     off_struct data )
* ACTION: computes intersection of an xray trajectory with an object.
* INPUT:  x,y,z and kx,ky,kz, are spatial coordinates and wavevector of the x-ray
*         respectively. data points to the OFF data structure.
* RETURN: the number of polyhedra the trajectory intersects
*         l0 and l3 are the smallest incoming and outgoing intersection lengths
*         n0 and n3 are the corresponding normal vectors to the surface
*******************************************************************************/
int off_x_intersect(double *l0,double *l3,
     Coords *n0, Coords *n3,
     double x,  double y,  double z, 
     double kx, double ky, double kz, 
     off_struct data );

/*******************************************************************************
* void off_display(off_struct data)
* ACTION: display up to N_VERTEX_DISPLAYED points from the object
*******************************************************************************/
void off_display(off_struct);

#endif

/* end of interoff-lib.h */
/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2008, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Runtime: share/interoff-lib.c
*
* %Identification
* Written by: Reynald Arnerin
* Date:    Jun 12, 2008
* Origin: ILL
* Release: $Revision$
* Version: McStas X.Y
*
* Object File Format intersection library for McStas. Requires the qsort function.
*
* Such files may be obtained with e.g.
*   qhull < points.xyz Qx Qv Tv o > points.off
* where points.xyz has format (it supports comments):
*   3
*   <nb_points>
*   <x> <y> <z>
*   ...
* The resulting file should have its first line being changed from '3' into 'OFF'.
* It can then be displayed with geomview.
* A similar, but somewhat older solution is to use 'powercrust' with e.g.
*   powercrust -i points.xyz
* which will generate a 'pc.off' file to be renamed as suited.
*
*******************************************************************************/

#ifndef INTEROFF_LIB_H
#include "interoff-lib.h"
#endif

double off_F(double x, double y,double z,double A,double B,double C,double D) {
  return ( A*x + B*y + C*z + D );
}

char off_sign(double a) {
  if (a<0)       return(-1);
  else if (a==0) return(0);
  else           return(1);
}

// off_normal ******************************************************************
//gives the normal vector of p
void off_normal(Coords* n, polygon p)
{
  //using Newell method
  int i=0,j=0;
  n->x=0;n->y=0;n->z=0;
  for (i = 0, j = p.npol-1; i < p.npol; j = i++)
  {
    MCNUM x1=p.p[3*i],
          y1=p.p[3*i+1],
          z1=p.p[3*i+2];
    MCNUM x2=p.p[3*j],
          y2=p.p[3*j+1],
          z2=p.p[3*j+2];
    // n is the cross product of v1*v2
    n->x += (y1 - y2) * (z1 + z2);
    n->y += (z1 - z2) * (x1 + x2);
    n->z += (x1 - x2) * (y1 + y2);
  }
} /* off_normal */

// off_pnpoly ******************************************************************
//based on http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
//return 0 if the vertex is out
//    1 if it is in
//   -1 if on the boundary
int off_pnpoly(polygon p, Coords v)
{
  int i=0, c = 0;
  MCNUM minx=FLT_MAX,maxx=-FLT_MAX,miny=FLT_MAX,maxy=-FLT_MAX,minz=FLT_MAX,maxz=-FLT_MAX;
  MCNUM rangex=0,rangey=0,rangez=0;

  int pol2dx=0,pol2dy=1;          //2d restriction of the poly
  MCNUM x=v.x,y=v.y;


  //take the most relevant 2D projection (prevent from instability)
  for (i=0; i<p.npol; ++i)
  {
    if (p.p[3*i]<minx)   minx=p.p[3*i];
    if (p.p[3*i]>maxx)   maxx=p.p[3*i];
    if (p.p[3*i+1]<miny) miny=p.p[3*i+1];
    if (p.p[3*i+1]>maxy) maxy=p.p[3*i+1];
    if (p.p[3*i+2]<minz) minz=p.p[3*i+2];
    if (p.p[3*i+2]>maxz) maxz=p.p[3*i+2];
  }
  rangex=maxx-minx;
  rangey=maxy-miny;
  rangez=maxz-minz;

  if (rangex<rangez)
  {
    if (rangex<rangey) {
      pol2dx=2;
      x=v.z;
    } else {
      pol2dy=2;
      y=v.z;
    }
  }
  else if (rangey<rangez) {
    pol2dy=2;
    y=v.z;
  }

  //trace rays and test number of intersection
  int j;
  for (i = 0, j = p.npol-1; i < p.npol; j = i++) {
    if (((((p.p[3*i+pol2dy])<=y) && (y<(p.p[3*j+pol2dy]))) ||
         (((p.p[3*j+pol2dy])<=y) && (y<(p.p[3*i+pol2dy])))) &&
        (x < ( (p.p[3*j+pol2dx] - p.p[3*i+pol2dx]) * (y - p.p[3*i+pol2dy])
             / (p.p[3*j+pol2dy] - p.p[3*i+pol2dy]) + p.p[3*i+pol2dx]) ))
      c = !c;

    if (((fabs(p.p[3*i+pol2dy]-y)<=EPSILON) || ((fabs(p.p[3*j+pol2dy]-y)<=EPSILON))) &&
        fabs(x -((p.p[3*j+pol2dx] - p.p[3*i+pol2dx]) * (y - p.p[3*i+pol2dy])
          / (p.p[3*j+pol2dy] - p.p[3*i+pol2dy]) + p.p[3*i+pol2dx])) < EPSILON)
    {
      //the point lies on the edge
      c=-1;
      break;
    }
  }

  return c;
} /* off_pnpoly */

// off_intersectPoly ***********************************************************
//gives the intersection vertex between ray [a,b) and polygon p and its parametric value on (a b)
//based on http://geometryalgorithms.com/Archive/algorithm_0105/algorithm_0105.htm
int off_intersectPoly(intersection *inter, Coords a, Coords b, polygon p)
{
  //direction vector of [a,b]
  Coords dir = {b.x-a.x, b.y-a.y, b.z-a.z};

  //the normal vector to the polygon
  Coords normale=p.normal;
  //off_normal(&normale, p); done at the init stage

  //direction vector from a to a vertex of the polygon
  Coords w0 = {a.x-p.p[0], a.y-p.p[1], a.z-p.p[2]};

  //scalar product
  MCNUM nw0  =-scalar_prod(normale.x,normale.y,normale.z,w0.x,w0.y,w0.z);
  MCNUM ndir = scalar_prod(normale.x,normale.y,normale.z,dir.x,dir.y,dir.z);
  inter->time = inter->edge = inter->in_out=0;
  inter->v = inter->normal = coords_set(0,0,1);

  if (fabs(ndir) < EPSILON)    // ray is parallel to polygon plane
  {
    if (nw0 == 0)              // ray lies in polygon plane (infinite number of solution)
      return 0;
    else return 0;             // ray disjoint from plane (no solution)
  }

  // get intersect point of ray with polygon plane
  inter->time = nw0 / ndir;            //parametric value the point on line (a,b)

  inter->v = coords_set(a.x + inter->time * dir.x,// intersect point of ray and plane
    a.y + inter->time * dir.y,
    a.z + inter->time * dir.z);

  int res=off_pnpoly(p,inter->v);

  inter->edge=(res==-1);
  if (ndir<0)
    inter->in_out=1;  //the negative dot product means we enter the surface
  else
    inter->in_out=-1;

  inter->normal=p.normal;

  return res;         //true if the intersection point lies inside the poly
} /* off_intersectPoly */


// off_getBlocksIndex **********************************************************
/*reads the indexes at the beginning of the off file as this :
line 1  OFF
line 2  nbVertex nbFaces nbEdges
*/
FILE *off_getBlocksIndex(char* filename, long* vtxSize, long* polySize )
{
  FILE* f = Open_File(filename,"r", NULL); /* from read_table-lib: FILE *Open_File(char *name, char *Mode, char *path) */
  if (!f) return (f);
  
  char line[CHAR_BUF_LENGTH];
  char *ret=0;
  *vtxSize = *polySize = 0;

  /* **************** start to read the file header */
  /* OFF file:
     'OFF' or '3'
   */

  ret=fgets(line,CHAR_BUF_LENGTH , f);// line 1 = "OFF"
  if (ret == NULL)
  {
    fprintf(stderr, "Error: Can not read 1st line in file %s (interoff/off_getBlocksIndex)\n", filename);
    exit(1);
  }
  if (strlen(line)>5)
  {
      fprintf(stderr,"Error: First line in %s is too long (=%lu). Possibly the line is not terminated by '\\n'.\n" 
              "       The first line is required to be exactly 'OFF', '3' or 'ply'.\n",filename,strlen(line));
      fclose(f);
      return(NULL);
  }

  if (strncmp(line,"OFF",3) && strncmp(line,"3",1) && strncmp(line,"ply",1))
  {
    fprintf(stderr, "Error: %s is probably not an OFF, NOFF or PLY file (interoff/off_getBlocksIndex).\n"
                    "       Requires first line to be 'OFF', '3' or 'ply'.\n",filename);
    fclose(f);
    return(NULL);
  }

  if (!strncmp(line,"OFF",3) || !strncmp(line,"3",1)) {
    do  /* OFF file: skip # comments which may be there */
    {
      ret=fgets(line,CHAR_BUF_LENGTH , f);
      if (ret == NULL)
      {
        fprintf(stderr, "Error: Can not read line in file %s (interoff/off_getBlocksIndex)\n", filename);
        exit(1);
      }
    } while (line[0]=='#');
    //line = nblines of vertex,faces and edges arrays
    sscanf(line,"%lu %lu",vtxSize,polySize);
  } else {
    do  /* PLY file: read all lines until find 'end_header'
           and locate 'element faces' and 'element vertex' */
    {
      ret=fgets(line,CHAR_BUF_LENGTH , f);
      if (ret == NULL)
      {
        fprintf(stderr, "Error: Can not read line in file %s (interoff/off_getBlocksIndex)\n", filename);
        exit(1);
      }
      if (!strncmp(line,"element face",12))
        sscanf(line,"element face %lu",polySize);
      else if (!strncmp(line,"element vertex",14))
        sscanf(line,"element vertex %lu",vtxSize);
      else if (!strncmp(line,"format binary",13))
        exit(fprintf(stderr,
          "Error: Can not read binary PLY file %s, only 'format ascii' (interoff/off_getBlocksIndex)\n%s\n",
          filename, line));
    } while (strncmp(line,"end_header",10));
  }
  
  /* The FILE is left opened ready to read 'vtxSize' vertices (vtxSize *3 numbers)
     and then polySize polygons (rows) */

  return(f);
} /* off_getBlocksIndex */

// off_init_planes *************************************************************
//gives the equations of 2 perpandicular planes of [ab]
void off_init_planes(Coords a, Coords b,
  MCNUM* A1, MCNUM* C1, MCNUM* D1, MCNUM *A2, MCNUM* B2, MCNUM* C2, MCNUM* D2)
{
  //direction vector of [a b]
  Coords dir={b.x-a.x, b.y-a.y, b.z-a.z};

  //the plane parallel to the 'y' is computed with the normal vector of the projection of [ab] on plane 'xz'
  *A1= dir.z;
  *C1=-dir.x;
  if(*A1!=0 || *C1!=0)
    *D1=-(a.x)*(*A1)-(a.z)*(*C1);
  else
  {
    //the plane does not support the vector, take the one parallel to 'z''
    *A1=1;
    //B1=dir.x=0
    *D1=-(a.x);
  }
  //the plane parallel to the 'x' is computed with the normal vector of the projection of [ab] on plane 'yz'
  *B2= dir.z;
  *C2=-dir.y;
  *A2= 0;
  if (*B2==0 && *C2==0)
  {
    //the plane does not support the vector, take the one parallel to 'z'
    *B2=1;
    //B1=dir.x=0
    *D2=-(a.y);
  }
  else {
    if (dir.z==0)
    {
      //the planes are the same, take the one parallel to 'z'
      *A2= dir.y;
      *B2=-dir.x;
      *D2=-(a.x)*(*A2)-(a.y)*(*B2);
    }
    else
      *D2=-(a.y)**B2-(a.z)**C2;
  }
} /* off_init_planes */

// off_clip_3D_mod *************************************************************
int off_clip_3D_mod(intersection* t, Coords a, Coords b,
  Coords* vtxArray, unsigned long vtxSize, unsigned long* faceArray,
  unsigned long faceSize, Coords* normalArray)
{
  MCNUM A1=0, C1=0, D1=0, A2=0, B2=0, C2=0, D2=0;      //perpendicular plane equations to [a,b]
  off_init_planes(a, b, &A1, &C1, &D1, &A2, &B2, &C2, &D2);

  int t_size=0;
  //unsigned long vtxSize=vtxTable.rows, faceSize=faceTable.columns;  //Size of the corresponding tables
  char sg[vtxSize];  //array telling if vertex is left or right of the plane
  MCNUM popol[3*CHAR_BUF_LENGTH];
  unsigned long i=0,indPoly=0;
  for (i=0; i < vtxSize; ++i)
  {
    sg[i]=off_sign(off_F(vtxArray[i].x,vtxArray[i].y,vtxArray[i].z,A1,0,C1,D1));
  }

  //exploring the polygons :
  i=indPoly=0;
  while (i<faceSize)
  {
    polygon pol;
    pol.npol  = faceArray[i];                //nb vertex of polygon
    pol.p     = popol;
    pol.normal= coords_set(0,0,1);
    unsigned long indVertP1=faceArray[++i];  //polygon's first vertex index in vtxTable
    int j=1;
    while (j<pol.npol)
    {
      //polygon's j-th vertex index in vtxTable
      if (sg[indVertP1]!=sg[faceArray[i+j]]) //if the plane intersect the polygon
        break;

      ++j;
    }

    if (j<pol.npol)          //ok, let's test with the second plane
    {
      char sg1=off_sign(off_F(vtxArray[indVertP1].x,vtxArray[indVertP1].y,vtxArray[indVertP1].z,A2,B2,C2,D2));//tells if vertex is left or right of the plane

      j=1;
      while (j<pol.npol)
      {
        //unsigned long indVertPi=faceArray[i+j];  //polyg's j-th vertex index in vtxTable
        Coords vertPi=vtxArray[faceArray[i+j]];
        if (sg1!=off_sign(off_F(vertPi.x,vertPi.y,vertPi.z,A2,B2,C2,D2)))//if the plane intersect the polygon
          break;
        ++j;
      }
      if (j<pol.npol)
      {
        if (t_size>CHAR_BUF_LENGTH)
        {
          fprintf(stderr, "Warning: number of intersection exceeded (%d) (interoff-lib/off_clip_3D_mod)\n", CHAR_BUF_LENGTH);
            return (t_size);
        }
        //both planes intersect the polygon, let's find the intersection point
        //our polygon :
        int k;
        for (k=0; k<pol.npol; ++k)
        {
          Coords vertPk=vtxArray[faceArray[i+k]];
          pol.p[3*k]  =vertPk.x;
          pol.p[3*k+1]=vertPk.y;
          pol.p[3*k+2]=vertPk.z;
        }
        pol.normal=normalArray[indPoly];
        intersection x;
        if (off_intersectPoly(&x, a, b, pol))
        {
          x.index = indPoly;
          t[t_size++]=x;
        }
      } /* if (j<pol.npol) */
    } /* if (j<pol.npol) */
    i += pol.npol;
    indPoly++;
  } /* while i<faceSize */
  return t_size;
} /* off_clip_3D_mod */


// off_compare *****************************************************************
int off_compare (void const *a, void const *b)
{
   intersection const *pa = a;
   intersection const *pb = b;

   return off_sign(pa->time - pb->time);
} /* off_compare */

// off_cleanDouble *************************************************************
//given an array of intersections throw those which appear several times
//returns 1 if there is a possibility of error
int off_cleanDouble(intersection* t, int* t_size)
{
  int i=1;
  intersection prev=t[0];
  while (i<*t_size)
  {
    int j=i;
    //for each intersection with the same time
    while (j<*t_size && fabs(prev.time-t[j].time)<EPSILON)
    {
      //if the intersection is the exact same erase it
      if (prev.in_out==t[j].in_out)
      {
        int k;
        for (k=j+1; k<*t_size; ++k)
        {
          t[k-1]=t[k];
        }
        *t_size-=1;
      }
      else
        ++j;
    }
    prev=t[i];
    ++i;

  }
  return 1;
} /* off_cleanDouble */

// off_cleanInOut **************************************************************
//given an array of intesections throw those which enter and exit in the same time
//Meaning the ray passes very close to the volume
//returns 1 if there is a possibility of error
int off_cleanInOut(intersection* t, int* t_size)
{
  int i=1;
  intersection prev=t[0];
  while (i<*t_size)
  {
    //if two intersection have the same time but one enters and the other exits erase both
    //(such intersections must be adjacent in the array : run off_cleanDouble before)
    if (fabs(prev.time-t[i].time)<EPSILON && prev.in_out!=t[i].in_out)
    {
      int j=0;
      for (j=i+1; j<*t_size; ++j)
      {
        t[j-2]=t[j];
      }
      *t_size-=2;
      prev=t[i-1];
    }
    else
    {
      prev=t[i];
      ++i;
    }
  }
  return (*t_size);
} /* off_cleanInOut */

/* PUBLIC functions ******************************************************** */

/*******************************************************************************
* long off_init(  char *offfile, double xwidth, double yheight, double zdepth, off_struct* data)
* ACTION: read an OFF file, optionally center object and rescale, initialize OFF data structure
* INPUT: 'offfile' OFF file to read
*        'xwidth,yheight,zdepth' if given as non-zero, apply bounding box.
*           Specifying only one of these will also use the same ratio on all axes
*        'notcenter' center the object to the (0,0,0) position in local frame when set to zero
* RETURN: number of polyhedra and 'data' OFF structure
*******************************************************************************/
long off_init(  char *offfile, double xwidth, double yheight, double zdepth,
                int notcenter, off_struct* data)
{
  // data to be initialized
  long    vtxSize =0, polySize=0, i=0, ret=0, faceSize=0;
  Coords* vtxArray        =NULL;
  Coords* normalArray     =NULL;
  unsigned long* faceArray=NULL;
  FILE*   f               =NULL; /* the FILE with vertices and polygons */
  double minx=FLT_MAX,maxx=-FLT_MAX,miny=FLT_MAX,maxy=-FLT_MAX,minz=FLT_MAX,maxz=-FLT_MAX;

  // get the indexes
  if (!data) return(0);
  
  MPI_MASTER(
  printf("Loading geometry file (OFF/PLY): %s\n", offfile);
  );
  
  f=off_getBlocksIndex(offfile,&vtxSize,&polySize);
  if (!f) return(0);
  
  // read vertex table = [x y z | x y z | ...] =================================
  // now we read the vertices as 'vtxSize*3' numbers and store it in vtxArray 
  MPI_MASTER(
  printf("  Number of vertices: %ld\n", vtxSize);
  );
  vtxArray   = malloc(vtxSize*sizeof(Coords));
  if (!vtxArray) return(0);
  i=0;
  while (i<vtxSize && ~feof(f))
  {
    double x,y,z;
    ret=fscanf(f, "%lg%lg%lg", &x,&y,&z);
    if (!ret) { 
      // invalid line: we skip it (probably a comment)
      char line[CHAR_BUF_LENGTH];
      fgets(line, CHAR_BUF_LENGTH, f);
      continue; 
    }
    if (ret != 3) {
      fprintf(stderr, "Error: can not read [xyz] coordinates for vertex %ld in file %s (interoff/off_init). Read %ld values.\n", 
        i, offfile, ret);
      exit(2);
    }
    vtxArray[i].x=x;
    vtxArray[i].y=y;
    vtxArray[i].z=z;

    //bounding box
    if (vtxArray[i].x<minx) minx=vtxArray[i].x;
    if (vtxArray[i].x>maxx) maxx=vtxArray[i].x;
    if (vtxArray[i].y<miny) miny=vtxArray[i].y;
    if (vtxArray[i].y>maxy) maxy=vtxArray[i].y;
    if (vtxArray[i].z<minz) minz=vtxArray[i].z;
    if (vtxArray[i].z>maxz) maxz=vtxArray[i].z;
    i++; // inquire next vertex
  }

  // resizing and repositioning params
  double centerx=0, centery=0, centerz=0;
  if (!notcenter) {
    centerx=(minx+maxx)*0.5;
    centery=(miny+maxy)*0.5;
    centerz=(minz+maxz)*0.5;
  }

  double rangex=-minx+maxx,
         rangey=-miny+maxy,
         rangez=-minz+maxz;

  double ratiox=1,ratioy=1,ratioz=1;

  if (xwidth && rangex)
  {
    ratiox=xwidth/rangex;
    ratioy=ratiox;
    ratioz=ratiox;
  }

  if (yheight && rangey)
  {
    ratioy=yheight/rangey;
    if(!xwidth)  ratiox=ratioy;
    ratioz=ratioy;
  }

  if (zdepth && rangez)
  {
    ratioz=zdepth/rangez;
    if(!xwidth)  ratiox=ratioz;
    if(!yheight) ratioy=ratioz;
  }

  rangex *= ratiox;
  rangey *= ratioy;
  rangez *= ratioz;

  //center and resize the object
  for (i=0; i<vtxSize; ++i)
  {
    vtxArray[i].x=(vtxArray[i].x-centerx)*ratiox+(!notcenter ? 0 : centerx);
    vtxArray[i].y=(vtxArray[i].y-centery)*ratioy+(!notcenter ? 0 : centery);
    vtxArray[i].z=(vtxArray[i].z-centerz)*ratioz+(!notcenter ? 0 : centerz);
  }
  
  // read face table = [nbvertex v1 v2 vn | nbvertex v1 v2 vn ...] =============
  MPI_MASTER(
  printf("  Number of polygons: %ld\n", polySize);
  );
  normalArray= malloc(polySize*sizeof(Coords));
  faceArray  = malloc(polySize*10*sizeof(unsigned long)); // we assume polygons have less than 9 vertices
  if (!normalArray || !faceArray) return(0);
  
  // fill faces
  faceSize=0;
  i=0;
  while (i<polySize && ~feof(f)) {
    int  nbVertex=0, j=0;
    // read the length of this polygon
    ret=fscanf(f, "%d", &nbVertex);
    if (!ret) { 
      // invalid line: we skip it (probably a comment)
      char line[CHAR_BUF_LENGTH];
      fgets(line, CHAR_BUF_LENGTH, f);
      continue; 
    }
    if (ret != 1) {
      fprintf(stderr, "Error: can not read polygon %ld length in file %s (interoff/off_init)\n", 
        i, offfile);
      exit(3);
    }
    if (faceSize > polySize*10) {
      fprintf(stderr, "Error: %li exceeded allocated polygon array[%li] in file %s (interoff/off_init)\n", 
        faceSize, polySize*10, offfile);
    }
    faceArray[faceSize++] = nbVertex; // length of the polygon/face
    // then read the vertex ID's
    for (j=0; j<nbVertex; j++) {
      double vtx=0;
      fscanf(f, "%lg", &vtx);
      faceArray[faceSize++] = vtx;   // add vertices index after length of polygon
    }
    i++;
  }

  // precomputes normals
  long indNormal=0;//index in polyArray
  i=0;    //index in faceArray
  while (i<faceSize)
  {
    int    nbVertex=faceArray[i];//nb of vertices of this polygon
    double vertices[3*nbVertex];
    int j;

    for (j=0; j<nbVertex; ++j)
    {
      unsigned long indVertPj=faceArray[i+j+1];
      vertices[3*j]  =vtxArray[indVertPj].x;
      vertices[3*j+1]=vtxArray[indVertPj].y;
      vertices[3*j+2]=vtxArray[indVertPj].z;
    }

    polygon p;
    p.p   =vertices;
    p.npol=nbVertex;
    off_normal(&(p.normal),p);

    normalArray[indNormal]=p.normal;

    i += nbVertex+1;
    indNormal++;

  }
  
  MPI_MASTER(
  if (ratiox!=ratioy || ratiox!=ratioz || ratioy!=ratioz)
    printf("Warning: Aspect ratio of the geometry %s was modified.\n"
           "         If you want to keep the original proportions, specifiy only one of the dimensions.\n",
           offfile);
  if ( xwidth==0 && yheight==0 && zdepth==0 ) {
    printf("Warning: Neither xwidth, yheight or zdepth are defined.\n"
	   "           The file-defined (non-scaled) geometry the OFF geometry %s will be applied!\n", 
           offfile);
  }
  printf("  Bounding box dimensions for geometry %s:\n", offfile);
  printf("    Length=%f (%.3f%%)\n", rangex, ratiox*100);
  printf("    Width= %f (%.3f%%)\n", rangey, ratioy*100);
  printf("    Depth= %f (%.3f%%)\n", rangez, ratioz*100);
  );

  data->vtxArray   = vtxArray;
  data->normalArray= normalArray;
  data->faceArray  = faceArray;
  data->vtxSize    = vtxSize;
  data->polySize   = polySize;
  data->faceSize   = faceSize;
  data->filename   = offfile;
  return(polySize);
} /* off_init */

/*******************************************************************************
* int off_intersect_all(double* t0, double* t3,
     Coords *n0, Coords *n3,
     double x, double y, double z,
     double vx, double vy, double vz,
     off_struct *data )
* ACTION: computes intersection of neutron trajectory with an object.
* INPUT:  x,y,z and vx,vy,vz are the position and velocity of the neutron
*         data points to the OFF data structure
* RETURN: the number of polyhedra which trajectory intersects
*         t0 and t3 are the smallest incoming and outgoing intersection times
*         n0 and n3 are the corresponding normal vectors to the surface
*         data is the full OFF structure, including a list intersection type
*******************************************************************************/
int off_intersect_all(double* t0, double* t3,
     Coords *n0, Coords *n3,
     double x,  double y,  double z,
     double vx, double vy, double vz,
     off_struct *data )
{
    Coords A={x, y, z};
    Coords B={x+vx, y+vy, z+vz};
    int t_size=off_clip_3D_mod(data->intersects, A, B,
      data->vtxArray, data->vtxSize, data->faceArray, data->faceSize, data->normalArray );
    qsort(data->intersects, t_size, sizeof(intersection),  off_compare);
    off_cleanDouble(data->intersects, &t_size);
    off_cleanInOut(data->intersects,  &t_size);

    /*find intersections "closest" to 0 (favouring positive ones)*/
    if(t_size>0){
      int i=0;
      if(t_size>1) {
        for (i=1; i < t_size-1; i++){
          if (data->intersects[i-1].time > 0 && data->intersects[i].time > 0)
            break;
        }
	
	data->nextintersect=i-1;
	data->numintersect=t_size;

        if (t0) *t0 = data->intersects[i-1].time;
        if (n0) *n0 = data->intersects[i-1].normal;
        if (t3) *t3 = data->intersects[i].time;
        if (n3) *n3 = data->intersects[i].normal;
      } else {
        if (t0) *t0 = data->intersects[0].time; 	 
	      if (n0) *n0 = data->intersects[0].normal;
      }
      /* should also return t[0].index and t[i].index as polygon ID */
      return t_size;
    }
    return 0;
} /* off_intersect */

/*******************************************************************************
* int off_intersect(double* t0, double* t3,
     Coords *n0, Coords *n3,
     double x, double y, double z,
     double vx, double vy, double vz,
     off_struct data )
* ACTION: computes intersection of neutron trajectory with an object.
* INPUT:  x,y,z and vx,vy,vz are the position and velocity of the neutron
*         data points to the OFF data structure
* RETURN: the number of polyhedra which trajectory intersects
*         t0 and t3 are the smallest incoming and outgoing intersection times
*         n0 and n3 are the corresponding normal vectors to the surface
*******************************************************************************/
int off_intersect(double* t0, double* t3,
     Coords *n0, Coords *n3,
     double x,  double y,  double z,
     double vx, double vy, double vz,
     off_struct data )
{
  return off_intersect_all(t0, t3, n0, n3, x, y, z, vx, vy, vz, &data );
} /* off_intersect */

/*****************************************************************************
* int off_x_intersect(double* l0, double* l3,
     Coords *n0, Coords *n3,
     double x, double y, double z,
     double kx, double ky, double kz,
     off_struct data )
* ACTION: computes intersection of an xray trajectory with an object.
* INPUT:  x,y,z and kx,ky,kz, are spatial coordinates and wavevector of the x-ray
*         respectively. data points to the OFF data structure.
* RETURN: the number of polyhedra the trajectory intersects
*         l0 and l3 are the smallest incoming and outgoing intersection lengths
*         n0 and n3 are the corresponding normal vectors to the surface
*******************************************************************************/
int off_x_intersect(double *l0,double *l3,
     Coords *n0, Coords *n3,
     double x,  double y,  double z,
     double kx, double ky, double kz,
     off_struct data )
{
  /*This function simply reformats and calls off_intersect (as for neutrons)
   *by normalizing the wavevector - this will yield the intersection lengths
   *in m*/
  double jx,jy,jz,invk;
  int n;
  invk=1/sqrt(scalar_prod(kx,ky,kz,kx,ky,kz));
  jx=kx*invk;jy=ky*invk;jz=kz*invk;
  n=off_intersect(l0,l3,n0,n3,x,y,z,jx,jy,jz,data);
  return n;
}


/*******************************************************************************
* void off_display(off_struct data)
* ACTION: display up to N_VERTEX_DISPLAYED polygons from the object
*******************************************************************************/
void off_display(off_struct data)
{
  unsigned int i;
  double ratio=(double)(N_VERTEX_DISPLAYED)/(double)data.faceSize;
  unsigned int pixel=0;
  for (i=0; i<data.faceSize-1; i++) {
    int j;
    int nbVertex = data.faceArray[i];
    double x0,y0,z0;
    x0 = data.vtxArray[data.faceArray[i+1]].x;
    y0 = data.vtxArray[data.faceArray[i+1]].y;
    z0 = data.vtxArray[data.faceArray[i+1]].z;
    double x1=x0,y1=y0,z1=z0;
    double cmx=0,cmy=0,cmz=0;
    
    int drawthis = rand01() < ratio;
    // First pass, calculate center of mass location...
    for (j=1; j<=nbVertex; j++) {
      cmx = cmx+data.vtxArray[data.faceArray[i+j]].x;
      cmy = cmy+data.vtxArray[data.faceArray[i+j]].y;
      cmz = cmz+data.vtxArray[data.faceArray[i+j]].z;
    }
    cmx /= nbVertex;
    cmy /= nbVertex;
    cmz /= nbVertex;
    
    char pixelinfo[1024];    
    sprintf(pixelinfo, "%lu,%lu,%lu,%i,%g,%g,%g,%g,%g,%g", data.mantidoffset+pixel, data.mantidoffset, data.mantidoffset+data.polySize-1, nbVertex, cmx, cmy, cmz, x1-cmx, y1-cmy, z1-cmz);
    for (j=2; j<=nbVertex; j++) {
      double x2,y2,z2;
      x2 = data.vtxArray[data.faceArray[i+j]].x;
      y2 = data.vtxArray[data.faceArray[i+j]].y;
      z2 = data.vtxArray[data.faceArray[i+j]].z;
      sprintf(pixelinfo, "%s,%g,%g,%g", pixelinfo, x2-cmx, y2-cmy, z2-cmz); 
      if (ratio > 1 || drawthis) {
	mcdis_line(x1,y1,z1,x2,y2,z2);
      }
      x1 = x2; y1 = y2; z1 = z2;
    }
    if (ratio > 1 || drawthis) {
	mcdis_line(x1,y1,z1,x0,y0,z0);
      }
    if (data.mantidflag) {
      printf("MANTID_PIXEL: %s\n", pixelinfo);
      pixel++;
    }
    i += nbVertex;
  }
} /* off_display */

/* end of interoff-lib.c */

#line 10152 "ILL_H15_D11.c"

/* Instrument parameters. */
MCNUM mcipLambda;
char* mcipConfig;
MCNUM mcipLc;
MCNUM mcipiLc;
MCNUM mcipChamfers;
MCNUM mcipWaviness;

#define mcNUMIPAR 6
int mcnumipar = 6;
struct mcinputtable_struct mcinputtable[mcNUMIPAR+1] = {
  "Lambda", &mcipLambda, instr_type_double, "4.51", 
  "Config", &mcipConfig, instr_type_string, "Borkron_1972", 
  "Lc", &mcipLc, instr_type_double, "0", 
  "iLc", &mcipiLc, instr_type_double, "5", 
  "Chamfers", &mcipChamfers, instr_type_double, "0.0002", 
  "Waviness", &mcipWaviness, instr_type_double, "2.5e-5", 
  NULL, NULL, instr_type_double, ""
};

/* User declarations from instrument definition. */
#define mccompcurname  ILL_H15_D11
#define mccompcurtype  INSTRUMENT
#define mccompcurindex 0
#define mcposaILL_H15_D11 coords_set(0,0,0)
#define Lambda mcipLambda
#define Config mcipConfig
#define Lc mcipLc
#define iLc mcipiLc
#define Chamfers mcipChamfers
#define Waviness mcipWaviness
#line 77 "ILL_H15_D11.instr"

  #define VERSION "H15_D11@ILL Farhi 10/08/2003"

  /* all variables defined here can be used, and modified, in the whole instrument */
  /* variables used in instrument definition and for user computations */

  /* Source specifications */
  double sLambda            = 4;
  double sDeltaLambdaPercent= 0.08;  /* Lambda spread in % (full width) */
  double sDeltaLambda;
  double sT1=216.8,sI1=1.24e+13;  /* VCS */
  double sT2=33.9, sI2=1.02e+13; 
  double sT3=16.7, sI3=3.0423e+12;
  double sH                 = 0.22;
  double sW                 = 0.10;

  /* Guide geometry specifications, default values */
  double gInputWidth        = 0.038;
  double gObtWidth          = 0.032;
  double gGuideHeight1      = 0.2;
  double gGuideHeight2      = 0.05;
  double gSourceInput       = 2.33;

  double gGuideWidth        = 0.03;
  double gLength1           = 25.5;   /* 25 pieces */
  double gCurvatureRadius   = 2700.0;
  double gLength2           = 22.284; /* 22 pieces */
  double gLength3           = 5.4;    /* 5 pieces */  

  double gToSampleLength    = 1.5;
  double gElementGap        = 0.004;

  double gElmtLength1;
  double gElmtLength2;
  double gElmtLength3;
  double gElmtRot1;

  /* Guide coatings specifications */
  double mInPile            = 1;
  double mGuide1            = 1;
  double mGuide2            = 0.65; /* 0.953075 */

  double mAlpha             = 4.07; /* 0 */
  double mQc                = 0.0218; /* 0.0175455 */
  double mR0                = 0.995;  /* 0.953075 */
  double mW                 = 1.0/300.0;  /* 0.00299565 */
  
  double Vrpm;
  double Config_l[20];
  double Config_n[20];
  double Config_g[20];
  
  /* geometry configurations */
  double Borkron_1972_l[] = {20, 0,0,0,  0,4,3,3,2.5,0,  2.5,0,  1.5,0,1.5,0,0};  /* length 17 */
  double Borkron_2003_l[] = {6.5,0,6,7.5,0,4,3,3,2.5,0,  2.5,0,  1.5,0,1.5,0,1};
  double Borofloat_2001_l[]={0.5,6,6,0.5,7,4,3,3,2,  0.5,2,  0.5,0.5,1,0.5,1,1};
  
  double Borkron_1972_n[] = {40,0,0, 0, 0,8,6,6,5,0,5,0,3,0,3,0,0};
  double Borkron_2003_n[] = {13,0,12,15,0,8,6,6,5,0,5,0,3,0,3,0,2};
  double Borofloat_2001_n[]={1, 6,6, 1, 7,4,3,3,2,1,2,1,1,1,1,1,1};
  
  double Borkron_1972_g[] = {0   ,0   };
  double Borkron_2003_g[] = {0.002,0.002};
  double Borofloat_2001_g[]={0.002,0.002};
  
  double Length_Lc[]       ={1.5,2.5,4,5.5,8,10.5,13.5,16.5,20.5,28,34,40.5};
  
  double microGap = 0.0001;
  
#line 10255 "ILL_H15_D11.c"
#undef Waviness
#undef Chamfers
#undef iLc
#undef Lc
#undef Config
#undef Lambda
#undef mcposaILL_H15_D11
#undef mccompcurindex
#undef mccompcurtype
#undef mccompcurname

/* neutron state table at each component input (local coords) */
/* [x, y, z, vx, vy, vz, t, sx, sy, sz, p] */
MCNUM mccomp_storein[11*104];
/* Components position table (absolute and relative coords) */
Coords mccomp_posa[104];
Coords mccomp_posr[104];
/* Counter for each comp to check for inactive ones */
MCNUM  mcNCounter[104];
MCNUM  mcPCounter[104];
MCNUM  mcP2Counter[104];
#define mcNUMCOMP 103 /* number of components */
/* Counter for PROP ABSORB */
MCNUM  mcAbsorbProp[104];
/* Flag true when previous component acted on the neutron (SCATTER) */
MCNUM mcScattered=0;
/* Flag true when neutron should be restored (RESTORE) */
MCNUM mcRestore=0;
/* Declarations of component definition and setting parameters. */

/* Setting parameters for component 'PG' [1]. */
char mccPG_profile[16384];
MCNUM mccPG_percent;
MCNUM mccPG_flag_save;
MCNUM mccPG_minutes;

/* Setting parameters for component 'Source' [2]. */
char mccSource_flux_file[16384];
char mccSource_xdiv_file[16384];
char mccSource_ydiv_file[16384];
MCNUM mccSource_radius;
MCNUM mccSource_dist;
MCNUM mccSource_focus_xw;
MCNUM mccSource_focus_yh;
MCNUM mccSource_focus_aw;
MCNUM mccSource_focus_ah;
MCNUM mccSource_E0;
MCNUM mccSource_dE;
MCNUM mccSource_lambda0;
MCNUM mccSource_dlambda;
MCNUM mccSource_I1;
MCNUM mccSource_yheight;
MCNUM mccSource_xwidth;
MCNUM mccSource_verbose;
MCNUM mccSource_T1;
MCNUM mccSource_flux_file_perAA;
MCNUM mccSource_flux_file_log;
MCNUM mccSource_Lmin;
MCNUM mccSource_Lmax;
MCNUM mccSource_Emin;
MCNUM mccSource_Emax;
MCNUM mccSource_T2;
MCNUM mccSource_I2;
MCNUM mccSource_T3;
MCNUM mccSource_I3;
MCNUM mccSource_zdepth;
int mccSource_target_index;

/* Setting parameters for component 'AlWindow1' [3]. */
MCNUM mccAlWindow1_thickness;

/* Setting parameters for component 'PinkCarter' [4]. */
MCNUM mccPinkCarter_w1;
MCNUM mccPinkCarter_h1;
MCNUM mccPinkCarter_w2;
MCNUM mccPinkCarter_h2;
MCNUM mccPinkCarter_l;
MCNUM mccPinkCarter_R0;
MCNUM mccPinkCarter_Qc;
MCNUM mccPinkCarter_alpha;
MCNUM mccPinkCarter_m;
MCNUM mccPinkCarter_W;
MCNUM mccPinkCarter_nslit;
MCNUM mccPinkCarter_d;
MCNUM mccPinkCarter_mleft;
MCNUM mccPinkCarter_mright;
MCNUM mccPinkCarter_mtop;
MCNUM mccPinkCarter_mbottom;
MCNUM mccPinkCarter_nhslit;
MCNUM mccPinkCarter_G;
MCNUM mccPinkCarter_aleft;
MCNUM mccPinkCarter_aright;
MCNUM mccPinkCarter_atop;
MCNUM mccPinkCarter_abottom;
MCNUM mccPinkCarter_wavy;
MCNUM mccPinkCarter_wavy_z;
MCNUM mccPinkCarter_wavy_tb;
MCNUM mccPinkCarter_wavy_lr;
MCNUM mccPinkCarter_chamfers;
MCNUM mccPinkCarter_chamfers_z;
MCNUM mccPinkCarter_chamfers_lr;
MCNUM mccPinkCarter_chamfers_tb;
MCNUM mccPinkCarter_nelements;
MCNUM mccPinkCarter_nu;
MCNUM mccPinkCarter_phase;
char mccPinkCarter_reflect[16384];

/* Setting parameters for component 'AlWindow2' [5]. */
MCNUM mccAlWindow2_thickness;

/* Setting parameters for component 'LeadShutter' [6]. */
MCNUM mccLeadShutter_w1;
MCNUM mccLeadShutter_h1;
MCNUM mccLeadShutter_w2;
MCNUM mccLeadShutter_h2;
MCNUM mccLeadShutter_l;
MCNUM mccLeadShutter_R0;
MCNUM mccLeadShutter_Qc;
MCNUM mccLeadShutter_alpha;
MCNUM mccLeadShutter_m;
MCNUM mccLeadShutter_W;
MCNUM mccLeadShutter_nslit;
MCNUM mccLeadShutter_d;
MCNUM mccLeadShutter_mleft;
MCNUM mccLeadShutter_mright;
MCNUM mccLeadShutter_mtop;
MCNUM mccLeadShutter_mbottom;
MCNUM mccLeadShutter_nhslit;
MCNUM mccLeadShutter_G;
MCNUM mccLeadShutter_aleft;
MCNUM mccLeadShutter_aright;
MCNUM mccLeadShutter_atop;
MCNUM mccLeadShutter_abottom;
MCNUM mccLeadShutter_wavy;
MCNUM mccLeadShutter_wavy_z;
MCNUM mccLeadShutter_wavy_tb;
MCNUM mccLeadShutter_wavy_lr;
MCNUM mccLeadShutter_chamfers;
MCNUM mccLeadShutter_chamfers_z;
MCNUM mccLeadShutter_chamfers_lr;
MCNUM mccLeadShutter_chamfers_tb;
MCNUM mccLeadShutter_nelements;
MCNUM mccLeadShutter_nu;
MCNUM mccLeadShutter_phase;
char mccLeadShutter_reflect[16384];

/* Setting parameters for component 'AlWindow3' [7]. */
MCNUM mccAlWindow3_thickness;

/* Setting parameters for component 'cg1' [9]. */
MCNUM mcccg1_w1;
MCNUM mcccg1_h1;
MCNUM mcccg1_w2;
MCNUM mcccg1_h2;
MCNUM mcccg1_l;
MCNUM mcccg1_R0;
MCNUM mcccg1_Qc;
MCNUM mcccg1_alpha;
MCNUM mcccg1_m;
MCNUM mcccg1_W;
MCNUM mcccg1_nslit;
MCNUM mcccg1_d;
MCNUM mcccg1_mleft;
MCNUM mcccg1_mright;
MCNUM mcccg1_mtop;
MCNUM mcccg1_mbottom;
MCNUM mcccg1_nhslit;
MCNUM mcccg1_G;
MCNUM mcccg1_aleft;
MCNUM mcccg1_aright;
MCNUM mcccg1_atop;
MCNUM mcccg1_abottom;
MCNUM mcccg1_wavy;
MCNUM mcccg1_wavy_z;
MCNUM mcccg1_wavy_tb;
MCNUM mcccg1_wavy_lr;
MCNUM mcccg1_chamfers;
MCNUM mcccg1_chamfers_z;
MCNUM mcccg1_chamfers_lr;
MCNUM mcccg1_chamfers_tb;
MCNUM mcccg1_nelements;
MCNUM mcccg1_nu;
MCNUM mcccg1_phase;
char mcccg1_reflect[16384];

/* Setting parameters for component 'cg2' [10]. */
MCNUM mcccg2_w1;
MCNUM mcccg2_h1;
MCNUM mcccg2_w2;
MCNUM mcccg2_h2;
MCNUM mcccg2_l;
MCNUM mcccg2_R0;
MCNUM mcccg2_Qc;
MCNUM mcccg2_alpha;
MCNUM mcccg2_m;
MCNUM mcccg2_W;
MCNUM mcccg2_nslit;
MCNUM mcccg2_d;
MCNUM mcccg2_mleft;
MCNUM mcccg2_mright;
MCNUM mcccg2_mtop;
MCNUM mcccg2_mbottom;
MCNUM mcccg2_nhslit;
MCNUM mcccg2_G;
MCNUM mcccg2_aleft;
MCNUM mcccg2_aright;
MCNUM mcccg2_atop;
MCNUM mcccg2_abottom;
MCNUM mcccg2_wavy;
MCNUM mcccg2_wavy_z;
MCNUM mcccg2_wavy_tb;
MCNUM mcccg2_wavy_lr;
MCNUM mcccg2_chamfers;
MCNUM mcccg2_chamfers_z;
MCNUM mcccg2_chamfers_lr;
MCNUM mcccg2_chamfers_tb;
MCNUM mcccg2_nelements;
MCNUM mcccg2_nu;
MCNUM mcccg2_phase;
char mcccg2_reflect[16384];

/* Setting parameters for component 'cg3' [11]. */
MCNUM mcccg3_w1;
MCNUM mcccg3_h1;
MCNUM mcccg3_w2;
MCNUM mcccg3_h2;
MCNUM mcccg3_l;
MCNUM mcccg3_R0;
MCNUM mcccg3_Qc;
MCNUM mcccg3_alpha;
MCNUM mcccg3_m;
MCNUM mcccg3_W;
MCNUM mcccg3_nslit;
MCNUM mcccg3_d;
MCNUM mcccg3_mleft;
MCNUM mcccg3_mright;
MCNUM mcccg3_mtop;
MCNUM mcccg3_mbottom;
MCNUM mcccg3_nhslit;
MCNUM mcccg3_G;
MCNUM mcccg3_aleft;
MCNUM mcccg3_aright;
MCNUM mcccg3_atop;
MCNUM mcccg3_abottom;
MCNUM mcccg3_wavy;
MCNUM mcccg3_wavy_z;
MCNUM mcccg3_wavy_tb;
MCNUM mcccg3_wavy_lr;
MCNUM mcccg3_chamfers;
MCNUM mcccg3_chamfers_z;
MCNUM mcccg3_chamfers_lr;
MCNUM mcccg3_chamfers_tb;
MCNUM mcccg3_nelements;
MCNUM mcccg3_nu;
MCNUM mcccg3_phase;
char mcccg3_reflect[16384];

/* Setting parameters for component 'cg4' [12]. */
MCNUM mcccg4_w1;
MCNUM mcccg4_h1;
MCNUM mcccg4_w2;
MCNUM mcccg4_h2;
MCNUM mcccg4_l;
MCNUM mcccg4_R0;
MCNUM mcccg4_Qc;
MCNUM mcccg4_alpha;
MCNUM mcccg4_m;
MCNUM mcccg4_W;
MCNUM mcccg4_nslit;
MCNUM mcccg4_d;
MCNUM mcccg4_mleft;
MCNUM mcccg4_mright;
MCNUM mcccg4_mtop;
MCNUM mcccg4_mbottom;
MCNUM mcccg4_nhslit;
MCNUM mcccg4_G;
MCNUM mcccg4_aleft;
MCNUM mcccg4_aright;
MCNUM mcccg4_atop;
MCNUM mcccg4_abottom;
MCNUM mcccg4_wavy;
MCNUM mcccg4_wavy_z;
MCNUM mcccg4_wavy_tb;
MCNUM mcccg4_wavy_lr;
MCNUM mcccg4_chamfers;
MCNUM mcccg4_chamfers_z;
MCNUM mcccg4_chamfers_lr;
MCNUM mcccg4_chamfers_tb;
MCNUM mcccg4_nelements;
MCNUM mcccg4_nu;
MCNUM mcccg4_phase;
char mcccg4_reflect[16384];

/* Setting parameters for component 'cg5' [13]. */
MCNUM mcccg5_w1;
MCNUM mcccg5_h1;
MCNUM mcccg5_w2;
MCNUM mcccg5_h2;
MCNUM mcccg5_l;
MCNUM mcccg5_R0;
MCNUM mcccg5_Qc;
MCNUM mcccg5_alpha;
MCNUM mcccg5_m;
MCNUM mcccg5_W;
MCNUM mcccg5_nslit;
MCNUM mcccg5_d;
MCNUM mcccg5_mleft;
MCNUM mcccg5_mright;
MCNUM mcccg5_mtop;
MCNUM mcccg5_mbottom;
MCNUM mcccg5_nhslit;
MCNUM mcccg5_G;
MCNUM mcccg5_aleft;
MCNUM mcccg5_aright;
MCNUM mcccg5_atop;
MCNUM mcccg5_abottom;
MCNUM mcccg5_wavy;
MCNUM mcccg5_wavy_z;
MCNUM mcccg5_wavy_tb;
MCNUM mcccg5_wavy_lr;
MCNUM mcccg5_chamfers;
MCNUM mcccg5_chamfers_z;
MCNUM mcccg5_chamfers_lr;
MCNUM mcccg5_chamfers_tb;
MCNUM mcccg5_nelements;
MCNUM mcccg5_nu;
MCNUM mcccg5_phase;
char mcccg5_reflect[16384];

/* Setting parameters for component 'cg6' [14]. */
MCNUM mcccg6_w1;
MCNUM mcccg6_h1;
MCNUM mcccg6_w2;
MCNUM mcccg6_h2;
MCNUM mcccg6_l;
MCNUM mcccg6_R0;
MCNUM mcccg6_Qc;
MCNUM mcccg6_alpha;
MCNUM mcccg6_m;
MCNUM mcccg6_W;
MCNUM mcccg6_nslit;
MCNUM mcccg6_d;
MCNUM mcccg6_mleft;
MCNUM mcccg6_mright;
MCNUM mcccg6_mtop;
MCNUM mcccg6_mbottom;
MCNUM mcccg6_nhslit;
MCNUM mcccg6_G;
MCNUM mcccg6_aleft;
MCNUM mcccg6_aright;
MCNUM mcccg6_atop;
MCNUM mcccg6_abottom;
MCNUM mcccg6_wavy;
MCNUM mcccg6_wavy_z;
MCNUM mcccg6_wavy_tb;
MCNUM mcccg6_wavy_lr;
MCNUM mcccg6_chamfers;
MCNUM mcccg6_chamfers_z;
MCNUM mcccg6_chamfers_lr;
MCNUM mcccg6_chamfers_tb;
MCNUM mcccg6_nelements;
MCNUM mcccg6_nu;
MCNUM mcccg6_phase;
char mcccg6_reflect[16384];

/* Setting parameters for component 'cg7' [15]. */
MCNUM mcccg7_w1;
MCNUM mcccg7_h1;
MCNUM mcccg7_w2;
MCNUM mcccg7_h2;
MCNUM mcccg7_l;
MCNUM mcccg7_R0;
MCNUM mcccg7_Qc;
MCNUM mcccg7_alpha;
MCNUM mcccg7_m;
MCNUM mcccg7_W;
MCNUM mcccg7_nslit;
MCNUM mcccg7_d;
MCNUM mcccg7_mleft;
MCNUM mcccg7_mright;
MCNUM mcccg7_mtop;
MCNUM mcccg7_mbottom;
MCNUM mcccg7_nhslit;
MCNUM mcccg7_G;
MCNUM mcccg7_aleft;
MCNUM mcccg7_aright;
MCNUM mcccg7_atop;
MCNUM mcccg7_abottom;
MCNUM mcccg7_wavy;
MCNUM mcccg7_wavy_z;
MCNUM mcccg7_wavy_tb;
MCNUM mcccg7_wavy_lr;
MCNUM mcccg7_chamfers;
MCNUM mcccg7_chamfers_z;
MCNUM mcccg7_chamfers_lr;
MCNUM mcccg7_chamfers_tb;
MCNUM mcccg7_nelements;
MCNUM mcccg7_nu;
MCNUM mcccg7_phase;
char mcccg7_reflect[16384];

/* Setting parameters for component 'cg8' [16]. */
MCNUM mcccg8_w1;
MCNUM mcccg8_h1;
MCNUM mcccg8_w2;
MCNUM mcccg8_h2;
MCNUM mcccg8_l;
MCNUM mcccg8_R0;
MCNUM mcccg8_Qc;
MCNUM mcccg8_alpha;
MCNUM mcccg8_m;
MCNUM mcccg8_W;
MCNUM mcccg8_nslit;
MCNUM mcccg8_d;
MCNUM mcccg8_mleft;
MCNUM mcccg8_mright;
MCNUM mcccg8_mtop;
MCNUM mcccg8_mbottom;
MCNUM mcccg8_nhslit;
MCNUM mcccg8_G;
MCNUM mcccg8_aleft;
MCNUM mcccg8_aright;
MCNUM mcccg8_atop;
MCNUM mcccg8_abottom;
MCNUM mcccg8_wavy;
MCNUM mcccg8_wavy_z;
MCNUM mcccg8_wavy_tb;
MCNUM mcccg8_wavy_lr;
MCNUM mcccg8_chamfers;
MCNUM mcccg8_chamfers_z;
MCNUM mcccg8_chamfers_lr;
MCNUM mcccg8_chamfers_tb;
MCNUM mcccg8_nelements;
MCNUM mcccg8_nu;
MCNUM mcccg8_phase;
char mcccg8_reflect[16384];

/* Setting parameters for component 'cg9' [17]. */
MCNUM mcccg9_w1;
MCNUM mcccg9_h1;
MCNUM mcccg9_w2;
MCNUM mcccg9_h2;
MCNUM mcccg9_l;
MCNUM mcccg9_R0;
MCNUM mcccg9_Qc;
MCNUM mcccg9_alpha;
MCNUM mcccg9_m;
MCNUM mcccg9_W;
MCNUM mcccg9_nslit;
MCNUM mcccg9_d;
MCNUM mcccg9_mleft;
MCNUM mcccg9_mright;
MCNUM mcccg9_mtop;
MCNUM mcccg9_mbottom;
MCNUM mcccg9_nhslit;
MCNUM mcccg9_G;
MCNUM mcccg9_aleft;
MCNUM mcccg9_aright;
MCNUM mcccg9_atop;
MCNUM mcccg9_abottom;
MCNUM mcccg9_wavy;
MCNUM mcccg9_wavy_z;
MCNUM mcccg9_wavy_tb;
MCNUM mcccg9_wavy_lr;
MCNUM mcccg9_chamfers;
MCNUM mcccg9_chamfers_z;
MCNUM mcccg9_chamfers_lr;
MCNUM mcccg9_chamfers_tb;
MCNUM mcccg9_nelements;
MCNUM mcccg9_nu;
MCNUM mcccg9_phase;
char mcccg9_reflect[16384];

/* Setting parameters for component 'cg10' [18]. */
MCNUM mcccg10_w1;
MCNUM mcccg10_h1;
MCNUM mcccg10_w2;
MCNUM mcccg10_h2;
MCNUM mcccg10_l;
MCNUM mcccg10_R0;
MCNUM mcccg10_Qc;
MCNUM mcccg10_alpha;
MCNUM mcccg10_m;
MCNUM mcccg10_W;
MCNUM mcccg10_nslit;
MCNUM mcccg10_d;
MCNUM mcccg10_mleft;
MCNUM mcccg10_mright;
MCNUM mcccg10_mtop;
MCNUM mcccg10_mbottom;
MCNUM mcccg10_nhslit;
MCNUM mcccg10_G;
MCNUM mcccg10_aleft;
MCNUM mcccg10_aright;
MCNUM mcccg10_atop;
MCNUM mcccg10_abottom;
MCNUM mcccg10_wavy;
MCNUM mcccg10_wavy_z;
MCNUM mcccg10_wavy_tb;
MCNUM mcccg10_wavy_lr;
MCNUM mcccg10_chamfers;
MCNUM mcccg10_chamfers_z;
MCNUM mcccg10_chamfers_lr;
MCNUM mcccg10_chamfers_tb;
MCNUM mcccg10_nelements;
MCNUM mcccg10_nu;
MCNUM mcccg10_phase;
char mcccg10_reflect[16384];

/* Setting parameters for component 'cg11' [19]. */
MCNUM mcccg11_w1;
MCNUM mcccg11_h1;
MCNUM mcccg11_w2;
MCNUM mcccg11_h2;
MCNUM mcccg11_l;
MCNUM mcccg11_R0;
MCNUM mcccg11_Qc;
MCNUM mcccg11_alpha;
MCNUM mcccg11_m;
MCNUM mcccg11_W;
MCNUM mcccg11_nslit;
MCNUM mcccg11_d;
MCNUM mcccg11_mleft;
MCNUM mcccg11_mright;
MCNUM mcccg11_mtop;
MCNUM mcccg11_mbottom;
MCNUM mcccg11_nhslit;
MCNUM mcccg11_G;
MCNUM mcccg11_aleft;
MCNUM mcccg11_aright;
MCNUM mcccg11_atop;
MCNUM mcccg11_abottom;
MCNUM mcccg11_wavy;
MCNUM mcccg11_wavy_z;
MCNUM mcccg11_wavy_tb;
MCNUM mcccg11_wavy_lr;
MCNUM mcccg11_chamfers;
MCNUM mcccg11_chamfers_z;
MCNUM mcccg11_chamfers_lr;
MCNUM mcccg11_chamfers_tb;
MCNUM mcccg11_nelements;
MCNUM mcccg11_nu;
MCNUM mcccg11_phase;
char mcccg11_reflect[16384];

/* Setting parameters for component 'cg12' [20]. */
MCNUM mcccg12_w1;
MCNUM mcccg12_h1;
MCNUM mcccg12_w2;
MCNUM mcccg12_h2;
MCNUM mcccg12_l;
MCNUM mcccg12_R0;
MCNUM mcccg12_Qc;
MCNUM mcccg12_alpha;
MCNUM mcccg12_m;
MCNUM mcccg12_W;
MCNUM mcccg12_nslit;
MCNUM mcccg12_d;
MCNUM mcccg12_mleft;
MCNUM mcccg12_mright;
MCNUM mcccg12_mtop;
MCNUM mcccg12_mbottom;
MCNUM mcccg12_nhslit;
MCNUM mcccg12_G;
MCNUM mcccg12_aleft;
MCNUM mcccg12_aright;
MCNUM mcccg12_atop;
MCNUM mcccg12_abottom;
MCNUM mcccg12_wavy;
MCNUM mcccg12_wavy_z;
MCNUM mcccg12_wavy_tb;
MCNUM mcccg12_wavy_lr;
MCNUM mcccg12_chamfers;
MCNUM mcccg12_chamfers_z;
MCNUM mcccg12_chamfers_lr;
MCNUM mcccg12_chamfers_tb;
MCNUM mcccg12_nelements;
MCNUM mcccg12_nu;
MCNUM mcccg12_phase;
char mcccg12_reflect[16384];

/* Setting parameters for component 'cg13' [21]. */
MCNUM mcccg13_w1;
MCNUM mcccg13_h1;
MCNUM mcccg13_w2;
MCNUM mcccg13_h2;
MCNUM mcccg13_l;
MCNUM mcccg13_R0;
MCNUM mcccg13_Qc;
MCNUM mcccg13_alpha;
MCNUM mcccg13_m;
MCNUM mcccg13_W;
MCNUM mcccg13_nslit;
MCNUM mcccg13_d;
MCNUM mcccg13_mleft;
MCNUM mcccg13_mright;
MCNUM mcccg13_mtop;
MCNUM mcccg13_mbottom;
MCNUM mcccg13_nhslit;
MCNUM mcccg13_G;
MCNUM mcccg13_aleft;
MCNUM mcccg13_aright;
MCNUM mcccg13_atop;
MCNUM mcccg13_abottom;
MCNUM mcccg13_wavy;
MCNUM mcccg13_wavy_z;
MCNUM mcccg13_wavy_tb;
MCNUM mcccg13_wavy_lr;
MCNUM mcccg13_chamfers;
MCNUM mcccg13_chamfers_z;
MCNUM mcccg13_chamfers_lr;
MCNUM mcccg13_chamfers_tb;
MCNUM mcccg13_nelements;
MCNUM mcccg13_nu;
MCNUM mcccg13_phase;
char mcccg13_reflect[16384];

/* Setting parameters for component 'cg14' [22]. */
MCNUM mcccg14_w1;
MCNUM mcccg14_h1;
MCNUM mcccg14_w2;
MCNUM mcccg14_h2;
MCNUM mcccg14_l;
MCNUM mcccg14_R0;
MCNUM mcccg14_Qc;
MCNUM mcccg14_alpha;
MCNUM mcccg14_m;
MCNUM mcccg14_W;
MCNUM mcccg14_nslit;
MCNUM mcccg14_d;
MCNUM mcccg14_mleft;
MCNUM mcccg14_mright;
MCNUM mcccg14_mtop;
MCNUM mcccg14_mbottom;
MCNUM mcccg14_nhslit;
MCNUM mcccg14_G;
MCNUM mcccg14_aleft;
MCNUM mcccg14_aright;
MCNUM mcccg14_atop;
MCNUM mcccg14_abottom;
MCNUM mcccg14_wavy;
MCNUM mcccg14_wavy_z;
MCNUM mcccg14_wavy_tb;
MCNUM mcccg14_wavy_lr;
MCNUM mcccg14_chamfers;
MCNUM mcccg14_chamfers_z;
MCNUM mcccg14_chamfers_lr;
MCNUM mcccg14_chamfers_tb;
MCNUM mcccg14_nelements;
MCNUM mcccg14_nu;
MCNUM mcccg14_phase;
char mcccg14_reflect[16384];

/* Setting parameters for component 'cg15' [23]. */
MCNUM mcccg15_w1;
MCNUM mcccg15_h1;
MCNUM mcccg15_w2;
MCNUM mcccg15_h2;
MCNUM mcccg15_l;
MCNUM mcccg15_R0;
MCNUM mcccg15_Qc;
MCNUM mcccg15_alpha;
MCNUM mcccg15_m;
MCNUM mcccg15_W;
MCNUM mcccg15_nslit;
MCNUM mcccg15_d;
MCNUM mcccg15_mleft;
MCNUM mcccg15_mright;
MCNUM mcccg15_mtop;
MCNUM mcccg15_mbottom;
MCNUM mcccg15_nhslit;
MCNUM mcccg15_G;
MCNUM mcccg15_aleft;
MCNUM mcccg15_aright;
MCNUM mcccg15_atop;
MCNUM mcccg15_abottom;
MCNUM mcccg15_wavy;
MCNUM mcccg15_wavy_z;
MCNUM mcccg15_wavy_tb;
MCNUM mcccg15_wavy_lr;
MCNUM mcccg15_chamfers;
MCNUM mcccg15_chamfers_z;
MCNUM mcccg15_chamfers_lr;
MCNUM mcccg15_chamfers_tb;
MCNUM mcccg15_nelements;
MCNUM mcccg15_nu;
MCNUM mcccg15_phase;
char mcccg15_reflect[16384];

/* Setting parameters for component 'cg16' [24]. */
MCNUM mcccg16_w1;
MCNUM mcccg16_h1;
MCNUM mcccg16_w2;
MCNUM mcccg16_h2;
MCNUM mcccg16_l;
MCNUM mcccg16_R0;
MCNUM mcccg16_Qc;
MCNUM mcccg16_alpha;
MCNUM mcccg16_m;
MCNUM mcccg16_W;
MCNUM mcccg16_nslit;
MCNUM mcccg16_d;
MCNUM mcccg16_mleft;
MCNUM mcccg16_mright;
MCNUM mcccg16_mtop;
MCNUM mcccg16_mbottom;
MCNUM mcccg16_nhslit;
MCNUM mcccg16_G;
MCNUM mcccg16_aleft;
MCNUM mcccg16_aright;
MCNUM mcccg16_atop;
MCNUM mcccg16_abottom;
MCNUM mcccg16_wavy;
MCNUM mcccg16_wavy_z;
MCNUM mcccg16_wavy_tb;
MCNUM mcccg16_wavy_lr;
MCNUM mcccg16_chamfers;
MCNUM mcccg16_chamfers_z;
MCNUM mcccg16_chamfers_lr;
MCNUM mcccg16_chamfers_tb;
MCNUM mcccg16_nelements;
MCNUM mcccg16_nu;
MCNUM mcccg16_phase;
char mcccg16_reflect[16384];

/* Setting parameters for component 'cg17' [25]. */
MCNUM mcccg17_w1;
MCNUM mcccg17_h1;
MCNUM mcccg17_w2;
MCNUM mcccg17_h2;
MCNUM mcccg17_l;
MCNUM mcccg17_R0;
MCNUM mcccg17_Qc;
MCNUM mcccg17_alpha;
MCNUM mcccg17_m;
MCNUM mcccg17_W;
MCNUM mcccg17_nslit;
MCNUM mcccg17_d;
MCNUM mcccg17_mleft;
MCNUM mcccg17_mright;
MCNUM mcccg17_mtop;
MCNUM mcccg17_mbottom;
MCNUM mcccg17_nhslit;
MCNUM mcccg17_G;
MCNUM mcccg17_aleft;
MCNUM mcccg17_aright;
MCNUM mcccg17_atop;
MCNUM mcccg17_abottom;
MCNUM mcccg17_wavy;
MCNUM mcccg17_wavy_z;
MCNUM mcccg17_wavy_tb;
MCNUM mcccg17_wavy_lr;
MCNUM mcccg17_chamfers;
MCNUM mcccg17_chamfers_z;
MCNUM mcccg17_chamfers_lr;
MCNUM mcccg17_chamfers_tb;
MCNUM mcccg17_nelements;
MCNUM mcccg17_nu;
MCNUM mcccg17_phase;
char mcccg17_reflect[16384];

/* Setting parameters for component 'cg18' [26]. */
MCNUM mcccg18_w1;
MCNUM mcccg18_h1;
MCNUM mcccg18_w2;
MCNUM mcccg18_h2;
MCNUM mcccg18_l;
MCNUM mcccg18_R0;
MCNUM mcccg18_Qc;
MCNUM mcccg18_alpha;
MCNUM mcccg18_m;
MCNUM mcccg18_W;
MCNUM mcccg18_nslit;
MCNUM mcccg18_d;
MCNUM mcccg18_mleft;
MCNUM mcccg18_mright;
MCNUM mcccg18_mtop;
MCNUM mcccg18_mbottom;
MCNUM mcccg18_nhslit;
MCNUM mcccg18_G;
MCNUM mcccg18_aleft;
MCNUM mcccg18_aright;
MCNUM mcccg18_atop;
MCNUM mcccg18_abottom;
MCNUM mcccg18_wavy;
MCNUM mcccg18_wavy_z;
MCNUM mcccg18_wavy_tb;
MCNUM mcccg18_wavy_lr;
MCNUM mcccg18_chamfers;
MCNUM mcccg18_chamfers_z;
MCNUM mcccg18_chamfers_lr;
MCNUM mcccg18_chamfers_tb;
MCNUM mcccg18_nelements;
MCNUM mcccg18_nu;
MCNUM mcccg18_phase;
char mcccg18_reflect[16384];

/* Setting parameters for component 'cg19' [27]. */
MCNUM mcccg19_w1;
MCNUM mcccg19_h1;
MCNUM mcccg19_w2;
MCNUM mcccg19_h2;
MCNUM mcccg19_l;
MCNUM mcccg19_R0;
MCNUM mcccg19_Qc;
MCNUM mcccg19_alpha;
MCNUM mcccg19_m;
MCNUM mcccg19_W;
MCNUM mcccg19_nslit;
MCNUM mcccg19_d;
MCNUM mcccg19_mleft;
MCNUM mcccg19_mright;
MCNUM mcccg19_mtop;
MCNUM mcccg19_mbottom;
MCNUM mcccg19_nhslit;
MCNUM mcccg19_G;
MCNUM mcccg19_aleft;
MCNUM mcccg19_aright;
MCNUM mcccg19_atop;
MCNUM mcccg19_abottom;
MCNUM mcccg19_wavy;
MCNUM mcccg19_wavy_z;
MCNUM mcccg19_wavy_tb;
MCNUM mcccg19_wavy_lr;
MCNUM mcccg19_chamfers;
MCNUM mcccg19_chamfers_z;
MCNUM mcccg19_chamfers_lr;
MCNUM mcccg19_chamfers_tb;
MCNUM mcccg19_nelements;
MCNUM mcccg19_nu;
MCNUM mcccg19_phase;
char mcccg19_reflect[16384];

/* Setting parameters for component 'cg20' [28]. */
MCNUM mcccg20_w1;
MCNUM mcccg20_h1;
MCNUM mcccg20_w2;
MCNUM mcccg20_h2;
MCNUM mcccg20_l;
MCNUM mcccg20_R0;
MCNUM mcccg20_Qc;
MCNUM mcccg20_alpha;
MCNUM mcccg20_m;
MCNUM mcccg20_W;
MCNUM mcccg20_nslit;
MCNUM mcccg20_d;
MCNUM mcccg20_mleft;
MCNUM mcccg20_mright;
MCNUM mcccg20_mtop;
MCNUM mcccg20_mbottom;
MCNUM mcccg20_nhslit;
MCNUM mcccg20_G;
MCNUM mcccg20_aleft;
MCNUM mcccg20_aright;
MCNUM mcccg20_atop;
MCNUM mcccg20_abottom;
MCNUM mcccg20_wavy;
MCNUM mcccg20_wavy_z;
MCNUM mcccg20_wavy_tb;
MCNUM mcccg20_wavy_lr;
MCNUM mcccg20_chamfers;
MCNUM mcccg20_chamfers_z;
MCNUM mcccg20_chamfers_lr;
MCNUM mcccg20_chamfers_tb;
MCNUM mcccg20_nelements;
MCNUM mcccg20_nu;
MCNUM mcccg20_phase;
char mcccg20_reflect[16384];

/* Setting parameters for component 'cg21' [29]. */
MCNUM mcccg21_w1;
MCNUM mcccg21_h1;
MCNUM mcccg21_w2;
MCNUM mcccg21_h2;
MCNUM mcccg21_l;
MCNUM mcccg21_R0;
MCNUM mcccg21_Qc;
MCNUM mcccg21_alpha;
MCNUM mcccg21_m;
MCNUM mcccg21_W;
MCNUM mcccg21_nslit;
MCNUM mcccg21_d;
MCNUM mcccg21_mleft;
MCNUM mcccg21_mright;
MCNUM mcccg21_mtop;
MCNUM mcccg21_mbottom;
MCNUM mcccg21_nhslit;
MCNUM mcccg21_G;
MCNUM mcccg21_aleft;
MCNUM mcccg21_aright;
MCNUM mcccg21_atop;
MCNUM mcccg21_abottom;
MCNUM mcccg21_wavy;
MCNUM mcccg21_wavy_z;
MCNUM mcccg21_wavy_tb;
MCNUM mcccg21_wavy_lr;
MCNUM mcccg21_chamfers;
MCNUM mcccg21_chamfers_z;
MCNUM mcccg21_chamfers_lr;
MCNUM mcccg21_chamfers_tb;
MCNUM mcccg21_nelements;
MCNUM mcccg21_nu;
MCNUM mcccg21_phase;
char mcccg21_reflect[16384];

/* Setting parameters for component 'cg22' [30]. */
MCNUM mcccg22_w1;
MCNUM mcccg22_h1;
MCNUM mcccg22_w2;
MCNUM mcccg22_h2;
MCNUM mcccg22_l;
MCNUM mcccg22_R0;
MCNUM mcccg22_Qc;
MCNUM mcccg22_alpha;
MCNUM mcccg22_m;
MCNUM mcccg22_W;
MCNUM mcccg22_nslit;
MCNUM mcccg22_d;
MCNUM mcccg22_mleft;
MCNUM mcccg22_mright;
MCNUM mcccg22_mtop;
MCNUM mcccg22_mbottom;
MCNUM mcccg22_nhslit;
MCNUM mcccg22_G;
MCNUM mcccg22_aleft;
MCNUM mcccg22_aright;
MCNUM mcccg22_atop;
MCNUM mcccg22_abottom;
MCNUM mcccg22_wavy;
MCNUM mcccg22_wavy_z;
MCNUM mcccg22_wavy_tb;
MCNUM mcccg22_wavy_lr;
MCNUM mcccg22_chamfers;
MCNUM mcccg22_chamfers_z;
MCNUM mcccg22_chamfers_lr;
MCNUM mcccg22_chamfers_tb;
MCNUM mcccg22_nelements;
MCNUM mcccg22_nu;
MCNUM mcccg22_phase;
char mcccg22_reflect[16384];

/* Setting parameters for component 'cg23' [31]. */
MCNUM mcccg23_w1;
MCNUM mcccg23_h1;
MCNUM mcccg23_w2;
MCNUM mcccg23_h2;
MCNUM mcccg23_l;
MCNUM mcccg23_R0;
MCNUM mcccg23_Qc;
MCNUM mcccg23_alpha;
MCNUM mcccg23_m;
MCNUM mcccg23_W;
MCNUM mcccg23_nslit;
MCNUM mcccg23_d;
MCNUM mcccg23_mleft;
MCNUM mcccg23_mright;
MCNUM mcccg23_mtop;
MCNUM mcccg23_mbottom;
MCNUM mcccg23_nhslit;
MCNUM mcccg23_G;
MCNUM mcccg23_aleft;
MCNUM mcccg23_aright;
MCNUM mcccg23_atop;
MCNUM mcccg23_abottom;
MCNUM mcccg23_wavy;
MCNUM mcccg23_wavy_z;
MCNUM mcccg23_wavy_tb;
MCNUM mcccg23_wavy_lr;
MCNUM mcccg23_chamfers;
MCNUM mcccg23_chamfers_z;
MCNUM mcccg23_chamfers_lr;
MCNUM mcccg23_chamfers_tb;
MCNUM mcccg23_nelements;
MCNUM mcccg23_nu;
MCNUM mcccg23_phase;
char mcccg23_reflect[16384];

/* Setting parameters for component 'cg24' [32]. */
MCNUM mcccg24_w1;
MCNUM mcccg24_h1;
MCNUM mcccg24_w2;
MCNUM mcccg24_h2;
MCNUM mcccg24_l;
MCNUM mcccg24_R0;
MCNUM mcccg24_Qc;
MCNUM mcccg24_alpha;
MCNUM mcccg24_m;
MCNUM mcccg24_W;
MCNUM mcccg24_nslit;
MCNUM mcccg24_d;
MCNUM mcccg24_mleft;
MCNUM mcccg24_mright;
MCNUM mcccg24_mtop;
MCNUM mcccg24_mbottom;
MCNUM mcccg24_nhslit;
MCNUM mcccg24_G;
MCNUM mcccg24_aleft;
MCNUM mcccg24_aright;
MCNUM mcccg24_atop;
MCNUM mcccg24_abottom;
MCNUM mcccg24_wavy;
MCNUM mcccg24_wavy_z;
MCNUM mcccg24_wavy_tb;
MCNUM mcccg24_wavy_lr;
MCNUM mcccg24_chamfers;
MCNUM mcccg24_chamfers_z;
MCNUM mcccg24_chamfers_lr;
MCNUM mcccg24_chamfers_tb;
MCNUM mcccg24_nelements;
MCNUM mcccg24_nu;
MCNUM mcccg24_phase;
char mcccg24_reflect[16384];

/* Setting parameters for component 'cg25' [33]. */
MCNUM mcccg25_w1;
MCNUM mcccg25_h1;
MCNUM mcccg25_w2;
MCNUM mcccg25_h2;
MCNUM mcccg25_l;
MCNUM mcccg25_R0;
MCNUM mcccg25_Qc;
MCNUM mcccg25_alpha;
MCNUM mcccg25_m;
MCNUM mcccg25_W;
MCNUM mcccg25_nslit;
MCNUM mcccg25_d;
MCNUM mcccg25_mleft;
MCNUM mcccg25_mright;
MCNUM mcccg25_mtop;
MCNUM mcccg25_mbottom;
MCNUM mcccg25_nhslit;
MCNUM mcccg25_G;
MCNUM mcccg25_aleft;
MCNUM mcccg25_aright;
MCNUM mcccg25_atop;
MCNUM mcccg25_abottom;
MCNUM mcccg25_wavy;
MCNUM mcccg25_wavy_z;
MCNUM mcccg25_wavy_tb;
MCNUM mcccg25_wavy_lr;
MCNUM mcccg25_chamfers;
MCNUM mcccg25_chamfers_z;
MCNUM mcccg25_chamfers_lr;
MCNUM mcccg25_chamfers_tb;
MCNUM mcccg25_nelements;
MCNUM mcccg25_nu;
MCNUM mcccg25_phase;
char mcccg25_reflect[16384];

/* Setting parameters for component 'AlWindow4' [34]. */
MCNUM mccAlWindow4_thickness;

/* Definition parameters for component 'PSD_VTE' [35]. */
#define mccPSD_VTE_user1 FLT_MAX
#define mccPSD_VTE_user2 FLT_MAX
#define mccPSD_VTE_user3 FLT_MAX
/* Setting parameters for component 'PSD_VTE' [35]. */
MCNUM mccPSD_VTE_xwidth;
MCNUM mccPSD_VTE_yheight;
MCNUM mccPSD_VTE_zdepth;
MCNUM mccPSD_VTE_xmin;
MCNUM mccPSD_VTE_xmax;
MCNUM mccPSD_VTE_ymin;
MCNUM mccPSD_VTE_ymax;
MCNUM mccPSD_VTE_zmin;
MCNUM mccPSD_VTE_zmax;
MCNUM mccPSD_VTE_bins;
MCNUM mccPSD_VTE_min;
MCNUM mccPSD_VTE_max;
MCNUM mccPSD_VTE_restore_neutron;
MCNUM mccPSD_VTE_radius;
char mccPSD_VTE_options[16384];
char mccPSD_VTE_filename[16384];
char mccPSD_VTE_geometry[16384];
char mccPSD_VTE_username1[16384];
char mccPSD_VTE_username2[16384];
char mccPSD_VTE_username3[16384];
int mccPSD_VTE_nowritefile;

/* Setting parameters for component 'AlWindow5' [36]. */
MCNUM mccAlWindow5_thickness;

/* Setting parameters for component 'sg1' [38]. */
MCNUM mccsg1_w1;
MCNUM mccsg1_h1;
MCNUM mccsg1_w2;
MCNUM mccsg1_h2;
MCNUM mccsg1_l;
MCNUM mccsg1_R0;
MCNUM mccsg1_Qc;
MCNUM mccsg1_alpha;
MCNUM mccsg1_m;
MCNUM mccsg1_W;
MCNUM mccsg1_nslit;
MCNUM mccsg1_d;
MCNUM mccsg1_mleft;
MCNUM mccsg1_mright;
MCNUM mccsg1_mtop;
MCNUM mccsg1_mbottom;
MCNUM mccsg1_nhslit;
MCNUM mccsg1_G;
MCNUM mccsg1_aleft;
MCNUM mccsg1_aright;
MCNUM mccsg1_atop;
MCNUM mccsg1_abottom;
MCNUM mccsg1_wavy;
MCNUM mccsg1_wavy_z;
MCNUM mccsg1_wavy_tb;
MCNUM mccsg1_wavy_lr;
MCNUM mccsg1_chamfers;
MCNUM mccsg1_chamfers_z;
MCNUM mccsg1_chamfers_lr;
MCNUM mccsg1_chamfers_tb;
MCNUM mccsg1_nelements;
MCNUM mccsg1_nu;
MCNUM mccsg1_phase;
char mccsg1_reflect[16384];

/* Setting parameters for component 'sg2' [39]. */
MCNUM mccsg2_w1;
MCNUM mccsg2_h1;
MCNUM mccsg2_w2;
MCNUM mccsg2_h2;
MCNUM mccsg2_l;
MCNUM mccsg2_R0;
MCNUM mccsg2_Qc;
MCNUM mccsg2_alpha;
MCNUM mccsg2_m;
MCNUM mccsg2_W;
MCNUM mccsg2_nslit;
MCNUM mccsg2_d;
MCNUM mccsg2_mleft;
MCNUM mccsg2_mright;
MCNUM mccsg2_mtop;
MCNUM mccsg2_mbottom;
MCNUM mccsg2_nhslit;
MCNUM mccsg2_G;
MCNUM mccsg2_aleft;
MCNUM mccsg2_aright;
MCNUM mccsg2_atop;
MCNUM mccsg2_abottom;
MCNUM mccsg2_wavy;
MCNUM mccsg2_wavy_z;
MCNUM mccsg2_wavy_tb;
MCNUM mccsg2_wavy_lr;
MCNUM mccsg2_chamfers;
MCNUM mccsg2_chamfers_z;
MCNUM mccsg2_chamfers_lr;
MCNUM mccsg2_chamfers_tb;
MCNUM mccsg2_nelements;
MCNUM mccsg2_nu;
MCNUM mccsg2_phase;
char mccsg2_reflect[16384];

/* Setting parameters for component 'sg3' [40]. */
MCNUM mccsg3_w1;
MCNUM mccsg3_h1;
MCNUM mccsg3_w2;
MCNUM mccsg3_h2;
MCNUM mccsg3_l;
MCNUM mccsg3_R0;
MCNUM mccsg3_Qc;
MCNUM mccsg3_alpha;
MCNUM mccsg3_m;
MCNUM mccsg3_W;
MCNUM mccsg3_nslit;
MCNUM mccsg3_d;
MCNUM mccsg3_mleft;
MCNUM mccsg3_mright;
MCNUM mccsg3_mtop;
MCNUM mccsg3_mbottom;
MCNUM mccsg3_nhslit;
MCNUM mccsg3_G;
MCNUM mccsg3_aleft;
MCNUM mccsg3_aright;
MCNUM mccsg3_atop;
MCNUM mccsg3_abottom;
MCNUM mccsg3_wavy;
MCNUM mccsg3_wavy_z;
MCNUM mccsg3_wavy_tb;
MCNUM mccsg3_wavy_lr;
MCNUM mccsg3_chamfers;
MCNUM mccsg3_chamfers_z;
MCNUM mccsg3_chamfers_lr;
MCNUM mccsg3_chamfers_tb;
MCNUM mccsg3_nelements;
MCNUM mccsg3_nu;
MCNUM mccsg3_phase;
char mccsg3_reflect[16384];

/* Setting parameters for component 'sg4' [41]. */
MCNUM mccsg4_w1;
MCNUM mccsg4_h1;
MCNUM mccsg4_w2;
MCNUM mccsg4_h2;
MCNUM mccsg4_l;
MCNUM mccsg4_R0;
MCNUM mccsg4_Qc;
MCNUM mccsg4_alpha;
MCNUM mccsg4_m;
MCNUM mccsg4_W;
MCNUM mccsg4_nslit;
MCNUM mccsg4_d;
MCNUM mccsg4_mleft;
MCNUM mccsg4_mright;
MCNUM mccsg4_mtop;
MCNUM mccsg4_mbottom;
MCNUM mccsg4_nhslit;
MCNUM mccsg4_G;
MCNUM mccsg4_aleft;
MCNUM mccsg4_aright;
MCNUM mccsg4_atop;
MCNUM mccsg4_abottom;
MCNUM mccsg4_wavy;
MCNUM mccsg4_wavy_z;
MCNUM mccsg4_wavy_tb;
MCNUM mccsg4_wavy_lr;
MCNUM mccsg4_chamfers;
MCNUM mccsg4_chamfers_z;
MCNUM mccsg4_chamfers_lr;
MCNUM mccsg4_chamfers_tb;
MCNUM mccsg4_nelements;
MCNUM mccsg4_nu;
MCNUM mccsg4_phase;
char mccsg4_reflect[16384];

/* Setting parameters for component 'sg5' [42]. */
MCNUM mccsg5_w1;
MCNUM mccsg5_h1;
MCNUM mccsg5_w2;
MCNUM mccsg5_h2;
MCNUM mccsg5_l;
MCNUM mccsg5_R0;
MCNUM mccsg5_Qc;
MCNUM mccsg5_alpha;
MCNUM mccsg5_m;
MCNUM mccsg5_W;
MCNUM mccsg5_nslit;
MCNUM mccsg5_d;
MCNUM mccsg5_mleft;
MCNUM mccsg5_mright;
MCNUM mccsg5_mtop;
MCNUM mccsg5_mbottom;
MCNUM mccsg5_nhslit;
MCNUM mccsg5_G;
MCNUM mccsg5_aleft;
MCNUM mccsg5_aright;
MCNUM mccsg5_atop;
MCNUM mccsg5_abottom;
MCNUM mccsg5_wavy;
MCNUM mccsg5_wavy_z;
MCNUM mccsg5_wavy_tb;
MCNUM mccsg5_wavy_lr;
MCNUM mccsg5_chamfers;
MCNUM mccsg5_chamfers_z;
MCNUM mccsg5_chamfers_lr;
MCNUM mccsg5_chamfers_tb;
MCNUM mccsg5_nelements;
MCNUM mccsg5_nu;
MCNUM mccsg5_phase;
char mccsg5_reflect[16384];

/* Setting parameters for component 'sg6' [43]. */
MCNUM mccsg6_w1;
MCNUM mccsg6_h1;
MCNUM mccsg6_w2;
MCNUM mccsg6_h2;
MCNUM mccsg6_l;
MCNUM mccsg6_R0;
MCNUM mccsg6_Qc;
MCNUM mccsg6_alpha;
MCNUM mccsg6_m;
MCNUM mccsg6_W;
MCNUM mccsg6_nslit;
MCNUM mccsg6_d;
MCNUM mccsg6_mleft;
MCNUM mccsg6_mright;
MCNUM mccsg6_mtop;
MCNUM mccsg6_mbottom;
MCNUM mccsg6_nhslit;
MCNUM mccsg6_G;
MCNUM mccsg6_aleft;
MCNUM mccsg6_aright;
MCNUM mccsg6_atop;
MCNUM mccsg6_abottom;
MCNUM mccsg6_wavy;
MCNUM mccsg6_wavy_z;
MCNUM mccsg6_wavy_tb;
MCNUM mccsg6_wavy_lr;
MCNUM mccsg6_chamfers;
MCNUM mccsg6_chamfers_z;
MCNUM mccsg6_chamfers_lr;
MCNUM mccsg6_chamfers_tb;
MCNUM mccsg6_nelements;
MCNUM mccsg6_nu;
MCNUM mccsg6_phase;
char mccsg6_reflect[16384];

/* Setting parameters for component 'sg7' [44]. */
MCNUM mccsg7_w1;
MCNUM mccsg7_h1;
MCNUM mccsg7_w2;
MCNUM mccsg7_h2;
MCNUM mccsg7_l;
MCNUM mccsg7_R0;
MCNUM mccsg7_Qc;
MCNUM mccsg7_alpha;
MCNUM mccsg7_m;
MCNUM mccsg7_W;
MCNUM mccsg7_nslit;
MCNUM mccsg7_d;
MCNUM mccsg7_mleft;
MCNUM mccsg7_mright;
MCNUM mccsg7_mtop;
MCNUM mccsg7_mbottom;
MCNUM mccsg7_nhslit;
MCNUM mccsg7_G;
MCNUM mccsg7_aleft;
MCNUM mccsg7_aright;
MCNUM mccsg7_atop;
MCNUM mccsg7_abottom;
MCNUM mccsg7_wavy;
MCNUM mccsg7_wavy_z;
MCNUM mccsg7_wavy_tb;
MCNUM mccsg7_wavy_lr;
MCNUM mccsg7_chamfers;
MCNUM mccsg7_chamfers_z;
MCNUM mccsg7_chamfers_lr;
MCNUM mccsg7_chamfers_tb;
MCNUM mccsg7_nelements;
MCNUM mccsg7_nu;
MCNUM mccsg7_phase;
char mccsg7_reflect[16384];

/* Setting parameters for component 'sg8' [45]. */
MCNUM mccsg8_w1;
MCNUM mccsg8_h1;
MCNUM mccsg8_w2;
MCNUM mccsg8_h2;
MCNUM mccsg8_l;
MCNUM mccsg8_R0;
MCNUM mccsg8_Qc;
MCNUM mccsg8_alpha;
MCNUM mccsg8_m;
MCNUM mccsg8_W;
MCNUM mccsg8_nslit;
MCNUM mccsg8_d;
MCNUM mccsg8_mleft;
MCNUM mccsg8_mright;
MCNUM mccsg8_mtop;
MCNUM mccsg8_mbottom;
MCNUM mccsg8_nhslit;
MCNUM mccsg8_G;
MCNUM mccsg8_aleft;
MCNUM mccsg8_aright;
MCNUM mccsg8_atop;
MCNUM mccsg8_abottom;
MCNUM mccsg8_wavy;
MCNUM mccsg8_wavy_z;
MCNUM mccsg8_wavy_tb;
MCNUM mccsg8_wavy_lr;
MCNUM mccsg8_chamfers;
MCNUM mccsg8_chamfers_z;
MCNUM mccsg8_chamfers_lr;
MCNUM mccsg8_chamfers_tb;
MCNUM mccsg8_nelements;
MCNUM mccsg8_nu;
MCNUM mccsg8_phase;
char mccsg8_reflect[16384];

/* Setting parameters for component 'sg9' [46]. */
MCNUM mccsg9_w1;
MCNUM mccsg9_h1;
MCNUM mccsg9_w2;
MCNUM mccsg9_h2;
MCNUM mccsg9_l;
MCNUM mccsg9_R0;
MCNUM mccsg9_Qc;
MCNUM mccsg9_alpha;
MCNUM mccsg9_m;
MCNUM mccsg9_W;
MCNUM mccsg9_nslit;
MCNUM mccsg9_d;
MCNUM mccsg9_mleft;
MCNUM mccsg9_mright;
MCNUM mccsg9_mtop;
MCNUM mccsg9_mbottom;
MCNUM mccsg9_nhslit;
MCNUM mccsg9_G;
MCNUM mccsg9_aleft;
MCNUM mccsg9_aright;
MCNUM mccsg9_atop;
MCNUM mccsg9_abottom;
MCNUM mccsg9_wavy;
MCNUM mccsg9_wavy_z;
MCNUM mccsg9_wavy_tb;
MCNUM mccsg9_wavy_lr;
MCNUM mccsg9_chamfers;
MCNUM mccsg9_chamfers_z;
MCNUM mccsg9_chamfers_lr;
MCNUM mccsg9_chamfers_tb;
MCNUM mccsg9_nelements;
MCNUM mccsg9_nu;
MCNUM mccsg9_phase;
char mccsg9_reflect[16384];

/* Setting parameters for component 'sg10' [47]. */
MCNUM mccsg10_w1;
MCNUM mccsg10_h1;
MCNUM mccsg10_w2;
MCNUM mccsg10_h2;
MCNUM mccsg10_l;
MCNUM mccsg10_R0;
MCNUM mccsg10_Qc;
MCNUM mccsg10_alpha;
MCNUM mccsg10_m;
MCNUM mccsg10_W;
MCNUM mccsg10_nslit;
MCNUM mccsg10_d;
MCNUM mccsg10_mleft;
MCNUM mccsg10_mright;
MCNUM mccsg10_mtop;
MCNUM mccsg10_mbottom;
MCNUM mccsg10_nhslit;
MCNUM mccsg10_G;
MCNUM mccsg10_aleft;
MCNUM mccsg10_aright;
MCNUM mccsg10_atop;
MCNUM mccsg10_abottom;
MCNUM mccsg10_wavy;
MCNUM mccsg10_wavy_z;
MCNUM mccsg10_wavy_tb;
MCNUM mccsg10_wavy_lr;
MCNUM mccsg10_chamfers;
MCNUM mccsg10_chamfers_z;
MCNUM mccsg10_chamfers_lr;
MCNUM mccsg10_chamfers_tb;
MCNUM mccsg10_nelements;
MCNUM mccsg10_nu;
MCNUM mccsg10_phase;
char mccsg10_reflect[16384];

/* Setting parameters for component 'sg11' [48]. */
MCNUM mccsg11_w1;
MCNUM mccsg11_h1;
MCNUM mccsg11_w2;
MCNUM mccsg11_h2;
MCNUM mccsg11_l;
MCNUM mccsg11_R0;
MCNUM mccsg11_Qc;
MCNUM mccsg11_alpha;
MCNUM mccsg11_m;
MCNUM mccsg11_W;
MCNUM mccsg11_nslit;
MCNUM mccsg11_d;
MCNUM mccsg11_mleft;
MCNUM mccsg11_mright;
MCNUM mccsg11_mtop;
MCNUM mccsg11_mbottom;
MCNUM mccsg11_nhslit;
MCNUM mccsg11_G;
MCNUM mccsg11_aleft;
MCNUM mccsg11_aright;
MCNUM mccsg11_atop;
MCNUM mccsg11_abottom;
MCNUM mccsg11_wavy;
MCNUM mccsg11_wavy_z;
MCNUM mccsg11_wavy_tb;
MCNUM mccsg11_wavy_lr;
MCNUM mccsg11_chamfers;
MCNUM mccsg11_chamfers_z;
MCNUM mccsg11_chamfers_lr;
MCNUM mccsg11_chamfers_tb;
MCNUM mccsg11_nelements;
MCNUM mccsg11_nu;
MCNUM mccsg11_phase;
char mccsg11_reflect[16384];

/* Setting parameters for component 'sg12' [49]. */
MCNUM mccsg12_w1;
MCNUM mccsg12_h1;
MCNUM mccsg12_w2;
MCNUM mccsg12_h2;
MCNUM mccsg12_l;
MCNUM mccsg12_R0;
MCNUM mccsg12_Qc;
MCNUM mccsg12_alpha;
MCNUM mccsg12_m;
MCNUM mccsg12_W;
MCNUM mccsg12_nslit;
MCNUM mccsg12_d;
MCNUM mccsg12_mleft;
MCNUM mccsg12_mright;
MCNUM mccsg12_mtop;
MCNUM mccsg12_mbottom;
MCNUM mccsg12_nhslit;
MCNUM mccsg12_G;
MCNUM mccsg12_aleft;
MCNUM mccsg12_aright;
MCNUM mccsg12_atop;
MCNUM mccsg12_abottom;
MCNUM mccsg12_wavy;
MCNUM mccsg12_wavy_z;
MCNUM mccsg12_wavy_tb;
MCNUM mccsg12_wavy_lr;
MCNUM mccsg12_chamfers;
MCNUM mccsg12_chamfers_z;
MCNUM mccsg12_chamfers_lr;
MCNUM mccsg12_chamfers_tb;
MCNUM mccsg12_nelements;
MCNUM mccsg12_nu;
MCNUM mccsg12_phase;
char mccsg12_reflect[16384];

/* Setting parameters for component 'sg13' [50]. */
MCNUM mccsg13_w1;
MCNUM mccsg13_h1;
MCNUM mccsg13_w2;
MCNUM mccsg13_h2;
MCNUM mccsg13_l;
MCNUM mccsg13_R0;
MCNUM mccsg13_Qc;
MCNUM mccsg13_alpha;
MCNUM mccsg13_m;
MCNUM mccsg13_W;
MCNUM mccsg13_nslit;
MCNUM mccsg13_d;
MCNUM mccsg13_mleft;
MCNUM mccsg13_mright;
MCNUM mccsg13_mtop;
MCNUM mccsg13_mbottom;
MCNUM mccsg13_nhslit;
MCNUM mccsg13_G;
MCNUM mccsg13_aleft;
MCNUM mccsg13_aright;
MCNUM mccsg13_atop;
MCNUM mccsg13_abottom;
MCNUM mccsg13_wavy;
MCNUM mccsg13_wavy_z;
MCNUM mccsg13_wavy_tb;
MCNUM mccsg13_wavy_lr;
MCNUM mccsg13_chamfers;
MCNUM mccsg13_chamfers_z;
MCNUM mccsg13_chamfers_lr;
MCNUM mccsg13_chamfers_tb;
MCNUM mccsg13_nelements;
MCNUM mccsg13_nu;
MCNUM mccsg13_phase;
char mccsg13_reflect[16384];

/* Setting parameters for component 'sg14' [51]. */
MCNUM mccsg14_w1;
MCNUM mccsg14_h1;
MCNUM mccsg14_w2;
MCNUM mccsg14_h2;
MCNUM mccsg14_l;
MCNUM mccsg14_R0;
MCNUM mccsg14_Qc;
MCNUM mccsg14_alpha;
MCNUM mccsg14_m;
MCNUM mccsg14_W;
MCNUM mccsg14_nslit;
MCNUM mccsg14_d;
MCNUM mccsg14_mleft;
MCNUM mccsg14_mright;
MCNUM mccsg14_mtop;
MCNUM mccsg14_mbottom;
MCNUM mccsg14_nhslit;
MCNUM mccsg14_G;
MCNUM mccsg14_aleft;
MCNUM mccsg14_aright;
MCNUM mccsg14_atop;
MCNUM mccsg14_abottom;
MCNUM mccsg14_wavy;
MCNUM mccsg14_wavy_z;
MCNUM mccsg14_wavy_tb;
MCNUM mccsg14_wavy_lr;
MCNUM mccsg14_chamfers;
MCNUM mccsg14_chamfers_z;
MCNUM mccsg14_chamfers_lr;
MCNUM mccsg14_chamfers_tb;
MCNUM mccsg14_nelements;
MCNUM mccsg14_nu;
MCNUM mccsg14_phase;
char mccsg14_reflect[16384];

/* Setting parameters for component 'sg15' [52]. */
MCNUM mccsg15_w1;
MCNUM mccsg15_h1;
MCNUM mccsg15_w2;
MCNUM mccsg15_h2;
MCNUM mccsg15_l;
MCNUM mccsg15_R0;
MCNUM mccsg15_Qc;
MCNUM mccsg15_alpha;
MCNUM mccsg15_m;
MCNUM mccsg15_W;
MCNUM mccsg15_nslit;
MCNUM mccsg15_d;
MCNUM mccsg15_mleft;
MCNUM mccsg15_mright;
MCNUM mccsg15_mtop;
MCNUM mccsg15_mbottom;
MCNUM mccsg15_nhslit;
MCNUM mccsg15_G;
MCNUM mccsg15_aleft;
MCNUM mccsg15_aright;
MCNUM mccsg15_atop;
MCNUM mccsg15_abottom;
MCNUM mccsg15_wavy;
MCNUM mccsg15_wavy_z;
MCNUM mccsg15_wavy_tb;
MCNUM mccsg15_wavy_lr;
MCNUM mccsg15_chamfers;
MCNUM mccsg15_chamfers_z;
MCNUM mccsg15_chamfers_lr;
MCNUM mccsg15_chamfers_tb;
MCNUM mccsg15_nelements;
MCNUM mccsg15_nu;
MCNUM mccsg15_phase;
char mccsg15_reflect[16384];

/* Setting parameters for component 'sg16' [53]. */
MCNUM mccsg16_w1;
MCNUM mccsg16_h1;
MCNUM mccsg16_w2;
MCNUM mccsg16_h2;
MCNUM mccsg16_l;
MCNUM mccsg16_R0;
MCNUM mccsg16_Qc;
MCNUM mccsg16_alpha;
MCNUM mccsg16_m;
MCNUM mccsg16_W;
MCNUM mccsg16_nslit;
MCNUM mccsg16_d;
MCNUM mccsg16_mleft;
MCNUM mccsg16_mright;
MCNUM mccsg16_mtop;
MCNUM mccsg16_mbottom;
MCNUM mccsg16_nhslit;
MCNUM mccsg16_G;
MCNUM mccsg16_aleft;
MCNUM mccsg16_aright;
MCNUM mccsg16_atop;
MCNUM mccsg16_abottom;
MCNUM mccsg16_wavy;
MCNUM mccsg16_wavy_z;
MCNUM mccsg16_wavy_tb;
MCNUM mccsg16_wavy_lr;
MCNUM mccsg16_chamfers;
MCNUM mccsg16_chamfers_z;
MCNUM mccsg16_chamfers_lr;
MCNUM mccsg16_chamfers_tb;
MCNUM mccsg16_nelements;
MCNUM mccsg16_nu;
MCNUM mccsg16_phase;
char mccsg16_reflect[16384];

/* Setting parameters for component 'sg17' [54]. */
MCNUM mccsg17_w1;
MCNUM mccsg17_h1;
MCNUM mccsg17_w2;
MCNUM mccsg17_h2;
MCNUM mccsg17_l;
MCNUM mccsg17_R0;
MCNUM mccsg17_Qc;
MCNUM mccsg17_alpha;
MCNUM mccsg17_m;
MCNUM mccsg17_W;
MCNUM mccsg17_nslit;
MCNUM mccsg17_d;
MCNUM mccsg17_mleft;
MCNUM mccsg17_mright;
MCNUM mccsg17_mtop;
MCNUM mccsg17_mbottom;
MCNUM mccsg17_nhslit;
MCNUM mccsg17_G;
MCNUM mccsg17_aleft;
MCNUM mccsg17_aright;
MCNUM mccsg17_atop;
MCNUM mccsg17_abottom;
MCNUM mccsg17_wavy;
MCNUM mccsg17_wavy_z;
MCNUM mccsg17_wavy_tb;
MCNUM mccsg17_wavy_lr;
MCNUM mccsg17_chamfers;
MCNUM mccsg17_chamfers_z;
MCNUM mccsg17_chamfers_lr;
MCNUM mccsg17_chamfers_tb;
MCNUM mccsg17_nelements;
MCNUM mccsg17_nu;
MCNUM mccsg17_phase;
char mccsg17_reflect[16384];

/* Setting parameters for component 'sg18' [55]. */
MCNUM mccsg18_w1;
MCNUM mccsg18_h1;
MCNUM mccsg18_w2;
MCNUM mccsg18_h2;
MCNUM mccsg18_l;
MCNUM mccsg18_R0;
MCNUM mccsg18_Qc;
MCNUM mccsg18_alpha;
MCNUM mccsg18_m;
MCNUM mccsg18_W;
MCNUM mccsg18_nslit;
MCNUM mccsg18_d;
MCNUM mccsg18_mleft;
MCNUM mccsg18_mright;
MCNUM mccsg18_mtop;
MCNUM mccsg18_mbottom;
MCNUM mccsg18_nhslit;
MCNUM mccsg18_G;
MCNUM mccsg18_aleft;
MCNUM mccsg18_aright;
MCNUM mccsg18_atop;
MCNUM mccsg18_abottom;
MCNUM mccsg18_wavy;
MCNUM mccsg18_wavy_z;
MCNUM mccsg18_wavy_tb;
MCNUM mccsg18_wavy_lr;
MCNUM mccsg18_chamfers;
MCNUM mccsg18_chamfers_z;
MCNUM mccsg18_chamfers_lr;
MCNUM mccsg18_chamfers_tb;
MCNUM mccsg18_nelements;
MCNUM mccsg18_nu;
MCNUM mccsg18_phase;
char mccsg18_reflect[16384];

/* Setting parameters for component 'sg19' [56]. */
MCNUM mccsg19_w1;
MCNUM mccsg19_h1;
MCNUM mccsg19_w2;
MCNUM mccsg19_h2;
MCNUM mccsg19_l;
MCNUM mccsg19_R0;
MCNUM mccsg19_Qc;
MCNUM mccsg19_alpha;
MCNUM mccsg19_m;
MCNUM mccsg19_W;
MCNUM mccsg19_nslit;
MCNUM mccsg19_d;
MCNUM mccsg19_mleft;
MCNUM mccsg19_mright;
MCNUM mccsg19_mtop;
MCNUM mccsg19_mbottom;
MCNUM mccsg19_nhslit;
MCNUM mccsg19_G;
MCNUM mccsg19_aleft;
MCNUM mccsg19_aright;
MCNUM mccsg19_atop;
MCNUM mccsg19_abottom;
MCNUM mccsg19_wavy;
MCNUM mccsg19_wavy_z;
MCNUM mccsg19_wavy_tb;
MCNUM mccsg19_wavy_lr;
MCNUM mccsg19_chamfers;
MCNUM mccsg19_chamfers_z;
MCNUM mccsg19_chamfers_lr;
MCNUM mccsg19_chamfers_tb;
MCNUM mccsg19_nelements;
MCNUM mccsg19_nu;
MCNUM mccsg19_phase;
char mccsg19_reflect[16384];

/* Setting parameters for component 'sg20' [57]. */
MCNUM mccsg20_w1;
MCNUM mccsg20_h1;
MCNUM mccsg20_w2;
MCNUM mccsg20_h2;
MCNUM mccsg20_l;
MCNUM mccsg20_R0;
MCNUM mccsg20_Qc;
MCNUM mccsg20_alpha;
MCNUM mccsg20_m;
MCNUM mccsg20_W;
MCNUM mccsg20_nslit;
MCNUM mccsg20_d;
MCNUM mccsg20_mleft;
MCNUM mccsg20_mright;
MCNUM mccsg20_mtop;
MCNUM mccsg20_mbottom;
MCNUM mccsg20_nhslit;
MCNUM mccsg20_G;
MCNUM mccsg20_aleft;
MCNUM mccsg20_aright;
MCNUM mccsg20_atop;
MCNUM mccsg20_abottom;
MCNUM mccsg20_wavy;
MCNUM mccsg20_wavy_z;
MCNUM mccsg20_wavy_tb;
MCNUM mccsg20_wavy_lr;
MCNUM mccsg20_chamfers;
MCNUM mccsg20_chamfers_z;
MCNUM mccsg20_chamfers_lr;
MCNUM mccsg20_chamfers_tb;
MCNUM mccsg20_nelements;
MCNUM mccsg20_nu;
MCNUM mccsg20_phase;
char mccsg20_reflect[16384];

/* Setting parameters for component 'sg21' [58]. */
MCNUM mccsg21_w1;
MCNUM mccsg21_h1;
MCNUM mccsg21_w2;
MCNUM mccsg21_h2;
MCNUM mccsg21_l;
MCNUM mccsg21_R0;
MCNUM mccsg21_Qc;
MCNUM mccsg21_alpha;
MCNUM mccsg21_m;
MCNUM mccsg21_W;
MCNUM mccsg21_nslit;
MCNUM mccsg21_d;
MCNUM mccsg21_mleft;
MCNUM mccsg21_mright;
MCNUM mccsg21_mtop;
MCNUM mccsg21_mbottom;
MCNUM mccsg21_nhslit;
MCNUM mccsg21_G;
MCNUM mccsg21_aleft;
MCNUM mccsg21_aright;
MCNUM mccsg21_atop;
MCNUM mccsg21_abottom;
MCNUM mccsg21_wavy;
MCNUM mccsg21_wavy_z;
MCNUM mccsg21_wavy_tb;
MCNUM mccsg21_wavy_lr;
MCNUM mccsg21_chamfers;
MCNUM mccsg21_chamfers_z;
MCNUM mccsg21_chamfers_lr;
MCNUM mccsg21_chamfers_tb;
MCNUM mccsg21_nelements;
MCNUM mccsg21_nu;
MCNUM mccsg21_phase;
char mccsg21_reflect[16384];

/* Setting parameters for component 'sg22' [59]. */
MCNUM mccsg22_w1;
MCNUM mccsg22_h1;
MCNUM mccsg22_w2;
MCNUM mccsg22_h2;
MCNUM mccsg22_l;
MCNUM mccsg22_R0;
MCNUM mccsg22_Qc;
MCNUM mccsg22_alpha;
MCNUM mccsg22_m;
MCNUM mccsg22_W;
MCNUM mccsg22_nslit;
MCNUM mccsg22_d;
MCNUM mccsg22_mleft;
MCNUM mccsg22_mright;
MCNUM mccsg22_mtop;
MCNUM mccsg22_mbottom;
MCNUM mccsg22_nhslit;
MCNUM mccsg22_G;
MCNUM mccsg22_aleft;
MCNUM mccsg22_aright;
MCNUM mccsg22_atop;
MCNUM mccsg22_abottom;
MCNUM mccsg22_wavy;
MCNUM mccsg22_wavy_z;
MCNUM mccsg22_wavy_tb;
MCNUM mccsg22_wavy_lr;
MCNUM mccsg22_chamfers;
MCNUM mccsg22_chamfers_z;
MCNUM mccsg22_chamfers_lr;
MCNUM mccsg22_chamfers_tb;
MCNUM mccsg22_nelements;
MCNUM mccsg22_nu;
MCNUM mccsg22_phase;
char mccsg22_reflect[16384];

/* Setting parameters for component 'AlWindow6' [60]. */
MCNUM mccAlWindow6_thickness;

/* Definition parameters for component 'PSD_IN6' [61]. */
#define mccPSD_IN6_user1 FLT_MAX
#define mccPSD_IN6_user2 FLT_MAX
#define mccPSD_IN6_user3 FLT_MAX
/* Setting parameters for component 'PSD_IN6' [61]. */
MCNUM mccPSD_IN6_xwidth;
MCNUM mccPSD_IN6_yheight;
MCNUM mccPSD_IN6_zdepth;
MCNUM mccPSD_IN6_xmin;
MCNUM mccPSD_IN6_xmax;
MCNUM mccPSD_IN6_ymin;
MCNUM mccPSD_IN6_ymax;
MCNUM mccPSD_IN6_zmin;
MCNUM mccPSD_IN6_zmax;
MCNUM mccPSD_IN6_bins;
MCNUM mccPSD_IN6_min;
MCNUM mccPSD_IN6_max;
MCNUM mccPSD_IN6_restore_neutron;
MCNUM mccPSD_IN6_radius;
char mccPSD_IN6_options[16384];
char mccPSD_IN6_filename[16384];
char mccPSD_IN6_geometry[16384];
char mccPSD_IN6_username1[16384];
char mccPSD_IN6_username2[16384];
char mccPSD_IN6_username3[16384];
int mccPSD_IN6_nowritefile;

/* Setting parameters for component 'AlWindow7' [62]. */
MCNUM mccAlWindow7_thickness;

/* Setting parameters for component 'sg23' [64]. */
MCNUM mccsg23_w1;
MCNUM mccsg23_h1;
MCNUM mccsg23_w2;
MCNUM mccsg23_h2;
MCNUM mccsg23_l;
MCNUM mccsg23_R0;
MCNUM mccsg23_Qc;
MCNUM mccsg23_alpha;
MCNUM mccsg23_m;
MCNUM mccsg23_W;
MCNUM mccsg23_nslit;
MCNUM mccsg23_d;
MCNUM mccsg23_mleft;
MCNUM mccsg23_mright;
MCNUM mccsg23_mtop;
MCNUM mccsg23_mbottom;
MCNUM mccsg23_nhslit;
MCNUM mccsg23_G;
MCNUM mccsg23_aleft;
MCNUM mccsg23_aright;
MCNUM mccsg23_atop;
MCNUM mccsg23_abottom;
MCNUM mccsg23_wavy;
MCNUM mccsg23_wavy_z;
MCNUM mccsg23_wavy_tb;
MCNUM mccsg23_wavy_lr;
MCNUM mccsg23_chamfers;
MCNUM mccsg23_chamfers_z;
MCNUM mccsg23_chamfers_lr;
MCNUM mccsg23_chamfers_tb;
MCNUM mccsg23_nelements;
MCNUM mccsg23_nu;
MCNUM mccsg23_phase;
char mccsg23_reflect[16384];

/* Setting parameters for component 'sg24' [65]. */
MCNUM mccsg24_w1;
MCNUM mccsg24_h1;
MCNUM mccsg24_w2;
MCNUM mccsg24_h2;
MCNUM mccsg24_l;
MCNUM mccsg24_R0;
MCNUM mccsg24_Qc;
MCNUM mccsg24_alpha;
MCNUM mccsg24_m;
MCNUM mccsg24_W;
MCNUM mccsg24_nslit;
MCNUM mccsg24_d;
MCNUM mccsg24_mleft;
MCNUM mccsg24_mright;
MCNUM mccsg24_mtop;
MCNUM mccsg24_mbottom;
MCNUM mccsg24_nhslit;
MCNUM mccsg24_G;
MCNUM mccsg24_aleft;
MCNUM mccsg24_aright;
MCNUM mccsg24_atop;
MCNUM mccsg24_abottom;
MCNUM mccsg24_wavy;
MCNUM mccsg24_wavy_z;
MCNUM mccsg24_wavy_tb;
MCNUM mccsg24_wavy_lr;
MCNUM mccsg24_chamfers;
MCNUM mccsg24_chamfers_z;
MCNUM mccsg24_chamfers_lr;
MCNUM mccsg24_chamfers_tb;
MCNUM mccsg24_nelements;
MCNUM mccsg24_nu;
MCNUM mccsg24_phase;
char mccsg24_reflect[16384];

/* Setting parameters for component 'sg25' [66]. */
MCNUM mccsg25_w1;
MCNUM mccsg25_h1;
MCNUM mccsg25_w2;
MCNUM mccsg25_h2;
MCNUM mccsg25_l;
MCNUM mccsg25_R0;
MCNUM mccsg25_Qc;
MCNUM mccsg25_alpha;
MCNUM mccsg25_m;
MCNUM mccsg25_W;
MCNUM mccsg25_nslit;
MCNUM mccsg25_d;
MCNUM mccsg25_mleft;
MCNUM mccsg25_mright;
MCNUM mccsg25_mtop;
MCNUM mccsg25_mbottom;
MCNUM mccsg25_nhslit;
MCNUM mccsg25_G;
MCNUM mccsg25_aleft;
MCNUM mccsg25_aright;
MCNUM mccsg25_atop;
MCNUM mccsg25_abottom;
MCNUM mccsg25_wavy;
MCNUM mccsg25_wavy_z;
MCNUM mccsg25_wavy_tb;
MCNUM mccsg25_wavy_lr;
MCNUM mccsg25_chamfers;
MCNUM mccsg25_chamfers_z;
MCNUM mccsg25_chamfers_lr;
MCNUM mccsg25_chamfers_tb;
MCNUM mccsg25_nelements;
MCNUM mccsg25_nu;
MCNUM mccsg25_phase;
char mccsg25_reflect[16384];

/* Setting parameters for component 'sg26' [67]. */
MCNUM mccsg26_w1;
MCNUM mccsg26_h1;
MCNUM mccsg26_w2;
MCNUM mccsg26_h2;
MCNUM mccsg26_l;
MCNUM mccsg26_R0;
MCNUM mccsg26_Qc;
MCNUM mccsg26_alpha;
MCNUM mccsg26_m;
MCNUM mccsg26_W;
MCNUM mccsg26_nslit;
MCNUM mccsg26_d;
MCNUM mccsg26_mleft;
MCNUM mccsg26_mright;
MCNUM mccsg26_mtop;
MCNUM mccsg26_mbottom;
MCNUM mccsg26_nhslit;
MCNUM mccsg26_G;
MCNUM mccsg26_aleft;
MCNUM mccsg26_aright;
MCNUM mccsg26_atop;
MCNUM mccsg26_abottom;
MCNUM mccsg26_wavy;
MCNUM mccsg26_wavy_z;
MCNUM mccsg26_wavy_tb;
MCNUM mccsg26_wavy_lr;
MCNUM mccsg26_chamfers;
MCNUM mccsg26_chamfers_z;
MCNUM mccsg26_chamfers_lr;
MCNUM mccsg26_chamfers_tb;
MCNUM mccsg26_nelements;
MCNUM mccsg26_nu;
MCNUM mccsg26_phase;
char mccsg26_reflect[16384];

/* Setting parameters for component 'sg27' [68]. */
MCNUM mccsg27_w1;
MCNUM mccsg27_h1;
MCNUM mccsg27_w2;
MCNUM mccsg27_h2;
MCNUM mccsg27_l;
MCNUM mccsg27_R0;
MCNUM mccsg27_Qc;
MCNUM mccsg27_alpha;
MCNUM mccsg27_m;
MCNUM mccsg27_W;
MCNUM mccsg27_nslit;
MCNUM mccsg27_d;
MCNUM mccsg27_mleft;
MCNUM mccsg27_mright;
MCNUM mccsg27_mtop;
MCNUM mccsg27_mbottom;
MCNUM mccsg27_nhslit;
MCNUM mccsg27_G;
MCNUM mccsg27_aleft;
MCNUM mccsg27_aright;
MCNUM mccsg27_atop;
MCNUM mccsg27_abottom;
MCNUM mccsg27_wavy;
MCNUM mccsg27_wavy_z;
MCNUM mccsg27_wavy_tb;
MCNUM mccsg27_wavy_lr;
MCNUM mccsg27_chamfers;
MCNUM mccsg27_chamfers_z;
MCNUM mccsg27_chamfers_lr;
MCNUM mccsg27_chamfers_tb;
MCNUM mccsg27_nelements;
MCNUM mccsg27_nu;
MCNUM mccsg27_phase;
char mccsg27_reflect[16384];

/* Setting parameters for component 'AlWindow8' [69]. */
MCNUM mccAlWindow8_thickness;

/* Definition parameters for component 'PSD_D7' [70]. */
#define mccPSD_D7_user1 FLT_MAX
#define mccPSD_D7_user2 FLT_MAX
#define mccPSD_D7_user3 FLT_MAX
/* Setting parameters for component 'PSD_D7' [70]. */
MCNUM mccPSD_D7_xwidth;
MCNUM mccPSD_D7_yheight;
MCNUM mccPSD_D7_zdepth;
MCNUM mccPSD_D7_xmin;
MCNUM mccPSD_D7_xmax;
MCNUM mccPSD_D7_ymin;
MCNUM mccPSD_D7_ymax;
MCNUM mccPSD_D7_zmin;
MCNUM mccPSD_D7_zmax;
MCNUM mccPSD_D7_bins;
MCNUM mccPSD_D7_min;
MCNUM mccPSD_D7_max;
MCNUM mccPSD_D7_restore_neutron;
MCNUM mccPSD_D7_radius;
char mccPSD_D7_options[16384];
char mccPSD_D7_filename[16384];
char mccPSD_D7_geometry[16384];
char mccPSD_D7_username1[16384];
char mccPSD_D7_username2[16384];
char mccPSD_D7_username3[16384];
int mccPSD_D7_nowritefile;

/* Setting parameters for component 'AlWindow9' [71]. */
MCNUM mccAlWindow9_thickness;

/* Setting parameters for component 'sg28' [73]. */
MCNUM mccsg28_w1;
MCNUM mccsg28_h1;
MCNUM mccsg28_w2;
MCNUM mccsg28_h2;
MCNUM mccsg28_l;
MCNUM mccsg28_R0;
MCNUM mccsg28_Qc;
MCNUM mccsg28_alpha;
MCNUM mccsg28_m;
MCNUM mccsg28_W;
MCNUM mccsg28_nslit;
MCNUM mccsg28_d;
MCNUM mccsg28_mleft;
MCNUM mccsg28_mright;
MCNUM mccsg28_mtop;
MCNUM mccsg28_mbottom;
MCNUM mccsg28_nhslit;
MCNUM mccsg28_G;
MCNUM mccsg28_aleft;
MCNUM mccsg28_aright;
MCNUM mccsg28_atop;
MCNUM mccsg28_abottom;
MCNUM mccsg28_wavy;
MCNUM mccsg28_wavy_z;
MCNUM mccsg28_wavy_tb;
MCNUM mccsg28_wavy_lr;
MCNUM mccsg28_chamfers;
MCNUM mccsg28_chamfers_z;
MCNUM mccsg28_chamfers_lr;
MCNUM mccsg28_chamfers_tb;
MCNUM mccsg28_nelements;
MCNUM mccsg28_nu;
MCNUM mccsg28_phase;
char mccsg28_reflect[16384];

/* Setting parameters for component 'sg29' [74]. */
MCNUM mccsg29_w1;
MCNUM mccsg29_h1;
MCNUM mccsg29_w2;
MCNUM mccsg29_h2;
MCNUM mccsg29_l;
MCNUM mccsg29_R0;
MCNUM mccsg29_Qc;
MCNUM mccsg29_alpha;
MCNUM mccsg29_m;
MCNUM mccsg29_W;
MCNUM mccsg29_nslit;
MCNUM mccsg29_d;
MCNUM mccsg29_mleft;
MCNUM mccsg29_mright;
MCNUM mccsg29_mtop;
MCNUM mccsg29_mbottom;
MCNUM mccsg29_nhslit;
MCNUM mccsg29_G;
MCNUM mccsg29_aleft;
MCNUM mccsg29_aright;
MCNUM mccsg29_atop;
MCNUM mccsg29_abottom;
MCNUM mccsg29_wavy;
MCNUM mccsg29_wavy_z;
MCNUM mccsg29_wavy_tb;
MCNUM mccsg29_wavy_lr;
MCNUM mccsg29_chamfers;
MCNUM mccsg29_chamfers_z;
MCNUM mccsg29_chamfers_lr;
MCNUM mccsg29_chamfers_tb;
MCNUM mccsg29_nelements;
MCNUM mccsg29_nu;
MCNUM mccsg29_phase;
char mccsg29_reflect[16384];

/* Setting parameters for component 'AlWindow10' [75]. */
MCNUM mccAlWindow10_thickness;

/* Definition parameters for component 'Mon_D11_In' [76]. */
#define mccMon_D11_In_user1 FLT_MAX
#define mccMon_D11_In_user2 FLT_MAX
#define mccMon_D11_In_user3 FLT_MAX
/* Setting parameters for component 'Mon_D11_In' [76]. */
MCNUM mccMon_D11_In_xwidth;
MCNUM mccMon_D11_In_yheight;
MCNUM mccMon_D11_In_zdepth;
MCNUM mccMon_D11_In_xmin;
MCNUM mccMon_D11_In_xmax;
MCNUM mccMon_D11_In_ymin;
MCNUM mccMon_D11_In_ymax;
MCNUM mccMon_D11_In_zmin;
MCNUM mccMon_D11_In_zmax;
MCNUM mccMon_D11_In_bins;
MCNUM mccMon_D11_In_min;
MCNUM mccMon_D11_In_max;
MCNUM mccMon_D11_In_restore_neutron;
MCNUM mccMon_D11_In_radius;
char mccMon_D11_In_options[16384];
char mccMon_D11_In_filename[16384];
char mccMon_D11_In_geometry[16384];
char mccMon_D11_In_username1[16384];
char mccMon_D11_In_username2[16384];
char mccMon_D11_In_username3[16384];
int mccMon_D11_In_nowritefile;

/* Setting parameters for component 'Dolores' [77]. */
MCNUM mccDolores_xwidth;
MCNUM mccDolores_yheight;
MCNUM mccDolores_zdepth;
MCNUM mccDolores_radius;
MCNUM mccDolores_alpha;
MCNUM mccDolores_length;
MCNUM mccDolores_d;
MCNUM mccDolores_nu;
MCNUM mccDolores_nslit;

/* Setting parameters for component 'AlWindow11' [78]. */
MCNUM mccAlWindow11_thickness;

/* Setting parameters for component 'sg30' [79]. */
MCNUM mccsg30_w1;
MCNUM mccsg30_h1;
MCNUM mccsg30_w2;
MCNUM mccsg30_h2;
MCNUM mccsg30_l;
MCNUM mccsg30_R0;
MCNUM mccsg30_Qc;
MCNUM mccsg30_alpha;
MCNUM mccsg30_m;
MCNUM mccsg30_W;
MCNUM mccsg30_nslit;
MCNUM mccsg30_d;
MCNUM mccsg30_mleft;
MCNUM mccsg30_mright;
MCNUM mccsg30_mtop;
MCNUM mccsg30_mbottom;
MCNUM mccsg30_nhslit;
MCNUM mccsg30_G;
MCNUM mccsg30_aleft;
MCNUM mccsg30_aright;
MCNUM mccsg30_atop;
MCNUM mccsg30_abottom;
MCNUM mccsg30_wavy;
MCNUM mccsg30_wavy_z;
MCNUM mccsg30_wavy_tb;
MCNUM mccsg30_wavy_lr;
MCNUM mccsg30_chamfers;
MCNUM mccsg30_chamfers_z;
MCNUM mccsg30_chamfers_lr;
MCNUM mccsg30_chamfers_tb;
MCNUM mccsg30_nelements;
MCNUM mccsg30_nu;
MCNUM mccsg30_phase;
char mccsg30_reflect[16384];

/* Setting parameters for component 'AlWindow12' [80]. */
MCNUM mccAlWindow12_thickness;

/* Definition parameters for component 'Mon_D11_Out' [81]. */
#define mccMon_D11_Out_user1 FLT_MAX
#define mccMon_D11_Out_user2 FLT_MAX
#define mccMon_D11_Out_user3 FLT_MAX
/* Setting parameters for component 'Mon_D11_Out' [81]. */
MCNUM mccMon_D11_Out_xwidth;
MCNUM mccMon_D11_Out_yheight;
MCNUM mccMon_D11_Out_zdepth;
MCNUM mccMon_D11_Out_xmin;
MCNUM mccMon_D11_Out_xmax;
MCNUM mccMon_D11_Out_ymin;
MCNUM mccMon_D11_Out_ymax;
MCNUM mccMon_D11_Out_zmin;
MCNUM mccMon_D11_Out_zmax;
MCNUM mccMon_D11_Out_bins;
MCNUM mccMon_D11_Out_min;
MCNUM mccMon_D11_Out_max;
MCNUM mccMon_D11_Out_restore_neutron;
MCNUM mccMon_D11_Out_radius;
char mccMon_D11_Out_options[16384];
char mccMon_D11_Out_filename[16384];
char mccMon_D11_Out_geometry[16384];
char mccMon_D11_Out_username1[16384];
char mccMon_D11_Out_username2[16384];
char mccMon_D11_Out_username3[16384];
int mccMon_D11_Out_nowritefile;

/* Setting parameters for component 'AlWindow13' [82]. */
MCNUM mccAlWindow13_thickness;

/* Setting parameters for component 'mg0' [84]. */
MCNUM mccmg0_w1;
MCNUM mccmg0_h1;
MCNUM mccmg0_w2;
MCNUM mccmg0_h2;
MCNUM mccmg0_l;
MCNUM mccmg0_R0;
MCNUM mccmg0_Qc;
MCNUM mccmg0_alpha;
MCNUM mccmg0_m;
MCNUM mccmg0_W;
MCNUM mccmg0_nslit;
MCNUM mccmg0_d;
MCNUM mccmg0_mleft;
MCNUM mccmg0_mright;
MCNUM mccmg0_mtop;
MCNUM mccmg0_mbottom;
MCNUM mccmg0_nhslit;
MCNUM mccmg0_G;
MCNUM mccmg0_aleft;
MCNUM mccmg0_aright;
MCNUM mccmg0_atop;
MCNUM mccmg0_abottom;
MCNUM mccmg0_wavy;
MCNUM mccmg0_wavy_z;
MCNUM mccmg0_wavy_tb;
MCNUM mccmg0_wavy_lr;
MCNUM mccmg0_chamfers;
MCNUM mccmg0_chamfers_z;
MCNUM mccmg0_chamfers_lr;
MCNUM mccmg0_chamfers_tb;
MCNUM mccmg0_nelements;
MCNUM mccmg0_nu;
MCNUM mccmg0_phase;
char mccmg0_reflect[16384];

/* Setting parameters for component 'mg1' [85]. */
MCNUM mccmg1_w1;
MCNUM mccmg1_h1;
MCNUM mccmg1_w2;
MCNUM mccmg1_h2;
MCNUM mccmg1_l;
MCNUM mccmg1_R0;
MCNUM mccmg1_Qc;
MCNUM mccmg1_alpha;
MCNUM mccmg1_m;
MCNUM mccmg1_W;
MCNUM mccmg1_nslit;
MCNUM mccmg1_d;
MCNUM mccmg1_mleft;
MCNUM mccmg1_mright;
MCNUM mccmg1_mtop;
MCNUM mccmg1_mbottom;
MCNUM mccmg1_nhslit;
MCNUM mccmg1_G;
MCNUM mccmg1_aleft;
MCNUM mccmg1_aright;
MCNUM mccmg1_atop;
MCNUM mccmg1_abottom;
MCNUM mccmg1_wavy;
MCNUM mccmg1_wavy_z;
MCNUM mccmg1_wavy_tb;
MCNUM mccmg1_wavy_lr;
MCNUM mccmg1_chamfers;
MCNUM mccmg1_chamfers_z;
MCNUM mccmg1_chamfers_lr;
MCNUM mccmg1_chamfers_tb;
MCNUM mccmg1_nelements;
MCNUM mccmg1_nu;
MCNUM mccmg1_phase;
char mccmg1_reflect[16384];

/* Setting parameters for component 'mg2' [86]. */
MCNUM mccmg2_w1;
MCNUM mccmg2_h1;
MCNUM mccmg2_w2;
MCNUM mccmg2_h2;
MCNUM mccmg2_l;
MCNUM mccmg2_R0;
MCNUM mccmg2_Qc;
MCNUM mccmg2_alpha;
MCNUM mccmg2_m;
MCNUM mccmg2_W;
MCNUM mccmg2_nslit;
MCNUM mccmg2_d;
MCNUM mccmg2_mleft;
MCNUM mccmg2_mright;
MCNUM mccmg2_mtop;
MCNUM mccmg2_mbottom;
MCNUM mccmg2_nhslit;
MCNUM mccmg2_G;
MCNUM mccmg2_aleft;
MCNUM mccmg2_aright;
MCNUM mccmg2_atop;
MCNUM mccmg2_abottom;
MCNUM mccmg2_wavy;
MCNUM mccmg2_wavy_z;
MCNUM mccmg2_wavy_tb;
MCNUM mccmg2_wavy_lr;
MCNUM mccmg2_chamfers;
MCNUM mccmg2_chamfers_z;
MCNUM mccmg2_chamfers_lr;
MCNUM mccmg2_chamfers_tb;
MCNUM mccmg2_nelements;
MCNUM mccmg2_nu;
MCNUM mccmg2_phase;
char mccmg2_reflect[16384];

/* Setting parameters for component 'mg3' [87]. */
MCNUM mccmg3_w1;
MCNUM mccmg3_h1;
MCNUM mccmg3_w2;
MCNUM mccmg3_h2;
MCNUM mccmg3_l;
MCNUM mccmg3_R0;
MCNUM mccmg3_Qc;
MCNUM mccmg3_alpha;
MCNUM mccmg3_m;
MCNUM mccmg3_W;
MCNUM mccmg3_nslit;
MCNUM mccmg3_d;
MCNUM mccmg3_mleft;
MCNUM mccmg3_mright;
MCNUM mccmg3_mtop;
MCNUM mccmg3_mbottom;
MCNUM mccmg3_nhslit;
MCNUM mccmg3_G;
MCNUM mccmg3_aleft;
MCNUM mccmg3_aright;
MCNUM mccmg3_atop;
MCNUM mccmg3_abottom;
MCNUM mccmg3_wavy;
MCNUM mccmg3_wavy_z;
MCNUM mccmg3_wavy_tb;
MCNUM mccmg3_wavy_lr;
MCNUM mccmg3_chamfers;
MCNUM mccmg3_chamfers_z;
MCNUM mccmg3_chamfers_lr;
MCNUM mccmg3_chamfers_tb;
MCNUM mccmg3_nelements;
MCNUM mccmg3_nu;
MCNUM mccmg3_phase;
char mccmg3_reflect[16384];

/* Setting parameters for component 'mg4' [88]. */
MCNUM mccmg4_w1;
MCNUM mccmg4_h1;
MCNUM mccmg4_w2;
MCNUM mccmg4_h2;
MCNUM mccmg4_l;
MCNUM mccmg4_R0;
MCNUM mccmg4_Qc;
MCNUM mccmg4_alpha;
MCNUM mccmg4_m;
MCNUM mccmg4_W;
MCNUM mccmg4_nslit;
MCNUM mccmg4_d;
MCNUM mccmg4_mleft;
MCNUM mccmg4_mright;
MCNUM mccmg4_mtop;
MCNUM mccmg4_mbottom;
MCNUM mccmg4_nhslit;
MCNUM mccmg4_G;
MCNUM mccmg4_aleft;
MCNUM mccmg4_aright;
MCNUM mccmg4_atop;
MCNUM mccmg4_abottom;
MCNUM mccmg4_wavy;
MCNUM mccmg4_wavy_z;
MCNUM mccmg4_wavy_tb;
MCNUM mccmg4_wavy_lr;
MCNUM mccmg4_chamfers;
MCNUM mccmg4_chamfers_z;
MCNUM mccmg4_chamfers_lr;
MCNUM mccmg4_chamfers_tb;
MCNUM mccmg4_nelements;
MCNUM mccmg4_nu;
MCNUM mccmg4_phase;
char mccmg4_reflect[16384];

/* Setting parameters for component 'mg5' [89]. */
MCNUM mccmg5_w1;
MCNUM mccmg5_h1;
MCNUM mccmg5_w2;
MCNUM mccmg5_h2;
MCNUM mccmg5_l;
MCNUM mccmg5_R0;
MCNUM mccmg5_Qc;
MCNUM mccmg5_alpha;
MCNUM mccmg5_m;
MCNUM mccmg5_W;
MCNUM mccmg5_nslit;
MCNUM mccmg5_d;
MCNUM mccmg5_mleft;
MCNUM mccmg5_mright;
MCNUM mccmg5_mtop;
MCNUM mccmg5_mbottom;
MCNUM mccmg5_nhslit;
MCNUM mccmg5_G;
MCNUM mccmg5_aleft;
MCNUM mccmg5_aright;
MCNUM mccmg5_atop;
MCNUM mccmg5_abottom;
MCNUM mccmg5_wavy;
MCNUM mccmg5_wavy_z;
MCNUM mccmg5_wavy_tb;
MCNUM mccmg5_wavy_lr;
MCNUM mccmg5_chamfers;
MCNUM mccmg5_chamfers_z;
MCNUM mccmg5_chamfers_lr;
MCNUM mccmg5_chamfers_tb;
MCNUM mccmg5_nelements;
MCNUM mccmg5_nu;
MCNUM mccmg5_phase;
char mccmg5_reflect[16384];

/* Setting parameters for component 'mg6' [90]. */
MCNUM mccmg6_w1;
MCNUM mccmg6_h1;
MCNUM mccmg6_w2;
MCNUM mccmg6_h2;
MCNUM mccmg6_l;
MCNUM mccmg6_R0;
MCNUM mccmg6_Qc;
MCNUM mccmg6_alpha;
MCNUM mccmg6_m;
MCNUM mccmg6_W;
MCNUM mccmg6_nslit;
MCNUM mccmg6_d;
MCNUM mccmg6_mleft;
MCNUM mccmg6_mright;
MCNUM mccmg6_mtop;
MCNUM mccmg6_mbottom;
MCNUM mccmg6_nhslit;
MCNUM mccmg6_G;
MCNUM mccmg6_aleft;
MCNUM mccmg6_aright;
MCNUM mccmg6_atop;
MCNUM mccmg6_abottom;
MCNUM mccmg6_wavy;
MCNUM mccmg6_wavy_z;
MCNUM mccmg6_wavy_tb;
MCNUM mccmg6_wavy_lr;
MCNUM mccmg6_chamfers;
MCNUM mccmg6_chamfers_z;
MCNUM mccmg6_chamfers_lr;
MCNUM mccmg6_chamfers_tb;
MCNUM mccmg6_nelements;
MCNUM mccmg6_nu;
MCNUM mccmg6_phase;
char mccmg6_reflect[16384];

/* Setting parameters for component 'mg7' [91]. */
MCNUM mccmg7_w1;
MCNUM mccmg7_h1;
MCNUM mccmg7_w2;
MCNUM mccmg7_h2;
MCNUM mccmg7_l;
MCNUM mccmg7_R0;
MCNUM mccmg7_Qc;
MCNUM mccmg7_alpha;
MCNUM mccmg7_m;
MCNUM mccmg7_W;
MCNUM mccmg7_nslit;
MCNUM mccmg7_d;
MCNUM mccmg7_mleft;
MCNUM mccmg7_mright;
MCNUM mccmg7_mtop;
MCNUM mccmg7_mbottom;
MCNUM mccmg7_nhslit;
MCNUM mccmg7_G;
MCNUM mccmg7_aleft;
MCNUM mccmg7_aright;
MCNUM mccmg7_atop;
MCNUM mccmg7_abottom;
MCNUM mccmg7_wavy;
MCNUM mccmg7_wavy_z;
MCNUM mccmg7_wavy_tb;
MCNUM mccmg7_wavy_lr;
MCNUM mccmg7_chamfers;
MCNUM mccmg7_chamfers_z;
MCNUM mccmg7_chamfers_lr;
MCNUM mccmg7_chamfers_tb;
MCNUM mccmg7_nelements;
MCNUM mccmg7_nu;
MCNUM mccmg7_phase;
char mccmg7_reflect[16384];

/* Setting parameters for component 'mg8' [92]. */
MCNUM mccmg8_w1;
MCNUM mccmg8_h1;
MCNUM mccmg8_w2;
MCNUM mccmg8_h2;
MCNUM mccmg8_l;
MCNUM mccmg8_R0;
MCNUM mccmg8_Qc;
MCNUM mccmg8_alpha;
MCNUM mccmg8_m;
MCNUM mccmg8_W;
MCNUM mccmg8_nslit;
MCNUM mccmg8_d;
MCNUM mccmg8_mleft;
MCNUM mccmg8_mright;
MCNUM mccmg8_mtop;
MCNUM mccmg8_mbottom;
MCNUM mccmg8_nhslit;
MCNUM mccmg8_G;
MCNUM mccmg8_aleft;
MCNUM mccmg8_aright;
MCNUM mccmg8_atop;
MCNUM mccmg8_abottom;
MCNUM mccmg8_wavy;
MCNUM mccmg8_wavy_z;
MCNUM mccmg8_wavy_tb;
MCNUM mccmg8_wavy_lr;
MCNUM mccmg8_chamfers;
MCNUM mccmg8_chamfers_z;
MCNUM mccmg8_chamfers_lr;
MCNUM mccmg8_chamfers_tb;
MCNUM mccmg8_nelements;
MCNUM mccmg8_nu;
MCNUM mccmg8_phase;
char mccmg8_reflect[16384];

/* Setting parameters for component 'mg9' [93]. */
MCNUM mccmg9_w1;
MCNUM mccmg9_h1;
MCNUM mccmg9_w2;
MCNUM mccmg9_h2;
MCNUM mccmg9_l;
MCNUM mccmg9_R0;
MCNUM mccmg9_Qc;
MCNUM mccmg9_alpha;
MCNUM mccmg9_m;
MCNUM mccmg9_W;
MCNUM mccmg9_nslit;
MCNUM mccmg9_d;
MCNUM mccmg9_mleft;
MCNUM mccmg9_mright;
MCNUM mccmg9_mtop;
MCNUM mccmg9_mbottom;
MCNUM mccmg9_nhslit;
MCNUM mccmg9_G;
MCNUM mccmg9_aleft;
MCNUM mccmg9_aright;
MCNUM mccmg9_atop;
MCNUM mccmg9_abottom;
MCNUM mccmg9_wavy;
MCNUM mccmg9_wavy_z;
MCNUM mccmg9_wavy_tb;
MCNUM mccmg9_wavy_lr;
MCNUM mccmg9_chamfers;
MCNUM mccmg9_chamfers_z;
MCNUM mccmg9_chamfers_lr;
MCNUM mccmg9_chamfers_tb;
MCNUM mccmg9_nelements;
MCNUM mccmg9_nu;
MCNUM mccmg9_phase;
char mccmg9_reflect[16384];

/* Setting parameters for component 'mg10' [94]. */
MCNUM mccmg10_w1;
MCNUM mccmg10_h1;
MCNUM mccmg10_w2;
MCNUM mccmg10_h2;
MCNUM mccmg10_l;
MCNUM mccmg10_R0;
MCNUM mccmg10_Qc;
MCNUM mccmg10_alpha;
MCNUM mccmg10_m;
MCNUM mccmg10_W;
MCNUM mccmg10_nslit;
MCNUM mccmg10_d;
MCNUM mccmg10_mleft;
MCNUM mccmg10_mright;
MCNUM mccmg10_mtop;
MCNUM mccmg10_mbottom;
MCNUM mccmg10_nhslit;
MCNUM mccmg10_G;
MCNUM mccmg10_aleft;
MCNUM mccmg10_aright;
MCNUM mccmg10_atop;
MCNUM mccmg10_abottom;
MCNUM mccmg10_wavy;
MCNUM mccmg10_wavy_z;
MCNUM mccmg10_wavy_tb;
MCNUM mccmg10_wavy_lr;
MCNUM mccmg10_chamfers;
MCNUM mccmg10_chamfers_z;
MCNUM mccmg10_chamfers_lr;
MCNUM mccmg10_chamfers_tb;
MCNUM mccmg10_nelements;
MCNUM mccmg10_nu;
MCNUM mccmg10_phase;
char mccmg10_reflect[16384];

/* Setting parameters for component 'mg11' [95]. */
MCNUM mccmg11_w1;
MCNUM mccmg11_h1;
MCNUM mccmg11_w2;
MCNUM mccmg11_h2;
MCNUM mccmg11_l;
MCNUM mccmg11_R0;
MCNUM mccmg11_Qc;
MCNUM mccmg11_alpha;
MCNUM mccmg11_m;
MCNUM mccmg11_W;
MCNUM mccmg11_nslit;
MCNUM mccmg11_d;
MCNUM mccmg11_mleft;
MCNUM mccmg11_mright;
MCNUM mccmg11_mtop;
MCNUM mccmg11_mbottom;
MCNUM mccmg11_nhslit;
MCNUM mccmg11_G;
MCNUM mccmg11_aleft;
MCNUM mccmg11_aright;
MCNUM mccmg11_atop;
MCNUM mccmg11_abottom;
MCNUM mccmg11_wavy;
MCNUM mccmg11_wavy_z;
MCNUM mccmg11_wavy_tb;
MCNUM mccmg11_wavy_lr;
MCNUM mccmg11_chamfers;
MCNUM mccmg11_chamfers_z;
MCNUM mccmg11_chamfers_lr;
MCNUM mccmg11_chamfers_tb;
MCNUM mccmg11_nelements;
MCNUM mccmg11_nu;
MCNUM mccmg11_phase;
char mccmg11_reflect[16384];

/* Setting parameters for component 'mg12' [96]. */
MCNUM mccmg12_w1;
MCNUM mccmg12_h1;
MCNUM mccmg12_w2;
MCNUM mccmg12_h2;
MCNUM mccmg12_l;
MCNUM mccmg12_R0;
MCNUM mccmg12_Qc;
MCNUM mccmg12_alpha;
MCNUM mccmg12_m;
MCNUM mccmg12_W;
MCNUM mccmg12_nslit;
MCNUM mccmg12_d;
MCNUM mccmg12_mleft;
MCNUM mccmg12_mright;
MCNUM mccmg12_mtop;
MCNUM mccmg12_mbottom;
MCNUM mccmg12_nhslit;
MCNUM mccmg12_G;
MCNUM mccmg12_aleft;
MCNUM mccmg12_aright;
MCNUM mccmg12_atop;
MCNUM mccmg12_abottom;
MCNUM mccmg12_wavy;
MCNUM mccmg12_wavy_z;
MCNUM mccmg12_wavy_tb;
MCNUM mccmg12_wavy_lr;
MCNUM mccmg12_chamfers;
MCNUM mccmg12_chamfers_z;
MCNUM mccmg12_chamfers_lr;
MCNUM mccmg12_chamfers_tb;
MCNUM mccmg12_nelements;
MCNUM mccmg12_nu;
MCNUM mccmg12_phase;
char mccmg12_reflect[16384];

/* Setting parameters for component 'mg13' [97]. */
MCNUM mccmg13_w1;
MCNUM mccmg13_h1;
MCNUM mccmg13_w2;
MCNUM mccmg13_h2;
MCNUM mccmg13_l;
MCNUM mccmg13_R0;
MCNUM mccmg13_Qc;
MCNUM mccmg13_alpha;
MCNUM mccmg13_m;
MCNUM mccmg13_W;
MCNUM mccmg13_nslit;
MCNUM mccmg13_d;
MCNUM mccmg13_mleft;
MCNUM mccmg13_mright;
MCNUM mccmg13_mtop;
MCNUM mccmg13_mbottom;
MCNUM mccmg13_nhslit;
MCNUM mccmg13_G;
MCNUM mccmg13_aleft;
MCNUM mccmg13_aright;
MCNUM mccmg13_atop;
MCNUM mccmg13_abottom;
MCNUM mccmg13_wavy;
MCNUM mccmg13_wavy_z;
MCNUM mccmg13_wavy_tb;
MCNUM mccmg13_wavy_lr;
MCNUM mccmg13_chamfers;
MCNUM mccmg13_chamfers_z;
MCNUM mccmg13_chamfers_lr;
MCNUM mccmg13_chamfers_tb;
MCNUM mccmg13_nelements;
MCNUM mccmg13_nu;
MCNUM mccmg13_phase;
char mccmg13_reflect[16384];

/* Setting parameters for component 'mg14' [98]. */
MCNUM mccmg14_w1;
MCNUM mccmg14_h1;
MCNUM mccmg14_w2;
MCNUM mccmg14_h2;
MCNUM mccmg14_l;
MCNUM mccmg14_R0;
MCNUM mccmg14_Qc;
MCNUM mccmg14_alpha;
MCNUM mccmg14_m;
MCNUM mccmg14_W;
MCNUM mccmg14_nslit;
MCNUM mccmg14_d;
MCNUM mccmg14_mleft;
MCNUM mccmg14_mright;
MCNUM mccmg14_mtop;
MCNUM mccmg14_mbottom;
MCNUM mccmg14_nhslit;
MCNUM mccmg14_G;
MCNUM mccmg14_aleft;
MCNUM mccmg14_aright;
MCNUM mccmg14_atop;
MCNUM mccmg14_abottom;
MCNUM mccmg14_wavy;
MCNUM mccmg14_wavy_z;
MCNUM mccmg14_wavy_tb;
MCNUM mccmg14_wavy_lr;
MCNUM mccmg14_chamfers;
MCNUM mccmg14_chamfers_z;
MCNUM mccmg14_chamfers_lr;
MCNUM mccmg14_chamfers_tb;
MCNUM mccmg14_nelements;
MCNUM mccmg14_nu;
MCNUM mccmg14_phase;
char mccmg14_reflect[16384];

/* Setting parameters for component 'mg15' [99]. */
MCNUM mccmg15_w1;
MCNUM mccmg15_h1;
MCNUM mccmg15_w2;
MCNUM mccmg15_h2;
MCNUM mccmg15_l;
MCNUM mccmg15_R0;
MCNUM mccmg15_Qc;
MCNUM mccmg15_alpha;
MCNUM mccmg15_m;
MCNUM mccmg15_W;
MCNUM mccmg15_nslit;
MCNUM mccmg15_d;
MCNUM mccmg15_mleft;
MCNUM mccmg15_mright;
MCNUM mccmg15_mtop;
MCNUM mccmg15_mbottom;
MCNUM mccmg15_nhslit;
MCNUM mccmg15_G;
MCNUM mccmg15_aleft;
MCNUM mccmg15_aright;
MCNUM mccmg15_atop;
MCNUM mccmg15_abottom;
MCNUM mccmg15_wavy;
MCNUM mccmg15_wavy_z;
MCNUM mccmg15_wavy_tb;
MCNUM mccmg15_wavy_lr;
MCNUM mccmg15_chamfers;
MCNUM mccmg15_chamfers_z;
MCNUM mccmg15_chamfers_lr;
MCNUM mccmg15_chamfers_tb;
MCNUM mccmg15_nelements;
MCNUM mccmg15_nu;
MCNUM mccmg15_phase;
char mccmg15_reflect[16384];

/* Setting parameters for component 'mg16' [100]. */
MCNUM mccmg16_w1;
MCNUM mccmg16_h1;
MCNUM mccmg16_w2;
MCNUM mccmg16_h2;
MCNUM mccmg16_l;
MCNUM mccmg16_R0;
MCNUM mccmg16_Qc;
MCNUM mccmg16_alpha;
MCNUM mccmg16_m;
MCNUM mccmg16_W;
MCNUM mccmg16_nslit;
MCNUM mccmg16_d;
MCNUM mccmg16_mleft;
MCNUM mccmg16_mright;
MCNUM mccmg16_mtop;
MCNUM mccmg16_mbottom;
MCNUM mccmg16_nhslit;
MCNUM mccmg16_G;
MCNUM mccmg16_aleft;
MCNUM mccmg16_aright;
MCNUM mccmg16_atop;
MCNUM mccmg16_abottom;
MCNUM mccmg16_wavy;
MCNUM mccmg16_wavy_z;
MCNUM mccmg16_wavy_tb;
MCNUM mccmg16_wavy_lr;
MCNUM mccmg16_chamfers;
MCNUM mccmg16_chamfers_z;
MCNUM mccmg16_chamfers_lr;
MCNUM mccmg16_chamfers_tb;
MCNUM mccmg16_nelements;
MCNUM mccmg16_nu;
MCNUM mccmg16_phase;
char mccmg16_reflect[16384];

/* Definition parameters for component 'SampleF' [101]. */
#define mccSampleF_user1 FLT_MAX
#define mccSampleF_user2 FLT_MAX
#define mccSampleF_user3 FLT_MAX
/* Setting parameters for component 'SampleF' [101]. */
MCNUM mccSampleF_xwidth;
MCNUM mccSampleF_yheight;
MCNUM mccSampleF_zdepth;
MCNUM mccSampleF_xmin;
MCNUM mccSampleF_xmax;
MCNUM mccSampleF_ymin;
MCNUM mccSampleF_ymax;
MCNUM mccSampleF_zmin;
MCNUM mccSampleF_zmax;
MCNUM mccSampleF_bins;
MCNUM mccSampleF_min;
MCNUM mccSampleF_max;
MCNUM mccSampleF_restore_neutron;
MCNUM mccSampleF_radius;
char mccSampleF_options[16384];
char mccSampleF_filename[16384];
char mccSampleF_geometry[16384];
char mccSampleF_username1[16384];
char mccSampleF_username2[16384];
char mccSampleF_username3[16384];
int mccSampleF_nowritefile;

/* Definition parameters for component 'SampleC' [102]. */
#define mccSampleC_user1 FLT_MAX
#define mccSampleC_user2 FLT_MAX
#define mccSampleC_user3 FLT_MAX
/* Setting parameters for component 'SampleC' [102]. */
MCNUM mccSampleC_xwidth;
MCNUM mccSampleC_yheight;
MCNUM mccSampleC_zdepth;
MCNUM mccSampleC_xmin;
MCNUM mccSampleC_xmax;
MCNUM mccSampleC_ymin;
MCNUM mccSampleC_ymax;
MCNUM mccSampleC_zmin;
MCNUM mccSampleC_zmax;
MCNUM mccSampleC_bins;
MCNUM mccSampleC_min;
MCNUM mccSampleC_max;
MCNUM mccSampleC_restore_neutron;
MCNUM mccSampleC_radius;
char mccSampleC_options[16384];
char mccSampleC_filename[16384];
char mccSampleC_geometry[16384];
char mccSampleC_username1[16384];
char mccSampleC_username2[16384];
char mccSampleC_username3[16384];
int mccSampleC_nowritefile;

/* User component declarations. */

/* User declarations for component 'PG' [1]. */
#define mccompcurname  PG
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccPG_IntermediateCnts
#define StartTime mccPG_StartTime
#define EndTime mccPG_EndTime
#define CurrentTime mccPG_CurrentTime
#define profile mccPG_profile
#define percent mccPG_percent
#define flag_save mccPG_flag_save
#define minutes mccPG_minutes
#line 44 "/usr/share/mcstas/2.6rc1/misc/Progress_bar.comp"
#ifndef PROGRESS_BAR
#define PROGRESS_BAR
#else
#error Only one Progress_bar component may be used in an instrument definition.
#endif

double IntermediateCnts;
time_t StartTime;
time_t EndTime;
time_t CurrentTime;
#line 13252 "ILL_H15_D11.c"
#undef minutes
#undef flag_save
#undef percent
#undef profile
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Source' [2]. */
#define mccompcurname  Source
#define mccompcurtype  Source_gen
#define mccompcurindex 2
#define p_in mccSource_p_in
#define lambda1 mccSource_lambda1
#define lambda2 mccSource_lambda2
#define lambda3 mccSource_lambda3
#define pTable mccSource_pTable
#define pTable_x mccSource_pTable_x
#define pTable_y mccSource_pTable_y
#define pTable_xmin mccSource_pTable_xmin
#define pTable_xmax mccSource_pTable_xmax
#define pTable_xsum mccSource_pTable_xsum
#define pTable_ymin mccSource_pTable_ymin
#define pTable_ymax mccSource_pTable_ymax
#define pTable_ysum mccSource_pTable_ysum
#define pTable_dxmin mccSource_pTable_dxmin
#define pTable_dxmax mccSource_pTable_dxmax
#define pTable_dymin mccSource_pTable_dymin
#define pTable_dymax mccSource_pTable_dymax
#define flux_file mccSource_flux_file
#define xdiv_file mccSource_xdiv_file
#define ydiv_file mccSource_ydiv_file
#define radius mccSource_radius
#define dist mccSource_dist
#define focus_xw mccSource_focus_xw
#define focus_yh mccSource_focus_yh
#define focus_aw mccSource_focus_aw
#define focus_ah mccSource_focus_ah
#define E0 mccSource_E0
#define dE mccSource_dE
#define lambda0 mccSource_lambda0
#define dlambda mccSource_dlambda
#define I1 mccSource_I1
#define yheight mccSource_yheight
#define xwidth mccSource_xwidth
#define verbose mccSource_verbose
#define T1 mccSource_T1
#define flux_file_perAA mccSource_flux_file_perAA
#define flux_file_log mccSource_flux_file_log
#define Lmin mccSource_Lmin
#define Lmax mccSource_Lmax
#define Emin mccSource_Emin
#define Emax mccSource_Emax
#define T2 mccSource_T2
#define I2 mccSource_I2
#define T3 mccSource_T3
#define I3 mccSource_I3
#define zdepth mccSource_zdepth
#define target_index mccSource_target_index
#line 184 "/usr/share/mcstas/2.6rc1/sources/Source_gen.comp"

  double p_in;
  double lambda1;  /* first Maxwellian source */
  double lambda2;  /* second Maxwellian source */
  double lambda3;  /* third Maxwellian source */
  t_Table pTable;
  t_Table pTable_x;
  t_Table pTable_y;
  double pTable_xmin;
  double pTable_xmax;
  double pTable_xsum;
  double pTable_ymin;
  double pTable_ymax;
  double pTable_ysum;
  double pTable_dxmin;
  double pTable_dxmax;
  double pTable_dymin;
  double pTable_dymax;

#line 13336 "ILL_H15_D11.c"
#undef target_index
#undef zdepth
#undef I3
#undef T3
#undef I2
#undef T2
#undef Emax
#undef Emin
#undef Lmax
#undef Lmin
#undef flux_file_log
#undef flux_file_perAA
#undef T1
#undef verbose
#undef xwidth
#undef yheight
#undef I1
#undef dlambda
#undef lambda0
#undef dE
#undef E0
#undef focus_ah
#undef focus_aw
#undef focus_yh
#undef focus_xw
#undef dist
#undef radius
#undef ydiv_file
#undef xdiv_file
#undef flux_file
#undef pTable_dymax
#undef pTable_dymin
#undef pTable_dxmax
#undef pTable_dxmin
#undef pTable_ysum
#undef pTable_ymax
#undef pTable_ymin
#undef pTable_xsum
#undef pTable_xmax
#undef pTable_xmin
#undef pTable_y
#undef pTable_x
#undef pTable
#undef lambda3
#undef lambda2
#undef lambda1
#undef p_in
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PinkCarter' [4]. */
#define mccompcurname  PinkCarter
#define mccompcurtype  Guide_gravity
#define mccompcurindex 4
#define GVars mccPinkCarter_GVars
#define pTable mccPinkCarter_pTable
#define w1 mccPinkCarter_w1
#define h1 mccPinkCarter_h1
#define w2 mccPinkCarter_w2
#define h2 mccPinkCarter_h2
#define l mccPinkCarter_l
#define R0 mccPinkCarter_R0
#define Qc mccPinkCarter_Qc
#define alpha mccPinkCarter_alpha
#define m mccPinkCarter_m
#define W mccPinkCarter_W
#define nslit mccPinkCarter_nslit
#define d mccPinkCarter_d
#define mleft mccPinkCarter_mleft
#define mright mccPinkCarter_mright
#define mtop mccPinkCarter_mtop
#define mbottom mccPinkCarter_mbottom
#define nhslit mccPinkCarter_nhslit
#define G mccPinkCarter_G
#define aleft mccPinkCarter_aleft
#define aright mccPinkCarter_aright
#define atop mccPinkCarter_atop
#define abottom mccPinkCarter_abottom
#define wavy mccPinkCarter_wavy
#define wavy_z mccPinkCarter_wavy_z
#define wavy_tb mccPinkCarter_wavy_tb
#define wavy_lr mccPinkCarter_wavy_lr
#define chamfers mccPinkCarter_chamfers
#define chamfers_z mccPinkCarter_chamfers_z
#define chamfers_lr mccPinkCarter_chamfers_lr
#define chamfers_tb mccPinkCarter_chamfers_tb
#define nelements mccPinkCarter_nelements
#define nu mccPinkCarter_nu
#define phase mccPinkCarter_phase
#define reflect mccPinkCarter_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 13431 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'LeadShutter' [6]. */
#define mccompcurname  LeadShutter
#define mccompcurtype  Guide_gravity
#define mccompcurindex 6
#define GVars mccLeadShutter_GVars
#define pTable mccLeadShutter_pTable
#define w1 mccLeadShutter_w1
#define h1 mccLeadShutter_h1
#define w2 mccLeadShutter_w2
#define h2 mccLeadShutter_h2
#define l mccLeadShutter_l
#define R0 mccLeadShutter_R0
#define Qc mccLeadShutter_Qc
#define alpha mccLeadShutter_alpha
#define m mccLeadShutter_m
#define W mccLeadShutter_W
#define nslit mccLeadShutter_nslit
#define d mccLeadShutter_d
#define mleft mccLeadShutter_mleft
#define mright mccLeadShutter_mright
#define mtop mccLeadShutter_mtop
#define mbottom mccLeadShutter_mbottom
#define nhslit mccLeadShutter_nhslit
#define G mccLeadShutter_G
#define aleft mccLeadShutter_aleft
#define aright mccLeadShutter_aright
#define atop mccLeadShutter_atop
#define abottom mccLeadShutter_abottom
#define wavy mccLeadShutter_wavy
#define wavy_z mccLeadShutter_wavy_z
#define wavy_tb mccLeadShutter_wavy_tb
#define wavy_lr mccLeadShutter_wavy_lr
#define chamfers mccLeadShutter_chamfers
#define chamfers_z mccLeadShutter_chamfers_z
#define chamfers_lr mccLeadShutter_chamfers_lr
#define chamfers_tb mccLeadShutter_chamfers_tb
#define nelements mccLeadShutter_nelements
#define nu mccLeadShutter_nu
#define phase mccLeadShutter_phase
#define reflect mccLeadShutter_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 13515 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'CurvedGuideStart' [8]. */
#define mccompcurname  CurvedGuideStart
#define mccompcurtype  Arm
#define mccompcurindex 8
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg1' [9]. */
#define mccompcurname  cg1
#define mccompcurtype  Guide_gravity
#define mccompcurindex 9
#define GVars mcccg1_GVars
#define pTable mcccg1_pTable
#define w1 mcccg1_w1
#define h1 mcccg1_h1
#define w2 mcccg1_w2
#define h2 mcccg1_h2
#define l mcccg1_l
#define R0 mcccg1_R0
#define Qc mcccg1_Qc
#define alpha mcccg1_alpha
#define m mcccg1_m
#define W mcccg1_W
#define nslit mcccg1_nslit
#define d mcccg1_d
#define mleft mcccg1_mleft
#define mright mcccg1_mright
#define mtop mcccg1_mtop
#define mbottom mcccg1_mbottom
#define nhslit mcccg1_nhslit
#define G mcccg1_G
#define aleft mcccg1_aleft
#define aright mcccg1_aright
#define atop mcccg1_atop
#define abottom mcccg1_abottom
#define wavy mcccg1_wavy
#define wavy_z mcccg1_wavy_z
#define wavy_tb mcccg1_wavy_tb
#define wavy_lr mcccg1_wavy_lr
#define chamfers mcccg1_chamfers
#define chamfers_z mcccg1_chamfers_z
#define chamfers_lr mcccg1_chamfers_lr
#define chamfers_tb mcccg1_chamfers_tb
#define nelements mcccg1_nelements
#define nu mcccg1_nu
#define phase mcccg1_phase
#define reflect mcccg1_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 13607 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg2' [10]. */
#define mccompcurname  cg2
#define mccompcurtype  Guide_gravity
#define mccompcurindex 10
#define GVars mcccg2_GVars
#define pTable mcccg2_pTable
#define w1 mcccg2_w1
#define h1 mcccg2_h1
#define w2 mcccg2_w2
#define h2 mcccg2_h2
#define l mcccg2_l
#define R0 mcccg2_R0
#define Qc mcccg2_Qc
#define alpha mcccg2_alpha
#define m mcccg2_m
#define W mcccg2_W
#define nslit mcccg2_nslit
#define d mcccg2_d
#define mleft mcccg2_mleft
#define mright mcccg2_mright
#define mtop mcccg2_mtop
#define mbottom mcccg2_mbottom
#define nhslit mcccg2_nhslit
#define G mcccg2_G
#define aleft mcccg2_aleft
#define aright mcccg2_aright
#define atop mcccg2_atop
#define abottom mcccg2_abottom
#define wavy mcccg2_wavy
#define wavy_z mcccg2_wavy_z
#define wavy_tb mcccg2_wavy_tb
#define wavy_lr mcccg2_wavy_lr
#define chamfers mcccg2_chamfers
#define chamfers_z mcccg2_chamfers_z
#define chamfers_lr mcccg2_chamfers_lr
#define chamfers_tb mcccg2_chamfers_tb
#define nelements mcccg2_nelements
#define nu mcccg2_nu
#define phase mcccg2_phase
#define reflect mcccg2_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 13691 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg3' [11]. */
#define mccompcurname  cg3
#define mccompcurtype  Guide_gravity
#define mccompcurindex 11
#define GVars mcccg3_GVars
#define pTable mcccg3_pTable
#define w1 mcccg3_w1
#define h1 mcccg3_h1
#define w2 mcccg3_w2
#define h2 mcccg3_h2
#define l mcccg3_l
#define R0 mcccg3_R0
#define Qc mcccg3_Qc
#define alpha mcccg3_alpha
#define m mcccg3_m
#define W mcccg3_W
#define nslit mcccg3_nslit
#define d mcccg3_d
#define mleft mcccg3_mleft
#define mright mcccg3_mright
#define mtop mcccg3_mtop
#define mbottom mcccg3_mbottom
#define nhslit mcccg3_nhslit
#define G mcccg3_G
#define aleft mcccg3_aleft
#define aright mcccg3_aright
#define atop mcccg3_atop
#define abottom mcccg3_abottom
#define wavy mcccg3_wavy
#define wavy_z mcccg3_wavy_z
#define wavy_tb mcccg3_wavy_tb
#define wavy_lr mcccg3_wavy_lr
#define chamfers mcccg3_chamfers
#define chamfers_z mcccg3_chamfers_z
#define chamfers_lr mcccg3_chamfers_lr
#define chamfers_tb mcccg3_chamfers_tb
#define nelements mcccg3_nelements
#define nu mcccg3_nu
#define phase mcccg3_phase
#define reflect mcccg3_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 13775 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg4' [12]. */
#define mccompcurname  cg4
#define mccompcurtype  Guide_gravity
#define mccompcurindex 12
#define GVars mcccg4_GVars
#define pTable mcccg4_pTable
#define w1 mcccg4_w1
#define h1 mcccg4_h1
#define w2 mcccg4_w2
#define h2 mcccg4_h2
#define l mcccg4_l
#define R0 mcccg4_R0
#define Qc mcccg4_Qc
#define alpha mcccg4_alpha
#define m mcccg4_m
#define W mcccg4_W
#define nslit mcccg4_nslit
#define d mcccg4_d
#define mleft mcccg4_mleft
#define mright mcccg4_mright
#define mtop mcccg4_mtop
#define mbottom mcccg4_mbottom
#define nhslit mcccg4_nhslit
#define G mcccg4_G
#define aleft mcccg4_aleft
#define aright mcccg4_aright
#define atop mcccg4_atop
#define abottom mcccg4_abottom
#define wavy mcccg4_wavy
#define wavy_z mcccg4_wavy_z
#define wavy_tb mcccg4_wavy_tb
#define wavy_lr mcccg4_wavy_lr
#define chamfers mcccg4_chamfers
#define chamfers_z mcccg4_chamfers_z
#define chamfers_lr mcccg4_chamfers_lr
#define chamfers_tb mcccg4_chamfers_tb
#define nelements mcccg4_nelements
#define nu mcccg4_nu
#define phase mcccg4_phase
#define reflect mcccg4_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 13859 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg5' [13]. */
#define mccompcurname  cg5
#define mccompcurtype  Guide_gravity
#define mccompcurindex 13
#define GVars mcccg5_GVars
#define pTable mcccg5_pTable
#define w1 mcccg5_w1
#define h1 mcccg5_h1
#define w2 mcccg5_w2
#define h2 mcccg5_h2
#define l mcccg5_l
#define R0 mcccg5_R0
#define Qc mcccg5_Qc
#define alpha mcccg5_alpha
#define m mcccg5_m
#define W mcccg5_W
#define nslit mcccg5_nslit
#define d mcccg5_d
#define mleft mcccg5_mleft
#define mright mcccg5_mright
#define mtop mcccg5_mtop
#define mbottom mcccg5_mbottom
#define nhslit mcccg5_nhslit
#define G mcccg5_G
#define aleft mcccg5_aleft
#define aright mcccg5_aright
#define atop mcccg5_atop
#define abottom mcccg5_abottom
#define wavy mcccg5_wavy
#define wavy_z mcccg5_wavy_z
#define wavy_tb mcccg5_wavy_tb
#define wavy_lr mcccg5_wavy_lr
#define chamfers mcccg5_chamfers
#define chamfers_z mcccg5_chamfers_z
#define chamfers_lr mcccg5_chamfers_lr
#define chamfers_tb mcccg5_chamfers_tb
#define nelements mcccg5_nelements
#define nu mcccg5_nu
#define phase mcccg5_phase
#define reflect mcccg5_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 13943 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg6' [14]. */
#define mccompcurname  cg6
#define mccompcurtype  Guide_gravity
#define mccompcurindex 14
#define GVars mcccg6_GVars
#define pTable mcccg6_pTable
#define w1 mcccg6_w1
#define h1 mcccg6_h1
#define w2 mcccg6_w2
#define h2 mcccg6_h2
#define l mcccg6_l
#define R0 mcccg6_R0
#define Qc mcccg6_Qc
#define alpha mcccg6_alpha
#define m mcccg6_m
#define W mcccg6_W
#define nslit mcccg6_nslit
#define d mcccg6_d
#define mleft mcccg6_mleft
#define mright mcccg6_mright
#define mtop mcccg6_mtop
#define mbottom mcccg6_mbottom
#define nhslit mcccg6_nhslit
#define G mcccg6_G
#define aleft mcccg6_aleft
#define aright mcccg6_aright
#define atop mcccg6_atop
#define abottom mcccg6_abottom
#define wavy mcccg6_wavy
#define wavy_z mcccg6_wavy_z
#define wavy_tb mcccg6_wavy_tb
#define wavy_lr mcccg6_wavy_lr
#define chamfers mcccg6_chamfers
#define chamfers_z mcccg6_chamfers_z
#define chamfers_lr mcccg6_chamfers_lr
#define chamfers_tb mcccg6_chamfers_tb
#define nelements mcccg6_nelements
#define nu mcccg6_nu
#define phase mcccg6_phase
#define reflect mcccg6_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14027 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg7' [15]. */
#define mccompcurname  cg7
#define mccompcurtype  Guide_gravity
#define mccompcurindex 15
#define GVars mcccg7_GVars
#define pTable mcccg7_pTable
#define w1 mcccg7_w1
#define h1 mcccg7_h1
#define w2 mcccg7_w2
#define h2 mcccg7_h2
#define l mcccg7_l
#define R0 mcccg7_R0
#define Qc mcccg7_Qc
#define alpha mcccg7_alpha
#define m mcccg7_m
#define W mcccg7_W
#define nslit mcccg7_nslit
#define d mcccg7_d
#define mleft mcccg7_mleft
#define mright mcccg7_mright
#define mtop mcccg7_mtop
#define mbottom mcccg7_mbottom
#define nhslit mcccg7_nhslit
#define G mcccg7_G
#define aleft mcccg7_aleft
#define aright mcccg7_aright
#define atop mcccg7_atop
#define abottom mcccg7_abottom
#define wavy mcccg7_wavy
#define wavy_z mcccg7_wavy_z
#define wavy_tb mcccg7_wavy_tb
#define wavy_lr mcccg7_wavy_lr
#define chamfers mcccg7_chamfers
#define chamfers_z mcccg7_chamfers_z
#define chamfers_lr mcccg7_chamfers_lr
#define chamfers_tb mcccg7_chamfers_tb
#define nelements mcccg7_nelements
#define nu mcccg7_nu
#define phase mcccg7_phase
#define reflect mcccg7_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14111 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg8' [16]. */
#define mccompcurname  cg8
#define mccompcurtype  Guide_gravity
#define mccompcurindex 16
#define GVars mcccg8_GVars
#define pTable mcccg8_pTable
#define w1 mcccg8_w1
#define h1 mcccg8_h1
#define w2 mcccg8_w2
#define h2 mcccg8_h2
#define l mcccg8_l
#define R0 mcccg8_R0
#define Qc mcccg8_Qc
#define alpha mcccg8_alpha
#define m mcccg8_m
#define W mcccg8_W
#define nslit mcccg8_nslit
#define d mcccg8_d
#define mleft mcccg8_mleft
#define mright mcccg8_mright
#define mtop mcccg8_mtop
#define mbottom mcccg8_mbottom
#define nhslit mcccg8_nhslit
#define G mcccg8_G
#define aleft mcccg8_aleft
#define aright mcccg8_aright
#define atop mcccg8_atop
#define abottom mcccg8_abottom
#define wavy mcccg8_wavy
#define wavy_z mcccg8_wavy_z
#define wavy_tb mcccg8_wavy_tb
#define wavy_lr mcccg8_wavy_lr
#define chamfers mcccg8_chamfers
#define chamfers_z mcccg8_chamfers_z
#define chamfers_lr mcccg8_chamfers_lr
#define chamfers_tb mcccg8_chamfers_tb
#define nelements mcccg8_nelements
#define nu mcccg8_nu
#define phase mcccg8_phase
#define reflect mcccg8_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14195 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg9' [17]. */
#define mccompcurname  cg9
#define mccompcurtype  Guide_gravity
#define mccompcurindex 17
#define GVars mcccg9_GVars
#define pTable mcccg9_pTable
#define w1 mcccg9_w1
#define h1 mcccg9_h1
#define w2 mcccg9_w2
#define h2 mcccg9_h2
#define l mcccg9_l
#define R0 mcccg9_R0
#define Qc mcccg9_Qc
#define alpha mcccg9_alpha
#define m mcccg9_m
#define W mcccg9_W
#define nslit mcccg9_nslit
#define d mcccg9_d
#define mleft mcccg9_mleft
#define mright mcccg9_mright
#define mtop mcccg9_mtop
#define mbottom mcccg9_mbottom
#define nhslit mcccg9_nhslit
#define G mcccg9_G
#define aleft mcccg9_aleft
#define aright mcccg9_aright
#define atop mcccg9_atop
#define abottom mcccg9_abottom
#define wavy mcccg9_wavy
#define wavy_z mcccg9_wavy_z
#define wavy_tb mcccg9_wavy_tb
#define wavy_lr mcccg9_wavy_lr
#define chamfers mcccg9_chamfers
#define chamfers_z mcccg9_chamfers_z
#define chamfers_lr mcccg9_chamfers_lr
#define chamfers_tb mcccg9_chamfers_tb
#define nelements mcccg9_nelements
#define nu mcccg9_nu
#define phase mcccg9_phase
#define reflect mcccg9_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14279 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg10' [18]. */
#define mccompcurname  cg10
#define mccompcurtype  Guide_gravity
#define mccompcurindex 18
#define GVars mcccg10_GVars
#define pTable mcccg10_pTable
#define w1 mcccg10_w1
#define h1 mcccg10_h1
#define w2 mcccg10_w2
#define h2 mcccg10_h2
#define l mcccg10_l
#define R0 mcccg10_R0
#define Qc mcccg10_Qc
#define alpha mcccg10_alpha
#define m mcccg10_m
#define W mcccg10_W
#define nslit mcccg10_nslit
#define d mcccg10_d
#define mleft mcccg10_mleft
#define mright mcccg10_mright
#define mtop mcccg10_mtop
#define mbottom mcccg10_mbottom
#define nhslit mcccg10_nhslit
#define G mcccg10_G
#define aleft mcccg10_aleft
#define aright mcccg10_aright
#define atop mcccg10_atop
#define abottom mcccg10_abottom
#define wavy mcccg10_wavy
#define wavy_z mcccg10_wavy_z
#define wavy_tb mcccg10_wavy_tb
#define wavy_lr mcccg10_wavy_lr
#define chamfers mcccg10_chamfers
#define chamfers_z mcccg10_chamfers_z
#define chamfers_lr mcccg10_chamfers_lr
#define chamfers_tb mcccg10_chamfers_tb
#define nelements mcccg10_nelements
#define nu mcccg10_nu
#define phase mcccg10_phase
#define reflect mcccg10_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14363 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg11' [19]. */
#define mccompcurname  cg11
#define mccompcurtype  Guide_gravity
#define mccompcurindex 19
#define GVars mcccg11_GVars
#define pTable mcccg11_pTable
#define w1 mcccg11_w1
#define h1 mcccg11_h1
#define w2 mcccg11_w2
#define h2 mcccg11_h2
#define l mcccg11_l
#define R0 mcccg11_R0
#define Qc mcccg11_Qc
#define alpha mcccg11_alpha
#define m mcccg11_m
#define W mcccg11_W
#define nslit mcccg11_nslit
#define d mcccg11_d
#define mleft mcccg11_mleft
#define mright mcccg11_mright
#define mtop mcccg11_mtop
#define mbottom mcccg11_mbottom
#define nhslit mcccg11_nhslit
#define G mcccg11_G
#define aleft mcccg11_aleft
#define aright mcccg11_aright
#define atop mcccg11_atop
#define abottom mcccg11_abottom
#define wavy mcccg11_wavy
#define wavy_z mcccg11_wavy_z
#define wavy_tb mcccg11_wavy_tb
#define wavy_lr mcccg11_wavy_lr
#define chamfers mcccg11_chamfers
#define chamfers_z mcccg11_chamfers_z
#define chamfers_lr mcccg11_chamfers_lr
#define chamfers_tb mcccg11_chamfers_tb
#define nelements mcccg11_nelements
#define nu mcccg11_nu
#define phase mcccg11_phase
#define reflect mcccg11_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14447 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg12' [20]. */
#define mccompcurname  cg12
#define mccompcurtype  Guide_gravity
#define mccompcurindex 20
#define GVars mcccg12_GVars
#define pTable mcccg12_pTable
#define w1 mcccg12_w1
#define h1 mcccg12_h1
#define w2 mcccg12_w2
#define h2 mcccg12_h2
#define l mcccg12_l
#define R0 mcccg12_R0
#define Qc mcccg12_Qc
#define alpha mcccg12_alpha
#define m mcccg12_m
#define W mcccg12_W
#define nslit mcccg12_nslit
#define d mcccg12_d
#define mleft mcccg12_mleft
#define mright mcccg12_mright
#define mtop mcccg12_mtop
#define mbottom mcccg12_mbottom
#define nhslit mcccg12_nhslit
#define G mcccg12_G
#define aleft mcccg12_aleft
#define aright mcccg12_aright
#define atop mcccg12_atop
#define abottom mcccg12_abottom
#define wavy mcccg12_wavy
#define wavy_z mcccg12_wavy_z
#define wavy_tb mcccg12_wavy_tb
#define wavy_lr mcccg12_wavy_lr
#define chamfers mcccg12_chamfers
#define chamfers_z mcccg12_chamfers_z
#define chamfers_lr mcccg12_chamfers_lr
#define chamfers_tb mcccg12_chamfers_tb
#define nelements mcccg12_nelements
#define nu mcccg12_nu
#define phase mcccg12_phase
#define reflect mcccg12_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14531 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg13' [21]. */
#define mccompcurname  cg13
#define mccompcurtype  Guide_gravity
#define mccompcurindex 21
#define GVars mcccg13_GVars
#define pTable mcccg13_pTable
#define w1 mcccg13_w1
#define h1 mcccg13_h1
#define w2 mcccg13_w2
#define h2 mcccg13_h2
#define l mcccg13_l
#define R0 mcccg13_R0
#define Qc mcccg13_Qc
#define alpha mcccg13_alpha
#define m mcccg13_m
#define W mcccg13_W
#define nslit mcccg13_nslit
#define d mcccg13_d
#define mleft mcccg13_mleft
#define mright mcccg13_mright
#define mtop mcccg13_mtop
#define mbottom mcccg13_mbottom
#define nhslit mcccg13_nhslit
#define G mcccg13_G
#define aleft mcccg13_aleft
#define aright mcccg13_aright
#define atop mcccg13_atop
#define abottom mcccg13_abottom
#define wavy mcccg13_wavy
#define wavy_z mcccg13_wavy_z
#define wavy_tb mcccg13_wavy_tb
#define wavy_lr mcccg13_wavy_lr
#define chamfers mcccg13_chamfers
#define chamfers_z mcccg13_chamfers_z
#define chamfers_lr mcccg13_chamfers_lr
#define chamfers_tb mcccg13_chamfers_tb
#define nelements mcccg13_nelements
#define nu mcccg13_nu
#define phase mcccg13_phase
#define reflect mcccg13_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14615 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg14' [22]. */
#define mccompcurname  cg14
#define mccompcurtype  Guide_gravity
#define mccompcurindex 22
#define GVars mcccg14_GVars
#define pTable mcccg14_pTable
#define w1 mcccg14_w1
#define h1 mcccg14_h1
#define w2 mcccg14_w2
#define h2 mcccg14_h2
#define l mcccg14_l
#define R0 mcccg14_R0
#define Qc mcccg14_Qc
#define alpha mcccg14_alpha
#define m mcccg14_m
#define W mcccg14_W
#define nslit mcccg14_nslit
#define d mcccg14_d
#define mleft mcccg14_mleft
#define mright mcccg14_mright
#define mtop mcccg14_mtop
#define mbottom mcccg14_mbottom
#define nhslit mcccg14_nhslit
#define G mcccg14_G
#define aleft mcccg14_aleft
#define aright mcccg14_aright
#define atop mcccg14_atop
#define abottom mcccg14_abottom
#define wavy mcccg14_wavy
#define wavy_z mcccg14_wavy_z
#define wavy_tb mcccg14_wavy_tb
#define wavy_lr mcccg14_wavy_lr
#define chamfers mcccg14_chamfers
#define chamfers_z mcccg14_chamfers_z
#define chamfers_lr mcccg14_chamfers_lr
#define chamfers_tb mcccg14_chamfers_tb
#define nelements mcccg14_nelements
#define nu mcccg14_nu
#define phase mcccg14_phase
#define reflect mcccg14_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14699 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg15' [23]. */
#define mccompcurname  cg15
#define mccompcurtype  Guide_gravity
#define mccompcurindex 23
#define GVars mcccg15_GVars
#define pTable mcccg15_pTable
#define w1 mcccg15_w1
#define h1 mcccg15_h1
#define w2 mcccg15_w2
#define h2 mcccg15_h2
#define l mcccg15_l
#define R0 mcccg15_R0
#define Qc mcccg15_Qc
#define alpha mcccg15_alpha
#define m mcccg15_m
#define W mcccg15_W
#define nslit mcccg15_nslit
#define d mcccg15_d
#define mleft mcccg15_mleft
#define mright mcccg15_mright
#define mtop mcccg15_mtop
#define mbottom mcccg15_mbottom
#define nhslit mcccg15_nhslit
#define G mcccg15_G
#define aleft mcccg15_aleft
#define aright mcccg15_aright
#define atop mcccg15_atop
#define abottom mcccg15_abottom
#define wavy mcccg15_wavy
#define wavy_z mcccg15_wavy_z
#define wavy_tb mcccg15_wavy_tb
#define wavy_lr mcccg15_wavy_lr
#define chamfers mcccg15_chamfers
#define chamfers_z mcccg15_chamfers_z
#define chamfers_lr mcccg15_chamfers_lr
#define chamfers_tb mcccg15_chamfers_tb
#define nelements mcccg15_nelements
#define nu mcccg15_nu
#define phase mcccg15_phase
#define reflect mcccg15_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14783 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg16' [24]. */
#define mccompcurname  cg16
#define mccompcurtype  Guide_gravity
#define mccompcurindex 24
#define GVars mcccg16_GVars
#define pTable mcccg16_pTable
#define w1 mcccg16_w1
#define h1 mcccg16_h1
#define w2 mcccg16_w2
#define h2 mcccg16_h2
#define l mcccg16_l
#define R0 mcccg16_R0
#define Qc mcccg16_Qc
#define alpha mcccg16_alpha
#define m mcccg16_m
#define W mcccg16_W
#define nslit mcccg16_nslit
#define d mcccg16_d
#define mleft mcccg16_mleft
#define mright mcccg16_mright
#define mtop mcccg16_mtop
#define mbottom mcccg16_mbottom
#define nhslit mcccg16_nhslit
#define G mcccg16_G
#define aleft mcccg16_aleft
#define aright mcccg16_aright
#define atop mcccg16_atop
#define abottom mcccg16_abottom
#define wavy mcccg16_wavy
#define wavy_z mcccg16_wavy_z
#define wavy_tb mcccg16_wavy_tb
#define wavy_lr mcccg16_wavy_lr
#define chamfers mcccg16_chamfers
#define chamfers_z mcccg16_chamfers_z
#define chamfers_lr mcccg16_chamfers_lr
#define chamfers_tb mcccg16_chamfers_tb
#define nelements mcccg16_nelements
#define nu mcccg16_nu
#define phase mcccg16_phase
#define reflect mcccg16_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14867 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg17' [25]. */
#define mccompcurname  cg17
#define mccompcurtype  Guide_gravity
#define mccompcurindex 25
#define GVars mcccg17_GVars
#define pTable mcccg17_pTable
#define w1 mcccg17_w1
#define h1 mcccg17_h1
#define w2 mcccg17_w2
#define h2 mcccg17_h2
#define l mcccg17_l
#define R0 mcccg17_R0
#define Qc mcccg17_Qc
#define alpha mcccg17_alpha
#define m mcccg17_m
#define W mcccg17_W
#define nslit mcccg17_nslit
#define d mcccg17_d
#define mleft mcccg17_mleft
#define mright mcccg17_mright
#define mtop mcccg17_mtop
#define mbottom mcccg17_mbottom
#define nhslit mcccg17_nhslit
#define G mcccg17_G
#define aleft mcccg17_aleft
#define aright mcccg17_aright
#define atop mcccg17_atop
#define abottom mcccg17_abottom
#define wavy mcccg17_wavy
#define wavy_z mcccg17_wavy_z
#define wavy_tb mcccg17_wavy_tb
#define wavy_lr mcccg17_wavy_lr
#define chamfers mcccg17_chamfers
#define chamfers_z mcccg17_chamfers_z
#define chamfers_lr mcccg17_chamfers_lr
#define chamfers_tb mcccg17_chamfers_tb
#define nelements mcccg17_nelements
#define nu mcccg17_nu
#define phase mcccg17_phase
#define reflect mcccg17_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 14951 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg18' [26]. */
#define mccompcurname  cg18
#define mccompcurtype  Guide_gravity
#define mccompcurindex 26
#define GVars mcccg18_GVars
#define pTable mcccg18_pTable
#define w1 mcccg18_w1
#define h1 mcccg18_h1
#define w2 mcccg18_w2
#define h2 mcccg18_h2
#define l mcccg18_l
#define R0 mcccg18_R0
#define Qc mcccg18_Qc
#define alpha mcccg18_alpha
#define m mcccg18_m
#define W mcccg18_W
#define nslit mcccg18_nslit
#define d mcccg18_d
#define mleft mcccg18_mleft
#define mright mcccg18_mright
#define mtop mcccg18_mtop
#define mbottom mcccg18_mbottom
#define nhslit mcccg18_nhslit
#define G mcccg18_G
#define aleft mcccg18_aleft
#define aright mcccg18_aright
#define atop mcccg18_atop
#define abottom mcccg18_abottom
#define wavy mcccg18_wavy
#define wavy_z mcccg18_wavy_z
#define wavy_tb mcccg18_wavy_tb
#define wavy_lr mcccg18_wavy_lr
#define chamfers mcccg18_chamfers
#define chamfers_z mcccg18_chamfers_z
#define chamfers_lr mcccg18_chamfers_lr
#define chamfers_tb mcccg18_chamfers_tb
#define nelements mcccg18_nelements
#define nu mcccg18_nu
#define phase mcccg18_phase
#define reflect mcccg18_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15035 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg19' [27]. */
#define mccompcurname  cg19
#define mccompcurtype  Guide_gravity
#define mccompcurindex 27
#define GVars mcccg19_GVars
#define pTable mcccg19_pTable
#define w1 mcccg19_w1
#define h1 mcccg19_h1
#define w2 mcccg19_w2
#define h2 mcccg19_h2
#define l mcccg19_l
#define R0 mcccg19_R0
#define Qc mcccg19_Qc
#define alpha mcccg19_alpha
#define m mcccg19_m
#define W mcccg19_W
#define nslit mcccg19_nslit
#define d mcccg19_d
#define mleft mcccg19_mleft
#define mright mcccg19_mright
#define mtop mcccg19_mtop
#define mbottom mcccg19_mbottom
#define nhslit mcccg19_nhslit
#define G mcccg19_G
#define aleft mcccg19_aleft
#define aright mcccg19_aright
#define atop mcccg19_atop
#define abottom mcccg19_abottom
#define wavy mcccg19_wavy
#define wavy_z mcccg19_wavy_z
#define wavy_tb mcccg19_wavy_tb
#define wavy_lr mcccg19_wavy_lr
#define chamfers mcccg19_chamfers
#define chamfers_z mcccg19_chamfers_z
#define chamfers_lr mcccg19_chamfers_lr
#define chamfers_tb mcccg19_chamfers_tb
#define nelements mcccg19_nelements
#define nu mcccg19_nu
#define phase mcccg19_phase
#define reflect mcccg19_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15119 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg20' [28]. */
#define mccompcurname  cg20
#define mccompcurtype  Guide_gravity
#define mccompcurindex 28
#define GVars mcccg20_GVars
#define pTable mcccg20_pTable
#define w1 mcccg20_w1
#define h1 mcccg20_h1
#define w2 mcccg20_w2
#define h2 mcccg20_h2
#define l mcccg20_l
#define R0 mcccg20_R0
#define Qc mcccg20_Qc
#define alpha mcccg20_alpha
#define m mcccg20_m
#define W mcccg20_W
#define nslit mcccg20_nslit
#define d mcccg20_d
#define mleft mcccg20_mleft
#define mright mcccg20_mright
#define mtop mcccg20_mtop
#define mbottom mcccg20_mbottom
#define nhslit mcccg20_nhslit
#define G mcccg20_G
#define aleft mcccg20_aleft
#define aright mcccg20_aright
#define atop mcccg20_atop
#define abottom mcccg20_abottom
#define wavy mcccg20_wavy
#define wavy_z mcccg20_wavy_z
#define wavy_tb mcccg20_wavy_tb
#define wavy_lr mcccg20_wavy_lr
#define chamfers mcccg20_chamfers
#define chamfers_z mcccg20_chamfers_z
#define chamfers_lr mcccg20_chamfers_lr
#define chamfers_tb mcccg20_chamfers_tb
#define nelements mcccg20_nelements
#define nu mcccg20_nu
#define phase mcccg20_phase
#define reflect mcccg20_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15203 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg21' [29]. */
#define mccompcurname  cg21
#define mccompcurtype  Guide_gravity
#define mccompcurindex 29
#define GVars mcccg21_GVars
#define pTable mcccg21_pTable
#define w1 mcccg21_w1
#define h1 mcccg21_h1
#define w2 mcccg21_w2
#define h2 mcccg21_h2
#define l mcccg21_l
#define R0 mcccg21_R0
#define Qc mcccg21_Qc
#define alpha mcccg21_alpha
#define m mcccg21_m
#define W mcccg21_W
#define nslit mcccg21_nslit
#define d mcccg21_d
#define mleft mcccg21_mleft
#define mright mcccg21_mright
#define mtop mcccg21_mtop
#define mbottom mcccg21_mbottom
#define nhslit mcccg21_nhslit
#define G mcccg21_G
#define aleft mcccg21_aleft
#define aright mcccg21_aright
#define atop mcccg21_atop
#define abottom mcccg21_abottom
#define wavy mcccg21_wavy
#define wavy_z mcccg21_wavy_z
#define wavy_tb mcccg21_wavy_tb
#define wavy_lr mcccg21_wavy_lr
#define chamfers mcccg21_chamfers
#define chamfers_z mcccg21_chamfers_z
#define chamfers_lr mcccg21_chamfers_lr
#define chamfers_tb mcccg21_chamfers_tb
#define nelements mcccg21_nelements
#define nu mcccg21_nu
#define phase mcccg21_phase
#define reflect mcccg21_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15287 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg22' [30]. */
#define mccompcurname  cg22
#define mccompcurtype  Guide_gravity
#define mccompcurindex 30
#define GVars mcccg22_GVars
#define pTable mcccg22_pTable
#define w1 mcccg22_w1
#define h1 mcccg22_h1
#define w2 mcccg22_w2
#define h2 mcccg22_h2
#define l mcccg22_l
#define R0 mcccg22_R0
#define Qc mcccg22_Qc
#define alpha mcccg22_alpha
#define m mcccg22_m
#define W mcccg22_W
#define nslit mcccg22_nslit
#define d mcccg22_d
#define mleft mcccg22_mleft
#define mright mcccg22_mright
#define mtop mcccg22_mtop
#define mbottom mcccg22_mbottom
#define nhslit mcccg22_nhslit
#define G mcccg22_G
#define aleft mcccg22_aleft
#define aright mcccg22_aright
#define atop mcccg22_atop
#define abottom mcccg22_abottom
#define wavy mcccg22_wavy
#define wavy_z mcccg22_wavy_z
#define wavy_tb mcccg22_wavy_tb
#define wavy_lr mcccg22_wavy_lr
#define chamfers mcccg22_chamfers
#define chamfers_z mcccg22_chamfers_z
#define chamfers_lr mcccg22_chamfers_lr
#define chamfers_tb mcccg22_chamfers_tb
#define nelements mcccg22_nelements
#define nu mcccg22_nu
#define phase mcccg22_phase
#define reflect mcccg22_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15371 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg23' [31]. */
#define mccompcurname  cg23
#define mccompcurtype  Guide_gravity
#define mccompcurindex 31
#define GVars mcccg23_GVars
#define pTable mcccg23_pTable
#define w1 mcccg23_w1
#define h1 mcccg23_h1
#define w2 mcccg23_w2
#define h2 mcccg23_h2
#define l mcccg23_l
#define R0 mcccg23_R0
#define Qc mcccg23_Qc
#define alpha mcccg23_alpha
#define m mcccg23_m
#define W mcccg23_W
#define nslit mcccg23_nslit
#define d mcccg23_d
#define mleft mcccg23_mleft
#define mright mcccg23_mright
#define mtop mcccg23_mtop
#define mbottom mcccg23_mbottom
#define nhslit mcccg23_nhslit
#define G mcccg23_G
#define aleft mcccg23_aleft
#define aright mcccg23_aright
#define atop mcccg23_atop
#define abottom mcccg23_abottom
#define wavy mcccg23_wavy
#define wavy_z mcccg23_wavy_z
#define wavy_tb mcccg23_wavy_tb
#define wavy_lr mcccg23_wavy_lr
#define chamfers mcccg23_chamfers
#define chamfers_z mcccg23_chamfers_z
#define chamfers_lr mcccg23_chamfers_lr
#define chamfers_tb mcccg23_chamfers_tb
#define nelements mcccg23_nelements
#define nu mcccg23_nu
#define phase mcccg23_phase
#define reflect mcccg23_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15455 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg24' [32]. */
#define mccompcurname  cg24
#define mccompcurtype  Guide_gravity
#define mccompcurindex 32
#define GVars mcccg24_GVars
#define pTable mcccg24_pTable
#define w1 mcccg24_w1
#define h1 mcccg24_h1
#define w2 mcccg24_w2
#define h2 mcccg24_h2
#define l mcccg24_l
#define R0 mcccg24_R0
#define Qc mcccg24_Qc
#define alpha mcccg24_alpha
#define m mcccg24_m
#define W mcccg24_W
#define nslit mcccg24_nslit
#define d mcccg24_d
#define mleft mcccg24_mleft
#define mright mcccg24_mright
#define mtop mcccg24_mtop
#define mbottom mcccg24_mbottom
#define nhslit mcccg24_nhslit
#define G mcccg24_G
#define aleft mcccg24_aleft
#define aright mcccg24_aright
#define atop mcccg24_atop
#define abottom mcccg24_abottom
#define wavy mcccg24_wavy
#define wavy_z mcccg24_wavy_z
#define wavy_tb mcccg24_wavy_tb
#define wavy_lr mcccg24_wavy_lr
#define chamfers mcccg24_chamfers
#define chamfers_z mcccg24_chamfers_z
#define chamfers_lr mcccg24_chamfers_lr
#define chamfers_tb mcccg24_chamfers_tb
#define nelements mcccg24_nelements
#define nu mcccg24_nu
#define phase mcccg24_phase
#define reflect mcccg24_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15539 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'cg25' [33]. */
#define mccompcurname  cg25
#define mccompcurtype  Guide_gravity
#define mccompcurindex 33
#define GVars mcccg25_GVars
#define pTable mcccg25_pTable
#define w1 mcccg25_w1
#define h1 mcccg25_h1
#define w2 mcccg25_w2
#define h2 mcccg25_h2
#define l mcccg25_l
#define R0 mcccg25_R0
#define Qc mcccg25_Qc
#define alpha mcccg25_alpha
#define m mcccg25_m
#define W mcccg25_W
#define nslit mcccg25_nslit
#define d mcccg25_d
#define mleft mcccg25_mleft
#define mright mcccg25_mright
#define mtop mcccg25_mtop
#define mbottom mcccg25_mbottom
#define nhslit mcccg25_nhslit
#define G mcccg25_G
#define aleft mcccg25_aleft
#define aright mcccg25_aright
#define atop mcccg25_atop
#define abottom mcccg25_abottom
#define wavy mcccg25_wavy
#define wavy_z mcccg25_wavy_z
#define wavy_tb mcccg25_wavy_tb
#define wavy_lr mcccg25_wavy_lr
#define chamfers mcccg25_chamfers
#define chamfers_z mcccg25_chamfers_z
#define chamfers_lr mcccg25_chamfers_lr
#define chamfers_tb mcccg25_chamfers_tb
#define nelements mcccg25_nelements
#define nu mcccg25_nu
#define phase mcccg25_phase
#define reflect mcccg25_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15623 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PSD_VTE' [35]. */
#define mccompcurname  PSD_VTE
#define mccompcurtype  Monitor_nD
#define mccompcurindex 35
#define user1 mccPSD_VTE_user1
#define user2 mccPSD_VTE_user2
#define user3 mccPSD_VTE_user3
#define DEFS mccPSD_VTE_DEFS
#define Vars mccPSD_VTE_Vars
#define detector mccPSD_VTE_detector
#define offdata mccPSD_VTE_offdata
#define xwidth mccPSD_VTE_xwidth
#define yheight mccPSD_VTE_yheight
#define zdepth mccPSD_VTE_zdepth
#define xmin mccPSD_VTE_xmin
#define xmax mccPSD_VTE_xmax
#define ymin mccPSD_VTE_ymin
#define ymax mccPSD_VTE_ymax
#define zmin mccPSD_VTE_zmin
#define zmax mccPSD_VTE_zmax
#define bins mccPSD_VTE_bins
#define min mccPSD_VTE_min
#define max mccPSD_VTE_max
#define restore_neutron mccPSD_VTE_restore_neutron
#define radius mccPSD_VTE_radius
#define options mccPSD_VTE_options
#define filename mccPSD_VTE_filename
#define geometry mccPSD_VTE_geometry
#define username1 mccPSD_VTE_username1
#define username2 mccPSD_VTE_username2
#define username3 mccPSD_VTE_username3
#define nowritefile mccPSD_VTE_nowritefile
#line 224 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
  MonitornD_Defines_type DEFS;
  MonitornD_Variables_type Vars;
  MCDETECTOR detector;
  off_struct offdata;
#line 15701 "ILL_H15_D11.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'VTEtoIN6GuideStart' [37]. */
#define mccompcurname  VTEtoIN6GuideStart
#define mccompcurtype  Arm
#define mccompcurindex 37
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg1' [38]. */
#define mccompcurname  sg1
#define mccompcurtype  Guide_gravity
#define mccompcurindex 38
#define GVars mccsg1_GVars
#define pTable mccsg1_pTable
#define w1 mccsg1_w1
#define h1 mccsg1_h1
#define w2 mccsg1_w2
#define h2 mccsg1_h2
#define l mccsg1_l
#define R0 mccsg1_R0
#define Qc mccsg1_Qc
#define alpha mccsg1_alpha
#define m mccsg1_m
#define W mccsg1_W
#define nslit mccsg1_nslit
#define d mccsg1_d
#define mleft mccsg1_mleft
#define mright mccsg1_mright
#define mtop mccsg1_mtop
#define mbottom mccsg1_mbottom
#define nhslit mccsg1_nhslit
#define G mccsg1_G
#define aleft mccsg1_aleft
#define aright mccsg1_aright
#define atop mccsg1_atop
#define abottom mccsg1_abottom
#define wavy mccsg1_wavy
#define wavy_z mccsg1_wavy_z
#define wavy_tb mccsg1_wavy_tb
#define wavy_lr mccsg1_wavy_lr
#define chamfers mccsg1_chamfers
#define chamfers_z mccsg1_chamfers_z
#define chamfers_lr mccsg1_chamfers_lr
#define chamfers_tb mccsg1_chamfers_tb
#define nelements mccsg1_nelements
#define nu mccsg1_nu
#define phase mccsg1_phase
#define reflect mccsg1_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15785 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg2' [39]. */
#define mccompcurname  sg2
#define mccompcurtype  Guide_gravity
#define mccompcurindex 39
#define GVars mccsg2_GVars
#define pTable mccsg2_pTable
#define w1 mccsg2_w1
#define h1 mccsg2_h1
#define w2 mccsg2_w2
#define h2 mccsg2_h2
#define l mccsg2_l
#define R0 mccsg2_R0
#define Qc mccsg2_Qc
#define alpha mccsg2_alpha
#define m mccsg2_m
#define W mccsg2_W
#define nslit mccsg2_nslit
#define d mccsg2_d
#define mleft mccsg2_mleft
#define mright mccsg2_mright
#define mtop mccsg2_mtop
#define mbottom mccsg2_mbottom
#define nhslit mccsg2_nhslit
#define G mccsg2_G
#define aleft mccsg2_aleft
#define aright mccsg2_aright
#define atop mccsg2_atop
#define abottom mccsg2_abottom
#define wavy mccsg2_wavy
#define wavy_z mccsg2_wavy_z
#define wavy_tb mccsg2_wavy_tb
#define wavy_lr mccsg2_wavy_lr
#define chamfers mccsg2_chamfers
#define chamfers_z mccsg2_chamfers_z
#define chamfers_lr mccsg2_chamfers_lr
#define chamfers_tb mccsg2_chamfers_tb
#define nelements mccsg2_nelements
#define nu mccsg2_nu
#define phase mccsg2_phase
#define reflect mccsg2_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15869 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg3' [40]. */
#define mccompcurname  sg3
#define mccompcurtype  Guide_gravity
#define mccompcurindex 40
#define GVars mccsg3_GVars
#define pTable mccsg3_pTable
#define w1 mccsg3_w1
#define h1 mccsg3_h1
#define w2 mccsg3_w2
#define h2 mccsg3_h2
#define l mccsg3_l
#define R0 mccsg3_R0
#define Qc mccsg3_Qc
#define alpha mccsg3_alpha
#define m mccsg3_m
#define W mccsg3_W
#define nslit mccsg3_nslit
#define d mccsg3_d
#define mleft mccsg3_mleft
#define mright mccsg3_mright
#define mtop mccsg3_mtop
#define mbottom mccsg3_mbottom
#define nhslit mccsg3_nhslit
#define G mccsg3_G
#define aleft mccsg3_aleft
#define aright mccsg3_aright
#define atop mccsg3_atop
#define abottom mccsg3_abottom
#define wavy mccsg3_wavy
#define wavy_z mccsg3_wavy_z
#define wavy_tb mccsg3_wavy_tb
#define wavy_lr mccsg3_wavy_lr
#define chamfers mccsg3_chamfers
#define chamfers_z mccsg3_chamfers_z
#define chamfers_lr mccsg3_chamfers_lr
#define chamfers_tb mccsg3_chamfers_tb
#define nelements mccsg3_nelements
#define nu mccsg3_nu
#define phase mccsg3_phase
#define reflect mccsg3_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 15953 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg4' [41]. */
#define mccompcurname  sg4
#define mccompcurtype  Guide_gravity
#define mccompcurindex 41
#define GVars mccsg4_GVars
#define pTable mccsg4_pTable
#define w1 mccsg4_w1
#define h1 mccsg4_h1
#define w2 mccsg4_w2
#define h2 mccsg4_h2
#define l mccsg4_l
#define R0 mccsg4_R0
#define Qc mccsg4_Qc
#define alpha mccsg4_alpha
#define m mccsg4_m
#define W mccsg4_W
#define nslit mccsg4_nslit
#define d mccsg4_d
#define mleft mccsg4_mleft
#define mright mccsg4_mright
#define mtop mccsg4_mtop
#define mbottom mccsg4_mbottom
#define nhslit mccsg4_nhslit
#define G mccsg4_G
#define aleft mccsg4_aleft
#define aright mccsg4_aright
#define atop mccsg4_atop
#define abottom mccsg4_abottom
#define wavy mccsg4_wavy
#define wavy_z mccsg4_wavy_z
#define wavy_tb mccsg4_wavy_tb
#define wavy_lr mccsg4_wavy_lr
#define chamfers mccsg4_chamfers
#define chamfers_z mccsg4_chamfers_z
#define chamfers_lr mccsg4_chamfers_lr
#define chamfers_tb mccsg4_chamfers_tb
#define nelements mccsg4_nelements
#define nu mccsg4_nu
#define phase mccsg4_phase
#define reflect mccsg4_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16037 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg5' [42]. */
#define mccompcurname  sg5
#define mccompcurtype  Guide_gravity
#define mccompcurindex 42
#define GVars mccsg5_GVars
#define pTable mccsg5_pTable
#define w1 mccsg5_w1
#define h1 mccsg5_h1
#define w2 mccsg5_w2
#define h2 mccsg5_h2
#define l mccsg5_l
#define R0 mccsg5_R0
#define Qc mccsg5_Qc
#define alpha mccsg5_alpha
#define m mccsg5_m
#define W mccsg5_W
#define nslit mccsg5_nslit
#define d mccsg5_d
#define mleft mccsg5_mleft
#define mright mccsg5_mright
#define mtop mccsg5_mtop
#define mbottom mccsg5_mbottom
#define nhslit mccsg5_nhslit
#define G mccsg5_G
#define aleft mccsg5_aleft
#define aright mccsg5_aright
#define atop mccsg5_atop
#define abottom mccsg5_abottom
#define wavy mccsg5_wavy
#define wavy_z mccsg5_wavy_z
#define wavy_tb mccsg5_wavy_tb
#define wavy_lr mccsg5_wavy_lr
#define chamfers mccsg5_chamfers
#define chamfers_z mccsg5_chamfers_z
#define chamfers_lr mccsg5_chamfers_lr
#define chamfers_tb mccsg5_chamfers_tb
#define nelements mccsg5_nelements
#define nu mccsg5_nu
#define phase mccsg5_phase
#define reflect mccsg5_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16121 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg6' [43]. */
#define mccompcurname  sg6
#define mccompcurtype  Guide_gravity
#define mccompcurindex 43
#define GVars mccsg6_GVars
#define pTable mccsg6_pTable
#define w1 mccsg6_w1
#define h1 mccsg6_h1
#define w2 mccsg6_w2
#define h2 mccsg6_h2
#define l mccsg6_l
#define R0 mccsg6_R0
#define Qc mccsg6_Qc
#define alpha mccsg6_alpha
#define m mccsg6_m
#define W mccsg6_W
#define nslit mccsg6_nslit
#define d mccsg6_d
#define mleft mccsg6_mleft
#define mright mccsg6_mright
#define mtop mccsg6_mtop
#define mbottom mccsg6_mbottom
#define nhslit mccsg6_nhslit
#define G mccsg6_G
#define aleft mccsg6_aleft
#define aright mccsg6_aright
#define atop mccsg6_atop
#define abottom mccsg6_abottom
#define wavy mccsg6_wavy
#define wavy_z mccsg6_wavy_z
#define wavy_tb mccsg6_wavy_tb
#define wavy_lr mccsg6_wavy_lr
#define chamfers mccsg6_chamfers
#define chamfers_z mccsg6_chamfers_z
#define chamfers_lr mccsg6_chamfers_lr
#define chamfers_tb mccsg6_chamfers_tb
#define nelements mccsg6_nelements
#define nu mccsg6_nu
#define phase mccsg6_phase
#define reflect mccsg6_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16205 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg7' [44]. */
#define mccompcurname  sg7
#define mccompcurtype  Guide_gravity
#define mccompcurindex 44
#define GVars mccsg7_GVars
#define pTable mccsg7_pTable
#define w1 mccsg7_w1
#define h1 mccsg7_h1
#define w2 mccsg7_w2
#define h2 mccsg7_h2
#define l mccsg7_l
#define R0 mccsg7_R0
#define Qc mccsg7_Qc
#define alpha mccsg7_alpha
#define m mccsg7_m
#define W mccsg7_W
#define nslit mccsg7_nslit
#define d mccsg7_d
#define mleft mccsg7_mleft
#define mright mccsg7_mright
#define mtop mccsg7_mtop
#define mbottom mccsg7_mbottom
#define nhslit mccsg7_nhslit
#define G mccsg7_G
#define aleft mccsg7_aleft
#define aright mccsg7_aright
#define atop mccsg7_atop
#define abottom mccsg7_abottom
#define wavy mccsg7_wavy
#define wavy_z mccsg7_wavy_z
#define wavy_tb mccsg7_wavy_tb
#define wavy_lr mccsg7_wavy_lr
#define chamfers mccsg7_chamfers
#define chamfers_z mccsg7_chamfers_z
#define chamfers_lr mccsg7_chamfers_lr
#define chamfers_tb mccsg7_chamfers_tb
#define nelements mccsg7_nelements
#define nu mccsg7_nu
#define phase mccsg7_phase
#define reflect mccsg7_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16289 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg8' [45]. */
#define mccompcurname  sg8
#define mccompcurtype  Guide_gravity
#define mccompcurindex 45
#define GVars mccsg8_GVars
#define pTable mccsg8_pTable
#define w1 mccsg8_w1
#define h1 mccsg8_h1
#define w2 mccsg8_w2
#define h2 mccsg8_h2
#define l mccsg8_l
#define R0 mccsg8_R0
#define Qc mccsg8_Qc
#define alpha mccsg8_alpha
#define m mccsg8_m
#define W mccsg8_W
#define nslit mccsg8_nslit
#define d mccsg8_d
#define mleft mccsg8_mleft
#define mright mccsg8_mright
#define mtop mccsg8_mtop
#define mbottom mccsg8_mbottom
#define nhslit mccsg8_nhslit
#define G mccsg8_G
#define aleft mccsg8_aleft
#define aright mccsg8_aright
#define atop mccsg8_atop
#define abottom mccsg8_abottom
#define wavy mccsg8_wavy
#define wavy_z mccsg8_wavy_z
#define wavy_tb mccsg8_wavy_tb
#define wavy_lr mccsg8_wavy_lr
#define chamfers mccsg8_chamfers
#define chamfers_z mccsg8_chamfers_z
#define chamfers_lr mccsg8_chamfers_lr
#define chamfers_tb mccsg8_chamfers_tb
#define nelements mccsg8_nelements
#define nu mccsg8_nu
#define phase mccsg8_phase
#define reflect mccsg8_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16373 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg9' [46]. */
#define mccompcurname  sg9
#define mccompcurtype  Guide_gravity
#define mccompcurindex 46
#define GVars mccsg9_GVars
#define pTable mccsg9_pTable
#define w1 mccsg9_w1
#define h1 mccsg9_h1
#define w2 mccsg9_w2
#define h2 mccsg9_h2
#define l mccsg9_l
#define R0 mccsg9_R0
#define Qc mccsg9_Qc
#define alpha mccsg9_alpha
#define m mccsg9_m
#define W mccsg9_W
#define nslit mccsg9_nslit
#define d mccsg9_d
#define mleft mccsg9_mleft
#define mright mccsg9_mright
#define mtop mccsg9_mtop
#define mbottom mccsg9_mbottom
#define nhslit mccsg9_nhslit
#define G mccsg9_G
#define aleft mccsg9_aleft
#define aright mccsg9_aright
#define atop mccsg9_atop
#define abottom mccsg9_abottom
#define wavy mccsg9_wavy
#define wavy_z mccsg9_wavy_z
#define wavy_tb mccsg9_wavy_tb
#define wavy_lr mccsg9_wavy_lr
#define chamfers mccsg9_chamfers
#define chamfers_z mccsg9_chamfers_z
#define chamfers_lr mccsg9_chamfers_lr
#define chamfers_tb mccsg9_chamfers_tb
#define nelements mccsg9_nelements
#define nu mccsg9_nu
#define phase mccsg9_phase
#define reflect mccsg9_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16457 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg10' [47]. */
#define mccompcurname  sg10
#define mccompcurtype  Guide_gravity
#define mccompcurindex 47
#define GVars mccsg10_GVars
#define pTable mccsg10_pTable
#define w1 mccsg10_w1
#define h1 mccsg10_h1
#define w2 mccsg10_w2
#define h2 mccsg10_h2
#define l mccsg10_l
#define R0 mccsg10_R0
#define Qc mccsg10_Qc
#define alpha mccsg10_alpha
#define m mccsg10_m
#define W mccsg10_W
#define nslit mccsg10_nslit
#define d mccsg10_d
#define mleft mccsg10_mleft
#define mright mccsg10_mright
#define mtop mccsg10_mtop
#define mbottom mccsg10_mbottom
#define nhslit mccsg10_nhslit
#define G mccsg10_G
#define aleft mccsg10_aleft
#define aright mccsg10_aright
#define atop mccsg10_atop
#define abottom mccsg10_abottom
#define wavy mccsg10_wavy
#define wavy_z mccsg10_wavy_z
#define wavy_tb mccsg10_wavy_tb
#define wavy_lr mccsg10_wavy_lr
#define chamfers mccsg10_chamfers
#define chamfers_z mccsg10_chamfers_z
#define chamfers_lr mccsg10_chamfers_lr
#define chamfers_tb mccsg10_chamfers_tb
#define nelements mccsg10_nelements
#define nu mccsg10_nu
#define phase mccsg10_phase
#define reflect mccsg10_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16541 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg11' [48]. */
#define mccompcurname  sg11
#define mccompcurtype  Guide_gravity
#define mccompcurindex 48
#define GVars mccsg11_GVars
#define pTable mccsg11_pTable
#define w1 mccsg11_w1
#define h1 mccsg11_h1
#define w2 mccsg11_w2
#define h2 mccsg11_h2
#define l mccsg11_l
#define R0 mccsg11_R0
#define Qc mccsg11_Qc
#define alpha mccsg11_alpha
#define m mccsg11_m
#define W mccsg11_W
#define nslit mccsg11_nslit
#define d mccsg11_d
#define mleft mccsg11_mleft
#define mright mccsg11_mright
#define mtop mccsg11_mtop
#define mbottom mccsg11_mbottom
#define nhslit mccsg11_nhslit
#define G mccsg11_G
#define aleft mccsg11_aleft
#define aright mccsg11_aright
#define atop mccsg11_atop
#define abottom mccsg11_abottom
#define wavy mccsg11_wavy
#define wavy_z mccsg11_wavy_z
#define wavy_tb mccsg11_wavy_tb
#define wavy_lr mccsg11_wavy_lr
#define chamfers mccsg11_chamfers
#define chamfers_z mccsg11_chamfers_z
#define chamfers_lr mccsg11_chamfers_lr
#define chamfers_tb mccsg11_chamfers_tb
#define nelements mccsg11_nelements
#define nu mccsg11_nu
#define phase mccsg11_phase
#define reflect mccsg11_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16625 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg12' [49]. */
#define mccompcurname  sg12
#define mccompcurtype  Guide_gravity
#define mccompcurindex 49
#define GVars mccsg12_GVars
#define pTable mccsg12_pTable
#define w1 mccsg12_w1
#define h1 mccsg12_h1
#define w2 mccsg12_w2
#define h2 mccsg12_h2
#define l mccsg12_l
#define R0 mccsg12_R0
#define Qc mccsg12_Qc
#define alpha mccsg12_alpha
#define m mccsg12_m
#define W mccsg12_W
#define nslit mccsg12_nslit
#define d mccsg12_d
#define mleft mccsg12_mleft
#define mright mccsg12_mright
#define mtop mccsg12_mtop
#define mbottom mccsg12_mbottom
#define nhslit mccsg12_nhslit
#define G mccsg12_G
#define aleft mccsg12_aleft
#define aright mccsg12_aright
#define atop mccsg12_atop
#define abottom mccsg12_abottom
#define wavy mccsg12_wavy
#define wavy_z mccsg12_wavy_z
#define wavy_tb mccsg12_wavy_tb
#define wavy_lr mccsg12_wavy_lr
#define chamfers mccsg12_chamfers
#define chamfers_z mccsg12_chamfers_z
#define chamfers_lr mccsg12_chamfers_lr
#define chamfers_tb mccsg12_chamfers_tb
#define nelements mccsg12_nelements
#define nu mccsg12_nu
#define phase mccsg12_phase
#define reflect mccsg12_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16709 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg13' [50]. */
#define mccompcurname  sg13
#define mccompcurtype  Guide_gravity
#define mccompcurindex 50
#define GVars mccsg13_GVars
#define pTable mccsg13_pTable
#define w1 mccsg13_w1
#define h1 mccsg13_h1
#define w2 mccsg13_w2
#define h2 mccsg13_h2
#define l mccsg13_l
#define R0 mccsg13_R0
#define Qc mccsg13_Qc
#define alpha mccsg13_alpha
#define m mccsg13_m
#define W mccsg13_W
#define nslit mccsg13_nslit
#define d mccsg13_d
#define mleft mccsg13_mleft
#define mright mccsg13_mright
#define mtop mccsg13_mtop
#define mbottom mccsg13_mbottom
#define nhslit mccsg13_nhslit
#define G mccsg13_G
#define aleft mccsg13_aleft
#define aright mccsg13_aright
#define atop mccsg13_atop
#define abottom mccsg13_abottom
#define wavy mccsg13_wavy
#define wavy_z mccsg13_wavy_z
#define wavy_tb mccsg13_wavy_tb
#define wavy_lr mccsg13_wavy_lr
#define chamfers mccsg13_chamfers
#define chamfers_z mccsg13_chamfers_z
#define chamfers_lr mccsg13_chamfers_lr
#define chamfers_tb mccsg13_chamfers_tb
#define nelements mccsg13_nelements
#define nu mccsg13_nu
#define phase mccsg13_phase
#define reflect mccsg13_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16793 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg14' [51]. */
#define mccompcurname  sg14
#define mccompcurtype  Guide_gravity
#define mccompcurindex 51
#define GVars mccsg14_GVars
#define pTable mccsg14_pTable
#define w1 mccsg14_w1
#define h1 mccsg14_h1
#define w2 mccsg14_w2
#define h2 mccsg14_h2
#define l mccsg14_l
#define R0 mccsg14_R0
#define Qc mccsg14_Qc
#define alpha mccsg14_alpha
#define m mccsg14_m
#define W mccsg14_W
#define nslit mccsg14_nslit
#define d mccsg14_d
#define mleft mccsg14_mleft
#define mright mccsg14_mright
#define mtop mccsg14_mtop
#define mbottom mccsg14_mbottom
#define nhslit mccsg14_nhslit
#define G mccsg14_G
#define aleft mccsg14_aleft
#define aright mccsg14_aright
#define atop mccsg14_atop
#define abottom mccsg14_abottom
#define wavy mccsg14_wavy
#define wavy_z mccsg14_wavy_z
#define wavy_tb mccsg14_wavy_tb
#define wavy_lr mccsg14_wavy_lr
#define chamfers mccsg14_chamfers
#define chamfers_z mccsg14_chamfers_z
#define chamfers_lr mccsg14_chamfers_lr
#define chamfers_tb mccsg14_chamfers_tb
#define nelements mccsg14_nelements
#define nu mccsg14_nu
#define phase mccsg14_phase
#define reflect mccsg14_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16877 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg15' [52]. */
#define mccompcurname  sg15
#define mccompcurtype  Guide_gravity
#define mccompcurindex 52
#define GVars mccsg15_GVars
#define pTable mccsg15_pTable
#define w1 mccsg15_w1
#define h1 mccsg15_h1
#define w2 mccsg15_w2
#define h2 mccsg15_h2
#define l mccsg15_l
#define R0 mccsg15_R0
#define Qc mccsg15_Qc
#define alpha mccsg15_alpha
#define m mccsg15_m
#define W mccsg15_W
#define nslit mccsg15_nslit
#define d mccsg15_d
#define mleft mccsg15_mleft
#define mright mccsg15_mright
#define mtop mccsg15_mtop
#define mbottom mccsg15_mbottom
#define nhslit mccsg15_nhslit
#define G mccsg15_G
#define aleft mccsg15_aleft
#define aright mccsg15_aright
#define atop mccsg15_atop
#define abottom mccsg15_abottom
#define wavy mccsg15_wavy
#define wavy_z mccsg15_wavy_z
#define wavy_tb mccsg15_wavy_tb
#define wavy_lr mccsg15_wavy_lr
#define chamfers mccsg15_chamfers
#define chamfers_z mccsg15_chamfers_z
#define chamfers_lr mccsg15_chamfers_lr
#define chamfers_tb mccsg15_chamfers_tb
#define nelements mccsg15_nelements
#define nu mccsg15_nu
#define phase mccsg15_phase
#define reflect mccsg15_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 16961 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg16' [53]. */
#define mccompcurname  sg16
#define mccompcurtype  Guide_gravity
#define mccompcurindex 53
#define GVars mccsg16_GVars
#define pTable mccsg16_pTable
#define w1 mccsg16_w1
#define h1 mccsg16_h1
#define w2 mccsg16_w2
#define h2 mccsg16_h2
#define l mccsg16_l
#define R0 mccsg16_R0
#define Qc mccsg16_Qc
#define alpha mccsg16_alpha
#define m mccsg16_m
#define W mccsg16_W
#define nslit mccsg16_nslit
#define d mccsg16_d
#define mleft mccsg16_mleft
#define mright mccsg16_mright
#define mtop mccsg16_mtop
#define mbottom mccsg16_mbottom
#define nhslit mccsg16_nhslit
#define G mccsg16_G
#define aleft mccsg16_aleft
#define aright mccsg16_aright
#define atop mccsg16_atop
#define abottom mccsg16_abottom
#define wavy mccsg16_wavy
#define wavy_z mccsg16_wavy_z
#define wavy_tb mccsg16_wavy_tb
#define wavy_lr mccsg16_wavy_lr
#define chamfers mccsg16_chamfers
#define chamfers_z mccsg16_chamfers_z
#define chamfers_lr mccsg16_chamfers_lr
#define chamfers_tb mccsg16_chamfers_tb
#define nelements mccsg16_nelements
#define nu mccsg16_nu
#define phase mccsg16_phase
#define reflect mccsg16_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17045 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg17' [54]. */
#define mccompcurname  sg17
#define mccompcurtype  Guide_gravity
#define mccompcurindex 54
#define GVars mccsg17_GVars
#define pTable mccsg17_pTable
#define w1 mccsg17_w1
#define h1 mccsg17_h1
#define w2 mccsg17_w2
#define h2 mccsg17_h2
#define l mccsg17_l
#define R0 mccsg17_R0
#define Qc mccsg17_Qc
#define alpha mccsg17_alpha
#define m mccsg17_m
#define W mccsg17_W
#define nslit mccsg17_nslit
#define d mccsg17_d
#define mleft mccsg17_mleft
#define mright mccsg17_mright
#define mtop mccsg17_mtop
#define mbottom mccsg17_mbottom
#define nhslit mccsg17_nhslit
#define G mccsg17_G
#define aleft mccsg17_aleft
#define aright mccsg17_aright
#define atop mccsg17_atop
#define abottom mccsg17_abottom
#define wavy mccsg17_wavy
#define wavy_z mccsg17_wavy_z
#define wavy_tb mccsg17_wavy_tb
#define wavy_lr mccsg17_wavy_lr
#define chamfers mccsg17_chamfers
#define chamfers_z mccsg17_chamfers_z
#define chamfers_lr mccsg17_chamfers_lr
#define chamfers_tb mccsg17_chamfers_tb
#define nelements mccsg17_nelements
#define nu mccsg17_nu
#define phase mccsg17_phase
#define reflect mccsg17_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17129 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg18' [55]. */
#define mccompcurname  sg18
#define mccompcurtype  Guide_gravity
#define mccompcurindex 55
#define GVars mccsg18_GVars
#define pTable mccsg18_pTable
#define w1 mccsg18_w1
#define h1 mccsg18_h1
#define w2 mccsg18_w2
#define h2 mccsg18_h2
#define l mccsg18_l
#define R0 mccsg18_R0
#define Qc mccsg18_Qc
#define alpha mccsg18_alpha
#define m mccsg18_m
#define W mccsg18_W
#define nslit mccsg18_nslit
#define d mccsg18_d
#define mleft mccsg18_mleft
#define mright mccsg18_mright
#define mtop mccsg18_mtop
#define mbottom mccsg18_mbottom
#define nhslit mccsg18_nhslit
#define G mccsg18_G
#define aleft mccsg18_aleft
#define aright mccsg18_aright
#define atop mccsg18_atop
#define abottom mccsg18_abottom
#define wavy mccsg18_wavy
#define wavy_z mccsg18_wavy_z
#define wavy_tb mccsg18_wavy_tb
#define wavy_lr mccsg18_wavy_lr
#define chamfers mccsg18_chamfers
#define chamfers_z mccsg18_chamfers_z
#define chamfers_lr mccsg18_chamfers_lr
#define chamfers_tb mccsg18_chamfers_tb
#define nelements mccsg18_nelements
#define nu mccsg18_nu
#define phase mccsg18_phase
#define reflect mccsg18_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17213 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg19' [56]. */
#define mccompcurname  sg19
#define mccompcurtype  Guide_gravity
#define mccompcurindex 56
#define GVars mccsg19_GVars
#define pTable mccsg19_pTable
#define w1 mccsg19_w1
#define h1 mccsg19_h1
#define w2 mccsg19_w2
#define h2 mccsg19_h2
#define l mccsg19_l
#define R0 mccsg19_R0
#define Qc mccsg19_Qc
#define alpha mccsg19_alpha
#define m mccsg19_m
#define W mccsg19_W
#define nslit mccsg19_nslit
#define d mccsg19_d
#define mleft mccsg19_mleft
#define mright mccsg19_mright
#define mtop mccsg19_mtop
#define mbottom mccsg19_mbottom
#define nhslit mccsg19_nhslit
#define G mccsg19_G
#define aleft mccsg19_aleft
#define aright mccsg19_aright
#define atop mccsg19_atop
#define abottom mccsg19_abottom
#define wavy mccsg19_wavy
#define wavy_z mccsg19_wavy_z
#define wavy_tb mccsg19_wavy_tb
#define wavy_lr mccsg19_wavy_lr
#define chamfers mccsg19_chamfers
#define chamfers_z mccsg19_chamfers_z
#define chamfers_lr mccsg19_chamfers_lr
#define chamfers_tb mccsg19_chamfers_tb
#define nelements mccsg19_nelements
#define nu mccsg19_nu
#define phase mccsg19_phase
#define reflect mccsg19_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17297 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg20' [57]. */
#define mccompcurname  sg20
#define mccompcurtype  Guide_gravity
#define mccompcurindex 57
#define GVars mccsg20_GVars
#define pTable mccsg20_pTable
#define w1 mccsg20_w1
#define h1 mccsg20_h1
#define w2 mccsg20_w2
#define h2 mccsg20_h2
#define l mccsg20_l
#define R0 mccsg20_R0
#define Qc mccsg20_Qc
#define alpha mccsg20_alpha
#define m mccsg20_m
#define W mccsg20_W
#define nslit mccsg20_nslit
#define d mccsg20_d
#define mleft mccsg20_mleft
#define mright mccsg20_mright
#define mtop mccsg20_mtop
#define mbottom mccsg20_mbottom
#define nhslit mccsg20_nhslit
#define G mccsg20_G
#define aleft mccsg20_aleft
#define aright mccsg20_aright
#define atop mccsg20_atop
#define abottom mccsg20_abottom
#define wavy mccsg20_wavy
#define wavy_z mccsg20_wavy_z
#define wavy_tb mccsg20_wavy_tb
#define wavy_lr mccsg20_wavy_lr
#define chamfers mccsg20_chamfers
#define chamfers_z mccsg20_chamfers_z
#define chamfers_lr mccsg20_chamfers_lr
#define chamfers_tb mccsg20_chamfers_tb
#define nelements mccsg20_nelements
#define nu mccsg20_nu
#define phase mccsg20_phase
#define reflect mccsg20_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17381 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg21' [58]. */
#define mccompcurname  sg21
#define mccompcurtype  Guide_gravity
#define mccompcurindex 58
#define GVars mccsg21_GVars
#define pTable mccsg21_pTable
#define w1 mccsg21_w1
#define h1 mccsg21_h1
#define w2 mccsg21_w2
#define h2 mccsg21_h2
#define l mccsg21_l
#define R0 mccsg21_R0
#define Qc mccsg21_Qc
#define alpha mccsg21_alpha
#define m mccsg21_m
#define W mccsg21_W
#define nslit mccsg21_nslit
#define d mccsg21_d
#define mleft mccsg21_mleft
#define mright mccsg21_mright
#define mtop mccsg21_mtop
#define mbottom mccsg21_mbottom
#define nhslit mccsg21_nhslit
#define G mccsg21_G
#define aleft mccsg21_aleft
#define aright mccsg21_aright
#define atop mccsg21_atop
#define abottom mccsg21_abottom
#define wavy mccsg21_wavy
#define wavy_z mccsg21_wavy_z
#define wavy_tb mccsg21_wavy_tb
#define wavy_lr mccsg21_wavy_lr
#define chamfers mccsg21_chamfers
#define chamfers_z mccsg21_chamfers_z
#define chamfers_lr mccsg21_chamfers_lr
#define chamfers_tb mccsg21_chamfers_tb
#define nelements mccsg21_nelements
#define nu mccsg21_nu
#define phase mccsg21_phase
#define reflect mccsg21_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17465 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg22' [59]. */
#define mccompcurname  sg22
#define mccompcurtype  Guide_gravity
#define mccompcurindex 59
#define GVars mccsg22_GVars
#define pTable mccsg22_pTable
#define w1 mccsg22_w1
#define h1 mccsg22_h1
#define w2 mccsg22_w2
#define h2 mccsg22_h2
#define l mccsg22_l
#define R0 mccsg22_R0
#define Qc mccsg22_Qc
#define alpha mccsg22_alpha
#define m mccsg22_m
#define W mccsg22_W
#define nslit mccsg22_nslit
#define d mccsg22_d
#define mleft mccsg22_mleft
#define mright mccsg22_mright
#define mtop mccsg22_mtop
#define mbottom mccsg22_mbottom
#define nhslit mccsg22_nhslit
#define G mccsg22_G
#define aleft mccsg22_aleft
#define aright mccsg22_aright
#define atop mccsg22_atop
#define abottom mccsg22_abottom
#define wavy mccsg22_wavy
#define wavy_z mccsg22_wavy_z
#define wavy_tb mccsg22_wavy_tb
#define wavy_lr mccsg22_wavy_lr
#define chamfers mccsg22_chamfers
#define chamfers_z mccsg22_chamfers_z
#define chamfers_lr mccsg22_chamfers_lr
#define chamfers_tb mccsg22_chamfers_tb
#define nelements mccsg22_nelements
#define nu mccsg22_nu
#define phase mccsg22_phase
#define reflect mccsg22_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17549 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PSD_IN6' [61]. */
#define mccompcurname  PSD_IN6
#define mccompcurtype  Monitor_nD
#define mccompcurindex 61
#define user1 mccPSD_IN6_user1
#define user2 mccPSD_IN6_user2
#define user3 mccPSD_IN6_user3
#define DEFS mccPSD_IN6_DEFS
#define Vars mccPSD_IN6_Vars
#define detector mccPSD_IN6_detector
#define offdata mccPSD_IN6_offdata
#define xwidth mccPSD_IN6_xwidth
#define yheight mccPSD_IN6_yheight
#define zdepth mccPSD_IN6_zdepth
#define xmin mccPSD_IN6_xmin
#define xmax mccPSD_IN6_xmax
#define ymin mccPSD_IN6_ymin
#define ymax mccPSD_IN6_ymax
#define zmin mccPSD_IN6_zmin
#define zmax mccPSD_IN6_zmax
#define bins mccPSD_IN6_bins
#define min mccPSD_IN6_min
#define max mccPSD_IN6_max
#define restore_neutron mccPSD_IN6_restore_neutron
#define radius mccPSD_IN6_radius
#define options mccPSD_IN6_options
#define filename mccPSD_IN6_filename
#define geometry mccPSD_IN6_geometry
#define username1 mccPSD_IN6_username1
#define username2 mccPSD_IN6_username2
#define username3 mccPSD_IN6_username3
#define nowritefile mccPSD_IN6_nowritefile
#line 224 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
  MonitornD_Defines_type DEFS;
  MonitornD_Variables_type Vars;
  MCDETECTOR detector;
  off_struct offdata;
#line 17627 "ILL_H15_D11.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'IN6toD7GuideStart' [63]. */
#define mccompcurname  IN6toD7GuideStart
#define mccompcurtype  Arm
#define mccompcurindex 63
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg23' [64]. */
#define mccompcurname  sg23
#define mccompcurtype  Guide_gravity
#define mccompcurindex 64
#define GVars mccsg23_GVars
#define pTable mccsg23_pTable
#define w1 mccsg23_w1
#define h1 mccsg23_h1
#define w2 mccsg23_w2
#define h2 mccsg23_h2
#define l mccsg23_l
#define R0 mccsg23_R0
#define Qc mccsg23_Qc
#define alpha mccsg23_alpha
#define m mccsg23_m
#define W mccsg23_W
#define nslit mccsg23_nslit
#define d mccsg23_d
#define mleft mccsg23_mleft
#define mright mccsg23_mright
#define mtop mccsg23_mtop
#define mbottom mccsg23_mbottom
#define nhslit mccsg23_nhslit
#define G mccsg23_G
#define aleft mccsg23_aleft
#define aright mccsg23_aright
#define atop mccsg23_atop
#define abottom mccsg23_abottom
#define wavy mccsg23_wavy
#define wavy_z mccsg23_wavy_z
#define wavy_tb mccsg23_wavy_tb
#define wavy_lr mccsg23_wavy_lr
#define chamfers mccsg23_chamfers
#define chamfers_z mccsg23_chamfers_z
#define chamfers_lr mccsg23_chamfers_lr
#define chamfers_tb mccsg23_chamfers_tb
#define nelements mccsg23_nelements
#define nu mccsg23_nu
#define phase mccsg23_phase
#define reflect mccsg23_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17711 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg24' [65]. */
#define mccompcurname  sg24
#define mccompcurtype  Guide_gravity
#define mccompcurindex 65
#define GVars mccsg24_GVars
#define pTable mccsg24_pTable
#define w1 mccsg24_w1
#define h1 mccsg24_h1
#define w2 mccsg24_w2
#define h2 mccsg24_h2
#define l mccsg24_l
#define R0 mccsg24_R0
#define Qc mccsg24_Qc
#define alpha mccsg24_alpha
#define m mccsg24_m
#define W mccsg24_W
#define nslit mccsg24_nslit
#define d mccsg24_d
#define mleft mccsg24_mleft
#define mright mccsg24_mright
#define mtop mccsg24_mtop
#define mbottom mccsg24_mbottom
#define nhslit mccsg24_nhslit
#define G mccsg24_G
#define aleft mccsg24_aleft
#define aright mccsg24_aright
#define atop mccsg24_atop
#define abottom mccsg24_abottom
#define wavy mccsg24_wavy
#define wavy_z mccsg24_wavy_z
#define wavy_tb mccsg24_wavy_tb
#define wavy_lr mccsg24_wavy_lr
#define chamfers mccsg24_chamfers
#define chamfers_z mccsg24_chamfers_z
#define chamfers_lr mccsg24_chamfers_lr
#define chamfers_tb mccsg24_chamfers_tb
#define nelements mccsg24_nelements
#define nu mccsg24_nu
#define phase mccsg24_phase
#define reflect mccsg24_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17795 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg25' [66]. */
#define mccompcurname  sg25
#define mccompcurtype  Guide_gravity
#define mccompcurindex 66
#define GVars mccsg25_GVars
#define pTable mccsg25_pTable
#define w1 mccsg25_w1
#define h1 mccsg25_h1
#define w2 mccsg25_w2
#define h2 mccsg25_h2
#define l mccsg25_l
#define R0 mccsg25_R0
#define Qc mccsg25_Qc
#define alpha mccsg25_alpha
#define m mccsg25_m
#define W mccsg25_W
#define nslit mccsg25_nslit
#define d mccsg25_d
#define mleft mccsg25_mleft
#define mright mccsg25_mright
#define mtop mccsg25_mtop
#define mbottom mccsg25_mbottom
#define nhslit mccsg25_nhslit
#define G mccsg25_G
#define aleft mccsg25_aleft
#define aright mccsg25_aright
#define atop mccsg25_atop
#define abottom mccsg25_abottom
#define wavy mccsg25_wavy
#define wavy_z mccsg25_wavy_z
#define wavy_tb mccsg25_wavy_tb
#define wavy_lr mccsg25_wavy_lr
#define chamfers mccsg25_chamfers
#define chamfers_z mccsg25_chamfers_z
#define chamfers_lr mccsg25_chamfers_lr
#define chamfers_tb mccsg25_chamfers_tb
#define nelements mccsg25_nelements
#define nu mccsg25_nu
#define phase mccsg25_phase
#define reflect mccsg25_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17879 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg26' [67]. */
#define mccompcurname  sg26
#define mccompcurtype  Guide_gravity
#define mccompcurindex 67
#define GVars mccsg26_GVars
#define pTable mccsg26_pTable
#define w1 mccsg26_w1
#define h1 mccsg26_h1
#define w2 mccsg26_w2
#define h2 mccsg26_h2
#define l mccsg26_l
#define R0 mccsg26_R0
#define Qc mccsg26_Qc
#define alpha mccsg26_alpha
#define m mccsg26_m
#define W mccsg26_W
#define nslit mccsg26_nslit
#define d mccsg26_d
#define mleft mccsg26_mleft
#define mright mccsg26_mright
#define mtop mccsg26_mtop
#define mbottom mccsg26_mbottom
#define nhslit mccsg26_nhslit
#define G mccsg26_G
#define aleft mccsg26_aleft
#define aright mccsg26_aright
#define atop mccsg26_atop
#define abottom mccsg26_abottom
#define wavy mccsg26_wavy
#define wavy_z mccsg26_wavy_z
#define wavy_tb mccsg26_wavy_tb
#define wavy_lr mccsg26_wavy_lr
#define chamfers mccsg26_chamfers
#define chamfers_z mccsg26_chamfers_z
#define chamfers_lr mccsg26_chamfers_lr
#define chamfers_tb mccsg26_chamfers_tb
#define nelements mccsg26_nelements
#define nu mccsg26_nu
#define phase mccsg26_phase
#define reflect mccsg26_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 17963 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg27' [68]. */
#define mccompcurname  sg27
#define mccompcurtype  Guide_gravity
#define mccompcurindex 68
#define GVars mccsg27_GVars
#define pTable mccsg27_pTable
#define w1 mccsg27_w1
#define h1 mccsg27_h1
#define w2 mccsg27_w2
#define h2 mccsg27_h2
#define l mccsg27_l
#define R0 mccsg27_R0
#define Qc mccsg27_Qc
#define alpha mccsg27_alpha
#define m mccsg27_m
#define W mccsg27_W
#define nslit mccsg27_nslit
#define d mccsg27_d
#define mleft mccsg27_mleft
#define mright mccsg27_mright
#define mtop mccsg27_mtop
#define mbottom mccsg27_mbottom
#define nhslit mccsg27_nhslit
#define G mccsg27_G
#define aleft mccsg27_aleft
#define aright mccsg27_aright
#define atop mccsg27_atop
#define abottom mccsg27_abottom
#define wavy mccsg27_wavy
#define wavy_z mccsg27_wavy_z
#define wavy_tb mccsg27_wavy_tb
#define wavy_lr mccsg27_wavy_lr
#define chamfers mccsg27_chamfers
#define chamfers_z mccsg27_chamfers_z
#define chamfers_lr mccsg27_chamfers_lr
#define chamfers_tb mccsg27_chamfers_tb
#define nelements mccsg27_nelements
#define nu mccsg27_nu
#define phase mccsg27_phase
#define reflect mccsg27_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 18047 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'PSD_D7' [70]. */
#define mccompcurname  PSD_D7
#define mccompcurtype  Monitor_nD
#define mccompcurindex 70
#define user1 mccPSD_D7_user1
#define user2 mccPSD_D7_user2
#define user3 mccPSD_D7_user3
#define DEFS mccPSD_D7_DEFS
#define Vars mccPSD_D7_Vars
#define detector mccPSD_D7_detector
#define offdata mccPSD_D7_offdata
#define xwidth mccPSD_D7_xwidth
#define yheight mccPSD_D7_yheight
#define zdepth mccPSD_D7_zdepth
#define xmin mccPSD_D7_xmin
#define xmax mccPSD_D7_xmax
#define ymin mccPSD_D7_ymin
#define ymax mccPSD_D7_ymax
#define zmin mccPSD_D7_zmin
#define zmax mccPSD_D7_zmax
#define bins mccPSD_D7_bins
#define min mccPSD_D7_min
#define max mccPSD_D7_max
#define restore_neutron mccPSD_D7_restore_neutron
#define radius mccPSD_D7_radius
#define options mccPSD_D7_options
#define filename mccPSD_D7_filename
#define geometry mccPSD_D7_geometry
#define username1 mccPSD_D7_username1
#define username2 mccPSD_D7_username2
#define username3 mccPSD_D7_username3
#define nowritefile mccPSD_D7_nowritefile
#line 224 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
  MonitornD_Defines_type DEFS;
  MonitornD_Variables_type Vars;
  MCDETECTOR detector;
  off_struct offdata;
#line 18125 "ILL_H15_D11.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'D7toD11GuideStart' [72]. */
#define mccompcurname  D7toD11GuideStart
#define mccompcurtype  Arm
#define mccompcurindex 72
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg28' [73]. */
#define mccompcurname  sg28
#define mccompcurtype  Guide_gravity
#define mccompcurindex 73
#define GVars mccsg28_GVars
#define pTable mccsg28_pTable
#define w1 mccsg28_w1
#define h1 mccsg28_h1
#define w2 mccsg28_w2
#define h2 mccsg28_h2
#define l mccsg28_l
#define R0 mccsg28_R0
#define Qc mccsg28_Qc
#define alpha mccsg28_alpha
#define m mccsg28_m
#define W mccsg28_W
#define nslit mccsg28_nslit
#define d mccsg28_d
#define mleft mccsg28_mleft
#define mright mccsg28_mright
#define mtop mccsg28_mtop
#define mbottom mccsg28_mbottom
#define nhslit mccsg28_nhslit
#define G mccsg28_G
#define aleft mccsg28_aleft
#define aright mccsg28_aright
#define atop mccsg28_atop
#define abottom mccsg28_abottom
#define wavy mccsg28_wavy
#define wavy_z mccsg28_wavy_z
#define wavy_tb mccsg28_wavy_tb
#define wavy_lr mccsg28_wavy_lr
#define chamfers mccsg28_chamfers
#define chamfers_z mccsg28_chamfers_z
#define chamfers_lr mccsg28_chamfers_lr
#define chamfers_tb mccsg28_chamfers_tb
#define nelements mccsg28_nelements
#define nu mccsg28_nu
#define phase mccsg28_phase
#define reflect mccsg28_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 18209 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg29' [74]. */
#define mccompcurname  sg29
#define mccompcurtype  Guide_gravity
#define mccompcurindex 74
#define GVars mccsg29_GVars
#define pTable mccsg29_pTable
#define w1 mccsg29_w1
#define h1 mccsg29_h1
#define w2 mccsg29_w2
#define h2 mccsg29_h2
#define l mccsg29_l
#define R0 mccsg29_R0
#define Qc mccsg29_Qc
#define alpha mccsg29_alpha
#define m mccsg29_m
#define W mccsg29_W
#define nslit mccsg29_nslit
#define d mccsg29_d
#define mleft mccsg29_mleft
#define mright mccsg29_mright
#define mtop mccsg29_mtop
#define mbottom mccsg29_mbottom
#define nhslit mccsg29_nhslit
#define G mccsg29_G
#define aleft mccsg29_aleft
#define aright mccsg29_aright
#define atop mccsg29_atop
#define abottom mccsg29_abottom
#define wavy mccsg29_wavy
#define wavy_z mccsg29_wavy_z
#define wavy_tb mccsg29_wavy_tb
#define wavy_lr mccsg29_wavy_lr
#define chamfers mccsg29_chamfers
#define chamfers_z mccsg29_chamfers_z
#define chamfers_lr mccsg29_chamfers_lr
#define chamfers_tb mccsg29_chamfers_tb
#define nelements mccsg29_nelements
#define nu mccsg29_nu
#define phase mccsg29_phase
#define reflect mccsg29_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 18293 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Mon_D11_In' [76]. */
#define mccompcurname  Mon_D11_In
#define mccompcurtype  Monitor_nD
#define mccompcurindex 76
#define user1 mccMon_D11_In_user1
#define user2 mccMon_D11_In_user2
#define user3 mccMon_D11_In_user3
#define DEFS mccMon_D11_In_DEFS
#define Vars mccMon_D11_In_Vars
#define detector mccMon_D11_In_detector
#define offdata mccMon_D11_In_offdata
#define xwidth mccMon_D11_In_xwidth
#define yheight mccMon_D11_In_yheight
#define zdepth mccMon_D11_In_zdepth
#define xmin mccMon_D11_In_xmin
#define xmax mccMon_D11_In_xmax
#define ymin mccMon_D11_In_ymin
#define ymax mccMon_D11_In_ymax
#define zmin mccMon_D11_In_zmin
#define zmax mccMon_D11_In_zmax
#define bins mccMon_D11_In_bins
#define min mccMon_D11_In_min
#define max mccMon_D11_In_max
#define restore_neutron mccMon_D11_In_restore_neutron
#define radius mccMon_D11_In_radius
#define options mccMon_D11_In_options
#define filename mccMon_D11_In_filename
#define geometry mccMon_D11_In_geometry
#define username1 mccMon_D11_In_username1
#define username2 mccMon_D11_In_username2
#define username3 mccMon_D11_In_username3
#define nowritefile mccMon_D11_In_nowritefile
#line 224 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
  MonitornD_Defines_type DEFS;
  MonitornD_Variables_type Vars;
  MCDETECTOR detector;
  off_struct offdata;
#line 18371 "ILL_H15_D11.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Dolores' [77]. */
#define mccompcurname  Dolores
#define mccompcurtype  V_selector
#define mccompcurindex 77
#define omega mccDolores_omega
#define alpha_rad mccDolores_alpha_rad
#define dt0 mccDolores_dt0
#define dt1 mccDolores_dt1
#define r_i mccDolores_r_i
#define r_f mccDolores_r_f
#define r_mean mccDolores_r_mean
#define theta_i mccDolores_theta_i
#define theta_f mccDolores_theta_f
#define A mccDolores_A
#define d_s_alpha mccDolores_d_s_alpha
#define xwidth mccDolores_xwidth
#define yheight mccDolores_yheight
#define zdepth mccDolores_zdepth
#define radius mccDolores_radius
#define alpha mccDolores_alpha
#define length mccDolores_length
#define d mccDolores_d
#define nu mccDolores_nu
#define nslit mccDolores_nslit
#line 58 "/usr/share/mcstas/2.6rc1/optics/V_selector.comp"
double omega, alpha_rad, dt0, dt1, r_i, r_f, r_mean, theta_i, theta_f, A, d_s_alpha;
#line 18430 "ILL_H15_D11.c"
#undef nslit
#undef nu
#undef d
#undef length
#undef alpha
#undef radius
#undef zdepth
#undef yheight
#undef xwidth
#undef d_s_alpha
#undef A
#undef theta_f
#undef theta_i
#undef r_mean
#undef r_f
#undef r_i
#undef dt1
#undef dt0
#undef alpha_rad
#undef omega
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'sg30' [79]. */
#define mccompcurname  sg30
#define mccompcurtype  Guide_gravity
#define mccompcurindex 79
#define GVars mccsg30_GVars
#define pTable mccsg30_pTable
#define w1 mccsg30_w1
#define h1 mccsg30_h1
#define w2 mccsg30_w2
#define h2 mccsg30_h2
#define l mccsg30_l
#define R0 mccsg30_R0
#define Qc mccsg30_Qc
#define alpha mccsg30_alpha
#define m mccsg30_m
#define W mccsg30_W
#define nslit mccsg30_nslit
#define d mccsg30_d
#define mleft mccsg30_mleft
#define mright mccsg30_mright
#define mtop mccsg30_mtop
#define mbottom mccsg30_mbottom
#define nhslit mccsg30_nhslit
#define G mccsg30_G
#define aleft mccsg30_aleft
#define aright mccsg30_aright
#define atop mccsg30_atop
#define abottom mccsg30_abottom
#define wavy mccsg30_wavy
#define wavy_z mccsg30_wavy_z
#define wavy_tb mccsg30_wavy_tb
#define wavy_lr mccsg30_wavy_lr
#define chamfers mccsg30_chamfers
#define chamfers_z mccsg30_chamfers_z
#define chamfers_lr mccsg30_chamfers_lr
#define chamfers_tb mccsg30_chamfers_tb
#define nelements mccsg30_nelements
#define nu mccsg30_nu
#define phase mccsg30_phase
#define reflect mccsg30_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 18498 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'Mon_D11_Out' [81]. */
#define mccompcurname  Mon_D11_Out
#define mccompcurtype  Monitor_nD
#define mccompcurindex 81
#define user1 mccMon_D11_Out_user1
#define user2 mccMon_D11_Out_user2
#define user3 mccMon_D11_Out_user3
#define DEFS mccMon_D11_Out_DEFS
#define Vars mccMon_D11_Out_Vars
#define detector mccMon_D11_Out_detector
#define offdata mccMon_D11_Out_offdata
#define xwidth mccMon_D11_Out_xwidth
#define yheight mccMon_D11_Out_yheight
#define zdepth mccMon_D11_Out_zdepth
#define xmin mccMon_D11_Out_xmin
#define xmax mccMon_D11_Out_xmax
#define ymin mccMon_D11_Out_ymin
#define ymax mccMon_D11_Out_ymax
#define zmin mccMon_D11_Out_zmin
#define zmax mccMon_D11_Out_zmax
#define bins mccMon_D11_Out_bins
#define min mccMon_D11_Out_min
#define max mccMon_D11_Out_max
#define restore_neutron mccMon_D11_Out_restore_neutron
#define radius mccMon_D11_Out_radius
#define options mccMon_D11_Out_options
#define filename mccMon_D11_Out_filename
#define geometry mccMon_D11_Out_geometry
#define username1 mccMon_D11_Out_username1
#define username2 mccMon_D11_Out_username2
#define username3 mccMon_D11_Out_username3
#define nowritefile mccMon_D11_Out_nowritefile
#line 224 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
  MonitornD_Defines_type DEFS;
  MonitornD_Variables_type Vars;
  MCDETECTOR detector;
  off_struct offdata;
#line 18576 "ILL_H15_D11.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'MovableGuideStart' [83]. */
#define mccompcurname  MovableGuideStart
#define mccompcurtype  Arm
#define mccompcurindex 83
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'mg0' [84]. */
#define mccompcurname  mg0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 84
#define GVars mccmg0_GVars
#define pTable mccmg0_pTable
#define w1 mccmg0_w1
#define h1 mccmg0_h1
#define w2 mccmg0_w2
#define h2 mccmg0_h2
#define l mccmg0_l
#define R0 mccmg0_R0
#define Qc mccmg0_Qc
#define alpha mccmg0_alpha
#define m mccmg0_m
#define W mccmg0_W
#define nslit mccmg0_nslit
#define d mccmg0_d
#define mleft mccmg0_mleft
#define mright mccmg0_mright
#define mtop mccmg0_mtop
#define mbottom mccmg0_mbottom
#define nhslit mccmg0_nhslit
#define G mccmg0_G
#define aleft mccmg0_aleft
#define aright mccmg0_aright
#define atop mccmg0_atop
#define abottom mccmg0_abottom
#define wavy mccmg0_wavy
#define wavy_z mccmg0_wavy_z
#define wavy_tb mccmg0_wavy_tb
#define wavy_lr mccmg0_wavy_lr
#define chamfers mccmg0_chamfers
#define chamfers_z mccmg0_chamfers_z
#define chamfers_lr mccmg0_chamfers_lr
#define chamfers_tb mccmg0_chamfers_tb
#define nelements mccmg0_nelements
#define nu mccmg0_nu
#define phase mccmg0_phase
#define reflect mccmg0_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 18660 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'mg1' [85]. */
#define mccompcurname  mg1
#define mccompcurtype  Guide_gravity
#define mccompcurindex 85
#define GVars mccmg1_GVars
#define pTable mccmg1_pTable
#define w1 mccmg1_w1
#define h1 mccmg1_h1
#define w2 mccmg1_w2
#define h2 mccmg1_h2
#define l mccmg1_l
#define R0 mccmg1_R0
#define Qc mccmg1_Qc
#define alpha mccmg1_alpha
#define m mccmg1_m
#define W mccmg1_W
#define nslit mccmg1_nslit
#define d mccmg1_d
#define mleft mccmg1_mleft
#define mright mccmg1_mright
#define mtop mccmg1_mtop
#define mbottom mccmg1_mbottom
#define nhslit mccmg1_nhslit
#define G mccmg1_G
#define aleft mccmg1_aleft
#define aright mccmg1_aright
#define atop mccmg1_atop
#define abottom mccmg1_abottom
#define wavy mccmg1_wavy
#define wavy_z mccmg1_wavy_z
#define wavy_tb mccmg1_wavy_tb
#define wavy_lr mccmg1_wavy_lr
#define chamfers mccmg1_chamfers
#define chamfers_z mccmg1_chamfers_z
#define chamfers_lr mccmg1_chamfers_lr
#define chamfers_tb mccmg1_chamfers_tb
#define nelements mccmg1_nelements
#define nu mccmg1_nu
#define phase mccmg1_phase
#define reflect mccmg1_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 18744 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'mg2' [86]. */
#define mccompcurname  mg2
#define mccompcurtype  Guide_gravity
#define mccompcurindex 86
#define GVars mccmg2_GVars
#define pTable mccmg2_pTable
#define w1 mccmg2_w1
#define h1 mccmg2_h1
#define w2 mccmg2_w2
#define h2 mccmg2_h2
#define l mccmg2_l
#define R0 mccmg2_R0
#define Qc mccmg2_Qc
#define alpha mccmg2_alpha
#define m mccmg2_m
#define W mccmg2_W
#define nslit mccmg2_nslit
#define d mccmg2_d
#define mleft mccmg2_mleft
#define mright mccmg2_mright
#define mtop mccmg2_mtop
#define mbottom mccmg2_mbottom
#define nhslit mccmg2_nhslit
#define G mccmg2_G
#define aleft mccmg2_aleft
#define aright mccmg2_aright
#define atop mccmg2_atop
#define abottom mccmg2_abottom
#define wavy mccmg2_wavy
#define wavy_z mccmg2_wavy_z
#define wavy_tb mccmg2_wavy_tb
#define wavy_lr mccmg2_wavy_lr
#define chamfers mccmg2_chamfers
#define chamfers_z mccmg2_chamfers_z
#define chamfers_lr mccmg2_chamfers_lr
#define chamfers_tb mccmg2_chamfers_tb
#define nelements mccmg2_nelements
#define nu mccmg2_nu
#define phase mccmg2_phase
#define reflect mccmg2_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 18828 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'mg3' [87]. */
#define mccompcurname  mg3
#define mccompcurtype  Guide_gravity
#define mccompcurindex 87
#define GVars mccmg3_GVars
#define pTable mccmg3_pTable
#define w1 mccmg3_w1
#define h1 mccmg3_h1
#define w2 mccmg3_w2
#define h2 mccmg3_h2
#define l mccmg3_l
#define R0 mccmg3_R0
#define Qc mccmg3_Qc
#define alpha mccmg3_alpha
#define m mccmg3_m
#define W mccmg3_W
#define nslit mccmg3_nslit
#define d mccmg3_d
#define mleft mccmg3_mleft
#define mright mccmg3_mright
#define mtop mccmg3_mtop
#define mbottom mccmg3_mbottom
#define nhslit mccmg3_nhslit
#define G mccmg3_G
#define aleft mccmg3_aleft
#define aright mccmg3_aright
#define atop mccmg3_atop
#define abottom mccmg3_abottom
#define wavy mccmg3_wavy
#define wavy_z mccmg3_wavy_z
#define wavy_tb mccmg3_wavy_tb
#define wavy_lr mccmg3_wavy_lr
#define chamfers mccmg3_chamfers
#define chamfers_z mccmg3_chamfers_z
#define chamfers_lr mccmg3_chamfers_lr
#define chamfers_tb mccmg3_chamfers_tb
#define nelements mccmg3_nelements
#define nu mccmg3_nu
#define phase mccmg3_phase
#define reflect mccmg3_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 18912 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'mg4' [88]. */
#define mccompcurname  mg4
#define mccompcurtype  Guide_gravity
#define mccompcurindex 88
#define GVars mccmg4_GVars
#define pTable mccmg4_pTable
#define w1 mccmg4_w1
#define h1 mccmg4_h1
#define w2 mccmg4_w2
#define h2 mccmg4_h2
#define l mccmg4_l
#define R0 mccmg4_R0
#define Qc mccmg4_Qc
#define alpha mccmg4_alpha
#define m mccmg4_m
#define W mccmg4_W
#define nslit mccmg4_nslit
#define d mccmg4_d
#define mleft mccmg4_mleft
#define mright mccmg4_mright
#define mtop mccmg4_mtop
#define mbottom mccmg4_mbottom
#define nhslit mccmg4_nhslit
#define G mccmg4_G
#define aleft mccmg4_aleft
#define aright mccmg4_aright
#define atop mccmg4_atop
#define abottom mccmg4_abottom
#define wavy mccmg4_wavy
#define wavy_z mccmg4_wavy_z
#define wavy_tb mccmg4_wavy_tb
#define wavy_lr mccmg4_wavy_lr
#define chamfers mccmg4_chamfers
#define chamfers_z mccmg4_chamfers_z
#define chamfers_lr mccmg4_chamfers_lr
#define chamfers_tb mccmg4_chamfers_tb
#define nelements mccmg4_nelements
#define nu mccmg4_nu
#define phase mccmg4_phase
#define reflect mccmg4_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 18996 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'mg5' [89]. */
#define mccompcurname  mg5
#define mccompcurtype  Guide_gravity
#define mccompcurindex 89
#define GVars mccmg5_GVars
#define pTable mccmg5_pTable
#define w1 mccmg5_w1
#define h1 mccmg5_h1
#define w2 mccmg5_w2
#define h2 mccmg5_h2
#define l mccmg5_l
#define R0 mccmg5_R0
#define Qc mccmg5_Qc
#define alpha mccmg5_alpha
#define m mccmg5_m
#define W mccmg5_W
#define nslit mccmg5_nslit
#define d mccmg5_d
#define mleft mccmg5_mleft
#define mright mccmg5_mright
#define mtop mccmg5_mtop
#define mbottom mccmg5_mbottom
#define nhslit mccmg5_nhslit
#define G mccmg5_G
#define aleft mccmg5_aleft
#define aright mccmg5_aright
#define atop mccmg5_atop
#define abottom mccmg5_abottom
#define wavy mccmg5_wavy
#define wavy_z mccmg5_wavy_z
#define wavy_tb mccmg5_wavy_tb
#define wavy_lr mccmg5_wavy_lr
#define chamfers mccmg5_chamfers
#define chamfers_z mccmg5_chamfers_z
#define chamfers_lr mccmg5_chamfers_lr
#define chamfers_tb mccmg5_chamfers_tb
#define nelements mccmg5_nelements
#define nu mccmg5_nu
#define phase mccmg5_phase
#define reflect mccmg5_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 19080 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'mg6' [90]. */
#define mccompcurname  mg6
#define mccompcurtype  Guide_gravity
#define mccompcurindex 90
#define GVars mccmg6_GVars
#define pTable mccmg6_pTable
#define w1 mccmg6_w1
#define h1 mccmg6_h1
#define w2 mccmg6_w2
#define h2 mccmg6_h2
#define l mccmg6_l
#define R0 mccmg6_R0
#define Qc mccmg6_Qc
#define alpha mccmg6_alpha
#define m mccmg6_m
#define W mccmg6_W
#define nslit mccmg6_nslit
#define d mccmg6_d
#define mleft mccmg6_mleft
#define mright mccmg6_mright
#define mtop mccmg6_mtop
#define mbottom mccmg6_mbottom
#define nhslit mccmg6_nhslit
#define G mccmg6_G
#define aleft mccmg6_aleft
#define aright mccmg6_aright
#define atop mccmg6_atop
#define abottom mccmg6_abottom
#define wavy mccmg6_wavy
#define wavy_z mccmg6_wavy_z
#define wavy_tb mccmg6_wavy_tb
#define wavy_lr mccmg6_wavy_lr
#define chamfers mccmg6_chamfers
#define chamfers_z mccmg6_chamfers_z
#define chamfers_lr mccmg6_chamfers_lr
#define chamfers_tb mccmg6_chamfers_tb
#define nelements mccmg6_nelements
#define nu mccmg6_nu
#define phase mccmg6_phase
#define reflect mccmg6_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 19164 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'mg7' [91]. */
#define mccompcurname  mg7
#define mccompcurtype  Guide_gravity
#define mccompcurindex 91
#define GVars mccmg7_GVars
#define pTable mccmg7_pTable
#define w1 mccmg7_w1
#define h1 mccmg7_h1
#define w2 mccmg7_w2
#define h2 mccmg7_h2
#define l mccmg7_l
#define R0 mccmg7_R0
#define Qc mccmg7_Qc
#define alpha mccmg7_alpha
#define m mccmg7_m
#define W mccmg7_W
#define nslit mccmg7_nslit
#define d mccmg7_d
#define mleft mccmg7_mleft
#define mright mccmg7_mright
#define mtop mccmg7_mtop
#define mbottom mccmg7_mbottom
#define nhslit mccmg7_nhslit
#define G mccmg7_G
#define aleft mccmg7_aleft
#define aright mccmg7_aright
#define atop mccmg7_atop
#define abottom mccmg7_abottom
#define wavy mccmg7_wavy
#define wavy_z mccmg7_wavy_z
#define wavy_tb mccmg7_wavy_tb
#define wavy_lr mccmg7_wavy_lr
#define chamfers mccmg7_chamfers
#define chamfers_z mccmg7_chamfers_z
#define chamfers_lr mccmg7_chamfers_lr
#define chamfers_tb mccmg7_chamfers_tb
#define nelements mccmg7_nelements
#define nu mccmg7_nu
#define phase mccmg7_phase
#define reflect mccmg7_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 19248 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'mg8' [92]. */
#define mccompcurname  mg8
#define mccompcurtype  Guide_gravity
#define mccompcurindex 92
#define GVars mccmg8_GVars
#define pTable mccmg8_pTable
#define w1 mccmg8_w1
#define h1 mccmg8_h1
#define w2 mccmg8_w2
#define h2 mccmg8_h2
#define l mccmg8_l
#define R0 mccmg8_R0
#define Qc mccmg8_Qc
#define alpha mccmg8_alpha
#define m mccmg8_m
#define W mccmg8_W
#define nslit mccmg8_nslit
#define d mccmg8_d
#define mleft mccmg8_mleft
#define mright mccmg8_mright
#define mtop mccmg8_mtop
#define mbottom mccmg8_mbottom
#define nhslit mccmg8_nhslit
#define G mccmg8_G
#define aleft mccmg8_aleft
#define aright mccmg8_aright
#define atop mccmg8_atop
#define abottom mccmg8_abottom
#define wavy mccmg8_wavy
#define wavy_z mccmg8_wavy_z
#define wavy_tb mccmg8_wavy_tb
#define wavy_lr mccmg8_wavy_lr
#define chamfers mccmg8_chamfers
#define chamfers_z mccmg8_chamfers_z
#define chamfers_lr mccmg8_chamfers_lr
#define chamfers_tb mccmg8_chamfers_tb
#define nelements mccmg8_nelements
#define nu mccmg8_nu
#define phase mccmg8_phase
#define reflect mccmg8_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 19332 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'mg9' [93]. */
#define mccompcurname  mg9
#define mccompcurtype  Guide_gravity
#define mccompcurindex 93
#define GVars mccmg9_GVars
#define pTable mccmg9_pTable
#define w1 mccmg9_w1
#define h1 mccmg9_h1
#define w2 mccmg9_w2
#define h2 mccmg9_h2
#define l mccmg9_l
#define R0 mccmg9_R0
#define Qc mccmg9_Qc
#define alpha mccmg9_alpha
#define m mccmg9_m
#define W mccmg9_W
#define nslit mccmg9_nslit
#define d mccmg9_d
#define mleft mccmg9_mleft
#define mright mccmg9_mright
#define mtop mccmg9_mtop
#define mbottom mccmg9_mbottom
#define nhslit mccmg9_nhslit
#define G mccmg9_G
#define aleft mccmg9_aleft
#define aright mccmg9_aright
#define atop mccmg9_atop
#define abottom mccmg9_abottom
#define wavy mccmg9_wavy
#define wavy_z mccmg9_wavy_z
#define wavy_tb mccmg9_wavy_tb
#define wavy_lr mccmg9_wavy_lr
#define chamfers mccmg9_chamfers
#define chamfers_z mccmg9_chamfers_z
#define chamfers_lr mccmg9_chamfers_lr
#define chamfers_tb mccmg9_chamfers_tb
#define nelements mccmg9_nelements
#define nu mccmg9_nu
#define phase mccmg9_phase
#define reflect mccmg9_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 19416 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'mg10' [94]. */
#define mccompcurname  mg10
#define mccompcurtype  Guide_gravity
#define mccompcurindex 94
#define GVars mccmg10_GVars
#define pTable mccmg10_pTable
#define w1 mccmg10_w1
#define h1 mccmg10_h1
#define w2 mccmg10_w2
#define h2 mccmg10_h2
#define l mccmg10_l
#define R0 mccmg10_R0
#define Qc mccmg10_Qc
#define alpha mccmg10_alpha
#define m mccmg10_m
#define W mccmg10_W
#define nslit mccmg10_nslit
#define d mccmg10_d
#define mleft mccmg10_mleft
#define mright mccmg10_mright
#define mtop mccmg10_mtop
#define mbottom mccmg10_mbottom
#define nhslit mccmg10_nhslit
#define G mccmg10_G
#define aleft mccmg10_aleft
#define aright mccmg10_aright
#define atop mccmg10_atop
#define abottom mccmg10_abottom
#define wavy mccmg10_wavy
#define wavy_z mccmg10_wavy_z
#define wavy_tb mccmg10_wavy_tb
#define wavy_lr mccmg10_wavy_lr
#define chamfers mccmg10_chamfers
#define chamfers_z mccmg10_chamfers_z
#define chamfers_lr mccmg10_chamfers_lr
#define chamfers_tb mccmg10_chamfers_tb
#define nelements mccmg10_nelements
#define nu mccmg10_nu
#define phase mccmg10_phase
#define reflect mccmg10_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 19500 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'mg11' [95]. */
#define mccompcurname  mg11
#define mccompcurtype  Guide_gravity
#define mccompcurindex 95
#define GVars mccmg11_GVars
#define pTable mccmg11_pTable
#define w1 mccmg11_w1
#define h1 mccmg11_h1
#define w2 mccmg11_w2
#define h2 mccmg11_h2
#define l mccmg11_l
#define R0 mccmg11_R0
#define Qc mccmg11_Qc
#define alpha mccmg11_alpha
#define m mccmg11_m
#define W mccmg11_W
#define nslit mccmg11_nslit
#define d mccmg11_d
#define mleft mccmg11_mleft
#define mright mccmg11_mright
#define mtop mccmg11_mtop
#define mbottom mccmg11_mbottom
#define nhslit mccmg11_nhslit
#define G mccmg11_G
#define aleft mccmg11_aleft
#define aright mccmg11_aright
#define atop mccmg11_atop
#define abottom mccmg11_abottom
#define wavy mccmg11_wavy
#define wavy_z mccmg11_wavy_z
#define wavy_tb mccmg11_wavy_tb
#define wavy_lr mccmg11_wavy_lr
#define chamfers mccmg11_chamfers
#define chamfers_z mccmg11_chamfers_z
#define chamfers_lr mccmg11_chamfers_lr
#define chamfers_tb mccmg11_chamfers_tb
#define nelements mccmg11_nelements
#define nu mccmg11_nu
#define phase mccmg11_phase
#define reflect mccmg11_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 19584 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'mg12' [96]. */
#define mccompcurname  mg12
#define mccompcurtype  Guide_gravity
#define mccompcurindex 96
#define GVars mccmg12_GVars
#define pTable mccmg12_pTable
#define w1 mccmg12_w1
#define h1 mccmg12_h1
#define w2 mccmg12_w2
#define h2 mccmg12_h2
#define l mccmg12_l
#define R0 mccmg12_R0
#define Qc mccmg12_Qc
#define alpha mccmg12_alpha
#define m mccmg12_m
#define W mccmg12_W
#define nslit mccmg12_nslit
#define d mccmg12_d
#define mleft mccmg12_mleft
#define mright mccmg12_mright
#define mtop mccmg12_mtop
#define mbottom mccmg12_mbottom
#define nhslit mccmg12_nhslit
#define G mccmg12_G
#define aleft mccmg12_aleft
#define aright mccmg12_aright
#define atop mccmg12_atop
#define abottom mccmg12_abottom
#define wavy mccmg12_wavy
#define wavy_z mccmg12_wavy_z
#define wavy_tb mccmg12_wavy_tb
#define wavy_lr mccmg12_wavy_lr
#define chamfers mccmg12_chamfers
#define chamfers_z mccmg12_chamfers_z
#define chamfers_lr mccmg12_chamfers_lr
#define chamfers_tb mccmg12_chamfers_tb
#define nelements mccmg12_nelements
#define nu mccmg12_nu
#define phase mccmg12_phase
#define reflect mccmg12_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 19668 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'mg13' [97]. */
#define mccompcurname  mg13
#define mccompcurtype  Guide_gravity
#define mccompcurindex 97
#define GVars mccmg13_GVars
#define pTable mccmg13_pTable
#define w1 mccmg13_w1
#define h1 mccmg13_h1
#define w2 mccmg13_w2
#define h2 mccmg13_h2
#define l mccmg13_l
#define R0 mccmg13_R0
#define Qc mccmg13_Qc
#define alpha mccmg13_alpha
#define m mccmg13_m
#define W mccmg13_W
#define nslit mccmg13_nslit
#define d mccmg13_d
#define mleft mccmg13_mleft
#define mright mccmg13_mright
#define mtop mccmg13_mtop
#define mbottom mccmg13_mbottom
#define nhslit mccmg13_nhslit
#define G mccmg13_G
#define aleft mccmg13_aleft
#define aright mccmg13_aright
#define atop mccmg13_atop
#define abottom mccmg13_abottom
#define wavy mccmg13_wavy
#define wavy_z mccmg13_wavy_z
#define wavy_tb mccmg13_wavy_tb
#define wavy_lr mccmg13_wavy_lr
#define chamfers mccmg13_chamfers
#define chamfers_z mccmg13_chamfers_z
#define chamfers_lr mccmg13_chamfers_lr
#define chamfers_tb mccmg13_chamfers_tb
#define nelements mccmg13_nelements
#define nu mccmg13_nu
#define phase mccmg13_phase
#define reflect mccmg13_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 19752 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'mg14' [98]. */
#define mccompcurname  mg14
#define mccompcurtype  Guide_gravity
#define mccompcurindex 98
#define GVars mccmg14_GVars
#define pTable mccmg14_pTable
#define w1 mccmg14_w1
#define h1 mccmg14_h1
#define w2 mccmg14_w2
#define h2 mccmg14_h2
#define l mccmg14_l
#define R0 mccmg14_R0
#define Qc mccmg14_Qc
#define alpha mccmg14_alpha
#define m mccmg14_m
#define W mccmg14_W
#define nslit mccmg14_nslit
#define d mccmg14_d
#define mleft mccmg14_mleft
#define mright mccmg14_mright
#define mtop mccmg14_mtop
#define mbottom mccmg14_mbottom
#define nhslit mccmg14_nhslit
#define G mccmg14_G
#define aleft mccmg14_aleft
#define aright mccmg14_aright
#define atop mccmg14_atop
#define abottom mccmg14_abottom
#define wavy mccmg14_wavy
#define wavy_z mccmg14_wavy_z
#define wavy_tb mccmg14_wavy_tb
#define wavy_lr mccmg14_wavy_lr
#define chamfers mccmg14_chamfers
#define chamfers_z mccmg14_chamfers_z
#define chamfers_lr mccmg14_chamfers_lr
#define chamfers_tb mccmg14_chamfers_tb
#define nelements mccmg14_nelements
#define nu mccmg14_nu
#define phase mccmg14_phase
#define reflect mccmg14_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 19836 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'mg15' [99]. */
#define mccompcurname  mg15
#define mccompcurtype  Guide_gravity
#define mccompcurindex 99
#define GVars mccmg15_GVars
#define pTable mccmg15_pTable
#define w1 mccmg15_w1
#define h1 mccmg15_h1
#define w2 mccmg15_w2
#define h2 mccmg15_h2
#define l mccmg15_l
#define R0 mccmg15_R0
#define Qc mccmg15_Qc
#define alpha mccmg15_alpha
#define m mccmg15_m
#define W mccmg15_W
#define nslit mccmg15_nslit
#define d mccmg15_d
#define mleft mccmg15_mleft
#define mright mccmg15_mright
#define mtop mccmg15_mtop
#define mbottom mccmg15_mbottom
#define nhslit mccmg15_nhslit
#define G mccmg15_G
#define aleft mccmg15_aleft
#define aright mccmg15_aright
#define atop mccmg15_atop
#define abottom mccmg15_abottom
#define wavy mccmg15_wavy
#define wavy_z mccmg15_wavy_z
#define wavy_tb mccmg15_wavy_tb
#define wavy_lr mccmg15_wavy_lr
#define chamfers mccmg15_chamfers
#define chamfers_z mccmg15_chamfers_z
#define chamfers_lr mccmg15_chamfers_lr
#define chamfers_tb mccmg15_chamfers_tb
#define nelements mccmg15_nelements
#define nu mccmg15_nu
#define phase mccmg15_phase
#define reflect mccmg15_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 19920 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'mg16' [100]. */
#define mccompcurname  mg16
#define mccompcurtype  Guide_gravity
#define mccompcurindex 100
#define GVars mccmg16_GVars
#define pTable mccmg16_pTable
#define w1 mccmg16_w1
#define h1 mccmg16_h1
#define w2 mccmg16_w2
#define h2 mccmg16_h2
#define l mccmg16_l
#define R0 mccmg16_R0
#define Qc mccmg16_Qc
#define alpha mccmg16_alpha
#define m mccmg16_m
#define W mccmg16_W
#define nslit mccmg16_nslit
#define d mccmg16_d
#define mleft mccmg16_mleft
#define mright mccmg16_mright
#define mtop mccmg16_mtop
#define mbottom mccmg16_mbottom
#define nhslit mccmg16_nhslit
#define G mccmg16_G
#define aleft mccmg16_aleft
#define aright mccmg16_aright
#define atop mccmg16_atop
#define abottom mccmg16_abottom
#define wavy mccmg16_wavy
#define wavy_z mccmg16_wavy_z
#define wavy_tb mccmg16_wavy_tb
#define wavy_lr mccmg16_wavy_lr
#define chamfers mccmg16_chamfers
#define chamfers_z mccmg16_chamfers_z
#define chamfers_lr mccmg16_chamfers_lr
#define chamfers_tb mccmg16_chamfers_tb
#define nelements mccmg16_nelements
#define nu mccmg16_nu
#define phase mccmg16_phase
#define reflect mccmg16_reflect
#line 334 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
  Gravity_guide_Vars_type GVars;
  t_Table pTable;
#line 20004 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'SampleF' [101]. */
#define mccompcurname  SampleF
#define mccompcurtype  Monitor_nD
#define mccompcurindex 101
#define user1 mccSampleF_user1
#define user2 mccSampleF_user2
#define user3 mccSampleF_user3
#define DEFS mccSampleF_DEFS
#define Vars mccSampleF_Vars
#define detector mccSampleF_detector
#define offdata mccSampleF_offdata
#define xwidth mccSampleF_xwidth
#define yheight mccSampleF_yheight
#define zdepth mccSampleF_zdepth
#define xmin mccSampleF_xmin
#define xmax mccSampleF_xmax
#define ymin mccSampleF_ymin
#define ymax mccSampleF_ymax
#define zmin mccSampleF_zmin
#define zmax mccSampleF_zmax
#define bins mccSampleF_bins
#define min mccSampleF_min
#define max mccSampleF_max
#define restore_neutron mccSampleF_restore_neutron
#define radius mccSampleF_radius
#define options mccSampleF_options
#define filename mccSampleF_filename
#define geometry mccSampleF_geometry
#define username1 mccSampleF_username1
#define username2 mccSampleF_username2
#define username3 mccSampleF_username3
#define nowritefile mccSampleF_nowritefile
#line 224 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
  MonitornD_Defines_type DEFS;
  MonitornD_Variables_type Vars;
  MCDETECTOR detector;
  off_struct offdata;
#line 20082 "ILL_H15_D11.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

/* User declarations for component 'SampleC' [102]. */
#define mccompcurname  SampleC
#define mccompcurtype  Monitor_nD
#define mccompcurindex 102
#define user1 mccSampleC_user1
#define user2 mccSampleC_user2
#define user3 mccSampleC_user3
#define DEFS mccSampleC_DEFS
#define Vars mccSampleC_Vars
#define detector mccSampleC_detector
#define offdata mccSampleC_offdata
#define xwidth mccSampleC_xwidth
#define yheight mccSampleC_yheight
#define zdepth mccSampleC_zdepth
#define xmin mccSampleC_xmin
#define xmax mccSampleC_xmax
#define ymin mccSampleC_ymin
#define ymax mccSampleC_ymax
#define zmin mccSampleC_zmin
#define zmax mccSampleC_zmax
#define bins mccSampleC_bins
#define min mccSampleC_min
#define max mccSampleC_max
#define restore_neutron mccSampleC_restore_neutron
#define radius mccSampleC_radius
#define options mccSampleC_options
#define filename mccSampleC_filename
#define geometry mccSampleC_geometry
#define username1 mccSampleC_username1
#define username2 mccSampleC_username2
#define username3 mccSampleC_username3
#define nowritefile mccSampleC_nowritefile
#line 224 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
  MonitornD_Defines_type DEFS;
  MonitornD_Variables_type Vars;
  MCDETECTOR detector;
  off_struct offdata;
#line 20152 "ILL_H15_D11.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

Coords mcposaPG, mcposrPG;
Rotation mcrotaPG, mcrotrPG;
Coords mcposaSource, mcposrSource;
Rotation mcrotaSource, mcrotrSource;
Coords mcposaAlWindow1, mcposrAlWindow1;
Rotation mcrotaAlWindow1, mcrotrAlWindow1;
Coords mcposaPinkCarter, mcposrPinkCarter;
Rotation mcrotaPinkCarter, mcrotrPinkCarter;
Coords mcposaAlWindow2, mcposrAlWindow2;
Rotation mcrotaAlWindow2, mcrotrAlWindow2;
Coords mcposaLeadShutter, mcposrLeadShutter;
Rotation mcrotaLeadShutter, mcrotrLeadShutter;
Coords mcposaAlWindow3, mcposrAlWindow3;
Rotation mcrotaAlWindow3, mcrotrAlWindow3;
Coords mcposaCurvedGuideStart, mcposrCurvedGuideStart;
Rotation mcrotaCurvedGuideStart, mcrotrCurvedGuideStart;
Coords mcposacg1, mcposrcg1;
Rotation mcrotacg1, mcrotrcg1;
Coords mcposacg2, mcposrcg2;
Rotation mcrotacg2, mcrotrcg2;
Coords mcposacg3, mcposrcg3;
Rotation mcrotacg3, mcrotrcg3;
Coords mcposacg4, mcposrcg4;
Rotation mcrotacg4, mcrotrcg4;
Coords mcposacg5, mcposrcg5;
Rotation mcrotacg5, mcrotrcg5;
Coords mcposacg6, mcposrcg6;
Rotation mcrotacg6, mcrotrcg6;
Coords mcposacg7, mcposrcg7;
Rotation mcrotacg7, mcrotrcg7;
Coords mcposacg8, mcposrcg8;
Rotation mcrotacg8, mcrotrcg8;
Coords mcposacg9, mcposrcg9;
Rotation mcrotacg9, mcrotrcg9;
Coords mcposacg10, mcposrcg10;
Rotation mcrotacg10, mcrotrcg10;
Coords mcposacg11, mcposrcg11;
Rotation mcrotacg11, mcrotrcg11;
Coords mcposacg12, mcposrcg12;
Rotation mcrotacg12, mcrotrcg12;
Coords mcposacg13, mcposrcg13;
Rotation mcrotacg13, mcrotrcg13;
Coords mcposacg14, mcposrcg14;
Rotation mcrotacg14, mcrotrcg14;
Coords mcposacg15, mcposrcg15;
Rotation mcrotacg15, mcrotrcg15;
Coords mcposacg16, mcposrcg16;
Rotation mcrotacg16, mcrotrcg16;
Coords mcposacg17, mcposrcg17;
Rotation mcrotacg17, mcrotrcg17;
Coords mcposacg18, mcposrcg18;
Rotation mcrotacg18, mcrotrcg18;
Coords mcposacg19, mcposrcg19;
Rotation mcrotacg19, mcrotrcg19;
Coords mcposacg20, mcposrcg20;
Rotation mcrotacg20, mcrotrcg20;
Coords mcposacg21, mcposrcg21;
Rotation mcrotacg21, mcrotrcg21;
Coords mcposacg22, mcposrcg22;
Rotation mcrotacg22, mcrotrcg22;
Coords mcposacg23, mcposrcg23;
Rotation mcrotacg23, mcrotrcg23;
Coords mcposacg24, mcposrcg24;
Rotation mcrotacg24, mcrotrcg24;
Coords mcposacg25, mcposrcg25;
Rotation mcrotacg25, mcrotrcg25;
Coords mcposaAlWindow4, mcposrAlWindow4;
Rotation mcrotaAlWindow4, mcrotrAlWindow4;
Coords mcposaPSD_VTE, mcposrPSD_VTE;
Rotation mcrotaPSD_VTE, mcrotrPSD_VTE;
Coords mcposaAlWindow5, mcposrAlWindow5;
Rotation mcrotaAlWindow5, mcrotrAlWindow5;
Coords mcposaVTEtoIN6GuideStart, mcposrVTEtoIN6GuideStart;
Rotation mcrotaVTEtoIN6GuideStart, mcrotrVTEtoIN6GuideStart;
Coords mcposasg1, mcposrsg1;
Rotation mcrotasg1, mcrotrsg1;
Coords mcposasg2, mcposrsg2;
Rotation mcrotasg2, mcrotrsg2;
Coords mcposasg3, mcposrsg3;
Rotation mcrotasg3, mcrotrsg3;
Coords mcposasg4, mcposrsg4;
Rotation mcrotasg4, mcrotrsg4;
Coords mcposasg5, mcposrsg5;
Rotation mcrotasg5, mcrotrsg5;
Coords mcposasg6, mcposrsg6;
Rotation mcrotasg6, mcrotrsg6;
Coords mcposasg7, mcposrsg7;
Rotation mcrotasg7, mcrotrsg7;
Coords mcposasg8, mcposrsg8;
Rotation mcrotasg8, mcrotrsg8;
Coords mcposasg9, mcposrsg9;
Rotation mcrotasg9, mcrotrsg9;
Coords mcposasg10, mcposrsg10;
Rotation mcrotasg10, mcrotrsg10;
Coords mcposasg11, mcposrsg11;
Rotation mcrotasg11, mcrotrsg11;
Coords mcposasg12, mcposrsg12;
Rotation mcrotasg12, mcrotrsg12;
Coords mcposasg13, mcposrsg13;
Rotation mcrotasg13, mcrotrsg13;
Coords mcposasg14, mcposrsg14;
Rotation mcrotasg14, mcrotrsg14;
Coords mcposasg15, mcposrsg15;
Rotation mcrotasg15, mcrotrsg15;
Coords mcposasg16, mcposrsg16;
Rotation mcrotasg16, mcrotrsg16;
Coords mcposasg17, mcposrsg17;
Rotation mcrotasg17, mcrotrsg17;
Coords mcposasg18, mcposrsg18;
Rotation mcrotasg18, mcrotrsg18;
Coords mcposasg19, mcposrsg19;
Rotation mcrotasg19, mcrotrsg19;
Coords mcposasg20, mcposrsg20;
Rotation mcrotasg20, mcrotrsg20;
Coords mcposasg21, mcposrsg21;
Rotation mcrotasg21, mcrotrsg21;
Coords mcposasg22, mcposrsg22;
Rotation mcrotasg22, mcrotrsg22;
Coords mcposaAlWindow6, mcposrAlWindow6;
Rotation mcrotaAlWindow6, mcrotrAlWindow6;
Coords mcposaPSD_IN6, mcposrPSD_IN6;
Rotation mcrotaPSD_IN6, mcrotrPSD_IN6;
Coords mcposaAlWindow7, mcposrAlWindow7;
Rotation mcrotaAlWindow7, mcrotrAlWindow7;
Coords mcposaIN6toD7GuideStart, mcposrIN6toD7GuideStart;
Rotation mcrotaIN6toD7GuideStart, mcrotrIN6toD7GuideStart;
Coords mcposasg23, mcposrsg23;
Rotation mcrotasg23, mcrotrsg23;
Coords mcposasg24, mcposrsg24;
Rotation mcrotasg24, mcrotrsg24;
Coords mcposasg25, mcposrsg25;
Rotation mcrotasg25, mcrotrsg25;
Coords mcposasg26, mcposrsg26;
Rotation mcrotasg26, mcrotrsg26;
Coords mcposasg27, mcposrsg27;
Rotation mcrotasg27, mcrotrsg27;
Coords mcposaAlWindow8, mcposrAlWindow8;
Rotation mcrotaAlWindow8, mcrotrAlWindow8;
Coords mcposaPSD_D7, mcposrPSD_D7;
Rotation mcrotaPSD_D7, mcrotrPSD_D7;
Coords mcposaAlWindow9, mcposrAlWindow9;
Rotation mcrotaAlWindow9, mcrotrAlWindow9;
Coords mcposaD7toD11GuideStart, mcposrD7toD11GuideStart;
Rotation mcrotaD7toD11GuideStart, mcrotrD7toD11GuideStart;
Coords mcposasg28, mcposrsg28;
Rotation mcrotasg28, mcrotrsg28;
Coords mcposasg29, mcposrsg29;
Rotation mcrotasg29, mcrotrsg29;
Coords mcposaAlWindow10, mcposrAlWindow10;
Rotation mcrotaAlWindow10, mcrotrAlWindow10;
Coords mcposaMon_D11_In, mcposrMon_D11_In;
Rotation mcrotaMon_D11_In, mcrotrMon_D11_In;
Coords mcposaDolores, mcposrDolores;
Rotation mcrotaDolores, mcrotrDolores;
Coords mcposaAlWindow11, mcposrAlWindow11;
Rotation mcrotaAlWindow11, mcrotrAlWindow11;
Coords mcposasg30, mcposrsg30;
Rotation mcrotasg30, mcrotrsg30;
Coords mcposaAlWindow12, mcposrAlWindow12;
Rotation mcrotaAlWindow12, mcrotrAlWindow12;
Coords mcposaMon_D11_Out, mcposrMon_D11_Out;
Rotation mcrotaMon_D11_Out, mcrotrMon_D11_Out;
Coords mcposaAlWindow13, mcposrAlWindow13;
Rotation mcrotaAlWindow13, mcrotrAlWindow13;
Coords mcposaMovableGuideStart, mcposrMovableGuideStart;
Rotation mcrotaMovableGuideStart, mcrotrMovableGuideStart;
Coords mcposamg0, mcposrmg0;
Rotation mcrotamg0, mcrotrmg0;
Coords mcposamg1, mcposrmg1;
Rotation mcrotamg1, mcrotrmg1;
Coords mcposamg2, mcposrmg2;
Rotation mcrotamg2, mcrotrmg2;
Coords mcposamg3, mcposrmg3;
Rotation mcrotamg3, mcrotrmg3;
Coords mcposamg4, mcposrmg4;
Rotation mcrotamg4, mcrotrmg4;
Coords mcposamg5, mcposrmg5;
Rotation mcrotamg5, mcrotrmg5;
Coords mcposamg6, mcposrmg6;
Rotation mcrotamg6, mcrotrmg6;
Coords mcposamg7, mcposrmg7;
Rotation mcrotamg7, mcrotrmg7;
Coords mcposamg8, mcposrmg8;
Rotation mcrotamg8, mcrotrmg8;
Coords mcposamg9, mcposrmg9;
Rotation mcrotamg9, mcrotrmg9;
Coords mcposamg10, mcposrmg10;
Rotation mcrotamg10, mcrotrmg10;
Coords mcposamg11, mcposrmg11;
Rotation mcrotamg11, mcrotrmg11;
Coords mcposamg12, mcposrmg12;
Rotation mcrotamg12, mcrotrmg12;
Coords mcposamg13, mcposrmg13;
Rotation mcrotamg13, mcrotrmg13;
Coords mcposamg14, mcposrmg14;
Rotation mcrotamg14, mcrotrmg14;
Coords mcposamg15, mcposrmg15;
Rotation mcrotamg15, mcrotrmg15;
Coords mcposamg16, mcposrmg16;
Rotation mcrotamg16, mcrotrmg16;
Coords mcposaSampleF, mcposrSampleF;
Rotation mcrotaSampleF, mcrotrSampleF;
Coords mcposaSampleC, mcposrSampleC;
Rotation mcrotaSampleC, mcrotrSampleC;

MCNUM mcnx, mcny, mcnz, mcnvx, mcnvy, mcnvz, mcnt, mcnsx, mcnsy, mcnsz, mcnp;

/* end declare */

void mcinit(void) {
#define mccompcurname  ILL_H15_D11
#define mccompcurtype  INSTRUMENT
#define mccompcurindex 0
#define mcposaILL_H15_D11 coords_set(0,0,0)
#define Lambda mcipLambda
#define Config mcipConfig
#define Lc mcipLc
#define iLc mcipiLc
#define Chamfers mcipChamfers
#define Waviness mcipWaviness
#line 150 "ILL_H15_D11.instr"
{
  double PhiC, GammaC, ThetaC, LambdaC, LStar, Zc;
  double Ki;
  int    i=0;
  double sum_length=0;
  double n_elements=0;
  
  /* curved section total 25.5 m in 25 elements */
  gElmtLength1 = fabs(gLength1)/25;
  gElmtRot1    = gElmtLength1/gCurvatureRadius*180/PI;
  
  gElmtLength2 = fabs(gLength2)/22;
  gElmtLength3 = fabs(gLength3)/5;

/* INFO ******************************************************************* */
  printf("Simulation : %s on %s [pid %i]\n",VERSION,getenv("HOSTNAME"), getpid());

  /* Source and guide parameters */
 
  sLambda = Lambda;
  sDeltaLambda        = sDeltaLambdaPercent * sLambda / 2;

  /* First guide Phase-Space parameters */
  PhiC    = sqrt(2*fabs(gGuideWidth/gCurvatureRadius));
  GammaC  = mGuide1*mQc/4/PI;
  ThetaC  = sLambda*GammaC;
  LambdaC = PhiC/GammaC;
  LStar   = sqrt(8*fabs(gGuideWidth*gCurvatureRadius));
  Zc      = gGuideWidth*(0.5-ThetaC*ThetaC/PhiC/PhiC);

  printf("Guide: L =%.4f m, rho=%.4f m, m=%.2f\n", gLength1, gCurvatureRadius, mGuide1);
  printf("Guide: L*=%.2f m, Phi_c = %.2f deg, Gamma_c = %.2f deg/Angs\n", LStar, PhiC*RAD2DEG, GammaC*RAD2DEG);
  printf("Guide: Zc = %.4f m, Lambda_c = %.2f Angs\n", Zc, LambdaC);
  if (sLambda < LambdaC) 
    printf("Guide: Garland reflections only\n");
  else 
    printf("Guide: Garland and Zig-Zag reflections\n");
  if (gLength1 < LStar) 
    printf("Guide: Guide is too short\n");
  
  if (Lambda < 0.12) exit(printf("** D11 Error: Unreachable wavelength for D11: %.4g\n", Lambda));

  Ki   = 2*PI/Lambda;
  Vrpm = 124270/(Lambda-0.11832);
  if (Vrpm < 3100 || Vrpm > 28300) exit(printf("D11 Error: Unreachable V_selector speed for D11: %.4g\n", Vrpm));
  if (Vrpm > 9000 && Vrpm < 11900) printf("D11 Warning: Resonance V_selector speed for D11: %.4g\n", Vrpm);
  printf("D11:   Ki = %.4g [Angs-1], Lambda = %.4g [Angs], V_Dolores=%.4g [rpm]\n", Ki, Lambda, Vrpm);
  
  if (!Config) exit(printf("** D11 Error: No movable guide configuration selected for D11\n"));
  
  if (strstr(Config, "Borkron_1972")) {
    for (i=0; i<17; i++) {
      Config_l[i] = Borkron_1972_l[i];
      Config_n[i] = Borkron_1972_n[i];
      if (i<2) Config_g[i] = Borkron_1972_g[i];
    }
  }
  if (strstr(Config, "Borkron_2003")) {
    for (i=0; i<17; i++) {
      Config_l[i] = Borkron_2003_l[i];
      Config_n[i] = Borkron_2003_n[i];
      if (i<2) Config_g[i] = Borkron_2003_g[i];
    }
  }
  if (strstr(Config, "Borofloat_2001")) {
    for (i=0; i<17; i++) {
      Config_l[i] = Borofloat_2001_l[i];
      Config_n[i] = Borofloat_2001_n[i];
      if (i<2) Config_g[i] = Borofloat_2001_g[i];
    }
  }
  if (strstr(Config, "Borofloat_2003")) {
    for (i=0; i<17; i++) {
      Config_l[i] = Borofloat_2001_l[i];
      Config_n[i] = Borofloat_2001_n[i];
      if (i<2) Config_g[i] = Borofloat_2001_g[i];
    }
  }
  if (!i) exit(printf("** D11 Error: No movable guide configuration selected for D11\n"));
  if (strstr(Config,"nogap")) for (i=0; i<2; Config_g[i++]=0);
  
  if (Lc == 0)
    if (iLc >= 0 && iLc < 12)
      Lc = Length_Lc[(int)iLc];
    else exit(printf("** D11 Error: invalid collimator length specification for D11\n"));
  
  for (i=0; i< 17; i++) { 
    if (40.5 - Lc <= sum_length) Config_n[i]=0;
    else {
      sum_length += Config_l[i];
      n_elements += Config_n[i];
    }
  }
  printf("D11:   Coll.  L_c=%8.3g [m], Configuration='%s', \n", Lc, Config);
  printf("D11:   Length L_g=%8.3g [m], n_elements=%8.2g\n", sum_length, n_elements);
  printf("D11:   Chamfers  =%8.3g [m], Waviness  =%8.3g [rad] (%.3g [deg])\n", Chamfers, Waviness, Waviness*RAD2DEG);
  Waviness *= RAD2DEG;

}
#line 20505 "ILL_H15_D11.c"
#undef Waviness
#undef Chamfers
#undef iLc
#undef Lc
#undef Config
#undef Lambda
#undef mcposaILL_H15_D11
#undef mccompcurindex
#undef mccompcurtype
#undef mccompcurname
  /* Computation of coordinate transformations. */
  {
    Coords mctc1, mctc2, mcLastComp;
    Rotation mctr1;
    double mcAccumulatedILength = 0;
    /* Initialize "last" component origin as (0,0,0) */
    mcLastComp = coords_set(0,0,0);

    mcDEBUG_INSTR()
  /* Component initializations. */
    /* Component PG. */
  /* Setting parameters for component PG. */
  SIG_MESSAGE("PG (Init:SetPar)");
#line 39 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccPG_profile, "NULL" ? "NULL" : "", 16384); else mccPG_profile[0]='\0';
#line 39 "ILL_H15_D11.instr"
  mccPG_percent = 10;
#line 39 "ILL_H15_D11.instr"
  mccPG_flag_save = 0;
#line 39 "ILL_H15_D11.instr"
  mccPG_minutes = 0;
#line 20537 "ILL_H15_D11.c"

  SIG_MESSAGE("PG (Init:Place/Rotate)");
  rot_set_rotation(mcrotaPG,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 20544 "ILL_H15_D11.c"
  rot_copy(mcrotrPG, mcrotaPG);
  mcposaPG = coords_set(
#line 258 "ILL_H15_D11.instr"
    0,
#line 258 "ILL_H15_D11.instr"
    0,
#line 258 "ILL_H15_D11.instr"
    0);
#line 20553 "ILL_H15_D11.c"
  mctc1 = coords_neg(mcposaPG);
  mcposrPG = rot_apply(mcrotaPG, mctc1);
  mcDEBUG_COMPONENT("PG", mcposaPG, mcrotaPG)
  mccomp_posa[1] = mcposaPG;
  mccomp_posr[1] = mcposrPG;
  mcNCounter[1]  = mcPCounter[1] = mcP2Counter[1] = 0;
  mcAbsorbProp[1]= 0;
    /* Component Source. */
  /* Setting parameters for component Source. */
  SIG_MESSAGE("Source (Init:SetPar)");
#line 129 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccSource_flux_file, "NULL" ? "NULL" : "", 16384); else mccSource_flux_file[0]='\0';
#line 129 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccSource_xdiv_file, "NULL" ? "NULL" : "", 16384); else mccSource_xdiv_file[0]='\0';
#line 129 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccSource_ydiv_file, "NULL" ? "NULL" : "", 16384); else mccSource_ydiv_file[0]='\0';
#line 130 "ILL_H15_D11.instr"
  mccSource_radius = 0.0;
#line 264 "ILL_H15_D11.instr"
  mccSource_dist = gSourceInput;
#line 265 "ILL_H15_D11.instr"
  mccSource_focus_xw = gInputWidth;
#line 266 "ILL_H15_D11.instr"
  mccSource_focus_yh = gGuideHeight1;
#line 130 "ILL_H15_D11.instr"
  mccSource_focus_aw = 0;
#line 130 "ILL_H15_D11.instr"
  mccSource_focus_ah = 0;
#line 131 "ILL_H15_D11.instr"
  mccSource_E0 = 0;
#line 131 "ILL_H15_D11.instr"
  mccSource_dE = 0;
#line 131 "ILL_H15_D11.instr"
  mccSource_lambda0 = 0;
#line 131 "ILL_H15_D11.instr"
  mccSource_dlambda = 0;
#line 270 "ILL_H15_D11.instr"
  mccSource_I1 = sI1;
#line 261 "ILL_H15_D11.instr"
  mccSource_yheight = sH;
#line 262 "ILL_H15_D11.instr"
  mccSource_xwidth = sW;
#line 275 "ILL_H15_D11.instr"
  mccSource_verbose = 1;
#line 269 "ILL_H15_D11.instr"
  mccSource_T1 = sT1;
#line 133 "ILL_H15_D11.instr"
  mccSource_flux_file_perAA = 0;
#line 133 "ILL_H15_D11.instr"
  mccSource_flux_file_log = 0;
#line 267 "ILL_H15_D11.instr"
  mccSource_Lmin = sLambda - sDeltaLambda;
#line 268 "ILL_H15_D11.instr"
  mccSource_Lmax = sLambda + sDeltaLambda;
#line 134 "ILL_H15_D11.instr"
  mccSource_Emin = 0;
#line 134 "ILL_H15_D11.instr"
  mccSource_Emax = 0;
#line 271 "ILL_H15_D11.instr"
  mccSource_T2 = sT2;
#line 272 "ILL_H15_D11.instr"
  mccSource_I2 = sI2;
#line 273 "ILL_H15_D11.instr"
  mccSource_T3 = sT3;
#line 274 "ILL_H15_D11.instr"
  mccSource_I3 = sI3;
#line 263 "ILL_H15_D11.instr"
  mccSource_zdepth = 0.1;
#line 134 "ILL_H15_D11.instr"
  mccSource_target_index = + 1;
#line 20624 "ILL_H15_D11.c"

  SIG_MESSAGE("Source (Init:Place/Rotate)");
  rot_set_rotation(mcrotaSource,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 20631 "ILL_H15_D11.c"
  rot_transpose(mcrotaPG, mctr1);
  rot_mul(mcrotaSource, mctr1, mcrotrSource);
  mcposaSource = coords_set(
#line 277 "ILL_H15_D11.instr"
    0,
#line 277 "ILL_H15_D11.instr"
    0,
#line 277 "ILL_H15_D11.instr"
    0);
#line 20641 "ILL_H15_D11.c"
  mctc1 = coords_sub(mcposaPG, mcposaSource);
  mcposrSource = rot_apply(mcrotaSource, mctc1);
  mcDEBUG_COMPONENT("Source", mcposaSource, mcrotaSource)
  mccomp_posa[2] = mcposaSource;
  mccomp_posr[2] = mcposrSource;
  mcNCounter[2]  = mcPCounter[2] = mcP2Counter[2] = 0;
  mcAbsorbProp[2]= 0;
    /* Component AlWindow1. */
  /* Setting parameters for component AlWindow1. */
  SIG_MESSAGE("AlWindow1 (Init:SetPar)");
#line 279 "ILL_H15_D11.instr"
  mccAlWindow1_thickness = 0.002;
#line 20654 "ILL_H15_D11.c"

  SIG_MESSAGE("AlWindow1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 20661 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotaSource, mcrotaAlWindow1);
  rot_transpose(mcrotaSource, mctr1);
  rot_mul(mcrotaAlWindow1, mctr1, mcrotrAlWindow1);
  mctc1 = coords_set(
#line 280 "ILL_H15_D11.instr"
    0,
#line 280 "ILL_H15_D11.instr"
    0,
#line 280 "ILL_H15_D11.instr"
    gSourceInput -0.01);
#line 20672 "ILL_H15_D11.c"
  rot_transpose(mcrotaSource, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAlWindow1 = coords_add(mcposaSource, mctc2);
  mctc1 = coords_sub(mcposaSource, mcposaAlWindow1);
  mcposrAlWindow1 = rot_apply(mcrotaAlWindow1, mctc1);
  mcDEBUG_COMPONENT("AlWindow1", mcposaAlWindow1, mcrotaAlWindow1)
  mccomp_posa[3] = mcposaAlWindow1;
  mccomp_posr[3] = mcposrAlWindow1;
  mcNCounter[3]  = mcPCounter[3] = mcP2Counter[3] = 0;
  mcAbsorbProp[3]= 0;
    /* Component PinkCarter. */
  /* Setting parameters for component PinkCarter. */
  SIG_MESSAGE("PinkCarter (Init:SetPar)");
#line 283 "ILL_H15_D11.instr"
  mccPinkCarter_w1 = gInputWidth;
#line 283 "ILL_H15_D11.instr"
  mccPinkCarter_h1 = gGuideHeight1;
#line 283 "ILL_H15_D11.instr"
  mccPinkCarter_w2 = gObtWidth;
#line 283 "ILL_H15_D11.instr"
  mccPinkCarter_h2 = gGuideHeight1;
#line 283 "ILL_H15_D11.instr"
  mccPinkCarter_l = 3.170;
#line 284 "ILL_H15_D11.instr"
  mccPinkCarter_R0 = mR0;
#line 284 "ILL_H15_D11.instr"
  mccPinkCarter_Qc = mQc;
#line 284 "ILL_H15_D11.instr"
  mccPinkCarter_alpha = mAlpha;
#line 284 "ILL_H15_D11.instr"
  mccPinkCarter_m = mInPile;
#line 284 "ILL_H15_D11.instr"
  mccPinkCarter_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccPinkCarter_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccPinkCarter_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccPinkCarter_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccPinkCarter_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccPinkCarter_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccPinkCarter_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccPinkCarter_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccPinkCarter_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccPinkCarter_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccPinkCarter_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccPinkCarter_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccPinkCarter_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccPinkCarter_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccPinkCarter_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccPinkCarter_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccPinkCarter_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccPinkCarter_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccPinkCarter_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccPinkCarter_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccPinkCarter_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccPinkCarter_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccPinkCarter_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccPinkCarter_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccPinkCarter_reflect, "NULL" ? "NULL" : "", 16384); else mccPinkCarter_reflect[0]='\0';
#line 20754 "ILL_H15_D11.c"

  SIG_MESSAGE("PinkCarter (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 20761 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotaSource, mcrotaPinkCarter);
  rot_transpose(mcrotaAlWindow1, mctr1);
  rot_mul(mcrotaPinkCarter, mctr1, mcrotrPinkCarter);
  mctc1 = coords_set(
#line 285 "ILL_H15_D11.instr"
    0,
#line 285 "ILL_H15_D11.instr"
    0,
#line 285 "ILL_H15_D11.instr"
    gSourceInput);
#line 20772 "ILL_H15_D11.c"
  rot_transpose(mcrotaSource, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPinkCarter = coords_add(mcposaSource, mctc2);
  mctc1 = coords_sub(mcposaAlWindow1, mcposaPinkCarter);
  mcposrPinkCarter = rot_apply(mcrotaPinkCarter, mctc1);
  mcDEBUG_COMPONENT("PinkCarter", mcposaPinkCarter, mcrotaPinkCarter)
  mccomp_posa[4] = mcposaPinkCarter;
  mccomp_posr[4] = mcposrPinkCarter;
  mcNCounter[4]  = mcPCounter[4] = mcP2Counter[4] = 0;
  mcAbsorbProp[4]= 0;
    /* Component AlWindow2. */
  /* Setting parameters for component AlWindow2. */
  SIG_MESSAGE("AlWindow2 (Init:SetPar)");
#line 287 "ILL_H15_D11.instr"
  mccAlWindow2_thickness = 0.002;
#line 20788 "ILL_H15_D11.c"

  SIG_MESSAGE("AlWindow2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 20795 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotaSource, mcrotaAlWindow2);
  rot_transpose(mcrotaPinkCarter, mctr1);
  rot_mul(mcrotaAlWindow2, mctr1, mcrotrAlWindow2);
  mctc1 = coords_set(
#line 288 "ILL_H15_D11.instr"
    0,
#line 288 "ILL_H15_D11.instr"
    0,
#line 288 "ILL_H15_D11.instr"
    gSourceInput + 3.522 + 0.001);
#line 20806 "ILL_H15_D11.c"
  rot_transpose(mcrotaSource, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAlWindow2 = coords_add(mcposaSource, mctc2);
  mctc1 = coords_sub(mcposaPinkCarter, mcposaAlWindow2);
  mcposrAlWindow2 = rot_apply(mcrotaAlWindow2, mctc1);
  mcDEBUG_COMPONENT("AlWindow2", mcposaAlWindow2, mcrotaAlWindow2)
  mccomp_posa[5] = mcposaAlWindow2;
  mccomp_posr[5] = mcposrAlWindow2;
  mcNCounter[5]  = mcPCounter[5] = mcP2Counter[5] = 0;
  mcAbsorbProp[5]= 0;
    /* Component LeadShutter. */
  /* Setting parameters for component LeadShutter. */
  SIG_MESSAGE("LeadShutter (Init:SetPar)");
#line 293 "ILL_H15_D11.instr"
  mccLeadShutter_w1 = gObtWidth;
#line 293 "ILL_H15_D11.instr"
  mccLeadShutter_h1 = gGuideHeight1;
#line 293 "ILL_H15_D11.instr"
  mccLeadShutter_w2 = gObtWidth;
#line 293 "ILL_H15_D11.instr"
  mccLeadShutter_h2 = gGuideHeight1;
#line 293 "ILL_H15_D11.instr"
  mccLeadShutter_l = 0.228;
#line 294 "ILL_H15_D11.instr"
  mccLeadShutter_R0 = mR0;
#line 294 "ILL_H15_D11.instr"
  mccLeadShutter_Qc = mQc;
#line 294 "ILL_H15_D11.instr"
  mccLeadShutter_alpha = mAlpha;
#line 294 "ILL_H15_D11.instr"
  mccLeadShutter_m = mInPile;
#line 294 "ILL_H15_D11.instr"
  mccLeadShutter_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccLeadShutter_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccLeadShutter_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccLeadShutter_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccLeadShutter_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccLeadShutter_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccLeadShutter_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccLeadShutter_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccLeadShutter_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccLeadShutter_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccLeadShutter_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccLeadShutter_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccLeadShutter_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccLeadShutter_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccLeadShutter_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccLeadShutter_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccLeadShutter_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccLeadShutter_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccLeadShutter_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccLeadShutter_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccLeadShutter_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccLeadShutter_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccLeadShutter_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccLeadShutter_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccLeadShutter_reflect, "NULL" ? "NULL" : "", 16384); else mccLeadShutter_reflect[0]='\0';
#line 20888 "ILL_H15_D11.c"

  SIG_MESSAGE("LeadShutter (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 20895 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotaSource, mcrotaLeadShutter);
  rot_transpose(mcrotaAlWindow2, mctr1);
  rot_mul(mcrotaLeadShutter, mctr1, mcrotrLeadShutter);
  mctc1 = coords_set(
#line 295 "ILL_H15_D11.instr"
    0,
#line 295 "ILL_H15_D11.instr"
    0,
#line 295 "ILL_H15_D11.instr"
    gSourceInput + 3.522 + 0.01);
#line 20906 "ILL_H15_D11.c"
  rot_transpose(mcrotaSource, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaLeadShutter = coords_add(mcposaSource, mctc2);
  mctc1 = coords_sub(mcposaAlWindow2, mcposaLeadShutter);
  mcposrLeadShutter = rot_apply(mcrotaLeadShutter, mctc1);
  mcDEBUG_COMPONENT("LeadShutter", mcposaLeadShutter, mcrotaLeadShutter)
  mccomp_posa[6] = mcposaLeadShutter;
  mccomp_posr[6] = mcposrLeadShutter;
  mcNCounter[6]  = mcPCounter[6] = mcP2Counter[6] = 0;
  mcAbsorbProp[6]= 0;
    /* Component AlWindow3. */
  /* Setting parameters for component AlWindow3. */
  SIG_MESSAGE("AlWindow3 (Init:SetPar)");
#line 298 "ILL_H15_D11.instr"
  mccAlWindow3_thickness = 0.002;
#line 20922 "ILL_H15_D11.c"

  SIG_MESSAGE("AlWindow3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 20929 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotaSource, mcrotaAlWindow3);
  rot_transpose(mcrotaLeadShutter, mctr1);
  rot_mul(mcrotaAlWindow3, mctr1, mcrotrAlWindow3);
  mctc1 = coords_set(
#line 299 "ILL_H15_D11.instr"
    0,
#line 299 "ILL_H15_D11.instr"
    0,
#line 299 "ILL_H15_D11.instr"
    gSourceInput + 3.522 + 0.01 + 0.228 + 0.005);
#line 20940 "ILL_H15_D11.c"
  rot_transpose(mcrotaSource, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAlWindow3 = coords_add(mcposaSource, mctc2);
  mctc1 = coords_sub(mcposaLeadShutter, mcposaAlWindow3);
  mcposrAlWindow3 = rot_apply(mcrotaAlWindow3, mctc1);
  mcDEBUG_COMPONENT("AlWindow3", mcposaAlWindow3, mcrotaAlWindow3)
  mccomp_posa[7] = mcposaAlWindow3;
  mccomp_posr[7] = mcposrAlWindow3;
  mcNCounter[7]  = mcPCounter[7] = mcP2Counter[7] = 0;
  mcAbsorbProp[7]= 0;
    /* Component CurvedGuideStart. */
  /* Setting parameters for component CurvedGuideStart. */
  SIG_MESSAGE("CurvedGuideStart (Init:SetPar)");

  SIG_MESSAGE("CurvedGuideStart (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 20960 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotaSource, mcrotaCurvedGuideStart);
  rot_transpose(mcrotaAlWindow3, mctr1);
  rot_mul(mcrotaCurvedGuideStart, mctr1, mcrotrCurvedGuideStart);
  mctc1 = coords_set(
#line 308 "ILL_H15_D11.instr"
    0,
#line 308 "ILL_H15_D11.instr"
    0,
#line 308 "ILL_H15_D11.instr"
    gSourceInput + 3.522 + 0.01 + 0.228 + 0.08);
#line 20971 "ILL_H15_D11.c"
  rot_transpose(mcrotaSource, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaCurvedGuideStart = coords_add(mcposaSource, mctc2);
  mctc1 = coords_sub(mcposaAlWindow3, mcposaCurvedGuideStart);
  mcposrCurvedGuideStart = rot_apply(mcrotaCurvedGuideStart, mctc1);
  mcDEBUG_COMPONENT("CurvedGuideStart", mcposaCurvedGuideStart, mcrotaCurvedGuideStart)
  mccomp_posa[8] = mcposaCurvedGuideStart;
  mccomp_posr[8] = mcposrCurvedGuideStart;
  mcNCounter[8]  = mcPCounter[8] = mcP2Counter[8] = 0;
  mcAbsorbProp[8]= 0;
    /* Component cg1. */
  /* Setting parameters for component cg1. */
  SIG_MESSAGE("cg1 (Init:SetPar)");
#line 312 "ILL_H15_D11.instr"
  mcccg1_w1 = gGuideWidth;
#line 312 "ILL_H15_D11.instr"
  mcccg1_h1 = gGuideHeight1;
#line 312 "ILL_H15_D11.instr"
  mcccg1_w2 = gGuideWidth;
#line 312 "ILL_H15_D11.instr"
  mcccg1_h2 = gGuideHeight1;
#line 313 "ILL_H15_D11.instr"
  mcccg1_l = ( gElmtLength1 - gElementGap );
#line 314 "ILL_H15_D11.instr"
  mcccg1_R0 = mR0;
#line 314 "ILL_H15_D11.instr"
  mcccg1_Qc = mQc;
#line 314 "ILL_H15_D11.instr"
  mcccg1_alpha = mAlpha;
#line 314 "ILL_H15_D11.instr"
  mcccg1_m = mGuide1;
#line 314 "ILL_H15_D11.instr"
  mcccg1_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg1_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg1_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg1_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg1_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg1_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg1_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg1_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg1_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg1_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg1_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg1_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg1_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg1_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg1_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg1_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg1_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg1_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg1_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg1_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg1_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg1_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg1_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg1_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg1_reflect, "NULL" ? "NULL" : "", 16384); else mcccg1_reflect[0]='\0';
#line 21053 "ILL_H15_D11.c"

  SIG_MESSAGE("cg1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 315 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 315 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 315 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 21063 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotaCurvedGuideStart, mcrotacg1);
  rot_transpose(mcrotaCurvedGuideStart, mctr1);
  rot_mul(mcrotacg1, mctr1, mcrotrcg1);
  mctc1 = coords_set(
#line 315 "ILL_H15_D11.instr"
    0,
#line 315 "ILL_H15_D11.instr"
    0,
#line 315 "ILL_H15_D11.instr"
    0);
#line 21074 "ILL_H15_D11.c"
  rot_transpose(mcrotaCurvedGuideStart, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg1 = coords_add(mcposaCurvedGuideStart, mctc2);
  mctc1 = coords_sub(mcposaCurvedGuideStart, mcposacg1);
  mcposrcg1 = rot_apply(mcrotacg1, mctc1);
  mcDEBUG_COMPONENT("cg1", mcposacg1, mcrotacg1)
  mccomp_posa[9] = mcposacg1;
  mccomp_posr[9] = mcposrcg1;
  mcNCounter[9]  = mcPCounter[9] = mcP2Counter[9] = 0;
  mcAbsorbProp[9]= 0;
    /* Component cg2. */
  /* Setting parameters for component cg2. */
  SIG_MESSAGE("cg2 (Init:SetPar)");
#line 317 "ILL_H15_D11.instr"
  mcccg2_w1 = gGuideWidth;
#line 317 "ILL_H15_D11.instr"
  mcccg2_h1 = gGuideHeight1;
#line 317 "ILL_H15_D11.instr"
  mcccg2_w2 = gGuideWidth;
#line 317 "ILL_H15_D11.instr"
  mcccg2_h2 = gGuideHeight1;
#line 318 "ILL_H15_D11.instr"
  mcccg2_l = ( gElmtLength1 - gElementGap );
#line 319 "ILL_H15_D11.instr"
  mcccg2_R0 = mR0;
#line 319 "ILL_H15_D11.instr"
  mcccg2_Qc = mQc;
#line 319 "ILL_H15_D11.instr"
  mcccg2_alpha = mAlpha;
#line 319 "ILL_H15_D11.instr"
  mcccg2_m = mGuide1;
#line 319 "ILL_H15_D11.instr"
  mcccg2_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg2_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg2_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg2_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg2_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg2_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg2_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg2_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg2_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg2_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg2_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg2_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg2_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg2_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg2_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg2_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg2_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg2_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg2_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg2_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg2_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg2_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg2_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg2_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg2_reflect, "NULL" ? "NULL" : "", 16384); else mcccg2_reflect[0]='\0';
#line 21156 "ILL_H15_D11.c"

  SIG_MESSAGE("cg2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 320 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 320 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 320 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 21166 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg1, mcrotacg2);
  rot_transpose(mcrotacg1, mctr1);
  rot_mul(mcrotacg2, mctr1, mcrotrcg2);
  mctc1 = coords_set(
#line 320 "ILL_H15_D11.instr"
    0,
#line 320 "ILL_H15_D11.instr"
    0,
#line 320 "ILL_H15_D11.instr"
    gElmtLength1);
#line 21177 "ILL_H15_D11.c"
  rot_transpose(mcrotacg1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg2 = coords_add(mcposacg1, mctc2);
  mctc1 = coords_sub(mcposacg1, mcposacg2);
  mcposrcg2 = rot_apply(mcrotacg2, mctc1);
  mcDEBUG_COMPONENT("cg2", mcposacg2, mcrotacg2)
  mccomp_posa[10] = mcposacg2;
  mccomp_posr[10] = mcposrcg2;
  mcNCounter[10]  = mcPCounter[10] = mcP2Counter[10] = 0;
  mcAbsorbProp[10]= 0;
    /* Component cg3. */
  /* Setting parameters for component cg3. */
  SIG_MESSAGE("cg3 (Init:SetPar)");
#line 322 "ILL_H15_D11.instr"
  mcccg3_w1 = gGuideWidth;
#line 322 "ILL_H15_D11.instr"
  mcccg3_h1 = gGuideHeight1;
#line 322 "ILL_H15_D11.instr"
  mcccg3_w2 = gGuideWidth;
#line 322 "ILL_H15_D11.instr"
  mcccg3_h2 = gGuideHeight1;
#line 323 "ILL_H15_D11.instr"
  mcccg3_l = ( gElmtLength1 - gElementGap );
#line 324 "ILL_H15_D11.instr"
  mcccg3_R0 = mR0;
#line 324 "ILL_H15_D11.instr"
  mcccg3_Qc = mQc;
#line 324 "ILL_H15_D11.instr"
  mcccg3_alpha = mAlpha;
#line 324 "ILL_H15_D11.instr"
  mcccg3_m = mGuide1;
#line 324 "ILL_H15_D11.instr"
  mcccg3_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg3_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg3_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg3_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg3_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg3_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg3_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg3_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg3_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg3_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg3_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg3_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg3_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg3_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg3_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg3_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg3_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg3_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg3_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg3_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg3_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg3_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg3_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg3_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg3_reflect, "NULL" ? "NULL" : "", 16384); else mcccg3_reflect[0]='\0';
#line 21259 "ILL_H15_D11.c"

  SIG_MESSAGE("cg3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 325 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 325 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 325 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 21269 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg2, mcrotacg3);
  rot_transpose(mcrotacg2, mctr1);
  rot_mul(mcrotacg3, mctr1, mcrotrcg3);
  mctc1 = coords_set(
#line 325 "ILL_H15_D11.instr"
    0,
#line 325 "ILL_H15_D11.instr"
    0,
#line 325 "ILL_H15_D11.instr"
    gElmtLength1);
#line 21280 "ILL_H15_D11.c"
  rot_transpose(mcrotacg2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg3 = coords_add(mcposacg2, mctc2);
  mctc1 = coords_sub(mcposacg2, mcposacg3);
  mcposrcg3 = rot_apply(mcrotacg3, mctc1);
  mcDEBUG_COMPONENT("cg3", mcposacg3, mcrotacg3)
  mccomp_posa[11] = mcposacg3;
  mccomp_posr[11] = mcposrcg3;
  mcNCounter[11]  = mcPCounter[11] = mcP2Counter[11] = 0;
  mcAbsorbProp[11]= 0;
    /* Component cg4. */
  /* Setting parameters for component cg4. */
  SIG_MESSAGE("cg4 (Init:SetPar)");
#line 327 "ILL_H15_D11.instr"
  mcccg4_w1 = gGuideWidth;
#line 327 "ILL_H15_D11.instr"
  mcccg4_h1 = gGuideHeight1;
#line 327 "ILL_H15_D11.instr"
  mcccg4_w2 = gGuideWidth;
#line 327 "ILL_H15_D11.instr"
  mcccg4_h2 = gGuideHeight1;
#line 328 "ILL_H15_D11.instr"
  mcccg4_l = ( gElmtLength1 - gElementGap );
#line 329 "ILL_H15_D11.instr"
  mcccg4_R0 = mR0;
#line 329 "ILL_H15_D11.instr"
  mcccg4_Qc = mQc;
#line 329 "ILL_H15_D11.instr"
  mcccg4_alpha = mAlpha;
#line 329 "ILL_H15_D11.instr"
  mcccg4_m = mGuide1;
#line 329 "ILL_H15_D11.instr"
  mcccg4_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg4_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg4_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg4_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg4_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg4_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg4_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg4_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg4_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg4_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg4_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg4_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg4_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg4_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg4_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg4_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg4_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg4_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg4_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg4_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg4_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg4_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg4_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg4_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg4_reflect, "NULL" ? "NULL" : "", 16384); else mcccg4_reflect[0]='\0';
#line 21362 "ILL_H15_D11.c"

  SIG_MESSAGE("cg4 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 330 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 330 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 330 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 21372 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg3, mcrotacg4);
  rot_transpose(mcrotacg3, mctr1);
  rot_mul(mcrotacg4, mctr1, mcrotrcg4);
  mctc1 = coords_set(
#line 330 "ILL_H15_D11.instr"
    0,
#line 330 "ILL_H15_D11.instr"
    0,
#line 330 "ILL_H15_D11.instr"
    gElmtLength1);
#line 21383 "ILL_H15_D11.c"
  rot_transpose(mcrotacg3, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg4 = coords_add(mcposacg3, mctc2);
  mctc1 = coords_sub(mcposacg3, mcposacg4);
  mcposrcg4 = rot_apply(mcrotacg4, mctc1);
  mcDEBUG_COMPONENT("cg4", mcposacg4, mcrotacg4)
  mccomp_posa[12] = mcposacg4;
  mccomp_posr[12] = mcposrcg4;
  mcNCounter[12]  = mcPCounter[12] = mcP2Counter[12] = 0;
  mcAbsorbProp[12]= 0;
    /* Component cg5. */
  /* Setting parameters for component cg5. */
  SIG_MESSAGE("cg5 (Init:SetPar)");
#line 332 "ILL_H15_D11.instr"
  mcccg5_w1 = gGuideWidth;
#line 332 "ILL_H15_D11.instr"
  mcccg5_h1 = gGuideHeight1;
#line 332 "ILL_H15_D11.instr"
  mcccg5_w2 = gGuideWidth;
#line 332 "ILL_H15_D11.instr"
  mcccg5_h2 = gGuideHeight1;
#line 333 "ILL_H15_D11.instr"
  mcccg5_l = ( gElmtLength1 - gElementGap );
#line 334 "ILL_H15_D11.instr"
  mcccg5_R0 = mR0;
#line 334 "ILL_H15_D11.instr"
  mcccg5_Qc = mQc;
#line 334 "ILL_H15_D11.instr"
  mcccg5_alpha = mAlpha;
#line 334 "ILL_H15_D11.instr"
  mcccg5_m = mGuide1;
#line 334 "ILL_H15_D11.instr"
  mcccg5_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg5_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg5_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg5_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg5_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg5_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg5_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg5_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg5_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg5_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg5_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg5_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg5_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg5_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg5_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg5_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg5_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg5_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg5_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg5_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg5_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg5_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg5_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg5_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg5_reflect, "NULL" ? "NULL" : "", 16384); else mcccg5_reflect[0]='\0';
#line 21465 "ILL_H15_D11.c"

  SIG_MESSAGE("cg5 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 335 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 335 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 335 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 21475 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg4, mcrotacg5);
  rot_transpose(mcrotacg4, mctr1);
  rot_mul(mcrotacg5, mctr1, mcrotrcg5);
  mctc1 = coords_set(
#line 335 "ILL_H15_D11.instr"
    0,
#line 335 "ILL_H15_D11.instr"
    0,
#line 335 "ILL_H15_D11.instr"
    gElmtLength1);
#line 21486 "ILL_H15_D11.c"
  rot_transpose(mcrotacg4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg5 = coords_add(mcposacg4, mctc2);
  mctc1 = coords_sub(mcposacg4, mcposacg5);
  mcposrcg5 = rot_apply(mcrotacg5, mctc1);
  mcDEBUG_COMPONENT("cg5", mcposacg5, mcrotacg5)
  mccomp_posa[13] = mcposacg5;
  mccomp_posr[13] = mcposrcg5;
  mcNCounter[13]  = mcPCounter[13] = mcP2Counter[13] = 0;
  mcAbsorbProp[13]= 0;
    /* Component cg6. */
  /* Setting parameters for component cg6. */
  SIG_MESSAGE("cg6 (Init:SetPar)");
#line 337 "ILL_H15_D11.instr"
  mcccg6_w1 = gGuideWidth;
#line 337 "ILL_H15_D11.instr"
  mcccg6_h1 = gGuideHeight1;
#line 337 "ILL_H15_D11.instr"
  mcccg6_w2 = gGuideWidth;
#line 337 "ILL_H15_D11.instr"
  mcccg6_h2 = gGuideHeight1;
#line 338 "ILL_H15_D11.instr"
  mcccg6_l = ( gElmtLength1 - gElementGap );
#line 339 "ILL_H15_D11.instr"
  mcccg6_R0 = mR0;
#line 339 "ILL_H15_D11.instr"
  mcccg6_Qc = mQc;
#line 339 "ILL_H15_D11.instr"
  mcccg6_alpha = mAlpha;
#line 339 "ILL_H15_D11.instr"
  mcccg6_m = mGuide1;
#line 339 "ILL_H15_D11.instr"
  mcccg6_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg6_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg6_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg6_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg6_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg6_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg6_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg6_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg6_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg6_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg6_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg6_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg6_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg6_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg6_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg6_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg6_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg6_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg6_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg6_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg6_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg6_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg6_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg6_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg6_reflect, "NULL" ? "NULL" : "", 16384); else mcccg6_reflect[0]='\0';
#line 21568 "ILL_H15_D11.c"

  SIG_MESSAGE("cg6 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 340 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 340 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 340 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 21578 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg5, mcrotacg6);
  rot_transpose(mcrotacg5, mctr1);
  rot_mul(mcrotacg6, mctr1, mcrotrcg6);
  mctc1 = coords_set(
#line 340 "ILL_H15_D11.instr"
    0,
#line 340 "ILL_H15_D11.instr"
    0,
#line 340 "ILL_H15_D11.instr"
    gElmtLength1);
#line 21589 "ILL_H15_D11.c"
  rot_transpose(mcrotacg5, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg6 = coords_add(mcposacg5, mctc2);
  mctc1 = coords_sub(mcposacg5, mcposacg6);
  mcposrcg6 = rot_apply(mcrotacg6, mctc1);
  mcDEBUG_COMPONENT("cg6", mcposacg6, mcrotacg6)
  mccomp_posa[14] = mcposacg6;
  mccomp_posr[14] = mcposrcg6;
  mcNCounter[14]  = mcPCounter[14] = mcP2Counter[14] = 0;
  mcAbsorbProp[14]= 0;
    /* Component cg7. */
  /* Setting parameters for component cg7. */
  SIG_MESSAGE("cg7 (Init:SetPar)");
#line 342 "ILL_H15_D11.instr"
  mcccg7_w1 = gGuideWidth;
#line 342 "ILL_H15_D11.instr"
  mcccg7_h1 = gGuideHeight1;
#line 342 "ILL_H15_D11.instr"
  mcccg7_w2 = gGuideWidth;
#line 342 "ILL_H15_D11.instr"
  mcccg7_h2 = gGuideHeight1;
#line 343 "ILL_H15_D11.instr"
  mcccg7_l = ( gElmtLength1 - gElementGap );
#line 344 "ILL_H15_D11.instr"
  mcccg7_R0 = mR0;
#line 344 "ILL_H15_D11.instr"
  mcccg7_Qc = mQc;
#line 344 "ILL_H15_D11.instr"
  mcccg7_alpha = mAlpha;
#line 344 "ILL_H15_D11.instr"
  mcccg7_m = mGuide1;
#line 344 "ILL_H15_D11.instr"
  mcccg7_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg7_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg7_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg7_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg7_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg7_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg7_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg7_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg7_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg7_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg7_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg7_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg7_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg7_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg7_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg7_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg7_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg7_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg7_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg7_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg7_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg7_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg7_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg7_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg7_reflect, "NULL" ? "NULL" : "", 16384); else mcccg7_reflect[0]='\0';
#line 21671 "ILL_H15_D11.c"

  SIG_MESSAGE("cg7 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 345 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 345 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 345 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 21681 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg6, mcrotacg7);
  rot_transpose(mcrotacg6, mctr1);
  rot_mul(mcrotacg7, mctr1, mcrotrcg7);
  mctc1 = coords_set(
#line 345 "ILL_H15_D11.instr"
    0,
#line 345 "ILL_H15_D11.instr"
    0,
#line 345 "ILL_H15_D11.instr"
    gElmtLength1);
#line 21692 "ILL_H15_D11.c"
  rot_transpose(mcrotacg6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg7 = coords_add(mcposacg6, mctc2);
  mctc1 = coords_sub(mcposacg6, mcposacg7);
  mcposrcg7 = rot_apply(mcrotacg7, mctc1);
  mcDEBUG_COMPONENT("cg7", mcposacg7, mcrotacg7)
  mccomp_posa[15] = mcposacg7;
  mccomp_posr[15] = mcposrcg7;
  mcNCounter[15]  = mcPCounter[15] = mcP2Counter[15] = 0;
  mcAbsorbProp[15]= 0;
    /* Component cg8. */
  /* Setting parameters for component cg8. */
  SIG_MESSAGE("cg8 (Init:SetPar)");
#line 347 "ILL_H15_D11.instr"
  mcccg8_w1 = gGuideWidth;
#line 347 "ILL_H15_D11.instr"
  mcccg8_h1 = gGuideHeight1;
#line 347 "ILL_H15_D11.instr"
  mcccg8_w2 = gGuideWidth;
#line 347 "ILL_H15_D11.instr"
  mcccg8_h2 = gGuideHeight1;
#line 348 "ILL_H15_D11.instr"
  mcccg8_l = ( gElmtLength1 - gElementGap );
#line 349 "ILL_H15_D11.instr"
  mcccg8_R0 = mR0;
#line 349 "ILL_H15_D11.instr"
  mcccg8_Qc = mQc;
#line 349 "ILL_H15_D11.instr"
  mcccg8_alpha = mAlpha;
#line 349 "ILL_H15_D11.instr"
  mcccg8_m = mGuide1;
#line 349 "ILL_H15_D11.instr"
  mcccg8_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg8_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg8_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg8_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg8_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg8_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg8_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg8_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg8_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg8_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg8_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg8_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg8_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg8_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg8_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg8_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg8_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg8_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg8_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg8_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg8_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg8_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg8_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg8_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg8_reflect, "NULL" ? "NULL" : "", 16384); else mcccg8_reflect[0]='\0';
#line 21774 "ILL_H15_D11.c"

  SIG_MESSAGE("cg8 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 350 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 350 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 350 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 21784 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg7, mcrotacg8);
  rot_transpose(mcrotacg7, mctr1);
  rot_mul(mcrotacg8, mctr1, mcrotrcg8);
  mctc1 = coords_set(
#line 350 "ILL_H15_D11.instr"
    0,
#line 350 "ILL_H15_D11.instr"
    0,
#line 350 "ILL_H15_D11.instr"
    gElmtLength1);
#line 21795 "ILL_H15_D11.c"
  rot_transpose(mcrotacg7, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg8 = coords_add(mcposacg7, mctc2);
  mctc1 = coords_sub(mcposacg7, mcposacg8);
  mcposrcg8 = rot_apply(mcrotacg8, mctc1);
  mcDEBUG_COMPONENT("cg8", mcposacg8, mcrotacg8)
  mccomp_posa[16] = mcposacg8;
  mccomp_posr[16] = mcposrcg8;
  mcNCounter[16]  = mcPCounter[16] = mcP2Counter[16] = 0;
  mcAbsorbProp[16]= 0;
    /* Component cg9. */
  /* Setting parameters for component cg9. */
  SIG_MESSAGE("cg9 (Init:SetPar)");
#line 352 "ILL_H15_D11.instr"
  mcccg9_w1 = gGuideWidth;
#line 352 "ILL_H15_D11.instr"
  mcccg9_h1 = gGuideHeight1;
#line 352 "ILL_H15_D11.instr"
  mcccg9_w2 = gGuideWidth;
#line 352 "ILL_H15_D11.instr"
  mcccg9_h2 = gGuideHeight1;
#line 353 "ILL_H15_D11.instr"
  mcccg9_l = ( gElmtLength1 - gElementGap );
#line 354 "ILL_H15_D11.instr"
  mcccg9_R0 = mR0;
#line 354 "ILL_H15_D11.instr"
  mcccg9_Qc = mQc;
#line 354 "ILL_H15_D11.instr"
  mcccg9_alpha = mAlpha;
#line 354 "ILL_H15_D11.instr"
  mcccg9_m = mGuide1;
#line 354 "ILL_H15_D11.instr"
  mcccg9_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg9_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg9_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg9_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg9_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg9_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg9_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg9_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg9_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg9_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg9_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg9_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg9_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg9_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg9_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg9_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg9_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg9_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg9_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg9_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg9_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg9_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg9_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg9_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg9_reflect, "NULL" ? "NULL" : "", 16384); else mcccg9_reflect[0]='\0';
#line 21877 "ILL_H15_D11.c"

  SIG_MESSAGE("cg9 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 355 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 355 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 355 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 21887 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg8, mcrotacg9);
  rot_transpose(mcrotacg8, mctr1);
  rot_mul(mcrotacg9, mctr1, mcrotrcg9);
  mctc1 = coords_set(
#line 355 "ILL_H15_D11.instr"
    0,
#line 355 "ILL_H15_D11.instr"
    0,
#line 355 "ILL_H15_D11.instr"
    gElmtLength1);
#line 21898 "ILL_H15_D11.c"
  rot_transpose(mcrotacg8, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg9 = coords_add(mcposacg8, mctc2);
  mctc1 = coords_sub(mcposacg8, mcposacg9);
  mcposrcg9 = rot_apply(mcrotacg9, mctc1);
  mcDEBUG_COMPONENT("cg9", mcposacg9, mcrotacg9)
  mccomp_posa[17] = mcposacg9;
  mccomp_posr[17] = mcposrcg9;
  mcNCounter[17]  = mcPCounter[17] = mcP2Counter[17] = 0;
  mcAbsorbProp[17]= 0;
    /* Component cg10. */
  /* Setting parameters for component cg10. */
  SIG_MESSAGE("cg10 (Init:SetPar)");
#line 357 "ILL_H15_D11.instr"
  mcccg10_w1 = gGuideWidth;
#line 357 "ILL_H15_D11.instr"
  mcccg10_h1 = gGuideHeight1;
#line 357 "ILL_H15_D11.instr"
  mcccg10_w2 = gGuideWidth;
#line 357 "ILL_H15_D11.instr"
  mcccg10_h2 = gGuideHeight1;
#line 358 "ILL_H15_D11.instr"
  mcccg10_l = ( gElmtLength1 - gElementGap );
#line 359 "ILL_H15_D11.instr"
  mcccg10_R0 = mR0;
#line 359 "ILL_H15_D11.instr"
  mcccg10_Qc = mQc;
#line 359 "ILL_H15_D11.instr"
  mcccg10_alpha = mAlpha;
#line 359 "ILL_H15_D11.instr"
  mcccg10_m = mGuide1;
#line 359 "ILL_H15_D11.instr"
  mcccg10_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg10_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg10_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg10_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg10_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg10_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg10_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg10_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg10_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg10_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg10_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg10_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg10_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg10_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg10_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg10_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg10_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg10_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg10_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg10_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg10_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg10_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg10_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg10_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg10_reflect, "NULL" ? "NULL" : "", 16384); else mcccg10_reflect[0]='\0';
#line 21980 "ILL_H15_D11.c"

  SIG_MESSAGE("cg10 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 360 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 360 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 360 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 21990 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg9, mcrotacg10);
  rot_transpose(mcrotacg9, mctr1);
  rot_mul(mcrotacg10, mctr1, mcrotrcg10);
  mctc1 = coords_set(
#line 360 "ILL_H15_D11.instr"
    0,
#line 360 "ILL_H15_D11.instr"
    0,
#line 360 "ILL_H15_D11.instr"
    gElmtLength1);
#line 22001 "ILL_H15_D11.c"
  rot_transpose(mcrotacg9, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg10 = coords_add(mcposacg9, mctc2);
  mctc1 = coords_sub(mcposacg9, mcposacg10);
  mcposrcg10 = rot_apply(mcrotacg10, mctc1);
  mcDEBUG_COMPONENT("cg10", mcposacg10, mcrotacg10)
  mccomp_posa[18] = mcposacg10;
  mccomp_posr[18] = mcposrcg10;
  mcNCounter[18]  = mcPCounter[18] = mcP2Counter[18] = 0;
  mcAbsorbProp[18]= 0;
    /* Component cg11. */
  /* Setting parameters for component cg11. */
  SIG_MESSAGE("cg11 (Init:SetPar)");
#line 362 "ILL_H15_D11.instr"
  mcccg11_w1 = gGuideWidth;
#line 362 "ILL_H15_D11.instr"
  mcccg11_h1 = gGuideHeight1;
#line 362 "ILL_H15_D11.instr"
  mcccg11_w2 = gGuideWidth;
#line 362 "ILL_H15_D11.instr"
  mcccg11_h2 = gGuideHeight1;
#line 363 "ILL_H15_D11.instr"
  mcccg11_l = ( gElmtLength1 - gElementGap );
#line 364 "ILL_H15_D11.instr"
  mcccg11_R0 = mR0;
#line 364 "ILL_H15_D11.instr"
  mcccg11_Qc = mQc;
#line 364 "ILL_H15_D11.instr"
  mcccg11_alpha = mAlpha;
#line 364 "ILL_H15_D11.instr"
  mcccg11_m = mGuide1;
#line 364 "ILL_H15_D11.instr"
  mcccg11_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg11_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg11_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg11_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg11_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg11_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg11_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg11_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg11_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg11_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg11_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg11_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg11_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg11_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg11_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg11_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg11_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg11_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg11_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg11_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg11_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg11_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg11_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg11_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg11_reflect, "NULL" ? "NULL" : "", 16384); else mcccg11_reflect[0]='\0';
#line 22083 "ILL_H15_D11.c"

  SIG_MESSAGE("cg11 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 365 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 365 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 365 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 22093 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg10, mcrotacg11);
  rot_transpose(mcrotacg10, mctr1);
  rot_mul(mcrotacg11, mctr1, mcrotrcg11);
  mctc1 = coords_set(
#line 365 "ILL_H15_D11.instr"
    0,
#line 365 "ILL_H15_D11.instr"
    0,
#line 365 "ILL_H15_D11.instr"
    gElmtLength1);
#line 22104 "ILL_H15_D11.c"
  rot_transpose(mcrotacg10, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg11 = coords_add(mcposacg10, mctc2);
  mctc1 = coords_sub(mcposacg10, mcposacg11);
  mcposrcg11 = rot_apply(mcrotacg11, mctc1);
  mcDEBUG_COMPONENT("cg11", mcposacg11, mcrotacg11)
  mccomp_posa[19] = mcposacg11;
  mccomp_posr[19] = mcposrcg11;
  mcNCounter[19]  = mcPCounter[19] = mcP2Counter[19] = 0;
  mcAbsorbProp[19]= 0;
    /* Component cg12. */
  /* Setting parameters for component cg12. */
  SIG_MESSAGE("cg12 (Init:SetPar)");
#line 367 "ILL_H15_D11.instr"
  mcccg12_w1 = gGuideWidth;
#line 367 "ILL_H15_D11.instr"
  mcccg12_h1 = gGuideHeight1;
#line 367 "ILL_H15_D11.instr"
  mcccg12_w2 = gGuideWidth;
#line 367 "ILL_H15_D11.instr"
  mcccg12_h2 = gGuideHeight1;
#line 368 "ILL_H15_D11.instr"
  mcccg12_l = ( gElmtLength1 - gElementGap );
#line 369 "ILL_H15_D11.instr"
  mcccg12_R0 = mR0;
#line 369 "ILL_H15_D11.instr"
  mcccg12_Qc = mQc;
#line 369 "ILL_H15_D11.instr"
  mcccg12_alpha = mAlpha;
#line 369 "ILL_H15_D11.instr"
  mcccg12_m = mGuide1;
#line 369 "ILL_H15_D11.instr"
  mcccg12_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg12_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg12_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg12_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg12_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg12_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg12_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg12_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg12_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg12_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg12_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg12_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg12_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg12_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg12_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg12_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg12_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg12_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg12_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg12_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg12_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg12_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg12_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg12_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg12_reflect, "NULL" ? "NULL" : "", 16384); else mcccg12_reflect[0]='\0';
#line 22186 "ILL_H15_D11.c"

  SIG_MESSAGE("cg12 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 370 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 370 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 370 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 22196 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg11, mcrotacg12);
  rot_transpose(mcrotacg11, mctr1);
  rot_mul(mcrotacg12, mctr1, mcrotrcg12);
  mctc1 = coords_set(
#line 370 "ILL_H15_D11.instr"
    0,
#line 370 "ILL_H15_D11.instr"
    0,
#line 370 "ILL_H15_D11.instr"
    gElmtLength1);
#line 22207 "ILL_H15_D11.c"
  rot_transpose(mcrotacg11, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg12 = coords_add(mcposacg11, mctc2);
  mctc1 = coords_sub(mcposacg11, mcposacg12);
  mcposrcg12 = rot_apply(mcrotacg12, mctc1);
  mcDEBUG_COMPONENT("cg12", mcposacg12, mcrotacg12)
  mccomp_posa[20] = mcposacg12;
  mccomp_posr[20] = mcposrcg12;
  mcNCounter[20]  = mcPCounter[20] = mcP2Counter[20] = 0;
  mcAbsorbProp[20]= 0;
    /* Component cg13. */
  /* Setting parameters for component cg13. */
  SIG_MESSAGE("cg13 (Init:SetPar)");
#line 372 "ILL_H15_D11.instr"
  mcccg13_w1 = gGuideWidth;
#line 372 "ILL_H15_D11.instr"
  mcccg13_h1 = gGuideHeight1;
#line 372 "ILL_H15_D11.instr"
  mcccg13_w2 = gGuideWidth;
#line 372 "ILL_H15_D11.instr"
  mcccg13_h2 = gGuideHeight1;
#line 373 "ILL_H15_D11.instr"
  mcccg13_l = ( gElmtLength1 - gElementGap );
#line 374 "ILL_H15_D11.instr"
  mcccg13_R0 = mR0;
#line 374 "ILL_H15_D11.instr"
  mcccg13_Qc = mQc;
#line 374 "ILL_H15_D11.instr"
  mcccg13_alpha = mAlpha;
#line 374 "ILL_H15_D11.instr"
  mcccg13_m = mGuide1;
#line 374 "ILL_H15_D11.instr"
  mcccg13_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg13_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg13_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg13_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg13_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg13_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg13_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg13_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg13_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg13_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg13_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg13_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg13_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg13_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg13_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg13_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg13_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg13_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg13_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg13_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg13_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg13_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg13_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg13_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg13_reflect, "NULL" ? "NULL" : "", 16384); else mcccg13_reflect[0]='\0';
#line 22289 "ILL_H15_D11.c"

  SIG_MESSAGE("cg13 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 375 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 375 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 375 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 22299 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg12, mcrotacg13);
  rot_transpose(mcrotacg12, mctr1);
  rot_mul(mcrotacg13, mctr1, mcrotrcg13);
  mctc1 = coords_set(
#line 375 "ILL_H15_D11.instr"
    0,
#line 375 "ILL_H15_D11.instr"
    0,
#line 375 "ILL_H15_D11.instr"
    gElmtLength1);
#line 22310 "ILL_H15_D11.c"
  rot_transpose(mcrotacg12, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg13 = coords_add(mcposacg12, mctc2);
  mctc1 = coords_sub(mcposacg12, mcposacg13);
  mcposrcg13 = rot_apply(mcrotacg13, mctc1);
  mcDEBUG_COMPONENT("cg13", mcposacg13, mcrotacg13)
  mccomp_posa[21] = mcposacg13;
  mccomp_posr[21] = mcposrcg13;
  mcNCounter[21]  = mcPCounter[21] = mcP2Counter[21] = 0;
  mcAbsorbProp[21]= 0;
    /* Component cg14. */
  /* Setting parameters for component cg14. */
  SIG_MESSAGE("cg14 (Init:SetPar)");
#line 377 "ILL_H15_D11.instr"
  mcccg14_w1 = gGuideWidth;
#line 377 "ILL_H15_D11.instr"
  mcccg14_h1 = gGuideHeight1;
#line 377 "ILL_H15_D11.instr"
  mcccg14_w2 = gGuideWidth;
#line 377 "ILL_H15_D11.instr"
  mcccg14_h2 = gGuideHeight1;
#line 378 "ILL_H15_D11.instr"
  mcccg14_l = ( gElmtLength1 - gElementGap );
#line 379 "ILL_H15_D11.instr"
  mcccg14_R0 = mR0;
#line 379 "ILL_H15_D11.instr"
  mcccg14_Qc = mQc;
#line 379 "ILL_H15_D11.instr"
  mcccg14_alpha = mAlpha;
#line 379 "ILL_H15_D11.instr"
  mcccg14_m = mGuide1;
#line 379 "ILL_H15_D11.instr"
  mcccg14_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg14_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg14_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg14_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg14_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg14_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg14_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg14_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg14_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg14_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg14_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg14_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg14_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg14_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg14_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg14_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg14_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg14_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg14_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg14_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg14_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg14_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg14_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg14_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg14_reflect, "NULL" ? "NULL" : "", 16384); else mcccg14_reflect[0]='\0';
#line 22392 "ILL_H15_D11.c"

  SIG_MESSAGE("cg14 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 380 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 380 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 380 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 22402 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg13, mcrotacg14);
  rot_transpose(mcrotacg13, mctr1);
  rot_mul(mcrotacg14, mctr1, mcrotrcg14);
  mctc1 = coords_set(
#line 380 "ILL_H15_D11.instr"
    0,
#line 380 "ILL_H15_D11.instr"
    0,
#line 380 "ILL_H15_D11.instr"
    gElmtLength1);
#line 22413 "ILL_H15_D11.c"
  rot_transpose(mcrotacg13, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg14 = coords_add(mcposacg13, mctc2);
  mctc1 = coords_sub(mcposacg13, mcposacg14);
  mcposrcg14 = rot_apply(mcrotacg14, mctc1);
  mcDEBUG_COMPONENT("cg14", mcposacg14, mcrotacg14)
  mccomp_posa[22] = mcposacg14;
  mccomp_posr[22] = mcposrcg14;
  mcNCounter[22]  = mcPCounter[22] = mcP2Counter[22] = 0;
  mcAbsorbProp[22]= 0;
    /* Component cg15. */
  /* Setting parameters for component cg15. */
  SIG_MESSAGE("cg15 (Init:SetPar)");
#line 382 "ILL_H15_D11.instr"
  mcccg15_w1 = gGuideWidth;
#line 382 "ILL_H15_D11.instr"
  mcccg15_h1 = gGuideHeight1;
#line 382 "ILL_H15_D11.instr"
  mcccg15_w2 = gGuideWidth;
#line 382 "ILL_H15_D11.instr"
  mcccg15_h2 = gGuideHeight1;
#line 383 "ILL_H15_D11.instr"
  mcccg15_l = ( gElmtLength1 - gElementGap );
#line 384 "ILL_H15_D11.instr"
  mcccg15_R0 = mR0;
#line 384 "ILL_H15_D11.instr"
  mcccg15_Qc = mQc;
#line 384 "ILL_H15_D11.instr"
  mcccg15_alpha = mAlpha;
#line 384 "ILL_H15_D11.instr"
  mcccg15_m = mGuide1;
#line 384 "ILL_H15_D11.instr"
  mcccg15_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg15_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg15_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg15_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg15_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg15_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg15_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg15_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg15_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg15_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg15_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg15_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg15_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg15_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg15_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg15_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg15_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg15_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg15_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg15_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg15_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg15_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg15_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg15_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg15_reflect, "NULL" ? "NULL" : "", 16384); else mcccg15_reflect[0]='\0';
#line 22495 "ILL_H15_D11.c"

  SIG_MESSAGE("cg15 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 385 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 385 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 385 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 22505 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg14, mcrotacg15);
  rot_transpose(mcrotacg14, mctr1);
  rot_mul(mcrotacg15, mctr1, mcrotrcg15);
  mctc1 = coords_set(
#line 385 "ILL_H15_D11.instr"
    0,
#line 385 "ILL_H15_D11.instr"
    0,
#line 385 "ILL_H15_D11.instr"
    gElmtLength1);
#line 22516 "ILL_H15_D11.c"
  rot_transpose(mcrotacg14, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg15 = coords_add(mcposacg14, mctc2);
  mctc1 = coords_sub(mcposacg14, mcposacg15);
  mcposrcg15 = rot_apply(mcrotacg15, mctc1);
  mcDEBUG_COMPONENT("cg15", mcposacg15, mcrotacg15)
  mccomp_posa[23] = mcposacg15;
  mccomp_posr[23] = mcposrcg15;
  mcNCounter[23]  = mcPCounter[23] = mcP2Counter[23] = 0;
  mcAbsorbProp[23]= 0;
    /* Component cg16. */
  /* Setting parameters for component cg16. */
  SIG_MESSAGE("cg16 (Init:SetPar)");
#line 387 "ILL_H15_D11.instr"
  mcccg16_w1 = gGuideWidth;
#line 387 "ILL_H15_D11.instr"
  mcccg16_h1 = gGuideHeight1;
#line 387 "ILL_H15_D11.instr"
  mcccg16_w2 = gGuideWidth;
#line 387 "ILL_H15_D11.instr"
  mcccg16_h2 = gGuideHeight1;
#line 388 "ILL_H15_D11.instr"
  mcccg16_l = ( gElmtLength1 - gElementGap );
#line 389 "ILL_H15_D11.instr"
  mcccg16_R0 = mR0;
#line 389 "ILL_H15_D11.instr"
  mcccg16_Qc = mQc;
#line 389 "ILL_H15_D11.instr"
  mcccg16_alpha = mAlpha;
#line 389 "ILL_H15_D11.instr"
  mcccg16_m = mGuide1;
#line 389 "ILL_H15_D11.instr"
  mcccg16_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg16_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg16_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg16_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg16_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg16_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg16_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg16_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg16_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg16_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg16_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg16_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg16_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg16_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg16_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg16_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg16_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg16_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg16_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg16_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg16_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg16_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg16_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg16_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg16_reflect, "NULL" ? "NULL" : "", 16384); else mcccg16_reflect[0]='\0';
#line 22598 "ILL_H15_D11.c"

  SIG_MESSAGE("cg16 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 390 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 390 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 390 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 22608 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg15, mcrotacg16);
  rot_transpose(mcrotacg15, mctr1);
  rot_mul(mcrotacg16, mctr1, mcrotrcg16);
  mctc1 = coords_set(
#line 390 "ILL_H15_D11.instr"
    0,
#line 390 "ILL_H15_D11.instr"
    0,
#line 390 "ILL_H15_D11.instr"
    gElmtLength1);
#line 22619 "ILL_H15_D11.c"
  rot_transpose(mcrotacg15, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg16 = coords_add(mcposacg15, mctc2);
  mctc1 = coords_sub(mcposacg15, mcposacg16);
  mcposrcg16 = rot_apply(mcrotacg16, mctc1);
  mcDEBUG_COMPONENT("cg16", mcposacg16, mcrotacg16)
  mccomp_posa[24] = mcposacg16;
  mccomp_posr[24] = mcposrcg16;
  mcNCounter[24]  = mcPCounter[24] = mcP2Counter[24] = 0;
  mcAbsorbProp[24]= 0;
    /* Component cg17. */
  /* Setting parameters for component cg17. */
  SIG_MESSAGE("cg17 (Init:SetPar)");
#line 392 "ILL_H15_D11.instr"
  mcccg17_w1 = gGuideWidth;
#line 392 "ILL_H15_D11.instr"
  mcccg17_h1 = gGuideHeight1;
#line 392 "ILL_H15_D11.instr"
  mcccg17_w2 = gGuideWidth;
#line 392 "ILL_H15_D11.instr"
  mcccg17_h2 = gGuideHeight1;
#line 393 "ILL_H15_D11.instr"
  mcccg17_l = ( gElmtLength1 - gElementGap );
#line 394 "ILL_H15_D11.instr"
  mcccg17_R0 = mR0;
#line 394 "ILL_H15_D11.instr"
  mcccg17_Qc = mQc;
#line 394 "ILL_H15_D11.instr"
  mcccg17_alpha = mAlpha;
#line 394 "ILL_H15_D11.instr"
  mcccg17_m = mGuide1;
#line 394 "ILL_H15_D11.instr"
  mcccg17_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg17_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg17_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg17_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg17_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg17_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg17_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg17_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg17_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg17_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg17_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg17_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg17_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg17_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg17_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg17_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg17_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg17_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg17_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg17_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg17_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg17_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg17_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg17_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg17_reflect, "NULL" ? "NULL" : "", 16384); else mcccg17_reflect[0]='\0';
#line 22701 "ILL_H15_D11.c"

  SIG_MESSAGE("cg17 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 395 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 395 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 395 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 22711 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg16, mcrotacg17);
  rot_transpose(mcrotacg16, mctr1);
  rot_mul(mcrotacg17, mctr1, mcrotrcg17);
  mctc1 = coords_set(
#line 395 "ILL_H15_D11.instr"
    0,
#line 395 "ILL_H15_D11.instr"
    0,
#line 395 "ILL_H15_D11.instr"
    gElmtLength1);
#line 22722 "ILL_H15_D11.c"
  rot_transpose(mcrotacg16, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg17 = coords_add(mcposacg16, mctc2);
  mctc1 = coords_sub(mcposacg16, mcposacg17);
  mcposrcg17 = rot_apply(mcrotacg17, mctc1);
  mcDEBUG_COMPONENT("cg17", mcposacg17, mcrotacg17)
  mccomp_posa[25] = mcposacg17;
  mccomp_posr[25] = mcposrcg17;
  mcNCounter[25]  = mcPCounter[25] = mcP2Counter[25] = 0;
  mcAbsorbProp[25]= 0;
    /* Component cg18. */
  /* Setting parameters for component cg18. */
  SIG_MESSAGE("cg18 (Init:SetPar)");
#line 397 "ILL_H15_D11.instr"
  mcccg18_w1 = gGuideWidth;
#line 397 "ILL_H15_D11.instr"
  mcccg18_h1 = gGuideHeight1;
#line 397 "ILL_H15_D11.instr"
  mcccg18_w2 = gGuideWidth;
#line 397 "ILL_H15_D11.instr"
  mcccg18_h2 = gGuideHeight1;
#line 398 "ILL_H15_D11.instr"
  mcccg18_l = ( gElmtLength1 - gElementGap );
#line 399 "ILL_H15_D11.instr"
  mcccg18_R0 = mR0;
#line 399 "ILL_H15_D11.instr"
  mcccg18_Qc = mQc;
#line 399 "ILL_H15_D11.instr"
  mcccg18_alpha = mAlpha;
#line 399 "ILL_H15_D11.instr"
  mcccg18_m = mGuide1;
#line 399 "ILL_H15_D11.instr"
  mcccg18_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg18_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg18_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg18_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg18_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg18_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg18_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg18_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg18_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg18_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg18_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg18_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg18_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg18_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg18_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg18_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg18_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg18_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg18_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg18_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg18_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg18_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg18_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg18_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg18_reflect, "NULL" ? "NULL" : "", 16384); else mcccg18_reflect[0]='\0';
#line 22804 "ILL_H15_D11.c"

  SIG_MESSAGE("cg18 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 400 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 400 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 400 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 22814 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg17, mcrotacg18);
  rot_transpose(mcrotacg17, mctr1);
  rot_mul(mcrotacg18, mctr1, mcrotrcg18);
  mctc1 = coords_set(
#line 400 "ILL_H15_D11.instr"
    0,
#line 400 "ILL_H15_D11.instr"
    0,
#line 400 "ILL_H15_D11.instr"
    gElmtLength1);
#line 22825 "ILL_H15_D11.c"
  rot_transpose(mcrotacg17, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg18 = coords_add(mcposacg17, mctc2);
  mctc1 = coords_sub(mcposacg17, mcposacg18);
  mcposrcg18 = rot_apply(mcrotacg18, mctc1);
  mcDEBUG_COMPONENT("cg18", mcposacg18, mcrotacg18)
  mccomp_posa[26] = mcposacg18;
  mccomp_posr[26] = mcposrcg18;
  mcNCounter[26]  = mcPCounter[26] = mcP2Counter[26] = 0;
  mcAbsorbProp[26]= 0;
    /* Component cg19. */
  /* Setting parameters for component cg19. */
  SIG_MESSAGE("cg19 (Init:SetPar)");
#line 402 "ILL_H15_D11.instr"
  mcccg19_w1 = gGuideWidth;
#line 402 "ILL_H15_D11.instr"
  mcccg19_h1 = gGuideHeight1;
#line 402 "ILL_H15_D11.instr"
  mcccg19_w2 = gGuideWidth;
#line 402 "ILL_H15_D11.instr"
  mcccg19_h2 = gGuideHeight1;
#line 403 "ILL_H15_D11.instr"
  mcccg19_l = ( gElmtLength1 - gElementGap );
#line 404 "ILL_H15_D11.instr"
  mcccg19_R0 = mR0;
#line 404 "ILL_H15_D11.instr"
  mcccg19_Qc = mQc;
#line 404 "ILL_H15_D11.instr"
  mcccg19_alpha = mAlpha;
#line 404 "ILL_H15_D11.instr"
  mcccg19_m = mGuide1;
#line 404 "ILL_H15_D11.instr"
  mcccg19_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg19_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg19_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg19_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg19_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg19_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg19_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg19_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg19_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg19_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg19_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg19_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg19_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg19_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg19_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg19_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg19_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg19_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg19_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg19_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg19_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg19_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg19_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg19_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg19_reflect, "NULL" ? "NULL" : "", 16384); else mcccg19_reflect[0]='\0';
#line 22907 "ILL_H15_D11.c"

  SIG_MESSAGE("cg19 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 405 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 405 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 405 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 22917 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg18, mcrotacg19);
  rot_transpose(mcrotacg18, mctr1);
  rot_mul(mcrotacg19, mctr1, mcrotrcg19);
  mctc1 = coords_set(
#line 405 "ILL_H15_D11.instr"
    0,
#line 405 "ILL_H15_D11.instr"
    0,
#line 405 "ILL_H15_D11.instr"
    gElmtLength1);
#line 22928 "ILL_H15_D11.c"
  rot_transpose(mcrotacg18, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg19 = coords_add(mcposacg18, mctc2);
  mctc1 = coords_sub(mcposacg18, mcposacg19);
  mcposrcg19 = rot_apply(mcrotacg19, mctc1);
  mcDEBUG_COMPONENT("cg19", mcposacg19, mcrotacg19)
  mccomp_posa[27] = mcposacg19;
  mccomp_posr[27] = mcposrcg19;
  mcNCounter[27]  = mcPCounter[27] = mcP2Counter[27] = 0;
  mcAbsorbProp[27]= 0;
    /* Component cg20. */
  /* Setting parameters for component cg20. */
  SIG_MESSAGE("cg20 (Init:SetPar)");
#line 407 "ILL_H15_D11.instr"
  mcccg20_w1 = gGuideWidth;
#line 407 "ILL_H15_D11.instr"
  mcccg20_h1 = gGuideHeight1;
#line 407 "ILL_H15_D11.instr"
  mcccg20_w2 = gGuideWidth;
#line 407 "ILL_H15_D11.instr"
  mcccg20_h2 = gGuideHeight1;
#line 408 "ILL_H15_D11.instr"
  mcccg20_l = ( gElmtLength1 - gElementGap );
#line 409 "ILL_H15_D11.instr"
  mcccg20_R0 = mR0;
#line 409 "ILL_H15_D11.instr"
  mcccg20_Qc = mQc;
#line 409 "ILL_H15_D11.instr"
  mcccg20_alpha = mAlpha;
#line 409 "ILL_H15_D11.instr"
  mcccg20_m = mGuide1;
#line 409 "ILL_H15_D11.instr"
  mcccg20_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg20_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg20_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg20_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg20_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg20_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg20_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg20_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg20_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg20_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg20_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg20_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg20_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg20_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg20_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg20_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg20_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg20_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg20_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg20_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg20_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg20_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg20_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg20_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg20_reflect, "NULL" ? "NULL" : "", 16384); else mcccg20_reflect[0]='\0';
#line 23010 "ILL_H15_D11.c"

  SIG_MESSAGE("cg20 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 410 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 410 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 410 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 23020 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg19, mcrotacg20);
  rot_transpose(mcrotacg19, mctr1);
  rot_mul(mcrotacg20, mctr1, mcrotrcg20);
  mctc1 = coords_set(
#line 410 "ILL_H15_D11.instr"
    0,
#line 410 "ILL_H15_D11.instr"
    0,
#line 410 "ILL_H15_D11.instr"
    gElmtLength1);
#line 23031 "ILL_H15_D11.c"
  rot_transpose(mcrotacg19, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg20 = coords_add(mcposacg19, mctc2);
  mctc1 = coords_sub(mcposacg19, mcposacg20);
  mcposrcg20 = rot_apply(mcrotacg20, mctc1);
  mcDEBUG_COMPONENT("cg20", mcposacg20, mcrotacg20)
  mccomp_posa[28] = mcposacg20;
  mccomp_posr[28] = mcposrcg20;
  mcNCounter[28]  = mcPCounter[28] = mcP2Counter[28] = 0;
  mcAbsorbProp[28]= 0;
    /* Component cg21. */
  /* Setting parameters for component cg21. */
  SIG_MESSAGE("cg21 (Init:SetPar)");
#line 412 "ILL_H15_D11.instr"
  mcccg21_w1 = gGuideWidth;
#line 412 "ILL_H15_D11.instr"
  mcccg21_h1 = gGuideHeight1;
#line 412 "ILL_H15_D11.instr"
  mcccg21_w2 = gGuideWidth;
#line 412 "ILL_H15_D11.instr"
  mcccg21_h2 = gGuideHeight1;
#line 413 "ILL_H15_D11.instr"
  mcccg21_l = ( gElmtLength1 - gElementGap );
#line 414 "ILL_H15_D11.instr"
  mcccg21_R0 = mR0;
#line 414 "ILL_H15_D11.instr"
  mcccg21_Qc = mQc;
#line 414 "ILL_H15_D11.instr"
  mcccg21_alpha = mAlpha;
#line 414 "ILL_H15_D11.instr"
  mcccg21_m = mGuide1;
#line 414 "ILL_H15_D11.instr"
  mcccg21_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg21_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg21_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg21_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg21_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg21_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg21_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg21_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg21_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg21_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg21_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg21_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg21_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg21_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg21_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg21_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg21_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg21_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg21_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg21_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg21_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg21_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg21_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg21_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg21_reflect, "NULL" ? "NULL" : "", 16384); else mcccg21_reflect[0]='\0';
#line 23113 "ILL_H15_D11.c"

  SIG_MESSAGE("cg21 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 415 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 415 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 415 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 23123 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg20, mcrotacg21);
  rot_transpose(mcrotacg20, mctr1);
  rot_mul(mcrotacg21, mctr1, mcrotrcg21);
  mctc1 = coords_set(
#line 415 "ILL_H15_D11.instr"
    0,
#line 415 "ILL_H15_D11.instr"
    0,
#line 415 "ILL_H15_D11.instr"
    gElmtLength1);
#line 23134 "ILL_H15_D11.c"
  rot_transpose(mcrotacg20, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg21 = coords_add(mcposacg20, mctc2);
  mctc1 = coords_sub(mcposacg20, mcposacg21);
  mcposrcg21 = rot_apply(mcrotacg21, mctc1);
  mcDEBUG_COMPONENT("cg21", mcposacg21, mcrotacg21)
  mccomp_posa[29] = mcposacg21;
  mccomp_posr[29] = mcposrcg21;
  mcNCounter[29]  = mcPCounter[29] = mcP2Counter[29] = 0;
  mcAbsorbProp[29]= 0;
    /* Component cg22. */
  /* Setting parameters for component cg22. */
  SIG_MESSAGE("cg22 (Init:SetPar)");
#line 417 "ILL_H15_D11.instr"
  mcccg22_w1 = gGuideWidth;
#line 417 "ILL_H15_D11.instr"
  mcccg22_h1 = gGuideHeight1;
#line 417 "ILL_H15_D11.instr"
  mcccg22_w2 = gGuideWidth;
#line 417 "ILL_H15_D11.instr"
  mcccg22_h2 = gGuideHeight1;
#line 418 "ILL_H15_D11.instr"
  mcccg22_l = ( gElmtLength1 - gElementGap );
#line 419 "ILL_H15_D11.instr"
  mcccg22_R0 = mR0;
#line 419 "ILL_H15_D11.instr"
  mcccg22_Qc = mQc;
#line 419 "ILL_H15_D11.instr"
  mcccg22_alpha = mAlpha;
#line 419 "ILL_H15_D11.instr"
  mcccg22_m = mGuide1;
#line 419 "ILL_H15_D11.instr"
  mcccg22_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg22_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg22_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg22_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg22_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg22_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg22_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg22_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg22_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg22_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg22_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg22_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg22_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg22_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg22_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg22_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg22_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg22_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg22_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg22_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg22_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg22_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg22_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg22_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg22_reflect, "NULL" ? "NULL" : "", 16384); else mcccg22_reflect[0]='\0';
#line 23216 "ILL_H15_D11.c"

  SIG_MESSAGE("cg22 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 420 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 420 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 420 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 23226 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg21, mcrotacg22);
  rot_transpose(mcrotacg21, mctr1);
  rot_mul(mcrotacg22, mctr1, mcrotrcg22);
  mctc1 = coords_set(
#line 420 "ILL_H15_D11.instr"
    0,
#line 420 "ILL_H15_D11.instr"
    0,
#line 420 "ILL_H15_D11.instr"
    gElmtLength1);
#line 23237 "ILL_H15_D11.c"
  rot_transpose(mcrotacg21, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg22 = coords_add(mcposacg21, mctc2);
  mctc1 = coords_sub(mcposacg21, mcposacg22);
  mcposrcg22 = rot_apply(mcrotacg22, mctc1);
  mcDEBUG_COMPONENT("cg22", mcposacg22, mcrotacg22)
  mccomp_posa[30] = mcposacg22;
  mccomp_posr[30] = mcposrcg22;
  mcNCounter[30]  = mcPCounter[30] = mcP2Counter[30] = 0;
  mcAbsorbProp[30]= 0;
    /* Component cg23. */
  /* Setting parameters for component cg23. */
  SIG_MESSAGE("cg23 (Init:SetPar)");
#line 422 "ILL_H15_D11.instr"
  mcccg23_w1 = gGuideWidth;
#line 422 "ILL_H15_D11.instr"
  mcccg23_h1 = gGuideHeight1;
#line 422 "ILL_H15_D11.instr"
  mcccg23_w2 = gGuideWidth;
#line 422 "ILL_H15_D11.instr"
  mcccg23_h2 = gGuideHeight1;
#line 423 "ILL_H15_D11.instr"
  mcccg23_l = ( gElmtLength1 - gElementGap );
#line 424 "ILL_H15_D11.instr"
  mcccg23_R0 = mR0;
#line 424 "ILL_H15_D11.instr"
  mcccg23_Qc = mQc;
#line 424 "ILL_H15_D11.instr"
  mcccg23_alpha = mAlpha;
#line 424 "ILL_H15_D11.instr"
  mcccg23_m = mGuide1;
#line 424 "ILL_H15_D11.instr"
  mcccg23_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg23_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg23_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg23_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg23_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg23_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg23_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg23_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg23_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg23_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg23_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg23_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg23_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg23_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg23_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg23_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg23_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg23_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg23_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg23_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg23_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg23_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg23_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg23_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg23_reflect, "NULL" ? "NULL" : "", 16384); else mcccg23_reflect[0]='\0';
#line 23319 "ILL_H15_D11.c"

  SIG_MESSAGE("cg23 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 425 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 425 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 425 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 23329 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg22, mcrotacg23);
  rot_transpose(mcrotacg22, mctr1);
  rot_mul(mcrotacg23, mctr1, mcrotrcg23);
  mctc1 = coords_set(
#line 425 "ILL_H15_D11.instr"
    0,
#line 425 "ILL_H15_D11.instr"
    0,
#line 425 "ILL_H15_D11.instr"
    gElmtLength1);
#line 23340 "ILL_H15_D11.c"
  rot_transpose(mcrotacg22, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg23 = coords_add(mcposacg22, mctc2);
  mctc1 = coords_sub(mcposacg22, mcposacg23);
  mcposrcg23 = rot_apply(mcrotacg23, mctc1);
  mcDEBUG_COMPONENT("cg23", mcposacg23, mcrotacg23)
  mccomp_posa[31] = mcposacg23;
  mccomp_posr[31] = mcposrcg23;
  mcNCounter[31]  = mcPCounter[31] = mcP2Counter[31] = 0;
  mcAbsorbProp[31]= 0;
    /* Component cg24. */
  /* Setting parameters for component cg24. */
  SIG_MESSAGE("cg24 (Init:SetPar)");
#line 427 "ILL_H15_D11.instr"
  mcccg24_w1 = gGuideWidth;
#line 427 "ILL_H15_D11.instr"
  mcccg24_h1 = gGuideHeight1;
#line 427 "ILL_H15_D11.instr"
  mcccg24_w2 = gGuideWidth;
#line 427 "ILL_H15_D11.instr"
  mcccg24_h2 = gGuideHeight1;
#line 428 "ILL_H15_D11.instr"
  mcccg24_l = ( gElmtLength1 - gElementGap );
#line 429 "ILL_H15_D11.instr"
  mcccg24_R0 = mR0;
#line 429 "ILL_H15_D11.instr"
  mcccg24_Qc = mQc;
#line 429 "ILL_H15_D11.instr"
  mcccg24_alpha = mAlpha;
#line 429 "ILL_H15_D11.instr"
  mcccg24_m = mGuide1;
#line 429 "ILL_H15_D11.instr"
  mcccg24_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg24_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg24_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg24_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg24_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg24_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg24_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg24_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg24_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg24_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg24_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg24_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg24_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg24_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg24_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg24_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg24_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg24_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg24_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg24_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg24_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg24_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg24_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg24_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg24_reflect, "NULL" ? "NULL" : "", 16384); else mcccg24_reflect[0]='\0';
#line 23422 "ILL_H15_D11.c"

  SIG_MESSAGE("cg24 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 430 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 430 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 430 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 23432 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg23, mcrotacg24);
  rot_transpose(mcrotacg23, mctr1);
  rot_mul(mcrotacg24, mctr1, mcrotrcg24);
  mctc1 = coords_set(
#line 430 "ILL_H15_D11.instr"
    0,
#line 430 "ILL_H15_D11.instr"
    0,
#line 430 "ILL_H15_D11.instr"
    gElmtLength1);
#line 23443 "ILL_H15_D11.c"
  rot_transpose(mcrotacg23, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg24 = coords_add(mcposacg23, mctc2);
  mctc1 = coords_sub(mcposacg23, mcposacg24);
  mcposrcg24 = rot_apply(mcrotacg24, mctc1);
  mcDEBUG_COMPONENT("cg24", mcposacg24, mcrotacg24)
  mccomp_posa[32] = mcposacg24;
  mccomp_posr[32] = mcposrcg24;
  mcNCounter[32]  = mcPCounter[32] = mcP2Counter[32] = 0;
  mcAbsorbProp[32]= 0;
    /* Component cg25. */
  /* Setting parameters for component cg25. */
  SIG_MESSAGE("cg25 (Init:SetPar)");
#line 432 "ILL_H15_D11.instr"
  mcccg25_w1 = gGuideWidth;
#line 432 "ILL_H15_D11.instr"
  mcccg25_h1 = gGuideHeight1;
#line 432 "ILL_H15_D11.instr"
  mcccg25_w2 = gGuideWidth;
#line 432 "ILL_H15_D11.instr"
  mcccg25_h2 = gGuideHeight1;
#line 433 "ILL_H15_D11.instr"
  mcccg25_l = ( gElmtLength1 - gElementGap );
#line 434 "ILL_H15_D11.instr"
  mcccg25_R0 = mR0;
#line 434 "ILL_H15_D11.instr"
  mcccg25_Qc = mQc;
#line 434 "ILL_H15_D11.instr"
  mcccg25_alpha = mAlpha;
#line 434 "ILL_H15_D11.instr"
  mcccg25_m = mGuide1;
#line 434 "ILL_H15_D11.instr"
  mcccg25_W = mW;
#line 114 "ILL_H15_D11.instr"
  mcccg25_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mcccg25_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mcccg25_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg25_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg25_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg25_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mcccg25_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mcccg25_G = 0;
#line 116 "ILL_H15_D11.instr"
  mcccg25_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg25_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg25_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mcccg25_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mcccg25_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg25_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg25_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mcccg25_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg25_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg25_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg25_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg25_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mcccg25_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mcccg25_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mcccg25_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mcccg25_reflect, "NULL" ? "NULL" : "", 16384); else mcccg25_reflect[0]='\0';
#line 23525 "ILL_H15_D11.c"

  SIG_MESSAGE("cg25 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
#line 435 "ILL_H15_D11.instr"
    (0)*DEG2RAD,
#line 435 "ILL_H15_D11.instr"
    (gElmtRot1)*DEG2RAD,
#line 435 "ILL_H15_D11.instr"
    (0)*DEG2RAD);
#line 23535 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg24, mcrotacg25);
  rot_transpose(mcrotacg24, mctr1);
  rot_mul(mcrotacg25, mctr1, mcrotrcg25);
  mctc1 = coords_set(
#line 435 "ILL_H15_D11.instr"
    0,
#line 435 "ILL_H15_D11.instr"
    0,
#line 435 "ILL_H15_D11.instr"
    gElmtLength1);
#line 23546 "ILL_H15_D11.c"
  rot_transpose(mcrotacg24, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposacg25 = coords_add(mcposacg24, mctc2);
  mctc1 = coords_sub(mcposacg24, mcposacg25);
  mcposrcg25 = rot_apply(mcrotacg25, mctc1);
  mcDEBUG_COMPONENT("cg25", mcposacg25, mcrotacg25)
  mccomp_posa[33] = mcposacg25;
  mccomp_posr[33] = mcposrcg25;
  mcNCounter[33]  = mcPCounter[33] = mcP2Counter[33] = 0;
  mcAbsorbProp[33]= 0;
    /* Component AlWindow4. */
  /* Setting parameters for component AlWindow4. */
  SIG_MESSAGE("AlWindow4 (Init:SetPar)");
#line 439 "ILL_H15_D11.instr"
  mccAlWindow4_thickness = 0.002;
#line 23562 "ILL_H15_D11.c"

  SIG_MESSAGE("AlWindow4 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23569 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg25, mcrotaAlWindow4);
  rot_transpose(mcrotacg25, mctr1);
  rot_mul(mcrotaAlWindow4, mctr1, mcrotrAlWindow4);
  mctc1 = coords_set(
#line 440 "ILL_H15_D11.instr"
    0,
#line 440 "ILL_H15_D11.instr"
    0,
#line 440 "ILL_H15_D11.instr"
    gElmtLength1 + 0.001);
#line 23580 "ILL_H15_D11.c"
  rot_transpose(mcrotacg25, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAlWindow4 = coords_add(mcposacg25, mctc2);
  mctc1 = coords_sub(mcposacg25, mcposaAlWindow4);
  mcposrAlWindow4 = rot_apply(mcrotaAlWindow4, mctc1);
  mcDEBUG_COMPONENT("AlWindow4", mcposaAlWindow4, mcrotaAlWindow4)
  mccomp_posa[34] = mcposaAlWindow4;
  mccomp_posr[34] = mcposrAlWindow4;
  mcNCounter[34]  = mcPCounter[34] = mcP2Counter[34] = 0;
  mcAbsorbProp[34]= 0;
    /* Component PSD_VTE. */
  /* Setting parameters for component PSD_VTE. */
  SIG_MESSAGE("PSD_VTE (Init:SetPar)");
#line 442 "ILL_H15_D11.instr"
  mccPSD_VTE_xwidth = gGuideWidth;
#line 442 "ILL_H15_D11.instr"
  mccPSD_VTE_yheight = gGuideHeight1;
#line 203 "ILL_H15_D11.instr"
  mccPSD_VTE_zdepth = 0;
#line 204 "ILL_H15_D11.instr"
  mccPSD_VTE_xmin = 0;
#line 204 "ILL_H15_D11.instr"
  mccPSD_VTE_xmax = 0;
#line 204 "ILL_H15_D11.instr"
  mccPSD_VTE_ymin = 0;
#line 204 "ILL_H15_D11.instr"
  mccPSD_VTE_ymax = 0;
#line 204 "ILL_H15_D11.instr"
  mccPSD_VTE_zmin = 0;
#line 204 "ILL_H15_D11.instr"
  mccPSD_VTE_zmax = 0;
#line 205 "ILL_H15_D11.instr"
  mccPSD_VTE_bins = 0;
#line 205 "ILL_H15_D11.instr"
  mccPSD_VTE_min = -1e40;
#line 205 "ILL_H15_D11.instr"
  mccPSD_VTE_max = 1e40;
#line 205 "ILL_H15_D11.instr"
  mccPSD_VTE_restore_neutron = 0;
#line 205 "ILL_H15_D11.instr"
  mccPSD_VTE_radius = 0;
#line 443 "ILL_H15_D11.instr"
  if("x y") strncpy(mccPSD_VTE_options, "x y" ? "x y" : "", 16384); else mccPSD_VTE_options[0]='\0';
#line 206 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccPSD_VTE_filename, "NULL" ? "NULL" : "", 16384); else mccPSD_VTE_filename[0]='\0';
#line 206 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccPSD_VTE_geometry, "NULL" ? "NULL" : "", 16384); else mccPSD_VTE_geometry[0]='\0';
#line 207 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccPSD_VTE_username1, "NULL" ? "NULL" : "", 16384); else mccPSD_VTE_username1[0]='\0';
#line 207 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccPSD_VTE_username2, "NULL" ? "NULL" : "", 16384); else mccPSD_VTE_username2[0]='\0';
#line 207 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccPSD_VTE_username3, "NULL" ? "NULL" : "", 16384); else mccPSD_VTE_username3[0]='\0';
#line 208 "ILL_H15_D11.instr"
  mccPSD_VTE_nowritefile = 0;
#line 23636 "ILL_H15_D11.c"

  SIG_MESSAGE("PSD_VTE (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23643 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg25, mcrotaPSD_VTE);
  rot_transpose(mcrotaAlWindow4, mctr1);
  rot_mul(mcrotaPSD_VTE, mctr1, mcrotrPSD_VTE);
  mctc1 = coords_set(
#line 444 "ILL_H15_D11.instr"
    0,
#line 444 "ILL_H15_D11.instr"
    0,
#line 444 "ILL_H15_D11.instr"
    gElmtLength1 + 0.13);
#line 23654 "ILL_H15_D11.c"
  rot_transpose(mcrotacg25, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPSD_VTE = coords_add(mcposacg25, mctc2);
  mctc1 = coords_sub(mcposaAlWindow4, mcposaPSD_VTE);
  mcposrPSD_VTE = rot_apply(mcrotaPSD_VTE, mctc1);
  mcDEBUG_COMPONENT("PSD_VTE", mcposaPSD_VTE, mcrotaPSD_VTE)
  mccomp_posa[35] = mcposaPSD_VTE;
  mccomp_posr[35] = mcposrPSD_VTE;
  mcNCounter[35]  = mcPCounter[35] = mcP2Counter[35] = 0;
  mcAbsorbProp[35]= 0;
    /* Component AlWindow5. */
  /* Setting parameters for component AlWindow5. */
  SIG_MESSAGE("AlWindow5 (Init:SetPar)");
#line 446 "ILL_H15_D11.instr"
  mccAlWindow5_thickness = 0.002;
#line 23670 "ILL_H15_D11.c"

  SIG_MESSAGE("AlWindow5 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23677 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg25, mcrotaAlWindow5);
  rot_transpose(mcrotaPSD_VTE, mctr1);
  rot_mul(mcrotaAlWindow5, mctr1, mcrotrAlWindow5);
  mctc1 = coords_set(
#line 447 "ILL_H15_D11.instr"
    0,
#line 447 "ILL_H15_D11.instr"
    0,
#line 447 "ILL_H15_D11.instr"
    gElmtLength1 + 0.26 -0.003);
#line 23688 "ILL_H15_D11.c"
  rot_transpose(mcrotacg25, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAlWindow5 = coords_add(mcposacg25, mctc2);
  mctc1 = coords_sub(mcposaPSD_VTE, mcposaAlWindow5);
  mcposrAlWindow5 = rot_apply(mcrotaAlWindow5, mctc1);
  mcDEBUG_COMPONENT("AlWindow5", mcposaAlWindow5, mcrotaAlWindow5)
  mccomp_posa[36] = mcposaAlWindow5;
  mccomp_posr[36] = mcposrAlWindow5;
  mcNCounter[36]  = mcPCounter[36] = mcP2Counter[36] = 0;
  mcAbsorbProp[36]= 0;
    /* Component VTEtoIN6GuideStart. */
  /* Setting parameters for component VTEtoIN6GuideStart. */
  SIG_MESSAGE("VTEtoIN6GuideStart (Init:SetPar)");

  SIG_MESSAGE("VTEtoIN6GuideStart (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23708 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotacg25, mcrotaVTEtoIN6GuideStart);
  rot_transpose(mcrotaAlWindow5, mctr1);
  rot_mul(mcrotaVTEtoIN6GuideStart, mctr1, mcrotrVTEtoIN6GuideStart);
  mctc1 = coords_set(
#line 450 "ILL_H15_D11.instr"
    0,
#line 450 "ILL_H15_D11.instr"
    0,
#line 450 "ILL_H15_D11.instr"
    gElmtLength1 + 0.26);
#line 23719 "ILL_H15_D11.c"
  rot_transpose(mcrotacg25, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaVTEtoIN6GuideStart = coords_add(mcposacg25, mctc2);
  mctc1 = coords_sub(mcposaAlWindow5, mcposaVTEtoIN6GuideStart);
  mcposrVTEtoIN6GuideStart = rot_apply(mcrotaVTEtoIN6GuideStart, mctc1);
  mcDEBUG_COMPONENT("VTEtoIN6GuideStart", mcposaVTEtoIN6GuideStart, mcrotaVTEtoIN6GuideStart)
  mccomp_posa[37] = mcposaVTEtoIN6GuideStart;
  mccomp_posr[37] = mcposrVTEtoIN6GuideStart;
  mcNCounter[37]  = mcPCounter[37] = mcP2Counter[37] = 0;
  mcAbsorbProp[37]= 0;
    /* Component sg1. */
  /* Setting parameters for component sg1. */
  SIG_MESSAGE("sg1 (Init:SetPar)");
#line 454 "ILL_H15_D11.instr"
  mccsg1_w1 = gGuideWidth;
#line 454 "ILL_H15_D11.instr"
  mccsg1_h1 = gGuideHeight1;
#line 454 "ILL_H15_D11.instr"
  mccsg1_w2 = gGuideWidth;
#line 454 "ILL_H15_D11.instr"
  mccsg1_h2 = gGuideHeight1;
#line 455 "ILL_H15_D11.instr"
  mccsg1_l = ( gElmtLength2 - gElementGap );
#line 456 "ILL_H15_D11.instr"
  mccsg1_R0 = mR0;
#line 456 "ILL_H15_D11.instr"
  mccsg1_Qc = mQc;
#line 456 "ILL_H15_D11.instr"
  mccsg1_alpha = mAlpha;
#line 456 "ILL_H15_D11.instr"
  mccsg1_m = mGuide1;
#line 456 "ILL_H15_D11.instr"
  mccsg1_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg1_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg1_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg1_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg1_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg1_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg1_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg1_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg1_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg1_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg1_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg1_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg1_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg1_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg1_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg1_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg1_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg1_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg1_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg1_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg1_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg1_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg1_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg1_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg1_reflect, "NULL" ? "NULL" : "", 16384); else mccsg1_reflect[0]='\0';
#line 23801 "ILL_H15_D11.c"

  SIG_MESSAGE("sg1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23808 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotaVTEtoIN6GuideStart, mcrotasg1);
  rot_transpose(mcrotaVTEtoIN6GuideStart, mctr1);
  rot_mul(mcrotasg1, mctr1, mcrotrsg1);
  mctc1 = coords_set(
#line 457 "ILL_H15_D11.instr"
    0,
#line 457 "ILL_H15_D11.instr"
    0,
#line 457 "ILL_H15_D11.instr"
    0);
#line 23819 "ILL_H15_D11.c"
  rot_transpose(mcrotaVTEtoIN6GuideStart, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg1 = coords_add(mcposaVTEtoIN6GuideStart, mctc2);
  mctc1 = coords_sub(mcposaVTEtoIN6GuideStart, mcposasg1);
  mcposrsg1 = rot_apply(mcrotasg1, mctc1);
  mcDEBUG_COMPONENT("sg1", mcposasg1, mcrotasg1)
  mccomp_posa[38] = mcposasg1;
  mccomp_posr[38] = mcposrsg1;
  mcNCounter[38]  = mcPCounter[38] = mcP2Counter[38] = 0;
  mcAbsorbProp[38]= 0;
    /* Component sg2. */
  /* Setting parameters for component sg2. */
  SIG_MESSAGE("sg2 (Init:SetPar)");
#line 459 "ILL_H15_D11.instr"
  mccsg2_w1 = gGuideWidth;
#line 459 "ILL_H15_D11.instr"
  mccsg2_h1 = gGuideHeight1;
#line 459 "ILL_H15_D11.instr"
  mccsg2_w2 = gGuideWidth;
#line 459 "ILL_H15_D11.instr"
  mccsg2_h2 = gGuideHeight1;
#line 460 "ILL_H15_D11.instr"
  mccsg2_l = ( gElmtLength2 - gElementGap );
#line 461 "ILL_H15_D11.instr"
  mccsg2_R0 = mR0;
#line 461 "ILL_H15_D11.instr"
  mccsg2_Qc = mQc;
#line 461 "ILL_H15_D11.instr"
  mccsg2_alpha = mAlpha;
#line 461 "ILL_H15_D11.instr"
  mccsg2_m = mGuide1;
#line 461 "ILL_H15_D11.instr"
  mccsg2_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg2_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg2_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg2_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg2_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg2_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg2_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg2_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg2_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg2_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg2_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg2_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg2_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg2_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg2_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg2_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg2_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg2_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg2_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg2_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg2_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg2_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg2_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg2_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg2_reflect, "NULL" ? "NULL" : "", 16384); else mccsg2_reflect[0]='\0';
#line 23901 "ILL_H15_D11.c"

  SIG_MESSAGE("sg2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 23908 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg1, mcrotasg2);
  rot_transpose(mcrotasg1, mctr1);
  rot_mul(mcrotasg2, mctr1, mcrotrsg2);
  mctc1 = coords_set(
#line 462 "ILL_H15_D11.instr"
    0,
#line 462 "ILL_H15_D11.instr"
    0,
#line 462 "ILL_H15_D11.instr"
    gElmtLength2);
#line 23919 "ILL_H15_D11.c"
  rot_transpose(mcrotasg1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg2 = coords_add(mcposasg1, mctc2);
  mctc1 = coords_sub(mcposasg1, mcposasg2);
  mcposrsg2 = rot_apply(mcrotasg2, mctc1);
  mcDEBUG_COMPONENT("sg2", mcposasg2, mcrotasg2)
  mccomp_posa[39] = mcposasg2;
  mccomp_posr[39] = mcposrsg2;
  mcNCounter[39]  = mcPCounter[39] = mcP2Counter[39] = 0;
  mcAbsorbProp[39]= 0;
    /* Component sg3. */
  /* Setting parameters for component sg3. */
  SIG_MESSAGE("sg3 (Init:SetPar)");
#line 464 "ILL_H15_D11.instr"
  mccsg3_w1 = gGuideWidth;
#line 464 "ILL_H15_D11.instr"
  mccsg3_h1 = gGuideHeight1;
#line 464 "ILL_H15_D11.instr"
  mccsg3_w2 = gGuideWidth;
#line 464 "ILL_H15_D11.instr"
  mccsg3_h2 = gGuideHeight1;
#line 465 "ILL_H15_D11.instr"
  mccsg3_l = ( gElmtLength2 - gElementGap );
#line 466 "ILL_H15_D11.instr"
  mccsg3_R0 = mR0;
#line 466 "ILL_H15_D11.instr"
  mccsg3_Qc = mQc;
#line 466 "ILL_H15_D11.instr"
  mccsg3_alpha = mAlpha;
#line 466 "ILL_H15_D11.instr"
  mccsg3_m = mGuide1;
#line 466 "ILL_H15_D11.instr"
  mccsg3_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg3_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg3_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg3_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg3_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg3_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg3_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg3_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg3_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg3_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg3_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg3_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg3_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg3_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg3_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg3_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg3_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg3_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg3_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg3_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg3_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg3_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg3_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg3_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg3_reflect, "NULL" ? "NULL" : "", 16384); else mccsg3_reflect[0]='\0';
#line 24001 "ILL_H15_D11.c"

  SIG_MESSAGE("sg3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24008 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg2, mcrotasg3);
  rot_transpose(mcrotasg2, mctr1);
  rot_mul(mcrotasg3, mctr1, mcrotrsg3);
  mctc1 = coords_set(
#line 467 "ILL_H15_D11.instr"
    0,
#line 467 "ILL_H15_D11.instr"
    0,
#line 467 "ILL_H15_D11.instr"
    gElmtLength2);
#line 24019 "ILL_H15_D11.c"
  rot_transpose(mcrotasg2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg3 = coords_add(mcposasg2, mctc2);
  mctc1 = coords_sub(mcposasg2, mcposasg3);
  mcposrsg3 = rot_apply(mcrotasg3, mctc1);
  mcDEBUG_COMPONENT("sg3", mcposasg3, mcrotasg3)
  mccomp_posa[40] = mcposasg3;
  mccomp_posr[40] = mcposrsg3;
  mcNCounter[40]  = mcPCounter[40] = mcP2Counter[40] = 0;
  mcAbsorbProp[40]= 0;
    /* Component sg4. */
  /* Setting parameters for component sg4. */
  SIG_MESSAGE("sg4 (Init:SetPar)");
#line 469 "ILL_H15_D11.instr"
  mccsg4_w1 = gGuideWidth;
#line 469 "ILL_H15_D11.instr"
  mccsg4_h1 = gGuideHeight1;
#line 469 "ILL_H15_D11.instr"
  mccsg4_w2 = gGuideWidth;
#line 469 "ILL_H15_D11.instr"
  mccsg4_h2 = gGuideHeight1;
#line 470 "ILL_H15_D11.instr"
  mccsg4_l = ( gElmtLength2 - gElementGap );
#line 471 "ILL_H15_D11.instr"
  mccsg4_R0 = mR0;
#line 471 "ILL_H15_D11.instr"
  mccsg4_Qc = mQc;
#line 471 "ILL_H15_D11.instr"
  mccsg4_alpha = mAlpha;
#line 471 "ILL_H15_D11.instr"
  mccsg4_m = mGuide1;
#line 471 "ILL_H15_D11.instr"
  mccsg4_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg4_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg4_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg4_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg4_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg4_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg4_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg4_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg4_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg4_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg4_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg4_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg4_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg4_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg4_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg4_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg4_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg4_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg4_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg4_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg4_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg4_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg4_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg4_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg4_reflect, "NULL" ? "NULL" : "", 16384); else mccsg4_reflect[0]='\0';
#line 24101 "ILL_H15_D11.c"

  SIG_MESSAGE("sg4 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24108 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg3, mcrotasg4);
  rot_transpose(mcrotasg3, mctr1);
  rot_mul(mcrotasg4, mctr1, mcrotrsg4);
  mctc1 = coords_set(
#line 472 "ILL_H15_D11.instr"
    0,
#line 472 "ILL_H15_D11.instr"
    0,
#line 472 "ILL_H15_D11.instr"
    gElmtLength2);
#line 24119 "ILL_H15_D11.c"
  rot_transpose(mcrotasg3, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg4 = coords_add(mcposasg3, mctc2);
  mctc1 = coords_sub(mcposasg3, mcposasg4);
  mcposrsg4 = rot_apply(mcrotasg4, mctc1);
  mcDEBUG_COMPONENT("sg4", mcposasg4, mcrotasg4)
  mccomp_posa[41] = mcposasg4;
  mccomp_posr[41] = mcposrsg4;
  mcNCounter[41]  = mcPCounter[41] = mcP2Counter[41] = 0;
  mcAbsorbProp[41]= 0;
    /* Component sg5. */
  /* Setting parameters for component sg5. */
  SIG_MESSAGE("sg5 (Init:SetPar)");
#line 474 "ILL_H15_D11.instr"
  mccsg5_w1 = gGuideWidth;
#line 474 "ILL_H15_D11.instr"
  mccsg5_h1 = gGuideHeight1;
#line 474 "ILL_H15_D11.instr"
  mccsg5_w2 = gGuideWidth;
#line 474 "ILL_H15_D11.instr"
  mccsg5_h2 = gGuideHeight1;
#line 475 "ILL_H15_D11.instr"
  mccsg5_l = ( gElmtLength2 - gElementGap );
#line 476 "ILL_H15_D11.instr"
  mccsg5_R0 = mR0;
#line 476 "ILL_H15_D11.instr"
  mccsg5_Qc = mQc;
#line 476 "ILL_H15_D11.instr"
  mccsg5_alpha = mAlpha;
#line 476 "ILL_H15_D11.instr"
  mccsg5_m = mGuide1;
#line 476 "ILL_H15_D11.instr"
  mccsg5_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg5_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg5_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg5_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg5_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg5_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg5_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg5_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg5_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg5_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg5_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg5_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg5_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg5_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg5_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg5_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg5_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg5_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg5_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg5_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg5_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg5_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg5_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg5_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg5_reflect, "NULL" ? "NULL" : "", 16384); else mccsg5_reflect[0]='\0';
#line 24201 "ILL_H15_D11.c"

  SIG_MESSAGE("sg5 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24208 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg4, mcrotasg5);
  rot_transpose(mcrotasg4, mctr1);
  rot_mul(mcrotasg5, mctr1, mcrotrsg5);
  mctc1 = coords_set(
#line 477 "ILL_H15_D11.instr"
    0,
#line 477 "ILL_H15_D11.instr"
    0,
#line 477 "ILL_H15_D11.instr"
    gElmtLength2);
#line 24219 "ILL_H15_D11.c"
  rot_transpose(mcrotasg4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg5 = coords_add(mcposasg4, mctc2);
  mctc1 = coords_sub(mcposasg4, mcposasg5);
  mcposrsg5 = rot_apply(mcrotasg5, mctc1);
  mcDEBUG_COMPONENT("sg5", mcposasg5, mcrotasg5)
  mccomp_posa[42] = mcposasg5;
  mccomp_posr[42] = mcposrsg5;
  mcNCounter[42]  = mcPCounter[42] = mcP2Counter[42] = 0;
  mcAbsorbProp[42]= 0;
    /* Component sg6. */
  /* Setting parameters for component sg6. */
  SIG_MESSAGE("sg6 (Init:SetPar)");
#line 479 "ILL_H15_D11.instr"
  mccsg6_w1 = gGuideWidth;
#line 479 "ILL_H15_D11.instr"
  mccsg6_h1 = gGuideHeight1;
#line 479 "ILL_H15_D11.instr"
  mccsg6_w2 = gGuideWidth;
#line 479 "ILL_H15_D11.instr"
  mccsg6_h2 = gGuideHeight1;
#line 480 "ILL_H15_D11.instr"
  mccsg6_l = ( gElmtLength2 - gElementGap );
#line 481 "ILL_H15_D11.instr"
  mccsg6_R0 = mR0;
#line 481 "ILL_H15_D11.instr"
  mccsg6_Qc = mQc;
#line 481 "ILL_H15_D11.instr"
  mccsg6_alpha = mAlpha;
#line 481 "ILL_H15_D11.instr"
  mccsg6_m = mGuide1;
#line 481 "ILL_H15_D11.instr"
  mccsg6_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg6_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg6_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg6_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg6_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg6_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg6_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg6_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg6_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg6_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg6_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg6_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg6_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg6_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg6_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg6_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg6_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg6_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg6_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg6_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg6_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg6_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg6_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg6_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg6_reflect, "NULL" ? "NULL" : "", 16384); else mccsg6_reflect[0]='\0';
#line 24301 "ILL_H15_D11.c"

  SIG_MESSAGE("sg6 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24308 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg5, mcrotasg6);
  rot_transpose(mcrotasg5, mctr1);
  rot_mul(mcrotasg6, mctr1, mcrotrsg6);
  mctc1 = coords_set(
#line 482 "ILL_H15_D11.instr"
    0,
#line 482 "ILL_H15_D11.instr"
    0,
#line 482 "ILL_H15_D11.instr"
    gElmtLength2);
#line 24319 "ILL_H15_D11.c"
  rot_transpose(mcrotasg5, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg6 = coords_add(mcposasg5, mctc2);
  mctc1 = coords_sub(mcposasg5, mcposasg6);
  mcposrsg6 = rot_apply(mcrotasg6, mctc1);
  mcDEBUG_COMPONENT("sg6", mcposasg6, mcrotasg6)
  mccomp_posa[43] = mcposasg6;
  mccomp_posr[43] = mcposrsg6;
  mcNCounter[43]  = mcPCounter[43] = mcP2Counter[43] = 0;
  mcAbsorbProp[43]= 0;
    /* Component sg7. */
  /* Setting parameters for component sg7. */
  SIG_MESSAGE("sg7 (Init:SetPar)");
#line 484 "ILL_H15_D11.instr"
  mccsg7_w1 = gGuideWidth;
#line 484 "ILL_H15_D11.instr"
  mccsg7_h1 = gGuideHeight1;
#line 484 "ILL_H15_D11.instr"
  mccsg7_w2 = gGuideWidth;
#line 484 "ILL_H15_D11.instr"
  mccsg7_h2 = gGuideHeight1;
#line 485 "ILL_H15_D11.instr"
  mccsg7_l = ( gElmtLength2 - gElementGap );
#line 486 "ILL_H15_D11.instr"
  mccsg7_R0 = mR0;
#line 486 "ILL_H15_D11.instr"
  mccsg7_Qc = mQc;
#line 486 "ILL_H15_D11.instr"
  mccsg7_alpha = mAlpha;
#line 486 "ILL_H15_D11.instr"
  mccsg7_m = mGuide1;
#line 486 "ILL_H15_D11.instr"
  mccsg7_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg7_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg7_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg7_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg7_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg7_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg7_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg7_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg7_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg7_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg7_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg7_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg7_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg7_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg7_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg7_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg7_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg7_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg7_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg7_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg7_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg7_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg7_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg7_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg7_reflect, "NULL" ? "NULL" : "", 16384); else mccsg7_reflect[0]='\0';
#line 24401 "ILL_H15_D11.c"

  SIG_MESSAGE("sg7 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24408 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg6, mcrotasg7);
  rot_transpose(mcrotasg6, mctr1);
  rot_mul(mcrotasg7, mctr1, mcrotrsg7);
  mctc1 = coords_set(
#line 487 "ILL_H15_D11.instr"
    0,
#line 487 "ILL_H15_D11.instr"
    0,
#line 487 "ILL_H15_D11.instr"
    gElmtLength2);
#line 24419 "ILL_H15_D11.c"
  rot_transpose(mcrotasg6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg7 = coords_add(mcposasg6, mctc2);
  mctc1 = coords_sub(mcposasg6, mcposasg7);
  mcposrsg7 = rot_apply(mcrotasg7, mctc1);
  mcDEBUG_COMPONENT("sg7", mcposasg7, mcrotasg7)
  mccomp_posa[44] = mcposasg7;
  mccomp_posr[44] = mcposrsg7;
  mcNCounter[44]  = mcPCounter[44] = mcP2Counter[44] = 0;
  mcAbsorbProp[44]= 0;
    /* Component sg8. */
  /* Setting parameters for component sg8. */
  SIG_MESSAGE("sg8 (Init:SetPar)");
#line 489 "ILL_H15_D11.instr"
  mccsg8_w1 = gGuideWidth;
#line 489 "ILL_H15_D11.instr"
  mccsg8_h1 = gGuideHeight1;
#line 489 "ILL_H15_D11.instr"
  mccsg8_w2 = gGuideWidth;
#line 489 "ILL_H15_D11.instr"
  mccsg8_h2 = gGuideHeight1;
#line 490 "ILL_H15_D11.instr"
  mccsg8_l = ( gElmtLength2 - gElementGap );
#line 491 "ILL_H15_D11.instr"
  mccsg8_R0 = mR0;
#line 491 "ILL_H15_D11.instr"
  mccsg8_Qc = mQc;
#line 491 "ILL_H15_D11.instr"
  mccsg8_alpha = mAlpha;
#line 491 "ILL_H15_D11.instr"
  mccsg8_m = mGuide1;
#line 491 "ILL_H15_D11.instr"
  mccsg8_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg8_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg8_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg8_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg8_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg8_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg8_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg8_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg8_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg8_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg8_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg8_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg8_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg8_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg8_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg8_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg8_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg8_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg8_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg8_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg8_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg8_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg8_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg8_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg8_reflect, "NULL" ? "NULL" : "", 16384); else mccsg8_reflect[0]='\0';
#line 24501 "ILL_H15_D11.c"

  SIG_MESSAGE("sg8 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24508 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg7, mcrotasg8);
  rot_transpose(mcrotasg7, mctr1);
  rot_mul(mcrotasg8, mctr1, mcrotrsg8);
  mctc1 = coords_set(
#line 492 "ILL_H15_D11.instr"
    0,
#line 492 "ILL_H15_D11.instr"
    0,
#line 492 "ILL_H15_D11.instr"
    gElmtLength2);
#line 24519 "ILL_H15_D11.c"
  rot_transpose(mcrotasg7, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg8 = coords_add(mcposasg7, mctc2);
  mctc1 = coords_sub(mcposasg7, mcposasg8);
  mcposrsg8 = rot_apply(mcrotasg8, mctc1);
  mcDEBUG_COMPONENT("sg8", mcposasg8, mcrotasg8)
  mccomp_posa[45] = mcposasg8;
  mccomp_posr[45] = mcposrsg8;
  mcNCounter[45]  = mcPCounter[45] = mcP2Counter[45] = 0;
  mcAbsorbProp[45]= 0;
    /* Component sg9. */
  /* Setting parameters for component sg9. */
  SIG_MESSAGE("sg9 (Init:SetPar)");
#line 494 "ILL_H15_D11.instr"
  mccsg9_w1 = gGuideWidth;
#line 494 "ILL_H15_D11.instr"
  mccsg9_h1 = gGuideHeight1;
#line 494 "ILL_H15_D11.instr"
  mccsg9_w2 = gGuideWidth;
#line 494 "ILL_H15_D11.instr"
  mccsg9_h2 = gGuideHeight1;
#line 495 "ILL_H15_D11.instr"
  mccsg9_l = ( gElmtLength2 - gElementGap );
#line 496 "ILL_H15_D11.instr"
  mccsg9_R0 = mR0;
#line 496 "ILL_H15_D11.instr"
  mccsg9_Qc = mQc;
#line 496 "ILL_H15_D11.instr"
  mccsg9_alpha = mAlpha;
#line 496 "ILL_H15_D11.instr"
  mccsg9_m = mGuide1;
#line 496 "ILL_H15_D11.instr"
  mccsg9_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg9_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg9_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg9_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg9_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg9_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg9_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg9_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg9_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg9_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg9_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg9_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg9_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg9_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg9_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg9_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg9_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg9_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg9_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg9_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg9_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg9_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg9_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg9_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg9_reflect, "NULL" ? "NULL" : "", 16384); else mccsg9_reflect[0]='\0';
#line 24601 "ILL_H15_D11.c"

  SIG_MESSAGE("sg9 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24608 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg8, mcrotasg9);
  rot_transpose(mcrotasg8, mctr1);
  rot_mul(mcrotasg9, mctr1, mcrotrsg9);
  mctc1 = coords_set(
#line 497 "ILL_H15_D11.instr"
    0,
#line 497 "ILL_H15_D11.instr"
    0,
#line 497 "ILL_H15_D11.instr"
    gElmtLength2);
#line 24619 "ILL_H15_D11.c"
  rot_transpose(mcrotasg8, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg9 = coords_add(mcposasg8, mctc2);
  mctc1 = coords_sub(mcposasg8, mcposasg9);
  mcposrsg9 = rot_apply(mcrotasg9, mctc1);
  mcDEBUG_COMPONENT("sg9", mcposasg9, mcrotasg9)
  mccomp_posa[46] = mcposasg9;
  mccomp_posr[46] = mcposrsg9;
  mcNCounter[46]  = mcPCounter[46] = mcP2Counter[46] = 0;
  mcAbsorbProp[46]= 0;
    /* Component sg10. */
  /* Setting parameters for component sg10. */
  SIG_MESSAGE("sg10 (Init:SetPar)");
#line 499 "ILL_H15_D11.instr"
  mccsg10_w1 = gGuideWidth;
#line 499 "ILL_H15_D11.instr"
  mccsg10_h1 = gGuideHeight1;
#line 499 "ILL_H15_D11.instr"
  mccsg10_w2 = gGuideWidth;
#line 499 "ILL_H15_D11.instr"
  mccsg10_h2 = gGuideHeight1;
#line 500 "ILL_H15_D11.instr"
  mccsg10_l = ( gElmtLength2 - gElementGap );
#line 501 "ILL_H15_D11.instr"
  mccsg10_R0 = mR0;
#line 501 "ILL_H15_D11.instr"
  mccsg10_Qc = mQc;
#line 501 "ILL_H15_D11.instr"
  mccsg10_alpha = mAlpha;
#line 501 "ILL_H15_D11.instr"
  mccsg10_m = mGuide1;
#line 501 "ILL_H15_D11.instr"
  mccsg10_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg10_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg10_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg10_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg10_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg10_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg10_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg10_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg10_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg10_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg10_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg10_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg10_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg10_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg10_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg10_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg10_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg10_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg10_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg10_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg10_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg10_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg10_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg10_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg10_reflect, "NULL" ? "NULL" : "", 16384); else mccsg10_reflect[0]='\0';
#line 24701 "ILL_H15_D11.c"

  SIG_MESSAGE("sg10 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24708 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg9, mcrotasg10);
  rot_transpose(mcrotasg9, mctr1);
  rot_mul(mcrotasg10, mctr1, mcrotrsg10);
  mctc1 = coords_set(
#line 502 "ILL_H15_D11.instr"
    0,
#line 502 "ILL_H15_D11.instr"
    0,
#line 502 "ILL_H15_D11.instr"
    gElmtLength2);
#line 24719 "ILL_H15_D11.c"
  rot_transpose(mcrotasg9, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg10 = coords_add(mcposasg9, mctc2);
  mctc1 = coords_sub(mcposasg9, mcposasg10);
  mcposrsg10 = rot_apply(mcrotasg10, mctc1);
  mcDEBUG_COMPONENT("sg10", mcposasg10, mcrotasg10)
  mccomp_posa[47] = mcposasg10;
  mccomp_posr[47] = mcposrsg10;
  mcNCounter[47]  = mcPCounter[47] = mcP2Counter[47] = 0;
  mcAbsorbProp[47]= 0;
    /* Component sg11. */
  /* Setting parameters for component sg11. */
  SIG_MESSAGE("sg11 (Init:SetPar)");
#line 504 "ILL_H15_D11.instr"
  mccsg11_w1 = gGuideWidth;
#line 504 "ILL_H15_D11.instr"
  mccsg11_h1 = gGuideHeight1;
#line 504 "ILL_H15_D11.instr"
  mccsg11_w2 = gGuideWidth;
#line 504 "ILL_H15_D11.instr"
  mccsg11_h2 = gGuideHeight1;
#line 505 "ILL_H15_D11.instr"
  mccsg11_l = ( gElmtLength2 - gElementGap );
#line 506 "ILL_H15_D11.instr"
  mccsg11_R0 = mR0;
#line 506 "ILL_H15_D11.instr"
  mccsg11_Qc = mQc;
#line 506 "ILL_H15_D11.instr"
  mccsg11_alpha = mAlpha;
#line 506 "ILL_H15_D11.instr"
  mccsg11_m = mGuide1;
#line 506 "ILL_H15_D11.instr"
  mccsg11_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg11_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg11_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg11_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg11_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg11_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg11_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg11_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg11_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg11_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg11_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg11_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg11_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg11_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg11_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg11_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg11_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg11_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg11_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg11_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg11_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg11_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg11_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg11_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg11_reflect, "NULL" ? "NULL" : "", 16384); else mccsg11_reflect[0]='\0';
#line 24801 "ILL_H15_D11.c"

  SIG_MESSAGE("sg11 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24808 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg10, mcrotasg11);
  rot_transpose(mcrotasg10, mctr1);
  rot_mul(mcrotasg11, mctr1, mcrotrsg11);
  mctc1 = coords_set(
#line 507 "ILL_H15_D11.instr"
    0,
#line 507 "ILL_H15_D11.instr"
    0,
#line 507 "ILL_H15_D11.instr"
    gElmtLength2);
#line 24819 "ILL_H15_D11.c"
  rot_transpose(mcrotasg10, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg11 = coords_add(mcposasg10, mctc2);
  mctc1 = coords_sub(mcposasg10, mcposasg11);
  mcposrsg11 = rot_apply(mcrotasg11, mctc1);
  mcDEBUG_COMPONENT("sg11", mcposasg11, mcrotasg11)
  mccomp_posa[48] = mcposasg11;
  mccomp_posr[48] = mcposrsg11;
  mcNCounter[48]  = mcPCounter[48] = mcP2Counter[48] = 0;
  mcAbsorbProp[48]= 0;
    /* Component sg12. */
  /* Setting parameters for component sg12. */
  SIG_MESSAGE("sg12 (Init:SetPar)");
#line 509 "ILL_H15_D11.instr"
  mccsg12_w1 = gGuideWidth;
#line 509 "ILL_H15_D11.instr"
  mccsg12_h1 = gGuideHeight1;
#line 509 "ILL_H15_D11.instr"
  mccsg12_w2 = gGuideWidth;
#line 509 "ILL_H15_D11.instr"
  mccsg12_h2 = gGuideHeight1;
#line 510 "ILL_H15_D11.instr"
  mccsg12_l = ( gElmtLength2 - gElementGap );
#line 511 "ILL_H15_D11.instr"
  mccsg12_R0 = mR0;
#line 511 "ILL_H15_D11.instr"
  mccsg12_Qc = mQc;
#line 511 "ILL_H15_D11.instr"
  mccsg12_alpha = mAlpha;
#line 511 "ILL_H15_D11.instr"
  mccsg12_m = mGuide1;
#line 511 "ILL_H15_D11.instr"
  mccsg12_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg12_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg12_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg12_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg12_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg12_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg12_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg12_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg12_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg12_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg12_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg12_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg12_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg12_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg12_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg12_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg12_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg12_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg12_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg12_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg12_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg12_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg12_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg12_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg12_reflect, "NULL" ? "NULL" : "", 16384); else mccsg12_reflect[0]='\0';
#line 24901 "ILL_H15_D11.c"

  SIG_MESSAGE("sg12 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 24908 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg11, mcrotasg12);
  rot_transpose(mcrotasg11, mctr1);
  rot_mul(mcrotasg12, mctr1, mcrotrsg12);
  mctc1 = coords_set(
#line 512 "ILL_H15_D11.instr"
    0,
#line 512 "ILL_H15_D11.instr"
    0,
#line 512 "ILL_H15_D11.instr"
    gElmtLength2);
#line 24919 "ILL_H15_D11.c"
  rot_transpose(mcrotasg11, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg12 = coords_add(mcposasg11, mctc2);
  mctc1 = coords_sub(mcposasg11, mcposasg12);
  mcposrsg12 = rot_apply(mcrotasg12, mctc1);
  mcDEBUG_COMPONENT("sg12", mcposasg12, mcrotasg12)
  mccomp_posa[49] = mcposasg12;
  mccomp_posr[49] = mcposrsg12;
  mcNCounter[49]  = mcPCounter[49] = mcP2Counter[49] = 0;
  mcAbsorbProp[49]= 0;
    /* Component sg13. */
  /* Setting parameters for component sg13. */
  SIG_MESSAGE("sg13 (Init:SetPar)");
#line 514 "ILL_H15_D11.instr"
  mccsg13_w1 = gGuideWidth;
#line 514 "ILL_H15_D11.instr"
  mccsg13_h1 = gGuideHeight1;
#line 514 "ILL_H15_D11.instr"
  mccsg13_w2 = gGuideWidth;
#line 514 "ILL_H15_D11.instr"
  mccsg13_h2 = gGuideHeight1;
#line 515 "ILL_H15_D11.instr"
  mccsg13_l = ( gElmtLength2 - gElementGap );
#line 516 "ILL_H15_D11.instr"
  mccsg13_R0 = mR0;
#line 516 "ILL_H15_D11.instr"
  mccsg13_Qc = mQc;
#line 516 "ILL_H15_D11.instr"
  mccsg13_alpha = mAlpha;
#line 516 "ILL_H15_D11.instr"
  mccsg13_m = mGuide1;
#line 516 "ILL_H15_D11.instr"
  mccsg13_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg13_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg13_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg13_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg13_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg13_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg13_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg13_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg13_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg13_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg13_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg13_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg13_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg13_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg13_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg13_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg13_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg13_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg13_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg13_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg13_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg13_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg13_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg13_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg13_reflect, "NULL" ? "NULL" : "", 16384); else mccsg13_reflect[0]='\0';
#line 25001 "ILL_H15_D11.c"

  SIG_MESSAGE("sg13 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25008 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg12, mcrotasg13);
  rot_transpose(mcrotasg12, mctr1);
  rot_mul(mcrotasg13, mctr1, mcrotrsg13);
  mctc1 = coords_set(
#line 517 "ILL_H15_D11.instr"
    0,
#line 517 "ILL_H15_D11.instr"
    0,
#line 517 "ILL_H15_D11.instr"
    gElmtLength2);
#line 25019 "ILL_H15_D11.c"
  rot_transpose(mcrotasg12, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg13 = coords_add(mcposasg12, mctc2);
  mctc1 = coords_sub(mcposasg12, mcposasg13);
  mcposrsg13 = rot_apply(mcrotasg13, mctc1);
  mcDEBUG_COMPONENT("sg13", mcposasg13, mcrotasg13)
  mccomp_posa[50] = mcposasg13;
  mccomp_posr[50] = mcposrsg13;
  mcNCounter[50]  = mcPCounter[50] = mcP2Counter[50] = 0;
  mcAbsorbProp[50]= 0;
    /* Component sg14. */
  /* Setting parameters for component sg14. */
  SIG_MESSAGE("sg14 (Init:SetPar)");
#line 519 "ILL_H15_D11.instr"
  mccsg14_w1 = gGuideWidth;
#line 519 "ILL_H15_D11.instr"
  mccsg14_h1 = gGuideHeight1;
#line 519 "ILL_H15_D11.instr"
  mccsg14_w2 = gGuideWidth;
#line 519 "ILL_H15_D11.instr"
  mccsg14_h2 = gGuideHeight1;
#line 520 "ILL_H15_D11.instr"
  mccsg14_l = ( gElmtLength2 - gElementGap );
#line 521 "ILL_H15_D11.instr"
  mccsg14_R0 = mR0;
#line 521 "ILL_H15_D11.instr"
  mccsg14_Qc = mQc;
#line 521 "ILL_H15_D11.instr"
  mccsg14_alpha = mAlpha;
#line 521 "ILL_H15_D11.instr"
  mccsg14_m = mGuide1;
#line 521 "ILL_H15_D11.instr"
  mccsg14_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg14_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg14_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg14_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg14_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg14_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg14_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg14_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg14_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg14_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg14_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg14_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg14_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg14_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg14_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg14_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg14_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg14_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg14_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg14_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg14_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg14_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg14_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg14_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg14_reflect, "NULL" ? "NULL" : "", 16384); else mccsg14_reflect[0]='\0';
#line 25101 "ILL_H15_D11.c"

  SIG_MESSAGE("sg14 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25108 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg13, mcrotasg14);
  rot_transpose(mcrotasg13, mctr1);
  rot_mul(mcrotasg14, mctr1, mcrotrsg14);
  mctc1 = coords_set(
#line 522 "ILL_H15_D11.instr"
    0,
#line 522 "ILL_H15_D11.instr"
    0,
#line 522 "ILL_H15_D11.instr"
    gElmtLength2);
#line 25119 "ILL_H15_D11.c"
  rot_transpose(mcrotasg13, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg14 = coords_add(mcposasg13, mctc2);
  mctc1 = coords_sub(mcposasg13, mcposasg14);
  mcposrsg14 = rot_apply(mcrotasg14, mctc1);
  mcDEBUG_COMPONENT("sg14", mcposasg14, mcrotasg14)
  mccomp_posa[51] = mcposasg14;
  mccomp_posr[51] = mcposrsg14;
  mcNCounter[51]  = mcPCounter[51] = mcP2Counter[51] = 0;
  mcAbsorbProp[51]= 0;
    /* Component sg15. */
  /* Setting parameters for component sg15. */
  SIG_MESSAGE("sg15 (Init:SetPar)");
#line 524 "ILL_H15_D11.instr"
  mccsg15_w1 = gGuideWidth;
#line 524 "ILL_H15_D11.instr"
  mccsg15_h1 = gGuideHeight1;
#line 524 "ILL_H15_D11.instr"
  mccsg15_w2 = gGuideWidth;
#line 524 "ILL_H15_D11.instr"
  mccsg15_h2 = gGuideHeight1;
#line 525 "ILL_H15_D11.instr"
  mccsg15_l = ( gElmtLength2 - gElementGap );
#line 526 "ILL_H15_D11.instr"
  mccsg15_R0 = mR0;
#line 526 "ILL_H15_D11.instr"
  mccsg15_Qc = mQc;
#line 526 "ILL_H15_D11.instr"
  mccsg15_alpha = mAlpha;
#line 526 "ILL_H15_D11.instr"
  mccsg15_m = mGuide1;
#line 526 "ILL_H15_D11.instr"
  mccsg15_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg15_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg15_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg15_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg15_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg15_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg15_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg15_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg15_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg15_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg15_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg15_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg15_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg15_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg15_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg15_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg15_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg15_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg15_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg15_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg15_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg15_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg15_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg15_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg15_reflect, "NULL" ? "NULL" : "", 16384); else mccsg15_reflect[0]='\0';
#line 25201 "ILL_H15_D11.c"

  SIG_MESSAGE("sg15 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25208 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg14, mcrotasg15);
  rot_transpose(mcrotasg14, mctr1);
  rot_mul(mcrotasg15, mctr1, mcrotrsg15);
  mctc1 = coords_set(
#line 527 "ILL_H15_D11.instr"
    0,
#line 527 "ILL_H15_D11.instr"
    0,
#line 527 "ILL_H15_D11.instr"
    gElmtLength2);
#line 25219 "ILL_H15_D11.c"
  rot_transpose(mcrotasg14, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg15 = coords_add(mcposasg14, mctc2);
  mctc1 = coords_sub(mcposasg14, mcposasg15);
  mcposrsg15 = rot_apply(mcrotasg15, mctc1);
  mcDEBUG_COMPONENT("sg15", mcposasg15, mcrotasg15)
  mccomp_posa[52] = mcposasg15;
  mccomp_posr[52] = mcposrsg15;
  mcNCounter[52]  = mcPCounter[52] = mcP2Counter[52] = 0;
  mcAbsorbProp[52]= 0;
    /* Component sg16. */
  /* Setting parameters for component sg16. */
  SIG_MESSAGE("sg16 (Init:SetPar)");
#line 529 "ILL_H15_D11.instr"
  mccsg16_w1 = gGuideWidth;
#line 529 "ILL_H15_D11.instr"
  mccsg16_h1 = gGuideHeight1;
#line 529 "ILL_H15_D11.instr"
  mccsg16_w2 = gGuideWidth;
#line 529 "ILL_H15_D11.instr"
  mccsg16_h2 = gGuideHeight1;
#line 530 "ILL_H15_D11.instr"
  mccsg16_l = ( gElmtLength2 - gElementGap );
#line 531 "ILL_H15_D11.instr"
  mccsg16_R0 = mR0;
#line 531 "ILL_H15_D11.instr"
  mccsg16_Qc = mQc;
#line 531 "ILL_H15_D11.instr"
  mccsg16_alpha = mAlpha;
#line 531 "ILL_H15_D11.instr"
  mccsg16_m = mGuide1;
#line 531 "ILL_H15_D11.instr"
  mccsg16_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg16_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg16_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg16_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg16_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg16_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg16_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg16_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg16_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg16_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg16_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg16_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg16_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg16_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg16_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg16_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg16_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg16_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg16_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg16_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg16_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg16_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg16_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg16_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg16_reflect, "NULL" ? "NULL" : "", 16384); else mccsg16_reflect[0]='\0';
#line 25301 "ILL_H15_D11.c"

  SIG_MESSAGE("sg16 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25308 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg15, mcrotasg16);
  rot_transpose(mcrotasg15, mctr1);
  rot_mul(mcrotasg16, mctr1, mcrotrsg16);
  mctc1 = coords_set(
#line 532 "ILL_H15_D11.instr"
    0,
#line 532 "ILL_H15_D11.instr"
    0,
#line 532 "ILL_H15_D11.instr"
    gElmtLength2);
#line 25319 "ILL_H15_D11.c"
  rot_transpose(mcrotasg15, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg16 = coords_add(mcposasg15, mctc2);
  mctc1 = coords_sub(mcposasg15, mcposasg16);
  mcposrsg16 = rot_apply(mcrotasg16, mctc1);
  mcDEBUG_COMPONENT("sg16", mcposasg16, mcrotasg16)
  mccomp_posa[53] = mcposasg16;
  mccomp_posr[53] = mcposrsg16;
  mcNCounter[53]  = mcPCounter[53] = mcP2Counter[53] = 0;
  mcAbsorbProp[53]= 0;
    /* Component sg17. */
  /* Setting parameters for component sg17. */
  SIG_MESSAGE("sg17 (Init:SetPar)");
#line 534 "ILL_H15_D11.instr"
  mccsg17_w1 = gGuideWidth;
#line 534 "ILL_H15_D11.instr"
  mccsg17_h1 = gGuideHeight1;
#line 534 "ILL_H15_D11.instr"
  mccsg17_w2 = gGuideWidth;
#line 534 "ILL_H15_D11.instr"
  mccsg17_h2 = gGuideHeight1;
#line 535 "ILL_H15_D11.instr"
  mccsg17_l = ( gElmtLength2 - gElementGap );
#line 536 "ILL_H15_D11.instr"
  mccsg17_R0 = mR0;
#line 536 "ILL_H15_D11.instr"
  mccsg17_Qc = mQc;
#line 536 "ILL_H15_D11.instr"
  mccsg17_alpha = mAlpha;
#line 536 "ILL_H15_D11.instr"
  mccsg17_m = mGuide1;
#line 536 "ILL_H15_D11.instr"
  mccsg17_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg17_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg17_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg17_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg17_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg17_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg17_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg17_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg17_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg17_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg17_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg17_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg17_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg17_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg17_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg17_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg17_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg17_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg17_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg17_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg17_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg17_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg17_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg17_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg17_reflect, "NULL" ? "NULL" : "", 16384); else mccsg17_reflect[0]='\0';
#line 25401 "ILL_H15_D11.c"

  SIG_MESSAGE("sg17 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25408 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg16, mcrotasg17);
  rot_transpose(mcrotasg16, mctr1);
  rot_mul(mcrotasg17, mctr1, mcrotrsg17);
  mctc1 = coords_set(
#line 537 "ILL_H15_D11.instr"
    0,
#line 537 "ILL_H15_D11.instr"
    0,
#line 537 "ILL_H15_D11.instr"
    gElmtLength2);
#line 25419 "ILL_H15_D11.c"
  rot_transpose(mcrotasg16, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg17 = coords_add(mcposasg16, mctc2);
  mctc1 = coords_sub(mcposasg16, mcposasg17);
  mcposrsg17 = rot_apply(mcrotasg17, mctc1);
  mcDEBUG_COMPONENT("sg17", mcposasg17, mcrotasg17)
  mccomp_posa[54] = mcposasg17;
  mccomp_posr[54] = mcposrsg17;
  mcNCounter[54]  = mcPCounter[54] = mcP2Counter[54] = 0;
  mcAbsorbProp[54]= 0;
    /* Component sg18. */
  /* Setting parameters for component sg18. */
  SIG_MESSAGE("sg18 (Init:SetPar)");
#line 539 "ILL_H15_D11.instr"
  mccsg18_w1 = gGuideWidth;
#line 539 "ILL_H15_D11.instr"
  mccsg18_h1 = gGuideHeight1;
#line 539 "ILL_H15_D11.instr"
  mccsg18_w2 = gGuideWidth;
#line 539 "ILL_H15_D11.instr"
  mccsg18_h2 = gGuideHeight1;
#line 540 "ILL_H15_D11.instr"
  mccsg18_l = ( gElmtLength2 - gElementGap );
#line 541 "ILL_H15_D11.instr"
  mccsg18_R0 = mR0;
#line 541 "ILL_H15_D11.instr"
  mccsg18_Qc = mQc;
#line 541 "ILL_H15_D11.instr"
  mccsg18_alpha = mAlpha;
#line 541 "ILL_H15_D11.instr"
  mccsg18_m = mGuide1;
#line 541 "ILL_H15_D11.instr"
  mccsg18_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg18_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg18_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg18_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg18_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg18_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg18_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg18_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg18_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg18_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg18_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg18_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg18_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg18_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg18_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg18_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg18_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg18_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg18_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg18_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg18_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg18_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg18_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg18_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg18_reflect, "NULL" ? "NULL" : "", 16384); else mccsg18_reflect[0]='\0';
#line 25501 "ILL_H15_D11.c"

  SIG_MESSAGE("sg18 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25508 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg17, mcrotasg18);
  rot_transpose(mcrotasg17, mctr1);
  rot_mul(mcrotasg18, mctr1, mcrotrsg18);
  mctc1 = coords_set(
#line 542 "ILL_H15_D11.instr"
    0,
#line 542 "ILL_H15_D11.instr"
    0,
#line 542 "ILL_H15_D11.instr"
    gElmtLength2);
#line 25519 "ILL_H15_D11.c"
  rot_transpose(mcrotasg17, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg18 = coords_add(mcposasg17, mctc2);
  mctc1 = coords_sub(mcposasg17, mcposasg18);
  mcposrsg18 = rot_apply(mcrotasg18, mctc1);
  mcDEBUG_COMPONENT("sg18", mcposasg18, mcrotasg18)
  mccomp_posa[55] = mcposasg18;
  mccomp_posr[55] = mcposrsg18;
  mcNCounter[55]  = mcPCounter[55] = mcP2Counter[55] = 0;
  mcAbsorbProp[55]= 0;
    /* Component sg19. */
  /* Setting parameters for component sg19. */
  SIG_MESSAGE("sg19 (Init:SetPar)");
#line 544 "ILL_H15_D11.instr"
  mccsg19_w1 = gGuideWidth;
#line 544 "ILL_H15_D11.instr"
  mccsg19_h1 = gGuideHeight1;
#line 544 "ILL_H15_D11.instr"
  mccsg19_w2 = gGuideWidth;
#line 544 "ILL_H15_D11.instr"
  mccsg19_h2 = gGuideHeight1;
#line 545 "ILL_H15_D11.instr"
  mccsg19_l = ( gElmtLength2 - gElementGap );
#line 546 "ILL_H15_D11.instr"
  mccsg19_R0 = mR0;
#line 546 "ILL_H15_D11.instr"
  mccsg19_Qc = mQc;
#line 546 "ILL_H15_D11.instr"
  mccsg19_alpha = mAlpha;
#line 546 "ILL_H15_D11.instr"
  mccsg19_m = mGuide1;
#line 546 "ILL_H15_D11.instr"
  mccsg19_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg19_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg19_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg19_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg19_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg19_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg19_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg19_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg19_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg19_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg19_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg19_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg19_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg19_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg19_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg19_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg19_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg19_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg19_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg19_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg19_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg19_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg19_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg19_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg19_reflect, "NULL" ? "NULL" : "", 16384); else mccsg19_reflect[0]='\0';
#line 25601 "ILL_H15_D11.c"

  SIG_MESSAGE("sg19 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25608 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg18, mcrotasg19);
  rot_transpose(mcrotasg18, mctr1);
  rot_mul(mcrotasg19, mctr1, mcrotrsg19);
  mctc1 = coords_set(
#line 547 "ILL_H15_D11.instr"
    0,
#line 547 "ILL_H15_D11.instr"
    0,
#line 547 "ILL_H15_D11.instr"
    gElmtLength2);
#line 25619 "ILL_H15_D11.c"
  rot_transpose(mcrotasg18, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg19 = coords_add(mcposasg18, mctc2);
  mctc1 = coords_sub(mcposasg18, mcposasg19);
  mcposrsg19 = rot_apply(mcrotasg19, mctc1);
  mcDEBUG_COMPONENT("sg19", mcposasg19, mcrotasg19)
  mccomp_posa[56] = mcposasg19;
  mccomp_posr[56] = mcposrsg19;
  mcNCounter[56]  = mcPCounter[56] = mcP2Counter[56] = 0;
  mcAbsorbProp[56]= 0;
    /* Component sg20. */
  /* Setting parameters for component sg20. */
  SIG_MESSAGE("sg20 (Init:SetPar)");
#line 549 "ILL_H15_D11.instr"
  mccsg20_w1 = gGuideWidth;
#line 549 "ILL_H15_D11.instr"
  mccsg20_h1 = gGuideHeight1;
#line 549 "ILL_H15_D11.instr"
  mccsg20_w2 = gGuideWidth;
#line 549 "ILL_H15_D11.instr"
  mccsg20_h2 = gGuideHeight1;
#line 550 "ILL_H15_D11.instr"
  mccsg20_l = ( gElmtLength2 - gElementGap );
#line 551 "ILL_H15_D11.instr"
  mccsg20_R0 = mR0;
#line 551 "ILL_H15_D11.instr"
  mccsg20_Qc = mQc;
#line 551 "ILL_H15_D11.instr"
  mccsg20_alpha = mAlpha;
#line 551 "ILL_H15_D11.instr"
  mccsg20_m = mGuide1;
#line 551 "ILL_H15_D11.instr"
  mccsg20_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg20_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg20_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg20_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg20_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg20_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg20_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg20_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg20_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg20_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg20_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg20_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg20_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg20_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg20_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg20_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg20_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg20_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg20_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg20_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg20_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg20_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg20_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg20_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg20_reflect, "NULL" ? "NULL" : "", 16384); else mccsg20_reflect[0]='\0';
#line 25701 "ILL_H15_D11.c"

  SIG_MESSAGE("sg20 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25708 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg19, mcrotasg20);
  rot_transpose(mcrotasg19, mctr1);
  rot_mul(mcrotasg20, mctr1, mcrotrsg20);
  mctc1 = coords_set(
#line 552 "ILL_H15_D11.instr"
    0,
#line 552 "ILL_H15_D11.instr"
    0,
#line 552 "ILL_H15_D11.instr"
    gElmtLength2);
#line 25719 "ILL_H15_D11.c"
  rot_transpose(mcrotasg19, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg20 = coords_add(mcposasg19, mctc2);
  mctc1 = coords_sub(mcposasg19, mcposasg20);
  mcposrsg20 = rot_apply(mcrotasg20, mctc1);
  mcDEBUG_COMPONENT("sg20", mcposasg20, mcrotasg20)
  mccomp_posa[57] = mcposasg20;
  mccomp_posr[57] = mcposrsg20;
  mcNCounter[57]  = mcPCounter[57] = mcP2Counter[57] = 0;
  mcAbsorbProp[57]= 0;
    /* Component sg21. */
  /* Setting parameters for component sg21. */
  SIG_MESSAGE("sg21 (Init:SetPar)");
#line 554 "ILL_H15_D11.instr"
  mccsg21_w1 = gGuideWidth;
#line 554 "ILL_H15_D11.instr"
  mccsg21_h1 = gGuideHeight1;
#line 554 "ILL_H15_D11.instr"
  mccsg21_w2 = gGuideWidth;
#line 554 "ILL_H15_D11.instr"
  mccsg21_h2 = gGuideHeight1;
#line 555 "ILL_H15_D11.instr"
  mccsg21_l = ( gElmtLength2 - gElementGap );
#line 556 "ILL_H15_D11.instr"
  mccsg21_R0 = mR0;
#line 556 "ILL_H15_D11.instr"
  mccsg21_Qc = mQc;
#line 556 "ILL_H15_D11.instr"
  mccsg21_alpha = mAlpha;
#line 556 "ILL_H15_D11.instr"
  mccsg21_m = mGuide1;
#line 556 "ILL_H15_D11.instr"
  mccsg21_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg21_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg21_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg21_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg21_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg21_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg21_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg21_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg21_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg21_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg21_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg21_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg21_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg21_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg21_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg21_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg21_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg21_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg21_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg21_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg21_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg21_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg21_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg21_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg21_reflect, "NULL" ? "NULL" : "", 16384); else mccsg21_reflect[0]='\0';
#line 25801 "ILL_H15_D11.c"

  SIG_MESSAGE("sg21 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25808 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg20, mcrotasg21);
  rot_transpose(mcrotasg20, mctr1);
  rot_mul(mcrotasg21, mctr1, mcrotrsg21);
  mctc1 = coords_set(
#line 557 "ILL_H15_D11.instr"
    0,
#line 557 "ILL_H15_D11.instr"
    0,
#line 557 "ILL_H15_D11.instr"
    gElmtLength2);
#line 25819 "ILL_H15_D11.c"
  rot_transpose(mcrotasg20, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg21 = coords_add(mcposasg20, mctc2);
  mctc1 = coords_sub(mcposasg20, mcposasg21);
  mcposrsg21 = rot_apply(mcrotasg21, mctc1);
  mcDEBUG_COMPONENT("sg21", mcposasg21, mcrotasg21)
  mccomp_posa[58] = mcposasg21;
  mccomp_posr[58] = mcposrsg21;
  mcNCounter[58]  = mcPCounter[58] = mcP2Counter[58] = 0;
  mcAbsorbProp[58]= 0;
    /* Component sg22. */
  /* Setting parameters for component sg22. */
  SIG_MESSAGE("sg22 (Init:SetPar)");
#line 559 "ILL_H15_D11.instr"
  mccsg22_w1 = gGuideWidth;
#line 559 "ILL_H15_D11.instr"
  mccsg22_h1 = gGuideHeight1;
#line 559 "ILL_H15_D11.instr"
  mccsg22_w2 = gGuideWidth;
#line 559 "ILL_H15_D11.instr"
  mccsg22_h2 = gGuideHeight1;
#line 560 "ILL_H15_D11.instr"
  mccsg22_l = ( gElmtLength2 - gElementGap );
#line 561 "ILL_H15_D11.instr"
  mccsg22_R0 = mR0;
#line 561 "ILL_H15_D11.instr"
  mccsg22_Qc = mQc;
#line 561 "ILL_H15_D11.instr"
  mccsg22_alpha = mAlpha;
#line 561 "ILL_H15_D11.instr"
  mccsg22_m = mGuide1;
#line 561 "ILL_H15_D11.instr"
  mccsg22_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg22_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg22_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg22_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg22_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg22_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg22_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg22_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg22_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg22_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg22_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg22_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg22_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg22_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg22_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg22_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg22_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg22_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg22_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg22_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg22_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg22_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg22_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg22_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg22_reflect, "NULL" ? "NULL" : "", 16384); else mccsg22_reflect[0]='\0';
#line 25901 "ILL_H15_D11.c"

  SIG_MESSAGE("sg22 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25908 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg21, mcrotasg22);
  rot_transpose(mcrotasg21, mctr1);
  rot_mul(mcrotasg22, mctr1, mcrotrsg22);
  mctc1 = coords_set(
#line 562 "ILL_H15_D11.instr"
    0,
#line 562 "ILL_H15_D11.instr"
    0,
#line 562 "ILL_H15_D11.instr"
    gElmtLength2);
#line 25919 "ILL_H15_D11.c"
  rot_transpose(mcrotasg21, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg22 = coords_add(mcposasg21, mctc2);
  mctc1 = coords_sub(mcposasg21, mcposasg22);
  mcposrsg22 = rot_apply(mcrotasg22, mctc1);
  mcDEBUG_COMPONENT("sg22", mcposasg22, mcrotasg22)
  mccomp_posa[59] = mcposasg22;
  mccomp_posr[59] = mcposrsg22;
  mcNCounter[59]  = mcPCounter[59] = mcP2Counter[59] = 0;
  mcAbsorbProp[59]= 0;
    /* Component AlWindow6. */
  /* Setting parameters for component AlWindow6. */
  SIG_MESSAGE("AlWindow6 (Init:SetPar)");
#line 566 "ILL_H15_D11.instr"
  mccAlWindow6_thickness = 0.002;
#line 25935 "ILL_H15_D11.c"

  SIG_MESSAGE("AlWindow6 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 25942 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg22, mcrotaAlWindow6);
  rot_transpose(mcrotasg22, mctr1);
  rot_mul(mcrotaAlWindow6, mctr1, mcrotrAlWindow6);
  mctc1 = coords_set(
#line 567 "ILL_H15_D11.instr"
    0,
#line 567 "ILL_H15_D11.instr"
    0,
#line 567 "ILL_H15_D11.instr"
    gElmtLength2 + 0.001);
#line 25953 "ILL_H15_D11.c"
  rot_transpose(mcrotasg22, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAlWindow6 = coords_add(mcposasg22, mctc2);
  mctc1 = coords_sub(mcposasg22, mcposaAlWindow6);
  mcposrAlWindow6 = rot_apply(mcrotaAlWindow6, mctc1);
  mcDEBUG_COMPONENT("AlWindow6", mcposaAlWindow6, mcrotaAlWindow6)
  mccomp_posa[60] = mcposaAlWindow6;
  mccomp_posr[60] = mcposrAlWindow6;
  mcNCounter[60]  = mcPCounter[60] = mcP2Counter[60] = 0;
  mcAbsorbProp[60]= 0;
    /* Component PSD_IN6. */
  /* Setting parameters for component PSD_IN6. */
  SIG_MESSAGE("PSD_IN6 (Init:SetPar)");
#line 569 "ILL_H15_D11.instr"
  mccPSD_IN6_xwidth = gGuideWidth;
#line 569 "ILL_H15_D11.instr"
  mccPSD_IN6_yheight = gGuideHeight1;
#line 203 "ILL_H15_D11.instr"
  mccPSD_IN6_zdepth = 0;
#line 204 "ILL_H15_D11.instr"
  mccPSD_IN6_xmin = 0;
#line 204 "ILL_H15_D11.instr"
  mccPSD_IN6_xmax = 0;
#line 204 "ILL_H15_D11.instr"
  mccPSD_IN6_ymin = 0;
#line 204 "ILL_H15_D11.instr"
  mccPSD_IN6_ymax = 0;
#line 204 "ILL_H15_D11.instr"
  mccPSD_IN6_zmin = 0;
#line 204 "ILL_H15_D11.instr"
  mccPSD_IN6_zmax = 0;
#line 205 "ILL_H15_D11.instr"
  mccPSD_IN6_bins = 0;
#line 205 "ILL_H15_D11.instr"
  mccPSD_IN6_min = -1e40;
#line 205 "ILL_H15_D11.instr"
  mccPSD_IN6_max = 1e40;
#line 205 "ILL_H15_D11.instr"
  mccPSD_IN6_restore_neutron = 0;
#line 205 "ILL_H15_D11.instr"
  mccPSD_IN6_radius = 0;
#line 570 "ILL_H15_D11.instr"
  if("x y") strncpy(mccPSD_IN6_options, "x y" ? "x y" : "", 16384); else mccPSD_IN6_options[0]='\0';
#line 206 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccPSD_IN6_filename, "NULL" ? "NULL" : "", 16384); else mccPSD_IN6_filename[0]='\0';
#line 206 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccPSD_IN6_geometry, "NULL" ? "NULL" : "", 16384); else mccPSD_IN6_geometry[0]='\0';
#line 207 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccPSD_IN6_username1, "NULL" ? "NULL" : "", 16384); else mccPSD_IN6_username1[0]='\0';
#line 207 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccPSD_IN6_username2, "NULL" ? "NULL" : "", 16384); else mccPSD_IN6_username2[0]='\0';
#line 207 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccPSD_IN6_username3, "NULL" ? "NULL" : "", 16384); else mccPSD_IN6_username3[0]='\0';
#line 208 "ILL_H15_D11.instr"
  mccPSD_IN6_nowritefile = 0;
#line 26009 "ILL_H15_D11.c"

  SIG_MESSAGE("PSD_IN6 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26016 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg22, mcrotaPSD_IN6);
  rot_transpose(mcrotaAlWindow6, mctr1);
  rot_mul(mcrotaPSD_IN6, mctr1, mcrotrPSD_IN6);
  mctc1 = coords_set(
#line 571 "ILL_H15_D11.instr"
    0,
#line 571 "ILL_H15_D11.instr"
    0,
#line 571 "ILL_H15_D11.instr"
    gElmtLength2 + 0.15);
#line 26027 "ILL_H15_D11.c"
  rot_transpose(mcrotasg22, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPSD_IN6 = coords_add(mcposasg22, mctc2);
  mctc1 = coords_sub(mcposaAlWindow6, mcposaPSD_IN6);
  mcposrPSD_IN6 = rot_apply(mcrotaPSD_IN6, mctc1);
  mcDEBUG_COMPONENT("PSD_IN6", mcposaPSD_IN6, mcrotaPSD_IN6)
  mccomp_posa[61] = mcposaPSD_IN6;
  mccomp_posr[61] = mcposrPSD_IN6;
  mcNCounter[61]  = mcPCounter[61] = mcP2Counter[61] = 0;
  mcAbsorbProp[61]= 0;
    /* Component AlWindow7. */
  /* Setting parameters for component AlWindow7. */
  SIG_MESSAGE("AlWindow7 (Init:SetPar)");
#line 573 "ILL_H15_D11.instr"
  mccAlWindow7_thickness = 0.002;
#line 26043 "ILL_H15_D11.c"

  SIG_MESSAGE("AlWindow7 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26050 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg22, mcrotaAlWindow7);
  rot_transpose(mcrotaPSD_IN6, mctr1);
  rot_mul(mcrotaAlWindow7, mctr1, mcrotrAlWindow7);
  mctc1 = coords_set(
#line 574 "ILL_H15_D11.instr"
    0,
#line 574 "ILL_H15_D11.instr"
    0,
#line 574 "ILL_H15_D11.instr"
    gElmtLength2 + 0.290);
#line 26061 "ILL_H15_D11.c"
  rot_transpose(mcrotasg22, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAlWindow7 = coords_add(mcposasg22, mctc2);
  mctc1 = coords_sub(mcposaPSD_IN6, mcposaAlWindow7);
  mcposrAlWindow7 = rot_apply(mcrotaAlWindow7, mctc1);
  mcDEBUG_COMPONENT("AlWindow7", mcposaAlWindow7, mcrotaAlWindow7)
  mccomp_posa[62] = mcposaAlWindow7;
  mccomp_posr[62] = mcposrAlWindow7;
  mcNCounter[62]  = mcPCounter[62] = mcP2Counter[62] = 0;
  mcAbsorbProp[62]= 0;
    /* Component IN6toD7GuideStart. */
  /* Setting parameters for component IN6toD7GuideStart. */
  SIG_MESSAGE("IN6toD7GuideStart (Init:SetPar)");

  SIG_MESSAGE("IN6toD7GuideStart (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26081 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg22, mcrotaIN6toD7GuideStart);
  rot_transpose(mcrotaAlWindow7, mctr1);
  rot_mul(mcrotaIN6toD7GuideStart, mctr1, mcrotrIN6toD7GuideStart);
  mctc1 = coords_set(
#line 577 "ILL_H15_D11.instr"
    0,
#line 577 "ILL_H15_D11.instr"
    0,
#line 577 "ILL_H15_D11.instr"
    gElmtLength2 + 0.30);
#line 26092 "ILL_H15_D11.c"
  rot_transpose(mcrotasg22, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaIN6toD7GuideStart = coords_add(mcposasg22, mctc2);
  mctc1 = coords_sub(mcposaAlWindow7, mcposaIN6toD7GuideStart);
  mcposrIN6toD7GuideStart = rot_apply(mcrotaIN6toD7GuideStart, mctc1);
  mcDEBUG_COMPONENT("IN6toD7GuideStart", mcposaIN6toD7GuideStart, mcrotaIN6toD7GuideStart)
  mccomp_posa[63] = mcposaIN6toD7GuideStart;
  mccomp_posr[63] = mcposrIN6toD7GuideStart;
  mcNCounter[63]  = mcPCounter[63] = mcP2Counter[63] = 0;
  mcAbsorbProp[63]= 0;
    /* Component sg23. */
  /* Setting parameters for component sg23. */
  SIG_MESSAGE("sg23 (Init:SetPar)");
#line 581 "ILL_H15_D11.instr"
  mccsg23_w1 = gGuideWidth;
#line 581 "ILL_H15_D11.instr"
  mccsg23_h1 = gGuideHeight1;
#line 581 "ILL_H15_D11.instr"
  mccsg23_w2 = gGuideWidth;
#line 581 "ILL_H15_D11.instr"
  mccsg23_h2 = gGuideHeight1;
#line 582 "ILL_H15_D11.instr"
  mccsg23_l = ( gElmtLength3 - gElementGap );
#line 583 "ILL_H15_D11.instr"
  mccsg23_R0 = mR0;
#line 583 "ILL_H15_D11.instr"
  mccsg23_Qc = mQc;
#line 583 "ILL_H15_D11.instr"
  mccsg23_alpha = mAlpha;
#line 583 "ILL_H15_D11.instr"
  mccsg23_m = mGuide1;
#line 583 "ILL_H15_D11.instr"
  mccsg23_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg23_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg23_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg23_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg23_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg23_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg23_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg23_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg23_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg23_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg23_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg23_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg23_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg23_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg23_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg23_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg23_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg23_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg23_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg23_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg23_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg23_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg23_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg23_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg23_reflect, "NULL" ? "NULL" : "", 16384); else mccsg23_reflect[0]='\0';
#line 26174 "ILL_H15_D11.c"

  SIG_MESSAGE("sg23 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26181 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotaIN6toD7GuideStart, mcrotasg23);
  rot_transpose(mcrotaIN6toD7GuideStart, mctr1);
  rot_mul(mcrotasg23, mctr1, mcrotrsg23);
  mctc1 = coords_set(
#line 584 "ILL_H15_D11.instr"
    0,
#line 584 "ILL_H15_D11.instr"
    0,
#line 584 "ILL_H15_D11.instr"
    0);
#line 26192 "ILL_H15_D11.c"
  rot_transpose(mcrotaIN6toD7GuideStart, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg23 = coords_add(mcposaIN6toD7GuideStart, mctc2);
  mctc1 = coords_sub(mcposaIN6toD7GuideStart, mcposasg23);
  mcposrsg23 = rot_apply(mcrotasg23, mctc1);
  mcDEBUG_COMPONENT("sg23", mcposasg23, mcrotasg23)
  mccomp_posa[64] = mcposasg23;
  mccomp_posr[64] = mcposrsg23;
  mcNCounter[64]  = mcPCounter[64] = mcP2Counter[64] = 0;
  mcAbsorbProp[64]= 0;
    /* Component sg24. */
  /* Setting parameters for component sg24. */
  SIG_MESSAGE("sg24 (Init:SetPar)");
#line 586 "ILL_H15_D11.instr"
  mccsg24_w1 = gGuideWidth;
#line 586 "ILL_H15_D11.instr"
  mccsg24_h1 = gGuideHeight1;
#line 586 "ILL_H15_D11.instr"
  mccsg24_w2 = gGuideWidth;
#line 586 "ILL_H15_D11.instr"
  mccsg24_h2 = gGuideHeight1;
#line 587 "ILL_H15_D11.instr"
  mccsg24_l = ( gElmtLength3 - gElementGap );
#line 588 "ILL_H15_D11.instr"
  mccsg24_R0 = mR0;
#line 588 "ILL_H15_D11.instr"
  mccsg24_Qc = mQc;
#line 588 "ILL_H15_D11.instr"
  mccsg24_alpha = mAlpha;
#line 588 "ILL_H15_D11.instr"
  mccsg24_m = mGuide1;
#line 588 "ILL_H15_D11.instr"
  mccsg24_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg24_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg24_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg24_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg24_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg24_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg24_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg24_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg24_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg24_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg24_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg24_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg24_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg24_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg24_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg24_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg24_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg24_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg24_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg24_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg24_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg24_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg24_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg24_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg24_reflect, "NULL" ? "NULL" : "", 16384); else mccsg24_reflect[0]='\0';
#line 26274 "ILL_H15_D11.c"

  SIG_MESSAGE("sg24 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26281 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg23, mcrotasg24);
  rot_transpose(mcrotasg23, mctr1);
  rot_mul(mcrotasg24, mctr1, mcrotrsg24);
  mctc1 = coords_set(
#line 589 "ILL_H15_D11.instr"
    0,
#line 589 "ILL_H15_D11.instr"
    0,
#line 589 "ILL_H15_D11.instr"
    gElmtLength3);
#line 26292 "ILL_H15_D11.c"
  rot_transpose(mcrotasg23, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg24 = coords_add(mcposasg23, mctc2);
  mctc1 = coords_sub(mcposasg23, mcposasg24);
  mcposrsg24 = rot_apply(mcrotasg24, mctc1);
  mcDEBUG_COMPONENT("sg24", mcposasg24, mcrotasg24)
  mccomp_posa[65] = mcposasg24;
  mccomp_posr[65] = mcposrsg24;
  mcNCounter[65]  = mcPCounter[65] = mcP2Counter[65] = 0;
  mcAbsorbProp[65]= 0;
    /* Component sg25. */
  /* Setting parameters for component sg25. */
  SIG_MESSAGE("sg25 (Init:SetPar)");
#line 591 "ILL_H15_D11.instr"
  mccsg25_w1 = gGuideWidth;
#line 591 "ILL_H15_D11.instr"
  mccsg25_h1 = gGuideHeight1;
#line 591 "ILL_H15_D11.instr"
  mccsg25_w2 = gGuideWidth;
#line 591 "ILL_H15_D11.instr"
  mccsg25_h2 = gGuideHeight1;
#line 592 "ILL_H15_D11.instr"
  mccsg25_l = ( gElmtLength3 - gElementGap );
#line 593 "ILL_H15_D11.instr"
  mccsg25_R0 = mR0;
#line 593 "ILL_H15_D11.instr"
  mccsg25_Qc = mQc;
#line 593 "ILL_H15_D11.instr"
  mccsg25_alpha = mAlpha;
#line 593 "ILL_H15_D11.instr"
  mccsg25_m = mGuide1;
#line 593 "ILL_H15_D11.instr"
  mccsg25_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg25_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg25_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg25_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg25_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg25_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg25_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg25_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg25_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg25_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg25_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg25_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg25_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg25_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg25_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg25_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg25_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg25_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg25_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg25_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg25_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg25_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg25_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg25_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg25_reflect, "NULL" ? "NULL" : "", 16384); else mccsg25_reflect[0]='\0';
#line 26374 "ILL_H15_D11.c"

  SIG_MESSAGE("sg25 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26381 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg24, mcrotasg25);
  rot_transpose(mcrotasg24, mctr1);
  rot_mul(mcrotasg25, mctr1, mcrotrsg25);
  mctc1 = coords_set(
#line 594 "ILL_H15_D11.instr"
    0,
#line 594 "ILL_H15_D11.instr"
    0,
#line 594 "ILL_H15_D11.instr"
    gElmtLength3);
#line 26392 "ILL_H15_D11.c"
  rot_transpose(mcrotasg24, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg25 = coords_add(mcposasg24, mctc2);
  mctc1 = coords_sub(mcposasg24, mcposasg25);
  mcposrsg25 = rot_apply(mcrotasg25, mctc1);
  mcDEBUG_COMPONENT("sg25", mcposasg25, mcrotasg25)
  mccomp_posa[66] = mcposasg25;
  mccomp_posr[66] = mcposrsg25;
  mcNCounter[66]  = mcPCounter[66] = mcP2Counter[66] = 0;
  mcAbsorbProp[66]= 0;
    /* Component sg26. */
  /* Setting parameters for component sg26. */
  SIG_MESSAGE("sg26 (Init:SetPar)");
#line 596 "ILL_H15_D11.instr"
  mccsg26_w1 = gGuideWidth;
#line 596 "ILL_H15_D11.instr"
  mccsg26_h1 = gGuideHeight1;
#line 596 "ILL_H15_D11.instr"
  mccsg26_w2 = gGuideWidth;
#line 596 "ILL_H15_D11.instr"
  mccsg26_h2 = gGuideHeight1;
#line 597 "ILL_H15_D11.instr"
  mccsg26_l = ( gElmtLength3 - gElementGap );
#line 598 "ILL_H15_D11.instr"
  mccsg26_R0 = mR0;
#line 598 "ILL_H15_D11.instr"
  mccsg26_Qc = mQc;
#line 598 "ILL_H15_D11.instr"
  mccsg26_alpha = mAlpha;
#line 598 "ILL_H15_D11.instr"
  mccsg26_m = mGuide1;
#line 598 "ILL_H15_D11.instr"
  mccsg26_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg26_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg26_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg26_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg26_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg26_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg26_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg26_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg26_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg26_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg26_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg26_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg26_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg26_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg26_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg26_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg26_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg26_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg26_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg26_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg26_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg26_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg26_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg26_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg26_reflect, "NULL" ? "NULL" : "", 16384); else mccsg26_reflect[0]='\0';
#line 26474 "ILL_H15_D11.c"

  SIG_MESSAGE("sg26 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26481 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg25, mcrotasg26);
  rot_transpose(mcrotasg25, mctr1);
  rot_mul(mcrotasg26, mctr1, mcrotrsg26);
  mctc1 = coords_set(
#line 599 "ILL_H15_D11.instr"
    0,
#line 599 "ILL_H15_D11.instr"
    0,
#line 599 "ILL_H15_D11.instr"
    gElmtLength3);
#line 26492 "ILL_H15_D11.c"
  rot_transpose(mcrotasg25, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg26 = coords_add(mcposasg25, mctc2);
  mctc1 = coords_sub(mcposasg25, mcposasg26);
  mcposrsg26 = rot_apply(mcrotasg26, mctc1);
  mcDEBUG_COMPONENT("sg26", mcposasg26, mcrotasg26)
  mccomp_posa[67] = mcposasg26;
  mccomp_posr[67] = mcposrsg26;
  mcNCounter[67]  = mcPCounter[67] = mcP2Counter[67] = 0;
  mcAbsorbProp[67]= 0;
    /* Component sg27. */
  /* Setting parameters for component sg27. */
  SIG_MESSAGE("sg27 (Init:SetPar)");
#line 601 "ILL_H15_D11.instr"
  mccsg27_w1 = gGuideWidth;
#line 601 "ILL_H15_D11.instr"
  mccsg27_h1 = gGuideHeight1;
#line 601 "ILL_H15_D11.instr"
  mccsg27_w2 = gGuideWidth;
#line 601 "ILL_H15_D11.instr"
  mccsg27_h2 = gGuideHeight1;
#line 602 "ILL_H15_D11.instr"
  mccsg27_l = ( gElmtLength3 - gElementGap );
#line 603 "ILL_H15_D11.instr"
  mccsg27_R0 = mR0;
#line 603 "ILL_H15_D11.instr"
  mccsg27_Qc = mQc;
#line 603 "ILL_H15_D11.instr"
  mccsg27_alpha = mAlpha;
#line 603 "ILL_H15_D11.instr"
  mccsg27_m = mGuide1;
#line 603 "ILL_H15_D11.instr"
  mccsg27_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg27_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg27_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg27_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg27_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg27_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg27_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg27_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg27_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg27_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg27_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg27_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg27_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg27_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg27_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg27_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg27_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg27_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg27_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg27_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg27_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg27_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg27_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg27_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg27_reflect, "NULL" ? "NULL" : "", 16384); else mccsg27_reflect[0]='\0';
#line 26574 "ILL_H15_D11.c"

  SIG_MESSAGE("sg27 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26581 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg26, mcrotasg27);
  rot_transpose(mcrotasg26, mctr1);
  rot_mul(mcrotasg27, mctr1, mcrotrsg27);
  mctc1 = coords_set(
#line 604 "ILL_H15_D11.instr"
    0,
#line 604 "ILL_H15_D11.instr"
    0,
#line 604 "ILL_H15_D11.instr"
    gElmtLength3);
#line 26592 "ILL_H15_D11.c"
  rot_transpose(mcrotasg26, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg27 = coords_add(mcposasg26, mctc2);
  mctc1 = coords_sub(mcposasg26, mcposasg27);
  mcposrsg27 = rot_apply(mcrotasg27, mctc1);
  mcDEBUG_COMPONENT("sg27", mcposasg27, mcrotasg27)
  mccomp_posa[68] = mcposasg27;
  mccomp_posr[68] = mcposrsg27;
  mcNCounter[68]  = mcPCounter[68] = mcP2Counter[68] = 0;
  mcAbsorbProp[68]= 0;
    /* Component AlWindow8. */
  /* Setting parameters for component AlWindow8. */
  SIG_MESSAGE("AlWindow8 (Init:SetPar)");
#line 608 "ILL_H15_D11.instr"
  mccAlWindow8_thickness = 0.002;
#line 26608 "ILL_H15_D11.c"

  SIG_MESSAGE("AlWindow8 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26615 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg27, mcrotaAlWindow8);
  rot_transpose(mcrotasg27, mctr1);
  rot_mul(mcrotaAlWindow8, mctr1, mcrotrAlWindow8);
  mctc1 = coords_set(
#line 609 "ILL_H15_D11.instr"
    0,
#line 609 "ILL_H15_D11.instr"
    0,
#line 609 "ILL_H15_D11.instr"
    gElmtLength3 + 0.001);
#line 26626 "ILL_H15_D11.c"
  rot_transpose(mcrotasg27, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAlWindow8 = coords_add(mcposasg27, mctc2);
  mctc1 = coords_sub(mcposasg27, mcposaAlWindow8);
  mcposrAlWindow8 = rot_apply(mcrotaAlWindow8, mctc1);
  mcDEBUG_COMPONENT("AlWindow8", mcposaAlWindow8, mcrotaAlWindow8)
  mccomp_posa[69] = mcposaAlWindow8;
  mccomp_posr[69] = mcposrAlWindow8;
  mcNCounter[69]  = mcPCounter[69] = mcP2Counter[69] = 0;
  mcAbsorbProp[69]= 0;
    /* Component PSD_D7. */
  /* Setting parameters for component PSD_D7. */
  SIG_MESSAGE("PSD_D7 (Init:SetPar)");
#line 611 "ILL_H15_D11.instr"
  mccPSD_D7_xwidth = gGuideWidth;
#line 611 "ILL_H15_D11.instr"
  mccPSD_D7_yheight = gGuideHeight1;
#line 203 "ILL_H15_D11.instr"
  mccPSD_D7_zdepth = 0;
#line 204 "ILL_H15_D11.instr"
  mccPSD_D7_xmin = 0;
#line 204 "ILL_H15_D11.instr"
  mccPSD_D7_xmax = 0;
#line 204 "ILL_H15_D11.instr"
  mccPSD_D7_ymin = 0;
#line 204 "ILL_H15_D11.instr"
  mccPSD_D7_ymax = 0;
#line 204 "ILL_H15_D11.instr"
  mccPSD_D7_zmin = 0;
#line 204 "ILL_H15_D11.instr"
  mccPSD_D7_zmax = 0;
#line 205 "ILL_H15_D11.instr"
  mccPSD_D7_bins = 0;
#line 205 "ILL_H15_D11.instr"
  mccPSD_D7_min = -1e40;
#line 205 "ILL_H15_D11.instr"
  mccPSD_D7_max = 1e40;
#line 205 "ILL_H15_D11.instr"
  mccPSD_D7_restore_neutron = 0;
#line 205 "ILL_H15_D11.instr"
  mccPSD_D7_radius = 0;
#line 612 "ILL_H15_D11.instr"
  if("x y") strncpy(mccPSD_D7_options, "x y" ? "x y" : "", 16384); else mccPSD_D7_options[0]='\0';
#line 206 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccPSD_D7_filename, "NULL" ? "NULL" : "", 16384); else mccPSD_D7_filename[0]='\0';
#line 206 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccPSD_D7_geometry, "NULL" ? "NULL" : "", 16384); else mccPSD_D7_geometry[0]='\0';
#line 207 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccPSD_D7_username1, "NULL" ? "NULL" : "", 16384); else mccPSD_D7_username1[0]='\0';
#line 207 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccPSD_D7_username2, "NULL" ? "NULL" : "", 16384); else mccPSD_D7_username2[0]='\0';
#line 207 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccPSD_D7_username3, "NULL" ? "NULL" : "", 16384); else mccPSD_D7_username3[0]='\0';
#line 208 "ILL_H15_D11.instr"
  mccPSD_D7_nowritefile = 0;
#line 26682 "ILL_H15_D11.c"

  SIG_MESSAGE("PSD_D7 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26689 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg27, mcrotaPSD_D7);
  rot_transpose(mcrotaAlWindow8, mctr1);
  rot_mul(mcrotaPSD_D7, mctr1, mcrotrPSD_D7);
  mctc1 = coords_set(
#line 613 "ILL_H15_D11.instr"
    0,
#line 613 "ILL_H15_D11.instr"
    0,
#line 613 "ILL_H15_D11.instr"
    gElmtLength3 + 0.15);
#line 26700 "ILL_H15_D11.c"
  rot_transpose(mcrotasg27, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaPSD_D7 = coords_add(mcposasg27, mctc2);
  mctc1 = coords_sub(mcposaAlWindow8, mcposaPSD_D7);
  mcposrPSD_D7 = rot_apply(mcrotaPSD_D7, mctc1);
  mcDEBUG_COMPONENT("PSD_D7", mcposaPSD_D7, mcrotaPSD_D7)
  mccomp_posa[70] = mcposaPSD_D7;
  mccomp_posr[70] = mcposrPSD_D7;
  mcNCounter[70]  = mcPCounter[70] = mcP2Counter[70] = 0;
  mcAbsorbProp[70]= 0;
    /* Component AlWindow9. */
  /* Setting parameters for component AlWindow9. */
  SIG_MESSAGE("AlWindow9 (Init:SetPar)");
#line 615 "ILL_H15_D11.instr"
  mccAlWindow9_thickness = 0.002;
#line 26716 "ILL_H15_D11.c"

  SIG_MESSAGE("AlWindow9 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26723 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg27, mcrotaAlWindow9);
  rot_transpose(mcrotaPSD_D7, mctr1);
  rot_mul(mcrotaAlWindow9, mctr1, mcrotrAlWindow9);
  mctc1 = coords_set(
#line 616 "ILL_H15_D11.instr"
    0,
#line 616 "ILL_H15_D11.instr"
    0,
#line 616 "ILL_H15_D11.instr"
    gElmtLength3 + 0.290);
#line 26734 "ILL_H15_D11.c"
  rot_transpose(mcrotasg27, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAlWindow9 = coords_add(mcposasg27, mctc2);
  mctc1 = coords_sub(mcposaPSD_D7, mcposaAlWindow9);
  mcposrAlWindow9 = rot_apply(mcrotaAlWindow9, mctc1);
  mcDEBUG_COMPONENT("AlWindow9", mcposaAlWindow9, mcrotaAlWindow9)
  mccomp_posa[71] = mcposaAlWindow9;
  mccomp_posr[71] = mcposrAlWindow9;
  mcNCounter[71]  = mcPCounter[71] = mcP2Counter[71] = 0;
  mcAbsorbProp[71]= 0;
    /* Component D7toD11GuideStart. */
  /* Setting parameters for component D7toD11GuideStart. */
  SIG_MESSAGE("D7toD11GuideStart (Init:SetPar)");

  SIG_MESSAGE("D7toD11GuideStart (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26754 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg27, mcrotaD7toD11GuideStart);
  rot_transpose(mcrotaAlWindow9, mctr1);
  rot_mul(mcrotaD7toD11GuideStart, mctr1, mcrotrD7toD11GuideStart);
  mctc1 = coords_set(
#line 619 "ILL_H15_D11.instr"
    0,
#line 619 "ILL_H15_D11.instr"
    -.065,
#line 619 "ILL_H15_D11.instr"
    gElmtLength3 + 0.30);
#line 26765 "ILL_H15_D11.c"
  rot_transpose(mcrotasg27, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaD7toD11GuideStart = coords_add(mcposasg27, mctc2);
  mctc1 = coords_sub(mcposaAlWindow9, mcposaD7toD11GuideStart);
  mcposrD7toD11GuideStart = rot_apply(mcrotaD7toD11GuideStart, mctc1);
  mcDEBUG_COMPONENT("D7toD11GuideStart", mcposaD7toD11GuideStart, mcrotaD7toD11GuideStart)
  mccomp_posa[72] = mcposaD7toD11GuideStart;
  mccomp_posr[72] = mcposrD7toD11GuideStart;
  mcNCounter[72]  = mcPCounter[72] = mcP2Counter[72] = 0;
  mcAbsorbProp[72]= 0;
    /* Component sg28. */
  /* Setting parameters for component sg28. */
  SIG_MESSAGE("sg28 (Init:SetPar)");
#line 623 "ILL_H15_D11.instr"
  mccsg28_w1 = gGuideWidth;
#line 623 "ILL_H15_D11.instr"
  mccsg28_h1 = gGuideHeight2;
#line 623 "ILL_H15_D11.instr"
  mccsg28_w2 = gGuideWidth;
#line 623 "ILL_H15_D11.instr"
  mccsg28_h2 = gGuideHeight2;
#line 624 "ILL_H15_D11.instr"
  mccsg28_l = ( 1.25 - gElementGap );
#line 625 "ILL_H15_D11.instr"
  mccsg28_R0 = mR0;
#line 625 "ILL_H15_D11.instr"
  mccsg28_Qc = mQc;
#line 625 "ILL_H15_D11.instr"
  mccsg28_alpha = mAlpha;
#line 625 "ILL_H15_D11.instr"
  mccsg28_m = mGuide2;
#line 625 "ILL_H15_D11.instr"
  mccsg28_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg28_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg28_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg28_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg28_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg28_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg28_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg28_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg28_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg28_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg28_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg28_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg28_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg28_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg28_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg28_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg28_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg28_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg28_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg28_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg28_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg28_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg28_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg28_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg28_reflect, "NULL" ? "NULL" : "", 16384); else mccsg28_reflect[0]='\0';
#line 26847 "ILL_H15_D11.c"

  SIG_MESSAGE("sg28 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26854 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotaD7toD11GuideStart, mcrotasg28);
  rot_transpose(mcrotaD7toD11GuideStart, mctr1);
  rot_mul(mcrotasg28, mctr1, mcrotrsg28);
  mctc1 = coords_set(
#line 626 "ILL_H15_D11.instr"
    0,
#line 626 "ILL_H15_D11.instr"
    0,
#line 626 "ILL_H15_D11.instr"
    0);
#line 26865 "ILL_H15_D11.c"
  rot_transpose(mcrotaD7toD11GuideStart, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg28 = coords_add(mcposaD7toD11GuideStart, mctc2);
  mctc1 = coords_sub(mcposaD7toD11GuideStart, mcposasg28);
  mcposrsg28 = rot_apply(mcrotasg28, mctc1);
  mcDEBUG_COMPONENT("sg28", mcposasg28, mcrotasg28)
  mccomp_posa[73] = mcposasg28;
  mccomp_posr[73] = mcposrsg28;
  mcNCounter[73]  = mcPCounter[73] = mcP2Counter[73] = 0;
  mcAbsorbProp[73]= 0;
    /* Component sg29. */
  /* Setting parameters for component sg29. */
  SIG_MESSAGE("sg29 (Init:SetPar)");
#line 630 "ILL_H15_D11.instr"
  mccsg29_w1 = gGuideWidth;
#line 630 "ILL_H15_D11.instr"
  mccsg29_h1 = gGuideHeight2;
#line 630 "ILL_H15_D11.instr"
  mccsg29_w2 = gGuideWidth;
#line 630 "ILL_H15_D11.instr"
  mccsg29_h2 = gGuideHeight2;
#line 631 "ILL_H15_D11.instr"
  mccsg29_l = ( 0.5 - gElementGap );
#line 632 "ILL_H15_D11.instr"
  mccsg29_R0 = mR0;
#line 632 "ILL_H15_D11.instr"
  mccsg29_Qc = mQc;
#line 632 "ILL_H15_D11.instr"
  mccsg29_alpha = mAlpha;
#line 632 "ILL_H15_D11.instr"
  mccsg29_m = mGuide2;
#line 632 "ILL_H15_D11.instr"
  mccsg29_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg29_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg29_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg29_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg29_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg29_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg29_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg29_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg29_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg29_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg29_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg29_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg29_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg29_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg29_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg29_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg29_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg29_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg29_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg29_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg29_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg29_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg29_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg29_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg29_reflect, "NULL" ? "NULL" : "", 16384); else mccsg29_reflect[0]='\0';
#line 26947 "ILL_H15_D11.c"

  SIG_MESSAGE("sg29 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26954 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg28, mcrotasg29);
  rot_transpose(mcrotasg28, mctr1);
  rot_mul(mcrotasg29, mctr1, mcrotrsg29);
  mctc1 = coords_set(
#line 633 "ILL_H15_D11.instr"
    0,
#line 633 "ILL_H15_D11.instr"
    0,
#line 633 "ILL_H15_D11.instr"
    1.25);
#line 26965 "ILL_H15_D11.c"
  rot_transpose(mcrotasg28, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg29 = coords_add(mcposasg28, mctc2);
  mctc1 = coords_sub(mcposasg28, mcposasg29);
  mcposrsg29 = rot_apply(mcrotasg29, mctc1);
  mcDEBUG_COMPONENT("sg29", mcposasg29, mcrotasg29)
  mccomp_posa[74] = mcposasg29;
  mccomp_posr[74] = mcposrsg29;
  mcNCounter[74]  = mcPCounter[74] = mcP2Counter[74] = 0;
  mcAbsorbProp[74]= 0;
    /* Component AlWindow10. */
  /* Setting parameters for component AlWindow10. */
  SIG_MESSAGE("AlWindow10 (Init:SetPar)");
#line 637 "ILL_H15_D11.instr"
  mccAlWindow10_thickness = 0.004;
#line 26981 "ILL_H15_D11.c"

  SIG_MESSAGE("AlWindow10 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 26988 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg29, mcrotaAlWindow10);
  rot_transpose(mcrotasg29, mctr1);
  rot_mul(mcrotaAlWindow10, mctr1, mcrotrAlWindow10);
  mctc1 = coords_set(
#line 638 "ILL_H15_D11.instr"
    0,
#line 638 "ILL_H15_D11.instr"
    0,
#line 638 "ILL_H15_D11.instr"
    0.5 + 0.001);
#line 26999 "ILL_H15_D11.c"
  rot_transpose(mcrotasg29, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAlWindow10 = coords_add(mcposasg29, mctc2);
  mctc1 = coords_sub(mcposasg29, mcposaAlWindow10);
  mcposrAlWindow10 = rot_apply(mcrotaAlWindow10, mctc1);
  mcDEBUG_COMPONENT("AlWindow10", mcposaAlWindow10, mcrotaAlWindow10)
  mccomp_posa[75] = mcposaAlWindow10;
  mccomp_posr[75] = mcposrAlWindow10;
  mcNCounter[75]  = mcPCounter[75] = mcP2Counter[75] = 0;
  mcAbsorbProp[75]= 0;
    /* Component Mon_D11_In. */
  /* Setting parameters for component Mon_D11_In. */
  SIG_MESSAGE("Mon_D11_In (Init:SetPar)");
#line 640 "ILL_H15_D11.instr"
  mccMon_D11_In_xwidth = gGuideWidth;
#line 640 "ILL_H15_D11.instr"
  mccMon_D11_In_yheight = gGuideHeight2;
#line 203 "ILL_H15_D11.instr"
  mccMon_D11_In_zdepth = 0;
#line 204 "ILL_H15_D11.instr"
  mccMon_D11_In_xmin = 0;
#line 204 "ILL_H15_D11.instr"
  mccMon_D11_In_xmax = 0;
#line 204 "ILL_H15_D11.instr"
  mccMon_D11_In_ymin = 0;
#line 204 "ILL_H15_D11.instr"
  mccMon_D11_In_ymax = 0;
#line 204 "ILL_H15_D11.instr"
  mccMon_D11_In_zmin = 0;
#line 204 "ILL_H15_D11.instr"
  mccMon_D11_In_zmax = 0;
#line 205 "ILL_H15_D11.instr"
  mccMon_D11_In_bins = 0;
#line 205 "ILL_H15_D11.instr"
  mccMon_D11_In_min = -1e40;
#line 205 "ILL_H15_D11.instr"
  mccMon_D11_In_max = 1e40;
#line 205 "ILL_H15_D11.instr"
  mccMon_D11_In_restore_neutron = 0;
#line 205 "ILL_H15_D11.instr"
  mccMon_D11_In_radius = 0;
#line 641 "ILL_H15_D11.instr"
  if("x lambda, auto") strncpy(mccMon_D11_In_options, "x lambda, auto" ? "x lambda, auto" : "", 16384); else mccMon_D11_In_options[0]='\0';
#line 206 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccMon_D11_In_filename, "NULL" ? "NULL" : "", 16384); else mccMon_D11_In_filename[0]='\0';
#line 206 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccMon_D11_In_geometry, "NULL" ? "NULL" : "", 16384); else mccMon_D11_In_geometry[0]='\0';
#line 207 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccMon_D11_In_username1, "NULL" ? "NULL" : "", 16384); else mccMon_D11_In_username1[0]='\0';
#line 207 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccMon_D11_In_username2, "NULL" ? "NULL" : "", 16384); else mccMon_D11_In_username2[0]='\0';
#line 207 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccMon_D11_In_username3, "NULL" ? "NULL" : "", 16384); else mccMon_D11_In_username3[0]='\0';
#line 208 "ILL_H15_D11.instr"
  mccMon_D11_In_nowritefile = 0;
#line 27055 "ILL_H15_D11.c"

  SIG_MESSAGE("Mon_D11_In (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27062 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg29, mcrotaMon_D11_In);
  rot_transpose(mcrotaAlWindow10, mctr1);
  rot_mul(mcrotaMon_D11_In, mctr1, mcrotrMon_D11_In);
  mctc1 = coords_set(
#line 642 "ILL_H15_D11.instr"
    0,
#line 642 "ILL_H15_D11.instr"
    0,
#line 642 "ILL_H15_D11.instr"
    0.5 + 0.01);
#line 27073 "ILL_H15_D11.c"
  rot_transpose(mcrotasg29, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaMon_D11_In = coords_add(mcposasg29, mctc2);
  mctc1 = coords_sub(mcposaAlWindow10, mcposaMon_D11_In);
  mcposrMon_D11_In = rot_apply(mcrotaMon_D11_In, mctc1);
  mcDEBUG_COMPONENT("Mon_D11_In", mcposaMon_D11_In, mcrotaMon_D11_In)
  mccomp_posa[76] = mcposaMon_D11_In;
  mccomp_posr[76] = mcposrMon_D11_In;
  mcNCounter[76]  = mcPCounter[76] = mcP2Counter[76] = 0;
  mcAbsorbProp[76]= 0;
    /* Component Dolores. */
  /* Setting parameters for component Dolores. */
  SIG_MESSAGE("Dolores (Init:SetPar)");
#line 644 "ILL_H15_D11.instr"
  mccDolores_xwidth = 0.03;
#line 644 "ILL_H15_D11.instr"
  mccDolores_yheight = 0.05;
#line 644 "ILL_H15_D11.instr"
  mccDolores_zdepth = 0.30;
#line 644 "ILL_H15_D11.instr"
  mccDolores_radius = 0.12;
#line 644 "ILL_H15_D11.instr"
  mccDolores_alpha = 48.298;
#line 645 "ILL_H15_D11.instr"
  mccDolores_length = 0.250;
#line 645 "ILL_H15_D11.instr"
  mccDolores_d = 0.0004;
#line 645 "ILL_H15_D11.instr"
  mccDolores_nu = Vrpm / 60;
#line 645 "ILL_H15_D11.instr"
  mccDolores_nslit = 72;
#line 27105 "ILL_H15_D11.c"

  SIG_MESSAGE("Dolores (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27112 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg29, mcrotaDolores);
  rot_transpose(mcrotaMon_D11_In, mctr1);
  rot_mul(mcrotaDolores, mctr1, mcrotrDolores);
  mctc1 = coords_set(
#line 646 "ILL_H15_D11.instr"
    0,
#line 646 "ILL_H15_D11.instr"
    0,
#line 646 "ILL_H15_D11.instr"
    0.5 + 0.025 + 0.30 / 2);
#line 27123 "ILL_H15_D11.c"
  rot_transpose(mcrotasg29, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaDolores = coords_add(mcposasg29, mctc2);
  mctc1 = coords_sub(mcposaMon_D11_In, mcposaDolores);
  mcposrDolores = rot_apply(mcrotaDolores, mctc1);
  mcDEBUG_COMPONENT("Dolores", mcposaDolores, mcrotaDolores)
  mccomp_posa[77] = mcposaDolores;
  mccomp_posr[77] = mcposrDolores;
  mcNCounter[77]  = mcPCounter[77] = mcP2Counter[77] = 0;
  mcAbsorbProp[77]= 0;
    /* Component AlWindow11. */
  /* Setting parameters for component AlWindow11. */
  SIG_MESSAGE("AlWindow11 (Init:SetPar)");
#line 648 "ILL_H15_D11.instr"
  mccAlWindow11_thickness = 0.004;
#line 27139 "ILL_H15_D11.c"

  SIG_MESSAGE("AlWindow11 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27146 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotaDolores, mcrotaAlWindow11);
  rot_transpose(mcrotaDolores, mctr1);
  rot_mul(mcrotaAlWindow11, mctr1, mcrotrAlWindow11);
  mctc1 = coords_set(
#line 649 "ILL_H15_D11.instr"
    0,
#line 649 "ILL_H15_D11.instr"
    0,
#line 649 "ILL_H15_D11.instr"
    0.15 + 0.01);
#line 27157 "ILL_H15_D11.c"
  rot_transpose(mcrotaDolores, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAlWindow11 = coords_add(mcposaDolores, mctc2);
  mctc1 = coords_sub(mcposaDolores, mcposaAlWindow11);
  mcposrAlWindow11 = rot_apply(mcrotaAlWindow11, mctc1);
  mcDEBUG_COMPONENT("AlWindow11", mcposaAlWindow11, mcrotaAlWindow11)
  mccomp_posa[78] = mcposaAlWindow11;
  mccomp_posr[78] = mcposrAlWindow11;
  mcNCounter[78]  = mcPCounter[78] = mcP2Counter[78] = 0;
  mcAbsorbProp[78]= 0;
    /* Component sg30. */
  /* Setting parameters for component sg30. */
  SIG_MESSAGE("sg30 (Init:SetPar)");
#line 653 "ILL_H15_D11.instr"
  mccsg30_w1 = gGuideWidth;
#line 653 "ILL_H15_D11.instr"
  mccsg30_h1 = gGuideHeight2;
#line 653 "ILL_H15_D11.instr"
  mccsg30_w2 = gGuideWidth;
#line 653 "ILL_H15_D11.instr"
  mccsg30_h2 = gGuideHeight2;
#line 654 "ILL_H15_D11.instr"
  mccsg30_l = ( 0.5 - gElementGap );
#line 655 "ILL_H15_D11.instr"
  mccsg30_R0 = mR0;
#line 655 "ILL_H15_D11.instr"
  mccsg30_Qc = mQc;
#line 655 "ILL_H15_D11.instr"
  mccsg30_alpha = mAlpha;
#line 655 "ILL_H15_D11.instr"
  mccsg30_m = mGuide2;
#line 655 "ILL_H15_D11.instr"
  mccsg30_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccsg30_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccsg30_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccsg30_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg30_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg30_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg30_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccsg30_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccsg30_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccsg30_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg30_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg30_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccsg30_abottom = -1;
#line 117 "ILL_H15_D11.instr"
  mccsg30_wavy = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg30_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg30_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccsg30_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg30_chamfers = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg30_chamfers_z = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg30_chamfers_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg30_chamfers_tb = 0;
#line 118 "ILL_H15_D11.instr"
  mccsg30_nelements = 1;
#line 119 "ILL_H15_D11.instr"
  mccsg30_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccsg30_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccsg30_reflect, "NULL" ? "NULL" : "", 16384); else mccsg30_reflect[0]='\0';
#line 27239 "ILL_H15_D11.c"

  SIG_MESSAGE("sg30 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27246 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotaDolores, mcrotasg30);
  rot_transpose(mcrotaAlWindow11, mctr1);
  rot_mul(mcrotasg30, mctr1, mcrotrsg30);
  mctc1 = coords_set(
#line 656 "ILL_H15_D11.instr"
    0,
#line 656 "ILL_H15_D11.instr"
    0,
#line 656 "ILL_H15_D11.instr"
    0.15 + 0.02);
#line 27257 "ILL_H15_D11.c"
  rot_transpose(mcrotaDolores, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposasg30 = coords_add(mcposaDolores, mctc2);
  mctc1 = coords_sub(mcposaAlWindow11, mcposasg30);
  mcposrsg30 = rot_apply(mcrotasg30, mctc1);
  mcDEBUG_COMPONENT("sg30", mcposasg30, mcrotasg30)
  mccomp_posa[79] = mcposasg30;
  mccomp_posr[79] = mcposrsg30;
  mcNCounter[79]  = mcPCounter[79] = mcP2Counter[79] = 0;
  mcAbsorbProp[79]= 0;
    /* Component AlWindow12. */
  /* Setting parameters for component AlWindow12. */
  SIG_MESSAGE("AlWindow12 (Init:SetPar)");
#line 660 "ILL_H15_D11.instr"
  mccAlWindow12_thickness = 0.002;
#line 27273 "ILL_H15_D11.c"

  SIG_MESSAGE("AlWindow12 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27280 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg30, mcrotaAlWindow12);
  rot_transpose(mcrotasg30, mctr1);
  rot_mul(mcrotaAlWindow12, mctr1, mcrotrAlWindow12);
  mctc1 = coords_set(
#line 661 "ILL_H15_D11.instr"
    0,
#line 661 "ILL_H15_D11.instr"
    0,
#line 661 "ILL_H15_D11.instr"
    0.5 + 0.001);
#line 27291 "ILL_H15_D11.c"
  rot_transpose(mcrotasg30, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAlWindow12 = coords_add(mcposasg30, mctc2);
  mctc1 = coords_sub(mcposasg30, mcposaAlWindow12);
  mcposrAlWindow12 = rot_apply(mcrotaAlWindow12, mctc1);
  mcDEBUG_COMPONENT("AlWindow12", mcposaAlWindow12, mcrotaAlWindow12)
  mccomp_posa[80] = mcposaAlWindow12;
  mccomp_posr[80] = mcposrAlWindow12;
  mcNCounter[80]  = mcPCounter[80] = mcP2Counter[80] = 0;
  mcAbsorbProp[80]= 0;
    /* Component Mon_D11_Out. */
  /* Setting parameters for component Mon_D11_Out. */
  SIG_MESSAGE("Mon_D11_Out (Init:SetPar)");
#line 663 "ILL_H15_D11.instr"
  mccMon_D11_Out_xwidth = gGuideWidth;
#line 663 "ILL_H15_D11.instr"
  mccMon_D11_Out_yheight = gGuideHeight2;
#line 203 "ILL_H15_D11.instr"
  mccMon_D11_Out_zdepth = 0;
#line 204 "ILL_H15_D11.instr"
  mccMon_D11_Out_xmin = 0;
#line 204 "ILL_H15_D11.instr"
  mccMon_D11_Out_xmax = 0;
#line 204 "ILL_H15_D11.instr"
  mccMon_D11_Out_ymin = 0;
#line 204 "ILL_H15_D11.instr"
  mccMon_D11_Out_ymax = 0;
#line 204 "ILL_H15_D11.instr"
  mccMon_D11_Out_zmin = 0;
#line 204 "ILL_H15_D11.instr"
  mccMon_D11_Out_zmax = 0;
#line 205 "ILL_H15_D11.instr"
  mccMon_D11_Out_bins = 0;
#line 205 "ILL_H15_D11.instr"
  mccMon_D11_Out_min = -1e40;
#line 205 "ILL_H15_D11.instr"
  mccMon_D11_Out_max = 1e40;
#line 205 "ILL_H15_D11.instr"
  mccMon_D11_Out_restore_neutron = 0;
#line 205 "ILL_H15_D11.instr"
  mccMon_D11_Out_radius = 0;
#line 664 "ILL_H15_D11.instr"
  if("x lambda, auto") strncpy(mccMon_D11_Out_options, "x lambda, auto" ? "x lambda, auto" : "", 16384); else mccMon_D11_Out_options[0]='\0';
#line 206 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccMon_D11_Out_filename, "NULL" ? "NULL" : "", 16384); else mccMon_D11_Out_filename[0]='\0';
#line 206 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccMon_D11_Out_geometry, "NULL" ? "NULL" : "", 16384); else mccMon_D11_Out_geometry[0]='\0';
#line 207 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccMon_D11_Out_username1, "NULL" ? "NULL" : "", 16384); else mccMon_D11_Out_username1[0]='\0';
#line 207 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccMon_D11_Out_username2, "NULL" ? "NULL" : "", 16384); else mccMon_D11_Out_username2[0]='\0';
#line 207 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccMon_D11_Out_username3, "NULL" ? "NULL" : "", 16384); else mccMon_D11_Out_username3[0]='\0';
#line 208 "ILL_H15_D11.instr"
  mccMon_D11_Out_nowritefile = 0;
#line 27347 "ILL_H15_D11.c"

  SIG_MESSAGE("Mon_D11_Out (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27354 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg30, mcrotaMon_D11_Out);
  rot_transpose(mcrotaAlWindow12, mctr1);
  rot_mul(mcrotaMon_D11_Out, mctr1, mcrotrMon_D11_Out);
  mctc1 = coords_set(
#line 665 "ILL_H15_D11.instr"
    0,
#line 665 "ILL_H15_D11.instr"
    0,
#line 665 "ILL_H15_D11.instr"
    0.5 + 0.01);
#line 27365 "ILL_H15_D11.c"
  rot_transpose(mcrotasg30, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaMon_D11_Out = coords_add(mcposasg30, mctc2);
  mctc1 = coords_sub(mcposaAlWindow12, mcposaMon_D11_Out);
  mcposrMon_D11_Out = rot_apply(mcrotaMon_D11_Out, mctc1);
  mcDEBUG_COMPONENT("Mon_D11_Out", mcposaMon_D11_Out, mcrotaMon_D11_Out)
  mccomp_posa[81] = mcposaMon_D11_Out;
  mccomp_posr[81] = mcposrMon_D11_Out;
  mcNCounter[81]  = mcPCounter[81] = mcP2Counter[81] = 0;
  mcAbsorbProp[81]= 0;
    /* Component AlWindow13. */
  /* Setting parameters for component AlWindow13. */
  SIG_MESSAGE("AlWindow13 (Init:SetPar)");
#line 667 "ILL_H15_D11.instr"
  mccAlWindow13_thickness = 0.002;
#line 27381 "ILL_H15_D11.c"

  SIG_MESSAGE("AlWindow13 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27388 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg30, mcrotaAlWindow13);
  rot_transpose(mcrotaMon_D11_Out, mctr1);
  rot_mul(mcrotaAlWindow13, mctr1, mcrotrAlWindow13);
  mctc1 = coords_set(
#line 668 "ILL_H15_D11.instr"
    0,
#line 668 "ILL_H15_D11.instr"
    0,
#line 668 "ILL_H15_D11.instr"
    0.5 + 0.03 -0.003);
#line 27399 "ILL_H15_D11.c"
  rot_transpose(mcrotasg30, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaAlWindow13 = coords_add(mcposasg30, mctc2);
  mctc1 = coords_sub(mcposaMon_D11_Out, mcposaAlWindow13);
  mcposrAlWindow13 = rot_apply(mcrotaAlWindow13, mctc1);
  mcDEBUG_COMPONENT("AlWindow13", mcposaAlWindow13, mcrotaAlWindow13)
  mccomp_posa[82] = mcposaAlWindow13;
  mccomp_posr[82] = mcposrAlWindow13;
  mcNCounter[82]  = mcPCounter[82] = mcP2Counter[82] = 0;
  mcAbsorbProp[82]= 0;
    /* Component MovableGuideStart. */
  /* Setting parameters for component MovableGuideStart. */
  SIG_MESSAGE("MovableGuideStart (Init:SetPar)");

  SIG_MESSAGE("MovableGuideStart (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27419 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotasg30, mcrotaMovableGuideStart);
  rot_transpose(mcrotaAlWindow13, mctr1);
  rot_mul(mcrotaMovableGuideStart, mctr1, mcrotrMovableGuideStart);
  mctc1 = coords_set(
#line 671 "ILL_H15_D11.instr"
    0,
#line 671 "ILL_H15_D11.instr"
    0,
#line 671 "ILL_H15_D11.instr"
    0.66);
#line 27430 "ILL_H15_D11.c"
  rot_transpose(mcrotasg30, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaMovableGuideStart = coords_add(mcposasg30, mctc2);
  mctc1 = coords_sub(mcposaAlWindow13, mcposaMovableGuideStart);
  mcposrMovableGuideStart = rot_apply(mcrotaMovableGuideStart, mctc1);
  mcDEBUG_COMPONENT("MovableGuideStart", mcposaMovableGuideStart, mcrotaMovableGuideStart)
  mccomp_posa[83] = mcposaMovableGuideStart;
  mccomp_posr[83] = mcposrMovableGuideStart;
  mcNCounter[83]  = mcPCounter[83] = mcP2Counter[83] = 0;
  mcAbsorbProp[83]= 0;
    /* Component mg0. */
  /* Setting parameters for component mg0. */
  SIG_MESSAGE("mg0 (Init:SetPar)");
#line 711 "ILL_H15_D11.instr"
  mccmg0_w1 = gGuideWidth;
#line 711 "ILL_H15_D11.instr"
  mccmg0_h1 = gGuideHeight2;
#line 712 "ILL_H15_D11.instr"
  mccmg0_w2 = gGuideWidth;
#line 712 "ILL_H15_D11.instr"
  mccmg0_h2 = gGuideHeight2;
#line 713 "ILL_H15_D11.instr"
  mccmg0_l = ( Config_l [ 0 ] );
#line 114 "ILL_H15_D11.instr"
  mccmg0_R0 = 0.995;
#line 114 "ILL_H15_D11.instr"
  mccmg0_Qc = 0.0218;
#line 714 "ILL_H15_D11.instr"
  mccmg0_alpha = mAlpha;
#line 714 "ILL_H15_D11.instr"
  mccmg0_m = mGuide2;
#line 714 "ILL_H15_D11.instr"
  mccmg0_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccmg0_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccmg0_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccmg0_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg0_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg0_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg0_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg0_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccmg0_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccmg0_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg0_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg0_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg0_abottom = -1;
#line 714 "ILL_H15_D11.instr"
  mccmg0_wavy = mcipWaviness;
#line 117 "ILL_H15_D11.instr"
  mccmg0_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg0_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg0_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccmg0_chamfers = 0;
#line 713 "ILL_H15_D11.instr"
  mccmg0_chamfers_z = mcipChamfers;
#line 118 "ILL_H15_D11.instr"
  mccmg0_chamfers_lr = 0;
#line 713 "ILL_H15_D11.instr"
  mccmg0_chamfers_tb = mcipChamfers;
#line 713 "ILL_H15_D11.instr"
  mccmg0_nelements = Config_n [ 0 ];
#line 119 "ILL_H15_D11.instr"
  mccmg0_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccmg0_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccmg0_reflect, "NULL" ? "NULL" : "", 16384); else mccmg0_reflect[0]='\0';
#line 27512 "ILL_H15_D11.c"

  SIG_MESSAGE("mg0 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27519 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotaMovableGuideStart, mcrotamg0);
  rot_transpose(mcrotaMovableGuideStart, mctr1);
  rot_mul(mcrotamg0, mctr1, mcrotrmg0);
  mctc1 = coords_set(
#line 715 "ILL_H15_D11.instr"
    0,
#line 715 "ILL_H15_D11.instr"
    0,
#line 715 "ILL_H15_D11.instr"
    0);
#line 27530 "ILL_H15_D11.c"
  rot_transpose(mcrotaMovableGuideStart, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamg0 = coords_add(mcposaMovableGuideStart, mctc2);
  mctc1 = coords_sub(mcposaMovableGuideStart, mcposamg0);
  mcposrmg0 = rot_apply(mcrotamg0, mctc1);
  mcDEBUG_COMPONENT("mg0", mcposamg0, mcrotamg0)
  mccomp_posa[84] = mcposamg0;
  mccomp_posr[84] = mcposrmg0;
  mcNCounter[84]  = mcPCounter[84] = mcP2Counter[84] = 0;
  mcAbsorbProp[84]= 0;
    /* Component mg1. */
  /* Setting parameters for component mg1. */
  SIG_MESSAGE("mg1 (Init:SetPar)");
#line 717 "ILL_H15_D11.instr"
  mccmg1_w1 = gGuideWidth;
#line 717 "ILL_H15_D11.instr"
  mccmg1_h1 = gGuideHeight2;
#line 718 "ILL_H15_D11.instr"
  mccmg1_w2 = gGuideWidth;
#line 718 "ILL_H15_D11.instr"
  mccmg1_h2 = gGuideHeight2;
#line 719 "ILL_H15_D11.instr"
  mccmg1_l = ( Config_l [ 1 ] );
#line 114 "ILL_H15_D11.instr"
  mccmg1_R0 = 0.995;
#line 114 "ILL_H15_D11.instr"
  mccmg1_Qc = 0.0218;
#line 720 "ILL_H15_D11.instr"
  mccmg1_alpha = mAlpha;
#line 720 "ILL_H15_D11.instr"
  mccmg1_m = mGuide2;
#line 720 "ILL_H15_D11.instr"
  mccmg1_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccmg1_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccmg1_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccmg1_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg1_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg1_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg1_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg1_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccmg1_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccmg1_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg1_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg1_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg1_abottom = -1;
#line 720 "ILL_H15_D11.instr"
  mccmg1_wavy = mcipWaviness;
#line 117 "ILL_H15_D11.instr"
  mccmg1_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg1_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg1_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccmg1_chamfers = 0;
#line 719 "ILL_H15_D11.instr"
  mccmg1_chamfers_z = mcipChamfers;
#line 118 "ILL_H15_D11.instr"
  mccmg1_chamfers_lr = 0;
#line 719 "ILL_H15_D11.instr"
  mccmg1_chamfers_tb = mcipChamfers;
#line 719 "ILL_H15_D11.instr"
  mccmg1_nelements = ( Config_n [ 1 ] );
#line 119 "ILL_H15_D11.instr"
  mccmg1_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccmg1_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccmg1_reflect, "NULL" ? "NULL" : "", 16384); else mccmg1_reflect[0]='\0';
#line 27612 "ILL_H15_D11.c"

  SIG_MESSAGE("mg1 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27619 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotamg0, mcrotamg1);
  rot_transpose(mcrotamg0, mctr1);
  rot_mul(mcrotamg1, mctr1, mcrotrmg1);
  mctc1 = coords_set(
#line 721 "ILL_H15_D11.instr"
    0,
#line 721 "ILL_H15_D11.instr"
    0,
#line 721 "ILL_H15_D11.instr"
    ( microGap + Config_l [ 0 ] ));
#line 27630 "ILL_H15_D11.c"
  rot_transpose(mcrotamg0, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamg1 = coords_add(mcposamg0, mctc2);
  mctc1 = coords_sub(mcposamg0, mcposamg1);
  mcposrmg1 = rot_apply(mcrotamg1, mctc1);
  mcDEBUG_COMPONENT("mg1", mcposamg1, mcrotamg1)
  mccomp_posa[85] = mcposamg1;
  mccomp_posr[85] = mcposrmg1;
  mcNCounter[85]  = mcPCounter[85] = mcP2Counter[85] = 0;
  mcAbsorbProp[85]= 0;
    /* Component mg2. */
  /* Setting parameters for component mg2. */
  SIG_MESSAGE("mg2 (Init:SetPar)");
#line 723 "ILL_H15_D11.instr"
  mccmg2_w1 = gGuideWidth;
#line 723 "ILL_H15_D11.instr"
  mccmg2_h1 = gGuideHeight2;
#line 724 "ILL_H15_D11.instr"
  mccmg2_w2 = gGuideWidth;
#line 724 "ILL_H15_D11.instr"
  mccmg2_h2 = gGuideHeight2;
#line 725 "ILL_H15_D11.instr"
  mccmg2_l = ( Config_l [ 2 ] );
#line 114 "ILL_H15_D11.instr"
  mccmg2_R0 = 0.995;
#line 114 "ILL_H15_D11.instr"
  mccmg2_Qc = 0.0218;
#line 726 "ILL_H15_D11.instr"
  mccmg2_alpha = mAlpha;
#line 726 "ILL_H15_D11.instr"
  mccmg2_m = mGuide2;
#line 726 "ILL_H15_D11.instr"
  mccmg2_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccmg2_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccmg2_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccmg2_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg2_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg2_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg2_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg2_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccmg2_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccmg2_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg2_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg2_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg2_abottom = -1;
#line 726 "ILL_H15_D11.instr"
  mccmg2_wavy = mcipWaviness;
#line 117 "ILL_H15_D11.instr"
  mccmg2_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg2_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg2_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccmg2_chamfers = 0;
#line 725 "ILL_H15_D11.instr"
  mccmg2_chamfers_z = mcipChamfers;
#line 118 "ILL_H15_D11.instr"
  mccmg2_chamfers_lr = 0;
#line 725 "ILL_H15_D11.instr"
  mccmg2_chamfers_tb = mcipChamfers;
#line 725 "ILL_H15_D11.instr"
  mccmg2_nelements = ( Config_n [ 2 ] );
#line 119 "ILL_H15_D11.instr"
  mccmg2_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccmg2_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccmg2_reflect, "NULL" ? "NULL" : "", 16384); else mccmg2_reflect[0]='\0';
#line 27712 "ILL_H15_D11.c"

  SIG_MESSAGE("mg2 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27719 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotamg1, mcrotamg2);
  rot_transpose(mcrotamg1, mctr1);
  rot_mul(mcrotamg2, mctr1, mcrotrmg2);
  mctc1 = coords_set(
#line 727 "ILL_H15_D11.instr"
    0,
#line 727 "ILL_H15_D11.instr"
    0,
#line 727 "ILL_H15_D11.instr"
    ( microGap + Config_l [ 1 ] + Config_g [ 0 ] ));
#line 27730 "ILL_H15_D11.c"
  rot_transpose(mcrotamg1, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamg2 = coords_add(mcposamg1, mctc2);
  mctc1 = coords_sub(mcposamg1, mcposamg2);
  mcposrmg2 = rot_apply(mcrotamg2, mctc1);
  mcDEBUG_COMPONENT("mg2", mcposamg2, mcrotamg2)
  mccomp_posa[86] = mcposamg2;
  mccomp_posr[86] = mcposrmg2;
  mcNCounter[86]  = mcPCounter[86] = mcP2Counter[86] = 0;
  mcAbsorbProp[86]= 0;
    /* Component mg3. */
  /* Setting parameters for component mg3. */
  SIG_MESSAGE("mg3 (Init:SetPar)");
#line 729 "ILL_H15_D11.instr"
  mccmg3_w1 = gGuideWidth;
#line 729 "ILL_H15_D11.instr"
  mccmg3_h1 = gGuideHeight2;
#line 730 "ILL_H15_D11.instr"
  mccmg3_w2 = gGuideWidth;
#line 730 "ILL_H15_D11.instr"
  mccmg3_h2 = gGuideHeight2;
#line 731 "ILL_H15_D11.instr"
  mccmg3_l = ( Config_l [ 3 ] );
#line 114 "ILL_H15_D11.instr"
  mccmg3_R0 = 0.995;
#line 114 "ILL_H15_D11.instr"
  mccmg3_Qc = 0.0218;
#line 732 "ILL_H15_D11.instr"
  mccmg3_alpha = mAlpha;
#line 732 "ILL_H15_D11.instr"
  mccmg3_m = mGuide2;
#line 732 "ILL_H15_D11.instr"
  mccmg3_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccmg3_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccmg3_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccmg3_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg3_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg3_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg3_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg3_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccmg3_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccmg3_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg3_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg3_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg3_abottom = -1;
#line 732 "ILL_H15_D11.instr"
  mccmg3_wavy = mcipWaviness;
#line 117 "ILL_H15_D11.instr"
  mccmg3_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg3_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg3_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccmg3_chamfers = 0;
#line 731 "ILL_H15_D11.instr"
  mccmg3_chamfers_z = mcipChamfers;
#line 118 "ILL_H15_D11.instr"
  mccmg3_chamfers_lr = 0;
#line 731 "ILL_H15_D11.instr"
  mccmg3_chamfers_tb = mcipChamfers;
#line 731 "ILL_H15_D11.instr"
  mccmg3_nelements = ( Config_n [ 3 ] );
#line 119 "ILL_H15_D11.instr"
  mccmg3_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccmg3_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccmg3_reflect, "NULL" ? "NULL" : "", 16384); else mccmg3_reflect[0]='\0';
#line 27812 "ILL_H15_D11.c"

  SIG_MESSAGE("mg3 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27819 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotamg2, mcrotamg3);
  rot_transpose(mcrotamg2, mctr1);
  rot_mul(mcrotamg3, mctr1, mcrotrmg3);
  mctc1 = coords_set(
#line 733 "ILL_H15_D11.instr"
    0,
#line 733 "ILL_H15_D11.instr"
    0,
#line 733 "ILL_H15_D11.instr"
    ( microGap + Config_l [ 2 ] + Config_g [ 1 ] ));
#line 27830 "ILL_H15_D11.c"
  rot_transpose(mcrotamg2, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamg3 = coords_add(mcposamg2, mctc2);
  mctc1 = coords_sub(mcposamg2, mcposamg3);
  mcposrmg3 = rot_apply(mcrotamg3, mctc1);
  mcDEBUG_COMPONENT("mg3", mcposamg3, mcrotamg3)
  mccomp_posa[87] = mcposamg3;
  mccomp_posr[87] = mcposrmg3;
  mcNCounter[87]  = mcPCounter[87] = mcP2Counter[87] = 0;
  mcAbsorbProp[87]= 0;
    /* Component mg4. */
  /* Setting parameters for component mg4. */
  SIG_MESSAGE("mg4 (Init:SetPar)");
#line 735 "ILL_H15_D11.instr"
  mccmg4_w1 = gGuideWidth;
#line 735 "ILL_H15_D11.instr"
  mccmg4_h1 = gGuideHeight2;
#line 736 "ILL_H15_D11.instr"
  mccmg4_w2 = gGuideWidth;
#line 736 "ILL_H15_D11.instr"
  mccmg4_h2 = gGuideHeight2;
#line 737 "ILL_H15_D11.instr"
  mccmg4_l = ( Config_l [ 4 ] );
#line 114 "ILL_H15_D11.instr"
  mccmg4_R0 = 0.995;
#line 114 "ILL_H15_D11.instr"
  mccmg4_Qc = 0.0218;
#line 738 "ILL_H15_D11.instr"
  mccmg4_alpha = mAlpha;
#line 738 "ILL_H15_D11.instr"
  mccmg4_m = mGuide2;
#line 738 "ILL_H15_D11.instr"
  mccmg4_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccmg4_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccmg4_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccmg4_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg4_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg4_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg4_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg4_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccmg4_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccmg4_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg4_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg4_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg4_abottom = -1;
#line 738 "ILL_H15_D11.instr"
  mccmg4_wavy = mcipWaviness;
#line 117 "ILL_H15_D11.instr"
  mccmg4_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg4_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg4_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccmg4_chamfers = 0;
#line 737 "ILL_H15_D11.instr"
  mccmg4_chamfers_z = mcipChamfers;
#line 118 "ILL_H15_D11.instr"
  mccmg4_chamfers_lr = 0;
#line 737 "ILL_H15_D11.instr"
  mccmg4_chamfers_tb = mcipChamfers;
#line 737 "ILL_H15_D11.instr"
  mccmg4_nelements = ( Config_n [ 4 ] );
#line 119 "ILL_H15_D11.instr"
  mccmg4_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccmg4_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccmg4_reflect, "NULL" ? "NULL" : "", 16384); else mccmg4_reflect[0]='\0';
#line 27912 "ILL_H15_D11.c"

  SIG_MESSAGE("mg4 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 27919 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotamg3, mcrotamg4);
  rot_transpose(mcrotamg3, mctr1);
  rot_mul(mcrotamg4, mctr1, mcrotrmg4);
  mctc1 = coords_set(
#line 739 "ILL_H15_D11.instr"
    0,
#line 739 "ILL_H15_D11.instr"
    0,
#line 739 "ILL_H15_D11.instr"
    ( microGap + Config_l [ 3 ] ));
#line 27930 "ILL_H15_D11.c"
  rot_transpose(mcrotamg3, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamg4 = coords_add(mcposamg3, mctc2);
  mctc1 = coords_sub(mcposamg3, mcposamg4);
  mcposrmg4 = rot_apply(mcrotamg4, mctc1);
  mcDEBUG_COMPONENT("mg4", mcposamg4, mcrotamg4)
  mccomp_posa[88] = mcposamg4;
  mccomp_posr[88] = mcposrmg4;
  mcNCounter[88]  = mcPCounter[88] = mcP2Counter[88] = 0;
  mcAbsorbProp[88]= 0;
    /* Component mg5. */
  /* Setting parameters for component mg5. */
  SIG_MESSAGE("mg5 (Init:SetPar)");
#line 743 "ILL_H15_D11.instr"
  mccmg5_w1 = gGuideWidth;
#line 743 "ILL_H15_D11.instr"
  mccmg5_h1 = gGuideHeight2;
#line 744 "ILL_H15_D11.instr"
  mccmg5_w2 = gGuideWidth;
#line 744 "ILL_H15_D11.instr"
  mccmg5_h2 = gGuideHeight2;
#line 745 "ILL_H15_D11.instr"
  mccmg5_l = ( Config_l [ 5 ] );
#line 114 "ILL_H15_D11.instr"
  mccmg5_R0 = 0.995;
#line 114 "ILL_H15_D11.instr"
  mccmg5_Qc = 0.0218;
#line 746 "ILL_H15_D11.instr"
  mccmg5_alpha = mAlpha;
#line 746 "ILL_H15_D11.instr"
  mccmg5_m = mGuide2;
#line 746 "ILL_H15_D11.instr"
  mccmg5_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccmg5_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccmg5_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccmg5_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg5_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg5_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg5_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg5_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccmg5_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccmg5_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg5_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg5_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg5_abottom = -1;
#line 746 "ILL_H15_D11.instr"
  mccmg5_wavy = mcipWaviness;
#line 117 "ILL_H15_D11.instr"
  mccmg5_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg5_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg5_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccmg5_chamfers = 0;
#line 745 "ILL_H15_D11.instr"
  mccmg5_chamfers_z = mcipChamfers;
#line 118 "ILL_H15_D11.instr"
  mccmg5_chamfers_lr = 0;
#line 745 "ILL_H15_D11.instr"
  mccmg5_chamfers_tb = mcipChamfers;
#line 745 "ILL_H15_D11.instr"
  mccmg5_nelements = ( Config_n [ 5 ] );
#line 119 "ILL_H15_D11.instr"
  mccmg5_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccmg5_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccmg5_reflect, "NULL" ? "NULL" : "", 16384); else mccmg5_reflect[0]='\0';
#line 28012 "ILL_H15_D11.c"

  SIG_MESSAGE("mg5 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28019 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotamg4, mcrotamg5);
  rot_transpose(mcrotamg4, mctr1);
  rot_mul(mcrotamg5, mctr1, mcrotrmg5);
  mctc1 = coords_set(
#line 747 "ILL_H15_D11.instr"
    0,
#line 747 "ILL_H15_D11.instr"
    0,
#line 747 "ILL_H15_D11.instr"
    ( microGap + Config_l [ 4 ] + 0.017 ));
#line 28030 "ILL_H15_D11.c"
  rot_transpose(mcrotamg4, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamg5 = coords_add(mcposamg4, mctc2);
  mctc1 = coords_sub(mcposamg4, mcposamg5);
  mcposrmg5 = rot_apply(mcrotamg5, mctc1);
  mcDEBUG_COMPONENT("mg5", mcposamg5, mcrotamg5)
  mccomp_posa[89] = mcposamg5;
  mccomp_posr[89] = mcposrmg5;
  mcNCounter[89]  = mcPCounter[89] = mcP2Counter[89] = 0;
  mcAbsorbProp[89]= 0;
    /* Component mg6. */
  /* Setting parameters for component mg6. */
  SIG_MESSAGE("mg6 (Init:SetPar)");
#line 749 "ILL_H15_D11.instr"
  mccmg6_w1 = gGuideWidth;
#line 749 "ILL_H15_D11.instr"
  mccmg6_h1 = gGuideHeight2;
#line 750 "ILL_H15_D11.instr"
  mccmg6_w2 = gGuideWidth;
#line 750 "ILL_H15_D11.instr"
  mccmg6_h2 = gGuideHeight2;
#line 751 "ILL_H15_D11.instr"
  mccmg6_l = ( Config_l [ 6 ] );
#line 114 "ILL_H15_D11.instr"
  mccmg6_R0 = 0.995;
#line 114 "ILL_H15_D11.instr"
  mccmg6_Qc = 0.0218;
#line 752 "ILL_H15_D11.instr"
  mccmg6_alpha = mAlpha;
#line 752 "ILL_H15_D11.instr"
  mccmg6_m = mGuide2;
#line 752 "ILL_H15_D11.instr"
  mccmg6_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccmg6_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccmg6_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccmg6_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg6_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg6_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg6_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg6_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccmg6_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccmg6_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg6_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg6_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg6_abottom = -1;
#line 752 "ILL_H15_D11.instr"
  mccmg6_wavy = mcipWaviness;
#line 117 "ILL_H15_D11.instr"
  mccmg6_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg6_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg6_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccmg6_chamfers = 0;
#line 751 "ILL_H15_D11.instr"
  mccmg6_chamfers_z = mcipChamfers;
#line 118 "ILL_H15_D11.instr"
  mccmg6_chamfers_lr = 0;
#line 751 "ILL_H15_D11.instr"
  mccmg6_chamfers_tb = mcipChamfers;
#line 751 "ILL_H15_D11.instr"
  mccmg6_nelements = ( Config_n [ 6 ] );
#line 119 "ILL_H15_D11.instr"
  mccmg6_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccmg6_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccmg6_reflect, "NULL" ? "NULL" : "", 16384); else mccmg6_reflect[0]='\0';
#line 28112 "ILL_H15_D11.c"

  SIG_MESSAGE("mg6 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28119 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotamg5, mcrotamg6);
  rot_transpose(mcrotamg5, mctr1);
  rot_mul(mcrotamg6, mctr1, mcrotrmg6);
  mctc1 = coords_set(
#line 753 "ILL_H15_D11.instr"
    0,
#line 753 "ILL_H15_D11.instr"
    0,
#line 753 "ILL_H15_D11.instr"
    ( microGap + Config_l [ 5 ] + 0.002 ));
#line 28130 "ILL_H15_D11.c"
  rot_transpose(mcrotamg5, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamg6 = coords_add(mcposamg5, mctc2);
  mctc1 = coords_sub(mcposamg5, mcposamg6);
  mcposrmg6 = rot_apply(mcrotamg6, mctc1);
  mcDEBUG_COMPONENT("mg6", mcposamg6, mcrotamg6)
  mccomp_posa[90] = mcposamg6;
  mccomp_posr[90] = mcposrmg6;
  mcNCounter[90]  = mcPCounter[90] = mcP2Counter[90] = 0;
  mcAbsorbProp[90]= 0;
    /* Component mg7. */
  /* Setting parameters for component mg7. */
  SIG_MESSAGE("mg7 (Init:SetPar)");
#line 755 "ILL_H15_D11.instr"
  mccmg7_w1 = gGuideWidth;
#line 755 "ILL_H15_D11.instr"
  mccmg7_h1 = gGuideHeight2;
#line 756 "ILL_H15_D11.instr"
  mccmg7_w2 = gGuideWidth;
#line 756 "ILL_H15_D11.instr"
  mccmg7_h2 = gGuideHeight2;
#line 757 "ILL_H15_D11.instr"
  mccmg7_l = ( Config_l [ 7 ] );
#line 114 "ILL_H15_D11.instr"
  mccmg7_R0 = 0.995;
#line 114 "ILL_H15_D11.instr"
  mccmg7_Qc = 0.0218;
#line 758 "ILL_H15_D11.instr"
  mccmg7_alpha = mAlpha;
#line 758 "ILL_H15_D11.instr"
  mccmg7_m = mGuide2;
#line 758 "ILL_H15_D11.instr"
  mccmg7_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccmg7_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccmg7_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccmg7_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg7_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg7_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg7_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg7_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccmg7_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccmg7_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg7_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg7_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg7_abottom = -1;
#line 758 "ILL_H15_D11.instr"
  mccmg7_wavy = mcipWaviness;
#line 117 "ILL_H15_D11.instr"
  mccmg7_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg7_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg7_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccmg7_chamfers = 0;
#line 757 "ILL_H15_D11.instr"
  mccmg7_chamfers_z = mcipChamfers;
#line 118 "ILL_H15_D11.instr"
  mccmg7_chamfers_lr = 0;
#line 757 "ILL_H15_D11.instr"
  mccmg7_chamfers_tb = mcipChamfers;
#line 757 "ILL_H15_D11.instr"
  mccmg7_nelements = ( Config_n [ 7 ] );
#line 119 "ILL_H15_D11.instr"
  mccmg7_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccmg7_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccmg7_reflect, "NULL" ? "NULL" : "", 16384); else mccmg7_reflect[0]='\0';
#line 28212 "ILL_H15_D11.c"

  SIG_MESSAGE("mg7 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28219 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotamg6, mcrotamg7);
  rot_transpose(mcrotamg6, mctr1);
  rot_mul(mcrotamg7, mctr1, mcrotrmg7);
  mctc1 = coords_set(
#line 759 "ILL_H15_D11.instr"
    0,
#line 759 "ILL_H15_D11.instr"
    0,
#line 759 "ILL_H15_D11.instr"
    ( microGap + Config_l [ 6 ] + 0.002 ));
#line 28230 "ILL_H15_D11.c"
  rot_transpose(mcrotamg6, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamg7 = coords_add(mcposamg6, mctc2);
  mctc1 = coords_sub(mcposamg6, mcposamg7);
  mcposrmg7 = rot_apply(mcrotamg7, mctc1);
  mcDEBUG_COMPONENT("mg7", mcposamg7, mcrotamg7)
  mccomp_posa[91] = mcposamg7;
  mccomp_posr[91] = mcposrmg7;
  mcNCounter[91]  = mcPCounter[91] = mcP2Counter[91] = 0;
  mcAbsorbProp[91]= 0;
    /* Component mg8. */
  /* Setting parameters for component mg8. */
  SIG_MESSAGE("mg8 (Init:SetPar)");
#line 761 "ILL_H15_D11.instr"
  mccmg8_w1 = gGuideWidth;
#line 761 "ILL_H15_D11.instr"
  mccmg8_h1 = gGuideHeight2;
#line 762 "ILL_H15_D11.instr"
  mccmg8_w2 = gGuideWidth;
#line 762 "ILL_H15_D11.instr"
  mccmg8_h2 = gGuideHeight2;
#line 763 "ILL_H15_D11.instr"
  mccmg8_l = ( Config_l [ 8 ] );
#line 114 "ILL_H15_D11.instr"
  mccmg8_R0 = 0.995;
#line 114 "ILL_H15_D11.instr"
  mccmg8_Qc = 0.0218;
#line 764 "ILL_H15_D11.instr"
  mccmg8_alpha = mAlpha;
#line 764 "ILL_H15_D11.instr"
  mccmg8_m = mGuide2;
#line 764 "ILL_H15_D11.instr"
  mccmg8_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccmg8_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccmg8_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccmg8_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg8_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg8_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg8_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg8_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccmg8_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccmg8_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg8_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg8_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg8_abottom = -1;
#line 764 "ILL_H15_D11.instr"
  mccmg8_wavy = mcipWaviness;
#line 117 "ILL_H15_D11.instr"
  mccmg8_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg8_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg8_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccmg8_chamfers = 0;
#line 763 "ILL_H15_D11.instr"
  mccmg8_chamfers_z = mcipChamfers;
#line 118 "ILL_H15_D11.instr"
  mccmg8_chamfers_lr = 0;
#line 763 "ILL_H15_D11.instr"
  mccmg8_chamfers_tb = mcipChamfers;
#line 763 "ILL_H15_D11.instr"
  mccmg8_nelements = ( Config_n [ 8 ] );
#line 119 "ILL_H15_D11.instr"
  mccmg8_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccmg8_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccmg8_reflect, "NULL" ? "NULL" : "", 16384); else mccmg8_reflect[0]='\0';
#line 28312 "ILL_H15_D11.c"

  SIG_MESSAGE("mg8 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28319 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotamg7, mcrotamg8);
  rot_transpose(mcrotamg7, mctr1);
  rot_mul(mcrotamg8, mctr1, mcrotrmg8);
  mctc1 = coords_set(
#line 765 "ILL_H15_D11.instr"
    0,
#line 765 "ILL_H15_D11.instr"
    0,
#line 765 "ILL_H15_D11.instr"
    ( microGap + Config_l [ 7 ] + 0.017 ));
#line 28330 "ILL_H15_D11.c"
  rot_transpose(mcrotamg7, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamg8 = coords_add(mcposamg7, mctc2);
  mctc1 = coords_sub(mcposamg7, mcposamg8);
  mcposrmg8 = rot_apply(mcrotamg8, mctc1);
  mcDEBUG_COMPONENT("mg8", mcposamg8, mcrotamg8)
  mccomp_posa[92] = mcposamg8;
  mccomp_posr[92] = mcposrmg8;
  mcNCounter[92]  = mcPCounter[92] = mcP2Counter[92] = 0;
  mcAbsorbProp[92]= 0;
    /* Component mg9. */
  /* Setting parameters for component mg9. */
  SIG_MESSAGE("mg9 (Init:SetPar)");
#line 767 "ILL_H15_D11.instr"
  mccmg9_w1 = gGuideWidth;
#line 767 "ILL_H15_D11.instr"
  mccmg9_h1 = gGuideHeight2;
#line 768 "ILL_H15_D11.instr"
  mccmg9_w2 = gGuideWidth;
#line 768 "ILL_H15_D11.instr"
  mccmg9_h2 = gGuideHeight2;
#line 769 "ILL_H15_D11.instr"
  mccmg9_l = ( Config_l [ 9 ] );
#line 114 "ILL_H15_D11.instr"
  mccmg9_R0 = 0.995;
#line 114 "ILL_H15_D11.instr"
  mccmg9_Qc = 0.0218;
#line 770 "ILL_H15_D11.instr"
  mccmg9_alpha = mAlpha;
#line 770 "ILL_H15_D11.instr"
  mccmg9_m = mGuide2;
#line 770 "ILL_H15_D11.instr"
  mccmg9_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccmg9_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccmg9_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccmg9_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg9_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg9_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg9_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg9_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccmg9_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccmg9_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg9_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg9_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg9_abottom = -1;
#line 770 "ILL_H15_D11.instr"
  mccmg9_wavy = mcipWaviness;
#line 117 "ILL_H15_D11.instr"
  mccmg9_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg9_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg9_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccmg9_chamfers = 0;
#line 769 "ILL_H15_D11.instr"
  mccmg9_chamfers_z = mcipChamfers;
#line 118 "ILL_H15_D11.instr"
  mccmg9_chamfers_lr = 0;
#line 769 "ILL_H15_D11.instr"
  mccmg9_chamfers_tb = mcipChamfers;
#line 769 "ILL_H15_D11.instr"
  mccmg9_nelements = ( Config_n [ 9 ] );
#line 119 "ILL_H15_D11.instr"
  mccmg9_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccmg9_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccmg9_reflect, "NULL" ? "NULL" : "", 16384); else mccmg9_reflect[0]='\0';
#line 28412 "ILL_H15_D11.c"

  SIG_MESSAGE("mg9 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28419 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotamg8, mcrotamg9);
  rot_transpose(mcrotamg8, mctr1);
  rot_mul(mcrotamg9, mctr1, mcrotrmg9);
  mctc1 = coords_set(
#line 771 "ILL_H15_D11.instr"
    0,
#line 771 "ILL_H15_D11.instr"
    0,
#line 771 "ILL_H15_D11.instr"
    ( microGap + Config_l [ 8 ] ));
#line 28430 "ILL_H15_D11.c"
  rot_transpose(mcrotamg8, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamg9 = coords_add(mcposamg8, mctc2);
  mctc1 = coords_sub(mcposamg8, mcposamg9);
  mcposrmg9 = rot_apply(mcrotamg9, mctc1);
  mcDEBUG_COMPONENT("mg9", mcposamg9, mcrotamg9)
  mccomp_posa[93] = mcposamg9;
  mccomp_posr[93] = mcposrmg9;
  mcNCounter[93]  = mcPCounter[93] = mcP2Counter[93] = 0;
  mcAbsorbProp[93]= 0;
    /* Component mg10. */
  /* Setting parameters for component mg10. */
  SIG_MESSAGE("mg10 (Init:SetPar)");
#line 773 "ILL_H15_D11.instr"
  mccmg10_w1 = gGuideWidth;
#line 773 "ILL_H15_D11.instr"
  mccmg10_h1 = gGuideHeight2;
#line 774 "ILL_H15_D11.instr"
  mccmg10_w2 = gGuideWidth;
#line 774 "ILL_H15_D11.instr"
  mccmg10_h2 = gGuideHeight2;
#line 775 "ILL_H15_D11.instr"
  mccmg10_l = ( Config_l [ 10 ] );
#line 114 "ILL_H15_D11.instr"
  mccmg10_R0 = 0.995;
#line 114 "ILL_H15_D11.instr"
  mccmg10_Qc = 0.0218;
#line 776 "ILL_H15_D11.instr"
  mccmg10_alpha = mAlpha;
#line 776 "ILL_H15_D11.instr"
  mccmg10_m = mGuide2;
#line 776 "ILL_H15_D11.instr"
  mccmg10_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccmg10_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccmg10_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccmg10_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg10_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg10_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg10_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg10_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccmg10_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccmg10_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg10_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg10_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg10_abottom = -1;
#line 776 "ILL_H15_D11.instr"
  mccmg10_wavy = mcipWaviness;
#line 117 "ILL_H15_D11.instr"
  mccmg10_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg10_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg10_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccmg10_chamfers = 0;
#line 775 "ILL_H15_D11.instr"
  mccmg10_chamfers_z = mcipChamfers;
#line 118 "ILL_H15_D11.instr"
  mccmg10_chamfers_lr = 0;
#line 775 "ILL_H15_D11.instr"
  mccmg10_chamfers_tb = mcipChamfers;
#line 775 "ILL_H15_D11.instr"
  mccmg10_nelements = ( Config_n [ 10 ] );
#line 119 "ILL_H15_D11.instr"
  mccmg10_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccmg10_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccmg10_reflect, "NULL" ? "NULL" : "", 16384); else mccmg10_reflect[0]='\0';
#line 28512 "ILL_H15_D11.c"

  SIG_MESSAGE("mg10 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28519 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotamg9, mcrotamg10);
  rot_transpose(mcrotamg9, mctr1);
  rot_mul(mcrotamg10, mctr1, mcrotrmg10);
  mctc1 = coords_set(
#line 777 "ILL_H15_D11.instr"
    0,
#line 777 "ILL_H15_D11.instr"
    0,
#line 777 "ILL_H15_D11.instr"
    ( microGap + Config_l [ 9 ] + 0.002 ));
#line 28530 "ILL_H15_D11.c"
  rot_transpose(mcrotamg9, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamg10 = coords_add(mcposamg9, mctc2);
  mctc1 = coords_sub(mcposamg9, mcposamg10);
  mcposrmg10 = rot_apply(mcrotamg10, mctc1);
  mcDEBUG_COMPONENT("mg10", mcposamg10, mcrotamg10)
  mccomp_posa[94] = mcposamg10;
  mccomp_posr[94] = mcposrmg10;
  mcNCounter[94]  = mcPCounter[94] = mcP2Counter[94] = 0;
  mcAbsorbProp[94]= 0;
    /* Component mg11. */
  /* Setting parameters for component mg11. */
  SIG_MESSAGE("mg11 (Init:SetPar)");
#line 779 "ILL_H15_D11.instr"
  mccmg11_w1 = gGuideWidth;
#line 779 "ILL_H15_D11.instr"
  mccmg11_h1 = gGuideHeight2;
#line 780 "ILL_H15_D11.instr"
  mccmg11_w2 = gGuideWidth;
#line 780 "ILL_H15_D11.instr"
  mccmg11_h2 = gGuideHeight2;
#line 781 "ILL_H15_D11.instr"
  mccmg11_l = ( Config_l [ 11 ] );
#line 114 "ILL_H15_D11.instr"
  mccmg11_R0 = 0.995;
#line 114 "ILL_H15_D11.instr"
  mccmg11_Qc = 0.0218;
#line 782 "ILL_H15_D11.instr"
  mccmg11_alpha = mAlpha;
#line 782 "ILL_H15_D11.instr"
  mccmg11_m = mGuide2;
#line 782 "ILL_H15_D11.instr"
  mccmg11_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccmg11_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccmg11_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccmg11_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg11_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg11_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg11_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg11_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccmg11_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccmg11_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg11_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg11_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg11_abottom = -1;
#line 782 "ILL_H15_D11.instr"
  mccmg11_wavy = mcipWaviness;
#line 117 "ILL_H15_D11.instr"
  mccmg11_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg11_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg11_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccmg11_chamfers = 0;
#line 781 "ILL_H15_D11.instr"
  mccmg11_chamfers_z = mcipChamfers;
#line 118 "ILL_H15_D11.instr"
  mccmg11_chamfers_lr = 0;
#line 781 "ILL_H15_D11.instr"
  mccmg11_chamfers_tb = mcipChamfers;
#line 781 "ILL_H15_D11.instr"
  mccmg11_nelements = ( Config_n [ 11 ] );
#line 119 "ILL_H15_D11.instr"
  mccmg11_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccmg11_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccmg11_reflect, "NULL" ? "NULL" : "", 16384); else mccmg11_reflect[0]='\0';
#line 28612 "ILL_H15_D11.c"

  SIG_MESSAGE("mg11 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28619 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotamg10, mcrotamg11);
  rot_transpose(mcrotamg10, mctr1);
  rot_mul(mcrotamg11, mctr1, mcrotrmg11);
  mctc1 = coords_set(
#line 783 "ILL_H15_D11.instr"
    0,
#line 783 "ILL_H15_D11.instr"
    0,
#line 783 "ILL_H15_D11.instr"
    ( microGap + Config_l [ 10 ] ));
#line 28630 "ILL_H15_D11.c"
  rot_transpose(mcrotamg10, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamg11 = coords_add(mcposamg10, mctc2);
  mctc1 = coords_sub(mcposamg10, mcposamg11);
  mcposrmg11 = rot_apply(mcrotamg11, mctc1);
  mcDEBUG_COMPONENT("mg11", mcposamg11, mcrotamg11)
  mccomp_posa[95] = mcposamg11;
  mccomp_posr[95] = mcposrmg11;
  mcNCounter[95]  = mcPCounter[95] = mcP2Counter[95] = 0;
  mcAbsorbProp[95]= 0;
    /* Component mg12. */
  /* Setting parameters for component mg12. */
  SIG_MESSAGE("mg12 (Init:SetPar)");
#line 785 "ILL_H15_D11.instr"
  mccmg12_w1 = gGuideWidth;
#line 785 "ILL_H15_D11.instr"
  mccmg12_h1 = gGuideHeight2;
#line 786 "ILL_H15_D11.instr"
  mccmg12_w2 = gGuideWidth;
#line 786 "ILL_H15_D11.instr"
  mccmg12_h2 = gGuideHeight2;
#line 787 "ILL_H15_D11.instr"
  mccmg12_l = ( Config_l [ 12 ] );
#line 114 "ILL_H15_D11.instr"
  mccmg12_R0 = 0.995;
#line 114 "ILL_H15_D11.instr"
  mccmg12_Qc = 0.0218;
#line 788 "ILL_H15_D11.instr"
  mccmg12_alpha = mAlpha;
#line 788 "ILL_H15_D11.instr"
  mccmg12_m = mGuide2;
#line 788 "ILL_H15_D11.instr"
  mccmg12_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccmg12_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccmg12_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccmg12_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg12_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg12_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg12_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg12_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccmg12_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccmg12_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg12_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg12_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg12_abottom = -1;
#line 788 "ILL_H15_D11.instr"
  mccmg12_wavy = mcipWaviness;
#line 117 "ILL_H15_D11.instr"
  mccmg12_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg12_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg12_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccmg12_chamfers = 0;
#line 787 "ILL_H15_D11.instr"
  mccmg12_chamfers_z = mcipChamfers;
#line 118 "ILL_H15_D11.instr"
  mccmg12_chamfers_lr = 0;
#line 787 "ILL_H15_D11.instr"
  mccmg12_chamfers_tb = mcipChamfers;
#line 787 "ILL_H15_D11.instr"
  mccmg12_nelements = ( Config_n [ 12 ] );
#line 119 "ILL_H15_D11.instr"
  mccmg12_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccmg12_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccmg12_reflect, "NULL" ? "NULL" : "", 16384); else mccmg12_reflect[0]='\0';
#line 28712 "ILL_H15_D11.c"

  SIG_MESSAGE("mg12 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28719 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotamg11, mcrotamg12);
  rot_transpose(mcrotamg11, mctr1);
  rot_mul(mcrotamg12, mctr1, mcrotrmg12);
  mctc1 = coords_set(
#line 789 "ILL_H15_D11.instr"
    0,
#line 789 "ILL_H15_D11.instr"
    0,
#line 789 "ILL_H15_D11.instr"
    ( microGap + Config_l [ 11 ] + 0.017 ));
#line 28730 "ILL_H15_D11.c"
  rot_transpose(mcrotamg11, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamg12 = coords_add(mcposamg11, mctc2);
  mctc1 = coords_sub(mcposamg11, mcposamg12);
  mcposrmg12 = rot_apply(mcrotamg12, mctc1);
  mcDEBUG_COMPONENT("mg12", mcposamg12, mcrotamg12)
  mccomp_posa[96] = mcposamg12;
  mccomp_posr[96] = mcposrmg12;
  mcNCounter[96]  = mcPCounter[96] = mcP2Counter[96] = 0;
  mcAbsorbProp[96]= 0;
    /* Component mg13. */
  /* Setting parameters for component mg13. */
  SIG_MESSAGE("mg13 (Init:SetPar)");
#line 791 "ILL_H15_D11.instr"
  mccmg13_w1 = gGuideWidth;
#line 791 "ILL_H15_D11.instr"
  mccmg13_h1 = gGuideHeight2;
#line 792 "ILL_H15_D11.instr"
  mccmg13_w2 = gGuideWidth;
#line 792 "ILL_H15_D11.instr"
  mccmg13_h2 = gGuideHeight2;
#line 793 "ILL_H15_D11.instr"
  mccmg13_l = ( Config_l [ 13 ] );
#line 114 "ILL_H15_D11.instr"
  mccmg13_R0 = 0.995;
#line 114 "ILL_H15_D11.instr"
  mccmg13_Qc = 0.0218;
#line 794 "ILL_H15_D11.instr"
  mccmg13_alpha = mAlpha;
#line 794 "ILL_H15_D11.instr"
  mccmg13_m = mGuide2;
#line 794 "ILL_H15_D11.instr"
  mccmg13_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccmg13_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccmg13_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccmg13_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg13_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg13_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg13_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg13_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccmg13_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccmg13_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg13_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg13_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg13_abottom = -1;
#line 794 "ILL_H15_D11.instr"
  mccmg13_wavy = mcipWaviness;
#line 117 "ILL_H15_D11.instr"
  mccmg13_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg13_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg13_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccmg13_chamfers = 0;
#line 793 "ILL_H15_D11.instr"
  mccmg13_chamfers_z = mcipChamfers;
#line 118 "ILL_H15_D11.instr"
  mccmg13_chamfers_lr = 0;
#line 793 "ILL_H15_D11.instr"
  mccmg13_chamfers_tb = mcipChamfers;
#line 793 "ILL_H15_D11.instr"
  mccmg13_nelements = ( Config_n [ 13 ] );
#line 119 "ILL_H15_D11.instr"
  mccmg13_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccmg13_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccmg13_reflect, "NULL" ? "NULL" : "", 16384); else mccmg13_reflect[0]='\0';
#line 28812 "ILL_H15_D11.c"

  SIG_MESSAGE("mg13 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28819 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotamg12, mcrotamg13);
  rot_transpose(mcrotamg12, mctr1);
  rot_mul(mcrotamg13, mctr1, mcrotrmg13);
  mctc1 = coords_set(
#line 795 "ILL_H15_D11.instr"
    0,
#line 795 "ILL_H15_D11.instr"
    0,
#line 795 "ILL_H15_D11.instr"
    ( microGap + Config_l [ 12 ] ));
#line 28830 "ILL_H15_D11.c"
  rot_transpose(mcrotamg12, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamg13 = coords_add(mcposamg12, mctc2);
  mctc1 = coords_sub(mcposamg12, mcposamg13);
  mcposrmg13 = rot_apply(mcrotamg13, mctc1);
  mcDEBUG_COMPONENT("mg13", mcposamg13, mcrotamg13)
  mccomp_posa[97] = mcposamg13;
  mccomp_posr[97] = mcposrmg13;
  mcNCounter[97]  = mcPCounter[97] = mcP2Counter[97] = 0;
  mcAbsorbProp[97]= 0;
    /* Component mg14. */
  /* Setting parameters for component mg14. */
  SIG_MESSAGE("mg14 (Init:SetPar)");
#line 797 "ILL_H15_D11.instr"
  mccmg14_w1 = gGuideWidth;
#line 797 "ILL_H15_D11.instr"
  mccmg14_h1 = gGuideHeight2;
#line 798 "ILL_H15_D11.instr"
  mccmg14_w2 = gGuideWidth;
#line 798 "ILL_H15_D11.instr"
  mccmg14_h2 = gGuideHeight2;
#line 799 "ILL_H15_D11.instr"
  mccmg14_l = ( Config_l [ 14 ] );
#line 114 "ILL_H15_D11.instr"
  mccmg14_R0 = 0.995;
#line 114 "ILL_H15_D11.instr"
  mccmg14_Qc = 0.0218;
#line 800 "ILL_H15_D11.instr"
  mccmg14_alpha = mAlpha;
#line 800 "ILL_H15_D11.instr"
  mccmg14_m = mGuide2;
#line 800 "ILL_H15_D11.instr"
  mccmg14_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccmg14_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccmg14_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccmg14_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg14_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg14_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg14_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg14_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccmg14_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccmg14_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg14_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg14_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg14_abottom = -1;
#line 800 "ILL_H15_D11.instr"
  mccmg14_wavy = mcipWaviness;
#line 117 "ILL_H15_D11.instr"
  mccmg14_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg14_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg14_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccmg14_chamfers = 0;
#line 799 "ILL_H15_D11.instr"
  mccmg14_chamfers_z = mcipChamfers;
#line 118 "ILL_H15_D11.instr"
  mccmg14_chamfers_lr = 0;
#line 799 "ILL_H15_D11.instr"
  mccmg14_chamfers_tb = mcipChamfers;
#line 799 "ILL_H15_D11.instr"
  mccmg14_nelements = ( Config_n [ 14 ] );
#line 119 "ILL_H15_D11.instr"
  mccmg14_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccmg14_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccmg14_reflect, "NULL" ? "NULL" : "", 16384); else mccmg14_reflect[0]='\0';
#line 28912 "ILL_H15_D11.c"

  SIG_MESSAGE("mg14 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 28919 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotamg13, mcrotamg14);
  rot_transpose(mcrotamg13, mctr1);
  rot_mul(mcrotamg14, mctr1, mcrotrmg14);
  mctc1 = coords_set(
#line 801 "ILL_H15_D11.instr"
    0,
#line 801 "ILL_H15_D11.instr"
    0,
#line 801 "ILL_H15_D11.instr"
    ( microGap + Config_l [ 13 ] + 0.002 ));
#line 28930 "ILL_H15_D11.c"
  rot_transpose(mcrotamg13, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamg14 = coords_add(mcposamg13, mctc2);
  mctc1 = coords_sub(mcposamg13, mcposamg14);
  mcposrmg14 = rot_apply(mcrotamg14, mctc1);
  mcDEBUG_COMPONENT("mg14", mcposamg14, mcrotamg14)
  mccomp_posa[98] = mcposamg14;
  mccomp_posr[98] = mcposrmg14;
  mcNCounter[98]  = mcPCounter[98] = mcP2Counter[98] = 0;
  mcAbsorbProp[98]= 0;
    /* Component mg15. */
  /* Setting parameters for component mg15. */
  SIG_MESSAGE("mg15 (Init:SetPar)");
#line 803 "ILL_H15_D11.instr"
  mccmg15_w1 = gGuideWidth;
#line 803 "ILL_H15_D11.instr"
  mccmg15_h1 = gGuideHeight2;
#line 804 "ILL_H15_D11.instr"
  mccmg15_w2 = gGuideWidth;
#line 804 "ILL_H15_D11.instr"
  mccmg15_h2 = gGuideHeight2;
#line 805 "ILL_H15_D11.instr"
  mccmg15_l = ( Config_l [ 15 ] );
#line 114 "ILL_H15_D11.instr"
  mccmg15_R0 = 0.995;
#line 114 "ILL_H15_D11.instr"
  mccmg15_Qc = 0.0218;
#line 806 "ILL_H15_D11.instr"
  mccmg15_alpha = mAlpha;
#line 806 "ILL_H15_D11.instr"
  mccmg15_m = mGuide2;
#line 806 "ILL_H15_D11.instr"
  mccmg15_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccmg15_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccmg15_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccmg15_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg15_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg15_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg15_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg15_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccmg15_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccmg15_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg15_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg15_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg15_abottom = -1;
#line 806 "ILL_H15_D11.instr"
  mccmg15_wavy = mcipWaviness;
#line 117 "ILL_H15_D11.instr"
  mccmg15_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg15_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg15_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccmg15_chamfers = 0;
#line 805 "ILL_H15_D11.instr"
  mccmg15_chamfers_z = mcipChamfers;
#line 118 "ILL_H15_D11.instr"
  mccmg15_chamfers_lr = 0;
#line 805 "ILL_H15_D11.instr"
  mccmg15_chamfers_tb = mcipChamfers;
#line 805 "ILL_H15_D11.instr"
  mccmg15_nelements = ( Config_n [ 15 ] );
#line 119 "ILL_H15_D11.instr"
  mccmg15_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccmg15_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccmg15_reflect, "NULL" ? "NULL" : "", 16384); else mccmg15_reflect[0]='\0';
#line 29012 "ILL_H15_D11.c"

  SIG_MESSAGE("mg15 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29019 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotamg14, mcrotamg15);
  rot_transpose(mcrotamg14, mctr1);
  rot_mul(mcrotamg15, mctr1, mcrotrmg15);
  mctc1 = coords_set(
#line 807 "ILL_H15_D11.instr"
    0,
#line 807 "ILL_H15_D11.instr"
    0,
#line 807 "ILL_H15_D11.instr"
    ( microGap + Config_l [ 14 ] ));
#line 29030 "ILL_H15_D11.c"
  rot_transpose(mcrotamg14, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamg15 = coords_add(mcposamg14, mctc2);
  mctc1 = coords_sub(mcposamg14, mcposamg15);
  mcposrmg15 = rot_apply(mcrotamg15, mctc1);
  mcDEBUG_COMPONENT("mg15", mcposamg15, mcrotamg15)
  mccomp_posa[99] = mcposamg15;
  mccomp_posr[99] = mcposrmg15;
  mcNCounter[99]  = mcPCounter[99] = mcP2Counter[99] = 0;
  mcAbsorbProp[99]= 0;
    /* Component mg16. */
  /* Setting parameters for component mg16. */
  SIG_MESSAGE("mg16 (Init:SetPar)");
#line 809 "ILL_H15_D11.instr"
  mccmg16_w1 = gGuideWidth;
#line 809 "ILL_H15_D11.instr"
  mccmg16_h1 = gGuideHeight2;
#line 810 "ILL_H15_D11.instr"
  mccmg16_w2 = gGuideWidth;
#line 810 "ILL_H15_D11.instr"
  mccmg16_h2 = gGuideHeight2;
#line 811 "ILL_H15_D11.instr"
  mccmg16_l = ( Config_l [ 16 ] );
#line 114 "ILL_H15_D11.instr"
  mccmg16_R0 = 0.995;
#line 114 "ILL_H15_D11.instr"
  mccmg16_Qc = 0.0218;
#line 812 "ILL_H15_D11.instr"
  mccmg16_alpha = mAlpha;
#line 812 "ILL_H15_D11.instr"
  mccmg16_m = mGuide2;
#line 812 "ILL_H15_D11.instr"
  mccmg16_W = mW;
#line 114 "ILL_H15_D11.instr"
  mccmg16_nslit = 1;
#line 114 "ILL_H15_D11.instr"
  mccmg16_d = 0.0005;
#line 115 "ILL_H15_D11.instr"
  mccmg16_mleft = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg16_mright = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg16_mtop = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg16_mbottom = -1;
#line 115 "ILL_H15_D11.instr"
  mccmg16_nhslit = 1;
#line 115 "ILL_H15_D11.instr"
  mccmg16_G = 0;
#line 116 "ILL_H15_D11.instr"
  mccmg16_aleft = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg16_aright = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg16_atop = -1;
#line 116 "ILL_H15_D11.instr"
  mccmg16_abottom = -1;
#line 812 "ILL_H15_D11.instr"
  mccmg16_wavy = mcipWaviness;
#line 117 "ILL_H15_D11.instr"
  mccmg16_wavy_z = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg16_wavy_tb = 0;
#line 117 "ILL_H15_D11.instr"
  mccmg16_wavy_lr = 0;
#line 118 "ILL_H15_D11.instr"
  mccmg16_chamfers = 0;
#line 811 "ILL_H15_D11.instr"
  mccmg16_chamfers_z = mcipChamfers;
#line 118 "ILL_H15_D11.instr"
  mccmg16_chamfers_lr = 0;
#line 811 "ILL_H15_D11.instr"
  mccmg16_chamfers_tb = mcipChamfers;
#line 811 "ILL_H15_D11.instr"
  mccmg16_nelements = ( Config_n [ 16 ] );
#line 119 "ILL_H15_D11.instr"
  mccmg16_nu = 0;
#line 119 "ILL_H15_D11.instr"
  mccmg16_phase = 0;
#line 119 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccmg16_reflect, "NULL" ? "NULL" : "", 16384); else mccmg16_reflect[0]='\0';
#line 29112 "ILL_H15_D11.c"

  SIG_MESSAGE("mg16 (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29119 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotamg15, mcrotamg16);
  rot_transpose(mcrotamg15, mctr1);
  rot_mul(mcrotamg16, mctr1, mcrotrmg16);
  mctc1 = coords_set(
#line 813 "ILL_H15_D11.instr"
    0,
#line 813 "ILL_H15_D11.instr"
    0,
#line 813 "ILL_H15_D11.instr"
    ( microGap + Config_l [ 15 ] + 0.002 ));
#line 29130 "ILL_H15_D11.c"
  rot_transpose(mcrotamg15, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposamg16 = coords_add(mcposamg15, mctc2);
  mctc1 = coords_sub(mcposamg15, mcposamg16);
  mcposrmg16 = rot_apply(mcrotamg16, mctc1);
  mcDEBUG_COMPONENT("mg16", mcposamg16, mcrotamg16)
  mccomp_posa[100] = mcposamg16;
  mccomp_posr[100] = mcposrmg16;
  mcNCounter[100]  = mcPCounter[100] = mcP2Counter[100] = 0;
  mcAbsorbProp[100]= 0;
    /* Component SampleF. */
  /* Setting parameters for component SampleF. */
  SIG_MESSAGE("SampleF (Init:SetPar)");
#line 816 "ILL_H15_D11.instr"
  mccSampleF_xwidth = gGuideWidth;
#line 816 "ILL_H15_D11.instr"
  mccSampleF_yheight = gGuideHeight2;
#line 203 "ILL_H15_D11.instr"
  mccSampleF_zdepth = 0;
#line 204 "ILL_H15_D11.instr"
  mccSampleF_xmin = 0;
#line 204 "ILL_H15_D11.instr"
  mccSampleF_xmax = 0;
#line 204 "ILL_H15_D11.instr"
  mccSampleF_ymin = 0;
#line 204 "ILL_H15_D11.instr"
  mccSampleF_ymax = 0;
#line 204 "ILL_H15_D11.instr"
  mccSampleF_zmin = 0;
#line 204 "ILL_H15_D11.instr"
  mccSampleF_zmax = 0;
#line 205 "ILL_H15_D11.instr"
  mccSampleF_bins = 0;
#line 205 "ILL_H15_D11.instr"
  mccSampleF_min = -1e40;
#line 205 "ILL_H15_D11.instr"
  mccSampleF_max = 1e40;
#line 205 "ILL_H15_D11.instr"
  mccSampleF_restore_neutron = 0;
#line 205 "ILL_H15_D11.instr"
  mccSampleF_radius = 0;
#line 817 "ILL_H15_D11.instr"
  if("x y, per cm2") strncpy(mccSampleF_options, "x y, per cm2" ? "x y, per cm2" : "", 16384); else mccSampleF_options[0]='\0';
#line 206 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccSampleF_filename, "NULL" ? "NULL" : "", 16384); else mccSampleF_filename[0]='\0';
#line 206 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccSampleF_geometry, "NULL" ? "NULL" : "", 16384); else mccSampleF_geometry[0]='\0';
#line 207 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccSampleF_username1, "NULL" ? "NULL" : "", 16384); else mccSampleF_username1[0]='\0';
#line 207 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccSampleF_username2, "NULL" ? "NULL" : "", 16384); else mccSampleF_username2[0]='\0';
#line 207 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccSampleF_username3, "NULL" ? "NULL" : "", 16384); else mccSampleF_username3[0]='\0';
#line 208 "ILL_H15_D11.instr"
  mccSampleF_nowritefile = 0;
#line 29186 "ILL_H15_D11.c"

  SIG_MESSAGE("SampleF (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29193 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotamg15, mcrotaSampleF);
  rot_transpose(mcrotamg16, mctr1);
  rot_mul(mcrotaSampleF, mctr1, mcrotrSampleF);
  mctc1 = coords_set(
#line 818 "ILL_H15_D11.instr"
    0,
#line 818 "ILL_H15_D11.instr"
    0,
#line 818 "ILL_H15_D11.instr"
    ( Config_l [ 15 ] + 2.5 ));
#line 29204 "ILL_H15_D11.c"
  rot_transpose(mcrotamg15, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaSampleF = coords_add(mcposamg15, mctc2);
  mctc1 = coords_sub(mcposamg16, mcposaSampleF);
  mcposrSampleF = rot_apply(mcrotaSampleF, mctc1);
  mcDEBUG_COMPONENT("SampleF", mcposaSampleF, mcrotaSampleF)
  mccomp_posa[101] = mcposaSampleF;
  mccomp_posr[101] = mcposrSampleF;
  mcNCounter[101]  = mcPCounter[101] = mcP2Counter[101] = 0;
  mcAbsorbProp[101]= 0;
    /* Component SampleC. */
  /* Setting parameters for component SampleC. */
  SIG_MESSAGE("SampleC (Init:SetPar)");
#line 820 "ILL_H15_D11.instr"
  mccSampleC_xwidth = gGuideWidth;
#line 820 "ILL_H15_D11.instr"
  mccSampleC_yheight = gGuideHeight2;
#line 203 "ILL_H15_D11.instr"
  mccSampleC_zdepth = 0;
#line 204 "ILL_H15_D11.instr"
  mccSampleC_xmin = 0;
#line 204 "ILL_H15_D11.instr"
  mccSampleC_xmax = 0;
#line 204 "ILL_H15_D11.instr"
  mccSampleC_ymin = 0;
#line 204 "ILL_H15_D11.instr"
  mccSampleC_ymax = 0;
#line 204 "ILL_H15_D11.instr"
  mccSampleC_zmin = 0;
#line 204 "ILL_H15_D11.instr"
  mccSampleC_zmax = 0;
#line 205 "ILL_H15_D11.instr"
  mccSampleC_bins = 0;
#line 205 "ILL_H15_D11.instr"
  mccSampleC_min = -1e40;
#line 205 "ILL_H15_D11.instr"
  mccSampleC_max = 1e40;
#line 205 "ILL_H15_D11.instr"
  mccSampleC_restore_neutron = 0;
#line 205 "ILL_H15_D11.instr"
  mccSampleC_radius = 0;
#line 821 "ILL_H15_D11.instr"
  if("x y, capture, per cm2") strncpy(mccSampleC_options, "x y, capture, per cm2" ? "x y, capture, per cm2" : "", 16384); else mccSampleC_options[0]='\0';
#line 206 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccSampleC_filename, "NULL" ? "NULL" : "", 16384); else mccSampleC_filename[0]='\0';
#line 206 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccSampleC_geometry, "NULL" ? "NULL" : "", 16384); else mccSampleC_geometry[0]='\0';
#line 207 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccSampleC_username1, "NULL" ? "NULL" : "", 16384); else mccSampleC_username1[0]='\0';
#line 207 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccSampleC_username2, "NULL" ? "NULL" : "", 16384); else mccSampleC_username2[0]='\0';
#line 207 "ILL_H15_D11.instr"
  if("NULL") strncpy(mccSampleC_username3, "NULL" ? "NULL" : "", 16384); else mccSampleC_username3[0]='\0';
#line 208 "ILL_H15_D11.instr"
  mccSampleC_nowritefile = 0;
#line 29260 "ILL_H15_D11.c"

  SIG_MESSAGE("SampleC (Init:Place/Rotate)");
  rot_set_rotation(mctr1,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD,
    (0.0)*DEG2RAD);
#line 29267 "ILL_H15_D11.c"
  rot_mul(mctr1, mcrotaSampleF, mcrotaSampleC);
  rot_transpose(mcrotaSampleF, mctr1);
  rot_mul(mcrotaSampleC, mctr1, mcrotrSampleC);
  mctc1 = coords_set(
#line 822 "ILL_H15_D11.instr"
    0,
#line 822 "ILL_H15_D11.instr"
    0,
#line 822 "ILL_H15_D11.instr"
    0.001);
#line 29278 "ILL_H15_D11.c"
  rot_transpose(mcrotaSampleF, mctr1);
  mctc2 = rot_apply(mctr1, mctc1);
  mcposaSampleC = coords_add(mcposaSampleF, mctc2);
  mctc1 = coords_sub(mcposaSampleF, mcposaSampleC);
  mcposrSampleC = rot_apply(mcrotaSampleC, mctc1);
  mcDEBUG_COMPONENT("SampleC", mcposaSampleC, mcrotaSampleC)
  mccomp_posa[102] = mcposaSampleC;
  mccomp_posr[102] = mcposrSampleC;
  mcNCounter[102]  = mcPCounter[102] = mcP2Counter[102] = 0;
  mcAbsorbProp[102]= 0;
  /* Component initializations. */
  /* Initializations for component PG. */
  SIG_MESSAGE("PG (Init)");
#define mccompcurname  PG
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccPG_IntermediateCnts
#define StartTime mccPG_StartTime
#define EndTime mccPG_EndTime
#define CurrentTime mccPG_CurrentTime
#define profile mccPG_profile
#define percent mccPG_percent
#define flag_save mccPG_flag_save
#define minutes mccPG_minutes
#line 57 "/usr/share/mcstas/2.6rc1/misc/Progress_bar.comp"
{
IntermediateCnts=0;
StartTime=0;
EndTime=0;
CurrentTime=0;

fprintf(stdout, "[%s] Initialize\n", mcinstrument_name);
  if (percent*mcget_ncount()/100 < 1e5) {
    percent=1e5*100.0/mcget_ncount();
  }
}
#line 29315 "ILL_H15_D11.c"
#undef minutes
#undef flag_save
#undef percent
#undef profile
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Source. */
  SIG_MESSAGE("Source (Init)");
#define mccompcurname  Source
#define mccompcurtype  Source_gen
#define mccompcurindex 2
#define p_in mccSource_p_in
#define lambda1 mccSource_lambda1
#define lambda2 mccSource_lambda2
#define lambda3 mccSource_lambda3
#define pTable mccSource_pTable
#define pTable_x mccSource_pTable_x
#define pTable_y mccSource_pTable_y
#define pTable_xmin mccSource_pTable_xmin
#define pTable_xmax mccSource_pTable_xmax
#define pTable_xsum mccSource_pTable_xsum
#define pTable_ymin mccSource_pTable_ymin
#define pTable_ymax mccSource_pTable_ymax
#define pTable_ysum mccSource_pTable_ysum
#define pTable_dxmin mccSource_pTable_dxmin
#define pTable_dxmax mccSource_pTable_dxmax
#define pTable_dymin mccSource_pTable_dymin
#define pTable_dymax mccSource_pTable_dymax
#define flux_file mccSource_flux_file
#define xdiv_file mccSource_xdiv_file
#define ydiv_file mccSource_ydiv_file
#define radius mccSource_radius
#define dist mccSource_dist
#define focus_xw mccSource_focus_xw
#define focus_yh mccSource_focus_yh
#define focus_aw mccSource_focus_aw
#define focus_ah mccSource_focus_ah
#define E0 mccSource_E0
#define dE mccSource_dE
#define lambda0 mccSource_lambda0
#define dlambda mccSource_dlambda
#define I1 mccSource_I1
#define yheight mccSource_yheight
#define xwidth mccSource_xwidth
#define verbose mccSource_verbose
#define T1 mccSource_T1
#define flux_file_perAA mccSource_flux_file_perAA
#define flux_file_log mccSource_flux_file_log
#define Lmin mccSource_Lmin
#define Lmax mccSource_Lmax
#define Emin mccSource_Emin
#define Emax mccSource_Emax
#define T2 mccSource_T2
#define I2 mccSource_I2
#define T3 mccSource_T3
#define I3 mccSource_I3
#define zdepth mccSource_zdepth
#define target_index mccSource_target_index
#line 206 "/usr/share/mcstas/2.6rc1/sources/Source_gen.comp"
{
  pTable_xsum=0;
  pTable_ysum=0;


  double source_area, k;

  if (target_index && !dist)
  {
    Coords ToTarget;
    double tx,ty,tz;
    ToTarget = coords_sub(POS_A_COMP_INDEX(INDEX_CURRENT_COMP+target_index),POS_A_CURRENT_COMP);
    ToTarget = rot_apply(ROT_A_CURRENT_COMP, ToTarget);
    coords_get(ToTarget, &tx, &ty, &tz);
    dist=sqrt(tx*tx+ty*ty+tz*tz);
  }

  /* spectrum characteristics */
  if (flux_file && strlen(flux_file) && strcmp(flux_file,"NULL") && strcmp(flux_file,"0")) {
    if (Table_Read(&pTable, flux_file, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr, "Source_gen: %s: can not read flux file %s\n", NAME_CURRENT_COMP, flux_file));
    /* put table in Log scale */
    int i;
    if (pTable.columns < 2) exit(fprintf(stderr, "Source_gen: %s: Flux file %s should contain at least 2 columns [wavelength in Angs,flux].\n", NAME_CURRENT_COMP, flux_file));
    double table_lmin=FLT_MAX, table_lmax=-FLT_MAX;
    double tmin=FLT_MAX, tmax=-FLT_MAX;
    for (i=0; i<pTable.rows; i++) {
      double val = Table_Index(pTable, i,1);
      val = Table_Index(pTable, i,0); /* lambda */
      if (val > tmax) tmax=val;
      if (val < tmin) tmin=val;
    }
    for (i=0; i<pTable.rows; i++) {
      double val = Table_Index(pTable, i,1);
      if (val < 0) fprintf(stderr, "Source_gen: %s: File %s has negative flux at row %i.\n", NAME_CURRENT_COMP, flux_file, i+1);
      if (flux_file_log)
        val = log(val > 0 ? val : tmin/10);
      Table_SetElement(&pTable, i, 1, val);
      val = Table_Index(pTable, i,0); /* lambda */
      if (val > table_lmax) table_lmax=val;
      if (val < table_lmin) table_lmin=val;
    }
    if (!Lmin && !Lmax && !lambda0 && !dlambda && !E0 && !dE && !Emin && !Emax) {
      Lmin = table_lmin; Lmax = table_lmax;
    }
    if (Lmax > table_lmax) {
      if (verbose) fprintf(stderr, "Source_gen: %s: Maximum wavelength %g is beyond table range upper limit %g. Constraining.\n", NAME_CURRENT_COMP, Lmax, table_lmax);
      Lmax = table_lmax;
    }
    if (Lmin < table_lmin) {
      if (verbose) fprintf(stderr, "Source_gen: %s: Minimum wavelength %g is below table range lower limit %g. Constraining.\n", NAME_CURRENT_COMP, Lmin, table_lmin);
      Lmin = table_lmin;
    }
  }  /* end flux file */
  else
  {
    k  = 1.38066e-23; /* k_B */
    if (T1 > 0)
    {
      lambda1  = 1.0e10*sqrt(HBAR*HBAR*4.0*PI*PI/2.0/MNEUTRON/k/T1);
    }
    else
      { lambda1 = lambda0; }

    if (T2 > 0)
    {
      lambda2  = 1.0e10*sqrt(HBAR*HBAR*4.0*PI*PI/2.0/MNEUTRON/k/T2);
    }
    else
      { lambda2 = lambda0; }

    if (T3 > 0)
    {
      lambda3  = 1.0e10*sqrt(HBAR*HBAR*4.0*PI*PI/2.0/MNEUTRON/k/T3);
    }
    else
      { lambda3 = lambda0; }
  }

  /* now read position-divergence files, if any */
  if (xdiv_file && strlen(xdiv_file) && strcmp(xdiv_file,"NULL") && strcmp(xdiv_file,"0")) {
    int i,j;
    if (Table_Read(&pTable_x, xdiv_file, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr, "Source_gen: %s: can not read XDiv file %s\n", NAME_CURRENT_COMP, xdiv_file));
    pTable_xsum = 0;
    for (i=0; i<pTable_x.rows; i++)
      for (j=0; j<pTable_x.columns; j++)
        pTable_xsum += Table_Index(pTable_x, i,j);

    /* now extract limits */
    char **parsing;
    char xylimits[1024];
    strcpy(xylimits, "");
    parsing = Table_ParseHeader(pTable_x.header,
      "xlimits", "xylimits",
      NULL);

    if (parsing) {
      if (parsing[0])  strcpy(xylimits, str_dup_numeric(parsing[0]));
      if (parsing[1] && !strlen(xylimits))
                       strcpy(xylimits, str_dup_numeric(parsing[1]));
      for (i=0; i<=1; i++) {
        if (parsing[i]) free(parsing[i]);
      }
      free(parsing);
    }
    i = sscanf(xylimits, "%lg %lg %lg %lg",
      &(pTable_xmin),  &(pTable_xmax),
      &(pTable_dxmin), &(pTable_dxmax));
    if (i != 2 && i != 4 && verbose)
      fprintf(stderr, "Source_gen: %s: invalid xylimits '%s' from file %s. extracted %i values\n",
        NAME_CURRENT_COMP, xylimits, xdiv_file, i);

    if (!xwidth) xwidth=pTable_xmax-pTable_xmin;
    if (!focus_xw && !dist) focus_xw=fabs(pTable_dxmax-pTable_dxmin);
  } /* end xdiv file */

  if (ydiv_file && strlen(ydiv_file) && strcmp(ydiv_file,"NULL") && strcmp(ydiv_file,"0")) {
    int i,j;
    if (Table_Read(&pTable_y, ydiv_file, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr, "Source_gen: %s: can not read YDiv file %s\n", NAME_CURRENT_COMP, ydiv_file));
    pTable_ysum = 0;
    for (i=0; i<pTable_y.rows; i++)
      for (j=0; j<pTable_y.columns; j++)
        pTable_ysum += Table_Index(pTable_y, i,j);

    /* now extract limits */
    char **parsing;
    char xylimits[1024];
    strcpy(xylimits, "");
    parsing = Table_ParseHeader(pTable_y.header,
      "xlimits", "xylimits",
      NULL);

    if (parsing) {
      if (parsing[0])  strcpy(xylimits,str_dup_numeric(parsing[0]));
      if (parsing[1] && !strlen(xylimits))
                       strcpy(xylimits,str_dup_numeric(parsing[1]));
      for (i=0; i<=1; i++) {
        if (parsing[i]) free(parsing[i]);
      }
      free(parsing);
    }
    i = sscanf(xylimits, "%lg %lg %lg %lg",
      &(pTable_ymin),  &(pTable_ymax),
      &(pTable_dymin), &(pTable_dymax));
    if (i != 2 && i != 4 && verbose)
      fprintf(stderr, "Source_gen: %s: invalid xylimits '%s' from file %s. extracted %i values\n",
        NAME_CURRENT_COMP, xylimits, ydiv_file, i);
    if (!yheight)  yheight=pTable_ymax-pTable_ymin;
    if (!focus_yh && !dist) focus_yh=fabs(pTable_dymax-pTable_dymin);
  } /* end ydiv file */

  /* tests for parameter values */
  if (Emin < 0 || Emax < 0 || Lmin < 0 || Lmax < 0 || E0 < 0 || dE < 0 || lambda0 < 0 || dlambda < 0)
  {
    fprintf(stderr,"Source_gen: %s: Error: Negative average\n"
                   "            or range values for wavelength or energy encountered\n",
                   NAME_CURRENT_COMP);
    exit(-1);
  }
  if ((Emin == 0 && Emax > 0) || (dE > 0 && dE >= E0))
  {
    fprintf(stderr,"Source_gen: %s: Error: minimal energy cannot be less or equal zero\n",
      NAME_CURRENT_COMP);
    exit(-1);
  }
  if ((Emax >= Emin) && (Emin > 0))
  { E0 = (Emax+Emin)/2;
    dE = (Emax-Emin)/2;
  }
  if ((E0 > dE) && (dE >= 0))
  {
    Lmin = sqrt(81.81/(E0+dE)); /* Angstroem */
    Lmax = sqrt(81.81/(E0-dE));
  }
  if (Lmax > 0)
  { lambda0 = (Lmax+Lmin)/2;
    dlambda = (Lmax-Lmin)/2;
  }
  if (lambda0 <= 0 || (lambda0 < dlambda) || (dlambda < 0))
  { fprintf(stderr,"Source_gen: %s: Error: Wavelength range %.3f +/- %.3f AA calculated \n",
      NAME_CURRENT_COMP, lambda0, dlambda);
    fprintf(stderr,"- whole wavelength range must be >= 0 \n");
    fprintf(stderr,"- range must be > 0; otherwise intensity gets zero, use other sources in this case \n\n");
    exit(-1);
  }

  radius = fabs(radius); xwidth=fabs(xwidth); yheight=fabs(yheight);  I1=fabs(I1);
  lambda0=fabs(lambda0); dlambda=fabs(dlambda);
  focus_xw = fabs(focus_xw); focus_yh=fabs(focus_yh); dist=fabs(dist);

  if ((!focus_ah && !focus_aw) && (!focus_xw && !focus_yh))
  {
    fprintf(stderr,"Source_gen: %s: Error: No focusing information.\n"
                   "            Specify focus_xw, focus_yh or focus_aw, focus_ah\n",
                   NAME_CURRENT_COMP);
    exit(-1);
  }
  Lmin = lambda0 - dlambda; /* Angstroem */
  Lmax = lambda0 + dlambda;

  /* compute initial weight factor p_in to get [n/s] */
  if ((I1 > 0  && T1 >= 0)
     || (flux_file && strlen(flux_file) && strcmp(flux_file,"NULL") && strcmp(flux_file,"0")))
  { /* the I1,2,3 are usually in [n/s/cm2/st/AA] */
    if (radius)
      source_area = radius*radius*PI*1e4; /* circular cm^2 */
    else
      source_area = yheight*xwidth*1e4; /* square cm^2 */
    p_in  = source_area; /* cm2 */
    p_in *= (Lmax-Lmin); /* AA. 1 bin=AA/n */
    if (flux_file && strlen(flux_file) && strcmp(flux_file,"NULL") && strcmp(flux_file,"0")
      && !flux_file_perAA)  p_in *= pTable.rows/(Lmax-Lmin);
  }
  else
    p_in = 1.0/4/PI; /* Small angle approx. */
  p_in /= mcget_ncount();
  if (!T1 && I1) p_in *= I1;

  if (radius == 0 && yheight == 0 && xwidth == 0)
  {
    fprintf(stderr,"Source_gen: %s: Error: Please specify source geometry (radius, yheight, xwidth)\n",
      NAME_CURRENT_COMP);
    exit(-1);
  }
  if (focus_xw*focus_yh == 0)
  {
    fprintf(stderr,"Source_gen: %s: Error: Please specify source target (focus_xw, focus_yh)\n",
      NAME_CURRENT_COMP);
    exit(-1);
  }
  MPI_MASTER(
  if (verbose)
  {
    printf("Source_gen: component %s ", NAME_CURRENT_COMP);
    if ((yheight == 0) || (xwidth == 0))
      printf("(disk, radius=%g)", radius);
    else
      printf("(square %g x %g)",xwidth,yheight);
    if (dist) printf("\n            focusing distance dist=%g area=%g x %g\n", dist, focus_xw, focus_yh);
    printf("            spectra ");
    printf("%.3f to %.3f AA (%.3f to %.3f meV)", Lmin, Lmax, 81.81/Lmax/Lmax, 81.81/Lmin/Lmin);
    printf("\n");
    if (flux_file && strlen(flux_file) && strcmp(flux_file,"NULL") && strcmp(flux_file,"0"))
    { printf("  File %s for flux distribution used. Flux is dPhi/dlambda in [n/s/AA]. \n", flux_file);
      Table_Info(pTable);
    }
    else if (T1>=0 && I1)
    { if (T1 != 0)
        printf("            T1=%.1f K (%.3f AA)", T1, lambda1);
      if (T2*I2 != 0)
        printf(", T2=%.1f K (%.3f AA)", T2, lambda2);
      if (T3*I3 != 0)
        printf(", T3=%.1f K (%.3f AA)", T3, lambda3);
      if (T1) printf("\n");
      printf("  Flux is dPhi/dlambda in [n/s/cm2].\n");
    }
    else
    { printf("  Flux is Phi in [n/s].\n");
    }
    if (xdiv_file && strlen(xdiv_file) && strcmp(xdiv_file,"NULL") && strcmp(xdiv_file,"0"))
      printf("  File %s x=[%g:%g] [m] xdiv=[%g:%g] [deg] used as horizontal phase space distribution.\n", xdiv_file, pTable_xmin, pTable_xmax, pTable_dxmin, pTable_dxmax);
    if (ydiv_file && strlen(ydiv_file) && strcmp(ydiv_file,"NULL") && strcmp(ydiv_file,"0"))
      printf("  File %s y=[%g:%g] [m] ydiv=[%g:%g] [deg] used as vertical phase space distribution.\n", ydiv_file, pTable_ymin, pTable_ymax, pTable_dymin, pTable_dymax);
  }
  else
    if (verbose == -1)
      printf("Source_gen: component %s unactivated", NAME_CURRENT_COMP);
  );
}
#line 29652 "ILL_H15_D11.c"
#undef target_index
#undef zdepth
#undef I3
#undef T3
#undef I2
#undef T2
#undef Emax
#undef Emin
#undef Lmax
#undef Lmin
#undef flux_file_log
#undef flux_file_perAA
#undef T1
#undef verbose
#undef xwidth
#undef yheight
#undef I1
#undef dlambda
#undef lambda0
#undef dE
#undef E0
#undef focus_ah
#undef focus_aw
#undef focus_yh
#undef focus_xw
#undef dist
#undef radius
#undef ydiv_file
#undef xdiv_file
#undef flux_file
#undef pTable_dymax
#undef pTable_dymin
#undef pTable_dxmax
#undef pTable_dxmin
#undef pTable_ysum
#undef pTable_ymax
#undef pTable_ymin
#undef pTable_xsum
#undef pTable_xmax
#undef pTable_xmin
#undef pTable_y
#undef pTable_x
#undef pTable
#undef lambda3
#undef lambda2
#undef lambda1
#undef p_in
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component AlWindow1. */
  SIG_MESSAGE("AlWindow1 (Init)");

  /* Initializations for component PinkCarter. */
  SIG_MESSAGE("PinkCarter (Init)");
#define mccompcurname  PinkCarter
#define mccompcurtype  Guide_gravity
#define mccompcurindex 4
#define GVars mccPinkCarter_GVars
#define pTable mccPinkCarter_pTable
#define w1 mccPinkCarter_w1
#define h1 mccPinkCarter_h1
#define w2 mccPinkCarter_w2
#define h2 mccPinkCarter_h2
#define l mccPinkCarter_l
#define R0 mccPinkCarter_R0
#define Qc mccPinkCarter_Qc
#define alpha mccPinkCarter_alpha
#define m mccPinkCarter_m
#define W mccPinkCarter_W
#define nslit mccPinkCarter_nslit
#define d mccPinkCarter_d
#define mleft mccPinkCarter_mleft
#define mright mccPinkCarter_mright
#define mtop mccPinkCarter_mtop
#define mbottom mccPinkCarter_mbottom
#define nhslit mccPinkCarter_nhslit
#define G mccPinkCarter_G
#define aleft mccPinkCarter_aleft
#define aright mccPinkCarter_aright
#define atop mccPinkCarter_atop
#define abottom mccPinkCarter_abottom
#define wavy mccPinkCarter_wavy
#define wavy_z mccPinkCarter_wavy_z
#define wavy_tb mccPinkCarter_wavy_tb
#define wavy_lr mccPinkCarter_wavy_lr
#define chamfers mccPinkCarter_chamfers
#define chamfers_z mccPinkCarter_chamfers_z
#define chamfers_lr mccPinkCarter_chamfers_lr
#define chamfers_tb mccPinkCarter_chamfers_tb
#define nelements mccPinkCarter_nelements
#define nu mccPinkCarter_nu
#define phase mccPinkCarter_phase
#define reflect mccPinkCarter_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 29800 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component AlWindow2. */
  SIG_MESSAGE("AlWindow2 (Init)");

  /* Initializations for component LeadShutter. */
  SIG_MESSAGE("LeadShutter (Init)");
#define mccompcurname  LeadShutter
#define mccompcurtype  Guide_gravity
#define mccompcurindex 6
#define GVars mccLeadShutter_GVars
#define pTable mccLeadShutter_pTable
#define w1 mccLeadShutter_w1
#define h1 mccLeadShutter_h1
#define w2 mccLeadShutter_w2
#define h2 mccLeadShutter_h2
#define l mccLeadShutter_l
#define R0 mccLeadShutter_R0
#define Qc mccLeadShutter_Qc
#define alpha mccLeadShutter_alpha
#define m mccLeadShutter_m
#define W mccLeadShutter_W
#define nslit mccLeadShutter_nslit
#define d mccLeadShutter_d
#define mleft mccLeadShutter_mleft
#define mright mccLeadShutter_mright
#define mtop mccLeadShutter_mtop
#define mbottom mccLeadShutter_mbottom
#define nhslit mccLeadShutter_nhslit
#define G mccLeadShutter_G
#define aleft mccLeadShutter_aleft
#define aright mccLeadShutter_aright
#define atop mccLeadShutter_atop
#define abottom mccLeadShutter_abottom
#define wavy mccLeadShutter_wavy
#define wavy_z mccLeadShutter_wavy_z
#define wavy_tb mccLeadShutter_wavy_tb
#define wavy_lr mccLeadShutter_wavy_lr
#define chamfers mccLeadShutter_chamfers
#define chamfers_z mccLeadShutter_chamfers_z
#define chamfers_lr mccLeadShutter_chamfers_lr
#define chamfers_tb mccLeadShutter_chamfers_tb
#define nelements mccLeadShutter_nelements
#define nu mccLeadShutter_nu
#define phase mccLeadShutter_phase
#define reflect mccLeadShutter_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 29937 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component AlWindow3. */
  SIG_MESSAGE("AlWindow3 (Init)");

  /* Initializations for component CurvedGuideStart. */
  SIG_MESSAGE("CurvedGuideStart (Init)");

  /* Initializations for component cg1. */
  SIG_MESSAGE("cg1 (Init)");
#define mccompcurname  cg1
#define mccompcurtype  Guide_gravity
#define mccompcurindex 9
#define GVars mcccg1_GVars
#define pTable mcccg1_pTable
#define w1 mcccg1_w1
#define h1 mcccg1_h1
#define w2 mcccg1_w2
#define h2 mcccg1_h2
#define l mcccg1_l
#define R0 mcccg1_R0
#define Qc mcccg1_Qc
#define alpha mcccg1_alpha
#define m mcccg1_m
#define W mcccg1_W
#define nslit mcccg1_nslit
#define d mcccg1_d
#define mleft mcccg1_mleft
#define mright mcccg1_mright
#define mtop mcccg1_mtop
#define mbottom mcccg1_mbottom
#define nhslit mcccg1_nhslit
#define G mcccg1_G
#define aleft mcccg1_aleft
#define aright mcccg1_aright
#define atop mcccg1_atop
#define abottom mcccg1_abottom
#define wavy mcccg1_wavy
#define wavy_z mcccg1_wavy_z
#define wavy_tb mcccg1_wavy_tb
#define wavy_lr mcccg1_wavy_lr
#define chamfers mcccg1_chamfers
#define chamfers_z mcccg1_chamfers_z
#define chamfers_lr mcccg1_chamfers_lr
#define chamfers_tb mcccg1_chamfers_tb
#define nelements mcccg1_nelements
#define nu mcccg1_nu
#define phase mcccg1_phase
#define reflect mcccg1_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 30077 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg2. */
  SIG_MESSAGE("cg2 (Init)");
#define mccompcurname  cg2
#define mccompcurtype  Guide_gravity
#define mccompcurindex 10
#define GVars mcccg2_GVars
#define pTable mcccg2_pTable
#define w1 mcccg2_w1
#define h1 mcccg2_h1
#define w2 mcccg2_w2
#define h2 mcccg2_h2
#define l mcccg2_l
#define R0 mcccg2_R0
#define Qc mcccg2_Qc
#define alpha mcccg2_alpha
#define m mcccg2_m
#define W mcccg2_W
#define nslit mcccg2_nslit
#define d mcccg2_d
#define mleft mcccg2_mleft
#define mright mcccg2_mright
#define mtop mcccg2_mtop
#define mbottom mcccg2_mbottom
#define nhslit mcccg2_nhslit
#define G mcccg2_G
#define aleft mcccg2_aleft
#define aright mcccg2_aright
#define atop mcccg2_atop
#define abottom mcccg2_abottom
#define wavy mcccg2_wavy
#define wavy_z mcccg2_wavy_z
#define wavy_tb mcccg2_wavy_tb
#define wavy_lr mcccg2_wavy_lr
#define chamfers mcccg2_chamfers
#define chamfers_z mcccg2_chamfers_z
#define chamfers_lr mcccg2_chamfers_lr
#define chamfers_tb mcccg2_chamfers_tb
#define nelements mcccg2_nelements
#define nu mcccg2_nu
#define phase mcccg2_phase
#define reflect mcccg2_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 30211 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg3. */
  SIG_MESSAGE("cg3 (Init)");
#define mccompcurname  cg3
#define mccompcurtype  Guide_gravity
#define mccompcurindex 11
#define GVars mcccg3_GVars
#define pTable mcccg3_pTable
#define w1 mcccg3_w1
#define h1 mcccg3_h1
#define w2 mcccg3_w2
#define h2 mcccg3_h2
#define l mcccg3_l
#define R0 mcccg3_R0
#define Qc mcccg3_Qc
#define alpha mcccg3_alpha
#define m mcccg3_m
#define W mcccg3_W
#define nslit mcccg3_nslit
#define d mcccg3_d
#define mleft mcccg3_mleft
#define mright mcccg3_mright
#define mtop mcccg3_mtop
#define mbottom mcccg3_mbottom
#define nhslit mcccg3_nhslit
#define G mcccg3_G
#define aleft mcccg3_aleft
#define aright mcccg3_aright
#define atop mcccg3_atop
#define abottom mcccg3_abottom
#define wavy mcccg3_wavy
#define wavy_z mcccg3_wavy_z
#define wavy_tb mcccg3_wavy_tb
#define wavy_lr mcccg3_wavy_lr
#define chamfers mcccg3_chamfers
#define chamfers_z mcccg3_chamfers_z
#define chamfers_lr mcccg3_chamfers_lr
#define chamfers_tb mcccg3_chamfers_tb
#define nelements mcccg3_nelements
#define nu mcccg3_nu
#define phase mcccg3_phase
#define reflect mcccg3_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 30345 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg4. */
  SIG_MESSAGE("cg4 (Init)");
#define mccompcurname  cg4
#define mccompcurtype  Guide_gravity
#define mccompcurindex 12
#define GVars mcccg4_GVars
#define pTable mcccg4_pTable
#define w1 mcccg4_w1
#define h1 mcccg4_h1
#define w2 mcccg4_w2
#define h2 mcccg4_h2
#define l mcccg4_l
#define R0 mcccg4_R0
#define Qc mcccg4_Qc
#define alpha mcccg4_alpha
#define m mcccg4_m
#define W mcccg4_W
#define nslit mcccg4_nslit
#define d mcccg4_d
#define mleft mcccg4_mleft
#define mright mcccg4_mright
#define mtop mcccg4_mtop
#define mbottom mcccg4_mbottom
#define nhslit mcccg4_nhslit
#define G mcccg4_G
#define aleft mcccg4_aleft
#define aright mcccg4_aright
#define atop mcccg4_atop
#define abottom mcccg4_abottom
#define wavy mcccg4_wavy
#define wavy_z mcccg4_wavy_z
#define wavy_tb mcccg4_wavy_tb
#define wavy_lr mcccg4_wavy_lr
#define chamfers mcccg4_chamfers
#define chamfers_z mcccg4_chamfers_z
#define chamfers_lr mcccg4_chamfers_lr
#define chamfers_tb mcccg4_chamfers_tb
#define nelements mcccg4_nelements
#define nu mcccg4_nu
#define phase mcccg4_phase
#define reflect mcccg4_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 30479 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg5. */
  SIG_MESSAGE("cg5 (Init)");
#define mccompcurname  cg5
#define mccompcurtype  Guide_gravity
#define mccompcurindex 13
#define GVars mcccg5_GVars
#define pTable mcccg5_pTable
#define w1 mcccg5_w1
#define h1 mcccg5_h1
#define w2 mcccg5_w2
#define h2 mcccg5_h2
#define l mcccg5_l
#define R0 mcccg5_R0
#define Qc mcccg5_Qc
#define alpha mcccg5_alpha
#define m mcccg5_m
#define W mcccg5_W
#define nslit mcccg5_nslit
#define d mcccg5_d
#define mleft mcccg5_mleft
#define mright mcccg5_mright
#define mtop mcccg5_mtop
#define mbottom mcccg5_mbottom
#define nhslit mcccg5_nhslit
#define G mcccg5_G
#define aleft mcccg5_aleft
#define aright mcccg5_aright
#define atop mcccg5_atop
#define abottom mcccg5_abottom
#define wavy mcccg5_wavy
#define wavy_z mcccg5_wavy_z
#define wavy_tb mcccg5_wavy_tb
#define wavy_lr mcccg5_wavy_lr
#define chamfers mcccg5_chamfers
#define chamfers_z mcccg5_chamfers_z
#define chamfers_lr mcccg5_chamfers_lr
#define chamfers_tb mcccg5_chamfers_tb
#define nelements mcccg5_nelements
#define nu mcccg5_nu
#define phase mcccg5_phase
#define reflect mcccg5_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 30613 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg6. */
  SIG_MESSAGE("cg6 (Init)");
#define mccompcurname  cg6
#define mccompcurtype  Guide_gravity
#define mccompcurindex 14
#define GVars mcccg6_GVars
#define pTable mcccg6_pTable
#define w1 mcccg6_w1
#define h1 mcccg6_h1
#define w2 mcccg6_w2
#define h2 mcccg6_h2
#define l mcccg6_l
#define R0 mcccg6_R0
#define Qc mcccg6_Qc
#define alpha mcccg6_alpha
#define m mcccg6_m
#define W mcccg6_W
#define nslit mcccg6_nslit
#define d mcccg6_d
#define mleft mcccg6_mleft
#define mright mcccg6_mright
#define mtop mcccg6_mtop
#define mbottom mcccg6_mbottom
#define nhslit mcccg6_nhslit
#define G mcccg6_G
#define aleft mcccg6_aleft
#define aright mcccg6_aright
#define atop mcccg6_atop
#define abottom mcccg6_abottom
#define wavy mcccg6_wavy
#define wavy_z mcccg6_wavy_z
#define wavy_tb mcccg6_wavy_tb
#define wavy_lr mcccg6_wavy_lr
#define chamfers mcccg6_chamfers
#define chamfers_z mcccg6_chamfers_z
#define chamfers_lr mcccg6_chamfers_lr
#define chamfers_tb mcccg6_chamfers_tb
#define nelements mcccg6_nelements
#define nu mcccg6_nu
#define phase mcccg6_phase
#define reflect mcccg6_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 30747 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg7. */
  SIG_MESSAGE("cg7 (Init)");
#define mccompcurname  cg7
#define mccompcurtype  Guide_gravity
#define mccompcurindex 15
#define GVars mcccg7_GVars
#define pTable mcccg7_pTable
#define w1 mcccg7_w1
#define h1 mcccg7_h1
#define w2 mcccg7_w2
#define h2 mcccg7_h2
#define l mcccg7_l
#define R0 mcccg7_R0
#define Qc mcccg7_Qc
#define alpha mcccg7_alpha
#define m mcccg7_m
#define W mcccg7_W
#define nslit mcccg7_nslit
#define d mcccg7_d
#define mleft mcccg7_mleft
#define mright mcccg7_mright
#define mtop mcccg7_mtop
#define mbottom mcccg7_mbottom
#define nhslit mcccg7_nhslit
#define G mcccg7_G
#define aleft mcccg7_aleft
#define aright mcccg7_aright
#define atop mcccg7_atop
#define abottom mcccg7_abottom
#define wavy mcccg7_wavy
#define wavy_z mcccg7_wavy_z
#define wavy_tb mcccg7_wavy_tb
#define wavy_lr mcccg7_wavy_lr
#define chamfers mcccg7_chamfers
#define chamfers_z mcccg7_chamfers_z
#define chamfers_lr mcccg7_chamfers_lr
#define chamfers_tb mcccg7_chamfers_tb
#define nelements mcccg7_nelements
#define nu mcccg7_nu
#define phase mcccg7_phase
#define reflect mcccg7_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 30881 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg8. */
  SIG_MESSAGE("cg8 (Init)");
#define mccompcurname  cg8
#define mccompcurtype  Guide_gravity
#define mccompcurindex 16
#define GVars mcccg8_GVars
#define pTable mcccg8_pTable
#define w1 mcccg8_w1
#define h1 mcccg8_h1
#define w2 mcccg8_w2
#define h2 mcccg8_h2
#define l mcccg8_l
#define R0 mcccg8_R0
#define Qc mcccg8_Qc
#define alpha mcccg8_alpha
#define m mcccg8_m
#define W mcccg8_W
#define nslit mcccg8_nslit
#define d mcccg8_d
#define mleft mcccg8_mleft
#define mright mcccg8_mright
#define mtop mcccg8_mtop
#define mbottom mcccg8_mbottom
#define nhslit mcccg8_nhslit
#define G mcccg8_G
#define aleft mcccg8_aleft
#define aright mcccg8_aright
#define atop mcccg8_atop
#define abottom mcccg8_abottom
#define wavy mcccg8_wavy
#define wavy_z mcccg8_wavy_z
#define wavy_tb mcccg8_wavy_tb
#define wavy_lr mcccg8_wavy_lr
#define chamfers mcccg8_chamfers
#define chamfers_z mcccg8_chamfers_z
#define chamfers_lr mcccg8_chamfers_lr
#define chamfers_tb mcccg8_chamfers_tb
#define nelements mcccg8_nelements
#define nu mcccg8_nu
#define phase mcccg8_phase
#define reflect mcccg8_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 31015 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg9. */
  SIG_MESSAGE("cg9 (Init)");
#define mccompcurname  cg9
#define mccompcurtype  Guide_gravity
#define mccompcurindex 17
#define GVars mcccg9_GVars
#define pTable mcccg9_pTable
#define w1 mcccg9_w1
#define h1 mcccg9_h1
#define w2 mcccg9_w2
#define h2 mcccg9_h2
#define l mcccg9_l
#define R0 mcccg9_R0
#define Qc mcccg9_Qc
#define alpha mcccg9_alpha
#define m mcccg9_m
#define W mcccg9_W
#define nslit mcccg9_nslit
#define d mcccg9_d
#define mleft mcccg9_mleft
#define mright mcccg9_mright
#define mtop mcccg9_mtop
#define mbottom mcccg9_mbottom
#define nhslit mcccg9_nhslit
#define G mcccg9_G
#define aleft mcccg9_aleft
#define aright mcccg9_aright
#define atop mcccg9_atop
#define abottom mcccg9_abottom
#define wavy mcccg9_wavy
#define wavy_z mcccg9_wavy_z
#define wavy_tb mcccg9_wavy_tb
#define wavy_lr mcccg9_wavy_lr
#define chamfers mcccg9_chamfers
#define chamfers_z mcccg9_chamfers_z
#define chamfers_lr mcccg9_chamfers_lr
#define chamfers_tb mcccg9_chamfers_tb
#define nelements mcccg9_nelements
#define nu mcccg9_nu
#define phase mcccg9_phase
#define reflect mcccg9_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 31149 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg10. */
  SIG_MESSAGE("cg10 (Init)");
#define mccompcurname  cg10
#define mccompcurtype  Guide_gravity
#define mccompcurindex 18
#define GVars mcccg10_GVars
#define pTable mcccg10_pTable
#define w1 mcccg10_w1
#define h1 mcccg10_h1
#define w2 mcccg10_w2
#define h2 mcccg10_h2
#define l mcccg10_l
#define R0 mcccg10_R0
#define Qc mcccg10_Qc
#define alpha mcccg10_alpha
#define m mcccg10_m
#define W mcccg10_W
#define nslit mcccg10_nslit
#define d mcccg10_d
#define mleft mcccg10_mleft
#define mright mcccg10_mright
#define mtop mcccg10_mtop
#define mbottom mcccg10_mbottom
#define nhslit mcccg10_nhslit
#define G mcccg10_G
#define aleft mcccg10_aleft
#define aright mcccg10_aright
#define atop mcccg10_atop
#define abottom mcccg10_abottom
#define wavy mcccg10_wavy
#define wavy_z mcccg10_wavy_z
#define wavy_tb mcccg10_wavy_tb
#define wavy_lr mcccg10_wavy_lr
#define chamfers mcccg10_chamfers
#define chamfers_z mcccg10_chamfers_z
#define chamfers_lr mcccg10_chamfers_lr
#define chamfers_tb mcccg10_chamfers_tb
#define nelements mcccg10_nelements
#define nu mcccg10_nu
#define phase mcccg10_phase
#define reflect mcccg10_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 31283 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg11. */
  SIG_MESSAGE("cg11 (Init)");
#define mccompcurname  cg11
#define mccompcurtype  Guide_gravity
#define mccompcurindex 19
#define GVars mcccg11_GVars
#define pTable mcccg11_pTable
#define w1 mcccg11_w1
#define h1 mcccg11_h1
#define w2 mcccg11_w2
#define h2 mcccg11_h2
#define l mcccg11_l
#define R0 mcccg11_R0
#define Qc mcccg11_Qc
#define alpha mcccg11_alpha
#define m mcccg11_m
#define W mcccg11_W
#define nslit mcccg11_nslit
#define d mcccg11_d
#define mleft mcccg11_mleft
#define mright mcccg11_mright
#define mtop mcccg11_mtop
#define mbottom mcccg11_mbottom
#define nhslit mcccg11_nhslit
#define G mcccg11_G
#define aleft mcccg11_aleft
#define aright mcccg11_aright
#define atop mcccg11_atop
#define abottom mcccg11_abottom
#define wavy mcccg11_wavy
#define wavy_z mcccg11_wavy_z
#define wavy_tb mcccg11_wavy_tb
#define wavy_lr mcccg11_wavy_lr
#define chamfers mcccg11_chamfers
#define chamfers_z mcccg11_chamfers_z
#define chamfers_lr mcccg11_chamfers_lr
#define chamfers_tb mcccg11_chamfers_tb
#define nelements mcccg11_nelements
#define nu mcccg11_nu
#define phase mcccg11_phase
#define reflect mcccg11_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 31417 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg12. */
  SIG_MESSAGE("cg12 (Init)");
#define mccompcurname  cg12
#define mccompcurtype  Guide_gravity
#define mccompcurindex 20
#define GVars mcccg12_GVars
#define pTable mcccg12_pTable
#define w1 mcccg12_w1
#define h1 mcccg12_h1
#define w2 mcccg12_w2
#define h2 mcccg12_h2
#define l mcccg12_l
#define R0 mcccg12_R0
#define Qc mcccg12_Qc
#define alpha mcccg12_alpha
#define m mcccg12_m
#define W mcccg12_W
#define nslit mcccg12_nslit
#define d mcccg12_d
#define mleft mcccg12_mleft
#define mright mcccg12_mright
#define mtop mcccg12_mtop
#define mbottom mcccg12_mbottom
#define nhslit mcccg12_nhslit
#define G mcccg12_G
#define aleft mcccg12_aleft
#define aright mcccg12_aright
#define atop mcccg12_atop
#define abottom mcccg12_abottom
#define wavy mcccg12_wavy
#define wavy_z mcccg12_wavy_z
#define wavy_tb mcccg12_wavy_tb
#define wavy_lr mcccg12_wavy_lr
#define chamfers mcccg12_chamfers
#define chamfers_z mcccg12_chamfers_z
#define chamfers_lr mcccg12_chamfers_lr
#define chamfers_tb mcccg12_chamfers_tb
#define nelements mcccg12_nelements
#define nu mcccg12_nu
#define phase mcccg12_phase
#define reflect mcccg12_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 31551 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg13. */
  SIG_MESSAGE("cg13 (Init)");
#define mccompcurname  cg13
#define mccompcurtype  Guide_gravity
#define mccompcurindex 21
#define GVars mcccg13_GVars
#define pTable mcccg13_pTable
#define w1 mcccg13_w1
#define h1 mcccg13_h1
#define w2 mcccg13_w2
#define h2 mcccg13_h2
#define l mcccg13_l
#define R0 mcccg13_R0
#define Qc mcccg13_Qc
#define alpha mcccg13_alpha
#define m mcccg13_m
#define W mcccg13_W
#define nslit mcccg13_nslit
#define d mcccg13_d
#define mleft mcccg13_mleft
#define mright mcccg13_mright
#define mtop mcccg13_mtop
#define mbottom mcccg13_mbottom
#define nhslit mcccg13_nhslit
#define G mcccg13_G
#define aleft mcccg13_aleft
#define aright mcccg13_aright
#define atop mcccg13_atop
#define abottom mcccg13_abottom
#define wavy mcccg13_wavy
#define wavy_z mcccg13_wavy_z
#define wavy_tb mcccg13_wavy_tb
#define wavy_lr mcccg13_wavy_lr
#define chamfers mcccg13_chamfers
#define chamfers_z mcccg13_chamfers_z
#define chamfers_lr mcccg13_chamfers_lr
#define chamfers_tb mcccg13_chamfers_tb
#define nelements mcccg13_nelements
#define nu mcccg13_nu
#define phase mcccg13_phase
#define reflect mcccg13_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 31685 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg14. */
  SIG_MESSAGE("cg14 (Init)");
#define mccompcurname  cg14
#define mccompcurtype  Guide_gravity
#define mccompcurindex 22
#define GVars mcccg14_GVars
#define pTable mcccg14_pTable
#define w1 mcccg14_w1
#define h1 mcccg14_h1
#define w2 mcccg14_w2
#define h2 mcccg14_h2
#define l mcccg14_l
#define R0 mcccg14_R0
#define Qc mcccg14_Qc
#define alpha mcccg14_alpha
#define m mcccg14_m
#define W mcccg14_W
#define nslit mcccg14_nslit
#define d mcccg14_d
#define mleft mcccg14_mleft
#define mright mcccg14_mright
#define mtop mcccg14_mtop
#define mbottom mcccg14_mbottom
#define nhslit mcccg14_nhslit
#define G mcccg14_G
#define aleft mcccg14_aleft
#define aright mcccg14_aright
#define atop mcccg14_atop
#define abottom mcccg14_abottom
#define wavy mcccg14_wavy
#define wavy_z mcccg14_wavy_z
#define wavy_tb mcccg14_wavy_tb
#define wavy_lr mcccg14_wavy_lr
#define chamfers mcccg14_chamfers
#define chamfers_z mcccg14_chamfers_z
#define chamfers_lr mcccg14_chamfers_lr
#define chamfers_tb mcccg14_chamfers_tb
#define nelements mcccg14_nelements
#define nu mcccg14_nu
#define phase mcccg14_phase
#define reflect mcccg14_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 31819 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg15. */
  SIG_MESSAGE("cg15 (Init)");
#define mccompcurname  cg15
#define mccompcurtype  Guide_gravity
#define mccompcurindex 23
#define GVars mcccg15_GVars
#define pTable mcccg15_pTable
#define w1 mcccg15_w1
#define h1 mcccg15_h1
#define w2 mcccg15_w2
#define h2 mcccg15_h2
#define l mcccg15_l
#define R0 mcccg15_R0
#define Qc mcccg15_Qc
#define alpha mcccg15_alpha
#define m mcccg15_m
#define W mcccg15_W
#define nslit mcccg15_nslit
#define d mcccg15_d
#define mleft mcccg15_mleft
#define mright mcccg15_mright
#define mtop mcccg15_mtop
#define mbottom mcccg15_mbottom
#define nhslit mcccg15_nhslit
#define G mcccg15_G
#define aleft mcccg15_aleft
#define aright mcccg15_aright
#define atop mcccg15_atop
#define abottom mcccg15_abottom
#define wavy mcccg15_wavy
#define wavy_z mcccg15_wavy_z
#define wavy_tb mcccg15_wavy_tb
#define wavy_lr mcccg15_wavy_lr
#define chamfers mcccg15_chamfers
#define chamfers_z mcccg15_chamfers_z
#define chamfers_lr mcccg15_chamfers_lr
#define chamfers_tb mcccg15_chamfers_tb
#define nelements mcccg15_nelements
#define nu mcccg15_nu
#define phase mcccg15_phase
#define reflect mcccg15_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 31953 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg16. */
  SIG_MESSAGE("cg16 (Init)");
#define mccompcurname  cg16
#define mccompcurtype  Guide_gravity
#define mccompcurindex 24
#define GVars mcccg16_GVars
#define pTable mcccg16_pTable
#define w1 mcccg16_w1
#define h1 mcccg16_h1
#define w2 mcccg16_w2
#define h2 mcccg16_h2
#define l mcccg16_l
#define R0 mcccg16_R0
#define Qc mcccg16_Qc
#define alpha mcccg16_alpha
#define m mcccg16_m
#define W mcccg16_W
#define nslit mcccg16_nslit
#define d mcccg16_d
#define mleft mcccg16_mleft
#define mright mcccg16_mright
#define mtop mcccg16_mtop
#define mbottom mcccg16_mbottom
#define nhslit mcccg16_nhslit
#define G mcccg16_G
#define aleft mcccg16_aleft
#define aright mcccg16_aright
#define atop mcccg16_atop
#define abottom mcccg16_abottom
#define wavy mcccg16_wavy
#define wavy_z mcccg16_wavy_z
#define wavy_tb mcccg16_wavy_tb
#define wavy_lr mcccg16_wavy_lr
#define chamfers mcccg16_chamfers
#define chamfers_z mcccg16_chamfers_z
#define chamfers_lr mcccg16_chamfers_lr
#define chamfers_tb mcccg16_chamfers_tb
#define nelements mcccg16_nelements
#define nu mcccg16_nu
#define phase mcccg16_phase
#define reflect mcccg16_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 32087 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg17. */
  SIG_MESSAGE("cg17 (Init)");
#define mccompcurname  cg17
#define mccompcurtype  Guide_gravity
#define mccompcurindex 25
#define GVars mcccg17_GVars
#define pTable mcccg17_pTable
#define w1 mcccg17_w1
#define h1 mcccg17_h1
#define w2 mcccg17_w2
#define h2 mcccg17_h2
#define l mcccg17_l
#define R0 mcccg17_R0
#define Qc mcccg17_Qc
#define alpha mcccg17_alpha
#define m mcccg17_m
#define W mcccg17_W
#define nslit mcccg17_nslit
#define d mcccg17_d
#define mleft mcccg17_mleft
#define mright mcccg17_mright
#define mtop mcccg17_mtop
#define mbottom mcccg17_mbottom
#define nhslit mcccg17_nhslit
#define G mcccg17_G
#define aleft mcccg17_aleft
#define aright mcccg17_aright
#define atop mcccg17_atop
#define abottom mcccg17_abottom
#define wavy mcccg17_wavy
#define wavy_z mcccg17_wavy_z
#define wavy_tb mcccg17_wavy_tb
#define wavy_lr mcccg17_wavy_lr
#define chamfers mcccg17_chamfers
#define chamfers_z mcccg17_chamfers_z
#define chamfers_lr mcccg17_chamfers_lr
#define chamfers_tb mcccg17_chamfers_tb
#define nelements mcccg17_nelements
#define nu mcccg17_nu
#define phase mcccg17_phase
#define reflect mcccg17_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 32221 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg18. */
  SIG_MESSAGE("cg18 (Init)");
#define mccompcurname  cg18
#define mccompcurtype  Guide_gravity
#define mccompcurindex 26
#define GVars mcccg18_GVars
#define pTable mcccg18_pTable
#define w1 mcccg18_w1
#define h1 mcccg18_h1
#define w2 mcccg18_w2
#define h2 mcccg18_h2
#define l mcccg18_l
#define R0 mcccg18_R0
#define Qc mcccg18_Qc
#define alpha mcccg18_alpha
#define m mcccg18_m
#define W mcccg18_W
#define nslit mcccg18_nslit
#define d mcccg18_d
#define mleft mcccg18_mleft
#define mright mcccg18_mright
#define mtop mcccg18_mtop
#define mbottom mcccg18_mbottom
#define nhslit mcccg18_nhslit
#define G mcccg18_G
#define aleft mcccg18_aleft
#define aright mcccg18_aright
#define atop mcccg18_atop
#define abottom mcccg18_abottom
#define wavy mcccg18_wavy
#define wavy_z mcccg18_wavy_z
#define wavy_tb mcccg18_wavy_tb
#define wavy_lr mcccg18_wavy_lr
#define chamfers mcccg18_chamfers
#define chamfers_z mcccg18_chamfers_z
#define chamfers_lr mcccg18_chamfers_lr
#define chamfers_tb mcccg18_chamfers_tb
#define nelements mcccg18_nelements
#define nu mcccg18_nu
#define phase mcccg18_phase
#define reflect mcccg18_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 32355 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg19. */
  SIG_MESSAGE("cg19 (Init)");
#define mccompcurname  cg19
#define mccompcurtype  Guide_gravity
#define mccompcurindex 27
#define GVars mcccg19_GVars
#define pTable mcccg19_pTable
#define w1 mcccg19_w1
#define h1 mcccg19_h1
#define w2 mcccg19_w2
#define h2 mcccg19_h2
#define l mcccg19_l
#define R0 mcccg19_R0
#define Qc mcccg19_Qc
#define alpha mcccg19_alpha
#define m mcccg19_m
#define W mcccg19_W
#define nslit mcccg19_nslit
#define d mcccg19_d
#define mleft mcccg19_mleft
#define mright mcccg19_mright
#define mtop mcccg19_mtop
#define mbottom mcccg19_mbottom
#define nhslit mcccg19_nhslit
#define G mcccg19_G
#define aleft mcccg19_aleft
#define aright mcccg19_aright
#define atop mcccg19_atop
#define abottom mcccg19_abottom
#define wavy mcccg19_wavy
#define wavy_z mcccg19_wavy_z
#define wavy_tb mcccg19_wavy_tb
#define wavy_lr mcccg19_wavy_lr
#define chamfers mcccg19_chamfers
#define chamfers_z mcccg19_chamfers_z
#define chamfers_lr mcccg19_chamfers_lr
#define chamfers_tb mcccg19_chamfers_tb
#define nelements mcccg19_nelements
#define nu mcccg19_nu
#define phase mcccg19_phase
#define reflect mcccg19_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 32489 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg20. */
  SIG_MESSAGE("cg20 (Init)");
#define mccompcurname  cg20
#define mccompcurtype  Guide_gravity
#define mccompcurindex 28
#define GVars mcccg20_GVars
#define pTable mcccg20_pTable
#define w1 mcccg20_w1
#define h1 mcccg20_h1
#define w2 mcccg20_w2
#define h2 mcccg20_h2
#define l mcccg20_l
#define R0 mcccg20_R0
#define Qc mcccg20_Qc
#define alpha mcccg20_alpha
#define m mcccg20_m
#define W mcccg20_W
#define nslit mcccg20_nslit
#define d mcccg20_d
#define mleft mcccg20_mleft
#define mright mcccg20_mright
#define mtop mcccg20_mtop
#define mbottom mcccg20_mbottom
#define nhslit mcccg20_nhslit
#define G mcccg20_G
#define aleft mcccg20_aleft
#define aright mcccg20_aright
#define atop mcccg20_atop
#define abottom mcccg20_abottom
#define wavy mcccg20_wavy
#define wavy_z mcccg20_wavy_z
#define wavy_tb mcccg20_wavy_tb
#define wavy_lr mcccg20_wavy_lr
#define chamfers mcccg20_chamfers
#define chamfers_z mcccg20_chamfers_z
#define chamfers_lr mcccg20_chamfers_lr
#define chamfers_tb mcccg20_chamfers_tb
#define nelements mcccg20_nelements
#define nu mcccg20_nu
#define phase mcccg20_phase
#define reflect mcccg20_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 32623 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg21. */
  SIG_MESSAGE("cg21 (Init)");
#define mccompcurname  cg21
#define mccompcurtype  Guide_gravity
#define mccompcurindex 29
#define GVars mcccg21_GVars
#define pTable mcccg21_pTable
#define w1 mcccg21_w1
#define h1 mcccg21_h1
#define w2 mcccg21_w2
#define h2 mcccg21_h2
#define l mcccg21_l
#define R0 mcccg21_R0
#define Qc mcccg21_Qc
#define alpha mcccg21_alpha
#define m mcccg21_m
#define W mcccg21_W
#define nslit mcccg21_nslit
#define d mcccg21_d
#define mleft mcccg21_mleft
#define mright mcccg21_mright
#define mtop mcccg21_mtop
#define mbottom mcccg21_mbottom
#define nhslit mcccg21_nhslit
#define G mcccg21_G
#define aleft mcccg21_aleft
#define aright mcccg21_aright
#define atop mcccg21_atop
#define abottom mcccg21_abottom
#define wavy mcccg21_wavy
#define wavy_z mcccg21_wavy_z
#define wavy_tb mcccg21_wavy_tb
#define wavy_lr mcccg21_wavy_lr
#define chamfers mcccg21_chamfers
#define chamfers_z mcccg21_chamfers_z
#define chamfers_lr mcccg21_chamfers_lr
#define chamfers_tb mcccg21_chamfers_tb
#define nelements mcccg21_nelements
#define nu mcccg21_nu
#define phase mcccg21_phase
#define reflect mcccg21_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 32757 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg22. */
  SIG_MESSAGE("cg22 (Init)");
#define mccompcurname  cg22
#define mccompcurtype  Guide_gravity
#define mccompcurindex 30
#define GVars mcccg22_GVars
#define pTable mcccg22_pTable
#define w1 mcccg22_w1
#define h1 mcccg22_h1
#define w2 mcccg22_w2
#define h2 mcccg22_h2
#define l mcccg22_l
#define R0 mcccg22_R0
#define Qc mcccg22_Qc
#define alpha mcccg22_alpha
#define m mcccg22_m
#define W mcccg22_W
#define nslit mcccg22_nslit
#define d mcccg22_d
#define mleft mcccg22_mleft
#define mright mcccg22_mright
#define mtop mcccg22_mtop
#define mbottom mcccg22_mbottom
#define nhslit mcccg22_nhslit
#define G mcccg22_G
#define aleft mcccg22_aleft
#define aright mcccg22_aright
#define atop mcccg22_atop
#define abottom mcccg22_abottom
#define wavy mcccg22_wavy
#define wavy_z mcccg22_wavy_z
#define wavy_tb mcccg22_wavy_tb
#define wavy_lr mcccg22_wavy_lr
#define chamfers mcccg22_chamfers
#define chamfers_z mcccg22_chamfers_z
#define chamfers_lr mcccg22_chamfers_lr
#define chamfers_tb mcccg22_chamfers_tb
#define nelements mcccg22_nelements
#define nu mcccg22_nu
#define phase mcccg22_phase
#define reflect mcccg22_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 32891 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg23. */
  SIG_MESSAGE("cg23 (Init)");
#define mccompcurname  cg23
#define mccompcurtype  Guide_gravity
#define mccompcurindex 31
#define GVars mcccg23_GVars
#define pTable mcccg23_pTable
#define w1 mcccg23_w1
#define h1 mcccg23_h1
#define w2 mcccg23_w2
#define h2 mcccg23_h2
#define l mcccg23_l
#define R0 mcccg23_R0
#define Qc mcccg23_Qc
#define alpha mcccg23_alpha
#define m mcccg23_m
#define W mcccg23_W
#define nslit mcccg23_nslit
#define d mcccg23_d
#define mleft mcccg23_mleft
#define mright mcccg23_mright
#define mtop mcccg23_mtop
#define mbottom mcccg23_mbottom
#define nhslit mcccg23_nhslit
#define G mcccg23_G
#define aleft mcccg23_aleft
#define aright mcccg23_aright
#define atop mcccg23_atop
#define abottom mcccg23_abottom
#define wavy mcccg23_wavy
#define wavy_z mcccg23_wavy_z
#define wavy_tb mcccg23_wavy_tb
#define wavy_lr mcccg23_wavy_lr
#define chamfers mcccg23_chamfers
#define chamfers_z mcccg23_chamfers_z
#define chamfers_lr mcccg23_chamfers_lr
#define chamfers_tb mcccg23_chamfers_tb
#define nelements mcccg23_nelements
#define nu mcccg23_nu
#define phase mcccg23_phase
#define reflect mcccg23_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33025 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg24. */
  SIG_MESSAGE("cg24 (Init)");
#define mccompcurname  cg24
#define mccompcurtype  Guide_gravity
#define mccompcurindex 32
#define GVars mcccg24_GVars
#define pTable mcccg24_pTable
#define w1 mcccg24_w1
#define h1 mcccg24_h1
#define w2 mcccg24_w2
#define h2 mcccg24_h2
#define l mcccg24_l
#define R0 mcccg24_R0
#define Qc mcccg24_Qc
#define alpha mcccg24_alpha
#define m mcccg24_m
#define W mcccg24_W
#define nslit mcccg24_nslit
#define d mcccg24_d
#define mleft mcccg24_mleft
#define mright mcccg24_mright
#define mtop mcccg24_mtop
#define mbottom mcccg24_mbottom
#define nhslit mcccg24_nhslit
#define G mcccg24_G
#define aleft mcccg24_aleft
#define aright mcccg24_aright
#define atop mcccg24_atop
#define abottom mcccg24_abottom
#define wavy mcccg24_wavy
#define wavy_z mcccg24_wavy_z
#define wavy_tb mcccg24_wavy_tb
#define wavy_lr mcccg24_wavy_lr
#define chamfers mcccg24_chamfers
#define chamfers_z mcccg24_chamfers_z
#define chamfers_lr mcccg24_chamfers_lr
#define chamfers_tb mcccg24_chamfers_tb
#define nelements mcccg24_nelements
#define nu mcccg24_nu
#define phase mcccg24_phase
#define reflect mcccg24_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33159 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component cg25. */
  SIG_MESSAGE("cg25 (Init)");
#define mccompcurname  cg25
#define mccompcurtype  Guide_gravity
#define mccompcurindex 33
#define GVars mcccg25_GVars
#define pTable mcccg25_pTable
#define w1 mcccg25_w1
#define h1 mcccg25_h1
#define w2 mcccg25_w2
#define h2 mcccg25_h2
#define l mcccg25_l
#define R0 mcccg25_R0
#define Qc mcccg25_Qc
#define alpha mcccg25_alpha
#define m mcccg25_m
#define W mcccg25_W
#define nslit mcccg25_nslit
#define d mcccg25_d
#define mleft mcccg25_mleft
#define mright mcccg25_mright
#define mtop mcccg25_mtop
#define mbottom mcccg25_mbottom
#define nhslit mcccg25_nhslit
#define G mcccg25_G
#define aleft mcccg25_aleft
#define aright mcccg25_aright
#define atop mcccg25_atop
#define abottom mcccg25_abottom
#define wavy mcccg25_wavy
#define wavy_z mcccg25_wavy_z
#define wavy_tb mcccg25_wavy_tb
#define wavy_lr mcccg25_wavy_lr
#define chamfers mcccg25_chamfers
#define chamfers_z mcccg25_chamfers_z
#define chamfers_lr mcccg25_chamfers_lr
#define chamfers_tb mcccg25_chamfers_tb
#define nelements mcccg25_nelements
#define nu mcccg25_nu
#define phase mcccg25_phase
#define reflect mcccg25_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33293 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component AlWindow4. */
  SIG_MESSAGE("AlWindow4 (Init)");

  /* Initializations for component PSD_VTE. */
  SIG_MESSAGE("PSD_VTE (Init)");
#define mccompcurname  PSD_VTE
#define mccompcurtype  Monitor_nD
#define mccompcurindex 35
#define user1 mccPSD_VTE_user1
#define user2 mccPSD_VTE_user2
#define user3 mccPSD_VTE_user3
#define DEFS mccPSD_VTE_DEFS
#define Vars mccPSD_VTE_Vars
#define detector mccPSD_VTE_detector
#define offdata mccPSD_VTE_offdata
#define xwidth mccPSD_VTE_xwidth
#define yheight mccPSD_VTE_yheight
#define zdepth mccPSD_VTE_zdepth
#define xmin mccPSD_VTE_xmin
#define xmax mccPSD_VTE_xmax
#define ymin mccPSD_VTE_ymin
#define ymax mccPSD_VTE_ymax
#define zmin mccPSD_VTE_zmin
#define zmax mccPSD_VTE_zmax
#define bins mccPSD_VTE_bins
#define min mccPSD_VTE_min
#define max mccPSD_VTE_max
#define restore_neutron mccPSD_VTE_restore_neutron
#define radius mccPSD_VTE_radius
#define options mccPSD_VTE_options
#define filename mccPSD_VTE_filename
#define geometry mccPSD_VTE_geometry
#define username1 mccPSD_VTE_username1
#define username2 mccPSD_VTE_username2
#define username3 mccPSD_VTE_username3
#define nowritefile mccPSD_VTE_nowritefile
#line 231 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  char tmp[CHAR_BUF_LENGTH];
  strcpy(Vars.compcurname, NAME_CURRENT_COMP);
  if (options != NULL)
    strncpy(Vars.option, options, CHAR_BUF_LENGTH);
  else {
    strcpy(Vars.option, "x y");
    printf("Monitor_nD: %s has no option specified. Setting to PSD ('x y') monitor.\n", NAME_CURRENT_COMP);
  }
  Vars.compcurpos = POS_A_CURRENT_COMP;

  if (strstr(Vars.option, "source"))
    strcat(Vars.option, " list, x y z vx vy vz t sx sy sz ");

  if (bins) { sprintf(tmp, " all bins=%ld ", (long)bins); strcat(Vars.option, tmp); }
  if (min > -FLT_MAX && max < FLT_MAX) { sprintf(tmp, " all limits=[%g %g]", min, max); strcat(Vars.option, tmp); }
  else if (min > -FLT_MAX) { sprintf(tmp, " all min=%g", min); strcat(Vars.option, tmp); }
  else if (max <  FLT_MAX) { sprintf(tmp, " all max=%g", max); strcat(Vars.option, tmp); }

  strncpy(Vars.UserName1,
    username1 && strlen(username1) && strcmp(username1, "0") && strcmp(username1, "NULL") ?
    username1 : "", 128);
  strncpy(Vars.UserName2,
    username2 && strlen(username2) && strcmp(username2, "0") && strcmp(username2, "NULL") ?
    username2 : "", 128);
  strncpy(Vars.UserName3,
    username3 && strlen(username3) && strcmp(username3, "0") && strcmp(username3, "NULL") ?
    username3 : "", 128);
  if (radius) {
    xwidth = zdepth = 2*radius;
    if (yheight && !strstr(Vars.option, "cylinder") && !strstr(Vars.option, "banana") && !strstr(Vars.option, "sphere"))
      strcat(Vars.option, " banana");
    else if (!yheight && !strstr(Vars.option ,"sphere")) {
      strcat(Vars.option, " sphere");
      yheight=2*radius;
    }
  }
  int offflag=0;
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) {
    if (!off_init(  geometry, xwidth, yheight, zdepth, 1, &offdata )) {
      printf("Monitor_nD: %s could not initiate the OFF geometry %s. \n"
             "            Defaulting to normal Monitor dimensions.\n",
             NAME_CURRENT_COMP, geometry);
      strcpy(geometry, "");
    } else {
      offflag=1;
    }
  }

  if (!radius && !xwidth && !yheight && !zdepth && !xmin && !xmax && !ymin && !ymax &&
    !strstr(Vars.option, "previous") && (!geometry || !strlen(geometry)))
    exit(printf("Monitor_nD: %s has no dimension specified. Aborting (radius, xwidth, yheight, zdepth, previous, geometry).\n", NAME_CURRENT_COMP));

  Monitor_nD_Init(&DEFS, &Vars, xwidth, yheight, zdepth, xmin,xmax,ymin,ymax,zmin,zmax,offflag);

  if (Vars.Flag_OFF) {
    offdata.mantidflag=Vars.Flag_mantid;
    offdata.mantidoffset=Vars.Coord_Min[Vars.Coord_Number-1];
  }


  if (filename && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
    strncpy(Vars.Mon_File, filename, 128);

  /* check if user given filename with ext will be used more than once */
  if ( ((Vars.Flag_Multiple && Vars.Coord_Number > 1) || Vars.Flag_List) && strchr(Vars.Mon_File,'.') )
  { char *XY; XY = strrchr(Vars.Mon_File,'.'); *XY='_'; }

  if (restore_neutron) Vars.Flag_parallel=1;
  detector.m = 0;

#ifdef USE_MPI
MPI_MASTER(
  if (strstr(Vars.option, "auto") && mpi_node_count > 1)
    printf("Monitor_nD: %s is using automatic limits option 'auto' together with MPI.\n"
           "WARNING     this may create incorrect distributions (but integrated flux will be right).\n", NAME_CURRENT_COMP);
);
#endif
}
#line 33450 "ILL_H15_D11.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component AlWindow5. */
  SIG_MESSAGE("AlWindow5 (Init)");

  /* Initializations for component VTEtoIN6GuideStart. */
  SIG_MESSAGE("VTEtoIN6GuideStart (Init)");

  /* Initializations for component sg1. */
  SIG_MESSAGE("sg1 (Init)");
#define mccompcurname  sg1
#define mccompcurtype  Guide_gravity
#define mccompcurindex 38
#define GVars mccsg1_GVars
#define pTable mccsg1_pTable
#define w1 mccsg1_w1
#define h1 mccsg1_h1
#define w2 mccsg1_w2
#define h2 mccsg1_h2
#define l mccsg1_l
#define R0 mccsg1_R0
#define Qc mccsg1_Qc
#define alpha mccsg1_alpha
#define m mccsg1_m
#define W mccsg1_W
#define nslit mccsg1_nslit
#define d mccsg1_d
#define mleft mccsg1_mleft
#define mright mccsg1_mright
#define mtop mccsg1_mtop
#define mbottom mccsg1_mbottom
#define nhslit mccsg1_nhslit
#define G mccsg1_G
#define aleft mccsg1_aleft
#define aright mccsg1_aright
#define atop mccsg1_atop
#define abottom mccsg1_abottom
#define wavy mccsg1_wavy
#define wavy_z mccsg1_wavy_z
#define wavy_tb mccsg1_wavy_tb
#define wavy_lr mccsg1_wavy_lr
#define chamfers mccsg1_chamfers
#define chamfers_z mccsg1_chamfers_z
#define chamfers_lr mccsg1_chamfers_lr
#define chamfers_tb mccsg1_chamfers_tb
#define nelements mccsg1_nelements
#define nu mccsg1_nu
#define phase mccsg1_phase
#define reflect mccsg1_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33582 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg2. */
  SIG_MESSAGE("sg2 (Init)");
#define mccompcurname  sg2
#define mccompcurtype  Guide_gravity
#define mccompcurindex 39
#define GVars mccsg2_GVars
#define pTable mccsg2_pTable
#define w1 mccsg2_w1
#define h1 mccsg2_h1
#define w2 mccsg2_w2
#define h2 mccsg2_h2
#define l mccsg2_l
#define R0 mccsg2_R0
#define Qc mccsg2_Qc
#define alpha mccsg2_alpha
#define m mccsg2_m
#define W mccsg2_W
#define nslit mccsg2_nslit
#define d mccsg2_d
#define mleft mccsg2_mleft
#define mright mccsg2_mright
#define mtop mccsg2_mtop
#define mbottom mccsg2_mbottom
#define nhslit mccsg2_nhslit
#define G mccsg2_G
#define aleft mccsg2_aleft
#define aright mccsg2_aright
#define atop mccsg2_atop
#define abottom mccsg2_abottom
#define wavy mccsg2_wavy
#define wavy_z mccsg2_wavy_z
#define wavy_tb mccsg2_wavy_tb
#define wavy_lr mccsg2_wavy_lr
#define chamfers mccsg2_chamfers
#define chamfers_z mccsg2_chamfers_z
#define chamfers_lr mccsg2_chamfers_lr
#define chamfers_tb mccsg2_chamfers_tb
#define nelements mccsg2_nelements
#define nu mccsg2_nu
#define phase mccsg2_phase
#define reflect mccsg2_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33716 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg3. */
  SIG_MESSAGE("sg3 (Init)");
#define mccompcurname  sg3
#define mccompcurtype  Guide_gravity
#define mccompcurindex 40
#define GVars mccsg3_GVars
#define pTable mccsg3_pTable
#define w1 mccsg3_w1
#define h1 mccsg3_h1
#define w2 mccsg3_w2
#define h2 mccsg3_h2
#define l mccsg3_l
#define R0 mccsg3_R0
#define Qc mccsg3_Qc
#define alpha mccsg3_alpha
#define m mccsg3_m
#define W mccsg3_W
#define nslit mccsg3_nslit
#define d mccsg3_d
#define mleft mccsg3_mleft
#define mright mccsg3_mright
#define mtop mccsg3_mtop
#define mbottom mccsg3_mbottom
#define nhslit mccsg3_nhslit
#define G mccsg3_G
#define aleft mccsg3_aleft
#define aright mccsg3_aright
#define atop mccsg3_atop
#define abottom mccsg3_abottom
#define wavy mccsg3_wavy
#define wavy_z mccsg3_wavy_z
#define wavy_tb mccsg3_wavy_tb
#define wavy_lr mccsg3_wavy_lr
#define chamfers mccsg3_chamfers
#define chamfers_z mccsg3_chamfers_z
#define chamfers_lr mccsg3_chamfers_lr
#define chamfers_tb mccsg3_chamfers_tb
#define nelements mccsg3_nelements
#define nu mccsg3_nu
#define phase mccsg3_phase
#define reflect mccsg3_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33850 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg4. */
  SIG_MESSAGE("sg4 (Init)");
#define mccompcurname  sg4
#define mccompcurtype  Guide_gravity
#define mccompcurindex 41
#define GVars mccsg4_GVars
#define pTable mccsg4_pTable
#define w1 mccsg4_w1
#define h1 mccsg4_h1
#define w2 mccsg4_w2
#define h2 mccsg4_h2
#define l mccsg4_l
#define R0 mccsg4_R0
#define Qc mccsg4_Qc
#define alpha mccsg4_alpha
#define m mccsg4_m
#define W mccsg4_W
#define nslit mccsg4_nslit
#define d mccsg4_d
#define mleft mccsg4_mleft
#define mright mccsg4_mright
#define mtop mccsg4_mtop
#define mbottom mccsg4_mbottom
#define nhslit mccsg4_nhslit
#define G mccsg4_G
#define aleft mccsg4_aleft
#define aright mccsg4_aright
#define atop mccsg4_atop
#define abottom mccsg4_abottom
#define wavy mccsg4_wavy
#define wavy_z mccsg4_wavy_z
#define wavy_tb mccsg4_wavy_tb
#define wavy_lr mccsg4_wavy_lr
#define chamfers mccsg4_chamfers
#define chamfers_z mccsg4_chamfers_z
#define chamfers_lr mccsg4_chamfers_lr
#define chamfers_tb mccsg4_chamfers_tb
#define nelements mccsg4_nelements
#define nu mccsg4_nu
#define phase mccsg4_phase
#define reflect mccsg4_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 33984 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg5. */
  SIG_MESSAGE("sg5 (Init)");
#define mccompcurname  sg5
#define mccompcurtype  Guide_gravity
#define mccompcurindex 42
#define GVars mccsg5_GVars
#define pTable mccsg5_pTable
#define w1 mccsg5_w1
#define h1 mccsg5_h1
#define w2 mccsg5_w2
#define h2 mccsg5_h2
#define l mccsg5_l
#define R0 mccsg5_R0
#define Qc mccsg5_Qc
#define alpha mccsg5_alpha
#define m mccsg5_m
#define W mccsg5_W
#define nslit mccsg5_nslit
#define d mccsg5_d
#define mleft mccsg5_mleft
#define mright mccsg5_mright
#define mtop mccsg5_mtop
#define mbottom mccsg5_mbottom
#define nhslit mccsg5_nhslit
#define G mccsg5_G
#define aleft mccsg5_aleft
#define aright mccsg5_aright
#define atop mccsg5_atop
#define abottom mccsg5_abottom
#define wavy mccsg5_wavy
#define wavy_z mccsg5_wavy_z
#define wavy_tb mccsg5_wavy_tb
#define wavy_lr mccsg5_wavy_lr
#define chamfers mccsg5_chamfers
#define chamfers_z mccsg5_chamfers_z
#define chamfers_lr mccsg5_chamfers_lr
#define chamfers_tb mccsg5_chamfers_tb
#define nelements mccsg5_nelements
#define nu mccsg5_nu
#define phase mccsg5_phase
#define reflect mccsg5_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34118 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg6. */
  SIG_MESSAGE("sg6 (Init)");
#define mccompcurname  sg6
#define mccompcurtype  Guide_gravity
#define mccompcurindex 43
#define GVars mccsg6_GVars
#define pTable mccsg6_pTable
#define w1 mccsg6_w1
#define h1 mccsg6_h1
#define w2 mccsg6_w2
#define h2 mccsg6_h2
#define l mccsg6_l
#define R0 mccsg6_R0
#define Qc mccsg6_Qc
#define alpha mccsg6_alpha
#define m mccsg6_m
#define W mccsg6_W
#define nslit mccsg6_nslit
#define d mccsg6_d
#define mleft mccsg6_mleft
#define mright mccsg6_mright
#define mtop mccsg6_mtop
#define mbottom mccsg6_mbottom
#define nhslit mccsg6_nhslit
#define G mccsg6_G
#define aleft mccsg6_aleft
#define aright mccsg6_aright
#define atop mccsg6_atop
#define abottom mccsg6_abottom
#define wavy mccsg6_wavy
#define wavy_z mccsg6_wavy_z
#define wavy_tb mccsg6_wavy_tb
#define wavy_lr mccsg6_wavy_lr
#define chamfers mccsg6_chamfers
#define chamfers_z mccsg6_chamfers_z
#define chamfers_lr mccsg6_chamfers_lr
#define chamfers_tb mccsg6_chamfers_tb
#define nelements mccsg6_nelements
#define nu mccsg6_nu
#define phase mccsg6_phase
#define reflect mccsg6_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34252 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg7. */
  SIG_MESSAGE("sg7 (Init)");
#define mccompcurname  sg7
#define mccompcurtype  Guide_gravity
#define mccompcurindex 44
#define GVars mccsg7_GVars
#define pTable mccsg7_pTable
#define w1 mccsg7_w1
#define h1 mccsg7_h1
#define w2 mccsg7_w2
#define h2 mccsg7_h2
#define l mccsg7_l
#define R0 mccsg7_R0
#define Qc mccsg7_Qc
#define alpha mccsg7_alpha
#define m mccsg7_m
#define W mccsg7_W
#define nslit mccsg7_nslit
#define d mccsg7_d
#define mleft mccsg7_mleft
#define mright mccsg7_mright
#define mtop mccsg7_mtop
#define mbottom mccsg7_mbottom
#define nhslit mccsg7_nhslit
#define G mccsg7_G
#define aleft mccsg7_aleft
#define aright mccsg7_aright
#define atop mccsg7_atop
#define abottom mccsg7_abottom
#define wavy mccsg7_wavy
#define wavy_z mccsg7_wavy_z
#define wavy_tb mccsg7_wavy_tb
#define wavy_lr mccsg7_wavy_lr
#define chamfers mccsg7_chamfers
#define chamfers_z mccsg7_chamfers_z
#define chamfers_lr mccsg7_chamfers_lr
#define chamfers_tb mccsg7_chamfers_tb
#define nelements mccsg7_nelements
#define nu mccsg7_nu
#define phase mccsg7_phase
#define reflect mccsg7_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34386 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg8. */
  SIG_MESSAGE("sg8 (Init)");
#define mccompcurname  sg8
#define mccompcurtype  Guide_gravity
#define mccompcurindex 45
#define GVars mccsg8_GVars
#define pTable mccsg8_pTable
#define w1 mccsg8_w1
#define h1 mccsg8_h1
#define w2 mccsg8_w2
#define h2 mccsg8_h2
#define l mccsg8_l
#define R0 mccsg8_R0
#define Qc mccsg8_Qc
#define alpha mccsg8_alpha
#define m mccsg8_m
#define W mccsg8_W
#define nslit mccsg8_nslit
#define d mccsg8_d
#define mleft mccsg8_mleft
#define mright mccsg8_mright
#define mtop mccsg8_mtop
#define mbottom mccsg8_mbottom
#define nhslit mccsg8_nhslit
#define G mccsg8_G
#define aleft mccsg8_aleft
#define aright mccsg8_aright
#define atop mccsg8_atop
#define abottom mccsg8_abottom
#define wavy mccsg8_wavy
#define wavy_z mccsg8_wavy_z
#define wavy_tb mccsg8_wavy_tb
#define wavy_lr mccsg8_wavy_lr
#define chamfers mccsg8_chamfers
#define chamfers_z mccsg8_chamfers_z
#define chamfers_lr mccsg8_chamfers_lr
#define chamfers_tb mccsg8_chamfers_tb
#define nelements mccsg8_nelements
#define nu mccsg8_nu
#define phase mccsg8_phase
#define reflect mccsg8_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34520 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg9. */
  SIG_MESSAGE("sg9 (Init)");
#define mccompcurname  sg9
#define mccompcurtype  Guide_gravity
#define mccompcurindex 46
#define GVars mccsg9_GVars
#define pTable mccsg9_pTable
#define w1 mccsg9_w1
#define h1 mccsg9_h1
#define w2 mccsg9_w2
#define h2 mccsg9_h2
#define l mccsg9_l
#define R0 mccsg9_R0
#define Qc mccsg9_Qc
#define alpha mccsg9_alpha
#define m mccsg9_m
#define W mccsg9_W
#define nslit mccsg9_nslit
#define d mccsg9_d
#define mleft mccsg9_mleft
#define mright mccsg9_mright
#define mtop mccsg9_mtop
#define mbottom mccsg9_mbottom
#define nhslit mccsg9_nhslit
#define G mccsg9_G
#define aleft mccsg9_aleft
#define aright mccsg9_aright
#define atop mccsg9_atop
#define abottom mccsg9_abottom
#define wavy mccsg9_wavy
#define wavy_z mccsg9_wavy_z
#define wavy_tb mccsg9_wavy_tb
#define wavy_lr mccsg9_wavy_lr
#define chamfers mccsg9_chamfers
#define chamfers_z mccsg9_chamfers_z
#define chamfers_lr mccsg9_chamfers_lr
#define chamfers_tb mccsg9_chamfers_tb
#define nelements mccsg9_nelements
#define nu mccsg9_nu
#define phase mccsg9_phase
#define reflect mccsg9_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34654 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg10. */
  SIG_MESSAGE("sg10 (Init)");
#define mccompcurname  sg10
#define mccompcurtype  Guide_gravity
#define mccompcurindex 47
#define GVars mccsg10_GVars
#define pTable mccsg10_pTable
#define w1 mccsg10_w1
#define h1 mccsg10_h1
#define w2 mccsg10_w2
#define h2 mccsg10_h2
#define l mccsg10_l
#define R0 mccsg10_R0
#define Qc mccsg10_Qc
#define alpha mccsg10_alpha
#define m mccsg10_m
#define W mccsg10_W
#define nslit mccsg10_nslit
#define d mccsg10_d
#define mleft mccsg10_mleft
#define mright mccsg10_mright
#define mtop mccsg10_mtop
#define mbottom mccsg10_mbottom
#define nhslit mccsg10_nhslit
#define G mccsg10_G
#define aleft mccsg10_aleft
#define aright mccsg10_aright
#define atop mccsg10_atop
#define abottom mccsg10_abottom
#define wavy mccsg10_wavy
#define wavy_z mccsg10_wavy_z
#define wavy_tb mccsg10_wavy_tb
#define wavy_lr mccsg10_wavy_lr
#define chamfers mccsg10_chamfers
#define chamfers_z mccsg10_chamfers_z
#define chamfers_lr mccsg10_chamfers_lr
#define chamfers_tb mccsg10_chamfers_tb
#define nelements mccsg10_nelements
#define nu mccsg10_nu
#define phase mccsg10_phase
#define reflect mccsg10_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34788 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg11. */
  SIG_MESSAGE("sg11 (Init)");
#define mccompcurname  sg11
#define mccompcurtype  Guide_gravity
#define mccompcurindex 48
#define GVars mccsg11_GVars
#define pTable mccsg11_pTable
#define w1 mccsg11_w1
#define h1 mccsg11_h1
#define w2 mccsg11_w2
#define h2 mccsg11_h2
#define l mccsg11_l
#define R0 mccsg11_R0
#define Qc mccsg11_Qc
#define alpha mccsg11_alpha
#define m mccsg11_m
#define W mccsg11_W
#define nslit mccsg11_nslit
#define d mccsg11_d
#define mleft mccsg11_mleft
#define mright mccsg11_mright
#define mtop mccsg11_mtop
#define mbottom mccsg11_mbottom
#define nhslit mccsg11_nhslit
#define G mccsg11_G
#define aleft mccsg11_aleft
#define aright mccsg11_aright
#define atop mccsg11_atop
#define abottom mccsg11_abottom
#define wavy mccsg11_wavy
#define wavy_z mccsg11_wavy_z
#define wavy_tb mccsg11_wavy_tb
#define wavy_lr mccsg11_wavy_lr
#define chamfers mccsg11_chamfers
#define chamfers_z mccsg11_chamfers_z
#define chamfers_lr mccsg11_chamfers_lr
#define chamfers_tb mccsg11_chamfers_tb
#define nelements mccsg11_nelements
#define nu mccsg11_nu
#define phase mccsg11_phase
#define reflect mccsg11_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 34922 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg12. */
  SIG_MESSAGE("sg12 (Init)");
#define mccompcurname  sg12
#define mccompcurtype  Guide_gravity
#define mccompcurindex 49
#define GVars mccsg12_GVars
#define pTable mccsg12_pTable
#define w1 mccsg12_w1
#define h1 mccsg12_h1
#define w2 mccsg12_w2
#define h2 mccsg12_h2
#define l mccsg12_l
#define R0 mccsg12_R0
#define Qc mccsg12_Qc
#define alpha mccsg12_alpha
#define m mccsg12_m
#define W mccsg12_W
#define nslit mccsg12_nslit
#define d mccsg12_d
#define mleft mccsg12_mleft
#define mright mccsg12_mright
#define mtop mccsg12_mtop
#define mbottom mccsg12_mbottom
#define nhslit mccsg12_nhslit
#define G mccsg12_G
#define aleft mccsg12_aleft
#define aright mccsg12_aright
#define atop mccsg12_atop
#define abottom mccsg12_abottom
#define wavy mccsg12_wavy
#define wavy_z mccsg12_wavy_z
#define wavy_tb mccsg12_wavy_tb
#define wavy_lr mccsg12_wavy_lr
#define chamfers mccsg12_chamfers
#define chamfers_z mccsg12_chamfers_z
#define chamfers_lr mccsg12_chamfers_lr
#define chamfers_tb mccsg12_chamfers_tb
#define nelements mccsg12_nelements
#define nu mccsg12_nu
#define phase mccsg12_phase
#define reflect mccsg12_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 35056 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg13. */
  SIG_MESSAGE("sg13 (Init)");
#define mccompcurname  sg13
#define mccompcurtype  Guide_gravity
#define mccompcurindex 50
#define GVars mccsg13_GVars
#define pTable mccsg13_pTable
#define w1 mccsg13_w1
#define h1 mccsg13_h1
#define w2 mccsg13_w2
#define h2 mccsg13_h2
#define l mccsg13_l
#define R0 mccsg13_R0
#define Qc mccsg13_Qc
#define alpha mccsg13_alpha
#define m mccsg13_m
#define W mccsg13_W
#define nslit mccsg13_nslit
#define d mccsg13_d
#define mleft mccsg13_mleft
#define mright mccsg13_mright
#define mtop mccsg13_mtop
#define mbottom mccsg13_mbottom
#define nhslit mccsg13_nhslit
#define G mccsg13_G
#define aleft mccsg13_aleft
#define aright mccsg13_aright
#define atop mccsg13_atop
#define abottom mccsg13_abottom
#define wavy mccsg13_wavy
#define wavy_z mccsg13_wavy_z
#define wavy_tb mccsg13_wavy_tb
#define wavy_lr mccsg13_wavy_lr
#define chamfers mccsg13_chamfers
#define chamfers_z mccsg13_chamfers_z
#define chamfers_lr mccsg13_chamfers_lr
#define chamfers_tb mccsg13_chamfers_tb
#define nelements mccsg13_nelements
#define nu mccsg13_nu
#define phase mccsg13_phase
#define reflect mccsg13_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 35190 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg14. */
  SIG_MESSAGE("sg14 (Init)");
#define mccompcurname  sg14
#define mccompcurtype  Guide_gravity
#define mccompcurindex 51
#define GVars mccsg14_GVars
#define pTable mccsg14_pTable
#define w1 mccsg14_w1
#define h1 mccsg14_h1
#define w2 mccsg14_w2
#define h2 mccsg14_h2
#define l mccsg14_l
#define R0 mccsg14_R0
#define Qc mccsg14_Qc
#define alpha mccsg14_alpha
#define m mccsg14_m
#define W mccsg14_W
#define nslit mccsg14_nslit
#define d mccsg14_d
#define mleft mccsg14_mleft
#define mright mccsg14_mright
#define mtop mccsg14_mtop
#define mbottom mccsg14_mbottom
#define nhslit mccsg14_nhslit
#define G mccsg14_G
#define aleft mccsg14_aleft
#define aright mccsg14_aright
#define atop mccsg14_atop
#define abottom mccsg14_abottom
#define wavy mccsg14_wavy
#define wavy_z mccsg14_wavy_z
#define wavy_tb mccsg14_wavy_tb
#define wavy_lr mccsg14_wavy_lr
#define chamfers mccsg14_chamfers
#define chamfers_z mccsg14_chamfers_z
#define chamfers_lr mccsg14_chamfers_lr
#define chamfers_tb mccsg14_chamfers_tb
#define nelements mccsg14_nelements
#define nu mccsg14_nu
#define phase mccsg14_phase
#define reflect mccsg14_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 35324 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg15. */
  SIG_MESSAGE("sg15 (Init)");
#define mccompcurname  sg15
#define mccompcurtype  Guide_gravity
#define mccompcurindex 52
#define GVars mccsg15_GVars
#define pTable mccsg15_pTable
#define w1 mccsg15_w1
#define h1 mccsg15_h1
#define w2 mccsg15_w2
#define h2 mccsg15_h2
#define l mccsg15_l
#define R0 mccsg15_R0
#define Qc mccsg15_Qc
#define alpha mccsg15_alpha
#define m mccsg15_m
#define W mccsg15_W
#define nslit mccsg15_nslit
#define d mccsg15_d
#define mleft mccsg15_mleft
#define mright mccsg15_mright
#define mtop mccsg15_mtop
#define mbottom mccsg15_mbottom
#define nhslit mccsg15_nhslit
#define G mccsg15_G
#define aleft mccsg15_aleft
#define aright mccsg15_aright
#define atop mccsg15_atop
#define abottom mccsg15_abottom
#define wavy mccsg15_wavy
#define wavy_z mccsg15_wavy_z
#define wavy_tb mccsg15_wavy_tb
#define wavy_lr mccsg15_wavy_lr
#define chamfers mccsg15_chamfers
#define chamfers_z mccsg15_chamfers_z
#define chamfers_lr mccsg15_chamfers_lr
#define chamfers_tb mccsg15_chamfers_tb
#define nelements mccsg15_nelements
#define nu mccsg15_nu
#define phase mccsg15_phase
#define reflect mccsg15_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 35458 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg16. */
  SIG_MESSAGE("sg16 (Init)");
#define mccompcurname  sg16
#define mccompcurtype  Guide_gravity
#define mccompcurindex 53
#define GVars mccsg16_GVars
#define pTable mccsg16_pTable
#define w1 mccsg16_w1
#define h1 mccsg16_h1
#define w2 mccsg16_w2
#define h2 mccsg16_h2
#define l mccsg16_l
#define R0 mccsg16_R0
#define Qc mccsg16_Qc
#define alpha mccsg16_alpha
#define m mccsg16_m
#define W mccsg16_W
#define nslit mccsg16_nslit
#define d mccsg16_d
#define mleft mccsg16_mleft
#define mright mccsg16_mright
#define mtop mccsg16_mtop
#define mbottom mccsg16_mbottom
#define nhslit mccsg16_nhslit
#define G mccsg16_G
#define aleft mccsg16_aleft
#define aright mccsg16_aright
#define atop mccsg16_atop
#define abottom mccsg16_abottom
#define wavy mccsg16_wavy
#define wavy_z mccsg16_wavy_z
#define wavy_tb mccsg16_wavy_tb
#define wavy_lr mccsg16_wavy_lr
#define chamfers mccsg16_chamfers
#define chamfers_z mccsg16_chamfers_z
#define chamfers_lr mccsg16_chamfers_lr
#define chamfers_tb mccsg16_chamfers_tb
#define nelements mccsg16_nelements
#define nu mccsg16_nu
#define phase mccsg16_phase
#define reflect mccsg16_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 35592 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg17. */
  SIG_MESSAGE("sg17 (Init)");
#define mccompcurname  sg17
#define mccompcurtype  Guide_gravity
#define mccompcurindex 54
#define GVars mccsg17_GVars
#define pTable mccsg17_pTable
#define w1 mccsg17_w1
#define h1 mccsg17_h1
#define w2 mccsg17_w2
#define h2 mccsg17_h2
#define l mccsg17_l
#define R0 mccsg17_R0
#define Qc mccsg17_Qc
#define alpha mccsg17_alpha
#define m mccsg17_m
#define W mccsg17_W
#define nslit mccsg17_nslit
#define d mccsg17_d
#define mleft mccsg17_mleft
#define mright mccsg17_mright
#define mtop mccsg17_mtop
#define mbottom mccsg17_mbottom
#define nhslit mccsg17_nhslit
#define G mccsg17_G
#define aleft mccsg17_aleft
#define aright mccsg17_aright
#define atop mccsg17_atop
#define abottom mccsg17_abottom
#define wavy mccsg17_wavy
#define wavy_z mccsg17_wavy_z
#define wavy_tb mccsg17_wavy_tb
#define wavy_lr mccsg17_wavy_lr
#define chamfers mccsg17_chamfers
#define chamfers_z mccsg17_chamfers_z
#define chamfers_lr mccsg17_chamfers_lr
#define chamfers_tb mccsg17_chamfers_tb
#define nelements mccsg17_nelements
#define nu mccsg17_nu
#define phase mccsg17_phase
#define reflect mccsg17_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 35726 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg18. */
  SIG_MESSAGE("sg18 (Init)");
#define mccompcurname  sg18
#define mccompcurtype  Guide_gravity
#define mccompcurindex 55
#define GVars mccsg18_GVars
#define pTable mccsg18_pTable
#define w1 mccsg18_w1
#define h1 mccsg18_h1
#define w2 mccsg18_w2
#define h2 mccsg18_h2
#define l mccsg18_l
#define R0 mccsg18_R0
#define Qc mccsg18_Qc
#define alpha mccsg18_alpha
#define m mccsg18_m
#define W mccsg18_W
#define nslit mccsg18_nslit
#define d mccsg18_d
#define mleft mccsg18_mleft
#define mright mccsg18_mright
#define mtop mccsg18_mtop
#define mbottom mccsg18_mbottom
#define nhslit mccsg18_nhslit
#define G mccsg18_G
#define aleft mccsg18_aleft
#define aright mccsg18_aright
#define atop mccsg18_atop
#define abottom mccsg18_abottom
#define wavy mccsg18_wavy
#define wavy_z mccsg18_wavy_z
#define wavy_tb mccsg18_wavy_tb
#define wavy_lr mccsg18_wavy_lr
#define chamfers mccsg18_chamfers
#define chamfers_z mccsg18_chamfers_z
#define chamfers_lr mccsg18_chamfers_lr
#define chamfers_tb mccsg18_chamfers_tb
#define nelements mccsg18_nelements
#define nu mccsg18_nu
#define phase mccsg18_phase
#define reflect mccsg18_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 35860 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg19. */
  SIG_MESSAGE("sg19 (Init)");
#define mccompcurname  sg19
#define mccompcurtype  Guide_gravity
#define mccompcurindex 56
#define GVars mccsg19_GVars
#define pTable mccsg19_pTable
#define w1 mccsg19_w1
#define h1 mccsg19_h1
#define w2 mccsg19_w2
#define h2 mccsg19_h2
#define l mccsg19_l
#define R0 mccsg19_R0
#define Qc mccsg19_Qc
#define alpha mccsg19_alpha
#define m mccsg19_m
#define W mccsg19_W
#define nslit mccsg19_nslit
#define d mccsg19_d
#define mleft mccsg19_mleft
#define mright mccsg19_mright
#define mtop mccsg19_mtop
#define mbottom mccsg19_mbottom
#define nhslit mccsg19_nhslit
#define G mccsg19_G
#define aleft mccsg19_aleft
#define aright mccsg19_aright
#define atop mccsg19_atop
#define abottom mccsg19_abottom
#define wavy mccsg19_wavy
#define wavy_z mccsg19_wavy_z
#define wavy_tb mccsg19_wavy_tb
#define wavy_lr mccsg19_wavy_lr
#define chamfers mccsg19_chamfers
#define chamfers_z mccsg19_chamfers_z
#define chamfers_lr mccsg19_chamfers_lr
#define chamfers_tb mccsg19_chamfers_tb
#define nelements mccsg19_nelements
#define nu mccsg19_nu
#define phase mccsg19_phase
#define reflect mccsg19_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 35994 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg20. */
  SIG_MESSAGE("sg20 (Init)");
#define mccompcurname  sg20
#define mccompcurtype  Guide_gravity
#define mccompcurindex 57
#define GVars mccsg20_GVars
#define pTable mccsg20_pTable
#define w1 mccsg20_w1
#define h1 mccsg20_h1
#define w2 mccsg20_w2
#define h2 mccsg20_h2
#define l mccsg20_l
#define R0 mccsg20_R0
#define Qc mccsg20_Qc
#define alpha mccsg20_alpha
#define m mccsg20_m
#define W mccsg20_W
#define nslit mccsg20_nslit
#define d mccsg20_d
#define mleft mccsg20_mleft
#define mright mccsg20_mright
#define mtop mccsg20_mtop
#define mbottom mccsg20_mbottom
#define nhslit mccsg20_nhslit
#define G mccsg20_G
#define aleft mccsg20_aleft
#define aright mccsg20_aright
#define atop mccsg20_atop
#define abottom mccsg20_abottom
#define wavy mccsg20_wavy
#define wavy_z mccsg20_wavy_z
#define wavy_tb mccsg20_wavy_tb
#define wavy_lr mccsg20_wavy_lr
#define chamfers mccsg20_chamfers
#define chamfers_z mccsg20_chamfers_z
#define chamfers_lr mccsg20_chamfers_lr
#define chamfers_tb mccsg20_chamfers_tb
#define nelements mccsg20_nelements
#define nu mccsg20_nu
#define phase mccsg20_phase
#define reflect mccsg20_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 36128 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg21. */
  SIG_MESSAGE("sg21 (Init)");
#define mccompcurname  sg21
#define mccompcurtype  Guide_gravity
#define mccompcurindex 58
#define GVars mccsg21_GVars
#define pTable mccsg21_pTable
#define w1 mccsg21_w1
#define h1 mccsg21_h1
#define w2 mccsg21_w2
#define h2 mccsg21_h2
#define l mccsg21_l
#define R0 mccsg21_R0
#define Qc mccsg21_Qc
#define alpha mccsg21_alpha
#define m mccsg21_m
#define W mccsg21_W
#define nslit mccsg21_nslit
#define d mccsg21_d
#define mleft mccsg21_mleft
#define mright mccsg21_mright
#define mtop mccsg21_mtop
#define mbottom mccsg21_mbottom
#define nhslit mccsg21_nhslit
#define G mccsg21_G
#define aleft mccsg21_aleft
#define aright mccsg21_aright
#define atop mccsg21_atop
#define abottom mccsg21_abottom
#define wavy mccsg21_wavy
#define wavy_z mccsg21_wavy_z
#define wavy_tb mccsg21_wavy_tb
#define wavy_lr mccsg21_wavy_lr
#define chamfers mccsg21_chamfers
#define chamfers_z mccsg21_chamfers_z
#define chamfers_lr mccsg21_chamfers_lr
#define chamfers_tb mccsg21_chamfers_tb
#define nelements mccsg21_nelements
#define nu mccsg21_nu
#define phase mccsg21_phase
#define reflect mccsg21_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 36262 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg22. */
  SIG_MESSAGE("sg22 (Init)");
#define mccompcurname  sg22
#define mccompcurtype  Guide_gravity
#define mccompcurindex 59
#define GVars mccsg22_GVars
#define pTable mccsg22_pTable
#define w1 mccsg22_w1
#define h1 mccsg22_h1
#define w2 mccsg22_w2
#define h2 mccsg22_h2
#define l mccsg22_l
#define R0 mccsg22_R0
#define Qc mccsg22_Qc
#define alpha mccsg22_alpha
#define m mccsg22_m
#define W mccsg22_W
#define nslit mccsg22_nslit
#define d mccsg22_d
#define mleft mccsg22_mleft
#define mright mccsg22_mright
#define mtop mccsg22_mtop
#define mbottom mccsg22_mbottom
#define nhslit mccsg22_nhslit
#define G mccsg22_G
#define aleft mccsg22_aleft
#define aright mccsg22_aright
#define atop mccsg22_atop
#define abottom mccsg22_abottom
#define wavy mccsg22_wavy
#define wavy_z mccsg22_wavy_z
#define wavy_tb mccsg22_wavy_tb
#define wavy_lr mccsg22_wavy_lr
#define chamfers mccsg22_chamfers
#define chamfers_z mccsg22_chamfers_z
#define chamfers_lr mccsg22_chamfers_lr
#define chamfers_tb mccsg22_chamfers_tb
#define nelements mccsg22_nelements
#define nu mccsg22_nu
#define phase mccsg22_phase
#define reflect mccsg22_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 36396 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component AlWindow6. */
  SIG_MESSAGE("AlWindow6 (Init)");

  /* Initializations for component PSD_IN6. */
  SIG_MESSAGE("PSD_IN6 (Init)");
#define mccompcurname  PSD_IN6
#define mccompcurtype  Monitor_nD
#define mccompcurindex 61
#define user1 mccPSD_IN6_user1
#define user2 mccPSD_IN6_user2
#define user3 mccPSD_IN6_user3
#define DEFS mccPSD_IN6_DEFS
#define Vars mccPSD_IN6_Vars
#define detector mccPSD_IN6_detector
#define offdata mccPSD_IN6_offdata
#define xwidth mccPSD_IN6_xwidth
#define yheight mccPSD_IN6_yheight
#define zdepth mccPSD_IN6_zdepth
#define xmin mccPSD_IN6_xmin
#define xmax mccPSD_IN6_xmax
#define ymin mccPSD_IN6_ymin
#define ymax mccPSD_IN6_ymax
#define zmin mccPSD_IN6_zmin
#define zmax mccPSD_IN6_zmax
#define bins mccPSD_IN6_bins
#define min mccPSD_IN6_min
#define max mccPSD_IN6_max
#define restore_neutron mccPSD_IN6_restore_neutron
#define radius mccPSD_IN6_radius
#define options mccPSD_IN6_options
#define filename mccPSD_IN6_filename
#define geometry mccPSD_IN6_geometry
#define username1 mccPSD_IN6_username1
#define username2 mccPSD_IN6_username2
#define username3 mccPSD_IN6_username3
#define nowritefile mccPSD_IN6_nowritefile
#line 231 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  char tmp[CHAR_BUF_LENGTH];
  strcpy(Vars.compcurname, NAME_CURRENT_COMP);
  if (options != NULL)
    strncpy(Vars.option, options, CHAR_BUF_LENGTH);
  else {
    strcpy(Vars.option, "x y");
    printf("Monitor_nD: %s has no option specified. Setting to PSD ('x y') monitor.\n", NAME_CURRENT_COMP);
  }
  Vars.compcurpos = POS_A_CURRENT_COMP;

  if (strstr(Vars.option, "source"))
    strcat(Vars.option, " list, x y z vx vy vz t sx sy sz ");

  if (bins) { sprintf(tmp, " all bins=%ld ", (long)bins); strcat(Vars.option, tmp); }
  if (min > -FLT_MAX && max < FLT_MAX) { sprintf(tmp, " all limits=[%g %g]", min, max); strcat(Vars.option, tmp); }
  else if (min > -FLT_MAX) { sprintf(tmp, " all min=%g", min); strcat(Vars.option, tmp); }
  else if (max <  FLT_MAX) { sprintf(tmp, " all max=%g", max); strcat(Vars.option, tmp); }

  strncpy(Vars.UserName1,
    username1 && strlen(username1) && strcmp(username1, "0") && strcmp(username1, "NULL") ?
    username1 : "", 128);
  strncpy(Vars.UserName2,
    username2 && strlen(username2) && strcmp(username2, "0") && strcmp(username2, "NULL") ?
    username2 : "", 128);
  strncpy(Vars.UserName3,
    username3 && strlen(username3) && strcmp(username3, "0") && strcmp(username3, "NULL") ?
    username3 : "", 128);
  if (radius) {
    xwidth = zdepth = 2*radius;
    if (yheight && !strstr(Vars.option, "cylinder") && !strstr(Vars.option, "banana") && !strstr(Vars.option, "sphere"))
      strcat(Vars.option, " banana");
    else if (!yheight && !strstr(Vars.option ,"sphere")) {
      strcat(Vars.option, " sphere");
      yheight=2*radius;
    }
  }
  int offflag=0;
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) {
    if (!off_init(  geometry, xwidth, yheight, zdepth, 1, &offdata )) {
      printf("Monitor_nD: %s could not initiate the OFF geometry %s. \n"
             "            Defaulting to normal Monitor dimensions.\n",
             NAME_CURRENT_COMP, geometry);
      strcpy(geometry, "");
    } else {
      offflag=1;
    }
  }

  if (!radius && !xwidth && !yheight && !zdepth && !xmin && !xmax && !ymin && !ymax &&
    !strstr(Vars.option, "previous") && (!geometry || !strlen(geometry)))
    exit(printf("Monitor_nD: %s has no dimension specified. Aborting (radius, xwidth, yheight, zdepth, previous, geometry).\n", NAME_CURRENT_COMP));

  Monitor_nD_Init(&DEFS, &Vars, xwidth, yheight, zdepth, xmin,xmax,ymin,ymax,zmin,zmax,offflag);

  if (Vars.Flag_OFF) {
    offdata.mantidflag=Vars.Flag_mantid;
    offdata.mantidoffset=Vars.Coord_Min[Vars.Coord_Number-1];
  }


  if (filename && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
    strncpy(Vars.Mon_File, filename, 128);

  /* check if user given filename with ext will be used more than once */
  if ( ((Vars.Flag_Multiple && Vars.Coord_Number > 1) || Vars.Flag_List) && strchr(Vars.Mon_File,'.') )
  { char *XY; XY = strrchr(Vars.Mon_File,'.'); *XY='_'; }

  if (restore_neutron) Vars.Flag_parallel=1;
  detector.m = 0;

#ifdef USE_MPI
MPI_MASTER(
  if (strstr(Vars.option, "auto") && mpi_node_count > 1)
    printf("Monitor_nD: %s is using automatic limits option 'auto' together with MPI.\n"
           "WARNING     this may create incorrect distributions (but integrated flux will be right).\n", NAME_CURRENT_COMP);
);
#endif
}
#line 36553 "ILL_H15_D11.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component AlWindow7. */
  SIG_MESSAGE("AlWindow7 (Init)");

  /* Initializations for component IN6toD7GuideStart. */
  SIG_MESSAGE("IN6toD7GuideStart (Init)");

  /* Initializations for component sg23. */
  SIG_MESSAGE("sg23 (Init)");
#define mccompcurname  sg23
#define mccompcurtype  Guide_gravity
#define mccompcurindex 64
#define GVars mccsg23_GVars
#define pTable mccsg23_pTable
#define w1 mccsg23_w1
#define h1 mccsg23_h1
#define w2 mccsg23_w2
#define h2 mccsg23_h2
#define l mccsg23_l
#define R0 mccsg23_R0
#define Qc mccsg23_Qc
#define alpha mccsg23_alpha
#define m mccsg23_m
#define W mccsg23_W
#define nslit mccsg23_nslit
#define d mccsg23_d
#define mleft mccsg23_mleft
#define mright mccsg23_mright
#define mtop mccsg23_mtop
#define mbottom mccsg23_mbottom
#define nhslit mccsg23_nhslit
#define G mccsg23_G
#define aleft mccsg23_aleft
#define aright mccsg23_aright
#define atop mccsg23_atop
#define abottom mccsg23_abottom
#define wavy mccsg23_wavy
#define wavy_z mccsg23_wavy_z
#define wavy_tb mccsg23_wavy_tb
#define wavy_lr mccsg23_wavy_lr
#define chamfers mccsg23_chamfers
#define chamfers_z mccsg23_chamfers_z
#define chamfers_lr mccsg23_chamfers_lr
#define chamfers_tb mccsg23_chamfers_tb
#define nelements mccsg23_nelements
#define nu mccsg23_nu
#define phase mccsg23_phase
#define reflect mccsg23_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 36685 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg24. */
  SIG_MESSAGE("sg24 (Init)");
#define mccompcurname  sg24
#define mccompcurtype  Guide_gravity
#define mccompcurindex 65
#define GVars mccsg24_GVars
#define pTable mccsg24_pTable
#define w1 mccsg24_w1
#define h1 mccsg24_h1
#define w2 mccsg24_w2
#define h2 mccsg24_h2
#define l mccsg24_l
#define R0 mccsg24_R0
#define Qc mccsg24_Qc
#define alpha mccsg24_alpha
#define m mccsg24_m
#define W mccsg24_W
#define nslit mccsg24_nslit
#define d mccsg24_d
#define mleft mccsg24_mleft
#define mright mccsg24_mright
#define mtop mccsg24_mtop
#define mbottom mccsg24_mbottom
#define nhslit mccsg24_nhslit
#define G mccsg24_G
#define aleft mccsg24_aleft
#define aright mccsg24_aright
#define atop mccsg24_atop
#define abottom mccsg24_abottom
#define wavy mccsg24_wavy
#define wavy_z mccsg24_wavy_z
#define wavy_tb mccsg24_wavy_tb
#define wavy_lr mccsg24_wavy_lr
#define chamfers mccsg24_chamfers
#define chamfers_z mccsg24_chamfers_z
#define chamfers_lr mccsg24_chamfers_lr
#define chamfers_tb mccsg24_chamfers_tb
#define nelements mccsg24_nelements
#define nu mccsg24_nu
#define phase mccsg24_phase
#define reflect mccsg24_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 36819 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg25. */
  SIG_MESSAGE("sg25 (Init)");
#define mccompcurname  sg25
#define mccompcurtype  Guide_gravity
#define mccompcurindex 66
#define GVars mccsg25_GVars
#define pTable mccsg25_pTable
#define w1 mccsg25_w1
#define h1 mccsg25_h1
#define w2 mccsg25_w2
#define h2 mccsg25_h2
#define l mccsg25_l
#define R0 mccsg25_R0
#define Qc mccsg25_Qc
#define alpha mccsg25_alpha
#define m mccsg25_m
#define W mccsg25_W
#define nslit mccsg25_nslit
#define d mccsg25_d
#define mleft mccsg25_mleft
#define mright mccsg25_mright
#define mtop mccsg25_mtop
#define mbottom mccsg25_mbottom
#define nhslit mccsg25_nhslit
#define G mccsg25_G
#define aleft mccsg25_aleft
#define aright mccsg25_aright
#define atop mccsg25_atop
#define abottom mccsg25_abottom
#define wavy mccsg25_wavy
#define wavy_z mccsg25_wavy_z
#define wavy_tb mccsg25_wavy_tb
#define wavy_lr mccsg25_wavy_lr
#define chamfers mccsg25_chamfers
#define chamfers_z mccsg25_chamfers_z
#define chamfers_lr mccsg25_chamfers_lr
#define chamfers_tb mccsg25_chamfers_tb
#define nelements mccsg25_nelements
#define nu mccsg25_nu
#define phase mccsg25_phase
#define reflect mccsg25_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 36953 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg26. */
  SIG_MESSAGE("sg26 (Init)");
#define mccompcurname  sg26
#define mccompcurtype  Guide_gravity
#define mccompcurindex 67
#define GVars mccsg26_GVars
#define pTable mccsg26_pTable
#define w1 mccsg26_w1
#define h1 mccsg26_h1
#define w2 mccsg26_w2
#define h2 mccsg26_h2
#define l mccsg26_l
#define R0 mccsg26_R0
#define Qc mccsg26_Qc
#define alpha mccsg26_alpha
#define m mccsg26_m
#define W mccsg26_W
#define nslit mccsg26_nslit
#define d mccsg26_d
#define mleft mccsg26_mleft
#define mright mccsg26_mright
#define mtop mccsg26_mtop
#define mbottom mccsg26_mbottom
#define nhslit mccsg26_nhslit
#define G mccsg26_G
#define aleft mccsg26_aleft
#define aright mccsg26_aright
#define atop mccsg26_atop
#define abottom mccsg26_abottom
#define wavy mccsg26_wavy
#define wavy_z mccsg26_wavy_z
#define wavy_tb mccsg26_wavy_tb
#define wavy_lr mccsg26_wavy_lr
#define chamfers mccsg26_chamfers
#define chamfers_z mccsg26_chamfers_z
#define chamfers_lr mccsg26_chamfers_lr
#define chamfers_tb mccsg26_chamfers_tb
#define nelements mccsg26_nelements
#define nu mccsg26_nu
#define phase mccsg26_phase
#define reflect mccsg26_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 37087 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg27. */
  SIG_MESSAGE("sg27 (Init)");
#define mccompcurname  sg27
#define mccompcurtype  Guide_gravity
#define mccompcurindex 68
#define GVars mccsg27_GVars
#define pTable mccsg27_pTable
#define w1 mccsg27_w1
#define h1 mccsg27_h1
#define w2 mccsg27_w2
#define h2 mccsg27_h2
#define l mccsg27_l
#define R0 mccsg27_R0
#define Qc mccsg27_Qc
#define alpha mccsg27_alpha
#define m mccsg27_m
#define W mccsg27_W
#define nslit mccsg27_nslit
#define d mccsg27_d
#define mleft mccsg27_mleft
#define mright mccsg27_mright
#define mtop mccsg27_mtop
#define mbottom mccsg27_mbottom
#define nhslit mccsg27_nhslit
#define G mccsg27_G
#define aleft mccsg27_aleft
#define aright mccsg27_aright
#define atop mccsg27_atop
#define abottom mccsg27_abottom
#define wavy mccsg27_wavy
#define wavy_z mccsg27_wavy_z
#define wavy_tb mccsg27_wavy_tb
#define wavy_lr mccsg27_wavy_lr
#define chamfers mccsg27_chamfers
#define chamfers_z mccsg27_chamfers_z
#define chamfers_lr mccsg27_chamfers_lr
#define chamfers_tb mccsg27_chamfers_tb
#define nelements mccsg27_nelements
#define nu mccsg27_nu
#define phase mccsg27_phase
#define reflect mccsg27_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 37221 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component AlWindow8. */
  SIG_MESSAGE("AlWindow8 (Init)");

  /* Initializations for component PSD_D7. */
  SIG_MESSAGE("PSD_D7 (Init)");
#define mccompcurname  PSD_D7
#define mccompcurtype  Monitor_nD
#define mccompcurindex 70
#define user1 mccPSD_D7_user1
#define user2 mccPSD_D7_user2
#define user3 mccPSD_D7_user3
#define DEFS mccPSD_D7_DEFS
#define Vars mccPSD_D7_Vars
#define detector mccPSD_D7_detector
#define offdata mccPSD_D7_offdata
#define xwidth mccPSD_D7_xwidth
#define yheight mccPSD_D7_yheight
#define zdepth mccPSD_D7_zdepth
#define xmin mccPSD_D7_xmin
#define xmax mccPSD_D7_xmax
#define ymin mccPSD_D7_ymin
#define ymax mccPSD_D7_ymax
#define zmin mccPSD_D7_zmin
#define zmax mccPSD_D7_zmax
#define bins mccPSD_D7_bins
#define min mccPSD_D7_min
#define max mccPSD_D7_max
#define restore_neutron mccPSD_D7_restore_neutron
#define radius mccPSD_D7_radius
#define options mccPSD_D7_options
#define filename mccPSD_D7_filename
#define geometry mccPSD_D7_geometry
#define username1 mccPSD_D7_username1
#define username2 mccPSD_D7_username2
#define username3 mccPSD_D7_username3
#define nowritefile mccPSD_D7_nowritefile
#line 231 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  char tmp[CHAR_BUF_LENGTH];
  strcpy(Vars.compcurname, NAME_CURRENT_COMP);
  if (options != NULL)
    strncpy(Vars.option, options, CHAR_BUF_LENGTH);
  else {
    strcpy(Vars.option, "x y");
    printf("Monitor_nD: %s has no option specified. Setting to PSD ('x y') monitor.\n", NAME_CURRENT_COMP);
  }
  Vars.compcurpos = POS_A_CURRENT_COMP;

  if (strstr(Vars.option, "source"))
    strcat(Vars.option, " list, x y z vx vy vz t sx sy sz ");

  if (bins) { sprintf(tmp, " all bins=%ld ", (long)bins); strcat(Vars.option, tmp); }
  if (min > -FLT_MAX && max < FLT_MAX) { sprintf(tmp, " all limits=[%g %g]", min, max); strcat(Vars.option, tmp); }
  else if (min > -FLT_MAX) { sprintf(tmp, " all min=%g", min); strcat(Vars.option, tmp); }
  else if (max <  FLT_MAX) { sprintf(tmp, " all max=%g", max); strcat(Vars.option, tmp); }

  strncpy(Vars.UserName1,
    username1 && strlen(username1) && strcmp(username1, "0") && strcmp(username1, "NULL") ?
    username1 : "", 128);
  strncpy(Vars.UserName2,
    username2 && strlen(username2) && strcmp(username2, "0") && strcmp(username2, "NULL") ?
    username2 : "", 128);
  strncpy(Vars.UserName3,
    username3 && strlen(username3) && strcmp(username3, "0") && strcmp(username3, "NULL") ?
    username3 : "", 128);
  if (radius) {
    xwidth = zdepth = 2*radius;
    if (yheight && !strstr(Vars.option, "cylinder") && !strstr(Vars.option, "banana") && !strstr(Vars.option, "sphere"))
      strcat(Vars.option, " banana");
    else if (!yheight && !strstr(Vars.option ,"sphere")) {
      strcat(Vars.option, " sphere");
      yheight=2*radius;
    }
  }
  int offflag=0;
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) {
    if (!off_init(  geometry, xwidth, yheight, zdepth, 1, &offdata )) {
      printf("Monitor_nD: %s could not initiate the OFF geometry %s. \n"
             "            Defaulting to normal Monitor dimensions.\n",
             NAME_CURRENT_COMP, geometry);
      strcpy(geometry, "");
    } else {
      offflag=1;
    }
  }

  if (!radius && !xwidth && !yheight && !zdepth && !xmin && !xmax && !ymin && !ymax &&
    !strstr(Vars.option, "previous") && (!geometry || !strlen(geometry)))
    exit(printf("Monitor_nD: %s has no dimension specified. Aborting (radius, xwidth, yheight, zdepth, previous, geometry).\n", NAME_CURRENT_COMP));

  Monitor_nD_Init(&DEFS, &Vars, xwidth, yheight, zdepth, xmin,xmax,ymin,ymax,zmin,zmax,offflag);

  if (Vars.Flag_OFF) {
    offdata.mantidflag=Vars.Flag_mantid;
    offdata.mantidoffset=Vars.Coord_Min[Vars.Coord_Number-1];
  }


  if (filename && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
    strncpy(Vars.Mon_File, filename, 128);

  /* check if user given filename with ext will be used more than once */
  if ( ((Vars.Flag_Multiple && Vars.Coord_Number > 1) || Vars.Flag_List) && strchr(Vars.Mon_File,'.') )
  { char *XY; XY = strrchr(Vars.Mon_File,'.'); *XY='_'; }

  if (restore_neutron) Vars.Flag_parallel=1;
  detector.m = 0;

#ifdef USE_MPI
MPI_MASTER(
  if (strstr(Vars.option, "auto") && mpi_node_count > 1)
    printf("Monitor_nD: %s is using automatic limits option 'auto' together with MPI.\n"
           "WARNING     this may create incorrect distributions (but integrated flux will be right).\n", NAME_CURRENT_COMP);
);
#endif
}
#line 37378 "ILL_H15_D11.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component AlWindow9. */
  SIG_MESSAGE("AlWindow9 (Init)");

  /* Initializations for component D7toD11GuideStart. */
  SIG_MESSAGE("D7toD11GuideStart (Init)");

  /* Initializations for component sg28. */
  SIG_MESSAGE("sg28 (Init)");
#define mccompcurname  sg28
#define mccompcurtype  Guide_gravity
#define mccompcurindex 73
#define GVars mccsg28_GVars
#define pTable mccsg28_pTable
#define w1 mccsg28_w1
#define h1 mccsg28_h1
#define w2 mccsg28_w2
#define h2 mccsg28_h2
#define l mccsg28_l
#define R0 mccsg28_R0
#define Qc mccsg28_Qc
#define alpha mccsg28_alpha
#define m mccsg28_m
#define W mccsg28_W
#define nslit mccsg28_nslit
#define d mccsg28_d
#define mleft mccsg28_mleft
#define mright mccsg28_mright
#define mtop mccsg28_mtop
#define mbottom mccsg28_mbottom
#define nhslit mccsg28_nhslit
#define G mccsg28_G
#define aleft mccsg28_aleft
#define aright mccsg28_aright
#define atop mccsg28_atop
#define abottom mccsg28_abottom
#define wavy mccsg28_wavy
#define wavy_z mccsg28_wavy_z
#define wavy_tb mccsg28_wavy_tb
#define wavy_lr mccsg28_wavy_lr
#define chamfers mccsg28_chamfers
#define chamfers_z mccsg28_chamfers_z
#define chamfers_lr mccsg28_chamfers_lr
#define chamfers_tb mccsg28_chamfers_tb
#define nelements mccsg28_nelements
#define nu mccsg28_nu
#define phase mccsg28_phase
#define reflect mccsg28_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 37510 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component sg29. */
  SIG_MESSAGE("sg29 (Init)");
#define mccompcurname  sg29
#define mccompcurtype  Guide_gravity
#define mccompcurindex 74
#define GVars mccsg29_GVars
#define pTable mccsg29_pTable
#define w1 mccsg29_w1
#define h1 mccsg29_h1
#define w2 mccsg29_w2
#define h2 mccsg29_h2
#define l mccsg29_l
#define R0 mccsg29_R0
#define Qc mccsg29_Qc
#define alpha mccsg29_alpha
#define m mccsg29_m
#define W mccsg29_W
#define nslit mccsg29_nslit
#define d mccsg29_d
#define mleft mccsg29_mleft
#define mright mccsg29_mright
#define mtop mccsg29_mtop
#define mbottom mccsg29_mbottom
#define nhslit mccsg29_nhslit
#define G mccsg29_G
#define aleft mccsg29_aleft
#define aright mccsg29_aright
#define atop mccsg29_atop
#define abottom mccsg29_abottom
#define wavy mccsg29_wavy
#define wavy_z mccsg29_wavy_z
#define wavy_tb mccsg29_wavy_tb
#define wavy_lr mccsg29_wavy_lr
#define chamfers mccsg29_chamfers
#define chamfers_z mccsg29_chamfers_z
#define chamfers_lr mccsg29_chamfers_lr
#define chamfers_tb mccsg29_chamfers_tb
#define nelements mccsg29_nelements
#define nu mccsg29_nu
#define phase mccsg29_phase
#define reflect mccsg29_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 37644 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component AlWindow10. */
  SIG_MESSAGE("AlWindow10 (Init)");

  /* Initializations for component Mon_D11_In. */
  SIG_MESSAGE("Mon_D11_In (Init)");
#define mccompcurname  Mon_D11_In
#define mccompcurtype  Monitor_nD
#define mccompcurindex 76
#define user1 mccMon_D11_In_user1
#define user2 mccMon_D11_In_user2
#define user3 mccMon_D11_In_user3
#define DEFS mccMon_D11_In_DEFS
#define Vars mccMon_D11_In_Vars
#define detector mccMon_D11_In_detector
#define offdata mccMon_D11_In_offdata
#define xwidth mccMon_D11_In_xwidth
#define yheight mccMon_D11_In_yheight
#define zdepth mccMon_D11_In_zdepth
#define xmin mccMon_D11_In_xmin
#define xmax mccMon_D11_In_xmax
#define ymin mccMon_D11_In_ymin
#define ymax mccMon_D11_In_ymax
#define zmin mccMon_D11_In_zmin
#define zmax mccMon_D11_In_zmax
#define bins mccMon_D11_In_bins
#define min mccMon_D11_In_min
#define max mccMon_D11_In_max
#define restore_neutron mccMon_D11_In_restore_neutron
#define radius mccMon_D11_In_radius
#define options mccMon_D11_In_options
#define filename mccMon_D11_In_filename
#define geometry mccMon_D11_In_geometry
#define username1 mccMon_D11_In_username1
#define username2 mccMon_D11_In_username2
#define username3 mccMon_D11_In_username3
#define nowritefile mccMon_D11_In_nowritefile
#line 231 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  char tmp[CHAR_BUF_LENGTH];
  strcpy(Vars.compcurname, NAME_CURRENT_COMP);
  if (options != NULL)
    strncpy(Vars.option, options, CHAR_BUF_LENGTH);
  else {
    strcpy(Vars.option, "x y");
    printf("Monitor_nD: %s has no option specified. Setting to PSD ('x y') monitor.\n", NAME_CURRENT_COMP);
  }
  Vars.compcurpos = POS_A_CURRENT_COMP;

  if (strstr(Vars.option, "source"))
    strcat(Vars.option, " list, x y z vx vy vz t sx sy sz ");

  if (bins) { sprintf(tmp, " all bins=%ld ", (long)bins); strcat(Vars.option, tmp); }
  if (min > -FLT_MAX && max < FLT_MAX) { sprintf(tmp, " all limits=[%g %g]", min, max); strcat(Vars.option, tmp); }
  else if (min > -FLT_MAX) { sprintf(tmp, " all min=%g", min); strcat(Vars.option, tmp); }
  else if (max <  FLT_MAX) { sprintf(tmp, " all max=%g", max); strcat(Vars.option, tmp); }

  strncpy(Vars.UserName1,
    username1 && strlen(username1) && strcmp(username1, "0") && strcmp(username1, "NULL") ?
    username1 : "", 128);
  strncpy(Vars.UserName2,
    username2 && strlen(username2) && strcmp(username2, "0") && strcmp(username2, "NULL") ?
    username2 : "", 128);
  strncpy(Vars.UserName3,
    username3 && strlen(username3) && strcmp(username3, "0") && strcmp(username3, "NULL") ?
    username3 : "", 128);
  if (radius) {
    xwidth = zdepth = 2*radius;
    if (yheight && !strstr(Vars.option, "cylinder") && !strstr(Vars.option, "banana") && !strstr(Vars.option, "sphere"))
      strcat(Vars.option, " banana");
    else if (!yheight && !strstr(Vars.option ,"sphere")) {
      strcat(Vars.option, " sphere");
      yheight=2*radius;
    }
  }
  int offflag=0;
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) {
    if (!off_init(  geometry, xwidth, yheight, zdepth, 1, &offdata )) {
      printf("Monitor_nD: %s could not initiate the OFF geometry %s. \n"
             "            Defaulting to normal Monitor dimensions.\n",
             NAME_CURRENT_COMP, geometry);
      strcpy(geometry, "");
    } else {
      offflag=1;
    }
  }

  if (!radius && !xwidth && !yheight && !zdepth && !xmin && !xmax && !ymin && !ymax &&
    !strstr(Vars.option, "previous") && (!geometry || !strlen(geometry)))
    exit(printf("Monitor_nD: %s has no dimension specified. Aborting (radius, xwidth, yheight, zdepth, previous, geometry).\n", NAME_CURRENT_COMP));

  Monitor_nD_Init(&DEFS, &Vars, xwidth, yheight, zdepth, xmin,xmax,ymin,ymax,zmin,zmax,offflag);

  if (Vars.Flag_OFF) {
    offdata.mantidflag=Vars.Flag_mantid;
    offdata.mantidoffset=Vars.Coord_Min[Vars.Coord_Number-1];
  }


  if (filename && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
    strncpy(Vars.Mon_File, filename, 128);

  /* check if user given filename with ext will be used more than once */
  if ( ((Vars.Flag_Multiple && Vars.Coord_Number > 1) || Vars.Flag_List) && strchr(Vars.Mon_File,'.') )
  { char *XY; XY = strrchr(Vars.Mon_File,'.'); *XY='_'; }

  if (restore_neutron) Vars.Flag_parallel=1;
  detector.m = 0;

#ifdef USE_MPI
MPI_MASTER(
  if (strstr(Vars.option, "auto") && mpi_node_count > 1)
    printf("Monitor_nD: %s is using automatic limits option 'auto' together with MPI.\n"
           "WARNING     this may create incorrect distributions (but integrated flux will be right).\n", NAME_CURRENT_COMP);
);
#endif
}
#line 37801 "ILL_H15_D11.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component Dolores. */
  SIG_MESSAGE("Dolores (Init)");
#define mccompcurname  Dolores
#define mccompcurtype  V_selector
#define mccompcurindex 77
#define omega mccDolores_omega
#define alpha_rad mccDolores_alpha_rad
#define dt0 mccDolores_dt0
#define dt1 mccDolores_dt1
#define r_i mccDolores_r_i
#define r_f mccDolores_r_f
#define r_mean mccDolores_r_mean
#define theta_i mccDolores_theta_i
#define theta_f mccDolores_theta_f
#define A mccDolores_A
#define d_s_alpha mccDolores_d_s_alpha
#define xwidth mccDolores_xwidth
#define yheight mccDolores_yheight
#define zdepth mccDolores_zdepth
#define radius mccDolores_radius
#define alpha mccDolores_alpha
#define length mccDolores_length
#define d mccDolores_d
#define nu mccDolores_nu
#define nslit mccDolores_nslit
#line 62 "/usr/share/mcstas/2.6rc1/optics/V_selector.comp"
{
omega=nu*2*PI;
alpha_rad = alpha*DEG2RAD;
if (zdepth < length) zdepth=length;
}
#line 37865 "ILL_H15_D11.c"
#undef nslit
#undef nu
#undef d
#undef length
#undef alpha
#undef radius
#undef zdepth
#undef yheight
#undef xwidth
#undef d_s_alpha
#undef A
#undef theta_f
#undef theta_i
#undef r_mean
#undef r_f
#undef r_i
#undef dt1
#undef dt0
#undef alpha_rad
#undef omega
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component AlWindow11. */
  SIG_MESSAGE("AlWindow11 (Init)");

  /* Initializations for component sg30. */
  SIG_MESSAGE("sg30 (Init)");
#define mccompcurname  sg30
#define mccompcurtype  Guide_gravity
#define mccompcurindex 79
#define GVars mccsg30_GVars
#define pTable mccsg30_pTable
#define w1 mccsg30_w1
#define h1 mccsg30_h1
#define w2 mccsg30_w2
#define h2 mccsg30_h2
#define l mccsg30_l
#define R0 mccsg30_R0
#define Qc mccsg30_Qc
#define alpha mccsg30_alpha
#define m mccsg30_m
#define W mccsg30_W
#define nslit mccsg30_nslit
#define d mccsg30_d
#define mleft mccsg30_mleft
#define mright mccsg30_mright
#define mtop mccsg30_mtop
#define mbottom mccsg30_mbottom
#define nhslit mccsg30_nhslit
#define G mccsg30_G
#define aleft mccsg30_aleft
#define aright mccsg30_aright
#define atop mccsg30_atop
#define abottom mccsg30_abottom
#define wavy mccsg30_wavy
#define wavy_z mccsg30_wavy_z
#define wavy_tb mccsg30_wavy_tb
#define wavy_lr mccsg30_wavy_lr
#define chamfers mccsg30_chamfers
#define chamfers_z mccsg30_chamfers_z
#define chamfers_lr mccsg30_chamfers_lr
#define chamfers_tb mccsg30_chamfers_tb
#define nelements mccsg30_nelements
#define nu mccsg30_nu
#define phase mccsg30_phase
#define reflect mccsg30_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 37986 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component AlWindow12. */
  SIG_MESSAGE("AlWindow12 (Init)");

  /* Initializations for component Mon_D11_Out. */
  SIG_MESSAGE("Mon_D11_Out (Init)");
#define mccompcurname  Mon_D11_Out
#define mccompcurtype  Monitor_nD
#define mccompcurindex 81
#define user1 mccMon_D11_Out_user1
#define user2 mccMon_D11_Out_user2
#define user3 mccMon_D11_Out_user3
#define DEFS mccMon_D11_Out_DEFS
#define Vars mccMon_D11_Out_Vars
#define detector mccMon_D11_Out_detector
#define offdata mccMon_D11_Out_offdata
#define xwidth mccMon_D11_Out_xwidth
#define yheight mccMon_D11_Out_yheight
#define zdepth mccMon_D11_Out_zdepth
#define xmin mccMon_D11_Out_xmin
#define xmax mccMon_D11_Out_xmax
#define ymin mccMon_D11_Out_ymin
#define ymax mccMon_D11_Out_ymax
#define zmin mccMon_D11_Out_zmin
#define zmax mccMon_D11_Out_zmax
#define bins mccMon_D11_Out_bins
#define min mccMon_D11_Out_min
#define max mccMon_D11_Out_max
#define restore_neutron mccMon_D11_Out_restore_neutron
#define radius mccMon_D11_Out_radius
#define options mccMon_D11_Out_options
#define filename mccMon_D11_Out_filename
#define geometry mccMon_D11_Out_geometry
#define username1 mccMon_D11_Out_username1
#define username2 mccMon_D11_Out_username2
#define username3 mccMon_D11_Out_username3
#define nowritefile mccMon_D11_Out_nowritefile
#line 231 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  char tmp[CHAR_BUF_LENGTH];
  strcpy(Vars.compcurname, NAME_CURRENT_COMP);
  if (options != NULL)
    strncpy(Vars.option, options, CHAR_BUF_LENGTH);
  else {
    strcpy(Vars.option, "x y");
    printf("Monitor_nD: %s has no option specified. Setting to PSD ('x y') monitor.\n", NAME_CURRENT_COMP);
  }
  Vars.compcurpos = POS_A_CURRENT_COMP;

  if (strstr(Vars.option, "source"))
    strcat(Vars.option, " list, x y z vx vy vz t sx sy sz ");

  if (bins) { sprintf(tmp, " all bins=%ld ", (long)bins); strcat(Vars.option, tmp); }
  if (min > -FLT_MAX && max < FLT_MAX) { sprintf(tmp, " all limits=[%g %g]", min, max); strcat(Vars.option, tmp); }
  else if (min > -FLT_MAX) { sprintf(tmp, " all min=%g", min); strcat(Vars.option, tmp); }
  else if (max <  FLT_MAX) { sprintf(tmp, " all max=%g", max); strcat(Vars.option, tmp); }

  strncpy(Vars.UserName1,
    username1 && strlen(username1) && strcmp(username1, "0") && strcmp(username1, "NULL") ?
    username1 : "", 128);
  strncpy(Vars.UserName2,
    username2 && strlen(username2) && strcmp(username2, "0") && strcmp(username2, "NULL") ?
    username2 : "", 128);
  strncpy(Vars.UserName3,
    username3 && strlen(username3) && strcmp(username3, "0") && strcmp(username3, "NULL") ?
    username3 : "", 128);
  if (radius) {
    xwidth = zdepth = 2*radius;
    if (yheight && !strstr(Vars.option, "cylinder") && !strstr(Vars.option, "banana") && !strstr(Vars.option, "sphere"))
      strcat(Vars.option, " banana");
    else if (!yheight && !strstr(Vars.option ,"sphere")) {
      strcat(Vars.option, " sphere");
      yheight=2*radius;
    }
  }
  int offflag=0;
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) {
    if (!off_init(  geometry, xwidth, yheight, zdepth, 1, &offdata )) {
      printf("Monitor_nD: %s could not initiate the OFF geometry %s. \n"
             "            Defaulting to normal Monitor dimensions.\n",
             NAME_CURRENT_COMP, geometry);
      strcpy(geometry, "");
    } else {
      offflag=1;
    }
  }

  if (!radius && !xwidth && !yheight && !zdepth && !xmin && !xmax && !ymin && !ymax &&
    !strstr(Vars.option, "previous") && (!geometry || !strlen(geometry)))
    exit(printf("Monitor_nD: %s has no dimension specified. Aborting (radius, xwidth, yheight, zdepth, previous, geometry).\n", NAME_CURRENT_COMP));

  Monitor_nD_Init(&DEFS, &Vars, xwidth, yheight, zdepth, xmin,xmax,ymin,ymax,zmin,zmax,offflag);

  if (Vars.Flag_OFF) {
    offdata.mantidflag=Vars.Flag_mantid;
    offdata.mantidoffset=Vars.Coord_Min[Vars.Coord_Number-1];
  }


  if (filename && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
    strncpy(Vars.Mon_File, filename, 128);

  /* check if user given filename with ext will be used more than once */
  if ( ((Vars.Flag_Multiple && Vars.Coord_Number > 1) || Vars.Flag_List) && strchr(Vars.Mon_File,'.') )
  { char *XY; XY = strrchr(Vars.Mon_File,'.'); *XY='_'; }

  if (restore_neutron) Vars.Flag_parallel=1;
  detector.m = 0;

#ifdef USE_MPI
MPI_MASTER(
  if (strstr(Vars.option, "auto") && mpi_node_count > 1)
    printf("Monitor_nD: %s is using automatic limits option 'auto' together with MPI.\n"
           "WARNING     this may create incorrect distributions (but integrated flux will be right).\n", NAME_CURRENT_COMP);
);
#endif
}
#line 38143 "ILL_H15_D11.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component AlWindow13. */
  SIG_MESSAGE("AlWindow13 (Init)");

  /* Initializations for component MovableGuideStart. */
  SIG_MESSAGE("MovableGuideStart (Init)");

  /* Initializations for component mg0. */
  SIG_MESSAGE("mg0 (Init)");
#define mccompcurname  mg0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 84
#define GVars mccmg0_GVars
#define pTable mccmg0_pTable
#define w1 mccmg0_w1
#define h1 mccmg0_h1
#define w2 mccmg0_w2
#define h2 mccmg0_h2
#define l mccmg0_l
#define R0 mccmg0_R0
#define Qc mccmg0_Qc
#define alpha mccmg0_alpha
#define m mccmg0_m
#define W mccmg0_W
#define nslit mccmg0_nslit
#define d mccmg0_d
#define mleft mccmg0_mleft
#define mright mccmg0_mright
#define mtop mccmg0_mtop
#define mbottom mccmg0_mbottom
#define nhslit mccmg0_nhslit
#define G mccmg0_G
#define aleft mccmg0_aleft
#define aright mccmg0_aright
#define atop mccmg0_atop
#define abottom mccmg0_abottom
#define wavy mccmg0_wavy
#define wavy_z mccmg0_wavy_z
#define wavy_tb mccmg0_wavy_tb
#define wavy_lr mccmg0_wavy_lr
#define chamfers mccmg0_chamfers
#define chamfers_z mccmg0_chamfers_z
#define chamfers_lr mccmg0_chamfers_lr
#define chamfers_tb mccmg0_chamfers_tb
#define nelements mccmg0_nelements
#define nu mccmg0_nu
#define phase mccmg0_phase
#define reflect mccmg0_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 38275 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component mg1. */
  SIG_MESSAGE("mg1 (Init)");
#define mccompcurname  mg1
#define mccompcurtype  Guide_gravity
#define mccompcurindex 85
#define GVars mccmg1_GVars
#define pTable mccmg1_pTable
#define w1 mccmg1_w1
#define h1 mccmg1_h1
#define w2 mccmg1_w2
#define h2 mccmg1_h2
#define l mccmg1_l
#define R0 mccmg1_R0
#define Qc mccmg1_Qc
#define alpha mccmg1_alpha
#define m mccmg1_m
#define W mccmg1_W
#define nslit mccmg1_nslit
#define d mccmg1_d
#define mleft mccmg1_mleft
#define mright mccmg1_mright
#define mtop mccmg1_mtop
#define mbottom mccmg1_mbottom
#define nhslit mccmg1_nhslit
#define G mccmg1_G
#define aleft mccmg1_aleft
#define aright mccmg1_aright
#define atop mccmg1_atop
#define abottom mccmg1_abottom
#define wavy mccmg1_wavy
#define wavy_z mccmg1_wavy_z
#define wavy_tb mccmg1_wavy_tb
#define wavy_lr mccmg1_wavy_lr
#define chamfers mccmg1_chamfers
#define chamfers_z mccmg1_chamfers_z
#define chamfers_lr mccmg1_chamfers_lr
#define chamfers_tb mccmg1_chamfers_tb
#define nelements mccmg1_nelements
#define nu mccmg1_nu
#define phase mccmg1_phase
#define reflect mccmg1_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 38409 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component mg2. */
  SIG_MESSAGE("mg2 (Init)");
#define mccompcurname  mg2
#define mccompcurtype  Guide_gravity
#define mccompcurindex 86
#define GVars mccmg2_GVars
#define pTable mccmg2_pTable
#define w1 mccmg2_w1
#define h1 mccmg2_h1
#define w2 mccmg2_w2
#define h2 mccmg2_h2
#define l mccmg2_l
#define R0 mccmg2_R0
#define Qc mccmg2_Qc
#define alpha mccmg2_alpha
#define m mccmg2_m
#define W mccmg2_W
#define nslit mccmg2_nslit
#define d mccmg2_d
#define mleft mccmg2_mleft
#define mright mccmg2_mright
#define mtop mccmg2_mtop
#define mbottom mccmg2_mbottom
#define nhslit mccmg2_nhslit
#define G mccmg2_G
#define aleft mccmg2_aleft
#define aright mccmg2_aright
#define atop mccmg2_atop
#define abottom mccmg2_abottom
#define wavy mccmg2_wavy
#define wavy_z mccmg2_wavy_z
#define wavy_tb mccmg2_wavy_tb
#define wavy_lr mccmg2_wavy_lr
#define chamfers mccmg2_chamfers
#define chamfers_z mccmg2_chamfers_z
#define chamfers_lr mccmg2_chamfers_lr
#define chamfers_tb mccmg2_chamfers_tb
#define nelements mccmg2_nelements
#define nu mccmg2_nu
#define phase mccmg2_phase
#define reflect mccmg2_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 38543 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component mg3. */
  SIG_MESSAGE("mg3 (Init)");
#define mccompcurname  mg3
#define mccompcurtype  Guide_gravity
#define mccompcurindex 87
#define GVars mccmg3_GVars
#define pTable mccmg3_pTable
#define w1 mccmg3_w1
#define h1 mccmg3_h1
#define w2 mccmg3_w2
#define h2 mccmg3_h2
#define l mccmg3_l
#define R0 mccmg3_R0
#define Qc mccmg3_Qc
#define alpha mccmg3_alpha
#define m mccmg3_m
#define W mccmg3_W
#define nslit mccmg3_nslit
#define d mccmg3_d
#define mleft mccmg3_mleft
#define mright mccmg3_mright
#define mtop mccmg3_mtop
#define mbottom mccmg3_mbottom
#define nhslit mccmg3_nhslit
#define G mccmg3_G
#define aleft mccmg3_aleft
#define aright mccmg3_aright
#define atop mccmg3_atop
#define abottom mccmg3_abottom
#define wavy mccmg3_wavy
#define wavy_z mccmg3_wavy_z
#define wavy_tb mccmg3_wavy_tb
#define wavy_lr mccmg3_wavy_lr
#define chamfers mccmg3_chamfers
#define chamfers_z mccmg3_chamfers_z
#define chamfers_lr mccmg3_chamfers_lr
#define chamfers_tb mccmg3_chamfers_tb
#define nelements mccmg3_nelements
#define nu mccmg3_nu
#define phase mccmg3_phase
#define reflect mccmg3_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 38677 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component mg4. */
  SIG_MESSAGE("mg4 (Init)");
#define mccompcurname  mg4
#define mccompcurtype  Guide_gravity
#define mccompcurindex 88
#define GVars mccmg4_GVars
#define pTable mccmg4_pTable
#define w1 mccmg4_w1
#define h1 mccmg4_h1
#define w2 mccmg4_w2
#define h2 mccmg4_h2
#define l mccmg4_l
#define R0 mccmg4_R0
#define Qc mccmg4_Qc
#define alpha mccmg4_alpha
#define m mccmg4_m
#define W mccmg4_W
#define nslit mccmg4_nslit
#define d mccmg4_d
#define mleft mccmg4_mleft
#define mright mccmg4_mright
#define mtop mccmg4_mtop
#define mbottom mccmg4_mbottom
#define nhslit mccmg4_nhslit
#define G mccmg4_G
#define aleft mccmg4_aleft
#define aright mccmg4_aright
#define atop mccmg4_atop
#define abottom mccmg4_abottom
#define wavy mccmg4_wavy
#define wavy_z mccmg4_wavy_z
#define wavy_tb mccmg4_wavy_tb
#define wavy_lr mccmg4_wavy_lr
#define chamfers mccmg4_chamfers
#define chamfers_z mccmg4_chamfers_z
#define chamfers_lr mccmg4_chamfers_lr
#define chamfers_tb mccmg4_chamfers_tb
#define nelements mccmg4_nelements
#define nu mccmg4_nu
#define phase mccmg4_phase
#define reflect mccmg4_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 38811 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component mg5. */
  SIG_MESSAGE("mg5 (Init)");
#define mccompcurname  mg5
#define mccompcurtype  Guide_gravity
#define mccompcurindex 89
#define GVars mccmg5_GVars
#define pTable mccmg5_pTable
#define w1 mccmg5_w1
#define h1 mccmg5_h1
#define w2 mccmg5_w2
#define h2 mccmg5_h2
#define l mccmg5_l
#define R0 mccmg5_R0
#define Qc mccmg5_Qc
#define alpha mccmg5_alpha
#define m mccmg5_m
#define W mccmg5_W
#define nslit mccmg5_nslit
#define d mccmg5_d
#define mleft mccmg5_mleft
#define mright mccmg5_mright
#define mtop mccmg5_mtop
#define mbottom mccmg5_mbottom
#define nhslit mccmg5_nhslit
#define G mccmg5_G
#define aleft mccmg5_aleft
#define aright mccmg5_aright
#define atop mccmg5_atop
#define abottom mccmg5_abottom
#define wavy mccmg5_wavy
#define wavy_z mccmg5_wavy_z
#define wavy_tb mccmg5_wavy_tb
#define wavy_lr mccmg5_wavy_lr
#define chamfers mccmg5_chamfers
#define chamfers_z mccmg5_chamfers_z
#define chamfers_lr mccmg5_chamfers_lr
#define chamfers_tb mccmg5_chamfers_tb
#define nelements mccmg5_nelements
#define nu mccmg5_nu
#define phase mccmg5_phase
#define reflect mccmg5_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 38945 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component mg6. */
  SIG_MESSAGE("mg6 (Init)");
#define mccompcurname  mg6
#define mccompcurtype  Guide_gravity
#define mccompcurindex 90
#define GVars mccmg6_GVars
#define pTable mccmg6_pTable
#define w1 mccmg6_w1
#define h1 mccmg6_h1
#define w2 mccmg6_w2
#define h2 mccmg6_h2
#define l mccmg6_l
#define R0 mccmg6_R0
#define Qc mccmg6_Qc
#define alpha mccmg6_alpha
#define m mccmg6_m
#define W mccmg6_W
#define nslit mccmg6_nslit
#define d mccmg6_d
#define mleft mccmg6_mleft
#define mright mccmg6_mright
#define mtop mccmg6_mtop
#define mbottom mccmg6_mbottom
#define nhslit mccmg6_nhslit
#define G mccmg6_G
#define aleft mccmg6_aleft
#define aright mccmg6_aright
#define atop mccmg6_atop
#define abottom mccmg6_abottom
#define wavy mccmg6_wavy
#define wavy_z mccmg6_wavy_z
#define wavy_tb mccmg6_wavy_tb
#define wavy_lr mccmg6_wavy_lr
#define chamfers mccmg6_chamfers
#define chamfers_z mccmg6_chamfers_z
#define chamfers_lr mccmg6_chamfers_lr
#define chamfers_tb mccmg6_chamfers_tb
#define nelements mccmg6_nelements
#define nu mccmg6_nu
#define phase mccmg6_phase
#define reflect mccmg6_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 39079 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component mg7. */
  SIG_MESSAGE("mg7 (Init)");
#define mccompcurname  mg7
#define mccompcurtype  Guide_gravity
#define mccompcurindex 91
#define GVars mccmg7_GVars
#define pTable mccmg7_pTable
#define w1 mccmg7_w1
#define h1 mccmg7_h1
#define w2 mccmg7_w2
#define h2 mccmg7_h2
#define l mccmg7_l
#define R0 mccmg7_R0
#define Qc mccmg7_Qc
#define alpha mccmg7_alpha
#define m mccmg7_m
#define W mccmg7_W
#define nslit mccmg7_nslit
#define d mccmg7_d
#define mleft mccmg7_mleft
#define mright mccmg7_mright
#define mtop mccmg7_mtop
#define mbottom mccmg7_mbottom
#define nhslit mccmg7_nhslit
#define G mccmg7_G
#define aleft mccmg7_aleft
#define aright mccmg7_aright
#define atop mccmg7_atop
#define abottom mccmg7_abottom
#define wavy mccmg7_wavy
#define wavy_z mccmg7_wavy_z
#define wavy_tb mccmg7_wavy_tb
#define wavy_lr mccmg7_wavy_lr
#define chamfers mccmg7_chamfers
#define chamfers_z mccmg7_chamfers_z
#define chamfers_lr mccmg7_chamfers_lr
#define chamfers_tb mccmg7_chamfers_tb
#define nelements mccmg7_nelements
#define nu mccmg7_nu
#define phase mccmg7_phase
#define reflect mccmg7_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 39213 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component mg8. */
  SIG_MESSAGE("mg8 (Init)");
#define mccompcurname  mg8
#define mccompcurtype  Guide_gravity
#define mccompcurindex 92
#define GVars mccmg8_GVars
#define pTable mccmg8_pTable
#define w1 mccmg8_w1
#define h1 mccmg8_h1
#define w2 mccmg8_w2
#define h2 mccmg8_h2
#define l mccmg8_l
#define R0 mccmg8_R0
#define Qc mccmg8_Qc
#define alpha mccmg8_alpha
#define m mccmg8_m
#define W mccmg8_W
#define nslit mccmg8_nslit
#define d mccmg8_d
#define mleft mccmg8_mleft
#define mright mccmg8_mright
#define mtop mccmg8_mtop
#define mbottom mccmg8_mbottom
#define nhslit mccmg8_nhslit
#define G mccmg8_G
#define aleft mccmg8_aleft
#define aright mccmg8_aright
#define atop mccmg8_atop
#define abottom mccmg8_abottom
#define wavy mccmg8_wavy
#define wavy_z mccmg8_wavy_z
#define wavy_tb mccmg8_wavy_tb
#define wavy_lr mccmg8_wavy_lr
#define chamfers mccmg8_chamfers
#define chamfers_z mccmg8_chamfers_z
#define chamfers_lr mccmg8_chamfers_lr
#define chamfers_tb mccmg8_chamfers_tb
#define nelements mccmg8_nelements
#define nu mccmg8_nu
#define phase mccmg8_phase
#define reflect mccmg8_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 39347 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component mg9. */
  SIG_MESSAGE("mg9 (Init)");
#define mccompcurname  mg9
#define mccompcurtype  Guide_gravity
#define mccompcurindex 93
#define GVars mccmg9_GVars
#define pTable mccmg9_pTable
#define w1 mccmg9_w1
#define h1 mccmg9_h1
#define w2 mccmg9_w2
#define h2 mccmg9_h2
#define l mccmg9_l
#define R0 mccmg9_R0
#define Qc mccmg9_Qc
#define alpha mccmg9_alpha
#define m mccmg9_m
#define W mccmg9_W
#define nslit mccmg9_nslit
#define d mccmg9_d
#define mleft mccmg9_mleft
#define mright mccmg9_mright
#define mtop mccmg9_mtop
#define mbottom mccmg9_mbottom
#define nhslit mccmg9_nhslit
#define G mccmg9_G
#define aleft mccmg9_aleft
#define aright mccmg9_aright
#define atop mccmg9_atop
#define abottom mccmg9_abottom
#define wavy mccmg9_wavy
#define wavy_z mccmg9_wavy_z
#define wavy_tb mccmg9_wavy_tb
#define wavy_lr mccmg9_wavy_lr
#define chamfers mccmg9_chamfers
#define chamfers_z mccmg9_chamfers_z
#define chamfers_lr mccmg9_chamfers_lr
#define chamfers_tb mccmg9_chamfers_tb
#define nelements mccmg9_nelements
#define nu mccmg9_nu
#define phase mccmg9_phase
#define reflect mccmg9_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 39481 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component mg10. */
  SIG_MESSAGE("mg10 (Init)");
#define mccompcurname  mg10
#define mccompcurtype  Guide_gravity
#define mccompcurindex 94
#define GVars mccmg10_GVars
#define pTable mccmg10_pTable
#define w1 mccmg10_w1
#define h1 mccmg10_h1
#define w2 mccmg10_w2
#define h2 mccmg10_h2
#define l mccmg10_l
#define R0 mccmg10_R0
#define Qc mccmg10_Qc
#define alpha mccmg10_alpha
#define m mccmg10_m
#define W mccmg10_W
#define nslit mccmg10_nslit
#define d mccmg10_d
#define mleft mccmg10_mleft
#define mright mccmg10_mright
#define mtop mccmg10_mtop
#define mbottom mccmg10_mbottom
#define nhslit mccmg10_nhslit
#define G mccmg10_G
#define aleft mccmg10_aleft
#define aright mccmg10_aright
#define atop mccmg10_atop
#define abottom mccmg10_abottom
#define wavy mccmg10_wavy
#define wavy_z mccmg10_wavy_z
#define wavy_tb mccmg10_wavy_tb
#define wavy_lr mccmg10_wavy_lr
#define chamfers mccmg10_chamfers
#define chamfers_z mccmg10_chamfers_z
#define chamfers_lr mccmg10_chamfers_lr
#define chamfers_tb mccmg10_chamfers_tb
#define nelements mccmg10_nelements
#define nu mccmg10_nu
#define phase mccmg10_phase
#define reflect mccmg10_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 39615 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component mg11. */
  SIG_MESSAGE("mg11 (Init)");
#define mccompcurname  mg11
#define mccompcurtype  Guide_gravity
#define mccompcurindex 95
#define GVars mccmg11_GVars
#define pTable mccmg11_pTable
#define w1 mccmg11_w1
#define h1 mccmg11_h1
#define w2 mccmg11_w2
#define h2 mccmg11_h2
#define l mccmg11_l
#define R0 mccmg11_R0
#define Qc mccmg11_Qc
#define alpha mccmg11_alpha
#define m mccmg11_m
#define W mccmg11_W
#define nslit mccmg11_nslit
#define d mccmg11_d
#define mleft mccmg11_mleft
#define mright mccmg11_mright
#define mtop mccmg11_mtop
#define mbottom mccmg11_mbottom
#define nhslit mccmg11_nhslit
#define G mccmg11_G
#define aleft mccmg11_aleft
#define aright mccmg11_aright
#define atop mccmg11_atop
#define abottom mccmg11_abottom
#define wavy mccmg11_wavy
#define wavy_z mccmg11_wavy_z
#define wavy_tb mccmg11_wavy_tb
#define wavy_lr mccmg11_wavy_lr
#define chamfers mccmg11_chamfers
#define chamfers_z mccmg11_chamfers_z
#define chamfers_lr mccmg11_chamfers_lr
#define chamfers_tb mccmg11_chamfers_tb
#define nelements mccmg11_nelements
#define nu mccmg11_nu
#define phase mccmg11_phase
#define reflect mccmg11_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 39749 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component mg12. */
  SIG_MESSAGE("mg12 (Init)");
#define mccompcurname  mg12
#define mccompcurtype  Guide_gravity
#define mccompcurindex 96
#define GVars mccmg12_GVars
#define pTable mccmg12_pTable
#define w1 mccmg12_w1
#define h1 mccmg12_h1
#define w2 mccmg12_w2
#define h2 mccmg12_h2
#define l mccmg12_l
#define R0 mccmg12_R0
#define Qc mccmg12_Qc
#define alpha mccmg12_alpha
#define m mccmg12_m
#define W mccmg12_W
#define nslit mccmg12_nslit
#define d mccmg12_d
#define mleft mccmg12_mleft
#define mright mccmg12_mright
#define mtop mccmg12_mtop
#define mbottom mccmg12_mbottom
#define nhslit mccmg12_nhslit
#define G mccmg12_G
#define aleft mccmg12_aleft
#define aright mccmg12_aright
#define atop mccmg12_atop
#define abottom mccmg12_abottom
#define wavy mccmg12_wavy
#define wavy_z mccmg12_wavy_z
#define wavy_tb mccmg12_wavy_tb
#define wavy_lr mccmg12_wavy_lr
#define chamfers mccmg12_chamfers
#define chamfers_z mccmg12_chamfers_z
#define chamfers_lr mccmg12_chamfers_lr
#define chamfers_tb mccmg12_chamfers_tb
#define nelements mccmg12_nelements
#define nu mccmg12_nu
#define phase mccmg12_phase
#define reflect mccmg12_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 39883 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component mg13. */
  SIG_MESSAGE("mg13 (Init)");
#define mccompcurname  mg13
#define mccompcurtype  Guide_gravity
#define mccompcurindex 97
#define GVars mccmg13_GVars
#define pTable mccmg13_pTable
#define w1 mccmg13_w1
#define h1 mccmg13_h1
#define w2 mccmg13_w2
#define h2 mccmg13_h2
#define l mccmg13_l
#define R0 mccmg13_R0
#define Qc mccmg13_Qc
#define alpha mccmg13_alpha
#define m mccmg13_m
#define W mccmg13_W
#define nslit mccmg13_nslit
#define d mccmg13_d
#define mleft mccmg13_mleft
#define mright mccmg13_mright
#define mtop mccmg13_mtop
#define mbottom mccmg13_mbottom
#define nhslit mccmg13_nhslit
#define G mccmg13_G
#define aleft mccmg13_aleft
#define aright mccmg13_aright
#define atop mccmg13_atop
#define abottom mccmg13_abottom
#define wavy mccmg13_wavy
#define wavy_z mccmg13_wavy_z
#define wavy_tb mccmg13_wavy_tb
#define wavy_lr mccmg13_wavy_lr
#define chamfers mccmg13_chamfers
#define chamfers_z mccmg13_chamfers_z
#define chamfers_lr mccmg13_chamfers_lr
#define chamfers_tb mccmg13_chamfers_tb
#define nelements mccmg13_nelements
#define nu mccmg13_nu
#define phase mccmg13_phase
#define reflect mccmg13_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 40017 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component mg14. */
  SIG_MESSAGE("mg14 (Init)");
#define mccompcurname  mg14
#define mccompcurtype  Guide_gravity
#define mccompcurindex 98
#define GVars mccmg14_GVars
#define pTable mccmg14_pTable
#define w1 mccmg14_w1
#define h1 mccmg14_h1
#define w2 mccmg14_w2
#define h2 mccmg14_h2
#define l mccmg14_l
#define R0 mccmg14_R0
#define Qc mccmg14_Qc
#define alpha mccmg14_alpha
#define m mccmg14_m
#define W mccmg14_W
#define nslit mccmg14_nslit
#define d mccmg14_d
#define mleft mccmg14_mleft
#define mright mccmg14_mright
#define mtop mccmg14_mtop
#define mbottom mccmg14_mbottom
#define nhslit mccmg14_nhslit
#define G mccmg14_G
#define aleft mccmg14_aleft
#define aright mccmg14_aright
#define atop mccmg14_atop
#define abottom mccmg14_abottom
#define wavy mccmg14_wavy
#define wavy_z mccmg14_wavy_z
#define wavy_tb mccmg14_wavy_tb
#define wavy_lr mccmg14_wavy_lr
#define chamfers mccmg14_chamfers
#define chamfers_z mccmg14_chamfers_z
#define chamfers_lr mccmg14_chamfers_lr
#define chamfers_tb mccmg14_chamfers_tb
#define nelements mccmg14_nelements
#define nu mccmg14_nu
#define phase mccmg14_phase
#define reflect mccmg14_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 40151 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component mg15. */
  SIG_MESSAGE("mg15 (Init)");
#define mccompcurname  mg15
#define mccompcurtype  Guide_gravity
#define mccompcurindex 99
#define GVars mccmg15_GVars
#define pTable mccmg15_pTable
#define w1 mccmg15_w1
#define h1 mccmg15_h1
#define w2 mccmg15_w2
#define h2 mccmg15_h2
#define l mccmg15_l
#define R0 mccmg15_R0
#define Qc mccmg15_Qc
#define alpha mccmg15_alpha
#define m mccmg15_m
#define W mccmg15_W
#define nslit mccmg15_nslit
#define d mccmg15_d
#define mleft mccmg15_mleft
#define mright mccmg15_mright
#define mtop mccmg15_mtop
#define mbottom mccmg15_mbottom
#define nhslit mccmg15_nhslit
#define G mccmg15_G
#define aleft mccmg15_aleft
#define aright mccmg15_aright
#define atop mccmg15_atop
#define abottom mccmg15_abottom
#define wavy mccmg15_wavy
#define wavy_z mccmg15_wavy_z
#define wavy_tb mccmg15_wavy_tb
#define wavy_lr mccmg15_wavy_lr
#define chamfers mccmg15_chamfers
#define chamfers_z mccmg15_chamfers_z
#define chamfers_lr mccmg15_chamfers_lr
#define chamfers_tb mccmg15_chamfers_tb
#define nelements mccmg15_nelements
#define nu mccmg15_nu
#define phase mccmg15_phase
#define reflect mccmg15_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 40285 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component mg16. */
  SIG_MESSAGE("mg16 (Init)");
#define mccompcurname  mg16
#define mccompcurtype  Guide_gravity
#define mccompcurindex 100
#define GVars mccmg16_GVars
#define pTable mccmg16_pTable
#define w1 mccmg16_w1
#define h1 mccmg16_h1
#define w2 mccmg16_w2
#define h2 mccmg16_h2
#define l mccmg16_l
#define R0 mccmg16_R0
#define Qc mccmg16_Qc
#define alpha mccmg16_alpha
#define m mccmg16_m
#define W mccmg16_W
#define nslit mccmg16_nslit
#define d mccmg16_d
#define mleft mccmg16_mleft
#define mright mccmg16_mright
#define mtop mccmg16_mtop
#define mbottom mccmg16_mbottom
#define nhslit mccmg16_nhslit
#define G mccmg16_G
#define aleft mccmg16_aleft
#define aright mccmg16_aright
#define atop mccmg16_atop
#define abottom mccmg16_abottom
#define wavy mccmg16_wavy
#define wavy_z mccmg16_wavy_z
#define wavy_tb mccmg16_wavy_tb
#define wavy_lr mccmg16_wavy_lr
#define chamfers mccmg16_chamfers
#define chamfers_z mccmg16_chamfers_z
#define chamfers_lr mccmg16_chamfers_lr
#define chamfers_tb mccmg16_chamfers_tb
#define nelements mccmg16_nelements
#define nu mccmg16_nu
#define phase mccmg16_phase
#define reflect mccmg16_reflect
#line 339 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  double Gx=0, Gy=-GRAVITY, Gz=0;
  Coords mcLocG;
  int i;

  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"Guide_gravity: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  } else {
    if (W < 0 || R0 < 0 || Qc < 0)
    { fprintf(stderr,"Guide_gravity: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
      exit(-1); }
  }

  if (nslit <= 0 || nhslit <= 0)
  { fprintf(stderr,"Guide_gravity: %s: nslit nhslit must be >0.\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (!w1 || !h1)
  { fprintf(stderr,"Guide_gravity: %s: input window is closed (w1=h1=0).\n", NAME_CURRENT_COMP);
    exit(-1); }

  if (d*nslit > w1) exit(fprintf(stderr, "Guide_gravity: %s: absorbing walls fill input window. No space left for transmission (d*nslit > w1).\n", NAME_CURRENT_COMP));

  if (!w2) w2=w1;
  if (!h2) h2=h1;

  if (mcgravitation) G=-GRAVITY;
  mcLocG = rot_apply(ROT_A_CURRENT_COMP, coords_set(0,G,0));
  coords_get(mcLocG, &Gx, &Gy, &Gz);

  strcpy(GVars.compcurname, NAME_CURRENT_COMP);

  if (l > 0 && nelements > 0) {

    Gravity_guide_Init(&GVars,
      w1, h1, w2, h2, l, R0,
      Qc, alpha, m, W, nslit, d,
      Gx, Gy, Gz, mleft, mright, mtop,
      mbottom, nhslit, wavy_lr, wavy_tb, wavy_z, wavy,
      chamfers_z, chamfers_lr, chamfers_tb, chamfers,nu,phase,aleft,aright,atop,abottom);
    if (!G) for (i=0; i<5; GVars.A[i++] = 0);
    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) {
      if (w1 != w2 || h1 != h2)
      exit(fprintf(stderr,"Guide_gravity: %s: rotating slit pack must be straight (w1=w2 and h1=h2).\n", NAME_CURRENT_COMP));
      printf("Guide_gravity: %s: Fermi Chopper mode: frequency=%g [Hz] phase=%g [deg]\n",
        NAME_CURRENT_COMP, GVars.fc_freq, GVars.fc_phase);
    }
  } else printf("Guide_gravity: %s: unactivated (l=0 or nelements=0)\n", NAME_CURRENT_COMP);

}
#line 40419 "ILL_H15_D11.c"
#undef reflect
#undef phase
#undef nu
#undef nelements
#undef chamfers_tb
#undef chamfers_lr
#undef chamfers_z
#undef chamfers
#undef wavy_lr
#undef wavy_tb
#undef wavy_z
#undef wavy
#undef abottom
#undef atop
#undef aright
#undef aleft
#undef G
#undef nhslit
#undef mbottom
#undef mtop
#undef mright
#undef mleft
#undef d
#undef nslit
#undef W
#undef m
#undef alpha
#undef Qc
#undef R0
#undef l
#undef h2
#undef w2
#undef h1
#undef w1
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component SampleF. */
  SIG_MESSAGE("SampleF (Init)");
#define mccompcurname  SampleF
#define mccompcurtype  Monitor_nD
#define mccompcurindex 101
#define user1 mccSampleF_user1
#define user2 mccSampleF_user2
#define user3 mccSampleF_user3
#define DEFS mccSampleF_DEFS
#define Vars mccSampleF_Vars
#define detector mccSampleF_detector
#define offdata mccSampleF_offdata
#define xwidth mccSampleF_xwidth
#define yheight mccSampleF_yheight
#define zdepth mccSampleF_zdepth
#define xmin mccSampleF_xmin
#define xmax mccSampleF_xmax
#define ymin mccSampleF_ymin
#define ymax mccSampleF_ymax
#define zmin mccSampleF_zmin
#define zmax mccSampleF_zmax
#define bins mccSampleF_bins
#define min mccSampleF_min
#define max mccSampleF_max
#define restore_neutron mccSampleF_restore_neutron
#define radius mccSampleF_radius
#define options mccSampleF_options
#define filename mccSampleF_filename
#define geometry mccSampleF_geometry
#define username1 mccSampleF_username1
#define username2 mccSampleF_username2
#define username3 mccSampleF_username3
#define nowritefile mccSampleF_nowritefile
#line 231 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  char tmp[CHAR_BUF_LENGTH];
  strcpy(Vars.compcurname, NAME_CURRENT_COMP);
  if (options != NULL)
    strncpy(Vars.option, options, CHAR_BUF_LENGTH);
  else {
    strcpy(Vars.option, "x y");
    printf("Monitor_nD: %s has no option specified. Setting to PSD ('x y') monitor.\n", NAME_CURRENT_COMP);
  }
  Vars.compcurpos = POS_A_CURRENT_COMP;

  if (strstr(Vars.option, "source"))
    strcat(Vars.option, " list, x y z vx vy vz t sx sy sz ");

  if (bins) { sprintf(tmp, " all bins=%ld ", (long)bins); strcat(Vars.option, tmp); }
  if (min > -FLT_MAX && max < FLT_MAX) { sprintf(tmp, " all limits=[%g %g]", min, max); strcat(Vars.option, tmp); }
  else if (min > -FLT_MAX) { sprintf(tmp, " all min=%g", min); strcat(Vars.option, tmp); }
  else if (max <  FLT_MAX) { sprintf(tmp, " all max=%g", max); strcat(Vars.option, tmp); }

  strncpy(Vars.UserName1,
    username1 && strlen(username1) && strcmp(username1, "0") && strcmp(username1, "NULL") ?
    username1 : "", 128);
  strncpy(Vars.UserName2,
    username2 && strlen(username2) && strcmp(username2, "0") && strcmp(username2, "NULL") ?
    username2 : "", 128);
  strncpy(Vars.UserName3,
    username3 && strlen(username3) && strcmp(username3, "0") && strcmp(username3, "NULL") ?
    username3 : "", 128);
  if (radius) {
    xwidth = zdepth = 2*radius;
    if (yheight && !strstr(Vars.option, "cylinder") && !strstr(Vars.option, "banana") && !strstr(Vars.option, "sphere"))
      strcat(Vars.option, " banana");
    else if (!yheight && !strstr(Vars.option ,"sphere")) {
      strcat(Vars.option, " sphere");
      yheight=2*radius;
    }
  }
  int offflag=0;
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) {
    if (!off_init(  geometry, xwidth, yheight, zdepth, 1, &offdata )) {
      printf("Monitor_nD: %s could not initiate the OFF geometry %s. \n"
             "            Defaulting to normal Monitor dimensions.\n",
             NAME_CURRENT_COMP, geometry);
      strcpy(geometry, "");
    } else {
      offflag=1;
    }
  }

  if (!radius && !xwidth && !yheight && !zdepth && !xmin && !xmax && !ymin && !ymax &&
    !strstr(Vars.option, "previous") && (!geometry || !strlen(geometry)))
    exit(printf("Monitor_nD: %s has no dimension specified. Aborting (radius, xwidth, yheight, zdepth, previous, geometry).\n", NAME_CURRENT_COMP));

  Monitor_nD_Init(&DEFS, &Vars, xwidth, yheight, zdepth, xmin,xmax,ymin,ymax,zmin,zmax,offflag);

  if (Vars.Flag_OFF) {
    offdata.mantidflag=Vars.Flag_mantid;
    offdata.mantidoffset=Vars.Coord_Min[Vars.Coord_Number-1];
  }


  if (filename && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
    strncpy(Vars.Mon_File, filename, 128);

  /* check if user given filename with ext will be used more than once */
  if ( ((Vars.Flag_Multiple && Vars.Coord_Number > 1) || Vars.Flag_List) && strchr(Vars.Mon_File,'.') )
  { char *XY; XY = strrchr(Vars.Mon_File,'.'); *XY='_'; }

  if (restore_neutron) Vars.Flag_parallel=1;
  detector.m = 0;

#ifdef USE_MPI
MPI_MASTER(
  if (strstr(Vars.option, "auto") && mpi_node_count > 1)
    printf("Monitor_nD: %s is using automatic limits option 'auto' together with MPI.\n"
           "WARNING     this may create incorrect distributions (but integrated flux will be right).\n", NAME_CURRENT_COMP);
);
#endif
}
#line 40573 "ILL_H15_D11.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* Initializations for component SampleC. */
  SIG_MESSAGE("SampleC (Init)");
#define mccompcurname  SampleC
#define mccompcurtype  Monitor_nD
#define mccompcurindex 102
#define user1 mccSampleC_user1
#define user2 mccSampleC_user2
#define user3 mccSampleC_user3
#define DEFS mccSampleC_DEFS
#define Vars mccSampleC_Vars
#define detector mccSampleC_detector
#define offdata mccSampleC_offdata
#define xwidth mccSampleC_xwidth
#define yheight mccSampleC_yheight
#define zdepth mccSampleC_zdepth
#define xmin mccSampleC_xmin
#define xmax mccSampleC_xmax
#define ymin mccSampleC_ymin
#define ymax mccSampleC_ymax
#define zmin mccSampleC_zmin
#define zmax mccSampleC_zmax
#define bins mccSampleC_bins
#define min mccSampleC_min
#define max mccSampleC_max
#define restore_neutron mccSampleC_restore_neutron
#define radius mccSampleC_radius
#define options mccSampleC_options
#define filename mccSampleC_filename
#define geometry mccSampleC_geometry
#define username1 mccSampleC_username1
#define username2 mccSampleC_username2
#define username3 mccSampleC_username3
#define nowritefile mccSampleC_nowritefile
#line 231 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  char tmp[CHAR_BUF_LENGTH];
  strcpy(Vars.compcurname, NAME_CURRENT_COMP);
  if (options != NULL)
    strncpy(Vars.option, options, CHAR_BUF_LENGTH);
  else {
    strcpy(Vars.option, "x y");
    printf("Monitor_nD: %s has no option specified. Setting to PSD ('x y') monitor.\n", NAME_CURRENT_COMP);
  }
  Vars.compcurpos = POS_A_CURRENT_COMP;

  if (strstr(Vars.option, "source"))
    strcat(Vars.option, " list, x y z vx vy vz t sx sy sz ");

  if (bins) { sprintf(tmp, " all bins=%ld ", (long)bins); strcat(Vars.option, tmp); }
  if (min > -FLT_MAX && max < FLT_MAX) { sprintf(tmp, " all limits=[%g %g]", min, max); strcat(Vars.option, tmp); }
  else if (min > -FLT_MAX) { sprintf(tmp, " all min=%g", min); strcat(Vars.option, tmp); }
  else if (max <  FLT_MAX) { sprintf(tmp, " all max=%g", max); strcat(Vars.option, tmp); }

  strncpy(Vars.UserName1,
    username1 && strlen(username1) && strcmp(username1, "0") && strcmp(username1, "NULL") ?
    username1 : "", 128);
  strncpy(Vars.UserName2,
    username2 && strlen(username2) && strcmp(username2, "0") && strcmp(username2, "NULL") ?
    username2 : "", 128);
  strncpy(Vars.UserName3,
    username3 && strlen(username3) && strcmp(username3, "0") && strcmp(username3, "NULL") ?
    username3 : "", 128);
  if (radius) {
    xwidth = zdepth = 2*radius;
    if (yheight && !strstr(Vars.option, "cylinder") && !strstr(Vars.option, "banana") && !strstr(Vars.option, "sphere"))
      strcat(Vars.option, " banana");
    else if (!yheight && !strstr(Vars.option ,"sphere")) {
      strcat(Vars.option, " sphere");
      yheight=2*radius;
    }
  }
  int offflag=0;
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) {
    if (!off_init(  geometry, xwidth, yheight, zdepth, 1, &offdata )) {
      printf("Monitor_nD: %s could not initiate the OFF geometry %s. \n"
             "            Defaulting to normal Monitor dimensions.\n",
             NAME_CURRENT_COMP, geometry);
      strcpy(geometry, "");
    } else {
      offflag=1;
    }
  }

  if (!radius && !xwidth && !yheight && !zdepth && !xmin && !xmax && !ymin && !ymax &&
    !strstr(Vars.option, "previous") && (!geometry || !strlen(geometry)))
    exit(printf("Monitor_nD: %s has no dimension specified. Aborting (radius, xwidth, yheight, zdepth, previous, geometry).\n", NAME_CURRENT_COMP));

  Monitor_nD_Init(&DEFS, &Vars, xwidth, yheight, zdepth, xmin,xmax,ymin,ymax,zmin,zmax,offflag);

  if (Vars.Flag_OFF) {
    offdata.mantidflag=Vars.Flag_mantid;
    offdata.mantidoffset=Vars.Coord_Min[Vars.Coord_Number-1];
  }


  if (filename && strlen(filename) && strcmp(filename,"NULL") && strcmp(filename,"0"))
    strncpy(Vars.Mon_File, filename, 128);

  /* check if user given filename with ext will be used more than once */
  if ( ((Vars.Flag_Multiple && Vars.Coord_Number > 1) || Vars.Flag_List) && strchr(Vars.Mon_File,'.') )
  { char *XY; XY = strrchr(Vars.Mon_File,'.'); *XY='_'; }

  if (restore_neutron) Vars.Flag_parallel=1;
  detector.m = 0;

#ifdef USE_MPI
MPI_MASTER(
  if (strstr(Vars.option, "auto") && mpi_node_count > 1)
    printf("Monitor_nD: %s is using automatic limits option 'auto' together with MPI.\n"
           "WARNING     this may create incorrect distributions (but integrated flux will be right).\n", NAME_CURRENT_COMP);
);
#endif
}
#line 40719 "ILL_H15_D11.c"
#undef nowritefile
#undef username3
#undef username2
#undef username1
#undef geometry
#undef filename
#undef options
#undef radius
#undef restore_neutron
#undef max
#undef min
#undef bins
#undef zmax
#undef zmin
#undef ymax
#undef ymin
#undef xmax
#undef xmin
#undef zdepth
#undef yheight
#undef xwidth
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if(mcdotrace) mcdisplay();
    mcDEBUG_INSTR_END()
  }

} /* end init */

void mcraytrace(void) {
  /* Neutronics-specific defines */
#ifdef NEUTRONICS
extern double mcnx, mcny, mcnz, mcnvx, mcnvy, mcnvz;
extern double mcnt, mcnsx, mcnsy, mcnsz, mcnp;
#endif
  /* End of Neutronics-specific defines */
  /* Copy neutron state to local variables. */
  MCNUM mcnlx = mcnx;
  MCNUM mcnly = mcny;
  MCNUM mcnlz = mcnz;
  MCNUM mcnlvx = mcnvx;
  MCNUM mcnlvy = mcnvy;
  MCNUM mcnlvz = mcnvz;
  MCNUM mcnlt = mcnt;
  MCNUM mcnlsx = mcnsx;
  MCNUM mcnlsy = mcnsy;
  MCNUM mcnlsz = mcnsz;
  MCNUM mcnlp = mcnp;

  mcDEBUG_ENTER()
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define mcabsorb mcabsorbAll
  /* TRACE Component PG [1] */
  mccoordschange(mcposrPG, mcrotrPG,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component PG (without coords transformations) */
  mcJumpTrace_PG:
  SIG_MESSAGE("PG (Trace)");
  mcDEBUG_COMP("PG")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPG
  STORE_NEUTRON(1,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[1]++;
  mcPCounter[1] += p;
  mcP2Counter[1] += p*p;
#define mccompcurname  PG
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccPG_IntermediateCnts
#define StartTime mccPG_StartTime
#define EndTime mccPG_EndTime
#define CurrentTime mccPG_CurrentTime
{   /* Declarations of PG=Progress_bar() SETTING parameters. */
char* profile = mccPG_profile;
MCNUM percent = mccPG_percent;
MCNUM flag_save = mccPG_flag_save;
MCNUM minutes = mccPG_minutes;
#line 70 "/usr/share/mcstas/2.6rc1/misc/Progress_bar.comp"
{
  double ncount;
  ncount = mcget_run_num();
  if (!StartTime) {
    time(&StartTime); /* compute starting time */
    IntermediateCnts = 1e3;
  }
  time_t NowTime;
  time(&NowTime);
  /* compute initial estimate of computation duration */
  if (!EndTime && ncount >= IntermediateCnts) {
    CurrentTime = NowTime;
    if (difftime(NowTime,StartTime) > 10 && ncount) { /* wait 10 sec before writing ETA */
      EndTime = StartTime + (time_t)(difftime(NowTime,StartTime)
				     *(double)mcget_ncount()/ncount);
      IntermediateCnts = 0;
      fprintf(stdout, "\nTrace ETA ");
      if (difftime(EndTime,StartTime) < 60.0)
        fprintf(stdout, "%g [s] %% ", difftime(EndTime,StartTime));
      else if (difftime(EndTime,StartTime) > 3600.0)
        fprintf(stdout, "%g [h] %% ", difftime(EndTime,StartTime)/3600.0);
      else
        fprintf(stdout, "%g [min] %% ", difftime(EndTime,StartTime)/60.0);
    } else IntermediateCnts += 1e3;
    fflush(stdout);
  }

  /* display percentage when percent or minutes have reached step */
  if (EndTime && mcget_ncount() &&
    (    (minutes && difftime(NowTime,CurrentTime) > minutes*60)
      || (percent && !minutes && ncount >= IntermediateCnts))   )
  {
    fprintf(stdout, "%d ", (int)(ncount*100.0/mcget_ncount())); fflush(stdout);
    CurrentTime = NowTime;

    IntermediateCnts = ncount + percent*mcget_ncount()/100;
    /* check that next intermediate ncount check is a multiple of the desired percentage */
    IntermediateCnts = floor(IntermediateCnts*100/percent/mcget_ncount())*percent*mcget_ncount()/100;
    /* raise flag to indicate that we did something */
    SCATTER;
    if (flag_save) mcsave(NULL);
  }
}
#line 40905 "ILL_H15_D11.c"
}   /* End of PG=Progress_bar() SETTING parameter declarations. */
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPG:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(1,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Source [2] */
  mccoordschange(mcposrSource, mcrotrSource,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Source (without coords transformations) */
  mcJumpTrace_Source:
  SIG_MESSAGE("Source (Trace)");
  mcDEBUG_COMP("Source")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompSource
  STORE_NEUTRON(2,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[2]++;
  mcPCounter[2] += p;
  mcP2Counter[2] += p*p;
#define mccompcurname  Source
#define mccompcurtype  Source_gen
#define mccompcurindex 2
#define p_in mccSource_p_in
#define lambda1 mccSource_lambda1
#define lambda2 mccSource_lambda2
#define lambda3 mccSource_lambda3
#define pTable mccSource_pTable
#define pTable_x mccSource_pTable_x
#define pTable_y mccSource_pTable_y
#define pTable_xmin mccSource_pTable_xmin
#define pTable_xmax mccSource_pTable_xmax
#define pTable_xsum mccSource_pTable_xsum
#define pTable_ymin mccSource_pTable_ymin
#define pTable_ymax mccSource_pTable_ymax
#define pTable_ysum mccSource_pTable_ysum
#define pTable_dxmin mccSource_pTable_dxmin
#define pTable_dxmax mccSource_pTable_dxmax
#define pTable_dymin mccSource_pTable_dymin
#define pTable_dymax mccSource_pTable_dymax
{   /* Declarations of Source=Source_gen() SETTING parameters. */
char* flux_file = mccSource_flux_file;
char* xdiv_file = mccSource_xdiv_file;
char* ydiv_file = mccSource_ydiv_file;
MCNUM radius = mccSource_radius;
MCNUM dist = mccSource_dist;
MCNUM focus_xw = mccSource_focus_xw;
MCNUM focus_yh = mccSource_focus_yh;
MCNUM focus_aw = mccSource_focus_aw;
MCNUM focus_ah = mccSource_focus_ah;
MCNUM E0 = mccSource_E0;
MCNUM dE = mccSource_dE;
MCNUM lambda0 = mccSource_lambda0;
MCNUM dlambda = mccSource_dlambda;
MCNUM I1 = mccSource_I1;
MCNUM yheight = mccSource_yheight;
MCNUM xwidth = mccSource_xwidth;
MCNUM verbose = mccSource_verbose;
MCNUM T1 = mccSource_T1;
MCNUM flux_file_perAA = mccSource_flux_file_perAA;
MCNUM flux_file_log = mccSource_flux_file_log;
MCNUM Lmin = mccSource_Lmin;
MCNUM Lmax = mccSource_Lmax;
MCNUM Emin = mccSource_Emin;
MCNUM Emax = mccSource_Emax;
MCNUM T2 = mccSource_T2;
MCNUM I2 = mccSource_I2;
MCNUM T3 = mccSource_T3;
MCNUM I3 = mccSource_I3;
MCNUM zdepth = mccSource_zdepth;
int target_index = mccSource_target_index;
#line 479 "/usr/share/mcstas/2.6rc1/sources/Source_gen.comp"
{
  double dx=0,dy=0,xf,yf,rf,pdir,chi,v,r, lambda;
  double Maxwell;

  if (verbose >= 0)
  {

    z=0;

    if (radius)
    {
      chi=2*PI*rand01();                          /* Choose point on source */
      r=sqrt(rand01())*radius;                    /* with uniform distribution. */
      x=r*cos(chi);
      y=r*sin(chi);
    }
    else
    {
      x = xwidth*randpm1()/2;   /* select point on source (uniform) */
      y = yheight*randpm1()/2;
    }
    if (zdepth != 0)
      z = zdepth*randpm1()/2;
  /* Assume linear wavelength distribution */
    lambda = lambda0+dlambda*randpm1();
    if (lambda <= 0) ABSORB;
    v = K2V*(2*PI/lambda);

    if (!focus_ah && !focus_aw) {
      randvec_target_rect_real(&xf, &yf, &rf, &pdir,
       0, 0, dist, focus_xw, focus_yh, ROT_A_CURRENT_COMP, x, y, z, 2);

      dx = xf-x;
      dy = yf-y;
      rf = sqrt(dx*dx+dy*dy+dist*dist);

      vz=v*dist/rf;
      vy=v*dy/rf;
      vx=v*dx/rf;
    } else {

      randvec_target_rect_angular(&vx, &vy, &vz, &pdir,
          0, 0, 1, focus_aw*DEG2RAD, focus_ah*DEG2RAD, ROT_A_CURRENT_COMP);
      dx = vx; dy = vy; /* from unit vector */
      vx *= v; vy *= v; vz *= v;
    }
    p = p_in*pdir;

    /* spectral dependency from files or Maxwellians */
    if (flux_file && strlen(flux_file) && strcmp(flux_file,"NULL") && strcmp(flux_file,"0"))
    {
       double xwidth=Table_Value(pTable, lambda, 1);
       if (flux_file_log) xwidth=exp(xwidth);
       p *= xwidth;
    }
    else if (T1 > 0 && I1 > 0)
    {
      Maxwell = I1 * SG_Maxwell(lambda, T1);;  /* 1/AA */

      if ((T2 > 0) && (I2 > 0))
      {
        Maxwell += I2 * SG_Maxwell(lambda, T2);
      }
      if ((T3 > 0) && (I3 > 0))
      {
        Maxwell += I3 * SG_Maxwell(lambda, T3);;
      }
      p *= Maxwell;
    }

    /* optional x-xdiv and y-ydiv weightening: position=along columns, div=along rows */
    if (xdiv_file && strlen(xdiv_file)
      && strcmp(xdiv_file,"NULL") && strcmp(xdiv_file,"0") && pTable_xsum > 0) {
      double i,j;
      j = (x-            pTable_xmin) /(pTable_xmax -pTable_xmin) *pTable_x.columns;
      i = (atan2(dx,rf)*RAD2DEG-pTable_dxmin)/(pTable_dxmax-pTable_dxmin)*pTable_x.rows;
      r = Table_Value2d(pTable_x, i,j); /* row, column */
      p *= r/pTable_xsum;
    }
    if (ydiv_file && strlen(ydiv_file)
       && strcmp(ydiv_file,"NULL") && strcmp(ydiv_file,"0") && pTable_ysum > 0) {
      double i,j;
      j = (y-            pTable_ymin) /(pTable_ymax -pTable_ymin) *pTable_y.columns;
      i = (atan2(dy,rf)*RAD2DEG-  pTable_dymin)/(pTable_dymax-pTable_dymin)*pTable_y.rows;
      r = Table_Value2d(pTable_y, i,j);
      p *= r/pTable_ysum;
    }
    SCATTER;
  }
}
#line 41153 "ILL_H15_D11.c"
}   /* End of Source=Source_gen() SETTING parameter declarations. */
#undef pTable_dymax
#undef pTable_dymin
#undef pTable_dxmax
#undef pTable_dxmin
#undef pTable_ysum
#undef pTable_ymax
#undef pTable_ymin
#undef pTable_xsum
#undef pTable_xmax
#undef pTable_xmin
#undef pTable_y
#undef pTable_x
#undef pTable
#undef lambda3
#undef lambda2
#undef lambda1
#undef p_in
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompSource:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(2,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component AlWindow1 [3] */
  mccoordschange(mcposrAlWindow1, mcrotrAlWindow1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component AlWindow1 (without coords transformations) */
  mcJumpTrace_AlWindow1:
  SIG_MESSAGE("AlWindow1 (Trace)");
  mcDEBUG_COMP("AlWindow1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAlWindow1
  STORE_NEUTRON(3,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[3]++;
  mcPCounter[3] += p;
  mcP2Counter[3] += p*p;
#define mccompcurname  AlWindow1
#define mccompcurtype  Al_window
#define mccompcurindex 3
{   /* Declarations of AlWindow1=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow1_thickness;
#line 68 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  double v;                     /* Neutron velocity */
  double dt0;     /* Flight times through sample */
  double dist;
  double Al_s_tot_lambda,Al_my_tot,Al_my_a ; /* total XS (barn), total scattering length (m-1), absorption scat. length */
  double lambda; /* neutrons wavelength */

  PROP_Z0;

  dt0=thickness/vz;
  v=sqrt(vx*vx+vy*vy+vz*vz);
  PROP_DT(dt0);
  dist=v*dt0;

  lambda=sqrt(81.81/(VS2E*v*v));
  Al_s_tot_lambda= Al_pf_A+Al_pf_B1*lambda+ Al_pf_B2*lambda*lambda+ Al_pf_B3*lambda*lambda*lambda;
  Al_s_tot_lambda+=Al_pf_B4*lambda*lambda*lambda*lambda;
  Al_my_tot=Al_rho / Al_mmol * Al_s_tot_lambda * avogadro * 10;
  Al_my_a = Al_my_a_v/v;

  p *=exp(-Al_my_a*dist);/* neutron passes window without any interaction */

  /* TODO: scatter in Debye-Scherrer cone */

}
#line 41303 "ILL_H15_D11.c"
}   /* End of AlWindow1=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAlWindow1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(3,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component PinkCarter [4] */
  mccoordschange(mcposrPinkCarter, mcrotrPinkCarter,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component PinkCarter (without coords transformations) */
  mcJumpTrace_PinkCarter:
  SIG_MESSAGE("PinkCarter (Trace)");
  mcDEBUG_COMP("PinkCarter")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPinkCarter
  STORE_NEUTRON(4,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[4]++;
  mcPCounter[4] += p;
  mcP2Counter[4] += p*p;
#define mccompcurname  PinkCarter
#define mccompcurtype  Guide_gravity
#define mccompcurindex 4
#define GVars mccPinkCarter_GVars
#define pTable mccPinkCarter_pTable
{   /* Declarations of PinkCarter=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccPinkCarter_w1;
MCNUM h1 = mccPinkCarter_h1;
MCNUM w2 = mccPinkCarter_w2;
MCNUM h2 = mccPinkCarter_h2;
MCNUM l = mccPinkCarter_l;
MCNUM R0 = mccPinkCarter_R0;
MCNUM Qc = mccPinkCarter_Qc;
MCNUM alpha = mccPinkCarter_alpha;
MCNUM m = mccPinkCarter_m;
MCNUM W = mccPinkCarter_W;
MCNUM nslit = mccPinkCarter_nslit;
MCNUM d = mccPinkCarter_d;
MCNUM mleft = mccPinkCarter_mleft;
MCNUM mright = mccPinkCarter_mright;
MCNUM mtop = mccPinkCarter_mtop;
MCNUM mbottom = mccPinkCarter_mbottom;
MCNUM nhslit = mccPinkCarter_nhslit;
MCNUM G = mccPinkCarter_G;
MCNUM aleft = mccPinkCarter_aleft;
MCNUM aright = mccPinkCarter_aright;
MCNUM atop = mccPinkCarter_atop;
MCNUM abottom = mccPinkCarter_abottom;
MCNUM wavy = mccPinkCarter_wavy;
MCNUM wavy_z = mccPinkCarter_wavy_z;
MCNUM wavy_tb = mccPinkCarter_wavy_tb;
MCNUM wavy_lr = mccPinkCarter_wavy_lr;
MCNUM chamfers = mccPinkCarter_chamfers;
MCNUM chamfers_z = mccPinkCarter_chamfers_z;
MCNUM chamfers_lr = mccPinkCarter_chamfers_lr;
MCNUM chamfers_tb = mccPinkCarter_chamfers_tb;
MCNUM nelements = mccPinkCarter_nelements;
MCNUM nu = mccPinkCarter_nu;
MCNUM phase = mccPinkCarter_phase;
char* reflect = mccPinkCarter_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 41614 "ILL_H15_D11.c"
}   /* End of PinkCarter=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPinkCarter:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(4,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component AlWindow2 [5] */
  mccoordschange(mcposrAlWindow2, mcrotrAlWindow2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component AlWindow2 (without coords transformations) */
  mcJumpTrace_AlWindow2:
  SIG_MESSAGE("AlWindow2 (Trace)");
  mcDEBUG_COMP("AlWindow2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAlWindow2
  STORE_NEUTRON(5,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[5]++;
  mcPCounter[5] += p;
  mcP2Counter[5] += p*p;
#define mccompcurname  AlWindow2
#define mccompcurtype  Al_window
#define mccompcurindex 5
{   /* Declarations of AlWindow2=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow2_thickness;
#line 68 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  double v;                     /* Neutron velocity */
  double dt0;     /* Flight times through sample */
  double dist;
  double Al_s_tot_lambda,Al_my_tot,Al_my_a ; /* total XS (barn), total scattering length (m-1), absorption scat. length */
  double lambda; /* neutrons wavelength */

  PROP_Z0;

  dt0=thickness/vz;
  v=sqrt(vx*vx+vy*vy+vz*vz);
  PROP_DT(dt0);
  dist=v*dt0;

  lambda=sqrt(81.81/(VS2E*v*v));
  Al_s_tot_lambda= Al_pf_A+Al_pf_B1*lambda+ Al_pf_B2*lambda*lambda+ Al_pf_B3*lambda*lambda*lambda;
  Al_s_tot_lambda+=Al_pf_B4*lambda*lambda*lambda*lambda;
  Al_my_tot=Al_rho / Al_mmol * Al_s_tot_lambda * avogadro * 10;
  Al_my_a = Al_my_a_v/v;

  p *=exp(-Al_my_a*dist);/* neutron passes window without any interaction */

  /* TODO: scatter in Debye-Scherrer cone */

}
#line 41749 "ILL_H15_D11.c"
}   /* End of AlWindow2=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAlWindow2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(5,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component LeadShutter [6] */
  mccoordschange(mcposrLeadShutter, mcrotrLeadShutter,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component LeadShutter (without coords transformations) */
  mcJumpTrace_LeadShutter:
  SIG_MESSAGE("LeadShutter (Trace)");
  mcDEBUG_COMP("LeadShutter")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompLeadShutter
  STORE_NEUTRON(6,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[6]++;
  mcPCounter[6] += p;
  mcP2Counter[6] += p*p;
#define mccompcurname  LeadShutter
#define mccompcurtype  Guide_gravity
#define mccompcurindex 6
#define GVars mccLeadShutter_GVars
#define pTable mccLeadShutter_pTable
{   /* Declarations of LeadShutter=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccLeadShutter_w1;
MCNUM h1 = mccLeadShutter_h1;
MCNUM w2 = mccLeadShutter_w2;
MCNUM h2 = mccLeadShutter_h2;
MCNUM l = mccLeadShutter_l;
MCNUM R0 = mccLeadShutter_R0;
MCNUM Qc = mccLeadShutter_Qc;
MCNUM alpha = mccLeadShutter_alpha;
MCNUM m = mccLeadShutter_m;
MCNUM W = mccLeadShutter_W;
MCNUM nslit = mccLeadShutter_nslit;
MCNUM d = mccLeadShutter_d;
MCNUM mleft = mccLeadShutter_mleft;
MCNUM mright = mccLeadShutter_mright;
MCNUM mtop = mccLeadShutter_mtop;
MCNUM mbottom = mccLeadShutter_mbottom;
MCNUM nhslit = mccLeadShutter_nhslit;
MCNUM G = mccLeadShutter_G;
MCNUM aleft = mccLeadShutter_aleft;
MCNUM aright = mccLeadShutter_aright;
MCNUM atop = mccLeadShutter_atop;
MCNUM abottom = mccLeadShutter_abottom;
MCNUM wavy = mccLeadShutter_wavy;
MCNUM wavy_z = mccLeadShutter_wavy_z;
MCNUM wavy_tb = mccLeadShutter_wavy_tb;
MCNUM wavy_lr = mccLeadShutter_wavy_lr;
MCNUM chamfers = mccLeadShutter_chamfers;
MCNUM chamfers_z = mccLeadShutter_chamfers_z;
MCNUM chamfers_lr = mccLeadShutter_chamfers_lr;
MCNUM chamfers_tb = mccLeadShutter_chamfers_tb;
MCNUM nelements = mccLeadShutter_nelements;
MCNUM nu = mccLeadShutter_nu;
MCNUM phase = mccLeadShutter_phase;
char* reflect = mccLeadShutter_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 42060 "ILL_H15_D11.c"
}   /* End of LeadShutter=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompLeadShutter:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(6,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component AlWindow3 [7] */
  mccoordschange(mcposrAlWindow3, mcrotrAlWindow3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component AlWindow3 (without coords transformations) */
  mcJumpTrace_AlWindow3:
  SIG_MESSAGE("AlWindow3 (Trace)");
  mcDEBUG_COMP("AlWindow3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAlWindow3
  STORE_NEUTRON(7,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[7]++;
  mcPCounter[7] += p;
  mcP2Counter[7] += p*p;
#define mccompcurname  AlWindow3
#define mccompcurtype  Al_window
#define mccompcurindex 7
{   /* Declarations of AlWindow3=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow3_thickness;
#line 68 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  double v;                     /* Neutron velocity */
  double dt0;     /* Flight times through sample */
  double dist;
  double Al_s_tot_lambda,Al_my_tot,Al_my_a ; /* total XS (barn), total scattering length (m-1), absorption scat. length */
  double lambda; /* neutrons wavelength */

  PROP_Z0;

  dt0=thickness/vz;
  v=sqrt(vx*vx+vy*vy+vz*vz);
  PROP_DT(dt0);
  dist=v*dt0;

  lambda=sqrt(81.81/(VS2E*v*v));
  Al_s_tot_lambda= Al_pf_A+Al_pf_B1*lambda+ Al_pf_B2*lambda*lambda+ Al_pf_B3*lambda*lambda*lambda;
  Al_s_tot_lambda+=Al_pf_B4*lambda*lambda*lambda*lambda;
  Al_my_tot=Al_rho / Al_mmol * Al_s_tot_lambda * avogadro * 10;
  Al_my_a = Al_my_a_v/v;

  p *=exp(-Al_my_a*dist);/* neutron passes window without any interaction */

  /* TODO: scatter in Debye-Scherrer cone */

}
#line 42195 "ILL_H15_D11.c"
}   /* End of AlWindow3=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAlWindow3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(7,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component CurvedGuideStart [8] */
  mccoordschange(mcposrCurvedGuideStart, mcrotrCurvedGuideStart,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component CurvedGuideStart (without coords transformations) */
  mcJumpTrace_CurvedGuideStart:
  SIG_MESSAGE("CurvedGuideStart (Trace)");
  mcDEBUG_COMP("CurvedGuideStart")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompCurvedGuideStart
  STORE_NEUTRON(8,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[8]++;
  mcPCounter[8] += p;
  mcP2Counter[8] += p*p;
#define mccompcurname  CurvedGuideStart
#define mccompcurtype  Arm
#define mccompcurindex 8
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompCurvedGuideStart:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(8,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg1 [9] */
  mccoordschange(mcposrcg1, mcrotrcg1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg1 (without coords transformations) */
  mcJumpTrace_cg1:
  SIG_MESSAGE("cg1 (Trace)");
  mcDEBUG_COMP("cg1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg1
  STORE_NEUTRON(9,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[9]++;
  mcPCounter[9] += p;
  mcP2Counter[9] += p*p;
#define mccompcurname  cg1
#define mccompcurtype  Guide_gravity
#define mccompcurindex 9
#define GVars mcccg1_GVars
#define pTable mcccg1_pTable
{   /* Declarations of cg1=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg1_w1;
MCNUM h1 = mcccg1_h1;
MCNUM w2 = mcccg1_w2;
MCNUM h2 = mcccg1_h2;
MCNUM l = mcccg1_l;
MCNUM R0 = mcccg1_R0;
MCNUM Qc = mcccg1_Qc;
MCNUM alpha = mcccg1_alpha;
MCNUM m = mcccg1_m;
MCNUM W = mcccg1_W;
MCNUM nslit = mcccg1_nslit;
MCNUM d = mcccg1_d;
MCNUM mleft = mcccg1_mleft;
MCNUM mright = mcccg1_mright;
MCNUM mtop = mcccg1_mtop;
MCNUM mbottom = mcccg1_mbottom;
MCNUM nhslit = mcccg1_nhslit;
MCNUM G = mcccg1_G;
MCNUM aleft = mcccg1_aleft;
MCNUM aright = mcccg1_aright;
MCNUM atop = mcccg1_atop;
MCNUM abottom = mcccg1_abottom;
MCNUM wavy = mcccg1_wavy;
MCNUM wavy_z = mcccg1_wavy_z;
MCNUM wavy_tb = mcccg1_wavy_tb;
MCNUM wavy_lr = mcccg1_wavy_lr;
MCNUM chamfers = mcccg1_chamfers;
MCNUM chamfers_z = mcccg1_chamfers_z;
MCNUM chamfers_lr = mcccg1_chamfers_lr;
MCNUM chamfers_tb = mcccg1_chamfers_tb;
MCNUM nelements = mcccg1_nelements;
MCNUM nu = mcccg1_nu;
MCNUM phase = mcccg1_phase;
char* reflect = mcccg1_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 42609 "ILL_H15_D11.c"
}   /* End of cg1=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(9,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg2 [10] */
  mccoordschange(mcposrcg2, mcrotrcg2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg2 (without coords transformations) */
  mcJumpTrace_cg2:
  SIG_MESSAGE("cg2 (Trace)");
  mcDEBUG_COMP("cg2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg2
  STORE_NEUTRON(10,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[10]++;
  mcPCounter[10] += p;
  mcP2Counter[10] += p*p;
#define mccompcurname  cg2
#define mccompcurtype  Guide_gravity
#define mccompcurindex 10
#define GVars mcccg2_GVars
#define pTable mcccg2_pTable
{   /* Declarations of cg2=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg2_w1;
MCNUM h1 = mcccg2_h1;
MCNUM w2 = mcccg2_w2;
MCNUM h2 = mcccg2_h2;
MCNUM l = mcccg2_l;
MCNUM R0 = mcccg2_R0;
MCNUM Qc = mcccg2_Qc;
MCNUM alpha = mcccg2_alpha;
MCNUM m = mcccg2_m;
MCNUM W = mcccg2_W;
MCNUM nslit = mcccg2_nslit;
MCNUM d = mcccg2_d;
MCNUM mleft = mcccg2_mleft;
MCNUM mright = mcccg2_mright;
MCNUM mtop = mcccg2_mtop;
MCNUM mbottom = mcccg2_mbottom;
MCNUM nhslit = mcccg2_nhslit;
MCNUM G = mcccg2_G;
MCNUM aleft = mcccg2_aleft;
MCNUM aright = mcccg2_aright;
MCNUM atop = mcccg2_atop;
MCNUM abottom = mcccg2_abottom;
MCNUM wavy = mcccg2_wavy;
MCNUM wavy_z = mcccg2_wavy_z;
MCNUM wavy_tb = mcccg2_wavy_tb;
MCNUM wavy_lr = mcccg2_wavy_lr;
MCNUM chamfers = mcccg2_chamfers;
MCNUM chamfers_z = mcccg2_chamfers_z;
MCNUM chamfers_lr = mcccg2_chamfers_lr;
MCNUM chamfers_tb = mcccg2_chamfers_tb;
MCNUM nelements = mcccg2_nelements;
MCNUM nu = mcccg2_nu;
MCNUM phase = mcccg2_phase;
char* reflect = mcccg2_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 42922 "ILL_H15_D11.c"
}   /* End of cg2=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(10,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg3 [11] */
  mccoordschange(mcposrcg3, mcrotrcg3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg3 (without coords transformations) */
  mcJumpTrace_cg3:
  SIG_MESSAGE("cg3 (Trace)");
  mcDEBUG_COMP("cg3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg3
  STORE_NEUTRON(11,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[11]++;
  mcPCounter[11] += p;
  mcP2Counter[11] += p*p;
#define mccompcurname  cg3
#define mccompcurtype  Guide_gravity
#define mccompcurindex 11
#define GVars mcccg3_GVars
#define pTable mcccg3_pTable
{   /* Declarations of cg3=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg3_w1;
MCNUM h1 = mcccg3_h1;
MCNUM w2 = mcccg3_w2;
MCNUM h2 = mcccg3_h2;
MCNUM l = mcccg3_l;
MCNUM R0 = mcccg3_R0;
MCNUM Qc = mcccg3_Qc;
MCNUM alpha = mcccg3_alpha;
MCNUM m = mcccg3_m;
MCNUM W = mcccg3_W;
MCNUM nslit = mcccg3_nslit;
MCNUM d = mcccg3_d;
MCNUM mleft = mcccg3_mleft;
MCNUM mright = mcccg3_mright;
MCNUM mtop = mcccg3_mtop;
MCNUM mbottom = mcccg3_mbottom;
MCNUM nhslit = mcccg3_nhslit;
MCNUM G = mcccg3_G;
MCNUM aleft = mcccg3_aleft;
MCNUM aright = mcccg3_aright;
MCNUM atop = mcccg3_atop;
MCNUM abottom = mcccg3_abottom;
MCNUM wavy = mcccg3_wavy;
MCNUM wavy_z = mcccg3_wavy_z;
MCNUM wavy_tb = mcccg3_wavy_tb;
MCNUM wavy_lr = mcccg3_wavy_lr;
MCNUM chamfers = mcccg3_chamfers;
MCNUM chamfers_z = mcccg3_chamfers_z;
MCNUM chamfers_lr = mcccg3_chamfers_lr;
MCNUM chamfers_tb = mcccg3_chamfers_tb;
MCNUM nelements = mcccg3_nelements;
MCNUM nu = mcccg3_nu;
MCNUM phase = mcccg3_phase;
char* reflect = mcccg3_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 43235 "ILL_H15_D11.c"
}   /* End of cg3=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(11,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg4 [12] */
  mccoordschange(mcposrcg4, mcrotrcg4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg4 (without coords transformations) */
  mcJumpTrace_cg4:
  SIG_MESSAGE("cg4 (Trace)");
  mcDEBUG_COMP("cg4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg4
  STORE_NEUTRON(12,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[12]++;
  mcPCounter[12] += p;
  mcP2Counter[12] += p*p;
#define mccompcurname  cg4
#define mccompcurtype  Guide_gravity
#define mccompcurindex 12
#define GVars mcccg4_GVars
#define pTable mcccg4_pTable
{   /* Declarations of cg4=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg4_w1;
MCNUM h1 = mcccg4_h1;
MCNUM w2 = mcccg4_w2;
MCNUM h2 = mcccg4_h2;
MCNUM l = mcccg4_l;
MCNUM R0 = mcccg4_R0;
MCNUM Qc = mcccg4_Qc;
MCNUM alpha = mcccg4_alpha;
MCNUM m = mcccg4_m;
MCNUM W = mcccg4_W;
MCNUM nslit = mcccg4_nslit;
MCNUM d = mcccg4_d;
MCNUM mleft = mcccg4_mleft;
MCNUM mright = mcccg4_mright;
MCNUM mtop = mcccg4_mtop;
MCNUM mbottom = mcccg4_mbottom;
MCNUM nhslit = mcccg4_nhslit;
MCNUM G = mcccg4_G;
MCNUM aleft = mcccg4_aleft;
MCNUM aright = mcccg4_aright;
MCNUM atop = mcccg4_atop;
MCNUM abottom = mcccg4_abottom;
MCNUM wavy = mcccg4_wavy;
MCNUM wavy_z = mcccg4_wavy_z;
MCNUM wavy_tb = mcccg4_wavy_tb;
MCNUM wavy_lr = mcccg4_wavy_lr;
MCNUM chamfers = mcccg4_chamfers;
MCNUM chamfers_z = mcccg4_chamfers_z;
MCNUM chamfers_lr = mcccg4_chamfers_lr;
MCNUM chamfers_tb = mcccg4_chamfers_tb;
MCNUM nelements = mcccg4_nelements;
MCNUM nu = mcccg4_nu;
MCNUM phase = mcccg4_phase;
char* reflect = mcccg4_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 43548 "ILL_H15_D11.c"
}   /* End of cg4=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg4:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(12,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg5 [13] */
  mccoordschange(mcposrcg5, mcrotrcg5,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg5 (without coords transformations) */
  mcJumpTrace_cg5:
  SIG_MESSAGE("cg5 (Trace)");
  mcDEBUG_COMP("cg5")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg5
  STORE_NEUTRON(13,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[13]++;
  mcPCounter[13] += p;
  mcP2Counter[13] += p*p;
#define mccompcurname  cg5
#define mccompcurtype  Guide_gravity
#define mccompcurindex 13
#define GVars mcccg5_GVars
#define pTable mcccg5_pTable
{   /* Declarations of cg5=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg5_w1;
MCNUM h1 = mcccg5_h1;
MCNUM w2 = mcccg5_w2;
MCNUM h2 = mcccg5_h2;
MCNUM l = mcccg5_l;
MCNUM R0 = mcccg5_R0;
MCNUM Qc = mcccg5_Qc;
MCNUM alpha = mcccg5_alpha;
MCNUM m = mcccg5_m;
MCNUM W = mcccg5_W;
MCNUM nslit = mcccg5_nslit;
MCNUM d = mcccg5_d;
MCNUM mleft = mcccg5_mleft;
MCNUM mright = mcccg5_mright;
MCNUM mtop = mcccg5_mtop;
MCNUM mbottom = mcccg5_mbottom;
MCNUM nhslit = mcccg5_nhslit;
MCNUM G = mcccg5_G;
MCNUM aleft = mcccg5_aleft;
MCNUM aright = mcccg5_aright;
MCNUM atop = mcccg5_atop;
MCNUM abottom = mcccg5_abottom;
MCNUM wavy = mcccg5_wavy;
MCNUM wavy_z = mcccg5_wavy_z;
MCNUM wavy_tb = mcccg5_wavy_tb;
MCNUM wavy_lr = mcccg5_wavy_lr;
MCNUM chamfers = mcccg5_chamfers;
MCNUM chamfers_z = mcccg5_chamfers_z;
MCNUM chamfers_lr = mcccg5_chamfers_lr;
MCNUM chamfers_tb = mcccg5_chamfers_tb;
MCNUM nelements = mcccg5_nelements;
MCNUM nu = mcccg5_nu;
MCNUM phase = mcccg5_phase;
char* reflect = mcccg5_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 43861 "ILL_H15_D11.c"
}   /* End of cg5=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg5:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(13,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg6 [14] */
  mccoordschange(mcposrcg6, mcrotrcg6,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg6 (without coords transformations) */
  mcJumpTrace_cg6:
  SIG_MESSAGE("cg6 (Trace)");
  mcDEBUG_COMP("cg6")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg6
  STORE_NEUTRON(14,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[14]++;
  mcPCounter[14] += p;
  mcP2Counter[14] += p*p;
#define mccompcurname  cg6
#define mccompcurtype  Guide_gravity
#define mccompcurindex 14
#define GVars mcccg6_GVars
#define pTable mcccg6_pTable
{   /* Declarations of cg6=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg6_w1;
MCNUM h1 = mcccg6_h1;
MCNUM w2 = mcccg6_w2;
MCNUM h2 = mcccg6_h2;
MCNUM l = mcccg6_l;
MCNUM R0 = mcccg6_R0;
MCNUM Qc = mcccg6_Qc;
MCNUM alpha = mcccg6_alpha;
MCNUM m = mcccg6_m;
MCNUM W = mcccg6_W;
MCNUM nslit = mcccg6_nslit;
MCNUM d = mcccg6_d;
MCNUM mleft = mcccg6_mleft;
MCNUM mright = mcccg6_mright;
MCNUM mtop = mcccg6_mtop;
MCNUM mbottom = mcccg6_mbottom;
MCNUM nhslit = mcccg6_nhslit;
MCNUM G = mcccg6_G;
MCNUM aleft = mcccg6_aleft;
MCNUM aright = mcccg6_aright;
MCNUM atop = mcccg6_atop;
MCNUM abottom = mcccg6_abottom;
MCNUM wavy = mcccg6_wavy;
MCNUM wavy_z = mcccg6_wavy_z;
MCNUM wavy_tb = mcccg6_wavy_tb;
MCNUM wavy_lr = mcccg6_wavy_lr;
MCNUM chamfers = mcccg6_chamfers;
MCNUM chamfers_z = mcccg6_chamfers_z;
MCNUM chamfers_lr = mcccg6_chamfers_lr;
MCNUM chamfers_tb = mcccg6_chamfers_tb;
MCNUM nelements = mcccg6_nelements;
MCNUM nu = mcccg6_nu;
MCNUM phase = mcccg6_phase;
char* reflect = mcccg6_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 44174 "ILL_H15_D11.c"
}   /* End of cg6=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg6:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(14,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg7 [15] */
  mccoordschange(mcposrcg7, mcrotrcg7,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg7 (without coords transformations) */
  mcJumpTrace_cg7:
  SIG_MESSAGE("cg7 (Trace)");
  mcDEBUG_COMP("cg7")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg7
  STORE_NEUTRON(15,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[15]++;
  mcPCounter[15] += p;
  mcP2Counter[15] += p*p;
#define mccompcurname  cg7
#define mccompcurtype  Guide_gravity
#define mccompcurindex 15
#define GVars mcccg7_GVars
#define pTable mcccg7_pTable
{   /* Declarations of cg7=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg7_w1;
MCNUM h1 = mcccg7_h1;
MCNUM w2 = mcccg7_w2;
MCNUM h2 = mcccg7_h2;
MCNUM l = mcccg7_l;
MCNUM R0 = mcccg7_R0;
MCNUM Qc = mcccg7_Qc;
MCNUM alpha = mcccg7_alpha;
MCNUM m = mcccg7_m;
MCNUM W = mcccg7_W;
MCNUM nslit = mcccg7_nslit;
MCNUM d = mcccg7_d;
MCNUM mleft = mcccg7_mleft;
MCNUM mright = mcccg7_mright;
MCNUM mtop = mcccg7_mtop;
MCNUM mbottom = mcccg7_mbottom;
MCNUM nhslit = mcccg7_nhslit;
MCNUM G = mcccg7_G;
MCNUM aleft = mcccg7_aleft;
MCNUM aright = mcccg7_aright;
MCNUM atop = mcccg7_atop;
MCNUM abottom = mcccg7_abottom;
MCNUM wavy = mcccg7_wavy;
MCNUM wavy_z = mcccg7_wavy_z;
MCNUM wavy_tb = mcccg7_wavy_tb;
MCNUM wavy_lr = mcccg7_wavy_lr;
MCNUM chamfers = mcccg7_chamfers;
MCNUM chamfers_z = mcccg7_chamfers_z;
MCNUM chamfers_lr = mcccg7_chamfers_lr;
MCNUM chamfers_tb = mcccg7_chamfers_tb;
MCNUM nelements = mcccg7_nelements;
MCNUM nu = mcccg7_nu;
MCNUM phase = mcccg7_phase;
char* reflect = mcccg7_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 44487 "ILL_H15_D11.c"
}   /* End of cg7=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg7:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(15,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg8 [16] */
  mccoordschange(mcposrcg8, mcrotrcg8,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg8 (without coords transformations) */
  mcJumpTrace_cg8:
  SIG_MESSAGE("cg8 (Trace)");
  mcDEBUG_COMP("cg8")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg8
  STORE_NEUTRON(16,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[16]++;
  mcPCounter[16] += p;
  mcP2Counter[16] += p*p;
#define mccompcurname  cg8
#define mccompcurtype  Guide_gravity
#define mccompcurindex 16
#define GVars mcccg8_GVars
#define pTable mcccg8_pTable
{   /* Declarations of cg8=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg8_w1;
MCNUM h1 = mcccg8_h1;
MCNUM w2 = mcccg8_w2;
MCNUM h2 = mcccg8_h2;
MCNUM l = mcccg8_l;
MCNUM R0 = mcccg8_R0;
MCNUM Qc = mcccg8_Qc;
MCNUM alpha = mcccg8_alpha;
MCNUM m = mcccg8_m;
MCNUM W = mcccg8_W;
MCNUM nslit = mcccg8_nslit;
MCNUM d = mcccg8_d;
MCNUM mleft = mcccg8_mleft;
MCNUM mright = mcccg8_mright;
MCNUM mtop = mcccg8_mtop;
MCNUM mbottom = mcccg8_mbottom;
MCNUM nhslit = mcccg8_nhslit;
MCNUM G = mcccg8_G;
MCNUM aleft = mcccg8_aleft;
MCNUM aright = mcccg8_aright;
MCNUM atop = mcccg8_atop;
MCNUM abottom = mcccg8_abottom;
MCNUM wavy = mcccg8_wavy;
MCNUM wavy_z = mcccg8_wavy_z;
MCNUM wavy_tb = mcccg8_wavy_tb;
MCNUM wavy_lr = mcccg8_wavy_lr;
MCNUM chamfers = mcccg8_chamfers;
MCNUM chamfers_z = mcccg8_chamfers_z;
MCNUM chamfers_lr = mcccg8_chamfers_lr;
MCNUM chamfers_tb = mcccg8_chamfers_tb;
MCNUM nelements = mcccg8_nelements;
MCNUM nu = mcccg8_nu;
MCNUM phase = mcccg8_phase;
char* reflect = mcccg8_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 44800 "ILL_H15_D11.c"
}   /* End of cg8=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg8:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(16,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg9 [17] */
  mccoordschange(mcposrcg9, mcrotrcg9,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg9 (without coords transformations) */
  mcJumpTrace_cg9:
  SIG_MESSAGE("cg9 (Trace)");
  mcDEBUG_COMP("cg9")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg9
  STORE_NEUTRON(17,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[17]++;
  mcPCounter[17] += p;
  mcP2Counter[17] += p*p;
#define mccompcurname  cg9
#define mccompcurtype  Guide_gravity
#define mccompcurindex 17
#define GVars mcccg9_GVars
#define pTable mcccg9_pTable
{   /* Declarations of cg9=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg9_w1;
MCNUM h1 = mcccg9_h1;
MCNUM w2 = mcccg9_w2;
MCNUM h2 = mcccg9_h2;
MCNUM l = mcccg9_l;
MCNUM R0 = mcccg9_R0;
MCNUM Qc = mcccg9_Qc;
MCNUM alpha = mcccg9_alpha;
MCNUM m = mcccg9_m;
MCNUM W = mcccg9_W;
MCNUM nslit = mcccg9_nslit;
MCNUM d = mcccg9_d;
MCNUM mleft = mcccg9_mleft;
MCNUM mright = mcccg9_mright;
MCNUM mtop = mcccg9_mtop;
MCNUM mbottom = mcccg9_mbottom;
MCNUM nhslit = mcccg9_nhslit;
MCNUM G = mcccg9_G;
MCNUM aleft = mcccg9_aleft;
MCNUM aright = mcccg9_aright;
MCNUM atop = mcccg9_atop;
MCNUM abottom = mcccg9_abottom;
MCNUM wavy = mcccg9_wavy;
MCNUM wavy_z = mcccg9_wavy_z;
MCNUM wavy_tb = mcccg9_wavy_tb;
MCNUM wavy_lr = mcccg9_wavy_lr;
MCNUM chamfers = mcccg9_chamfers;
MCNUM chamfers_z = mcccg9_chamfers_z;
MCNUM chamfers_lr = mcccg9_chamfers_lr;
MCNUM chamfers_tb = mcccg9_chamfers_tb;
MCNUM nelements = mcccg9_nelements;
MCNUM nu = mcccg9_nu;
MCNUM phase = mcccg9_phase;
char* reflect = mcccg9_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 45113 "ILL_H15_D11.c"
}   /* End of cg9=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg9:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(17,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg10 [18] */
  mccoordschange(mcposrcg10, mcrotrcg10,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg10 (without coords transformations) */
  mcJumpTrace_cg10:
  SIG_MESSAGE("cg10 (Trace)");
  mcDEBUG_COMP("cg10")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg10
  STORE_NEUTRON(18,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[18]++;
  mcPCounter[18] += p;
  mcP2Counter[18] += p*p;
#define mccompcurname  cg10
#define mccompcurtype  Guide_gravity
#define mccompcurindex 18
#define GVars mcccg10_GVars
#define pTable mcccg10_pTable
{   /* Declarations of cg10=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg10_w1;
MCNUM h1 = mcccg10_h1;
MCNUM w2 = mcccg10_w2;
MCNUM h2 = mcccg10_h2;
MCNUM l = mcccg10_l;
MCNUM R0 = mcccg10_R0;
MCNUM Qc = mcccg10_Qc;
MCNUM alpha = mcccg10_alpha;
MCNUM m = mcccg10_m;
MCNUM W = mcccg10_W;
MCNUM nslit = mcccg10_nslit;
MCNUM d = mcccg10_d;
MCNUM mleft = mcccg10_mleft;
MCNUM mright = mcccg10_mright;
MCNUM mtop = mcccg10_mtop;
MCNUM mbottom = mcccg10_mbottom;
MCNUM nhslit = mcccg10_nhslit;
MCNUM G = mcccg10_G;
MCNUM aleft = mcccg10_aleft;
MCNUM aright = mcccg10_aright;
MCNUM atop = mcccg10_atop;
MCNUM abottom = mcccg10_abottom;
MCNUM wavy = mcccg10_wavy;
MCNUM wavy_z = mcccg10_wavy_z;
MCNUM wavy_tb = mcccg10_wavy_tb;
MCNUM wavy_lr = mcccg10_wavy_lr;
MCNUM chamfers = mcccg10_chamfers;
MCNUM chamfers_z = mcccg10_chamfers_z;
MCNUM chamfers_lr = mcccg10_chamfers_lr;
MCNUM chamfers_tb = mcccg10_chamfers_tb;
MCNUM nelements = mcccg10_nelements;
MCNUM nu = mcccg10_nu;
MCNUM phase = mcccg10_phase;
char* reflect = mcccg10_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 45426 "ILL_H15_D11.c"
}   /* End of cg10=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg10:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(18,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg11 [19] */
  mccoordschange(mcposrcg11, mcrotrcg11,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg11 (without coords transformations) */
  mcJumpTrace_cg11:
  SIG_MESSAGE("cg11 (Trace)");
  mcDEBUG_COMP("cg11")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg11
  STORE_NEUTRON(19,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[19]++;
  mcPCounter[19] += p;
  mcP2Counter[19] += p*p;
#define mccompcurname  cg11
#define mccompcurtype  Guide_gravity
#define mccompcurindex 19
#define GVars mcccg11_GVars
#define pTable mcccg11_pTable
{   /* Declarations of cg11=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg11_w1;
MCNUM h1 = mcccg11_h1;
MCNUM w2 = mcccg11_w2;
MCNUM h2 = mcccg11_h2;
MCNUM l = mcccg11_l;
MCNUM R0 = mcccg11_R0;
MCNUM Qc = mcccg11_Qc;
MCNUM alpha = mcccg11_alpha;
MCNUM m = mcccg11_m;
MCNUM W = mcccg11_W;
MCNUM nslit = mcccg11_nslit;
MCNUM d = mcccg11_d;
MCNUM mleft = mcccg11_mleft;
MCNUM mright = mcccg11_mright;
MCNUM mtop = mcccg11_mtop;
MCNUM mbottom = mcccg11_mbottom;
MCNUM nhslit = mcccg11_nhslit;
MCNUM G = mcccg11_G;
MCNUM aleft = mcccg11_aleft;
MCNUM aright = mcccg11_aright;
MCNUM atop = mcccg11_atop;
MCNUM abottom = mcccg11_abottom;
MCNUM wavy = mcccg11_wavy;
MCNUM wavy_z = mcccg11_wavy_z;
MCNUM wavy_tb = mcccg11_wavy_tb;
MCNUM wavy_lr = mcccg11_wavy_lr;
MCNUM chamfers = mcccg11_chamfers;
MCNUM chamfers_z = mcccg11_chamfers_z;
MCNUM chamfers_lr = mcccg11_chamfers_lr;
MCNUM chamfers_tb = mcccg11_chamfers_tb;
MCNUM nelements = mcccg11_nelements;
MCNUM nu = mcccg11_nu;
MCNUM phase = mcccg11_phase;
char* reflect = mcccg11_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 45739 "ILL_H15_D11.c"
}   /* End of cg11=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg11:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(19,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg12 [20] */
  mccoordschange(mcposrcg12, mcrotrcg12,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg12 (without coords transformations) */
  mcJumpTrace_cg12:
  SIG_MESSAGE("cg12 (Trace)");
  mcDEBUG_COMP("cg12")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg12
  STORE_NEUTRON(20,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[20]++;
  mcPCounter[20] += p;
  mcP2Counter[20] += p*p;
#define mccompcurname  cg12
#define mccompcurtype  Guide_gravity
#define mccompcurindex 20
#define GVars mcccg12_GVars
#define pTable mcccg12_pTable
{   /* Declarations of cg12=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg12_w1;
MCNUM h1 = mcccg12_h1;
MCNUM w2 = mcccg12_w2;
MCNUM h2 = mcccg12_h2;
MCNUM l = mcccg12_l;
MCNUM R0 = mcccg12_R0;
MCNUM Qc = mcccg12_Qc;
MCNUM alpha = mcccg12_alpha;
MCNUM m = mcccg12_m;
MCNUM W = mcccg12_W;
MCNUM nslit = mcccg12_nslit;
MCNUM d = mcccg12_d;
MCNUM mleft = mcccg12_mleft;
MCNUM mright = mcccg12_mright;
MCNUM mtop = mcccg12_mtop;
MCNUM mbottom = mcccg12_mbottom;
MCNUM nhslit = mcccg12_nhslit;
MCNUM G = mcccg12_G;
MCNUM aleft = mcccg12_aleft;
MCNUM aright = mcccg12_aright;
MCNUM atop = mcccg12_atop;
MCNUM abottom = mcccg12_abottom;
MCNUM wavy = mcccg12_wavy;
MCNUM wavy_z = mcccg12_wavy_z;
MCNUM wavy_tb = mcccg12_wavy_tb;
MCNUM wavy_lr = mcccg12_wavy_lr;
MCNUM chamfers = mcccg12_chamfers;
MCNUM chamfers_z = mcccg12_chamfers_z;
MCNUM chamfers_lr = mcccg12_chamfers_lr;
MCNUM chamfers_tb = mcccg12_chamfers_tb;
MCNUM nelements = mcccg12_nelements;
MCNUM nu = mcccg12_nu;
MCNUM phase = mcccg12_phase;
char* reflect = mcccg12_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 46052 "ILL_H15_D11.c"
}   /* End of cg12=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg12:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(20,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg13 [21] */
  mccoordschange(mcposrcg13, mcrotrcg13,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg13 (without coords transformations) */
  mcJumpTrace_cg13:
  SIG_MESSAGE("cg13 (Trace)");
  mcDEBUG_COMP("cg13")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg13
  STORE_NEUTRON(21,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[21]++;
  mcPCounter[21] += p;
  mcP2Counter[21] += p*p;
#define mccompcurname  cg13
#define mccompcurtype  Guide_gravity
#define mccompcurindex 21
#define GVars mcccg13_GVars
#define pTable mcccg13_pTable
{   /* Declarations of cg13=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg13_w1;
MCNUM h1 = mcccg13_h1;
MCNUM w2 = mcccg13_w2;
MCNUM h2 = mcccg13_h2;
MCNUM l = mcccg13_l;
MCNUM R0 = mcccg13_R0;
MCNUM Qc = mcccg13_Qc;
MCNUM alpha = mcccg13_alpha;
MCNUM m = mcccg13_m;
MCNUM W = mcccg13_W;
MCNUM nslit = mcccg13_nslit;
MCNUM d = mcccg13_d;
MCNUM mleft = mcccg13_mleft;
MCNUM mright = mcccg13_mright;
MCNUM mtop = mcccg13_mtop;
MCNUM mbottom = mcccg13_mbottom;
MCNUM nhslit = mcccg13_nhslit;
MCNUM G = mcccg13_G;
MCNUM aleft = mcccg13_aleft;
MCNUM aright = mcccg13_aright;
MCNUM atop = mcccg13_atop;
MCNUM abottom = mcccg13_abottom;
MCNUM wavy = mcccg13_wavy;
MCNUM wavy_z = mcccg13_wavy_z;
MCNUM wavy_tb = mcccg13_wavy_tb;
MCNUM wavy_lr = mcccg13_wavy_lr;
MCNUM chamfers = mcccg13_chamfers;
MCNUM chamfers_z = mcccg13_chamfers_z;
MCNUM chamfers_lr = mcccg13_chamfers_lr;
MCNUM chamfers_tb = mcccg13_chamfers_tb;
MCNUM nelements = mcccg13_nelements;
MCNUM nu = mcccg13_nu;
MCNUM phase = mcccg13_phase;
char* reflect = mcccg13_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 46365 "ILL_H15_D11.c"
}   /* End of cg13=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg13:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(21,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg14 [22] */
  mccoordschange(mcposrcg14, mcrotrcg14,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg14 (without coords transformations) */
  mcJumpTrace_cg14:
  SIG_MESSAGE("cg14 (Trace)");
  mcDEBUG_COMP("cg14")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg14
  STORE_NEUTRON(22,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[22]++;
  mcPCounter[22] += p;
  mcP2Counter[22] += p*p;
#define mccompcurname  cg14
#define mccompcurtype  Guide_gravity
#define mccompcurindex 22
#define GVars mcccg14_GVars
#define pTable mcccg14_pTable
{   /* Declarations of cg14=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg14_w1;
MCNUM h1 = mcccg14_h1;
MCNUM w2 = mcccg14_w2;
MCNUM h2 = mcccg14_h2;
MCNUM l = mcccg14_l;
MCNUM R0 = mcccg14_R0;
MCNUM Qc = mcccg14_Qc;
MCNUM alpha = mcccg14_alpha;
MCNUM m = mcccg14_m;
MCNUM W = mcccg14_W;
MCNUM nslit = mcccg14_nslit;
MCNUM d = mcccg14_d;
MCNUM mleft = mcccg14_mleft;
MCNUM mright = mcccg14_mright;
MCNUM mtop = mcccg14_mtop;
MCNUM mbottom = mcccg14_mbottom;
MCNUM nhslit = mcccg14_nhslit;
MCNUM G = mcccg14_G;
MCNUM aleft = mcccg14_aleft;
MCNUM aright = mcccg14_aright;
MCNUM atop = mcccg14_atop;
MCNUM abottom = mcccg14_abottom;
MCNUM wavy = mcccg14_wavy;
MCNUM wavy_z = mcccg14_wavy_z;
MCNUM wavy_tb = mcccg14_wavy_tb;
MCNUM wavy_lr = mcccg14_wavy_lr;
MCNUM chamfers = mcccg14_chamfers;
MCNUM chamfers_z = mcccg14_chamfers_z;
MCNUM chamfers_lr = mcccg14_chamfers_lr;
MCNUM chamfers_tb = mcccg14_chamfers_tb;
MCNUM nelements = mcccg14_nelements;
MCNUM nu = mcccg14_nu;
MCNUM phase = mcccg14_phase;
char* reflect = mcccg14_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 46678 "ILL_H15_D11.c"
}   /* End of cg14=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg14:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(22,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg15 [23] */
  mccoordschange(mcposrcg15, mcrotrcg15,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg15 (without coords transformations) */
  mcJumpTrace_cg15:
  SIG_MESSAGE("cg15 (Trace)");
  mcDEBUG_COMP("cg15")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg15
  STORE_NEUTRON(23,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[23]++;
  mcPCounter[23] += p;
  mcP2Counter[23] += p*p;
#define mccompcurname  cg15
#define mccompcurtype  Guide_gravity
#define mccompcurindex 23
#define GVars mcccg15_GVars
#define pTable mcccg15_pTable
{   /* Declarations of cg15=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg15_w1;
MCNUM h1 = mcccg15_h1;
MCNUM w2 = mcccg15_w2;
MCNUM h2 = mcccg15_h2;
MCNUM l = mcccg15_l;
MCNUM R0 = mcccg15_R0;
MCNUM Qc = mcccg15_Qc;
MCNUM alpha = mcccg15_alpha;
MCNUM m = mcccg15_m;
MCNUM W = mcccg15_W;
MCNUM nslit = mcccg15_nslit;
MCNUM d = mcccg15_d;
MCNUM mleft = mcccg15_mleft;
MCNUM mright = mcccg15_mright;
MCNUM mtop = mcccg15_mtop;
MCNUM mbottom = mcccg15_mbottom;
MCNUM nhslit = mcccg15_nhslit;
MCNUM G = mcccg15_G;
MCNUM aleft = mcccg15_aleft;
MCNUM aright = mcccg15_aright;
MCNUM atop = mcccg15_atop;
MCNUM abottom = mcccg15_abottom;
MCNUM wavy = mcccg15_wavy;
MCNUM wavy_z = mcccg15_wavy_z;
MCNUM wavy_tb = mcccg15_wavy_tb;
MCNUM wavy_lr = mcccg15_wavy_lr;
MCNUM chamfers = mcccg15_chamfers;
MCNUM chamfers_z = mcccg15_chamfers_z;
MCNUM chamfers_lr = mcccg15_chamfers_lr;
MCNUM chamfers_tb = mcccg15_chamfers_tb;
MCNUM nelements = mcccg15_nelements;
MCNUM nu = mcccg15_nu;
MCNUM phase = mcccg15_phase;
char* reflect = mcccg15_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 46991 "ILL_H15_D11.c"
}   /* End of cg15=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg15:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(23,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg16 [24] */
  mccoordschange(mcposrcg16, mcrotrcg16,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg16 (without coords transformations) */
  mcJumpTrace_cg16:
  SIG_MESSAGE("cg16 (Trace)");
  mcDEBUG_COMP("cg16")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg16
  STORE_NEUTRON(24,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[24]++;
  mcPCounter[24] += p;
  mcP2Counter[24] += p*p;
#define mccompcurname  cg16
#define mccompcurtype  Guide_gravity
#define mccompcurindex 24
#define GVars mcccg16_GVars
#define pTable mcccg16_pTable
{   /* Declarations of cg16=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg16_w1;
MCNUM h1 = mcccg16_h1;
MCNUM w2 = mcccg16_w2;
MCNUM h2 = mcccg16_h2;
MCNUM l = mcccg16_l;
MCNUM R0 = mcccg16_R0;
MCNUM Qc = mcccg16_Qc;
MCNUM alpha = mcccg16_alpha;
MCNUM m = mcccg16_m;
MCNUM W = mcccg16_W;
MCNUM nslit = mcccg16_nslit;
MCNUM d = mcccg16_d;
MCNUM mleft = mcccg16_mleft;
MCNUM mright = mcccg16_mright;
MCNUM mtop = mcccg16_mtop;
MCNUM mbottom = mcccg16_mbottom;
MCNUM nhslit = mcccg16_nhslit;
MCNUM G = mcccg16_G;
MCNUM aleft = mcccg16_aleft;
MCNUM aright = mcccg16_aright;
MCNUM atop = mcccg16_atop;
MCNUM abottom = mcccg16_abottom;
MCNUM wavy = mcccg16_wavy;
MCNUM wavy_z = mcccg16_wavy_z;
MCNUM wavy_tb = mcccg16_wavy_tb;
MCNUM wavy_lr = mcccg16_wavy_lr;
MCNUM chamfers = mcccg16_chamfers;
MCNUM chamfers_z = mcccg16_chamfers_z;
MCNUM chamfers_lr = mcccg16_chamfers_lr;
MCNUM chamfers_tb = mcccg16_chamfers_tb;
MCNUM nelements = mcccg16_nelements;
MCNUM nu = mcccg16_nu;
MCNUM phase = mcccg16_phase;
char* reflect = mcccg16_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 47304 "ILL_H15_D11.c"
}   /* End of cg16=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg16:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(24,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg17 [25] */
  mccoordschange(mcposrcg17, mcrotrcg17,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg17 (without coords transformations) */
  mcJumpTrace_cg17:
  SIG_MESSAGE("cg17 (Trace)");
  mcDEBUG_COMP("cg17")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg17
  STORE_NEUTRON(25,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[25]++;
  mcPCounter[25] += p;
  mcP2Counter[25] += p*p;
#define mccompcurname  cg17
#define mccompcurtype  Guide_gravity
#define mccompcurindex 25
#define GVars mcccg17_GVars
#define pTable mcccg17_pTable
{   /* Declarations of cg17=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg17_w1;
MCNUM h1 = mcccg17_h1;
MCNUM w2 = mcccg17_w2;
MCNUM h2 = mcccg17_h2;
MCNUM l = mcccg17_l;
MCNUM R0 = mcccg17_R0;
MCNUM Qc = mcccg17_Qc;
MCNUM alpha = mcccg17_alpha;
MCNUM m = mcccg17_m;
MCNUM W = mcccg17_W;
MCNUM nslit = mcccg17_nslit;
MCNUM d = mcccg17_d;
MCNUM mleft = mcccg17_mleft;
MCNUM mright = mcccg17_mright;
MCNUM mtop = mcccg17_mtop;
MCNUM mbottom = mcccg17_mbottom;
MCNUM nhslit = mcccg17_nhslit;
MCNUM G = mcccg17_G;
MCNUM aleft = mcccg17_aleft;
MCNUM aright = mcccg17_aright;
MCNUM atop = mcccg17_atop;
MCNUM abottom = mcccg17_abottom;
MCNUM wavy = mcccg17_wavy;
MCNUM wavy_z = mcccg17_wavy_z;
MCNUM wavy_tb = mcccg17_wavy_tb;
MCNUM wavy_lr = mcccg17_wavy_lr;
MCNUM chamfers = mcccg17_chamfers;
MCNUM chamfers_z = mcccg17_chamfers_z;
MCNUM chamfers_lr = mcccg17_chamfers_lr;
MCNUM chamfers_tb = mcccg17_chamfers_tb;
MCNUM nelements = mcccg17_nelements;
MCNUM nu = mcccg17_nu;
MCNUM phase = mcccg17_phase;
char* reflect = mcccg17_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 47617 "ILL_H15_D11.c"
}   /* End of cg17=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg17:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(25,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg18 [26] */
  mccoordschange(mcposrcg18, mcrotrcg18,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg18 (without coords transformations) */
  mcJumpTrace_cg18:
  SIG_MESSAGE("cg18 (Trace)");
  mcDEBUG_COMP("cg18")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg18
  STORE_NEUTRON(26,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[26]++;
  mcPCounter[26] += p;
  mcP2Counter[26] += p*p;
#define mccompcurname  cg18
#define mccompcurtype  Guide_gravity
#define mccompcurindex 26
#define GVars mcccg18_GVars
#define pTable mcccg18_pTable
{   /* Declarations of cg18=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg18_w1;
MCNUM h1 = mcccg18_h1;
MCNUM w2 = mcccg18_w2;
MCNUM h2 = mcccg18_h2;
MCNUM l = mcccg18_l;
MCNUM R0 = mcccg18_R0;
MCNUM Qc = mcccg18_Qc;
MCNUM alpha = mcccg18_alpha;
MCNUM m = mcccg18_m;
MCNUM W = mcccg18_W;
MCNUM nslit = mcccg18_nslit;
MCNUM d = mcccg18_d;
MCNUM mleft = mcccg18_mleft;
MCNUM mright = mcccg18_mright;
MCNUM mtop = mcccg18_mtop;
MCNUM mbottom = mcccg18_mbottom;
MCNUM nhslit = mcccg18_nhslit;
MCNUM G = mcccg18_G;
MCNUM aleft = mcccg18_aleft;
MCNUM aright = mcccg18_aright;
MCNUM atop = mcccg18_atop;
MCNUM abottom = mcccg18_abottom;
MCNUM wavy = mcccg18_wavy;
MCNUM wavy_z = mcccg18_wavy_z;
MCNUM wavy_tb = mcccg18_wavy_tb;
MCNUM wavy_lr = mcccg18_wavy_lr;
MCNUM chamfers = mcccg18_chamfers;
MCNUM chamfers_z = mcccg18_chamfers_z;
MCNUM chamfers_lr = mcccg18_chamfers_lr;
MCNUM chamfers_tb = mcccg18_chamfers_tb;
MCNUM nelements = mcccg18_nelements;
MCNUM nu = mcccg18_nu;
MCNUM phase = mcccg18_phase;
char* reflect = mcccg18_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 47930 "ILL_H15_D11.c"
}   /* End of cg18=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg18:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(26,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg19 [27] */
  mccoordschange(mcposrcg19, mcrotrcg19,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg19 (without coords transformations) */
  mcJumpTrace_cg19:
  SIG_MESSAGE("cg19 (Trace)");
  mcDEBUG_COMP("cg19")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg19
  STORE_NEUTRON(27,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[27]++;
  mcPCounter[27] += p;
  mcP2Counter[27] += p*p;
#define mccompcurname  cg19
#define mccompcurtype  Guide_gravity
#define mccompcurindex 27
#define GVars mcccg19_GVars
#define pTable mcccg19_pTable
{   /* Declarations of cg19=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg19_w1;
MCNUM h1 = mcccg19_h1;
MCNUM w2 = mcccg19_w2;
MCNUM h2 = mcccg19_h2;
MCNUM l = mcccg19_l;
MCNUM R0 = mcccg19_R0;
MCNUM Qc = mcccg19_Qc;
MCNUM alpha = mcccg19_alpha;
MCNUM m = mcccg19_m;
MCNUM W = mcccg19_W;
MCNUM nslit = mcccg19_nslit;
MCNUM d = mcccg19_d;
MCNUM mleft = mcccg19_mleft;
MCNUM mright = mcccg19_mright;
MCNUM mtop = mcccg19_mtop;
MCNUM mbottom = mcccg19_mbottom;
MCNUM nhslit = mcccg19_nhslit;
MCNUM G = mcccg19_G;
MCNUM aleft = mcccg19_aleft;
MCNUM aright = mcccg19_aright;
MCNUM atop = mcccg19_atop;
MCNUM abottom = mcccg19_abottom;
MCNUM wavy = mcccg19_wavy;
MCNUM wavy_z = mcccg19_wavy_z;
MCNUM wavy_tb = mcccg19_wavy_tb;
MCNUM wavy_lr = mcccg19_wavy_lr;
MCNUM chamfers = mcccg19_chamfers;
MCNUM chamfers_z = mcccg19_chamfers_z;
MCNUM chamfers_lr = mcccg19_chamfers_lr;
MCNUM chamfers_tb = mcccg19_chamfers_tb;
MCNUM nelements = mcccg19_nelements;
MCNUM nu = mcccg19_nu;
MCNUM phase = mcccg19_phase;
char* reflect = mcccg19_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 48243 "ILL_H15_D11.c"
}   /* End of cg19=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg19:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(27,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg20 [28] */
  mccoordschange(mcposrcg20, mcrotrcg20,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg20 (without coords transformations) */
  mcJumpTrace_cg20:
  SIG_MESSAGE("cg20 (Trace)");
  mcDEBUG_COMP("cg20")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg20
  STORE_NEUTRON(28,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[28]++;
  mcPCounter[28] += p;
  mcP2Counter[28] += p*p;
#define mccompcurname  cg20
#define mccompcurtype  Guide_gravity
#define mccompcurindex 28
#define GVars mcccg20_GVars
#define pTable mcccg20_pTable
{   /* Declarations of cg20=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg20_w1;
MCNUM h1 = mcccg20_h1;
MCNUM w2 = mcccg20_w2;
MCNUM h2 = mcccg20_h2;
MCNUM l = mcccg20_l;
MCNUM R0 = mcccg20_R0;
MCNUM Qc = mcccg20_Qc;
MCNUM alpha = mcccg20_alpha;
MCNUM m = mcccg20_m;
MCNUM W = mcccg20_W;
MCNUM nslit = mcccg20_nslit;
MCNUM d = mcccg20_d;
MCNUM mleft = mcccg20_mleft;
MCNUM mright = mcccg20_mright;
MCNUM mtop = mcccg20_mtop;
MCNUM mbottom = mcccg20_mbottom;
MCNUM nhslit = mcccg20_nhslit;
MCNUM G = mcccg20_G;
MCNUM aleft = mcccg20_aleft;
MCNUM aright = mcccg20_aright;
MCNUM atop = mcccg20_atop;
MCNUM abottom = mcccg20_abottom;
MCNUM wavy = mcccg20_wavy;
MCNUM wavy_z = mcccg20_wavy_z;
MCNUM wavy_tb = mcccg20_wavy_tb;
MCNUM wavy_lr = mcccg20_wavy_lr;
MCNUM chamfers = mcccg20_chamfers;
MCNUM chamfers_z = mcccg20_chamfers_z;
MCNUM chamfers_lr = mcccg20_chamfers_lr;
MCNUM chamfers_tb = mcccg20_chamfers_tb;
MCNUM nelements = mcccg20_nelements;
MCNUM nu = mcccg20_nu;
MCNUM phase = mcccg20_phase;
char* reflect = mcccg20_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 48556 "ILL_H15_D11.c"
}   /* End of cg20=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg20:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(28,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg21 [29] */
  mccoordschange(mcposrcg21, mcrotrcg21,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg21 (without coords transformations) */
  mcJumpTrace_cg21:
  SIG_MESSAGE("cg21 (Trace)");
  mcDEBUG_COMP("cg21")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg21
  STORE_NEUTRON(29,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[29]++;
  mcPCounter[29] += p;
  mcP2Counter[29] += p*p;
#define mccompcurname  cg21
#define mccompcurtype  Guide_gravity
#define mccompcurindex 29
#define GVars mcccg21_GVars
#define pTable mcccg21_pTable
{   /* Declarations of cg21=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg21_w1;
MCNUM h1 = mcccg21_h1;
MCNUM w2 = mcccg21_w2;
MCNUM h2 = mcccg21_h2;
MCNUM l = mcccg21_l;
MCNUM R0 = mcccg21_R0;
MCNUM Qc = mcccg21_Qc;
MCNUM alpha = mcccg21_alpha;
MCNUM m = mcccg21_m;
MCNUM W = mcccg21_W;
MCNUM nslit = mcccg21_nslit;
MCNUM d = mcccg21_d;
MCNUM mleft = mcccg21_mleft;
MCNUM mright = mcccg21_mright;
MCNUM mtop = mcccg21_mtop;
MCNUM mbottom = mcccg21_mbottom;
MCNUM nhslit = mcccg21_nhslit;
MCNUM G = mcccg21_G;
MCNUM aleft = mcccg21_aleft;
MCNUM aright = mcccg21_aright;
MCNUM atop = mcccg21_atop;
MCNUM abottom = mcccg21_abottom;
MCNUM wavy = mcccg21_wavy;
MCNUM wavy_z = mcccg21_wavy_z;
MCNUM wavy_tb = mcccg21_wavy_tb;
MCNUM wavy_lr = mcccg21_wavy_lr;
MCNUM chamfers = mcccg21_chamfers;
MCNUM chamfers_z = mcccg21_chamfers_z;
MCNUM chamfers_lr = mcccg21_chamfers_lr;
MCNUM chamfers_tb = mcccg21_chamfers_tb;
MCNUM nelements = mcccg21_nelements;
MCNUM nu = mcccg21_nu;
MCNUM phase = mcccg21_phase;
char* reflect = mcccg21_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 48869 "ILL_H15_D11.c"
}   /* End of cg21=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg21:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(29,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg22 [30] */
  mccoordschange(mcposrcg22, mcrotrcg22,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg22 (without coords transformations) */
  mcJumpTrace_cg22:
  SIG_MESSAGE("cg22 (Trace)");
  mcDEBUG_COMP("cg22")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg22
  STORE_NEUTRON(30,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[30]++;
  mcPCounter[30] += p;
  mcP2Counter[30] += p*p;
#define mccompcurname  cg22
#define mccompcurtype  Guide_gravity
#define mccompcurindex 30
#define GVars mcccg22_GVars
#define pTable mcccg22_pTable
{   /* Declarations of cg22=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg22_w1;
MCNUM h1 = mcccg22_h1;
MCNUM w2 = mcccg22_w2;
MCNUM h2 = mcccg22_h2;
MCNUM l = mcccg22_l;
MCNUM R0 = mcccg22_R0;
MCNUM Qc = mcccg22_Qc;
MCNUM alpha = mcccg22_alpha;
MCNUM m = mcccg22_m;
MCNUM W = mcccg22_W;
MCNUM nslit = mcccg22_nslit;
MCNUM d = mcccg22_d;
MCNUM mleft = mcccg22_mleft;
MCNUM mright = mcccg22_mright;
MCNUM mtop = mcccg22_mtop;
MCNUM mbottom = mcccg22_mbottom;
MCNUM nhslit = mcccg22_nhslit;
MCNUM G = mcccg22_G;
MCNUM aleft = mcccg22_aleft;
MCNUM aright = mcccg22_aright;
MCNUM atop = mcccg22_atop;
MCNUM abottom = mcccg22_abottom;
MCNUM wavy = mcccg22_wavy;
MCNUM wavy_z = mcccg22_wavy_z;
MCNUM wavy_tb = mcccg22_wavy_tb;
MCNUM wavy_lr = mcccg22_wavy_lr;
MCNUM chamfers = mcccg22_chamfers;
MCNUM chamfers_z = mcccg22_chamfers_z;
MCNUM chamfers_lr = mcccg22_chamfers_lr;
MCNUM chamfers_tb = mcccg22_chamfers_tb;
MCNUM nelements = mcccg22_nelements;
MCNUM nu = mcccg22_nu;
MCNUM phase = mcccg22_phase;
char* reflect = mcccg22_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 49182 "ILL_H15_D11.c"
}   /* End of cg22=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg22:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(30,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg23 [31] */
  mccoordschange(mcposrcg23, mcrotrcg23,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg23 (without coords transformations) */
  mcJumpTrace_cg23:
  SIG_MESSAGE("cg23 (Trace)");
  mcDEBUG_COMP("cg23")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg23
  STORE_NEUTRON(31,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[31]++;
  mcPCounter[31] += p;
  mcP2Counter[31] += p*p;
#define mccompcurname  cg23
#define mccompcurtype  Guide_gravity
#define mccompcurindex 31
#define GVars mcccg23_GVars
#define pTable mcccg23_pTable
{   /* Declarations of cg23=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg23_w1;
MCNUM h1 = mcccg23_h1;
MCNUM w2 = mcccg23_w2;
MCNUM h2 = mcccg23_h2;
MCNUM l = mcccg23_l;
MCNUM R0 = mcccg23_R0;
MCNUM Qc = mcccg23_Qc;
MCNUM alpha = mcccg23_alpha;
MCNUM m = mcccg23_m;
MCNUM W = mcccg23_W;
MCNUM nslit = mcccg23_nslit;
MCNUM d = mcccg23_d;
MCNUM mleft = mcccg23_mleft;
MCNUM mright = mcccg23_mright;
MCNUM mtop = mcccg23_mtop;
MCNUM mbottom = mcccg23_mbottom;
MCNUM nhslit = mcccg23_nhslit;
MCNUM G = mcccg23_G;
MCNUM aleft = mcccg23_aleft;
MCNUM aright = mcccg23_aright;
MCNUM atop = mcccg23_atop;
MCNUM abottom = mcccg23_abottom;
MCNUM wavy = mcccg23_wavy;
MCNUM wavy_z = mcccg23_wavy_z;
MCNUM wavy_tb = mcccg23_wavy_tb;
MCNUM wavy_lr = mcccg23_wavy_lr;
MCNUM chamfers = mcccg23_chamfers;
MCNUM chamfers_z = mcccg23_chamfers_z;
MCNUM chamfers_lr = mcccg23_chamfers_lr;
MCNUM chamfers_tb = mcccg23_chamfers_tb;
MCNUM nelements = mcccg23_nelements;
MCNUM nu = mcccg23_nu;
MCNUM phase = mcccg23_phase;
char* reflect = mcccg23_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 49495 "ILL_H15_D11.c"
}   /* End of cg23=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg23:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(31,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg24 [32] */
  mccoordschange(mcposrcg24, mcrotrcg24,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg24 (without coords transformations) */
  mcJumpTrace_cg24:
  SIG_MESSAGE("cg24 (Trace)");
  mcDEBUG_COMP("cg24")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg24
  STORE_NEUTRON(32,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[32]++;
  mcPCounter[32] += p;
  mcP2Counter[32] += p*p;
#define mccompcurname  cg24
#define mccompcurtype  Guide_gravity
#define mccompcurindex 32
#define GVars mcccg24_GVars
#define pTable mcccg24_pTable
{   /* Declarations of cg24=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg24_w1;
MCNUM h1 = mcccg24_h1;
MCNUM w2 = mcccg24_w2;
MCNUM h2 = mcccg24_h2;
MCNUM l = mcccg24_l;
MCNUM R0 = mcccg24_R0;
MCNUM Qc = mcccg24_Qc;
MCNUM alpha = mcccg24_alpha;
MCNUM m = mcccg24_m;
MCNUM W = mcccg24_W;
MCNUM nslit = mcccg24_nslit;
MCNUM d = mcccg24_d;
MCNUM mleft = mcccg24_mleft;
MCNUM mright = mcccg24_mright;
MCNUM mtop = mcccg24_mtop;
MCNUM mbottom = mcccg24_mbottom;
MCNUM nhslit = mcccg24_nhslit;
MCNUM G = mcccg24_G;
MCNUM aleft = mcccg24_aleft;
MCNUM aright = mcccg24_aright;
MCNUM atop = mcccg24_atop;
MCNUM abottom = mcccg24_abottom;
MCNUM wavy = mcccg24_wavy;
MCNUM wavy_z = mcccg24_wavy_z;
MCNUM wavy_tb = mcccg24_wavy_tb;
MCNUM wavy_lr = mcccg24_wavy_lr;
MCNUM chamfers = mcccg24_chamfers;
MCNUM chamfers_z = mcccg24_chamfers_z;
MCNUM chamfers_lr = mcccg24_chamfers_lr;
MCNUM chamfers_tb = mcccg24_chamfers_tb;
MCNUM nelements = mcccg24_nelements;
MCNUM nu = mcccg24_nu;
MCNUM phase = mcccg24_phase;
char* reflect = mcccg24_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 49808 "ILL_H15_D11.c"
}   /* End of cg24=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg24:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(32,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component cg25 [33] */
  mccoordschange(mcposrcg25, mcrotrcg25,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component cg25 (without coords transformations) */
  mcJumpTrace_cg25:
  SIG_MESSAGE("cg25 (Trace)");
  mcDEBUG_COMP("cg25")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompcg25
  STORE_NEUTRON(33,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[33]++;
  mcPCounter[33] += p;
  mcP2Counter[33] += p*p;
#define mccompcurname  cg25
#define mccompcurtype  Guide_gravity
#define mccompcurindex 33
#define GVars mcccg25_GVars
#define pTable mcccg25_pTable
{   /* Declarations of cg25=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg25_w1;
MCNUM h1 = mcccg25_h1;
MCNUM w2 = mcccg25_w2;
MCNUM h2 = mcccg25_h2;
MCNUM l = mcccg25_l;
MCNUM R0 = mcccg25_R0;
MCNUM Qc = mcccg25_Qc;
MCNUM alpha = mcccg25_alpha;
MCNUM m = mcccg25_m;
MCNUM W = mcccg25_W;
MCNUM nslit = mcccg25_nslit;
MCNUM d = mcccg25_d;
MCNUM mleft = mcccg25_mleft;
MCNUM mright = mcccg25_mright;
MCNUM mtop = mcccg25_mtop;
MCNUM mbottom = mcccg25_mbottom;
MCNUM nhslit = mcccg25_nhslit;
MCNUM G = mcccg25_G;
MCNUM aleft = mcccg25_aleft;
MCNUM aright = mcccg25_aright;
MCNUM atop = mcccg25_atop;
MCNUM abottom = mcccg25_abottom;
MCNUM wavy = mcccg25_wavy;
MCNUM wavy_z = mcccg25_wavy_z;
MCNUM wavy_tb = mcccg25_wavy_tb;
MCNUM wavy_lr = mcccg25_wavy_lr;
MCNUM chamfers = mcccg25_chamfers;
MCNUM chamfers_z = mcccg25_chamfers_z;
MCNUM chamfers_lr = mcccg25_chamfers_lr;
MCNUM chamfers_tb = mcccg25_chamfers_tb;
MCNUM nelements = mcccg25_nelements;
MCNUM nu = mcccg25_nu;
MCNUM phase = mcccg25_phase;
char* reflect = mcccg25_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 50121 "ILL_H15_D11.c"
}   /* End of cg25=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompcg25:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(33,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component AlWindow4 [34] */
  mccoordschange(mcposrAlWindow4, mcrotrAlWindow4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component AlWindow4 (without coords transformations) */
  mcJumpTrace_AlWindow4:
  SIG_MESSAGE("AlWindow4 (Trace)");
  mcDEBUG_COMP("AlWindow4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAlWindow4
  STORE_NEUTRON(34,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[34]++;
  mcPCounter[34] += p;
  mcP2Counter[34] += p*p;
#define mccompcurname  AlWindow4
#define mccompcurtype  Al_window
#define mccompcurindex 34
{   /* Declarations of AlWindow4=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow4_thickness;
#line 68 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  double v;                     /* Neutron velocity */
  double dt0;     /* Flight times through sample */
  double dist;
  double Al_s_tot_lambda,Al_my_tot,Al_my_a ; /* total XS (barn), total scattering length (m-1), absorption scat. length */
  double lambda; /* neutrons wavelength */

  PROP_Z0;

  dt0=thickness/vz;
  v=sqrt(vx*vx+vy*vy+vz*vz);
  PROP_DT(dt0);
  dist=v*dt0;

  lambda=sqrt(81.81/(VS2E*v*v));
  Al_s_tot_lambda= Al_pf_A+Al_pf_B1*lambda+ Al_pf_B2*lambda*lambda+ Al_pf_B3*lambda*lambda*lambda;
  Al_s_tot_lambda+=Al_pf_B4*lambda*lambda*lambda*lambda;
  Al_my_tot=Al_rho / Al_mmol * Al_s_tot_lambda * avogadro * 10;
  Al_my_a = Al_my_a_v/v;

  p *=exp(-Al_my_a*dist);/* neutron passes window without any interaction */

  /* TODO: scatter in Debye-Scherrer cone */

}
#line 50256 "ILL_H15_D11.c"
}   /* End of AlWindow4=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAlWindow4:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(34,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component PSD_VTE [35] */
  mccoordschange(mcposrPSD_VTE, mcrotrPSD_VTE,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component PSD_VTE (without coords transformations) */
  mcJumpTrace_PSD_VTE:
  SIG_MESSAGE("PSD_VTE (Trace)");
  mcDEBUG_COMP("PSD_VTE")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPSD_VTE
  STORE_NEUTRON(35,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[35]++;
  mcPCounter[35] += p;
  mcP2Counter[35] += p*p;
#define mccompcurname  PSD_VTE
#define mccompcurtype  Monitor_nD
#define mccompcurindex 35
#define user1 mccPSD_VTE_user1
#define user2 mccPSD_VTE_user2
#define user3 mccPSD_VTE_user3
#define DEFS mccPSD_VTE_DEFS
#define Vars mccPSD_VTE_Vars
#define detector mccPSD_VTE_detector
#define offdata mccPSD_VTE_offdata
{   /* Declarations of PSD_VTE=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccPSD_VTE_xwidth;
MCNUM yheight = mccPSD_VTE_yheight;
MCNUM zdepth = mccPSD_VTE_zdepth;
MCNUM xmin = mccPSD_VTE_xmin;
MCNUM xmax = mccPSD_VTE_xmax;
MCNUM ymin = mccPSD_VTE_ymin;
MCNUM ymax = mccPSD_VTE_ymax;
MCNUM zmin = mccPSD_VTE_zmin;
MCNUM zmax = mccPSD_VTE_zmax;
MCNUM bins = mccPSD_VTE_bins;
MCNUM min = mccPSD_VTE_min;
MCNUM max = mccPSD_VTE_max;
MCNUM restore_neutron = mccPSD_VTE_restore_neutron;
MCNUM radius = mccPSD_VTE_radius;
char* options = mccPSD_VTE_options;
char* filename = mccPSD_VTE_filename;
char* geometry = mccPSD_VTE_geometry;
char* username1 = mccPSD_VTE_username1;
char* username2 = mccPSD_VTE_username2;
char* username3 = mccPSD_VTE_username3;
int nowritefile = mccPSD_VTE_nowritefile;
#line 312 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  double  XY=0;
  double  t0 = 0;
  double  t1 = 0;
  double  pp;
  int     intersect   = 0;
  char    Flag_Restore = 0;

  if (user1 != FLT_MAX) Vars.UserVariable1 = user1;
  if (user2 != FLT_MAX) Vars.UserVariable2 = user2;
  if (user3 != FLT_MAX) Vars.UserVariable3 = user3;

  /* this is done automatically
    STORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  */

  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    /* determine intersections with object */
    intersect = off_intersect_all(&t0, &t1, NULL, NULL,
       x,y,z, vx, vy, vz, &offdata );
    if (Vars.Flag_mantid) {
      if(intersect) {
        Vars.OFF_polyidx=(offdata.intersects[offdata.nextintersect]).index;
      } else {
        Vars.OFF_polyidx=-1;
      }
    }
  }
  else if ( (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
            || (abs(Vars.Flag_Shape) == DEFS.SHAPE_DISK) ) /* square xy or disk xy */
  {
    // propagate to xy plane and find intersection
    // make sure the event is recoverable afterwards
    t0 = t;
    ALLOW_BACKPROP;
    PROP_Z0;
    if ( (t>=t0) && (z==0.0) ) // forward propagation to xy plane was successful
    {
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
      {
        // square xy
        intersect = (x>=Vars.mxmin && x<=Vars.mxmax && y>=Vars.mymin && y<=Vars.mymax);
      }
      else
      {
        // disk xy
        intersect = (SQR(x) + SQR(y)) <= SQR(Vars.Sphere_Radius);
      }
    }
    else
    {
      intersect=0;
    }
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) /* sphere */
  {
    intersect = sphere_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius);
  /*      intersect = (intersect && t0 > 0); */
  }
  else if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)) /* cylinder */
  {
    intersect = cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius, Vars.Cylinder_Height);
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) /* box */
  {
    intersect = box_intersect(&t0, &t1, x, y, z, vx, vy, vz,
                              fabs(Vars.mxmax-Vars.mxmin), fabs(Vars.mymax-Vars.mymin), fabs(Vars.mzmax-Vars.mzmin));
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_PREVIOUS) /* previous comp */
  { intersect = 1; }

  if (intersect)
  {
    if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND)
     || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)
     || (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) )
    {
      /* check if we have to remove the top/bottom with BANANA shape */
      if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA) && (intersect != 1)) {
        double y0,y1;
        /* propagate to intersection point as temporary variable to check top/bottom */
        y0 = y+t0*vy;
        y1 = y+t1*vy;
        if (fabs(y0) >= Vars.Cylinder_Height/2*0.99) t0 = t1;
        if (fabs(y1) >= Vars.Cylinder_Height/2*0.99) t1 = t0;
      }
      if (t0 < 0 && t1 > 0)
        t0 = t;  /* neutron was already inside ! */
      if (t1 < 0 && t0 > 0) /* neutron exit before entering !! */
        t1 = t;
      /* t0 is now time of incoming intersection with the detection area */
      if ((Vars.Flag_Shape < 0) && (t1 > 0))
        PROP_DT(t1); /* t1 outgoing beam */
      else
        PROP_DT(t0); /* t0 incoming beam */
      /* Final test if we are on lid / bottom of banana/sphere */
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA || abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) {
        if (fabs(y) >= Vars.Cylinder_Height/2*0.99) {
          intersect=0;
          Flag_Restore=1;
        }
      }
    }
  }

  if (intersect)
  {
    /* Now get the data to monitor: current or keep from PreMonitor */
    if (Vars.Flag_UsePreMonitor != 1)
    {
      Vars.cp  = p;
      Vars.cx  = x;
      Vars.cvx = vx;
      Vars.csx = sx;
      Vars.cy  = y;
      Vars.cvy = vy;
      Vars.csy = sy;
      Vars.cz  = z;
      Vars.cvz = vz;
      Vars.csz = sz;
      Vars.ct  = t;
    }

    if ((Vars.He3_pressure > 0) && (t1 != t0) && ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX)))
    {
      XY = exp(-7.417*Vars.He3_pressure*fabs(t1-t0)*2*PI*K2V);
      /* will monitor the absorbed part */
      Vars.cp *= 1-XY;
      /* and modify the neutron weight after monitor, only remains 1-p_detect */
      p *= XY;
    }

    if (Vars.Flag_capture)
    {
      XY = sqrt(Vars.cvx*Vars.cvx+Vars.cvy*Vars.cvy+Vars.cvz*Vars.cvz);
      XY *= V2K;
      if (XY != 0) XY = 2*PI/XY; /* lambda. lambda(2200 m/2) = 1.7985 Angs  */
      Vars.cp *= XY/1.7985;
    }

    pp = Monitor_nD_Trace(&DEFS, &Vars);
    if (pp==0.0)
    { ABSORB;
    }
    else if(pp==1)
    {
      SCATTER;
    }

    if (Vars.Flag_parallel) /* back to neutron state before detection */
      Flag_Restore = 1;
  } /* end if intersection */
  else {
    if (Vars.Flag_Absorb && !Vars.Flag_parallel)
    {
      // restore neutron ray before absorbing for correct mcdisplay
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
      ABSORB;
    }
    else Flag_Restore = 1;  /* no intersection, back to previous state */
  }

  if (Flag_Restore)
  {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 50559 "ILL_H15_D11.c"
}   /* End of PSD_VTE=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPSD_VTE:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(35,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component AlWindow5 [36] */
  mccoordschange(mcposrAlWindow5, mcrotrAlWindow5,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component AlWindow5 (without coords transformations) */
  mcJumpTrace_AlWindow5:
  SIG_MESSAGE("AlWindow5 (Trace)");
  mcDEBUG_COMP("AlWindow5")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAlWindow5
  STORE_NEUTRON(36,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[36]++;
  mcPCounter[36] += p;
  mcP2Counter[36] += p*p;
#define mccompcurname  AlWindow5
#define mccompcurtype  Al_window
#define mccompcurindex 36
{   /* Declarations of AlWindow5=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow5_thickness;
#line 68 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  double v;                     /* Neutron velocity */
  double dt0;     /* Flight times through sample */
  double dist;
  double Al_s_tot_lambda,Al_my_tot,Al_my_a ; /* total XS (barn), total scattering length (m-1), absorption scat. length */
  double lambda; /* neutrons wavelength */

  PROP_Z0;

  dt0=thickness/vz;
  v=sqrt(vx*vx+vy*vy+vz*vz);
  PROP_DT(dt0);
  dist=v*dt0;

  lambda=sqrt(81.81/(VS2E*v*v));
  Al_s_tot_lambda= Al_pf_A+Al_pf_B1*lambda+ Al_pf_B2*lambda*lambda+ Al_pf_B3*lambda*lambda*lambda;
  Al_s_tot_lambda+=Al_pf_B4*lambda*lambda*lambda*lambda;
  Al_my_tot=Al_rho / Al_mmol * Al_s_tot_lambda * avogadro * 10;
  Al_my_a = Al_my_a_v/v;

  p *=exp(-Al_my_a*dist);/* neutron passes window without any interaction */

  /* TODO: scatter in Debye-Scherrer cone */

}
#line 50699 "ILL_H15_D11.c"
}   /* End of AlWindow5=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAlWindow5:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(36,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component VTEtoIN6GuideStart [37] */
  mccoordschange(mcposrVTEtoIN6GuideStart, mcrotrVTEtoIN6GuideStart,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component VTEtoIN6GuideStart (without coords transformations) */
  mcJumpTrace_VTEtoIN6GuideStart:
  SIG_MESSAGE("VTEtoIN6GuideStart (Trace)");
  mcDEBUG_COMP("VTEtoIN6GuideStart")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompVTEtoIN6GuideStart
  STORE_NEUTRON(37,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[37]++;
  mcPCounter[37] += p;
  mcP2Counter[37] += p*p;
#define mccompcurname  VTEtoIN6GuideStart
#define mccompcurtype  Arm
#define mccompcurindex 37
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompVTEtoIN6GuideStart:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(37,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg1 [38] */
  mccoordschange(mcposrsg1, mcrotrsg1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg1 (without coords transformations) */
  mcJumpTrace_sg1:
  SIG_MESSAGE("sg1 (Trace)");
  mcDEBUG_COMP("sg1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg1
  STORE_NEUTRON(38,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[38]++;
  mcPCounter[38] += p;
  mcP2Counter[38] += p*p;
#define mccompcurname  sg1
#define mccompcurtype  Guide_gravity
#define mccompcurindex 38
#define GVars mccsg1_GVars
#define pTable mccsg1_pTable
{   /* Declarations of sg1=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg1_w1;
MCNUM h1 = mccsg1_h1;
MCNUM w2 = mccsg1_w2;
MCNUM h2 = mccsg1_h2;
MCNUM l = mccsg1_l;
MCNUM R0 = mccsg1_R0;
MCNUM Qc = mccsg1_Qc;
MCNUM alpha = mccsg1_alpha;
MCNUM m = mccsg1_m;
MCNUM W = mccsg1_W;
MCNUM nslit = mccsg1_nslit;
MCNUM d = mccsg1_d;
MCNUM mleft = mccsg1_mleft;
MCNUM mright = mccsg1_mright;
MCNUM mtop = mccsg1_mtop;
MCNUM mbottom = mccsg1_mbottom;
MCNUM nhslit = mccsg1_nhslit;
MCNUM G = mccsg1_G;
MCNUM aleft = mccsg1_aleft;
MCNUM aright = mccsg1_aright;
MCNUM atop = mccsg1_atop;
MCNUM abottom = mccsg1_abottom;
MCNUM wavy = mccsg1_wavy;
MCNUM wavy_z = mccsg1_wavy_z;
MCNUM wavy_tb = mccsg1_wavy_tb;
MCNUM wavy_lr = mccsg1_wavy_lr;
MCNUM chamfers = mccsg1_chamfers;
MCNUM chamfers_z = mccsg1_chamfers_z;
MCNUM chamfers_lr = mccsg1_chamfers_lr;
MCNUM chamfers_tb = mccsg1_chamfers_tb;
MCNUM nelements = mccsg1_nelements;
MCNUM nu = mccsg1_nu;
MCNUM phase = mccsg1_phase;
char* reflect = mccsg1_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 51113 "ILL_H15_D11.c"
}   /* End of sg1=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(38,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg2 [39] */
  mccoordschange(mcposrsg2, mcrotrsg2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg2 (without coords transformations) */
  mcJumpTrace_sg2:
  SIG_MESSAGE("sg2 (Trace)");
  mcDEBUG_COMP("sg2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg2
  STORE_NEUTRON(39,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[39]++;
  mcPCounter[39] += p;
  mcP2Counter[39] += p*p;
#define mccompcurname  sg2
#define mccompcurtype  Guide_gravity
#define mccompcurindex 39
#define GVars mccsg2_GVars
#define pTable mccsg2_pTable
{   /* Declarations of sg2=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg2_w1;
MCNUM h1 = mccsg2_h1;
MCNUM w2 = mccsg2_w2;
MCNUM h2 = mccsg2_h2;
MCNUM l = mccsg2_l;
MCNUM R0 = mccsg2_R0;
MCNUM Qc = mccsg2_Qc;
MCNUM alpha = mccsg2_alpha;
MCNUM m = mccsg2_m;
MCNUM W = mccsg2_W;
MCNUM nslit = mccsg2_nslit;
MCNUM d = mccsg2_d;
MCNUM mleft = mccsg2_mleft;
MCNUM mright = mccsg2_mright;
MCNUM mtop = mccsg2_mtop;
MCNUM mbottom = mccsg2_mbottom;
MCNUM nhslit = mccsg2_nhslit;
MCNUM G = mccsg2_G;
MCNUM aleft = mccsg2_aleft;
MCNUM aright = mccsg2_aright;
MCNUM atop = mccsg2_atop;
MCNUM abottom = mccsg2_abottom;
MCNUM wavy = mccsg2_wavy;
MCNUM wavy_z = mccsg2_wavy_z;
MCNUM wavy_tb = mccsg2_wavy_tb;
MCNUM wavy_lr = mccsg2_wavy_lr;
MCNUM chamfers = mccsg2_chamfers;
MCNUM chamfers_z = mccsg2_chamfers_z;
MCNUM chamfers_lr = mccsg2_chamfers_lr;
MCNUM chamfers_tb = mccsg2_chamfers_tb;
MCNUM nelements = mccsg2_nelements;
MCNUM nu = mccsg2_nu;
MCNUM phase = mccsg2_phase;
char* reflect = mccsg2_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 51426 "ILL_H15_D11.c"
}   /* End of sg2=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(39,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg3 [40] */
  mccoordschange(mcposrsg3, mcrotrsg3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg3 (without coords transformations) */
  mcJumpTrace_sg3:
  SIG_MESSAGE("sg3 (Trace)");
  mcDEBUG_COMP("sg3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg3
  STORE_NEUTRON(40,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[40]++;
  mcPCounter[40] += p;
  mcP2Counter[40] += p*p;
#define mccompcurname  sg3
#define mccompcurtype  Guide_gravity
#define mccompcurindex 40
#define GVars mccsg3_GVars
#define pTable mccsg3_pTable
{   /* Declarations of sg3=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg3_w1;
MCNUM h1 = mccsg3_h1;
MCNUM w2 = mccsg3_w2;
MCNUM h2 = mccsg3_h2;
MCNUM l = mccsg3_l;
MCNUM R0 = mccsg3_R0;
MCNUM Qc = mccsg3_Qc;
MCNUM alpha = mccsg3_alpha;
MCNUM m = mccsg3_m;
MCNUM W = mccsg3_W;
MCNUM nslit = mccsg3_nslit;
MCNUM d = mccsg3_d;
MCNUM mleft = mccsg3_mleft;
MCNUM mright = mccsg3_mright;
MCNUM mtop = mccsg3_mtop;
MCNUM mbottom = mccsg3_mbottom;
MCNUM nhslit = mccsg3_nhslit;
MCNUM G = mccsg3_G;
MCNUM aleft = mccsg3_aleft;
MCNUM aright = mccsg3_aright;
MCNUM atop = mccsg3_atop;
MCNUM abottom = mccsg3_abottom;
MCNUM wavy = mccsg3_wavy;
MCNUM wavy_z = mccsg3_wavy_z;
MCNUM wavy_tb = mccsg3_wavy_tb;
MCNUM wavy_lr = mccsg3_wavy_lr;
MCNUM chamfers = mccsg3_chamfers;
MCNUM chamfers_z = mccsg3_chamfers_z;
MCNUM chamfers_lr = mccsg3_chamfers_lr;
MCNUM chamfers_tb = mccsg3_chamfers_tb;
MCNUM nelements = mccsg3_nelements;
MCNUM nu = mccsg3_nu;
MCNUM phase = mccsg3_phase;
char* reflect = mccsg3_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 51739 "ILL_H15_D11.c"
}   /* End of sg3=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(40,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg4 [41] */
  mccoordschange(mcposrsg4, mcrotrsg4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg4 (without coords transformations) */
  mcJumpTrace_sg4:
  SIG_MESSAGE("sg4 (Trace)");
  mcDEBUG_COMP("sg4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg4
  STORE_NEUTRON(41,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[41]++;
  mcPCounter[41] += p;
  mcP2Counter[41] += p*p;
#define mccompcurname  sg4
#define mccompcurtype  Guide_gravity
#define mccompcurindex 41
#define GVars mccsg4_GVars
#define pTable mccsg4_pTable
{   /* Declarations of sg4=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg4_w1;
MCNUM h1 = mccsg4_h1;
MCNUM w2 = mccsg4_w2;
MCNUM h2 = mccsg4_h2;
MCNUM l = mccsg4_l;
MCNUM R0 = mccsg4_R0;
MCNUM Qc = mccsg4_Qc;
MCNUM alpha = mccsg4_alpha;
MCNUM m = mccsg4_m;
MCNUM W = mccsg4_W;
MCNUM nslit = mccsg4_nslit;
MCNUM d = mccsg4_d;
MCNUM mleft = mccsg4_mleft;
MCNUM mright = mccsg4_mright;
MCNUM mtop = mccsg4_mtop;
MCNUM mbottom = mccsg4_mbottom;
MCNUM nhslit = mccsg4_nhslit;
MCNUM G = mccsg4_G;
MCNUM aleft = mccsg4_aleft;
MCNUM aright = mccsg4_aright;
MCNUM atop = mccsg4_atop;
MCNUM abottom = mccsg4_abottom;
MCNUM wavy = mccsg4_wavy;
MCNUM wavy_z = mccsg4_wavy_z;
MCNUM wavy_tb = mccsg4_wavy_tb;
MCNUM wavy_lr = mccsg4_wavy_lr;
MCNUM chamfers = mccsg4_chamfers;
MCNUM chamfers_z = mccsg4_chamfers_z;
MCNUM chamfers_lr = mccsg4_chamfers_lr;
MCNUM chamfers_tb = mccsg4_chamfers_tb;
MCNUM nelements = mccsg4_nelements;
MCNUM nu = mccsg4_nu;
MCNUM phase = mccsg4_phase;
char* reflect = mccsg4_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 52052 "ILL_H15_D11.c"
}   /* End of sg4=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg4:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(41,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg5 [42] */
  mccoordschange(mcposrsg5, mcrotrsg5,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg5 (without coords transformations) */
  mcJumpTrace_sg5:
  SIG_MESSAGE("sg5 (Trace)");
  mcDEBUG_COMP("sg5")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg5
  STORE_NEUTRON(42,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[42]++;
  mcPCounter[42] += p;
  mcP2Counter[42] += p*p;
#define mccompcurname  sg5
#define mccompcurtype  Guide_gravity
#define mccompcurindex 42
#define GVars mccsg5_GVars
#define pTable mccsg5_pTable
{   /* Declarations of sg5=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg5_w1;
MCNUM h1 = mccsg5_h1;
MCNUM w2 = mccsg5_w2;
MCNUM h2 = mccsg5_h2;
MCNUM l = mccsg5_l;
MCNUM R0 = mccsg5_R0;
MCNUM Qc = mccsg5_Qc;
MCNUM alpha = mccsg5_alpha;
MCNUM m = mccsg5_m;
MCNUM W = mccsg5_W;
MCNUM nslit = mccsg5_nslit;
MCNUM d = mccsg5_d;
MCNUM mleft = mccsg5_mleft;
MCNUM mright = mccsg5_mright;
MCNUM mtop = mccsg5_mtop;
MCNUM mbottom = mccsg5_mbottom;
MCNUM nhslit = mccsg5_nhslit;
MCNUM G = mccsg5_G;
MCNUM aleft = mccsg5_aleft;
MCNUM aright = mccsg5_aright;
MCNUM atop = mccsg5_atop;
MCNUM abottom = mccsg5_abottom;
MCNUM wavy = mccsg5_wavy;
MCNUM wavy_z = mccsg5_wavy_z;
MCNUM wavy_tb = mccsg5_wavy_tb;
MCNUM wavy_lr = mccsg5_wavy_lr;
MCNUM chamfers = mccsg5_chamfers;
MCNUM chamfers_z = mccsg5_chamfers_z;
MCNUM chamfers_lr = mccsg5_chamfers_lr;
MCNUM chamfers_tb = mccsg5_chamfers_tb;
MCNUM nelements = mccsg5_nelements;
MCNUM nu = mccsg5_nu;
MCNUM phase = mccsg5_phase;
char* reflect = mccsg5_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 52365 "ILL_H15_D11.c"
}   /* End of sg5=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg5:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(42,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg6 [43] */
  mccoordschange(mcposrsg6, mcrotrsg6,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg6 (without coords transformations) */
  mcJumpTrace_sg6:
  SIG_MESSAGE("sg6 (Trace)");
  mcDEBUG_COMP("sg6")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg6
  STORE_NEUTRON(43,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[43]++;
  mcPCounter[43] += p;
  mcP2Counter[43] += p*p;
#define mccompcurname  sg6
#define mccompcurtype  Guide_gravity
#define mccompcurindex 43
#define GVars mccsg6_GVars
#define pTable mccsg6_pTable
{   /* Declarations of sg6=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg6_w1;
MCNUM h1 = mccsg6_h1;
MCNUM w2 = mccsg6_w2;
MCNUM h2 = mccsg6_h2;
MCNUM l = mccsg6_l;
MCNUM R0 = mccsg6_R0;
MCNUM Qc = mccsg6_Qc;
MCNUM alpha = mccsg6_alpha;
MCNUM m = mccsg6_m;
MCNUM W = mccsg6_W;
MCNUM nslit = mccsg6_nslit;
MCNUM d = mccsg6_d;
MCNUM mleft = mccsg6_mleft;
MCNUM mright = mccsg6_mright;
MCNUM mtop = mccsg6_mtop;
MCNUM mbottom = mccsg6_mbottom;
MCNUM nhslit = mccsg6_nhslit;
MCNUM G = mccsg6_G;
MCNUM aleft = mccsg6_aleft;
MCNUM aright = mccsg6_aright;
MCNUM atop = mccsg6_atop;
MCNUM abottom = mccsg6_abottom;
MCNUM wavy = mccsg6_wavy;
MCNUM wavy_z = mccsg6_wavy_z;
MCNUM wavy_tb = mccsg6_wavy_tb;
MCNUM wavy_lr = mccsg6_wavy_lr;
MCNUM chamfers = mccsg6_chamfers;
MCNUM chamfers_z = mccsg6_chamfers_z;
MCNUM chamfers_lr = mccsg6_chamfers_lr;
MCNUM chamfers_tb = mccsg6_chamfers_tb;
MCNUM nelements = mccsg6_nelements;
MCNUM nu = mccsg6_nu;
MCNUM phase = mccsg6_phase;
char* reflect = mccsg6_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 52678 "ILL_H15_D11.c"
}   /* End of sg6=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg6:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(43,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg7 [44] */
  mccoordschange(mcposrsg7, mcrotrsg7,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg7 (without coords transformations) */
  mcJumpTrace_sg7:
  SIG_MESSAGE("sg7 (Trace)");
  mcDEBUG_COMP("sg7")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg7
  STORE_NEUTRON(44,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[44]++;
  mcPCounter[44] += p;
  mcP2Counter[44] += p*p;
#define mccompcurname  sg7
#define mccompcurtype  Guide_gravity
#define mccompcurindex 44
#define GVars mccsg7_GVars
#define pTable mccsg7_pTable
{   /* Declarations of sg7=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg7_w1;
MCNUM h1 = mccsg7_h1;
MCNUM w2 = mccsg7_w2;
MCNUM h2 = mccsg7_h2;
MCNUM l = mccsg7_l;
MCNUM R0 = mccsg7_R0;
MCNUM Qc = mccsg7_Qc;
MCNUM alpha = mccsg7_alpha;
MCNUM m = mccsg7_m;
MCNUM W = mccsg7_W;
MCNUM nslit = mccsg7_nslit;
MCNUM d = mccsg7_d;
MCNUM mleft = mccsg7_mleft;
MCNUM mright = mccsg7_mright;
MCNUM mtop = mccsg7_mtop;
MCNUM mbottom = mccsg7_mbottom;
MCNUM nhslit = mccsg7_nhslit;
MCNUM G = mccsg7_G;
MCNUM aleft = mccsg7_aleft;
MCNUM aright = mccsg7_aright;
MCNUM atop = mccsg7_atop;
MCNUM abottom = mccsg7_abottom;
MCNUM wavy = mccsg7_wavy;
MCNUM wavy_z = mccsg7_wavy_z;
MCNUM wavy_tb = mccsg7_wavy_tb;
MCNUM wavy_lr = mccsg7_wavy_lr;
MCNUM chamfers = mccsg7_chamfers;
MCNUM chamfers_z = mccsg7_chamfers_z;
MCNUM chamfers_lr = mccsg7_chamfers_lr;
MCNUM chamfers_tb = mccsg7_chamfers_tb;
MCNUM nelements = mccsg7_nelements;
MCNUM nu = mccsg7_nu;
MCNUM phase = mccsg7_phase;
char* reflect = mccsg7_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 52991 "ILL_H15_D11.c"
}   /* End of sg7=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg7:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(44,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg8 [45] */
  mccoordschange(mcposrsg8, mcrotrsg8,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg8 (without coords transformations) */
  mcJumpTrace_sg8:
  SIG_MESSAGE("sg8 (Trace)");
  mcDEBUG_COMP("sg8")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg8
  STORE_NEUTRON(45,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[45]++;
  mcPCounter[45] += p;
  mcP2Counter[45] += p*p;
#define mccompcurname  sg8
#define mccompcurtype  Guide_gravity
#define mccompcurindex 45
#define GVars mccsg8_GVars
#define pTable mccsg8_pTable
{   /* Declarations of sg8=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg8_w1;
MCNUM h1 = mccsg8_h1;
MCNUM w2 = mccsg8_w2;
MCNUM h2 = mccsg8_h2;
MCNUM l = mccsg8_l;
MCNUM R0 = mccsg8_R0;
MCNUM Qc = mccsg8_Qc;
MCNUM alpha = mccsg8_alpha;
MCNUM m = mccsg8_m;
MCNUM W = mccsg8_W;
MCNUM nslit = mccsg8_nslit;
MCNUM d = mccsg8_d;
MCNUM mleft = mccsg8_mleft;
MCNUM mright = mccsg8_mright;
MCNUM mtop = mccsg8_mtop;
MCNUM mbottom = mccsg8_mbottom;
MCNUM nhslit = mccsg8_nhslit;
MCNUM G = mccsg8_G;
MCNUM aleft = mccsg8_aleft;
MCNUM aright = mccsg8_aright;
MCNUM atop = mccsg8_atop;
MCNUM abottom = mccsg8_abottom;
MCNUM wavy = mccsg8_wavy;
MCNUM wavy_z = mccsg8_wavy_z;
MCNUM wavy_tb = mccsg8_wavy_tb;
MCNUM wavy_lr = mccsg8_wavy_lr;
MCNUM chamfers = mccsg8_chamfers;
MCNUM chamfers_z = mccsg8_chamfers_z;
MCNUM chamfers_lr = mccsg8_chamfers_lr;
MCNUM chamfers_tb = mccsg8_chamfers_tb;
MCNUM nelements = mccsg8_nelements;
MCNUM nu = mccsg8_nu;
MCNUM phase = mccsg8_phase;
char* reflect = mccsg8_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 53304 "ILL_H15_D11.c"
}   /* End of sg8=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg8:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(45,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg9 [46] */
  mccoordschange(mcposrsg9, mcrotrsg9,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg9 (without coords transformations) */
  mcJumpTrace_sg9:
  SIG_MESSAGE("sg9 (Trace)");
  mcDEBUG_COMP("sg9")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg9
  STORE_NEUTRON(46,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[46]++;
  mcPCounter[46] += p;
  mcP2Counter[46] += p*p;
#define mccompcurname  sg9
#define mccompcurtype  Guide_gravity
#define mccompcurindex 46
#define GVars mccsg9_GVars
#define pTable mccsg9_pTable
{   /* Declarations of sg9=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg9_w1;
MCNUM h1 = mccsg9_h1;
MCNUM w2 = mccsg9_w2;
MCNUM h2 = mccsg9_h2;
MCNUM l = mccsg9_l;
MCNUM R0 = mccsg9_R0;
MCNUM Qc = mccsg9_Qc;
MCNUM alpha = mccsg9_alpha;
MCNUM m = mccsg9_m;
MCNUM W = mccsg9_W;
MCNUM nslit = mccsg9_nslit;
MCNUM d = mccsg9_d;
MCNUM mleft = mccsg9_mleft;
MCNUM mright = mccsg9_mright;
MCNUM mtop = mccsg9_mtop;
MCNUM mbottom = mccsg9_mbottom;
MCNUM nhslit = mccsg9_nhslit;
MCNUM G = mccsg9_G;
MCNUM aleft = mccsg9_aleft;
MCNUM aright = mccsg9_aright;
MCNUM atop = mccsg9_atop;
MCNUM abottom = mccsg9_abottom;
MCNUM wavy = mccsg9_wavy;
MCNUM wavy_z = mccsg9_wavy_z;
MCNUM wavy_tb = mccsg9_wavy_tb;
MCNUM wavy_lr = mccsg9_wavy_lr;
MCNUM chamfers = mccsg9_chamfers;
MCNUM chamfers_z = mccsg9_chamfers_z;
MCNUM chamfers_lr = mccsg9_chamfers_lr;
MCNUM chamfers_tb = mccsg9_chamfers_tb;
MCNUM nelements = mccsg9_nelements;
MCNUM nu = mccsg9_nu;
MCNUM phase = mccsg9_phase;
char* reflect = mccsg9_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 53617 "ILL_H15_D11.c"
}   /* End of sg9=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg9:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(46,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg10 [47] */
  mccoordschange(mcposrsg10, mcrotrsg10,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg10 (without coords transformations) */
  mcJumpTrace_sg10:
  SIG_MESSAGE("sg10 (Trace)");
  mcDEBUG_COMP("sg10")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg10
  STORE_NEUTRON(47,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[47]++;
  mcPCounter[47] += p;
  mcP2Counter[47] += p*p;
#define mccompcurname  sg10
#define mccompcurtype  Guide_gravity
#define mccompcurindex 47
#define GVars mccsg10_GVars
#define pTable mccsg10_pTable
{   /* Declarations of sg10=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg10_w1;
MCNUM h1 = mccsg10_h1;
MCNUM w2 = mccsg10_w2;
MCNUM h2 = mccsg10_h2;
MCNUM l = mccsg10_l;
MCNUM R0 = mccsg10_R0;
MCNUM Qc = mccsg10_Qc;
MCNUM alpha = mccsg10_alpha;
MCNUM m = mccsg10_m;
MCNUM W = mccsg10_W;
MCNUM nslit = mccsg10_nslit;
MCNUM d = mccsg10_d;
MCNUM mleft = mccsg10_mleft;
MCNUM mright = mccsg10_mright;
MCNUM mtop = mccsg10_mtop;
MCNUM mbottom = mccsg10_mbottom;
MCNUM nhslit = mccsg10_nhslit;
MCNUM G = mccsg10_G;
MCNUM aleft = mccsg10_aleft;
MCNUM aright = mccsg10_aright;
MCNUM atop = mccsg10_atop;
MCNUM abottom = mccsg10_abottom;
MCNUM wavy = mccsg10_wavy;
MCNUM wavy_z = mccsg10_wavy_z;
MCNUM wavy_tb = mccsg10_wavy_tb;
MCNUM wavy_lr = mccsg10_wavy_lr;
MCNUM chamfers = mccsg10_chamfers;
MCNUM chamfers_z = mccsg10_chamfers_z;
MCNUM chamfers_lr = mccsg10_chamfers_lr;
MCNUM chamfers_tb = mccsg10_chamfers_tb;
MCNUM nelements = mccsg10_nelements;
MCNUM nu = mccsg10_nu;
MCNUM phase = mccsg10_phase;
char* reflect = mccsg10_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 53930 "ILL_H15_D11.c"
}   /* End of sg10=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg10:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(47,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg11 [48] */
  mccoordschange(mcposrsg11, mcrotrsg11,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg11 (without coords transformations) */
  mcJumpTrace_sg11:
  SIG_MESSAGE("sg11 (Trace)");
  mcDEBUG_COMP("sg11")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg11
  STORE_NEUTRON(48,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[48]++;
  mcPCounter[48] += p;
  mcP2Counter[48] += p*p;
#define mccompcurname  sg11
#define mccompcurtype  Guide_gravity
#define mccompcurindex 48
#define GVars mccsg11_GVars
#define pTable mccsg11_pTable
{   /* Declarations of sg11=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg11_w1;
MCNUM h1 = mccsg11_h1;
MCNUM w2 = mccsg11_w2;
MCNUM h2 = mccsg11_h2;
MCNUM l = mccsg11_l;
MCNUM R0 = mccsg11_R0;
MCNUM Qc = mccsg11_Qc;
MCNUM alpha = mccsg11_alpha;
MCNUM m = mccsg11_m;
MCNUM W = mccsg11_W;
MCNUM nslit = mccsg11_nslit;
MCNUM d = mccsg11_d;
MCNUM mleft = mccsg11_mleft;
MCNUM mright = mccsg11_mright;
MCNUM mtop = mccsg11_mtop;
MCNUM mbottom = mccsg11_mbottom;
MCNUM nhslit = mccsg11_nhslit;
MCNUM G = mccsg11_G;
MCNUM aleft = mccsg11_aleft;
MCNUM aright = mccsg11_aright;
MCNUM atop = mccsg11_atop;
MCNUM abottom = mccsg11_abottom;
MCNUM wavy = mccsg11_wavy;
MCNUM wavy_z = mccsg11_wavy_z;
MCNUM wavy_tb = mccsg11_wavy_tb;
MCNUM wavy_lr = mccsg11_wavy_lr;
MCNUM chamfers = mccsg11_chamfers;
MCNUM chamfers_z = mccsg11_chamfers_z;
MCNUM chamfers_lr = mccsg11_chamfers_lr;
MCNUM chamfers_tb = mccsg11_chamfers_tb;
MCNUM nelements = mccsg11_nelements;
MCNUM nu = mccsg11_nu;
MCNUM phase = mccsg11_phase;
char* reflect = mccsg11_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 54243 "ILL_H15_D11.c"
}   /* End of sg11=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg11:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(48,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg12 [49] */
  mccoordschange(mcposrsg12, mcrotrsg12,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg12 (without coords transformations) */
  mcJumpTrace_sg12:
  SIG_MESSAGE("sg12 (Trace)");
  mcDEBUG_COMP("sg12")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg12
  STORE_NEUTRON(49,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[49]++;
  mcPCounter[49] += p;
  mcP2Counter[49] += p*p;
#define mccompcurname  sg12
#define mccompcurtype  Guide_gravity
#define mccompcurindex 49
#define GVars mccsg12_GVars
#define pTable mccsg12_pTable
{   /* Declarations of sg12=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg12_w1;
MCNUM h1 = mccsg12_h1;
MCNUM w2 = mccsg12_w2;
MCNUM h2 = mccsg12_h2;
MCNUM l = mccsg12_l;
MCNUM R0 = mccsg12_R0;
MCNUM Qc = mccsg12_Qc;
MCNUM alpha = mccsg12_alpha;
MCNUM m = mccsg12_m;
MCNUM W = mccsg12_W;
MCNUM nslit = mccsg12_nslit;
MCNUM d = mccsg12_d;
MCNUM mleft = mccsg12_mleft;
MCNUM mright = mccsg12_mright;
MCNUM mtop = mccsg12_mtop;
MCNUM mbottom = mccsg12_mbottom;
MCNUM nhslit = mccsg12_nhslit;
MCNUM G = mccsg12_G;
MCNUM aleft = mccsg12_aleft;
MCNUM aright = mccsg12_aright;
MCNUM atop = mccsg12_atop;
MCNUM abottom = mccsg12_abottom;
MCNUM wavy = mccsg12_wavy;
MCNUM wavy_z = mccsg12_wavy_z;
MCNUM wavy_tb = mccsg12_wavy_tb;
MCNUM wavy_lr = mccsg12_wavy_lr;
MCNUM chamfers = mccsg12_chamfers;
MCNUM chamfers_z = mccsg12_chamfers_z;
MCNUM chamfers_lr = mccsg12_chamfers_lr;
MCNUM chamfers_tb = mccsg12_chamfers_tb;
MCNUM nelements = mccsg12_nelements;
MCNUM nu = mccsg12_nu;
MCNUM phase = mccsg12_phase;
char* reflect = mccsg12_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 54556 "ILL_H15_D11.c"
}   /* End of sg12=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg12:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(49,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg13 [50] */
  mccoordschange(mcposrsg13, mcrotrsg13,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg13 (without coords transformations) */
  mcJumpTrace_sg13:
  SIG_MESSAGE("sg13 (Trace)");
  mcDEBUG_COMP("sg13")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg13
  STORE_NEUTRON(50,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[50]++;
  mcPCounter[50] += p;
  mcP2Counter[50] += p*p;
#define mccompcurname  sg13
#define mccompcurtype  Guide_gravity
#define mccompcurindex 50
#define GVars mccsg13_GVars
#define pTable mccsg13_pTable
{   /* Declarations of sg13=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg13_w1;
MCNUM h1 = mccsg13_h1;
MCNUM w2 = mccsg13_w2;
MCNUM h2 = mccsg13_h2;
MCNUM l = mccsg13_l;
MCNUM R0 = mccsg13_R0;
MCNUM Qc = mccsg13_Qc;
MCNUM alpha = mccsg13_alpha;
MCNUM m = mccsg13_m;
MCNUM W = mccsg13_W;
MCNUM nslit = mccsg13_nslit;
MCNUM d = mccsg13_d;
MCNUM mleft = mccsg13_mleft;
MCNUM mright = mccsg13_mright;
MCNUM mtop = mccsg13_mtop;
MCNUM mbottom = mccsg13_mbottom;
MCNUM nhslit = mccsg13_nhslit;
MCNUM G = mccsg13_G;
MCNUM aleft = mccsg13_aleft;
MCNUM aright = mccsg13_aright;
MCNUM atop = mccsg13_atop;
MCNUM abottom = mccsg13_abottom;
MCNUM wavy = mccsg13_wavy;
MCNUM wavy_z = mccsg13_wavy_z;
MCNUM wavy_tb = mccsg13_wavy_tb;
MCNUM wavy_lr = mccsg13_wavy_lr;
MCNUM chamfers = mccsg13_chamfers;
MCNUM chamfers_z = mccsg13_chamfers_z;
MCNUM chamfers_lr = mccsg13_chamfers_lr;
MCNUM chamfers_tb = mccsg13_chamfers_tb;
MCNUM nelements = mccsg13_nelements;
MCNUM nu = mccsg13_nu;
MCNUM phase = mccsg13_phase;
char* reflect = mccsg13_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 54869 "ILL_H15_D11.c"
}   /* End of sg13=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg13:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(50,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg14 [51] */
  mccoordschange(mcposrsg14, mcrotrsg14,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg14 (without coords transformations) */
  mcJumpTrace_sg14:
  SIG_MESSAGE("sg14 (Trace)");
  mcDEBUG_COMP("sg14")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg14
  STORE_NEUTRON(51,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[51]++;
  mcPCounter[51] += p;
  mcP2Counter[51] += p*p;
#define mccompcurname  sg14
#define mccompcurtype  Guide_gravity
#define mccompcurindex 51
#define GVars mccsg14_GVars
#define pTable mccsg14_pTable
{   /* Declarations of sg14=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg14_w1;
MCNUM h1 = mccsg14_h1;
MCNUM w2 = mccsg14_w2;
MCNUM h2 = mccsg14_h2;
MCNUM l = mccsg14_l;
MCNUM R0 = mccsg14_R0;
MCNUM Qc = mccsg14_Qc;
MCNUM alpha = mccsg14_alpha;
MCNUM m = mccsg14_m;
MCNUM W = mccsg14_W;
MCNUM nslit = mccsg14_nslit;
MCNUM d = mccsg14_d;
MCNUM mleft = mccsg14_mleft;
MCNUM mright = mccsg14_mright;
MCNUM mtop = mccsg14_mtop;
MCNUM mbottom = mccsg14_mbottom;
MCNUM nhslit = mccsg14_nhslit;
MCNUM G = mccsg14_G;
MCNUM aleft = mccsg14_aleft;
MCNUM aright = mccsg14_aright;
MCNUM atop = mccsg14_atop;
MCNUM abottom = mccsg14_abottom;
MCNUM wavy = mccsg14_wavy;
MCNUM wavy_z = mccsg14_wavy_z;
MCNUM wavy_tb = mccsg14_wavy_tb;
MCNUM wavy_lr = mccsg14_wavy_lr;
MCNUM chamfers = mccsg14_chamfers;
MCNUM chamfers_z = mccsg14_chamfers_z;
MCNUM chamfers_lr = mccsg14_chamfers_lr;
MCNUM chamfers_tb = mccsg14_chamfers_tb;
MCNUM nelements = mccsg14_nelements;
MCNUM nu = mccsg14_nu;
MCNUM phase = mccsg14_phase;
char* reflect = mccsg14_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 55182 "ILL_H15_D11.c"
}   /* End of sg14=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg14:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(51,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg15 [52] */
  mccoordschange(mcposrsg15, mcrotrsg15,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg15 (without coords transformations) */
  mcJumpTrace_sg15:
  SIG_MESSAGE("sg15 (Trace)");
  mcDEBUG_COMP("sg15")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg15
  STORE_NEUTRON(52,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[52]++;
  mcPCounter[52] += p;
  mcP2Counter[52] += p*p;
#define mccompcurname  sg15
#define mccompcurtype  Guide_gravity
#define mccompcurindex 52
#define GVars mccsg15_GVars
#define pTable mccsg15_pTable
{   /* Declarations of sg15=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg15_w1;
MCNUM h1 = mccsg15_h1;
MCNUM w2 = mccsg15_w2;
MCNUM h2 = mccsg15_h2;
MCNUM l = mccsg15_l;
MCNUM R0 = mccsg15_R0;
MCNUM Qc = mccsg15_Qc;
MCNUM alpha = mccsg15_alpha;
MCNUM m = mccsg15_m;
MCNUM W = mccsg15_W;
MCNUM nslit = mccsg15_nslit;
MCNUM d = mccsg15_d;
MCNUM mleft = mccsg15_mleft;
MCNUM mright = mccsg15_mright;
MCNUM mtop = mccsg15_mtop;
MCNUM mbottom = mccsg15_mbottom;
MCNUM nhslit = mccsg15_nhslit;
MCNUM G = mccsg15_G;
MCNUM aleft = mccsg15_aleft;
MCNUM aright = mccsg15_aright;
MCNUM atop = mccsg15_atop;
MCNUM abottom = mccsg15_abottom;
MCNUM wavy = mccsg15_wavy;
MCNUM wavy_z = mccsg15_wavy_z;
MCNUM wavy_tb = mccsg15_wavy_tb;
MCNUM wavy_lr = mccsg15_wavy_lr;
MCNUM chamfers = mccsg15_chamfers;
MCNUM chamfers_z = mccsg15_chamfers_z;
MCNUM chamfers_lr = mccsg15_chamfers_lr;
MCNUM chamfers_tb = mccsg15_chamfers_tb;
MCNUM nelements = mccsg15_nelements;
MCNUM nu = mccsg15_nu;
MCNUM phase = mccsg15_phase;
char* reflect = mccsg15_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 55495 "ILL_H15_D11.c"
}   /* End of sg15=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg15:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(52,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg16 [53] */
  mccoordschange(mcposrsg16, mcrotrsg16,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg16 (without coords transformations) */
  mcJumpTrace_sg16:
  SIG_MESSAGE("sg16 (Trace)");
  mcDEBUG_COMP("sg16")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg16
  STORE_NEUTRON(53,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[53]++;
  mcPCounter[53] += p;
  mcP2Counter[53] += p*p;
#define mccompcurname  sg16
#define mccompcurtype  Guide_gravity
#define mccompcurindex 53
#define GVars mccsg16_GVars
#define pTable mccsg16_pTable
{   /* Declarations of sg16=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg16_w1;
MCNUM h1 = mccsg16_h1;
MCNUM w2 = mccsg16_w2;
MCNUM h2 = mccsg16_h2;
MCNUM l = mccsg16_l;
MCNUM R0 = mccsg16_R0;
MCNUM Qc = mccsg16_Qc;
MCNUM alpha = mccsg16_alpha;
MCNUM m = mccsg16_m;
MCNUM W = mccsg16_W;
MCNUM nslit = mccsg16_nslit;
MCNUM d = mccsg16_d;
MCNUM mleft = mccsg16_mleft;
MCNUM mright = mccsg16_mright;
MCNUM mtop = mccsg16_mtop;
MCNUM mbottom = mccsg16_mbottom;
MCNUM nhslit = mccsg16_nhslit;
MCNUM G = mccsg16_G;
MCNUM aleft = mccsg16_aleft;
MCNUM aright = mccsg16_aright;
MCNUM atop = mccsg16_atop;
MCNUM abottom = mccsg16_abottom;
MCNUM wavy = mccsg16_wavy;
MCNUM wavy_z = mccsg16_wavy_z;
MCNUM wavy_tb = mccsg16_wavy_tb;
MCNUM wavy_lr = mccsg16_wavy_lr;
MCNUM chamfers = mccsg16_chamfers;
MCNUM chamfers_z = mccsg16_chamfers_z;
MCNUM chamfers_lr = mccsg16_chamfers_lr;
MCNUM chamfers_tb = mccsg16_chamfers_tb;
MCNUM nelements = mccsg16_nelements;
MCNUM nu = mccsg16_nu;
MCNUM phase = mccsg16_phase;
char* reflect = mccsg16_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 55808 "ILL_H15_D11.c"
}   /* End of sg16=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg16:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(53,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg17 [54] */
  mccoordschange(mcposrsg17, mcrotrsg17,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg17 (without coords transformations) */
  mcJumpTrace_sg17:
  SIG_MESSAGE("sg17 (Trace)");
  mcDEBUG_COMP("sg17")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg17
  STORE_NEUTRON(54,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[54]++;
  mcPCounter[54] += p;
  mcP2Counter[54] += p*p;
#define mccompcurname  sg17
#define mccompcurtype  Guide_gravity
#define mccompcurindex 54
#define GVars mccsg17_GVars
#define pTable mccsg17_pTable
{   /* Declarations of sg17=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg17_w1;
MCNUM h1 = mccsg17_h1;
MCNUM w2 = mccsg17_w2;
MCNUM h2 = mccsg17_h2;
MCNUM l = mccsg17_l;
MCNUM R0 = mccsg17_R0;
MCNUM Qc = mccsg17_Qc;
MCNUM alpha = mccsg17_alpha;
MCNUM m = mccsg17_m;
MCNUM W = mccsg17_W;
MCNUM nslit = mccsg17_nslit;
MCNUM d = mccsg17_d;
MCNUM mleft = mccsg17_mleft;
MCNUM mright = mccsg17_mright;
MCNUM mtop = mccsg17_mtop;
MCNUM mbottom = mccsg17_mbottom;
MCNUM nhslit = mccsg17_nhslit;
MCNUM G = mccsg17_G;
MCNUM aleft = mccsg17_aleft;
MCNUM aright = mccsg17_aright;
MCNUM atop = mccsg17_atop;
MCNUM abottom = mccsg17_abottom;
MCNUM wavy = mccsg17_wavy;
MCNUM wavy_z = mccsg17_wavy_z;
MCNUM wavy_tb = mccsg17_wavy_tb;
MCNUM wavy_lr = mccsg17_wavy_lr;
MCNUM chamfers = mccsg17_chamfers;
MCNUM chamfers_z = mccsg17_chamfers_z;
MCNUM chamfers_lr = mccsg17_chamfers_lr;
MCNUM chamfers_tb = mccsg17_chamfers_tb;
MCNUM nelements = mccsg17_nelements;
MCNUM nu = mccsg17_nu;
MCNUM phase = mccsg17_phase;
char* reflect = mccsg17_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 56121 "ILL_H15_D11.c"
}   /* End of sg17=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg17:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(54,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg18 [55] */
  mccoordschange(mcposrsg18, mcrotrsg18,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg18 (without coords transformations) */
  mcJumpTrace_sg18:
  SIG_MESSAGE("sg18 (Trace)");
  mcDEBUG_COMP("sg18")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg18
  STORE_NEUTRON(55,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[55]++;
  mcPCounter[55] += p;
  mcP2Counter[55] += p*p;
#define mccompcurname  sg18
#define mccompcurtype  Guide_gravity
#define mccompcurindex 55
#define GVars mccsg18_GVars
#define pTable mccsg18_pTable
{   /* Declarations of sg18=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg18_w1;
MCNUM h1 = mccsg18_h1;
MCNUM w2 = mccsg18_w2;
MCNUM h2 = mccsg18_h2;
MCNUM l = mccsg18_l;
MCNUM R0 = mccsg18_R0;
MCNUM Qc = mccsg18_Qc;
MCNUM alpha = mccsg18_alpha;
MCNUM m = mccsg18_m;
MCNUM W = mccsg18_W;
MCNUM nslit = mccsg18_nslit;
MCNUM d = mccsg18_d;
MCNUM mleft = mccsg18_mleft;
MCNUM mright = mccsg18_mright;
MCNUM mtop = mccsg18_mtop;
MCNUM mbottom = mccsg18_mbottom;
MCNUM nhslit = mccsg18_nhslit;
MCNUM G = mccsg18_G;
MCNUM aleft = mccsg18_aleft;
MCNUM aright = mccsg18_aright;
MCNUM atop = mccsg18_atop;
MCNUM abottom = mccsg18_abottom;
MCNUM wavy = mccsg18_wavy;
MCNUM wavy_z = mccsg18_wavy_z;
MCNUM wavy_tb = mccsg18_wavy_tb;
MCNUM wavy_lr = mccsg18_wavy_lr;
MCNUM chamfers = mccsg18_chamfers;
MCNUM chamfers_z = mccsg18_chamfers_z;
MCNUM chamfers_lr = mccsg18_chamfers_lr;
MCNUM chamfers_tb = mccsg18_chamfers_tb;
MCNUM nelements = mccsg18_nelements;
MCNUM nu = mccsg18_nu;
MCNUM phase = mccsg18_phase;
char* reflect = mccsg18_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 56434 "ILL_H15_D11.c"
}   /* End of sg18=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg18:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(55,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg19 [56] */
  mccoordschange(mcposrsg19, mcrotrsg19,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg19 (without coords transformations) */
  mcJumpTrace_sg19:
  SIG_MESSAGE("sg19 (Trace)");
  mcDEBUG_COMP("sg19")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg19
  STORE_NEUTRON(56,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[56]++;
  mcPCounter[56] += p;
  mcP2Counter[56] += p*p;
#define mccompcurname  sg19
#define mccompcurtype  Guide_gravity
#define mccompcurindex 56
#define GVars mccsg19_GVars
#define pTable mccsg19_pTable
{   /* Declarations of sg19=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg19_w1;
MCNUM h1 = mccsg19_h1;
MCNUM w2 = mccsg19_w2;
MCNUM h2 = mccsg19_h2;
MCNUM l = mccsg19_l;
MCNUM R0 = mccsg19_R0;
MCNUM Qc = mccsg19_Qc;
MCNUM alpha = mccsg19_alpha;
MCNUM m = mccsg19_m;
MCNUM W = mccsg19_W;
MCNUM nslit = mccsg19_nslit;
MCNUM d = mccsg19_d;
MCNUM mleft = mccsg19_mleft;
MCNUM mright = mccsg19_mright;
MCNUM mtop = mccsg19_mtop;
MCNUM mbottom = mccsg19_mbottom;
MCNUM nhslit = mccsg19_nhslit;
MCNUM G = mccsg19_G;
MCNUM aleft = mccsg19_aleft;
MCNUM aright = mccsg19_aright;
MCNUM atop = mccsg19_atop;
MCNUM abottom = mccsg19_abottom;
MCNUM wavy = mccsg19_wavy;
MCNUM wavy_z = mccsg19_wavy_z;
MCNUM wavy_tb = mccsg19_wavy_tb;
MCNUM wavy_lr = mccsg19_wavy_lr;
MCNUM chamfers = mccsg19_chamfers;
MCNUM chamfers_z = mccsg19_chamfers_z;
MCNUM chamfers_lr = mccsg19_chamfers_lr;
MCNUM chamfers_tb = mccsg19_chamfers_tb;
MCNUM nelements = mccsg19_nelements;
MCNUM nu = mccsg19_nu;
MCNUM phase = mccsg19_phase;
char* reflect = mccsg19_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 56747 "ILL_H15_D11.c"
}   /* End of sg19=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg19:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(56,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg20 [57] */
  mccoordschange(mcposrsg20, mcrotrsg20,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg20 (without coords transformations) */
  mcJumpTrace_sg20:
  SIG_MESSAGE("sg20 (Trace)");
  mcDEBUG_COMP("sg20")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg20
  STORE_NEUTRON(57,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[57]++;
  mcPCounter[57] += p;
  mcP2Counter[57] += p*p;
#define mccompcurname  sg20
#define mccompcurtype  Guide_gravity
#define mccompcurindex 57
#define GVars mccsg20_GVars
#define pTable mccsg20_pTable
{   /* Declarations of sg20=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg20_w1;
MCNUM h1 = mccsg20_h1;
MCNUM w2 = mccsg20_w2;
MCNUM h2 = mccsg20_h2;
MCNUM l = mccsg20_l;
MCNUM R0 = mccsg20_R0;
MCNUM Qc = mccsg20_Qc;
MCNUM alpha = mccsg20_alpha;
MCNUM m = mccsg20_m;
MCNUM W = mccsg20_W;
MCNUM nslit = mccsg20_nslit;
MCNUM d = mccsg20_d;
MCNUM mleft = mccsg20_mleft;
MCNUM mright = mccsg20_mright;
MCNUM mtop = mccsg20_mtop;
MCNUM mbottom = mccsg20_mbottom;
MCNUM nhslit = mccsg20_nhslit;
MCNUM G = mccsg20_G;
MCNUM aleft = mccsg20_aleft;
MCNUM aright = mccsg20_aright;
MCNUM atop = mccsg20_atop;
MCNUM abottom = mccsg20_abottom;
MCNUM wavy = mccsg20_wavy;
MCNUM wavy_z = mccsg20_wavy_z;
MCNUM wavy_tb = mccsg20_wavy_tb;
MCNUM wavy_lr = mccsg20_wavy_lr;
MCNUM chamfers = mccsg20_chamfers;
MCNUM chamfers_z = mccsg20_chamfers_z;
MCNUM chamfers_lr = mccsg20_chamfers_lr;
MCNUM chamfers_tb = mccsg20_chamfers_tb;
MCNUM nelements = mccsg20_nelements;
MCNUM nu = mccsg20_nu;
MCNUM phase = mccsg20_phase;
char* reflect = mccsg20_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 57060 "ILL_H15_D11.c"
}   /* End of sg20=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg20:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(57,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg21 [58] */
  mccoordschange(mcposrsg21, mcrotrsg21,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg21 (without coords transformations) */
  mcJumpTrace_sg21:
  SIG_MESSAGE("sg21 (Trace)");
  mcDEBUG_COMP("sg21")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg21
  STORE_NEUTRON(58,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[58]++;
  mcPCounter[58] += p;
  mcP2Counter[58] += p*p;
#define mccompcurname  sg21
#define mccompcurtype  Guide_gravity
#define mccompcurindex 58
#define GVars mccsg21_GVars
#define pTable mccsg21_pTable
{   /* Declarations of sg21=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg21_w1;
MCNUM h1 = mccsg21_h1;
MCNUM w2 = mccsg21_w2;
MCNUM h2 = mccsg21_h2;
MCNUM l = mccsg21_l;
MCNUM R0 = mccsg21_R0;
MCNUM Qc = mccsg21_Qc;
MCNUM alpha = mccsg21_alpha;
MCNUM m = mccsg21_m;
MCNUM W = mccsg21_W;
MCNUM nslit = mccsg21_nslit;
MCNUM d = mccsg21_d;
MCNUM mleft = mccsg21_mleft;
MCNUM mright = mccsg21_mright;
MCNUM mtop = mccsg21_mtop;
MCNUM mbottom = mccsg21_mbottom;
MCNUM nhslit = mccsg21_nhslit;
MCNUM G = mccsg21_G;
MCNUM aleft = mccsg21_aleft;
MCNUM aright = mccsg21_aright;
MCNUM atop = mccsg21_atop;
MCNUM abottom = mccsg21_abottom;
MCNUM wavy = mccsg21_wavy;
MCNUM wavy_z = mccsg21_wavy_z;
MCNUM wavy_tb = mccsg21_wavy_tb;
MCNUM wavy_lr = mccsg21_wavy_lr;
MCNUM chamfers = mccsg21_chamfers;
MCNUM chamfers_z = mccsg21_chamfers_z;
MCNUM chamfers_lr = mccsg21_chamfers_lr;
MCNUM chamfers_tb = mccsg21_chamfers_tb;
MCNUM nelements = mccsg21_nelements;
MCNUM nu = mccsg21_nu;
MCNUM phase = mccsg21_phase;
char* reflect = mccsg21_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 57373 "ILL_H15_D11.c"
}   /* End of sg21=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg21:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(58,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg22 [59] */
  mccoordschange(mcposrsg22, mcrotrsg22,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg22 (without coords transformations) */
  mcJumpTrace_sg22:
  SIG_MESSAGE("sg22 (Trace)");
  mcDEBUG_COMP("sg22")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg22
  STORE_NEUTRON(59,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[59]++;
  mcPCounter[59] += p;
  mcP2Counter[59] += p*p;
#define mccompcurname  sg22
#define mccompcurtype  Guide_gravity
#define mccompcurindex 59
#define GVars mccsg22_GVars
#define pTable mccsg22_pTable
{   /* Declarations of sg22=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg22_w1;
MCNUM h1 = mccsg22_h1;
MCNUM w2 = mccsg22_w2;
MCNUM h2 = mccsg22_h2;
MCNUM l = mccsg22_l;
MCNUM R0 = mccsg22_R0;
MCNUM Qc = mccsg22_Qc;
MCNUM alpha = mccsg22_alpha;
MCNUM m = mccsg22_m;
MCNUM W = mccsg22_W;
MCNUM nslit = mccsg22_nslit;
MCNUM d = mccsg22_d;
MCNUM mleft = mccsg22_mleft;
MCNUM mright = mccsg22_mright;
MCNUM mtop = mccsg22_mtop;
MCNUM mbottom = mccsg22_mbottom;
MCNUM nhslit = mccsg22_nhslit;
MCNUM G = mccsg22_G;
MCNUM aleft = mccsg22_aleft;
MCNUM aright = mccsg22_aright;
MCNUM atop = mccsg22_atop;
MCNUM abottom = mccsg22_abottom;
MCNUM wavy = mccsg22_wavy;
MCNUM wavy_z = mccsg22_wavy_z;
MCNUM wavy_tb = mccsg22_wavy_tb;
MCNUM wavy_lr = mccsg22_wavy_lr;
MCNUM chamfers = mccsg22_chamfers;
MCNUM chamfers_z = mccsg22_chamfers_z;
MCNUM chamfers_lr = mccsg22_chamfers_lr;
MCNUM chamfers_tb = mccsg22_chamfers_tb;
MCNUM nelements = mccsg22_nelements;
MCNUM nu = mccsg22_nu;
MCNUM phase = mccsg22_phase;
char* reflect = mccsg22_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 57686 "ILL_H15_D11.c"
}   /* End of sg22=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg22:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(59,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component AlWindow6 [60] */
  mccoordschange(mcposrAlWindow6, mcrotrAlWindow6,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component AlWindow6 (without coords transformations) */
  mcJumpTrace_AlWindow6:
  SIG_MESSAGE("AlWindow6 (Trace)");
  mcDEBUG_COMP("AlWindow6")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAlWindow6
  STORE_NEUTRON(60,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[60]++;
  mcPCounter[60] += p;
  mcP2Counter[60] += p*p;
#define mccompcurname  AlWindow6
#define mccompcurtype  Al_window
#define mccompcurindex 60
{   /* Declarations of AlWindow6=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow6_thickness;
#line 68 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  double v;                     /* Neutron velocity */
  double dt0;     /* Flight times through sample */
  double dist;
  double Al_s_tot_lambda,Al_my_tot,Al_my_a ; /* total XS (barn), total scattering length (m-1), absorption scat. length */
  double lambda; /* neutrons wavelength */

  PROP_Z0;

  dt0=thickness/vz;
  v=sqrt(vx*vx+vy*vy+vz*vz);
  PROP_DT(dt0);
  dist=v*dt0;

  lambda=sqrt(81.81/(VS2E*v*v));
  Al_s_tot_lambda= Al_pf_A+Al_pf_B1*lambda+ Al_pf_B2*lambda*lambda+ Al_pf_B3*lambda*lambda*lambda;
  Al_s_tot_lambda+=Al_pf_B4*lambda*lambda*lambda*lambda;
  Al_my_tot=Al_rho / Al_mmol * Al_s_tot_lambda * avogadro * 10;
  Al_my_a = Al_my_a_v/v;

  p *=exp(-Al_my_a*dist);/* neutron passes window without any interaction */

  /* TODO: scatter in Debye-Scherrer cone */

}
#line 57821 "ILL_H15_D11.c"
}   /* End of AlWindow6=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAlWindow6:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(60,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component PSD_IN6 [61] */
  mccoordschange(mcposrPSD_IN6, mcrotrPSD_IN6,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component PSD_IN6 (without coords transformations) */
  mcJumpTrace_PSD_IN6:
  SIG_MESSAGE("PSD_IN6 (Trace)");
  mcDEBUG_COMP("PSD_IN6")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPSD_IN6
  STORE_NEUTRON(61,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[61]++;
  mcPCounter[61] += p;
  mcP2Counter[61] += p*p;
#define mccompcurname  PSD_IN6
#define mccompcurtype  Monitor_nD
#define mccompcurindex 61
#define user1 mccPSD_IN6_user1
#define user2 mccPSD_IN6_user2
#define user3 mccPSD_IN6_user3
#define DEFS mccPSD_IN6_DEFS
#define Vars mccPSD_IN6_Vars
#define detector mccPSD_IN6_detector
#define offdata mccPSD_IN6_offdata
{   /* Declarations of PSD_IN6=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccPSD_IN6_xwidth;
MCNUM yheight = mccPSD_IN6_yheight;
MCNUM zdepth = mccPSD_IN6_zdepth;
MCNUM xmin = mccPSD_IN6_xmin;
MCNUM xmax = mccPSD_IN6_xmax;
MCNUM ymin = mccPSD_IN6_ymin;
MCNUM ymax = mccPSD_IN6_ymax;
MCNUM zmin = mccPSD_IN6_zmin;
MCNUM zmax = mccPSD_IN6_zmax;
MCNUM bins = mccPSD_IN6_bins;
MCNUM min = mccPSD_IN6_min;
MCNUM max = mccPSD_IN6_max;
MCNUM restore_neutron = mccPSD_IN6_restore_neutron;
MCNUM radius = mccPSD_IN6_radius;
char* options = mccPSD_IN6_options;
char* filename = mccPSD_IN6_filename;
char* geometry = mccPSD_IN6_geometry;
char* username1 = mccPSD_IN6_username1;
char* username2 = mccPSD_IN6_username2;
char* username3 = mccPSD_IN6_username3;
int nowritefile = mccPSD_IN6_nowritefile;
#line 312 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  double  XY=0;
  double  t0 = 0;
  double  t1 = 0;
  double  pp;
  int     intersect   = 0;
  char    Flag_Restore = 0;

  if (user1 != FLT_MAX) Vars.UserVariable1 = user1;
  if (user2 != FLT_MAX) Vars.UserVariable2 = user2;
  if (user3 != FLT_MAX) Vars.UserVariable3 = user3;

  /* this is done automatically
    STORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  */

  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    /* determine intersections with object */
    intersect = off_intersect_all(&t0, &t1, NULL, NULL,
       x,y,z, vx, vy, vz, &offdata );
    if (Vars.Flag_mantid) {
      if(intersect) {
        Vars.OFF_polyidx=(offdata.intersects[offdata.nextintersect]).index;
      } else {
        Vars.OFF_polyidx=-1;
      }
    }
  }
  else if ( (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
            || (abs(Vars.Flag_Shape) == DEFS.SHAPE_DISK) ) /* square xy or disk xy */
  {
    // propagate to xy plane and find intersection
    // make sure the event is recoverable afterwards
    t0 = t;
    ALLOW_BACKPROP;
    PROP_Z0;
    if ( (t>=t0) && (z==0.0) ) // forward propagation to xy plane was successful
    {
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
      {
        // square xy
        intersect = (x>=Vars.mxmin && x<=Vars.mxmax && y>=Vars.mymin && y<=Vars.mymax);
      }
      else
      {
        // disk xy
        intersect = (SQR(x) + SQR(y)) <= SQR(Vars.Sphere_Radius);
      }
    }
    else
    {
      intersect=0;
    }
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) /* sphere */
  {
    intersect = sphere_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius);
  /*      intersect = (intersect && t0 > 0); */
  }
  else if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)) /* cylinder */
  {
    intersect = cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius, Vars.Cylinder_Height);
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) /* box */
  {
    intersect = box_intersect(&t0, &t1, x, y, z, vx, vy, vz,
                              fabs(Vars.mxmax-Vars.mxmin), fabs(Vars.mymax-Vars.mymin), fabs(Vars.mzmax-Vars.mzmin));
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_PREVIOUS) /* previous comp */
  { intersect = 1; }

  if (intersect)
  {
    if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND)
     || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)
     || (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) )
    {
      /* check if we have to remove the top/bottom with BANANA shape */
      if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA) && (intersect != 1)) {
        double y0,y1;
        /* propagate to intersection point as temporary variable to check top/bottom */
        y0 = y+t0*vy;
        y1 = y+t1*vy;
        if (fabs(y0) >= Vars.Cylinder_Height/2*0.99) t0 = t1;
        if (fabs(y1) >= Vars.Cylinder_Height/2*0.99) t1 = t0;
      }
      if (t0 < 0 && t1 > 0)
        t0 = t;  /* neutron was already inside ! */
      if (t1 < 0 && t0 > 0) /* neutron exit before entering !! */
        t1 = t;
      /* t0 is now time of incoming intersection with the detection area */
      if ((Vars.Flag_Shape < 0) && (t1 > 0))
        PROP_DT(t1); /* t1 outgoing beam */
      else
        PROP_DT(t0); /* t0 incoming beam */
      /* Final test if we are on lid / bottom of banana/sphere */
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA || abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) {
        if (fabs(y) >= Vars.Cylinder_Height/2*0.99) {
          intersect=0;
          Flag_Restore=1;
        }
      }
    }
  }

  if (intersect)
  {
    /* Now get the data to monitor: current or keep from PreMonitor */
    if (Vars.Flag_UsePreMonitor != 1)
    {
      Vars.cp  = p;
      Vars.cx  = x;
      Vars.cvx = vx;
      Vars.csx = sx;
      Vars.cy  = y;
      Vars.cvy = vy;
      Vars.csy = sy;
      Vars.cz  = z;
      Vars.cvz = vz;
      Vars.csz = sz;
      Vars.ct  = t;
    }

    if ((Vars.He3_pressure > 0) && (t1 != t0) && ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX)))
    {
      XY = exp(-7.417*Vars.He3_pressure*fabs(t1-t0)*2*PI*K2V);
      /* will monitor the absorbed part */
      Vars.cp *= 1-XY;
      /* and modify the neutron weight after monitor, only remains 1-p_detect */
      p *= XY;
    }

    if (Vars.Flag_capture)
    {
      XY = sqrt(Vars.cvx*Vars.cvx+Vars.cvy*Vars.cvy+Vars.cvz*Vars.cvz);
      XY *= V2K;
      if (XY != 0) XY = 2*PI/XY; /* lambda. lambda(2200 m/2) = 1.7985 Angs  */
      Vars.cp *= XY/1.7985;
    }

    pp = Monitor_nD_Trace(&DEFS, &Vars);
    if (pp==0.0)
    { ABSORB;
    }
    else if(pp==1)
    {
      SCATTER;
    }

    if (Vars.Flag_parallel) /* back to neutron state before detection */
      Flag_Restore = 1;
  } /* end if intersection */
  else {
    if (Vars.Flag_Absorb && !Vars.Flag_parallel)
    {
      // restore neutron ray before absorbing for correct mcdisplay
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
      ABSORB;
    }
    else Flag_Restore = 1;  /* no intersection, back to previous state */
  }

  if (Flag_Restore)
  {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 58124 "ILL_H15_D11.c"
}   /* End of PSD_IN6=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPSD_IN6:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(61,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component AlWindow7 [62] */
  mccoordschange(mcposrAlWindow7, mcrotrAlWindow7,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component AlWindow7 (without coords transformations) */
  mcJumpTrace_AlWindow7:
  SIG_MESSAGE("AlWindow7 (Trace)");
  mcDEBUG_COMP("AlWindow7")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAlWindow7
  STORE_NEUTRON(62,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[62]++;
  mcPCounter[62] += p;
  mcP2Counter[62] += p*p;
#define mccompcurname  AlWindow7
#define mccompcurtype  Al_window
#define mccompcurindex 62
{   /* Declarations of AlWindow7=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow7_thickness;
#line 68 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  double v;                     /* Neutron velocity */
  double dt0;     /* Flight times through sample */
  double dist;
  double Al_s_tot_lambda,Al_my_tot,Al_my_a ; /* total XS (barn), total scattering length (m-1), absorption scat. length */
  double lambda; /* neutrons wavelength */

  PROP_Z0;

  dt0=thickness/vz;
  v=sqrt(vx*vx+vy*vy+vz*vz);
  PROP_DT(dt0);
  dist=v*dt0;

  lambda=sqrt(81.81/(VS2E*v*v));
  Al_s_tot_lambda= Al_pf_A+Al_pf_B1*lambda+ Al_pf_B2*lambda*lambda+ Al_pf_B3*lambda*lambda*lambda;
  Al_s_tot_lambda+=Al_pf_B4*lambda*lambda*lambda*lambda;
  Al_my_tot=Al_rho / Al_mmol * Al_s_tot_lambda * avogadro * 10;
  Al_my_a = Al_my_a_v/v;

  p *=exp(-Al_my_a*dist);/* neutron passes window without any interaction */

  /* TODO: scatter in Debye-Scherrer cone */

}
#line 58264 "ILL_H15_D11.c"
}   /* End of AlWindow7=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAlWindow7:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(62,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component IN6toD7GuideStart [63] */
  mccoordschange(mcposrIN6toD7GuideStart, mcrotrIN6toD7GuideStart,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component IN6toD7GuideStart (without coords transformations) */
  mcJumpTrace_IN6toD7GuideStart:
  SIG_MESSAGE("IN6toD7GuideStart (Trace)");
  mcDEBUG_COMP("IN6toD7GuideStart")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompIN6toD7GuideStart
  STORE_NEUTRON(63,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[63]++;
  mcPCounter[63] += p;
  mcP2Counter[63] += p*p;
#define mccompcurname  IN6toD7GuideStart
#define mccompcurtype  Arm
#define mccompcurindex 63
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompIN6toD7GuideStart:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(63,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg23 [64] */
  mccoordschange(mcposrsg23, mcrotrsg23,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg23 (without coords transformations) */
  mcJumpTrace_sg23:
  SIG_MESSAGE("sg23 (Trace)");
  mcDEBUG_COMP("sg23")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg23
  STORE_NEUTRON(64,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[64]++;
  mcPCounter[64] += p;
  mcP2Counter[64] += p*p;
#define mccompcurname  sg23
#define mccompcurtype  Guide_gravity
#define mccompcurindex 64
#define GVars mccsg23_GVars
#define pTable mccsg23_pTable
{   /* Declarations of sg23=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg23_w1;
MCNUM h1 = mccsg23_h1;
MCNUM w2 = mccsg23_w2;
MCNUM h2 = mccsg23_h2;
MCNUM l = mccsg23_l;
MCNUM R0 = mccsg23_R0;
MCNUM Qc = mccsg23_Qc;
MCNUM alpha = mccsg23_alpha;
MCNUM m = mccsg23_m;
MCNUM W = mccsg23_W;
MCNUM nslit = mccsg23_nslit;
MCNUM d = mccsg23_d;
MCNUM mleft = mccsg23_mleft;
MCNUM mright = mccsg23_mright;
MCNUM mtop = mccsg23_mtop;
MCNUM mbottom = mccsg23_mbottom;
MCNUM nhslit = mccsg23_nhslit;
MCNUM G = mccsg23_G;
MCNUM aleft = mccsg23_aleft;
MCNUM aright = mccsg23_aright;
MCNUM atop = mccsg23_atop;
MCNUM abottom = mccsg23_abottom;
MCNUM wavy = mccsg23_wavy;
MCNUM wavy_z = mccsg23_wavy_z;
MCNUM wavy_tb = mccsg23_wavy_tb;
MCNUM wavy_lr = mccsg23_wavy_lr;
MCNUM chamfers = mccsg23_chamfers;
MCNUM chamfers_z = mccsg23_chamfers_z;
MCNUM chamfers_lr = mccsg23_chamfers_lr;
MCNUM chamfers_tb = mccsg23_chamfers_tb;
MCNUM nelements = mccsg23_nelements;
MCNUM nu = mccsg23_nu;
MCNUM phase = mccsg23_phase;
char* reflect = mccsg23_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 58678 "ILL_H15_D11.c"
}   /* End of sg23=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg23:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(64,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg24 [65] */
  mccoordschange(mcposrsg24, mcrotrsg24,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg24 (without coords transformations) */
  mcJumpTrace_sg24:
  SIG_MESSAGE("sg24 (Trace)");
  mcDEBUG_COMP("sg24")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg24
  STORE_NEUTRON(65,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[65]++;
  mcPCounter[65] += p;
  mcP2Counter[65] += p*p;
#define mccompcurname  sg24
#define mccompcurtype  Guide_gravity
#define mccompcurindex 65
#define GVars mccsg24_GVars
#define pTable mccsg24_pTable
{   /* Declarations of sg24=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg24_w1;
MCNUM h1 = mccsg24_h1;
MCNUM w2 = mccsg24_w2;
MCNUM h2 = mccsg24_h2;
MCNUM l = mccsg24_l;
MCNUM R0 = mccsg24_R0;
MCNUM Qc = mccsg24_Qc;
MCNUM alpha = mccsg24_alpha;
MCNUM m = mccsg24_m;
MCNUM W = mccsg24_W;
MCNUM nslit = mccsg24_nslit;
MCNUM d = mccsg24_d;
MCNUM mleft = mccsg24_mleft;
MCNUM mright = mccsg24_mright;
MCNUM mtop = mccsg24_mtop;
MCNUM mbottom = mccsg24_mbottom;
MCNUM nhslit = mccsg24_nhslit;
MCNUM G = mccsg24_G;
MCNUM aleft = mccsg24_aleft;
MCNUM aright = mccsg24_aright;
MCNUM atop = mccsg24_atop;
MCNUM abottom = mccsg24_abottom;
MCNUM wavy = mccsg24_wavy;
MCNUM wavy_z = mccsg24_wavy_z;
MCNUM wavy_tb = mccsg24_wavy_tb;
MCNUM wavy_lr = mccsg24_wavy_lr;
MCNUM chamfers = mccsg24_chamfers;
MCNUM chamfers_z = mccsg24_chamfers_z;
MCNUM chamfers_lr = mccsg24_chamfers_lr;
MCNUM chamfers_tb = mccsg24_chamfers_tb;
MCNUM nelements = mccsg24_nelements;
MCNUM nu = mccsg24_nu;
MCNUM phase = mccsg24_phase;
char* reflect = mccsg24_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 58991 "ILL_H15_D11.c"
}   /* End of sg24=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg24:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(65,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg25 [66] */
  mccoordschange(mcposrsg25, mcrotrsg25,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg25 (without coords transformations) */
  mcJumpTrace_sg25:
  SIG_MESSAGE("sg25 (Trace)");
  mcDEBUG_COMP("sg25")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg25
  STORE_NEUTRON(66,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[66]++;
  mcPCounter[66] += p;
  mcP2Counter[66] += p*p;
#define mccompcurname  sg25
#define mccompcurtype  Guide_gravity
#define mccompcurindex 66
#define GVars mccsg25_GVars
#define pTable mccsg25_pTable
{   /* Declarations of sg25=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg25_w1;
MCNUM h1 = mccsg25_h1;
MCNUM w2 = mccsg25_w2;
MCNUM h2 = mccsg25_h2;
MCNUM l = mccsg25_l;
MCNUM R0 = mccsg25_R0;
MCNUM Qc = mccsg25_Qc;
MCNUM alpha = mccsg25_alpha;
MCNUM m = mccsg25_m;
MCNUM W = mccsg25_W;
MCNUM nslit = mccsg25_nslit;
MCNUM d = mccsg25_d;
MCNUM mleft = mccsg25_mleft;
MCNUM mright = mccsg25_mright;
MCNUM mtop = mccsg25_mtop;
MCNUM mbottom = mccsg25_mbottom;
MCNUM nhslit = mccsg25_nhslit;
MCNUM G = mccsg25_G;
MCNUM aleft = mccsg25_aleft;
MCNUM aright = mccsg25_aright;
MCNUM atop = mccsg25_atop;
MCNUM abottom = mccsg25_abottom;
MCNUM wavy = mccsg25_wavy;
MCNUM wavy_z = mccsg25_wavy_z;
MCNUM wavy_tb = mccsg25_wavy_tb;
MCNUM wavy_lr = mccsg25_wavy_lr;
MCNUM chamfers = mccsg25_chamfers;
MCNUM chamfers_z = mccsg25_chamfers_z;
MCNUM chamfers_lr = mccsg25_chamfers_lr;
MCNUM chamfers_tb = mccsg25_chamfers_tb;
MCNUM nelements = mccsg25_nelements;
MCNUM nu = mccsg25_nu;
MCNUM phase = mccsg25_phase;
char* reflect = mccsg25_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 59304 "ILL_H15_D11.c"
}   /* End of sg25=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg25:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(66,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg26 [67] */
  mccoordschange(mcposrsg26, mcrotrsg26,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg26 (without coords transformations) */
  mcJumpTrace_sg26:
  SIG_MESSAGE("sg26 (Trace)");
  mcDEBUG_COMP("sg26")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg26
  STORE_NEUTRON(67,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[67]++;
  mcPCounter[67] += p;
  mcP2Counter[67] += p*p;
#define mccompcurname  sg26
#define mccompcurtype  Guide_gravity
#define mccompcurindex 67
#define GVars mccsg26_GVars
#define pTable mccsg26_pTable
{   /* Declarations of sg26=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg26_w1;
MCNUM h1 = mccsg26_h1;
MCNUM w2 = mccsg26_w2;
MCNUM h2 = mccsg26_h2;
MCNUM l = mccsg26_l;
MCNUM R0 = mccsg26_R0;
MCNUM Qc = mccsg26_Qc;
MCNUM alpha = mccsg26_alpha;
MCNUM m = mccsg26_m;
MCNUM W = mccsg26_W;
MCNUM nslit = mccsg26_nslit;
MCNUM d = mccsg26_d;
MCNUM mleft = mccsg26_mleft;
MCNUM mright = mccsg26_mright;
MCNUM mtop = mccsg26_mtop;
MCNUM mbottom = mccsg26_mbottom;
MCNUM nhslit = mccsg26_nhslit;
MCNUM G = mccsg26_G;
MCNUM aleft = mccsg26_aleft;
MCNUM aright = mccsg26_aright;
MCNUM atop = mccsg26_atop;
MCNUM abottom = mccsg26_abottom;
MCNUM wavy = mccsg26_wavy;
MCNUM wavy_z = mccsg26_wavy_z;
MCNUM wavy_tb = mccsg26_wavy_tb;
MCNUM wavy_lr = mccsg26_wavy_lr;
MCNUM chamfers = mccsg26_chamfers;
MCNUM chamfers_z = mccsg26_chamfers_z;
MCNUM chamfers_lr = mccsg26_chamfers_lr;
MCNUM chamfers_tb = mccsg26_chamfers_tb;
MCNUM nelements = mccsg26_nelements;
MCNUM nu = mccsg26_nu;
MCNUM phase = mccsg26_phase;
char* reflect = mccsg26_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 59617 "ILL_H15_D11.c"
}   /* End of sg26=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg26:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(67,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg27 [68] */
  mccoordschange(mcposrsg27, mcrotrsg27,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg27 (without coords transformations) */
  mcJumpTrace_sg27:
  SIG_MESSAGE("sg27 (Trace)");
  mcDEBUG_COMP("sg27")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg27
  STORE_NEUTRON(68,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[68]++;
  mcPCounter[68] += p;
  mcP2Counter[68] += p*p;
#define mccompcurname  sg27
#define mccompcurtype  Guide_gravity
#define mccompcurindex 68
#define GVars mccsg27_GVars
#define pTable mccsg27_pTable
{   /* Declarations of sg27=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg27_w1;
MCNUM h1 = mccsg27_h1;
MCNUM w2 = mccsg27_w2;
MCNUM h2 = mccsg27_h2;
MCNUM l = mccsg27_l;
MCNUM R0 = mccsg27_R0;
MCNUM Qc = mccsg27_Qc;
MCNUM alpha = mccsg27_alpha;
MCNUM m = mccsg27_m;
MCNUM W = mccsg27_W;
MCNUM nslit = mccsg27_nslit;
MCNUM d = mccsg27_d;
MCNUM mleft = mccsg27_mleft;
MCNUM mright = mccsg27_mright;
MCNUM mtop = mccsg27_mtop;
MCNUM mbottom = mccsg27_mbottom;
MCNUM nhslit = mccsg27_nhslit;
MCNUM G = mccsg27_G;
MCNUM aleft = mccsg27_aleft;
MCNUM aright = mccsg27_aright;
MCNUM atop = mccsg27_atop;
MCNUM abottom = mccsg27_abottom;
MCNUM wavy = mccsg27_wavy;
MCNUM wavy_z = mccsg27_wavy_z;
MCNUM wavy_tb = mccsg27_wavy_tb;
MCNUM wavy_lr = mccsg27_wavy_lr;
MCNUM chamfers = mccsg27_chamfers;
MCNUM chamfers_z = mccsg27_chamfers_z;
MCNUM chamfers_lr = mccsg27_chamfers_lr;
MCNUM chamfers_tb = mccsg27_chamfers_tb;
MCNUM nelements = mccsg27_nelements;
MCNUM nu = mccsg27_nu;
MCNUM phase = mccsg27_phase;
char* reflect = mccsg27_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 59930 "ILL_H15_D11.c"
}   /* End of sg27=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg27:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(68,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component AlWindow8 [69] */
  mccoordschange(mcposrAlWindow8, mcrotrAlWindow8,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component AlWindow8 (without coords transformations) */
  mcJumpTrace_AlWindow8:
  SIG_MESSAGE("AlWindow8 (Trace)");
  mcDEBUG_COMP("AlWindow8")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAlWindow8
  STORE_NEUTRON(69,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[69]++;
  mcPCounter[69] += p;
  mcP2Counter[69] += p*p;
#define mccompcurname  AlWindow8
#define mccompcurtype  Al_window
#define mccompcurindex 69
{   /* Declarations of AlWindow8=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow8_thickness;
#line 68 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  double v;                     /* Neutron velocity */
  double dt0;     /* Flight times through sample */
  double dist;
  double Al_s_tot_lambda,Al_my_tot,Al_my_a ; /* total XS (barn), total scattering length (m-1), absorption scat. length */
  double lambda; /* neutrons wavelength */

  PROP_Z0;

  dt0=thickness/vz;
  v=sqrt(vx*vx+vy*vy+vz*vz);
  PROP_DT(dt0);
  dist=v*dt0;

  lambda=sqrt(81.81/(VS2E*v*v));
  Al_s_tot_lambda= Al_pf_A+Al_pf_B1*lambda+ Al_pf_B2*lambda*lambda+ Al_pf_B3*lambda*lambda*lambda;
  Al_s_tot_lambda+=Al_pf_B4*lambda*lambda*lambda*lambda;
  Al_my_tot=Al_rho / Al_mmol * Al_s_tot_lambda * avogadro * 10;
  Al_my_a = Al_my_a_v/v;

  p *=exp(-Al_my_a*dist);/* neutron passes window without any interaction */

  /* TODO: scatter in Debye-Scherrer cone */

}
#line 60065 "ILL_H15_D11.c"
}   /* End of AlWindow8=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAlWindow8:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(69,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component PSD_D7 [70] */
  mccoordschange(mcposrPSD_D7, mcrotrPSD_D7,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component PSD_D7 (without coords transformations) */
  mcJumpTrace_PSD_D7:
  SIG_MESSAGE("PSD_D7 (Trace)");
  mcDEBUG_COMP("PSD_D7")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompPSD_D7
  STORE_NEUTRON(70,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[70]++;
  mcPCounter[70] += p;
  mcP2Counter[70] += p*p;
#define mccompcurname  PSD_D7
#define mccompcurtype  Monitor_nD
#define mccompcurindex 70
#define user1 mccPSD_D7_user1
#define user2 mccPSD_D7_user2
#define user3 mccPSD_D7_user3
#define DEFS mccPSD_D7_DEFS
#define Vars mccPSD_D7_Vars
#define detector mccPSD_D7_detector
#define offdata mccPSD_D7_offdata
{   /* Declarations of PSD_D7=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccPSD_D7_xwidth;
MCNUM yheight = mccPSD_D7_yheight;
MCNUM zdepth = mccPSD_D7_zdepth;
MCNUM xmin = mccPSD_D7_xmin;
MCNUM xmax = mccPSD_D7_xmax;
MCNUM ymin = mccPSD_D7_ymin;
MCNUM ymax = mccPSD_D7_ymax;
MCNUM zmin = mccPSD_D7_zmin;
MCNUM zmax = mccPSD_D7_zmax;
MCNUM bins = mccPSD_D7_bins;
MCNUM min = mccPSD_D7_min;
MCNUM max = mccPSD_D7_max;
MCNUM restore_neutron = mccPSD_D7_restore_neutron;
MCNUM radius = mccPSD_D7_radius;
char* options = mccPSD_D7_options;
char* filename = mccPSD_D7_filename;
char* geometry = mccPSD_D7_geometry;
char* username1 = mccPSD_D7_username1;
char* username2 = mccPSD_D7_username2;
char* username3 = mccPSD_D7_username3;
int nowritefile = mccPSD_D7_nowritefile;
#line 312 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  double  XY=0;
  double  t0 = 0;
  double  t1 = 0;
  double  pp;
  int     intersect   = 0;
  char    Flag_Restore = 0;

  if (user1 != FLT_MAX) Vars.UserVariable1 = user1;
  if (user2 != FLT_MAX) Vars.UserVariable2 = user2;
  if (user3 != FLT_MAX) Vars.UserVariable3 = user3;

  /* this is done automatically
    STORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  */

  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    /* determine intersections with object */
    intersect = off_intersect_all(&t0, &t1, NULL, NULL,
       x,y,z, vx, vy, vz, &offdata );
    if (Vars.Flag_mantid) {
      if(intersect) {
        Vars.OFF_polyidx=(offdata.intersects[offdata.nextintersect]).index;
      } else {
        Vars.OFF_polyidx=-1;
      }
    }
  }
  else if ( (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
            || (abs(Vars.Flag_Shape) == DEFS.SHAPE_DISK) ) /* square xy or disk xy */
  {
    // propagate to xy plane and find intersection
    // make sure the event is recoverable afterwards
    t0 = t;
    ALLOW_BACKPROP;
    PROP_Z0;
    if ( (t>=t0) && (z==0.0) ) // forward propagation to xy plane was successful
    {
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
      {
        // square xy
        intersect = (x>=Vars.mxmin && x<=Vars.mxmax && y>=Vars.mymin && y<=Vars.mymax);
      }
      else
      {
        // disk xy
        intersect = (SQR(x) + SQR(y)) <= SQR(Vars.Sphere_Radius);
      }
    }
    else
    {
      intersect=0;
    }
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) /* sphere */
  {
    intersect = sphere_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius);
  /*      intersect = (intersect && t0 > 0); */
  }
  else if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)) /* cylinder */
  {
    intersect = cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius, Vars.Cylinder_Height);
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) /* box */
  {
    intersect = box_intersect(&t0, &t1, x, y, z, vx, vy, vz,
                              fabs(Vars.mxmax-Vars.mxmin), fabs(Vars.mymax-Vars.mymin), fabs(Vars.mzmax-Vars.mzmin));
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_PREVIOUS) /* previous comp */
  { intersect = 1; }

  if (intersect)
  {
    if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND)
     || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)
     || (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) )
    {
      /* check if we have to remove the top/bottom with BANANA shape */
      if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA) && (intersect != 1)) {
        double y0,y1;
        /* propagate to intersection point as temporary variable to check top/bottom */
        y0 = y+t0*vy;
        y1 = y+t1*vy;
        if (fabs(y0) >= Vars.Cylinder_Height/2*0.99) t0 = t1;
        if (fabs(y1) >= Vars.Cylinder_Height/2*0.99) t1 = t0;
      }
      if (t0 < 0 && t1 > 0)
        t0 = t;  /* neutron was already inside ! */
      if (t1 < 0 && t0 > 0) /* neutron exit before entering !! */
        t1 = t;
      /* t0 is now time of incoming intersection with the detection area */
      if ((Vars.Flag_Shape < 0) && (t1 > 0))
        PROP_DT(t1); /* t1 outgoing beam */
      else
        PROP_DT(t0); /* t0 incoming beam */
      /* Final test if we are on lid / bottom of banana/sphere */
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA || abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) {
        if (fabs(y) >= Vars.Cylinder_Height/2*0.99) {
          intersect=0;
          Flag_Restore=1;
        }
      }
    }
  }

  if (intersect)
  {
    /* Now get the data to monitor: current or keep from PreMonitor */
    if (Vars.Flag_UsePreMonitor != 1)
    {
      Vars.cp  = p;
      Vars.cx  = x;
      Vars.cvx = vx;
      Vars.csx = sx;
      Vars.cy  = y;
      Vars.cvy = vy;
      Vars.csy = sy;
      Vars.cz  = z;
      Vars.cvz = vz;
      Vars.csz = sz;
      Vars.ct  = t;
    }

    if ((Vars.He3_pressure > 0) && (t1 != t0) && ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX)))
    {
      XY = exp(-7.417*Vars.He3_pressure*fabs(t1-t0)*2*PI*K2V);
      /* will monitor the absorbed part */
      Vars.cp *= 1-XY;
      /* and modify the neutron weight after monitor, only remains 1-p_detect */
      p *= XY;
    }

    if (Vars.Flag_capture)
    {
      XY = sqrt(Vars.cvx*Vars.cvx+Vars.cvy*Vars.cvy+Vars.cvz*Vars.cvz);
      XY *= V2K;
      if (XY != 0) XY = 2*PI/XY; /* lambda. lambda(2200 m/2) = 1.7985 Angs  */
      Vars.cp *= XY/1.7985;
    }

    pp = Monitor_nD_Trace(&DEFS, &Vars);
    if (pp==0.0)
    { ABSORB;
    }
    else if(pp==1)
    {
      SCATTER;
    }

    if (Vars.Flag_parallel) /* back to neutron state before detection */
      Flag_Restore = 1;
  } /* end if intersection */
  else {
    if (Vars.Flag_Absorb && !Vars.Flag_parallel)
    {
      // restore neutron ray before absorbing for correct mcdisplay
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
      ABSORB;
    }
    else Flag_Restore = 1;  /* no intersection, back to previous state */
  }

  if (Flag_Restore)
  {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 60368 "ILL_H15_D11.c"
}   /* End of PSD_D7=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompPSD_D7:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(70,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component AlWindow9 [71] */
  mccoordschange(mcposrAlWindow9, mcrotrAlWindow9,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component AlWindow9 (without coords transformations) */
  mcJumpTrace_AlWindow9:
  SIG_MESSAGE("AlWindow9 (Trace)");
  mcDEBUG_COMP("AlWindow9")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAlWindow9
  STORE_NEUTRON(71,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[71]++;
  mcPCounter[71] += p;
  mcP2Counter[71] += p*p;
#define mccompcurname  AlWindow9
#define mccompcurtype  Al_window
#define mccompcurindex 71
{   /* Declarations of AlWindow9=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow9_thickness;
#line 68 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  double v;                     /* Neutron velocity */
  double dt0;     /* Flight times through sample */
  double dist;
  double Al_s_tot_lambda,Al_my_tot,Al_my_a ; /* total XS (barn), total scattering length (m-1), absorption scat. length */
  double lambda; /* neutrons wavelength */

  PROP_Z0;

  dt0=thickness/vz;
  v=sqrt(vx*vx+vy*vy+vz*vz);
  PROP_DT(dt0);
  dist=v*dt0;

  lambda=sqrt(81.81/(VS2E*v*v));
  Al_s_tot_lambda= Al_pf_A+Al_pf_B1*lambda+ Al_pf_B2*lambda*lambda+ Al_pf_B3*lambda*lambda*lambda;
  Al_s_tot_lambda+=Al_pf_B4*lambda*lambda*lambda*lambda;
  Al_my_tot=Al_rho / Al_mmol * Al_s_tot_lambda * avogadro * 10;
  Al_my_a = Al_my_a_v/v;

  p *=exp(-Al_my_a*dist);/* neutron passes window without any interaction */

  /* TODO: scatter in Debye-Scherrer cone */

}
#line 60508 "ILL_H15_D11.c"
}   /* End of AlWindow9=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAlWindow9:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(71,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component D7toD11GuideStart [72] */
  mccoordschange(mcposrD7toD11GuideStart, mcrotrD7toD11GuideStart,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component D7toD11GuideStart (without coords transformations) */
  mcJumpTrace_D7toD11GuideStart:
  SIG_MESSAGE("D7toD11GuideStart (Trace)");
  mcDEBUG_COMP("D7toD11GuideStart")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompD7toD11GuideStart
  STORE_NEUTRON(72,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[72]++;
  mcPCounter[72] += p;
  mcP2Counter[72] += p*p;
#define mccompcurname  D7toD11GuideStart
#define mccompcurtype  Arm
#define mccompcurindex 72
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompD7toD11GuideStart:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(72,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg28 [73] */
  mccoordschange(mcposrsg28, mcrotrsg28,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg28 (without coords transformations) */
  mcJumpTrace_sg28:
  SIG_MESSAGE("sg28 (Trace)");
  mcDEBUG_COMP("sg28")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg28
  STORE_NEUTRON(73,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[73]++;
  mcPCounter[73] += p;
  mcP2Counter[73] += p*p;
#define mccompcurname  sg28
#define mccompcurtype  Guide_gravity
#define mccompcurindex 73
#define GVars mccsg28_GVars
#define pTable mccsg28_pTable
{   /* Declarations of sg28=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg28_w1;
MCNUM h1 = mccsg28_h1;
MCNUM w2 = mccsg28_w2;
MCNUM h2 = mccsg28_h2;
MCNUM l = mccsg28_l;
MCNUM R0 = mccsg28_R0;
MCNUM Qc = mccsg28_Qc;
MCNUM alpha = mccsg28_alpha;
MCNUM m = mccsg28_m;
MCNUM W = mccsg28_W;
MCNUM nslit = mccsg28_nslit;
MCNUM d = mccsg28_d;
MCNUM mleft = mccsg28_mleft;
MCNUM mright = mccsg28_mright;
MCNUM mtop = mccsg28_mtop;
MCNUM mbottom = mccsg28_mbottom;
MCNUM nhslit = mccsg28_nhslit;
MCNUM G = mccsg28_G;
MCNUM aleft = mccsg28_aleft;
MCNUM aright = mccsg28_aright;
MCNUM atop = mccsg28_atop;
MCNUM abottom = mccsg28_abottom;
MCNUM wavy = mccsg28_wavy;
MCNUM wavy_z = mccsg28_wavy_z;
MCNUM wavy_tb = mccsg28_wavy_tb;
MCNUM wavy_lr = mccsg28_wavy_lr;
MCNUM chamfers = mccsg28_chamfers;
MCNUM chamfers_z = mccsg28_chamfers_z;
MCNUM chamfers_lr = mccsg28_chamfers_lr;
MCNUM chamfers_tb = mccsg28_chamfers_tb;
MCNUM nelements = mccsg28_nelements;
MCNUM nu = mccsg28_nu;
MCNUM phase = mccsg28_phase;
char* reflect = mccsg28_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 60922 "ILL_H15_D11.c"
}   /* End of sg28=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg28:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(73,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg29 [74] */
  mccoordschange(mcposrsg29, mcrotrsg29,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg29 (without coords transformations) */
  mcJumpTrace_sg29:
  SIG_MESSAGE("sg29 (Trace)");
  mcDEBUG_COMP("sg29")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg29
  STORE_NEUTRON(74,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[74]++;
  mcPCounter[74] += p;
  mcP2Counter[74] += p*p;
#define mccompcurname  sg29
#define mccompcurtype  Guide_gravity
#define mccompcurindex 74
#define GVars mccsg29_GVars
#define pTable mccsg29_pTable
{   /* Declarations of sg29=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg29_w1;
MCNUM h1 = mccsg29_h1;
MCNUM w2 = mccsg29_w2;
MCNUM h2 = mccsg29_h2;
MCNUM l = mccsg29_l;
MCNUM R0 = mccsg29_R0;
MCNUM Qc = mccsg29_Qc;
MCNUM alpha = mccsg29_alpha;
MCNUM m = mccsg29_m;
MCNUM W = mccsg29_W;
MCNUM nslit = mccsg29_nslit;
MCNUM d = mccsg29_d;
MCNUM mleft = mccsg29_mleft;
MCNUM mright = mccsg29_mright;
MCNUM mtop = mccsg29_mtop;
MCNUM mbottom = mccsg29_mbottom;
MCNUM nhslit = mccsg29_nhslit;
MCNUM G = mccsg29_G;
MCNUM aleft = mccsg29_aleft;
MCNUM aright = mccsg29_aright;
MCNUM atop = mccsg29_atop;
MCNUM abottom = mccsg29_abottom;
MCNUM wavy = mccsg29_wavy;
MCNUM wavy_z = mccsg29_wavy_z;
MCNUM wavy_tb = mccsg29_wavy_tb;
MCNUM wavy_lr = mccsg29_wavy_lr;
MCNUM chamfers = mccsg29_chamfers;
MCNUM chamfers_z = mccsg29_chamfers_z;
MCNUM chamfers_lr = mccsg29_chamfers_lr;
MCNUM chamfers_tb = mccsg29_chamfers_tb;
MCNUM nelements = mccsg29_nelements;
MCNUM nu = mccsg29_nu;
MCNUM phase = mccsg29_phase;
char* reflect = mccsg29_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 61235 "ILL_H15_D11.c"
}   /* End of sg29=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg29:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(74,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component AlWindow10 [75] */
  mccoordschange(mcposrAlWindow10, mcrotrAlWindow10,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component AlWindow10 (without coords transformations) */
  mcJumpTrace_AlWindow10:
  SIG_MESSAGE("AlWindow10 (Trace)");
  mcDEBUG_COMP("AlWindow10")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAlWindow10
  STORE_NEUTRON(75,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[75]++;
  mcPCounter[75] += p;
  mcP2Counter[75] += p*p;
#define mccompcurname  AlWindow10
#define mccompcurtype  Al_window
#define mccompcurindex 75
{   /* Declarations of AlWindow10=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow10_thickness;
#line 68 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  double v;                     /* Neutron velocity */
  double dt0;     /* Flight times through sample */
  double dist;
  double Al_s_tot_lambda,Al_my_tot,Al_my_a ; /* total XS (barn), total scattering length (m-1), absorption scat. length */
  double lambda; /* neutrons wavelength */

  PROP_Z0;

  dt0=thickness/vz;
  v=sqrt(vx*vx+vy*vy+vz*vz);
  PROP_DT(dt0);
  dist=v*dt0;

  lambda=sqrt(81.81/(VS2E*v*v));
  Al_s_tot_lambda= Al_pf_A+Al_pf_B1*lambda+ Al_pf_B2*lambda*lambda+ Al_pf_B3*lambda*lambda*lambda;
  Al_s_tot_lambda+=Al_pf_B4*lambda*lambda*lambda*lambda;
  Al_my_tot=Al_rho / Al_mmol * Al_s_tot_lambda * avogadro * 10;
  Al_my_a = Al_my_a_v/v;

  p *=exp(-Al_my_a*dist);/* neutron passes window without any interaction */

  /* TODO: scatter in Debye-Scherrer cone */

}
#line 61370 "ILL_H15_D11.c"
}   /* End of AlWindow10=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAlWindow10:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(75,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Mon_D11_In [76] */
  mccoordschange(mcposrMon_D11_In, mcrotrMon_D11_In,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Mon_D11_In (without coords transformations) */
  mcJumpTrace_Mon_D11_In:
  SIG_MESSAGE("Mon_D11_In (Trace)");
  mcDEBUG_COMP("Mon_D11_In")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompMon_D11_In
  STORE_NEUTRON(76,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[76]++;
  mcPCounter[76] += p;
  mcP2Counter[76] += p*p;
#define mccompcurname  Mon_D11_In
#define mccompcurtype  Monitor_nD
#define mccompcurindex 76
#define user1 mccMon_D11_In_user1
#define user2 mccMon_D11_In_user2
#define user3 mccMon_D11_In_user3
#define DEFS mccMon_D11_In_DEFS
#define Vars mccMon_D11_In_Vars
#define detector mccMon_D11_In_detector
#define offdata mccMon_D11_In_offdata
{   /* Declarations of Mon_D11_In=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccMon_D11_In_xwidth;
MCNUM yheight = mccMon_D11_In_yheight;
MCNUM zdepth = mccMon_D11_In_zdepth;
MCNUM xmin = mccMon_D11_In_xmin;
MCNUM xmax = mccMon_D11_In_xmax;
MCNUM ymin = mccMon_D11_In_ymin;
MCNUM ymax = mccMon_D11_In_ymax;
MCNUM zmin = mccMon_D11_In_zmin;
MCNUM zmax = mccMon_D11_In_zmax;
MCNUM bins = mccMon_D11_In_bins;
MCNUM min = mccMon_D11_In_min;
MCNUM max = mccMon_D11_In_max;
MCNUM restore_neutron = mccMon_D11_In_restore_neutron;
MCNUM radius = mccMon_D11_In_radius;
char* options = mccMon_D11_In_options;
char* filename = mccMon_D11_In_filename;
char* geometry = mccMon_D11_In_geometry;
char* username1 = mccMon_D11_In_username1;
char* username2 = mccMon_D11_In_username2;
char* username3 = mccMon_D11_In_username3;
int nowritefile = mccMon_D11_In_nowritefile;
#line 312 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  double  XY=0;
  double  t0 = 0;
  double  t1 = 0;
  double  pp;
  int     intersect   = 0;
  char    Flag_Restore = 0;

  if (user1 != FLT_MAX) Vars.UserVariable1 = user1;
  if (user2 != FLT_MAX) Vars.UserVariable2 = user2;
  if (user3 != FLT_MAX) Vars.UserVariable3 = user3;

  /* this is done automatically
    STORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  */

  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    /* determine intersections with object */
    intersect = off_intersect_all(&t0, &t1, NULL, NULL,
       x,y,z, vx, vy, vz, &offdata );
    if (Vars.Flag_mantid) {
      if(intersect) {
        Vars.OFF_polyidx=(offdata.intersects[offdata.nextintersect]).index;
      } else {
        Vars.OFF_polyidx=-1;
      }
    }
  }
  else if ( (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
            || (abs(Vars.Flag_Shape) == DEFS.SHAPE_DISK) ) /* square xy or disk xy */
  {
    // propagate to xy plane and find intersection
    // make sure the event is recoverable afterwards
    t0 = t;
    ALLOW_BACKPROP;
    PROP_Z0;
    if ( (t>=t0) && (z==0.0) ) // forward propagation to xy plane was successful
    {
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
      {
        // square xy
        intersect = (x>=Vars.mxmin && x<=Vars.mxmax && y>=Vars.mymin && y<=Vars.mymax);
      }
      else
      {
        // disk xy
        intersect = (SQR(x) + SQR(y)) <= SQR(Vars.Sphere_Radius);
      }
    }
    else
    {
      intersect=0;
    }
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) /* sphere */
  {
    intersect = sphere_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius);
  /*      intersect = (intersect && t0 > 0); */
  }
  else if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)) /* cylinder */
  {
    intersect = cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius, Vars.Cylinder_Height);
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) /* box */
  {
    intersect = box_intersect(&t0, &t1, x, y, z, vx, vy, vz,
                              fabs(Vars.mxmax-Vars.mxmin), fabs(Vars.mymax-Vars.mymin), fabs(Vars.mzmax-Vars.mzmin));
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_PREVIOUS) /* previous comp */
  { intersect = 1; }

  if (intersect)
  {
    if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND)
     || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)
     || (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) )
    {
      /* check if we have to remove the top/bottom with BANANA shape */
      if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA) && (intersect != 1)) {
        double y0,y1;
        /* propagate to intersection point as temporary variable to check top/bottom */
        y0 = y+t0*vy;
        y1 = y+t1*vy;
        if (fabs(y0) >= Vars.Cylinder_Height/2*0.99) t0 = t1;
        if (fabs(y1) >= Vars.Cylinder_Height/2*0.99) t1 = t0;
      }
      if (t0 < 0 && t1 > 0)
        t0 = t;  /* neutron was already inside ! */
      if (t1 < 0 && t0 > 0) /* neutron exit before entering !! */
        t1 = t;
      /* t0 is now time of incoming intersection with the detection area */
      if ((Vars.Flag_Shape < 0) && (t1 > 0))
        PROP_DT(t1); /* t1 outgoing beam */
      else
        PROP_DT(t0); /* t0 incoming beam */
      /* Final test if we are on lid / bottom of banana/sphere */
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA || abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) {
        if (fabs(y) >= Vars.Cylinder_Height/2*0.99) {
          intersect=0;
          Flag_Restore=1;
        }
      }
    }
  }

  if (intersect)
  {
    /* Now get the data to monitor: current or keep from PreMonitor */
    if (Vars.Flag_UsePreMonitor != 1)
    {
      Vars.cp  = p;
      Vars.cx  = x;
      Vars.cvx = vx;
      Vars.csx = sx;
      Vars.cy  = y;
      Vars.cvy = vy;
      Vars.csy = sy;
      Vars.cz  = z;
      Vars.cvz = vz;
      Vars.csz = sz;
      Vars.ct  = t;
    }

    if ((Vars.He3_pressure > 0) && (t1 != t0) && ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX)))
    {
      XY = exp(-7.417*Vars.He3_pressure*fabs(t1-t0)*2*PI*K2V);
      /* will monitor the absorbed part */
      Vars.cp *= 1-XY;
      /* and modify the neutron weight after monitor, only remains 1-p_detect */
      p *= XY;
    }

    if (Vars.Flag_capture)
    {
      XY = sqrt(Vars.cvx*Vars.cvx+Vars.cvy*Vars.cvy+Vars.cvz*Vars.cvz);
      XY *= V2K;
      if (XY != 0) XY = 2*PI/XY; /* lambda. lambda(2200 m/2) = 1.7985 Angs  */
      Vars.cp *= XY/1.7985;
    }

    pp = Monitor_nD_Trace(&DEFS, &Vars);
    if (pp==0.0)
    { ABSORB;
    }
    else if(pp==1)
    {
      SCATTER;
    }

    if (Vars.Flag_parallel) /* back to neutron state before detection */
      Flag_Restore = 1;
  } /* end if intersection */
  else {
    if (Vars.Flag_Absorb && !Vars.Flag_parallel)
    {
      // restore neutron ray before absorbing for correct mcdisplay
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
      ABSORB;
    }
    else Flag_Restore = 1;  /* no intersection, back to previous state */
  }

  if (Flag_Restore)
  {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 61673 "ILL_H15_D11.c"
}   /* End of Mon_D11_In=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompMon_D11_In:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(76,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Dolores [77] */
  mccoordschange(mcposrDolores, mcrotrDolores,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Dolores (without coords transformations) */
  mcJumpTrace_Dolores:
  SIG_MESSAGE("Dolores (Trace)");
  mcDEBUG_COMP("Dolores")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompDolores
  STORE_NEUTRON(77,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[77]++;
  mcPCounter[77] += p;
  mcP2Counter[77] += p*p;
#define mccompcurname  Dolores
#define mccompcurtype  V_selector
#define mccompcurindex 77
#define omega mccDolores_omega
#define alpha_rad mccDolores_alpha_rad
#define dt0 mccDolores_dt0
#define dt1 mccDolores_dt1
#define r_i mccDolores_r_i
#define r_f mccDolores_r_f
#define r_mean mccDolores_r_mean
#define theta_i mccDolores_theta_i
#define theta_f mccDolores_theta_f
#define A mccDolores_A
#define d_s_alpha mccDolores_d_s_alpha
{   /* Declarations of Dolores=V_selector() SETTING parameters. */
MCNUM xwidth = mccDolores_xwidth;
MCNUM yheight = mccDolores_yheight;
MCNUM zdepth = mccDolores_zdepth;
MCNUM radius = mccDolores_radius;
MCNUM alpha = mccDolores_alpha;
MCNUM length = mccDolores_length;
MCNUM d = mccDolores_d;
MCNUM nu = mccDolores_nu;
MCNUM nslit = mccDolores_nslit;
#line 69 "/usr/share/mcstas/2.6rc1/optics/V_selector.comp"
{
  if (vz == 0)
    ABSORB;
  dt1= (-zdepth/2.0 - z)/vz;
  PROP_DT(dt1); /* Propagate to the entry aperture */
  if (x<(-xwidth/2.0) || x>(xwidth/2.0) || y<(-yheight/2.0) || y>(yheight/2.0))
    ABSORB;

  dt0 = (zdepth-length)/(2.0*vz); /* Propagate to the cylinder start */
  PROP_DT(dt0);
  r_i = sqrt(x*x+(y+radius)*(y+radius));
  theta_i = atan2(x,y+radius);

  dt1 = length/vz; /* Propagate along the cylinder length */
  PROP_DT(dt1);
  r_f = sqrt(x*x+(y+radius)*(y+radius));
  theta_f = atan2(x,y+radius);

  dt0 = (zdepth-length)/(2.0*vz); /* Propagate to the exit aperture */
  PROP_DT(dt0);
  if (x<(-xwidth/2.0) || x>(xwidth/2.0) || y<(-yheight/2.0) || y>(yheight/2.0))
    ABSORB;

  /* Calculate analytical transmission assuming continuous source */

  r_mean = (r_i + r_f)/2.0;          /* Approximation using mean radius */
  d_s_alpha = theta_f-theta_i;
  A = nslit/(2*PI)*( d/r_mean + fabs(alpha_rad+d_s_alpha-omega*length/vz) );
  if (A >= 1)
    ABSORB;
  p*= (1-A);
  SCATTER;
}
#line 61840 "ILL_H15_D11.c"
}   /* End of Dolores=V_selector() SETTING parameter declarations. */
#undef d_s_alpha
#undef A
#undef theta_f
#undef theta_i
#undef r_mean
#undef r_f
#undef r_i
#undef dt1
#undef dt0
#undef alpha_rad
#undef omega
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompDolores:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(77,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component AlWindow11 [78] */
  mccoordschange(mcposrAlWindow11, mcrotrAlWindow11,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component AlWindow11 (without coords transformations) */
  mcJumpTrace_AlWindow11:
  SIG_MESSAGE("AlWindow11 (Trace)");
  mcDEBUG_COMP("AlWindow11")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAlWindow11
  STORE_NEUTRON(78,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[78]++;
  mcPCounter[78] += p;
  mcP2Counter[78] += p*p;
#define mccompcurname  AlWindow11
#define mccompcurtype  Al_window
#define mccompcurindex 78
{   /* Declarations of AlWindow11=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow11_thickness;
#line 68 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  double v;                     /* Neutron velocity */
  double dt0;     /* Flight times through sample */
  double dist;
  double Al_s_tot_lambda,Al_my_tot,Al_my_a ; /* total XS (barn), total scattering length (m-1), absorption scat. length */
  double lambda; /* neutrons wavelength */

  PROP_Z0;

  dt0=thickness/vz;
  v=sqrt(vx*vx+vy*vy+vz*vz);
  PROP_DT(dt0);
  dist=v*dt0;

  lambda=sqrt(81.81/(VS2E*v*v));
  Al_s_tot_lambda= Al_pf_A+Al_pf_B1*lambda+ Al_pf_B2*lambda*lambda+ Al_pf_B3*lambda*lambda*lambda;
  Al_s_tot_lambda+=Al_pf_B4*lambda*lambda*lambda*lambda;
  Al_my_tot=Al_rho / Al_mmol * Al_s_tot_lambda * avogadro * 10;
  Al_my_a = Al_my_a_v/v;

  p *=exp(-Al_my_a*dist);/* neutron passes window without any interaction */

  /* TODO: scatter in Debye-Scherrer cone */

}
#line 61984 "ILL_H15_D11.c"
}   /* End of AlWindow11=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAlWindow11:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(78,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component sg30 [79] */
  mccoordschange(mcposrsg30, mcrotrsg30,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component sg30 (without coords transformations) */
  mcJumpTrace_sg30:
  SIG_MESSAGE("sg30 (Trace)");
  mcDEBUG_COMP("sg30")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompsg30
  STORE_NEUTRON(79,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[79]++;
  mcPCounter[79] += p;
  mcP2Counter[79] += p*p;
#define mccompcurname  sg30
#define mccompcurtype  Guide_gravity
#define mccompcurindex 79
#define GVars mccsg30_GVars
#define pTable mccsg30_pTable
{   /* Declarations of sg30=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg30_w1;
MCNUM h1 = mccsg30_h1;
MCNUM w2 = mccsg30_w2;
MCNUM h2 = mccsg30_h2;
MCNUM l = mccsg30_l;
MCNUM R0 = mccsg30_R0;
MCNUM Qc = mccsg30_Qc;
MCNUM alpha = mccsg30_alpha;
MCNUM m = mccsg30_m;
MCNUM W = mccsg30_W;
MCNUM nslit = mccsg30_nslit;
MCNUM d = mccsg30_d;
MCNUM mleft = mccsg30_mleft;
MCNUM mright = mccsg30_mright;
MCNUM mtop = mccsg30_mtop;
MCNUM mbottom = mccsg30_mbottom;
MCNUM nhslit = mccsg30_nhslit;
MCNUM G = mccsg30_G;
MCNUM aleft = mccsg30_aleft;
MCNUM aright = mccsg30_aright;
MCNUM atop = mccsg30_atop;
MCNUM abottom = mccsg30_abottom;
MCNUM wavy = mccsg30_wavy;
MCNUM wavy_z = mccsg30_wavy_z;
MCNUM wavy_tb = mccsg30_wavy_tb;
MCNUM wavy_lr = mccsg30_wavy_lr;
MCNUM chamfers = mccsg30_chamfers;
MCNUM chamfers_z = mccsg30_chamfers_z;
MCNUM chamfers_lr = mccsg30_chamfers_lr;
MCNUM chamfers_tb = mccsg30_chamfers_tb;
MCNUM nelements = mccsg30_nelements;
MCNUM nu = mccsg30_nu;
MCNUM phase = mccsg30_phase;
char* reflect = mccsg30_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 62295 "ILL_H15_D11.c"
}   /* End of sg30=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompsg30:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(79,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component AlWindow12 [80] */
  mccoordschange(mcposrAlWindow12, mcrotrAlWindow12,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component AlWindow12 (without coords transformations) */
  mcJumpTrace_AlWindow12:
  SIG_MESSAGE("AlWindow12 (Trace)");
  mcDEBUG_COMP("AlWindow12")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAlWindow12
  STORE_NEUTRON(80,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[80]++;
  mcPCounter[80] += p;
  mcP2Counter[80] += p*p;
#define mccompcurname  AlWindow12
#define mccompcurtype  Al_window
#define mccompcurindex 80
{   /* Declarations of AlWindow12=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow12_thickness;
#line 68 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  double v;                     /* Neutron velocity */
  double dt0;     /* Flight times through sample */
  double dist;
  double Al_s_tot_lambda,Al_my_tot,Al_my_a ; /* total XS (barn), total scattering length (m-1), absorption scat. length */
  double lambda; /* neutrons wavelength */

  PROP_Z0;

  dt0=thickness/vz;
  v=sqrt(vx*vx+vy*vy+vz*vz);
  PROP_DT(dt0);
  dist=v*dt0;

  lambda=sqrt(81.81/(VS2E*v*v));
  Al_s_tot_lambda= Al_pf_A+Al_pf_B1*lambda+ Al_pf_B2*lambda*lambda+ Al_pf_B3*lambda*lambda*lambda;
  Al_s_tot_lambda+=Al_pf_B4*lambda*lambda*lambda*lambda;
  Al_my_tot=Al_rho / Al_mmol * Al_s_tot_lambda * avogadro * 10;
  Al_my_a = Al_my_a_v/v;

  p *=exp(-Al_my_a*dist);/* neutron passes window without any interaction */

  /* TODO: scatter in Debye-Scherrer cone */

}
#line 62430 "ILL_H15_D11.c"
}   /* End of AlWindow12=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAlWindow12:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(80,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component Mon_D11_Out [81] */
  mccoordschange(mcposrMon_D11_Out, mcrotrMon_D11_Out,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component Mon_D11_Out (without coords transformations) */
  mcJumpTrace_Mon_D11_Out:
  SIG_MESSAGE("Mon_D11_Out (Trace)");
  mcDEBUG_COMP("Mon_D11_Out")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompMon_D11_Out
  STORE_NEUTRON(81,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[81]++;
  mcPCounter[81] += p;
  mcP2Counter[81] += p*p;
#define mccompcurname  Mon_D11_Out
#define mccompcurtype  Monitor_nD
#define mccompcurindex 81
#define user1 mccMon_D11_Out_user1
#define user2 mccMon_D11_Out_user2
#define user3 mccMon_D11_Out_user3
#define DEFS mccMon_D11_Out_DEFS
#define Vars mccMon_D11_Out_Vars
#define detector mccMon_D11_Out_detector
#define offdata mccMon_D11_Out_offdata
{   /* Declarations of Mon_D11_Out=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccMon_D11_Out_xwidth;
MCNUM yheight = mccMon_D11_Out_yheight;
MCNUM zdepth = mccMon_D11_Out_zdepth;
MCNUM xmin = mccMon_D11_Out_xmin;
MCNUM xmax = mccMon_D11_Out_xmax;
MCNUM ymin = mccMon_D11_Out_ymin;
MCNUM ymax = mccMon_D11_Out_ymax;
MCNUM zmin = mccMon_D11_Out_zmin;
MCNUM zmax = mccMon_D11_Out_zmax;
MCNUM bins = mccMon_D11_Out_bins;
MCNUM min = mccMon_D11_Out_min;
MCNUM max = mccMon_D11_Out_max;
MCNUM restore_neutron = mccMon_D11_Out_restore_neutron;
MCNUM radius = mccMon_D11_Out_radius;
char* options = mccMon_D11_Out_options;
char* filename = mccMon_D11_Out_filename;
char* geometry = mccMon_D11_Out_geometry;
char* username1 = mccMon_D11_Out_username1;
char* username2 = mccMon_D11_Out_username2;
char* username3 = mccMon_D11_Out_username3;
int nowritefile = mccMon_D11_Out_nowritefile;
#line 312 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  double  XY=0;
  double  t0 = 0;
  double  t1 = 0;
  double  pp;
  int     intersect   = 0;
  char    Flag_Restore = 0;

  if (user1 != FLT_MAX) Vars.UserVariable1 = user1;
  if (user2 != FLT_MAX) Vars.UserVariable2 = user2;
  if (user3 != FLT_MAX) Vars.UserVariable3 = user3;

  /* this is done automatically
    STORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  */

  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    /* determine intersections with object */
    intersect = off_intersect_all(&t0, &t1, NULL, NULL,
       x,y,z, vx, vy, vz, &offdata );
    if (Vars.Flag_mantid) {
      if(intersect) {
        Vars.OFF_polyidx=(offdata.intersects[offdata.nextintersect]).index;
      } else {
        Vars.OFF_polyidx=-1;
      }
    }
  }
  else if ( (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
            || (abs(Vars.Flag_Shape) == DEFS.SHAPE_DISK) ) /* square xy or disk xy */
  {
    // propagate to xy plane and find intersection
    // make sure the event is recoverable afterwards
    t0 = t;
    ALLOW_BACKPROP;
    PROP_Z0;
    if ( (t>=t0) && (z==0.0) ) // forward propagation to xy plane was successful
    {
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
      {
        // square xy
        intersect = (x>=Vars.mxmin && x<=Vars.mxmax && y>=Vars.mymin && y<=Vars.mymax);
      }
      else
      {
        // disk xy
        intersect = (SQR(x) + SQR(y)) <= SQR(Vars.Sphere_Radius);
      }
    }
    else
    {
      intersect=0;
    }
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) /* sphere */
  {
    intersect = sphere_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius);
  /*      intersect = (intersect && t0 > 0); */
  }
  else if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)) /* cylinder */
  {
    intersect = cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius, Vars.Cylinder_Height);
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) /* box */
  {
    intersect = box_intersect(&t0, &t1, x, y, z, vx, vy, vz,
                              fabs(Vars.mxmax-Vars.mxmin), fabs(Vars.mymax-Vars.mymin), fabs(Vars.mzmax-Vars.mzmin));
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_PREVIOUS) /* previous comp */
  { intersect = 1; }

  if (intersect)
  {
    if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND)
     || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)
     || (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) )
    {
      /* check if we have to remove the top/bottom with BANANA shape */
      if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA) && (intersect != 1)) {
        double y0,y1;
        /* propagate to intersection point as temporary variable to check top/bottom */
        y0 = y+t0*vy;
        y1 = y+t1*vy;
        if (fabs(y0) >= Vars.Cylinder_Height/2*0.99) t0 = t1;
        if (fabs(y1) >= Vars.Cylinder_Height/2*0.99) t1 = t0;
      }
      if (t0 < 0 && t1 > 0)
        t0 = t;  /* neutron was already inside ! */
      if (t1 < 0 && t0 > 0) /* neutron exit before entering !! */
        t1 = t;
      /* t0 is now time of incoming intersection with the detection area */
      if ((Vars.Flag_Shape < 0) && (t1 > 0))
        PROP_DT(t1); /* t1 outgoing beam */
      else
        PROP_DT(t0); /* t0 incoming beam */
      /* Final test if we are on lid / bottom of banana/sphere */
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA || abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) {
        if (fabs(y) >= Vars.Cylinder_Height/2*0.99) {
          intersect=0;
          Flag_Restore=1;
        }
      }
    }
  }

  if (intersect)
  {
    /* Now get the data to monitor: current or keep from PreMonitor */
    if (Vars.Flag_UsePreMonitor != 1)
    {
      Vars.cp  = p;
      Vars.cx  = x;
      Vars.cvx = vx;
      Vars.csx = sx;
      Vars.cy  = y;
      Vars.cvy = vy;
      Vars.csy = sy;
      Vars.cz  = z;
      Vars.cvz = vz;
      Vars.csz = sz;
      Vars.ct  = t;
    }

    if ((Vars.He3_pressure > 0) && (t1 != t0) && ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX)))
    {
      XY = exp(-7.417*Vars.He3_pressure*fabs(t1-t0)*2*PI*K2V);
      /* will monitor the absorbed part */
      Vars.cp *= 1-XY;
      /* and modify the neutron weight after monitor, only remains 1-p_detect */
      p *= XY;
    }

    if (Vars.Flag_capture)
    {
      XY = sqrt(Vars.cvx*Vars.cvx+Vars.cvy*Vars.cvy+Vars.cvz*Vars.cvz);
      XY *= V2K;
      if (XY != 0) XY = 2*PI/XY; /* lambda. lambda(2200 m/2) = 1.7985 Angs  */
      Vars.cp *= XY/1.7985;
    }

    pp = Monitor_nD_Trace(&DEFS, &Vars);
    if (pp==0.0)
    { ABSORB;
    }
    else if(pp==1)
    {
      SCATTER;
    }

    if (Vars.Flag_parallel) /* back to neutron state before detection */
      Flag_Restore = 1;
  } /* end if intersection */
  else {
    if (Vars.Flag_Absorb && !Vars.Flag_parallel)
    {
      // restore neutron ray before absorbing for correct mcdisplay
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
      ABSORB;
    }
    else Flag_Restore = 1;  /* no intersection, back to previous state */
  }

  if (Flag_Restore)
  {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 62733 "ILL_H15_D11.c"
}   /* End of Mon_D11_Out=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompMon_D11_Out:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(81,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component AlWindow13 [82] */
  mccoordschange(mcposrAlWindow13, mcrotrAlWindow13,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component AlWindow13 (without coords transformations) */
  mcJumpTrace_AlWindow13:
  SIG_MESSAGE("AlWindow13 (Trace)");
  mcDEBUG_COMP("AlWindow13")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompAlWindow13
  STORE_NEUTRON(82,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[82]++;
  mcPCounter[82] += p;
  mcP2Counter[82] += p*p;
#define mccompcurname  AlWindow13
#define mccompcurtype  Al_window
#define mccompcurindex 82
{   /* Declarations of AlWindow13=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow13_thickness;
#line 68 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  double v;                     /* Neutron velocity */
  double dt0;     /* Flight times through sample */
  double dist;
  double Al_s_tot_lambda,Al_my_tot,Al_my_a ; /* total XS (barn), total scattering length (m-1), absorption scat. length */
  double lambda; /* neutrons wavelength */

  PROP_Z0;

  dt0=thickness/vz;
  v=sqrt(vx*vx+vy*vy+vz*vz);
  PROP_DT(dt0);
  dist=v*dt0;

  lambda=sqrt(81.81/(VS2E*v*v));
  Al_s_tot_lambda= Al_pf_A+Al_pf_B1*lambda+ Al_pf_B2*lambda*lambda+ Al_pf_B3*lambda*lambda*lambda;
  Al_s_tot_lambda+=Al_pf_B4*lambda*lambda*lambda*lambda;
  Al_my_tot=Al_rho / Al_mmol * Al_s_tot_lambda * avogadro * 10;
  Al_my_a = Al_my_a_v/v;

  p *=exp(-Al_my_a*dist);/* neutron passes window without any interaction */

  /* TODO: scatter in Debye-Scherrer cone */

}
#line 62873 "ILL_H15_D11.c"
}   /* End of AlWindow13=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompAlWindow13:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(82,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component MovableGuideStart [83] */
  mccoordschange(mcposrMovableGuideStart, mcrotrMovableGuideStart,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component MovableGuideStart (without coords transformations) */
  mcJumpTrace_MovableGuideStart:
  SIG_MESSAGE("MovableGuideStart (Trace)");
  mcDEBUG_COMP("MovableGuideStart")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompMovableGuideStart
  STORE_NEUTRON(83,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[83]++;
  mcPCounter[83] += p;
  mcP2Counter[83] += p*p;
#define mccompcurname  MovableGuideStart
#define mccompcurtype  Arm
#define mccompcurindex 83
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompMovableGuideStart:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(83,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component mg0 [84] */
  mccoordschange(mcposrmg0, mcrotrmg0,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component mg0 (without coords transformations) */
  mcJumpTrace_mg0:
  SIG_MESSAGE("mg0 (Trace)");
  mcDEBUG_COMP("mg0")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmg0
  STORE_NEUTRON(84,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[84]++;
  mcPCounter[84] += p;
  mcP2Counter[84] += p*p;
#define mccompcurname  mg0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 84
#define GVars mccmg0_GVars
#define pTable mccmg0_pTable
{   /* Declarations of mg0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg0_w1;
MCNUM h1 = mccmg0_h1;
MCNUM w2 = mccmg0_w2;
MCNUM h2 = mccmg0_h2;
MCNUM l = mccmg0_l;
MCNUM R0 = mccmg0_R0;
MCNUM Qc = mccmg0_Qc;
MCNUM alpha = mccmg0_alpha;
MCNUM m = mccmg0_m;
MCNUM W = mccmg0_W;
MCNUM nslit = mccmg0_nslit;
MCNUM d = mccmg0_d;
MCNUM mleft = mccmg0_mleft;
MCNUM mright = mccmg0_mright;
MCNUM mtop = mccmg0_mtop;
MCNUM mbottom = mccmg0_mbottom;
MCNUM nhslit = mccmg0_nhslit;
MCNUM G = mccmg0_G;
MCNUM aleft = mccmg0_aleft;
MCNUM aright = mccmg0_aright;
MCNUM atop = mccmg0_atop;
MCNUM abottom = mccmg0_abottom;
MCNUM wavy = mccmg0_wavy;
MCNUM wavy_z = mccmg0_wavy_z;
MCNUM wavy_tb = mccmg0_wavy_tb;
MCNUM wavy_lr = mccmg0_wavy_lr;
MCNUM chamfers = mccmg0_chamfers;
MCNUM chamfers_z = mccmg0_chamfers_z;
MCNUM chamfers_lr = mccmg0_chamfers_lr;
MCNUM chamfers_tb = mccmg0_chamfers_tb;
MCNUM nelements = mccmg0_nelements;
MCNUM nu = mccmg0_nu;
MCNUM phase = mccmg0_phase;
char* reflect = mccmg0_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 63287 "ILL_H15_D11.c"
}   /* End of mg0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmg0:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(84,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component mg1 [85] */
  mccoordschange(mcposrmg1, mcrotrmg1,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component mg1 (without coords transformations) */
  mcJumpTrace_mg1:
  SIG_MESSAGE("mg1 (Trace)");
  mcDEBUG_COMP("mg1")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmg1
  STORE_NEUTRON(85,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[85]++;
  mcPCounter[85] += p;
  mcP2Counter[85] += p*p;
#define mccompcurname  mg1
#define mccompcurtype  Guide_gravity
#define mccompcurindex 85
#define GVars mccmg1_GVars
#define pTable mccmg1_pTable
{   /* Declarations of mg1=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg1_w1;
MCNUM h1 = mccmg1_h1;
MCNUM w2 = mccmg1_w2;
MCNUM h2 = mccmg1_h2;
MCNUM l = mccmg1_l;
MCNUM R0 = mccmg1_R0;
MCNUM Qc = mccmg1_Qc;
MCNUM alpha = mccmg1_alpha;
MCNUM m = mccmg1_m;
MCNUM W = mccmg1_W;
MCNUM nslit = mccmg1_nslit;
MCNUM d = mccmg1_d;
MCNUM mleft = mccmg1_mleft;
MCNUM mright = mccmg1_mright;
MCNUM mtop = mccmg1_mtop;
MCNUM mbottom = mccmg1_mbottom;
MCNUM nhslit = mccmg1_nhslit;
MCNUM G = mccmg1_G;
MCNUM aleft = mccmg1_aleft;
MCNUM aright = mccmg1_aright;
MCNUM atop = mccmg1_atop;
MCNUM abottom = mccmg1_abottom;
MCNUM wavy = mccmg1_wavy;
MCNUM wavy_z = mccmg1_wavy_z;
MCNUM wavy_tb = mccmg1_wavy_tb;
MCNUM wavy_lr = mccmg1_wavy_lr;
MCNUM chamfers = mccmg1_chamfers;
MCNUM chamfers_z = mccmg1_chamfers_z;
MCNUM chamfers_lr = mccmg1_chamfers_lr;
MCNUM chamfers_tb = mccmg1_chamfers_tb;
MCNUM nelements = mccmg1_nelements;
MCNUM nu = mccmg1_nu;
MCNUM phase = mccmg1_phase;
char* reflect = mccmg1_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 63600 "ILL_H15_D11.c"
}   /* End of mg1=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmg1:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(85,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component mg2 [86] */
  mccoordschange(mcposrmg2, mcrotrmg2,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component mg2 (without coords transformations) */
  mcJumpTrace_mg2:
  SIG_MESSAGE("mg2 (Trace)");
  mcDEBUG_COMP("mg2")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmg2
  STORE_NEUTRON(86,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[86]++;
  mcPCounter[86] += p;
  mcP2Counter[86] += p*p;
#define mccompcurname  mg2
#define mccompcurtype  Guide_gravity
#define mccompcurindex 86
#define GVars mccmg2_GVars
#define pTable mccmg2_pTable
{   /* Declarations of mg2=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg2_w1;
MCNUM h1 = mccmg2_h1;
MCNUM w2 = mccmg2_w2;
MCNUM h2 = mccmg2_h2;
MCNUM l = mccmg2_l;
MCNUM R0 = mccmg2_R0;
MCNUM Qc = mccmg2_Qc;
MCNUM alpha = mccmg2_alpha;
MCNUM m = mccmg2_m;
MCNUM W = mccmg2_W;
MCNUM nslit = mccmg2_nslit;
MCNUM d = mccmg2_d;
MCNUM mleft = mccmg2_mleft;
MCNUM mright = mccmg2_mright;
MCNUM mtop = mccmg2_mtop;
MCNUM mbottom = mccmg2_mbottom;
MCNUM nhslit = mccmg2_nhslit;
MCNUM G = mccmg2_G;
MCNUM aleft = mccmg2_aleft;
MCNUM aright = mccmg2_aright;
MCNUM atop = mccmg2_atop;
MCNUM abottom = mccmg2_abottom;
MCNUM wavy = mccmg2_wavy;
MCNUM wavy_z = mccmg2_wavy_z;
MCNUM wavy_tb = mccmg2_wavy_tb;
MCNUM wavy_lr = mccmg2_wavy_lr;
MCNUM chamfers = mccmg2_chamfers;
MCNUM chamfers_z = mccmg2_chamfers_z;
MCNUM chamfers_lr = mccmg2_chamfers_lr;
MCNUM chamfers_tb = mccmg2_chamfers_tb;
MCNUM nelements = mccmg2_nelements;
MCNUM nu = mccmg2_nu;
MCNUM phase = mccmg2_phase;
char* reflect = mccmg2_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 63913 "ILL_H15_D11.c"
}   /* End of mg2=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmg2:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(86,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component mg3 [87] */
  mccoordschange(mcposrmg3, mcrotrmg3,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component mg3 (without coords transformations) */
  mcJumpTrace_mg3:
  SIG_MESSAGE("mg3 (Trace)");
  mcDEBUG_COMP("mg3")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmg3
  STORE_NEUTRON(87,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[87]++;
  mcPCounter[87] += p;
  mcP2Counter[87] += p*p;
#define mccompcurname  mg3
#define mccompcurtype  Guide_gravity
#define mccompcurindex 87
#define GVars mccmg3_GVars
#define pTable mccmg3_pTable
{   /* Declarations of mg3=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg3_w1;
MCNUM h1 = mccmg3_h1;
MCNUM w2 = mccmg3_w2;
MCNUM h2 = mccmg3_h2;
MCNUM l = mccmg3_l;
MCNUM R0 = mccmg3_R0;
MCNUM Qc = mccmg3_Qc;
MCNUM alpha = mccmg3_alpha;
MCNUM m = mccmg3_m;
MCNUM W = mccmg3_W;
MCNUM nslit = mccmg3_nslit;
MCNUM d = mccmg3_d;
MCNUM mleft = mccmg3_mleft;
MCNUM mright = mccmg3_mright;
MCNUM mtop = mccmg3_mtop;
MCNUM mbottom = mccmg3_mbottom;
MCNUM nhslit = mccmg3_nhslit;
MCNUM G = mccmg3_G;
MCNUM aleft = mccmg3_aleft;
MCNUM aright = mccmg3_aright;
MCNUM atop = mccmg3_atop;
MCNUM abottom = mccmg3_abottom;
MCNUM wavy = mccmg3_wavy;
MCNUM wavy_z = mccmg3_wavy_z;
MCNUM wavy_tb = mccmg3_wavy_tb;
MCNUM wavy_lr = mccmg3_wavy_lr;
MCNUM chamfers = mccmg3_chamfers;
MCNUM chamfers_z = mccmg3_chamfers_z;
MCNUM chamfers_lr = mccmg3_chamfers_lr;
MCNUM chamfers_tb = mccmg3_chamfers_tb;
MCNUM nelements = mccmg3_nelements;
MCNUM nu = mccmg3_nu;
MCNUM phase = mccmg3_phase;
char* reflect = mccmg3_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 64226 "ILL_H15_D11.c"
}   /* End of mg3=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmg3:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(87,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component mg4 [88] */
  mccoordschange(mcposrmg4, mcrotrmg4,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component mg4 (without coords transformations) */
  mcJumpTrace_mg4:
  SIG_MESSAGE("mg4 (Trace)");
  mcDEBUG_COMP("mg4")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmg4
  STORE_NEUTRON(88,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[88]++;
  mcPCounter[88] += p;
  mcP2Counter[88] += p*p;
#define mccompcurname  mg4
#define mccompcurtype  Guide_gravity
#define mccompcurindex 88
#define GVars mccmg4_GVars
#define pTable mccmg4_pTable
{   /* Declarations of mg4=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg4_w1;
MCNUM h1 = mccmg4_h1;
MCNUM w2 = mccmg4_w2;
MCNUM h2 = mccmg4_h2;
MCNUM l = mccmg4_l;
MCNUM R0 = mccmg4_R0;
MCNUM Qc = mccmg4_Qc;
MCNUM alpha = mccmg4_alpha;
MCNUM m = mccmg4_m;
MCNUM W = mccmg4_W;
MCNUM nslit = mccmg4_nslit;
MCNUM d = mccmg4_d;
MCNUM mleft = mccmg4_mleft;
MCNUM mright = mccmg4_mright;
MCNUM mtop = mccmg4_mtop;
MCNUM mbottom = mccmg4_mbottom;
MCNUM nhslit = mccmg4_nhslit;
MCNUM G = mccmg4_G;
MCNUM aleft = mccmg4_aleft;
MCNUM aright = mccmg4_aright;
MCNUM atop = mccmg4_atop;
MCNUM abottom = mccmg4_abottom;
MCNUM wavy = mccmg4_wavy;
MCNUM wavy_z = mccmg4_wavy_z;
MCNUM wavy_tb = mccmg4_wavy_tb;
MCNUM wavy_lr = mccmg4_wavy_lr;
MCNUM chamfers = mccmg4_chamfers;
MCNUM chamfers_z = mccmg4_chamfers_z;
MCNUM chamfers_lr = mccmg4_chamfers_lr;
MCNUM chamfers_tb = mccmg4_chamfers_tb;
MCNUM nelements = mccmg4_nelements;
MCNUM nu = mccmg4_nu;
MCNUM phase = mccmg4_phase;
char* reflect = mccmg4_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 64539 "ILL_H15_D11.c"
}   /* End of mg4=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmg4:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(88,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component mg5 [89] */
  mccoordschange(mcposrmg5, mcrotrmg5,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component mg5 (without coords transformations) */
  mcJumpTrace_mg5:
  SIG_MESSAGE("mg5 (Trace)");
  mcDEBUG_COMP("mg5")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmg5
  STORE_NEUTRON(89,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[89]++;
  mcPCounter[89] += p;
  mcP2Counter[89] += p*p;
#define mccompcurname  mg5
#define mccompcurtype  Guide_gravity
#define mccompcurindex 89
#define GVars mccmg5_GVars
#define pTable mccmg5_pTable
{   /* Declarations of mg5=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg5_w1;
MCNUM h1 = mccmg5_h1;
MCNUM w2 = mccmg5_w2;
MCNUM h2 = mccmg5_h2;
MCNUM l = mccmg5_l;
MCNUM R0 = mccmg5_R0;
MCNUM Qc = mccmg5_Qc;
MCNUM alpha = mccmg5_alpha;
MCNUM m = mccmg5_m;
MCNUM W = mccmg5_W;
MCNUM nslit = mccmg5_nslit;
MCNUM d = mccmg5_d;
MCNUM mleft = mccmg5_mleft;
MCNUM mright = mccmg5_mright;
MCNUM mtop = mccmg5_mtop;
MCNUM mbottom = mccmg5_mbottom;
MCNUM nhslit = mccmg5_nhslit;
MCNUM G = mccmg5_G;
MCNUM aleft = mccmg5_aleft;
MCNUM aright = mccmg5_aright;
MCNUM atop = mccmg5_atop;
MCNUM abottom = mccmg5_abottom;
MCNUM wavy = mccmg5_wavy;
MCNUM wavy_z = mccmg5_wavy_z;
MCNUM wavy_tb = mccmg5_wavy_tb;
MCNUM wavy_lr = mccmg5_wavy_lr;
MCNUM chamfers = mccmg5_chamfers;
MCNUM chamfers_z = mccmg5_chamfers_z;
MCNUM chamfers_lr = mccmg5_chamfers_lr;
MCNUM chamfers_tb = mccmg5_chamfers_tb;
MCNUM nelements = mccmg5_nelements;
MCNUM nu = mccmg5_nu;
MCNUM phase = mccmg5_phase;
char* reflect = mccmg5_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 64852 "ILL_H15_D11.c"
}   /* End of mg5=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmg5:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(89,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component mg6 [90] */
  mccoordschange(mcposrmg6, mcrotrmg6,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component mg6 (without coords transformations) */
  mcJumpTrace_mg6:
  SIG_MESSAGE("mg6 (Trace)");
  mcDEBUG_COMP("mg6")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmg6
  STORE_NEUTRON(90,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[90]++;
  mcPCounter[90] += p;
  mcP2Counter[90] += p*p;
#define mccompcurname  mg6
#define mccompcurtype  Guide_gravity
#define mccompcurindex 90
#define GVars mccmg6_GVars
#define pTable mccmg6_pTable
{   /* Declarations of mg6=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg6_w1;
MCNUM h1 = mccmg6_h1;
MCNUM w2 = mccmg6_w2;
MCNUM h2 = mccmg6_h2;
MCNUM l = mccmg6_l;
MCNUM R0 = mccmg6_R0;
MCNUM Qc = mccmg6_Qc;
MCNUM alpha = mccmg6_alpha;
MCNUM m = mccmg6_m;
MCNUM W = mccmg6_W;
MCNUM nslit = mccmg6_nslit;
MCNUM d = mccmg6_d;
MCNUM mleft = mccmg6_mleft;
MCNUM mright = mccmg6_mright;
MCNUM mtop = mccmg6_mtop;
MCNUM mbottom = mccmg6_mbottom;
MCNUM nhslit = mccmg6_nhslit;
MCNUM G = mccmg6_G;
MCNUM aleft = mccmg6_aleft;
MCNUM aright = mccmg6_aright;
MCNUM atop = mccmg6_atop;
MCNUM abottom = mccmg6_abottom;
MCNUM wavy = mccmg6_wavy;
MCNUM wavy_z = mccmg6_wavy_z;
MCNUM wavy_tb = mccmg6_wavy_tb;
MCNUM wavy_lr = mccmg6_wavy_lr;
MCNUM chamfers = mccmg6_chamfers;
MCNUM chamfers_z = mccmg6_chamfers_z;
MCNUM chamfers_lr = mccmg6_chamfers_lr;
MCNUM chamfers_tb = mccmg6_chamfers_tb;
MCNUM nelements = mccmg6_nelements;
MCNUM nu = mccmg6_nu;
MCNUM phase = mccmg6_phase;
char* reflect = mccmg6_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 65165 "ILL_H15_D11.c"
}   /* End of mg6=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmg6:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(90,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component mg7 [91] */
  mccoordschange(mcposrmg7, mcrotrmg7,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component mg7 (without coords transformations) */
  mcJumpTrace_mg7:
  SIG_MESSAGE("mg7 (Trace)");
  mcDEBUG_COMP("mg7")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmg7
  STORE_NEUTRON(91,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[91]++;
  mcPCounter[91] += p;
  mcP2Counter[91] += p*p;
#define mccompcurname  mg7
#define mccompcurtype  Guide_gravity
#define mccompcurindex 91
#define GVars mccmg7_GVars
#define pTable mccmg7_pTable
{   /* Declarations of mg7=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg7_w1;
MCNUM h1 = mccmg7_h1;
MCNUM w2 = mccmg7_w2;
MCNUM h2 = mccmg7_h2;
MCNUM l = mccmg7_l;
MCNUM R0 = mccmg7_R0;
MCNUM Qc = mccmg7_Qc;
MCNUM alpha = mccmg7_alpha;
MCNUM m = mccmg7_m;
MCNUM W = mccmg7_W;
MCNUM nslit = mccmg7_nslit;
MCNUM d = mccmg7_d;
MCNUM mleft = mccmg7_mleft;
MCNUM mright = mccmg7_mright;
MCNUM mtop = mccmg7_mtop;
MCNUM mbottom = mccmg7_mbottom;
MCNUM nhslit = mccmg7_nhslit;
MCNUM G = mccmg7_G;
MCNUM aleft = mccmg7_aleft;
MCNUM aright = mccmg7_aright;
MCNUM atop = mccmg7_atop;
MCNUM abottom = mccmg7_abottom;
MCNUM wavy = mccmg7_wavy;
MCNUM wavy_z = mccmg7_wavy_z;
MCNUM wavy_tb = mccmg7_wavy_tb;
MCNUM wavy_lr = mccmg7_wavy_lr;
MCNUM chamfers = mccmg7_chamfers;
MCNUM chamfers_z = mccmg7_chamfers_z;
MCNUM chamfers_lr = mccmg7_chamfers_lr;
MCNUM chamfers_tb = mccmg7_chamfers_tb;
MCNUM nelements = mccmg7_nelements;
MCNUM nu = mccmg7_nu;
MCNUM phase = mccmg7_phase;
char* reflect = mccmg7_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 65478 "ILL_H15_D11.c"
}   /* End of mg7=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmg7:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(91,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component mg8 [92] */
  mccoordschange(mcposrmg8, mcrotrmg8,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component mg8 (without coords transformations) */
  mcJumpTrace_mg8:
  SIG_MESSAGE("mg8 (Trace)");
  mcDEBUG_COMP("mg8")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmg8
  STORE_NEUTRON(92,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[92]++;
  mcPCounter[92] += p;
  mcP2Counter[92] += p*p;
#define mccompcurname  mg8
#define mccompcurtype  Guide_gravity
#define mccompcurindex 92
#define GVars mccmg8_GVars
#define pTable mccmg8_pTable
{   /* Declarations of mg8=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg8_w1;
MCNUM h1 = mccmg8_h1;
MCNUM w2 = mccmg8_w2;
MCNUM h2 = mccmg8_h2;
MCNUM l = mccmg8_l;
MCNUM R0 = mccmg8_R0;
MCNUM Qc = mccmg8_Qc;
MCNUM alpha = mccmg8_alpha;
MCNUM m = mccmg8_m;
MCNUM W = mccmg8_W;
MCNUM nslit = mccmg8_nslit;
MCNUM d = mccmg8_d;
MCNUM mleft = mccmg8_mleft;
MCNUM mright = mccmg8_mright;
MCNUM mtop = mccmg8_mtop;
MCNUM mbottom = mccmg8_mbottom;
MCNUM nhslit = mccmg8_nhslit;
MCNUM G = mccmg8_G;
MCNUM aleft = mccmg8_aleft;
MCNUM aright = mccmg8_aright;
MCNUM atop = mccmg8_atop;
MCNUM abottom = mccmg8_abottom;
MCNUM wavy = mccmg8_wavy;
MCNUM wavy_z = mccmg8_wavy_z;
MCNUM wavy_tb = mccmg8_wavy_tb;
MCNUM wavy_lr = mccmg8_wavy_lr;
MCNUM chamfers = mccmg8_chamfers;
MCNUM chamfers_z = mccmg8_chamfers_z;
MCNUM chamfers_lr = mccmg8_chamfers_lr;
MCNUM chamfers_tb = mccmg8_chamfers_tb;
MCNUM nelements = mccmg8_nelements;
MCNUM nu = mccmg8_nu;
MCNUM phase = mccmg8_phase;
char* reflect = mccmg8_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 65791 "ILL_H15_D11.c"
}   /* End of mg8=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmg8:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(92,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component mg9 [93] */
  mccoordschange(mcposrmg9, mcrotrmg9,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component mg9 (without coords transformations) */
  mcJumpTrace_mg9:
  SIG_MESSAGE("mg9 (Trace)");
  mcDEBUG_COMP("mg9")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmg9
  STORE_NEUTRON(93,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[93]++;
  mcPCounter[93] += p;
  mcP2Counter[93] += p*p;
#define mccompcurname  mg9
#define mccompcurtype  Guide_gravity
#define mccompcurindex 93
#define GVars mccmg9_GVars
#define pTable mccmg9_pTable
{   /* Declarations of mg9=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg9_w1;
MCNUM h1 = mccmg9_h1;
MCNUM w2 = mccmg9_w2;
MCNUM h2 = mccmg9_h2;
MCNUM l = mccmg9_l;
MCNUM R0 = mccmg9_R0;
MCNUM Qc = mccmg9_Qc;
MCNUM alpha = mccmg9_alpha;
MCNUM m = mccmg9_m;
MCNUM W = mccmg9_W;
MCNUM nslit = mccmg9_nslit;
MCNUM d = mccmg9_d;
MCNUM mleft = mccmg9_mleft;
MCNUM mright = mccmg9_mright;
MCNUM mtop = mccmg9_mtop;
MCNUM mbottom = mccmg9_mbottom;
MCNUM nhslit = mccmg9_nhslit;
MCNUM G = mccmg9_G;
MCNUM aleft = mccmg9_aleft;
MCNUM aright = mccmg9_aright;
MCNUM atop = mccmg9_atop;
MCNUM abottom = mccmg9_abottom;
MCNUM wavy = mccmg9_wavy;
MCNUM wavy_z = mccmg9_wavy_z;
MCNUM wavy_tb = mccmg9_wavy_tb;
MCNUM wavy_lr = mccmg9_wavy_lr;
MCNUM chamfers = mccmg9_chamfers;
MCNUM chamfers_z = mccmg9_chamfers_z;
MCNUM chamfers_lr = mccmg9_chamfers_lr;
MCNUM chamfers_tb = mccmg9_chamfers_tb;
MCNUM nelements = mccmg9_nelements;
MCNUM nu = mccmg9_nu;
MCNUM phase = mccmg9_phase;
char* reflect = mccmg9_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 66104 "ILL_H15_D11.c"
}   /* End of mg9=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmg9:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(93,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component mg10 [94] */
  mccoordschange(mcposrmg10, mcrotrmg10,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component mg10 (without coords transformations) */
  mcJumpTrace_mg10:
  SIG_MESSAGE("mg10 (Trace)");
  mcDEBUG_COMP("mg10")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmg10
  STORE_NEUTRON(94,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[94]++;
  mcPCounter[94] += p;
  mcP2Counter[94] += p*p;
#define mccompcurname  mg10
#define mccompcurtype  Guide_gravity
#define mccompcurindex 94
#define GVars mccmg10_GVars
#define pTable mccmg10_pTable
{   /* Declarations of mg10=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg10_w1;
MCNUM h1 = mccmg10_h1;
MCNUM w2 = mccmg10_w2;
MCNUM h2 = mccmg10_h2;
MCNUM l = mccmg10_l;
MCNUM R0 = mccmg10_R0;
MCNUM Qc = mccmg10_Qc;
MCNUM alpha = mccmg10_alpha;
MCNUM m = mccmg10_m;
MCNUM W = mccmg10_W;
MCNUM nslit = mccmg10_nslit;
MCNUM d = mccmg10_d;
MCNUM mleft = mccmg10_mleft;
MCNUM mright = mccmg10_mright;
MCNUM mtop = mccmg10_mtop;
MCNUM mbottom = mccmg10_mbottom;
MCNUM nhslit = mccmg10_nhslit;
MCNUM G = mccmg10_G;
MCNUM aleft = mccmg10_aleft;
MCNUM aright = mccmg10_aright;
MCNUM atop = mccmg10_atop;
MCNUM abottom = mccmg10_abottom;
MCNUM wavy = mccmg10_wavy;
MCNUM wavy_z = mccmg10_wavy_z;
MCNUM wavy_tb = mccmg10_wavy_tb;
MCNUM wavy_lr = mccmg10_wavy_lr;
MCNUM chamfers = mccmg10_chamfers;
MCNUM chamfers_z = mccmg10_chamfers_z;
MCNUM chamfers_lr = mccmg10_chamfers_lr;
MCNUM chamfers_tb = mccmg10_chamfers_tb;
MCNUM nelements = mccmg10_nelements;
MCNUM nu = mccmg10_nu;
MCNUM phase = mccmg10_phase;
char* reflect = mccmg10_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 66417 "ILL_H15_D11.c"
}   /* End of mg10=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmg10:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(94,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component mg11 [95] */
  mccoordschange(mcposrmg11, mcrotrmg11,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component mg11 (without coords transformations) */
  mcJumpTrace_mg11:
  SIG_MESSAGE("mg11 (Trace)");
  mcDEBUG_COMP("mg11")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmg11
  STORE_NEUTRON(95,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[95]++;
  mcPCounter[95] += p;
  mcP2Counter[95] += p*p;
#define mccompcurname  mg11
#define mccompcurtype  Guide_gravity
#define mccompcurindex 95
#define GVars mccmg11_GVars
#define pTable mccmg11_pTable
{   /* Declarations of mg11=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg11_w1;
MCNUM h1 = mccmg11_h1;
MCNUM w2 = mccmg11_w2;
MCNUM h2 = mccmg11_h2;
MCNUM l = mccmg11_l;
MCNUM R0 = mccmg11_R0;
MCNUM Qc = mccmg11_Qc;
MCNUM alpha = mccmg11_alpha;
MCNUM m = mccmg11_m;
MCNUM W = mccmg11_W;
MCNUM nslit = mccmg11_nslit;
MCNUM d = mccmg11_d;
MCNUM mleft = mccmg11_mleft;
MCNUM mright = mccmg11_mright;
MCNUM mtop = mccmg11_mtop;
MCNUM mbottom = mccmg11_mbottom;
MCNUM nhslit = mccmg11_nhslit;
MCNUM G = mccmg11_G;
MCNUM aleft = mccmg11_aleft;
MCNUM aright = mccmg11_aright;
MCNUM atop = mccmg11_atop;
MCNUM abottom = mccmg11_abottom;
MCNUM wavy = mccmg11_wavy;
MCNUM wavy_z = mccmg11_wavy_z;
MCNUM wavy_tb = mccmg11_wavy_tb;
MCNUM wavy_lr = mccmg11_wavy_lr;
MCNUM chamfers = mccmg11_chamfers;
MCNUM chamfers_z = mccmg11_chamfers_z;
MCNUM chamfers_lr = mccmg11_chamfers_lr;
MCNUM chamfers_tb = mccmg11_chamfers_tb;
MCNUM nelements = mccmg11_nelements;
MCNUM nu = mccmg11_nu;
MCNUM phase = mccmg11_phase;
char* reflect = mccmg11_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 66730 "ILL_H15_D11.c"
}   /* End of mg11=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmg11:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(95,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component mg12 [96] */
  mccoordschange(mcposrmg12, mcrotrmg12,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component mg12 (without coords transformations) */
  mcJumpTrace_mg12:
  SIG_MESSAGE("mg12 (Trace)");
  mcDEBUG_COMP("mg12")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmg12
  STORE_NEUTRON(96,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[96]++;
  mcPCounter[96] += p;
  mcP2Counter[96] += p*p;
#define mccompcurname  mg12
#define mccompcurtype  Guide_gravity
#define mccompcurindex 96
#define GVars mccmg12_GVars
#define pTable mccmg12_pTable
{   /* Declarations of mg12=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg12_w1;
MCNUM h1 = mccmg12_h1;
MCNUM w2 = mccmg12_w2;
MCNUM h2 = mccmg12_h2;
MCNUM l = mccmg12_l;
MCNUM R0 = mccmg12_R0;
MCNUM Qc = mccmg12_Qc;
MCNUM alpha = mccmg12_alpha;
MCNUM m = mccmg12_m;
MCNUM W = mccmg12_W;
MCNUM nslit = mccmg12_nslit;
MCNUM d = mccmg12_d;
MCNUM mleft = mccmg12_mleft;
MCNUM mright = mccmg12_mright;
MCNUM mtop = mccmg12_mtop;
MCNUM mbottom = mccmg12_mbottom;
MCNUM nhslit = mccmg12_nhslit;
MCNUM G = mccmg12_G;
MCNUM aleft = mccmg12_aleft;
MCNUM aright = mccmg12_aright;
MCNUM atop = mccmg12_atop;
MCNUM abottom = mccmg12_abottom;
MCNUM wavy = mccmg12_wavy;
MCNUM wavy_z = mccmg12_wavy_z;
MCNUM wavy_tb = mccmg12_wavy_tb;
MCNUM wavy_lr = mccmg12_wavy_lr;
MCNUM chamfers = mccmg12_chamfers;
MCNUM chamfers_z = mccmg12_chamfers_z;
MCNUM chamfers_lr = mccmg12_chamfers_lr;
MCNUM chamfers_tb = mccmg12_chamfers_tb;
MCNUM nelements = mccmg12_nelements;
MCNUM nu = mccmg12_nu;
MCNUM phase = mccmg12_phase;
char* reflect = mccmg12_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 67043 "ILL_H15_D11.c"
}   /* End of mg12=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmg12:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(96,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component mg13 [97] */
  mccoordschange(mcposrmg13, mcrotrmg13,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component mg13 (without coords transformations) */
  mcJumpTrace_mg13:
  SIG_MESSAGE("mg13 (Trace)");
  mcDEBUG_COMP("mg13")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmg13
  STORE_NEUTRON(97,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[97]++;
  mcPCounter[97] += p;
  mcP2Counter[97] += p*p;
#define mccompcurname  mg13
#define mccompcurtype  Guide_gravity
#define mccompcurindex 97
#define GVars mccmg13_GVars
#define pTable mccmg13_pTable
{   /* Declarations of mg13=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg13_w1;
MCNUM h1 = mccmg13_h1;
MCNUM w2 = mccmg13_w2;
MCNUM h2 = mccmg13_h2;
MCNUM l = mccmg13_l;
MCNUM R0 = mccmg13_R0;
MCNUM Qc = mccmg13_Qc;
MCNUM alpha = mccmg13_alpha;
MCNUM m = mccmg13_m;
MCNUM W = mccmg13_W;
MCNUM nslit = mccmg13_nslit;
MCNUM d = mccmg13_d;
MCNUM mleft = mccmg13_mleft;
MCNUM mright = mccmg13_mright;
MCNUM mtop = mccmg13_mtop;
MCNUM mbottom = mccmg13_mbottom;
MCNUM nhslit = mccmg13_nhslit;
MCNUM G = mccmg13_G;
MCNUM aleft = mccmg13_aleft;
MCNUM aright = mccmg13_aright;
MCNUM atop = mccmg13_atop;
MCNUM abottom = mccmg13_abottom;
MCNUM wavy = mccmg13_wavy;
MCNUM wavy_z = mccmg13_wavy_z;
MCNUM wavy_tb = mccmg13_wavy_tb;
MCNUM wavy_lr = mccmg13_wavy_lr;
MCNUM chamfers = mccmg13_chamfers;
MCNUM chamfers_z = mccmg13_chamfers_z;
MCNUM chamfers_lr = mccmg13_chamfers_lr;
MCNUM chamfers_tb = mccmg13_chamfers_tb;
MCNUM nelements = mccmg13_nelements;
MCNUM nu = mccmg13_nu;
MCNUM phase = mccmg13_phase;
char* reflect = mccmg13_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 67356 "ILL_H15_D11.c"
}   /* End of mg13=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmg13:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(97,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component mg14 [98] */
  mccoordschange(mcposrmg14, mcrotrmg14,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component mg14 (without coords transformations) */
  mcJumpTrace_mg14:
  SIG_MESSAGE("mg14 (Trace)");
  mcDEBUG_COMP("mg14")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmg14
  STORE_NEUTRON(98,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[98]++;
  mcPCounter[98] += p;
  mcP2Counter[98] += p*p;
#define mccompcurname  mg14
#define mccompcurtype  Guide_gravity
#define mccompcurindex 98
#define GVars mccmg14_GVars
#define pTable mccmg14_pTable
{   /* Declarations of mg14=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg14_w1;
MCNUM h1 = mccmg14_h1;
MCNUM w2 = mccmg14_w2;
MCNUM h2 = mccmg14_h2;
MCNUM l = mccmg14_l;
MCNUM R0 = mccmg14_R0;
MCNUM Qc = mccmg14_Qc;
MCNUM alpha = mccmg14_alpha;
MCNUM m = mccmg14_m;
MCNUM W = mccmg14_W;
MCNUM nslit = mccmg14_nslit;
MCNUM d = mccmg14_d;
MCNUM mleft = mccmg14_mleft;
MCNUM mright = mccmg14_mright;
MCNUM mtop = mccmg14_mtop;
MCNUM mbottom = mccmg14_mbottom;
MCNUM nhslit = mccmg14_nhslit;
MCNUM G = mccmg14_G;
MCNUM aleft = mccmg14_aleft;
MCNUM aright = mccmg14_aright;
MCNUM atop = mccmg14_atop;
MCNUM abottom = mccmg14_abottom;
MCNUM wavy = mccmg14_wavy;
MCNUM wavy_z = mccmg14_wavy_z;
MCNUM wavy_tb = mccmg14_wavy_tb;
MCNUM wavy_lr = mccmg14_wavy_lr;
MCNUM chamfers = mccmg14_chamfers;
MCNUM chamfers_z = mccmg14_chamfers_z;
MCNUM chamfers_lr = mccmg14_chamfers_lr;
MCNUM chamfers_tb = mccmg14_chamfers_tb;
MCNUM nelements = mccmg14_nelements;
MCNUM nu = mccmg14_nu;
MCNUM phase = mccmg14_phase;
char* reflect = mccmg14_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 67669 "ILL_H15_D11.c"
}   /* End of mg14=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmg14:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(98,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component mg15 [99] */
  mccoordschange(mcposrmg15, mcrotrmg15,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component mg15 (without coords transformations) */
  mcJumpTrace_mg15:
  SIG_MESSAGE("mg15 (Trace)");
  mcDEBUG_COMP("mg15")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmg15
  STORE_NEUTRON(99,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[99]++;
  mcPCounter[99] += p;
  mcP2Counter[99] += p*p;
#define mccompcurname  mg15
#define mccompcurtype  Guide_gravity
#define mccompcurindex 99
#define GVars mccmg15_GVars
#define pTable mccmg15_pTable
{   /* Declarations of mg15=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg15_w1;
MCNUM h1 = mccmg15_h1;
MCNUM w2 = mccmg15_w2;
MCNUM h2 = mccmg15_h2;
MCNUM l = mccmg15_l;
MCNUM R0 = mccmg15_R0;
MCNUM Qc = mccmg15_Qc;
MCNUM alpha = mccmg15_alpha;
MCNUM m = mccmg15_m;
MCNUM W = mccmg15_W;
MCNUM nslit = mccmg15_nslit;
MCNUM d = mccmg15_d;
MCNUM mleft = mccmg15_mleft;
MCNUM mright = mccmg15_mright;
MCNUM mtop = mccmg15_mtop;
MCNUM mbottom = mccmg15_mbottom;
MCNUM nhslit = mccmg15_nhslit;
MCNUM G = mccmg15_G;
MCNUM aleft = mccmg15_aleft;
MCNUM aright = mccmg15_aright;
MCNUM atop = mccmg15_atop;
MCNUM abottom = mccmg15_abottom;
MCNUM wavy = mccmg15_wavy;
MCNUM wavy_z = mccmg15_wavy_z;
MCNUM wavy_tb = mccmg15_wavy_tb;
MCNUM wavy_lr = mccmg15_wavy_lr;
MCNUM chamfers = mccmg15_chamfers;
MCNUM chamfers_z = mccmg15_chamfers_z;
MCNUM chamfers_lr = mccmg15_chamfers_lr;
MCNUM chamfers_tb = mccmg15_chamfers_tb;
MCNUM nelements = mccmg15_nelements;
MCNUM nu = mccmg15_nu;
MCNUM phase = mccmg15_phase;
char* reflect = mccmg15_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 67982 "ILL_H15_D11.c"
}   /* End of mg15=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmg15:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(99,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component mg16 [100] */
  mccoordschange(mcposrmg16, mcrotrmg16,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component mg16 (without coords transformations) */
  mcJumpTrace_mg16:
  SIG_MESSAGE("mg16 (Trace)");
  mcDEBUG_COMP("mg16")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompmg16
  STORE_NEUTRON(100,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[100]++;
  mcPCounter[100] += p;
  mcP2Counter[100] += p*p;
#define mccompcurname  mg16
#define mccompcurtype  Guide_gravity
#define mccompcurindex 100
#define GVars mccmg16_GVars
#define pTable mccmg16_pTable
{   /* Declarations of mg16=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg16_w1;
MCNUM h1 = mccmg16_h1;
MCNUM w2 = mccmg16_w2;
MCNUM h2 = mccmg16_h2;
MCNUM l = mccmg16_l;
MCNUM R0 = mccmg16_R0;
MCNUM Qc = mccmg16_Qc;
MCNUM alpha = mccmg16_alpha;
MCNUM m = mccmg16_m;
MCNUM W = mccmg16_W;
MCNUM nslit = mccmg16_nslit;
MCNUM d = mccmg16_d;
MCNUM mleft = mccmg16_mleft;
MCNUM mright = mccmg16_mright;
MCNUM mtop = mccmg16_mtop;
MCNUM mbottom = mccmg16_mbottom;
MCNUM nhslit = mccmg16_nhslit;
MCNUM G = mccmg16_G;
MCNUM aleft = mccmg16_aleft;
MCNUM aright = mccmg16_aright;
MCNUM atop = mccmg16_atop;
MCNUM abottom = mccmg16_abottom;
MCNUM wavy = mccmg16_wavy;
MCNUM wavy_z = mccmg16_wavy_z;
MCNUM wavy_tb = mccmg16_wavy_tb;
MCNUM wavy_lr = mccmg16_wavy_lr;
MCNUM chamfers = mccmg16_chamfers;
MCNUM chamfers_z = mccmg16_chamfers_z;
MCNUM chamfers_lr = mccmg16_chamfers_lr;
MCNUM chamfers_tb = mccmg16_chamfers_tb;
MCNUM nelements = mccmg16_nelements;
MCNUM nu = mccmg16_nu;
MCNUM phase = mccmg16_phase;
char* reflect = mccmg16_reflect;
#line 392 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
  if (l > 0 && nelements > 0) {
    double B, C, dt;
    int    ret, bounces = 0, i=0;
    double this_width, this_height;
    double angle=0;

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      double dt=(-z+l/2)/vz; /* time shift to each center of slit package */
      angle=fmod(360*GVars.fc_freq*(t+dt)+GVars.fc_phase, 360); /* in deg */
      /* modify angle so that Z0 guide side is always in front of incoming neutron */
      if (angle > 90 && angle < 270) { angle -= 180; }
      angle *= DEG2RAD;
      rot_set_rotation(R, 0, -angle, 0); /* will rotate neutron instead of comp: negative side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

    for (i=0; i<7; GVars.N_reflection[i++] = 0);

    /* propagate to box input (with gravitation) in comp local coords */
    /* A = 0.5 n.g; B = n.v; C = n.(r-W); */
    /* 0=Z0 side: n=(0, 0, -l) ; W = (0, 0, 0) (at z=0, guide input)*/
    B = -l*vz; C = -l*z;

    ret = solve_2nd_order(&dt, NULL, GVars.A[0], B, C);
    if (ret==0) ABSORB;

    if (dt>0.0) PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz); else if (angle) ABSORB;
    GVars.N_reflection[6]++;

    this_width  = w1;
    this_height = h1;

  /* check if we are in the box input, else absorb */
    if (fabs(x) > this_width/2 || fabs(y) > this_height/2)
      ABSORB;
    else
    {
      double w_edge, w_adj; /* Channel displacement on X */
      double h_edge, h_adj; /* Channel displacement on Y */
      double w_chnum,h_chnum; /* channel indexes */

      SCATTER;

      /* X: Shift origin to center of channel hit (absorb if hit dividing walls) */
      x += w1/2.0;
      w_chnum = floor(x/(GVars.w1c+d));  /* 0= right side, nslit+1=left side  */
      w_edge  = w_chnum*(GVars.w1c+d);
      if(x - w_edge > GVars.w1c)
      {
        x -= w1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      w_adj = w_edge + (GVars.w1c)/2.0;
      x -= w_adj; w_adj -=  w1/2.0;

      /* Y: Shift origin to center of channel hit (absorb if hit dividing walls) */
      y += h1/2.0;
      h_chnum = floor(y/(GVars.h1c+d));  /* 0= lower side, nslit+1=upper side  */
      h_edge  = h_chnum*(GVars.h1c+d);
      if(y - h_edge > GVars.h1c)
      {
        y -= h1/2.0; /* Re-adjust origin */
        ABSORB;
      }
      h_adj = h_edge + (GVars.h1c)/2.0;
      y -= h_adj; h_adj -=  h1/2.0;

      /* neutron is now in the input window of the guide */
      /* do loops on reflections in the box */
      for(;;)
      {
        /* get intersections for all box sides */
        double q, nx,ny,nz;
        double this_length;
        int side=0;

        bounces++;
        /* now look for intersection with guide sides and exit */
        side = Gravity_guide_Trace(&dt, &GVars, x, y, z,
            vx, vy, vz, w_chnum, nslit, h_chnum, nhslit,
            &nx, &ny, &nz);

        /* only positive dt are valid */
        /* exit reflection loops if no intersection (neutron is after box) */
        if (side == 0 || dt <= 0)
          { if (GVars.warnings < 100)
              fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
            GVars.warnings++;
            x += w_adj; y += h_adj; ABSORB; } /* should never occur */

        /* propagate to dt */
        PROP_GRAV_DT(dt, GVars.gx, GVars.gy, GVars.gz);

        /* do reflection on speed for l/r/u/d sides */
        if (side == 5) /* neutron reaches end of guide: end loop and exit comp */
          { GVars.N_reflection[side]++; x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj; break; }
        /* else reflection on a guide wall */
        if(GVars.M[side] == 0 || Qc == 0 || R0 == 0)  /* walls are absorbing */
          { x += w_adj; y += h_adj; ABSORB; }
        /* handle chamfers */
        this_width = w1+(w2-w1)*z/l;
        this_height= h1+(h2-h1)*z/l;
        this_length= fmod(z, l/nelements);
        /* absorb on input/output of element parts */
        if (GVars.chamfer_z && (this_length<GVars.chamfer_z || this_length>l/nelements-GVars.chamfer_z))
        { x += w_adj; y += h_adj; ABSORB; }
        /* absorb on l/r/t/b sides */
        if (GVars.chamfer_lr && (side==1 || side==2) && (fabs(y+h_adj)>this_height/2-GVars.chamfer_lr))
        { x += w_adj; y += h_adj; ABSORB; }
        if (GVars.chamfer_tb && (side==3 || side==4) && (fabs(x+w_adj)>this_width/2- GVars.chamfer_tb))
        { x += w_adj; y += h_adj; ABSORB; }
        /* change/mirror velocity: h_f = v - n.2*n.v/|n|^2 */
        GVars.N_reflection[side]++; /* GVars.norm_n2 > 0 was checked at INIT */
        /* compute n.v using current values */
        B = scalar_prod(vx,vy,vz,nx,ny,nz);
        dt = 2*B/GVars.norm_n2[side]; /* 2*n.v/|n|^2 */
        vx -= nx*dt;
        vy -= ny*dt;
        vz -= nz*dt;

        /* compute q and modify neutron weight */
        /* scattering q=|n_i-n_f| = V2Q*|vf - v| = V2Q*2*n.v/|n| */
        q = 2*V2Q*fabs(B)/GVars.norm_n[side];

        if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
          TableReflecFunc(q, &pTable, &B);
        else {
          double par[] = {R0, Qc, GVars.Alpha[side], GVars.M[side], W};
          StdReflecFunc(q, par, &B);
        }
        if (B <= 0) { x += w_adj; y += h_adj; ABSORB; }
        else p *= B;
        x += w_adj; y += h_adj; SCATTER; x -= w_adj; y -= h_adj;
        GVars.N_reflection[0]++;
        /* go to the next reflection */
        if (bounces > 1000) ABSORB;
      } /* end for */
      x += w_adj; y += h_adj; /* Re-adjust origin after SCATTER */
    }

    if (GVars.fc_freq != 0 || GVars.fc_phase != 0) { /* rotate back neutron w/r to guide element */
      /* approximation of rotating straight Fermi Chopper */
      Coords   X = coords_set(x,y,z-l/2);  /* current coordinates of neutron in centered static frame */
      Rotation R;
      rot_set_rotation(R, 0, angle, 0); /* will rotate back neutron: positive side */
      /* apply rotation to centered coordinates */
      Coords   RX = rot_apply(R, X);
      coords_get(RX, &x, &y, &z);
      z = z+l/2;
      /* rotate speed */
      X  = coords_set(vx,vy,vz);
      RX = rot_apply(R, X);
      coords_get(RX, &vx, &vy, &vz);
    }

  } /* if l */
}
#line 68295 "ILL_H15_D11.c"
}   /* End of mg16=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompmg16:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(100,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component SampleF [101] */
  mccoordschange(mcposrSampleF, mcrotrSampleF,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component SampleF (without coords transformations) */
  mcJumpTrace_SampleF:
  SIG_MESSAGE("SampleF (Trace)");
  mcDEBUG_COMP("SampleF")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompSampleF
  STORE_NEUTRON(101,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[101]++;
  mcPCounter[101] += p;
  mcP2Counter[101] += p*p;
#define mccompcurname  SampleF
#define mccompcurtype  Monitor_nD
#define mccompcurindex 101
#define user1 mccSampleF_user1
#define user2 mccSampleF_user2
#define user3 mccSampleF_user3
#define DEFS mccSampleF_DEFS
#define Vars mccSampleF_Vars
#define detector mccSampleF_detector
#define offdata mccSampleF_offdata
{   /* Declarations of SampleF=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccSampleF_xwidth;
MCNUM yheight = mccSampleF_yheight;
MCNUM zdepth = mccSampleF_zdepth;
MCNUM xmin = mccSampleF_xmin;
MCNUM xmax = mccSampleF_xmax;
MCNUM ymin = mccSampleF_ymin;
MCNUM ymax = mccSampleF_ymax;
MCNUM zmin = mccSampleF_zmin;
MCNUM zmax = mccSampleF_zmax;
MCNUM bins = mccSampleF_bins;
MCNUM min = mccSampleF_min;
MCNUM max = mccSampleF_max;
MCNUM restore_neutron = mccSampleF_restore_neutron;
MCNUM radius = mccSampleF_radius;
char* options = mccSampleF_options;
char* filename = mccSampleF_filename;
char* geometry = mccSampleF_geometry;
char* username1 = mccSampleF_username1;
char* username2 = mccSampleF_username2;
char* username3 = mccSampleF_username3;
int nowritefile = mccSampleF_nowritefile;
#line 312 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  double  XY=0;
  double  t0 = 0;
  double  t1 = 0;
  double  pp;
  int     intersect   = 0;
  char    Flag_Restore = 0;

  if (user1 != FLT_MAX) Vars.UserVariable1 = user1;
  if (user2 != FLT_MAX) Vars.UserVariable2 = user2;
  if (user3 != FLT_MAX) Vars.UserVariable3 = user3;

  /* this is done automatically
    STORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  */

  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    /* determine intersections with object */
    intersect = off_intersect_all(&t0, &t1, NULL, NULL,
       x,y,z, vx, vy, vz, &offdata );
    if (Vars.Flag_mantid) {
      if(intersect) {
        Vars.OFF_polyidx=(offdata.intersects[offdata.nextintersect]).index;
      } else {
        Vars.OFF_polyidx=-1;
      }
    }
  }
  else if ( (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
            || (abs(Vars.Flag_Shape) == DEFS.SHAPE_DISK) ) /* square xy or disk xy */
  {
    // propagate to xy plane and find intersection
    // make sure the event is recoverable afterwards
    t0 = t;
    ALLOW_BACKPROP;
    PROP_Z0;
    if ( (t>=t0) && (z==0.0) ) // forward propagation to xy plane was successful
    {
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
      {
        // square xy
        intersect = (x>=Vars.mxmin && x<=Vars.mxmax && y>=Vars.mymin && y<=Vars.mymax);
      }
      else
      {
        // disk xy
        intersect = (SQR(x) + SQR(y)) <= SQR(Vars.Sphere_Radius);
      }
    }
    else
    {
      intersect=0;
    }
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) /* sphere */
  {
    intersect = sphere_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius);
  /*      intersect = (intersect && t0 > 0); */
  }
  else if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)) /* cylinder */
  {
    intersect = cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius, Vars.Cylinder_Height);
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) /* box */
  {
    intersect = box_intersect(&t0, &t1, x, y, z, vx, vy, vz,
                              fabs(Vars.mxmax-Vars.mxmin), fabs(Vars.mymax-Vars.mymin), fabs(Vars.mzmax-Vars.mzmin));
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_PREVIOUS) /* previous comp */
  { intersect = 1; }

  if (intersect)
  {
    if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND)
     || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)
     || (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) )
    {
      /* check if we have to remove the top/bottom with BANANA shape */
      if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA) && (intersect != 1)) {
        double y0,y1;
        /* propagate to intersection point as temporary variable to check top/bottom */
        y0 = y+t0*vy;
        y1 = y+t1*vy;
        if (fabs(y0) >= Vars.Cylinder_Height/2*0.99) t0 = t1;
        if (fabs(y1) >= Vars.Cylinder_Height/2*0.99) t1 = t0;
      }
      if (t0 < 0 && t1 > 0)
        t0 = t;  /* neutron was already inside ! */
      if (t1 < 0 && t0 > 0) /* neutron exit before entering !! */
        t1 = t;
      /* t0 is now time of incoming intersection with the detection area */
      if ((Vars.Flag_Shape < 0) && (t1 > 0))
        PROP_DT(t1); /* t1 outgoing beam */
      else
        PROP_DT(t0); /* t0 incoming beam */
      /* Final test if we are on lid / bottom of banana/sphere */
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA || abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) {
        if (fabs(y) >= Vars.Cylinder_Height/2*0.99) {
          intersect=0;
          Flag_Restore=1;
        }
      }
    }
  }

  if (intersect)
  {
    /* Now get the data to monitor: current or keep from PreMonitor */
    if (Vars.Flag_UsePreMonitor != 1)
    {
      Vars.cp  = p;
      Vars.cx  = x;
      Vars.cvx = vx;
      Vars.csx = sx;
      Vars.cy  = y;
      Vars.cvy = vy;
      Vars.csy = sy;
      Vars.cz  = z;
      Vars.cvz = vz;
      Vars.csz = sz;
      Vars.ct  = t;
    }

    if ((Vars.He3_pressure > 0) && (t1 != t0) && ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX)))
    {
      XY = exp(-7.417*Vars.He3_pressure*fabs(t1-t0)*2*PI*K2V);
      /* will monitor the absorbed part */
      Vars.cp *= 1-XY;
      /* and modify the neutron weight after monitor, only remains 1-p_detect */
      p *= XY;
    }

    if (Vars.Flag_capture)
    {
      XY = sqrt(Vars.cvx*Vars.cvx+Vars.cvy*Vars.cvy+Vars.cvz*Vars.cvz);
      XY *= V2K;
      if (XY != 0) XY = 2*PI/XY; /* lambda. lambda(2200 m/2) = 1.7985 Angs  */
      Vars.cp *= XY/1.7985;
    }

    pp = Monitor_nD_Trace(&DEFS, &Vars);
    if (pp==0.0)
    { ABSORB;
    }
    else if(pp==1)
    {
      SCATTER;
    }

    if (Vars.Flag_parallel) /* back to neutron state before detection */
      Flag_Restore = 1;
  } /* end if intersection */
  else {
    if (Vars.Flag_Absorb && !Vars.Flag_parallel)
    {
      // restore neutron ray before absorbing for correct mcdisplay
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
      ABSORB;
    }
    else Flag_Restore = 1;  /* no intersection, back to previous state */
  }

  if (Flag_Restore)
  {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 68600 "ILL_H15_D11.c"
}   /* End of SampleF=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompSampleF:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(101,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  /* TRACE Component SampleC [102] */
  mccoordschange(mcposrSampleC, mcrotrSampleC,
    &mcnlx,
    &mcnly,
    &mcnlz,
    &mcnlvx,
    &mcnlvy,
    &mcnlvz,
    &mcnlsx,
    &mcnlsy,
    &mcnlsz);
  /* define label inside component SampleC (without coords transformations) */
  mcJumpTrace_SampleC:
  SIG_MESSAGE("SampleC (Trace)");
  mcDEBUG_COMP("SampleC")
  mcDEBUG_STATE(
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp)
#define x mcnlx
#define y mcnly
#define z mcnlz
#define vx mcnlvx
#define vy mcnlvy
#define vz mcnlvz
#define t mcnlt
#define sx mcnlsx
#define sy mcnlsy
#define sz mcnlsz
#define p mcnlp

#define mcabsorbComp mcabsorbCompSampleC
  STORE_NEUTRON(102,
    mcnlx,
    mcnly,
    mcnlz,
    mcnlvx,
    mcnlvy,
    mcnlvz,
    mcnlt,
    mcnlsx,
    mcnlsy,
    mcnlsz,
    mcnlp);
  mcScattered=0;
  mcRestore=0;
  mcNCounter[102]++;
  mcPCounter[102] += p;
  mcP2Counter[102] += p*p;
#define mccompcurname  SampleC
#define mccompcurtype  Monitor_nD
#define mccompcurindex 102
#define user1 mccSampleC_user1
#define user2 mccSampleC_user2
#define user3 mccSampleC_user3
#define DEFS mccSampleC_DEFS
#define Vars mccSampleC_Vars
#define detector mccSampleC_detector
#define offdata mccSampleC_offdata
{   /* Declarations of SampleC=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccSampleC_xwidth;
MCNUM yheight = mccSampleC_yheight;
MCNUM zdepth = mccSampleC_zdepth;
MCNUM xmin = mccSampleC_xmin;
MCNUM xmax = mccSampleC_xmax;
MCNUM ymin = mccSampleC_ymin;
MCNUM ymax = mccSampleC_ymax;
MCNUM zmin = mccSampleC_zmin;
MCNUM zmax = mccSampleC_zmax;
MCNUM bins = mccSampleC_bins;
MCNUM min = mccSampleC_min;
MCNUM max = mccSampleC_max;
MCNUM restore_neutron = mccSampleC_restore_neutron;
MCNUM radius = mccSampleC_radius;
char* options = mccSampleC_options;
char* filename = mccSampleC_filename;
char* geometry = mccSampleC_geometry;
char* username1 = mccSampleC_username1;
char* username2 = mccSampleC_username2;
char* username3 = mccSampleC_username3;
int nowritefile = mccSampleC_nowritefile;
#line 312 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  double  XY=0;
  double  t0 = 0;
  double  t1 = 0;
  double  pp;
  int     intersect   = 0;
  char    Flag_Restore = 0;

  if (user1 != FLT_MAX) Vars.UserVariable1 = user1;
  if (user2 != FLT_MAX) Vars.UserVariable2 = user2;
  if (user3 != FLT_MAX) Vars.UserVariable3 = user3;

  /* this is done automatically
    STORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  */

  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    /* determine intersections with object */
    intersect = off_intersect_all(&t0, &t1, NULL, NULL,
       x,y,z, vx, vy, vz, &offdata );
    if (Vars.Flag_mantid) {
      if(intersect) {
        Vars.OFF_polyidx=(offdata.intersects[offdata.nextintersect]).index;
      } else {
        Vars.OFF_polyidx=-1;
      }
    }
  }
  else if ( (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
            || (abs(Vars.Flag_Shape) == DEFS.SHAPE_DISK) ) /* square xy or disk xy */
  {
    // propagate to xy plane and find intersection
    // make sure the event is recoverable afterwards
    t0 = t;
    ALLOW_BACKPROP;
    PROP_Z0;
    if ( (t>=t0) && (z==0.0) ) // forward propagation to xy plane was successful
    {
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SQUARE)
      {
        // square xy
        intersect = (x>=Vars.mxmin && x<=Vars.mxmax && y>=Vars.mymin && y<=Vars.mymax);
      }
      else
      {
        // disk xy
        intersect = (SQR(x) + SQR(y)) <= SQR(Vars.Sphere_Radius);
      }
    }
    else
    {
      intersect=0;
    }
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) /* sphere */
  {
    intersect = sphere_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius);
  /*      intersect = (intersect && t0 > 0); */
  }
  else if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)) /* cylinder */
  {
    intersect = cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, Vars.Sphere_Radius, Vars.Cylinder_Height);
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) /* box */
  {
    intersect = box_intersect(&t0, &t1, x, y, z, vx, vy, vz,
                              fabs(Vars.mxmax-Vars.mxmin), fabs(Vars.mymax-Vars.mymin), fabs(Vars.mzmax-Vars.mzmin));
  }
  else if (abs(Vars.Flag_Shape) == DEFS.SHAPE_PREVIOUS) /* previous comp */
  { intersect = 1; }

  if (intersect)
  {
    if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND)
     || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA)
     || (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL")) )
    {
      /* check if we have to remove the top/bottom with BANANA shape */
      if ((abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA) && (intersect != 1)) {
        double y0,y1;
        /* propagate to intersection point as temporary variable to check top/bottom */
        y0 = y+t0*vy;
        y1 = y+t1*vy;
        if (fabs(y0) >= Vars.Cylinder_Height/2*0.99) t0 = t1;
        if (fabs(y1) >= Vars.Cylinder_Height/2*0.99) t1 = t0;
      }
      if (t0 < 0 && t1 > 0)
        t0 = t;  /* neutron was already inside ! */
      if (t1 < 0 && t0 > 0) /* neutron exit before entering !! */
        t1 = t;
      /* t0 is now time of incoming intersection with the detection area */
      if ((Vars.Flag_Shape < 0) && (t1 > 0))
        PROP_DT(t1); /* t1 outgoing beam */
      else
        PROP_DT(t0); /* t0 incoming beam */
      /* Final test if we are on lid / bottom of banana/sphere */
      if (abs(Vars.Flag_Shape) == DEFS.SHAPE_BANANA || abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) {
        if (fabs(y) >= Vars.Cylinder_Height/2*0.99) {
          intersect=0;
          Flag_Restore=1;
        }
      }
    }
  }

  if (intersect)
  {
    /* Now get the data to monitor: current or keep from PreMonitor */
    if (Vars.Flag_UsePreMonitor != 1)
    {
      Vars.cp  = p;
      Vars.cx  = x;
      Vars.cvx = vx;
      Vars.csx = sx;
      Vars.cy  = y;
      Vars.cvy = vy;
      Vars.csy = sy;
      Vars.cz  = z;
      Vars.cvz = vz;
      Vars.csz = sz;
      Vars.ct  = t;
    }

    if ((Vars.He3_pressure > 0) && (t1 != t0) && ((abs(Vars.Flag_Shape) == DEFS.SHAPE_SPHERE) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_CYLIND) || (abs(Vars.Flag_Shape) == DEFS.SHAPE_BOX)))
    {
      XY = exp(-7.417*Vars.He3_pressure*fabs(t1-t0)*2*PI*K2V);
      /* will monitor the absorbed part */
      Vars.cp *= 1-XY;
      /* and modify the neutron weight after monitor, only remains 1-p_detect */
      p *= XY;
    }

    if (Vars.Flag_capture)
    {
      XY = sqrt(Vars.cvx*Vars.cvx+Vars.cvy*Vars.cvy+Vars.cvz*Vars.cvz);
      XY *= V2K;
      if (XY != 0) XY = 2*PI/XY; /* lambda. lambda(2200 m/2) = 1.7985 Angs  */
      Vars.cp *= XY/1.7985;
    }

    pp = Monitor_nD_Trace(&DEFS, &Vars);
    if (pp==0.0)
    { ABSORB;
    }
    else if(pp==1)
    {
      SCATTER;
    }

    if (Vars.Flag_parallel) /* back to neutron state before detection */
      Flag_Restore = 1;
  } /* end if intersection */
  else {
    if (Vars.Flag_Absorb && !Vars.Flag_parallel)
    {
      // restore neutron ray before absorbing for correct mcdisplay
      RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
      ABSORB;
    }
    else Flag_Restore = 1;  /* no intersection, back to previous state */
  }

  if (Flag_Restore)
  {
    RESTORE_NEUTRON(INDEX_CURRENT_COMP, x, y, z, vx, vy, vz, t, sx, sy, sz, p);
  }
}
#line 68910 "ILL_H15_D11.c"
}   /* End of SampleC=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex
  /* Label for restoring  neutron */
  mcabsorbCompSampleC:
  if (RESTORE) /* restore if needed */
  { RESTORE_NEUTRON(102,
      mcnlx,
      mcnly,
      mcnlz,
      mcnlvx,
      mcnlvy,
      mcnlvz,
      mcnlt,
      mcnlsx,
      mcnlsy,
      mcnlsz,
      mcnlp); }
#undef mcabsorbComp
#undef p
#undef sz
#undef sy
#undef sx
#undef t
#undef vz
#undef vy
#undef vx
#undef z
#undef y
#undef x
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)

  mcabsorbAll:
  mcDEBUG_LEAVE()
  mcDEBUG_STATE(
mcnlx,
mcnly,
mcnlz,
mcnlvx,
mcnlvy,
mcnlvz,
mcnlt,
mcnlsx,
mcnlsy,
mcnlsz,
mcnlp)
  /* Copy neutron state to global variables. */
  mcnx = mcnlx;
  mcny = mcnly;
  mcnz = mcnlz;
  mcnvx = mcnlvx;
  mcnvy = mcnlvy;
  mcnvz = mcnlvz;
  mcnt = mcnlt;
  mcnsx = mcnlsx;
  mcnsy = mcnlsy;
  mcnsz = mcnlsz;
  mcnp = mcnlp;

} /* end trace */

void mcsave(FILE *handle) {
  if (!handle) mcsiminfo_init(NULL);
  /* User component SAVE code. */

  /* User SAVE code for component 'PG'. */
  SIG_MESSAGE("PG (Save)");
#define mccompcurname  PG
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccPG_IntermediateCnts
#define StartTime mccPG_StartTime
#define EndTime mccPG_EndTime
#define CurrentTime mccPG_CurrentTime
{   /* Declarations of PG=Progress_bar() SETTING parameters. */
char* profile = mccPG_profile;
MCNUM percent = mccPG_percent;
MCNUM flag_save = mccPG_flag_save;
MCNUM minutes = mccPG_minutes;
#line 115 "/usr/share/mcstas/2.6rc1/misc/Progress_bar.comp"
{
  MPI_MASTER(fprintf(stdout, "\nSave [%s]\n", mcinstrument_name););
  if (profile && strlen(profile) && strcmp(profile,"NULL") && strcmp(profile,"0")) {
    char filename[256];
    if (!strlen(profile) || !strcmp(profile,"NULL") || !strcmp(profile,"0")) strcpy(filename, mcinstrument_name);
    else strcpy(filename, profile);
    DETECTOR_OUT_1D(
        "Intensity profiler",
        "Component index [1]",
        "Intensity",
        "prof", 1, mcNUMCOMP, mcNUMCOMP-1,
        &mcNCounter[1],&mcPCounter[1],&mcP2Counter[1],
        filename);

  }
}
#line 69026 "ILL_H15_D11.c"
}   /* End of PG=Progress_bar() SETTING parameter declarations. */
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'PSD_VTE'. */
  SIG_MESSAGE("PSD_VTE (Save)");
#define mccompcurname  PSD_VTE
#define mccompcurtype  Monitor_nD
#define mccompcurindex 35
#define user1 mccPSD_VTE_user1
#define user2 mccPSD_VTE_user2
#define user3 mccPSD_VTE_user3
#define DEFS mccPSD_VTE_DEFS
#define Vars mccPSD_VTE_Vars
#define detector mccPSD_VTE_detector
#define offdata mccPSD_VTE_offdata
{   /* Declarations of PSD_VTE=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccPSD_VTE_xwidth;
MCNUM yheight = mccPSD_VTE_yheight;
MCNUM zdepth = mccPSD_VTE_zdepth;
MCNUM xmin = mccPSD_VTE_xmin;
MCNUM xmax = mccPSD_VTE_xmax;
MCNUM ymin = mccPSD_VTE_ymin;
MCNUM ymax = mccPSD_VTE_ymax;
MCNUM zmin = mccPSD_VTE_zmin;
MCNUM zmax = mccPSD_VTE_zmax;
MCNUM bins = mccPSD_VTE_bins;
MCNUM min = mccPSD_VTE_min;
MCNUM max = mccPSD_VTE_max;
MCNUM restore_neutron = mccPSD_VTE_restore_neutron;
MCNUM radius = mccPSD_VTE_radius;
char* options = mccPSD_VTE_options;
char* filename = mccPSD_VTE_filename;
char* geometry = mccPSD_VTE_geometry;
char* username1 = mccPSD_VTE_username1;
char* username2 = mccPSD_VTE_username2;
char* username3 = mccPSD_VTE_username3;
int nowritefile = mccPSD_VTE_nowritefile;
#line 482 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  /* save results, but do not free pointers */
  if (!nowritefile) {
    detector = Monitor_nD_Save(&DEFS, &Vars);
  }
}
#line 69077 "ILL_H15_D11.c"
}   /* End of PSD_VTE=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'PSD_IN6'. */
  SIG_MESSAGE("PSD_IN6 (Save)");
#define mccompcurname  PSD_IN6
#define mccompcurtype  Monitor_nD
#define mccompcurindex 61
#define user1 mccPSD_IN6_user1
#define user2 mccPSD_IN6_user2
#define user3 mccPSD_IN6_user3
#define DEFS mccPSD_IN6_DEFS
#define Vars mccPSD_IN6_Vars
#define detector mccPSD_IN6_detector
#define offdata mccPSD_IN6_offdata
{   /* Declarations of PSD_IN6=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccPSD_IN6_xwidth;
MCNUM yheight = mccPSD_IN6_yheight;
MCNUM zdepth = mccPSD_IN6_zdepth;
MCNUM xmin = mccPSD_IN6_xmin;
MCNUM xmax = mccPSD_IN6_xmax;
MCNUM ymin = mccPSD_IN6_ymin;
MCNUM ymax = mccPSD_IN6_ymax;
MCNUM zmin = mccPSD_IN6_zmin;
MCNUM zmax = mccPSD_IN6_zmax;
MCNUM bins = mccPSD_IN6_bins;
MCNUM min = mccPSD_IN6_min;
MCNUM max = mccPSD_IN6_max;
MCNUM restore_neutron = mccPSD_IN6_restore_neutron;
MCNUM radius = mccPSD_IN6_radius;
char* options = mccPSD_IN6_options;
char* filename = mccPSD_IN6_filename;
char* geometry = mccPSD_IN6_geometry;
char* username1 = mccPSD_IN6_username1;
char* username2 = mccPSD_IN6_username2;
char* username3 = mccPSD_IN6_username3;
int nowritefile = mccPSD_IN6_nowritefile;
#line 482 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  /* save results, but do not free pointers */
  if (!nowritefile) {
    detector = Monitor_nD_Save(&DEFS, &Vars);
  }
}
#line 69131 "ILL_H15_D11.c"
}   /* End of PSD_IN6=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'PSD_D7'. */
  SIG_MESSAGE("PSD_D7 (Save)");
#define mccompcurname  PSD_D7
#define mccompcurtype  Monitor_nD
#define mccompcurindex 70
#define user1 mccPSD_D7_user1
#define user2 mccPSD_D7_user2
#define user3 mccPSD_D7_user3
#define DEFS mccPSD_D7_DEFS
#define Vars mccPSD_D7_Vars
#define detector mccPSD_D7_detector
#define offdata mccPSD_D7_offdata
{   /* Declarations of PSD_D7=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccPSD_D7_xwidth;
MCNUM yheight = mccPSD_D7_yheight;
MCNUM zdepth = mccPSD_D7_zdepth;
MCNUM xmin = mccPSD_D7_xmin;
MCNUM xmax = mccPSD_D7_xmax;
MCNUM ymin = mccPSD_D7_ymin;
MCNUM ymax = mccPSD_D7_ymax;
MCNUM zmin = mccPSD_D7_zmin;
MCNUM zmax = mccPSD_D7_zmax;
MCNUM bins = mccPSD_D7_bins;
MCNUM min = mccPSD_D7_min;
MCNUM max = mccPSD_D7_max;
MCNUM restore_neutron = mccPSD_D7_restore_neutron;
MCNUM radius = mccPSD_D7_radius;
char* options = mccPSD_D7_options;
char* filename = mccPSD_D7_filename;
char* geometry = mccPSD_D7_geometry;
char* username1 = mccPSD_D7_username1;
char* username2 = mccPSD_D7_username2;
char* username3 = mccPSD_D7_username3;
int nowritefile = mccPSD_D7_nowritefile;
#line 482 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  /* save results, but do not free pointers */
  if (!nowritefile) {
    detector = Monitor_nD_Save(&DEFS, &Vars);
  }
}
#line 69185 "ILL_H15_D11.c"
}   /* End of PSD_D7=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Mon_D11_In'. */
  SIG_MESSAGE("Mon_D11_In (Save)");
#define mccompcurname  Mon_D11_In
#define mccompcurtype  Monitor_nD
#define mccompcurindex 76
#define user1 mccMon_D11_In_user1
#define user2 mccMon_D11_In_user2
#define user3 mccMon_D11_In_user3
#define DEFS mccMon_D11_In_DEFS
#define Vars mccMon_D11_In_Vars
#define detector mccMon_D11_In_detector
#define offdata mccMon_D11_In_offdata
{   /* Declarations of Mon_D11_In=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccMon_D11_In_xwidth;
MCNUM yheight = mccMon_D11_In_yheight;
MCNUM zdepth = mccMon_D11_In_zdepth;
MCNUM xmin = mccMon_D11_In_xmin;
MCNUM xmax = mccMon_D11_In_xmax;
MCNUM ymin = mccMon_D11_In_ymin;
MCNUM ymax = mccMon_D11_In_ymax;
MCNUM zmin = mccMon_D11_In_zmin;
MCNUM zmax = mccMon_D11_In_zmax;
MCNUM bins = mccMon_D11_In_bins;
MCNUM min = mccMon_D11_In_min;
MCNUM max = mccMon_D11_In_max;
MCNUM restore_neutron = mccMon_D11_In_restore_neutron;
MCNUM radius = mccMon_D11_In_radius;
char* options = mccMon_D11_In_options;
char* filename = mccMon_D11_In_filename;
char* geometry = mccMon_D11_In_geometry;
char* username1 = mccMon_D11_In_username1;
char* username2 = mccMon_D11_In_username2;
char* username3 = mccMon_D11_In_username3;
int nowritefile = mccMon_D11_In_nowritefile;
#line 482 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  /* save results, but do not free pointers */
  if (!nowritefile) {
    detector = Monitor_nD_Save(&DEFS, &Vars);
  }
}
#line 69239 "ILL_H15_D11.c"
}   /* End of Mon_D11_In=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'Mon_D11_Out'. */
  SIG_MESSAGE("Mon_D11_Out (Save)");
#define mccompcurname  Mon_D11_Out
#define mccompcurtype  Monitor_nD
#define mccompcurindex 81
#define user1 mccMon_D11_Out_user1
#define user2 mccMon_D11_Out_user2
#define user3 mccMon_D11_Out_user3
#define DEFS mccMon_D11_Out_DEFS
#define Vars mccMon_D11_Out_Vars
#define detector mccMon_D11_Out_detector
#define offdata mccMon_D11_Out_offdata
{   /* Declarations of Mon_D11_Out=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccMon_D11_Out_xwidth;
MCNUM yheight = mccMon_D11_Out_yheight;
MCNUM zdepth = mccMon_D11_Out_zdepth;
MCNUM xmin = mccMon_D11_Out_xmin;
MCNUM xmax = mccMon_D11_Out_xmax;
MCNUM ymin = mccMon_D11_Out_ymin;
MCNUM ymax = mccMon_D11_Out_ymax;
MCNUM zmin = mccMon_D11_Out_zmin;
MCNUM zmax = mccMon_D11_Out_zmax;
MCNUM bins = mccMon_D11_Out_bins;
MCNUM min = mccMon_D11_Out_min;
MCNUM max = mccMon_D11_Out_max;
MCNUM restore_neutron = mccMon_D11_Out_restore_neutron;
MCNUM radius = mccMon_D11_Out_radius;
char* options = mccMon_D11_Out_options;
char* filename = mccMon_D11_Out_filename;
char* geometry = mccMon_D11_Out_geometry;
char* username1 = mccMon_D11_Out_username1;
char* username2 = mccMon_D11_Out_username2;
char* username3 = mccMon_D11_Out_username3;
int nowritefile = mccMon_D11_Out_nowritefile;
#line 482 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  /* save results, but do not free pointers */
  if (!nowritefile) {
    detector = Monitor_nD_Save(&DEFS, &Vars);
  }
}
#line 69293 "ILL_H15_D11.c"
}   /* End of Mon_D11_Out=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'SampleF'. */
  SIG_MESSAGE("SampleF (Save)");
#define mccompcurname  SampleF
#define mccompcurtype  Monitor_nD
#define mccompcurindex 101
#define user1 mccSampleF_user1
#define user2 mccSampleF_user2
#define user3 mccSampleF_user3
#define DEFS mccSampleF_DEFS
#define Vars mccSampleF_Vars
#define detector mccSampleF_detector
#define offdata mccSampleF_offdata
{   /* Declarations of SampleF=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccSampleF_xwidth;
MCNUM yheight = mccSampleF_yheight;
MCNUM zdepth = mccSampleF_zdepth;
MCNUM xmin = mccSampleF_xmin;
MCNUM xmax = mccSampleF_xmax;
MCNUM ymin = mccSampleF_ymin;
MCNUM ymax = mccSampleF_ymax;
MCNUM zmin = mccSampleF_zmin;
MCNUM zmax = mccSampleF_zmax;
MCNUM bins = mccSampleF_bins;
MCNUM min = mccSampleF_min;
MCNUM max = mccSampleF_max;
MCNUM restore_neutron = mccSampleF_restore_neutron;
MCNUM radius = mccSampleF_radius;
char* options = mccSampleF_options;
char* filename = mccSampleF_filename;
char* geometry = mccSampleF_geometry;
char* username1 = mccSampleF_username1;
char* username2 = mccSampleF_username2;
char* username3 = mccSampleF_username3;
int nowritefile = mccSampleF_nowritefile;
#line 482 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  /* save results, but do not free pointers */
  if (!nowritefile) {
    detector = Monitor_nD_Save(&DEFS, &Vars);
  }
}
#line 69347 "ILL_H15_D11.c"
}   /* End of SampleF=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* User SAVE code for component 'SampleC'. */
  SIG_MESSAGE("SampleC (Save)");
#define mccompcurname  SampleC
#define mccompcurtype  Monitor_nD
#define mccompcurindex 102
#define user1 mccSampleC_user1
#define user2 mccSampleC_user2
#define user3 mccSampleC_user3
#define DEFS mccSampleC_DEFS
#define Vars mccSampleC_Vars
#define detector mccSampleC_detector
#define offdata mccSampleC_offdata
{   /* Declarations of SampleC=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccSampleC_xwidth;
MCNUM yheight = mccSampleC_yheight;
MCNUM zdepth = mccSampleC_zdepth;
MCNUM xmin = mccSampleC_xmin;
MCNUM xmax = mccSampleC_xmax;
MCNUM ymin = mccSampleC_ymin;
MCNUM ymax = mccSampleC_ymax;
MCNUM zmin = mccSampleC_zmin;
MCNUM zmax = mccSampleC_zmax;
MCNUM bins = mccSampleC_bins;
MCNUM min = mccSampleC_min;
MCNUM max = mccSampleC_max;
MCNUM restore_neutron = mccSampleC_restore_neutron;
MCNUM radius = mccSampleC_radius;
char* options = mccSampleC_options;
char* filename = mccSampleC_filename;
char* geometry = mccSampleC_geometry;
char* username1 = mccSampleC_username1;
char* username2 = mccSampleC_username2;
char* username3 = mccSampleC_username3;
int nowritefile = mccSampleC_nowritefile;
#line 482 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  /* save results, but do not free pointers */
  if (!nowritefile) {
    detector = Monitor_nD_Save(&DEFS, &Vars);
  }
}
#line 69401 "ILL_H15_D11.c"
}   /* End of SampleC=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  if (!handle) mcsiminfo_close(); 
} /* end save */
void mcfinally(void) {
  /* User component FINALLY code. */
  mcsiminfo_init(NULL);
  mcsave(mcsiminfo_file); /* save data when simulation ends */

  /* User FINALLY code for component 'PG'. */
  SIG_MESSAGE("PG (Finally)");
#define mccompcurname  PG
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccPG_IntermediateCnts
#define StartTime mccPG_StartTime
#define EndTime mccPG_EndTime
#define CurrentTime mccPG_CurrentTime
{   /* Declarations of PG=Progress_bar() SETTING parameters. */
char* profile = mccPG_profile;
MCNUM percent = mccPG_percent;
MCNUM flag_save = mccPG_flag_save;
MCNUM minutes = mccPG_minutes;
#line 133 "/usr/share/mcstas/2.6rc1/misc/Progress_bar.comp"
{
  time_t NowTime;
  time(&NowTime);
  fprintf(stdout, "\nFinally [%s: %s]. Time: ", mcinstrument_name, mcdirname ? mcdirname : ".");
  if (difftime(NowTime,StartTime) < 60.0)
    fprintf(stdout, "%g [s] ", difftime(NowTime,StartTime));
  else if (difftime(NowTime,StartTime) > 3600.0)
    fprintf(stdout, "%g [h] ", difftime(NowTime,StartTime)/3660.0);
  else
    fprintf(stdout, "%g [min] ", difftime(NowTime,StartTime)/60.0);
  fprintf(stdout, "\n");
}
#line 69448 "ILL_H15_D11.c"
}   /* End of PG=Progress_bar() SETTING parameter declarations. */
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[1]) fprintf(stderr, "Warning: No neutron could reach Component[1] PG\n");
    if (mcAbsorbProp[1]) fprintf(stderr, "Warning: %g events were removed in Component[1] PG=Progress_bar()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[1]);
  /* User FINALLY code for component 'Source'. */
  SIG_MESSAGE("Source (Finally)");
#define mccompcurname  Source
#define mccompcurtype  Source_gen
#define mccompcurindex 2
#define p_in mccSource_p_in
#define lambda1 mccSource_lambda1
#define lambda2 mccSource_lambda2
#define lambda3 mccSource_lambda3
#define pTable mccSource_pTable
#define pTable_x mccSource_pTable_x
#define pTable_y mccSource_pTable_y
#define pTable_xmin mccSource_pTable_xmin
#define pTable_xmax mccSource_pTable_xmax
#define pTable_xsum mccSource_pTable_xsum
#define pTable_ymin mccSource_pTable_ymin
#define pTable_ymax mccSource_pTable_ymax
#define pTable_ysum mccSource_pTable_ysum
#define pTable_dxmin mccSource_pTable_dxmin
#define pTable_dxmax mccSource_pTable_dxmax
#define pTable_dymin mccSource_pTable_dymin
#define pTable_dymax mccSource_pTable_dymax
{   /* Declarations of Source=Source_gen() SETTING parameters. */
char* flux_file = mccSource_flux_file;
char* xdiv_file = mccSource_xdiv_file;
char* ydiv_file = mccSource_ydiv_file;
MCNUM radius = mccSource_radius;
MCNUM dist = mccSource_dist;
MCNUM focus_xw = mccSource_focus_xw;
MCNUM focus_yh = mccSource_focus_yh;
MCNUM focus_aw = mccSource_focus_aw;
MCNUM focus_ah = mccSource_focus_ah;
MCNUM E0 = mccSource_E0;
MCNUM dE = mccSource_dE;
MCNUM lambda0 = mccSource_lambda0;
MCNUM dlambda = mccSource_dlambda;
MCNUM I1 = mccSource_I1;
MCNUM yheight = mccSource_yheight;
MCNUM xwidth = mccSource_xwidth;
MCNUM verbose = mccSource_verbose;
MCNUM T1 = mccSource_T1;
MCNUM flux_file_perAA = mccSource_flux_file_perAA;
MCNUM flux_file_log = mccSource_flux_file_log;
MCNUM Lmin = mccSource_Lmin;
MCNUM Lmax = mccSource_Lmax;
MCNUM Emin = mccSource_Emin;
MCNUM Emax = mccSource_Emax;
MCNUM T2 = mccSource_T2;
MCNUM I2 = mccSource_I2;
MCNUM T3 = mccSource_T3;
MCNUM I3 = mccSource_I3;
MCNUM zdepth = mccSource_zdepth;
int target_index = mccSource_target_index;
#line 571 "/usr/share/mcstas/2.6rc1/sources/Source_gen.comp"
{
  Table_Free(&pTable);
  Table_Free(&pTable_x);
  Table_Free(&pTable_y);
}
#line 69519 "ILL_H15_D11.c"
}   /* End of Source=Source_gen() SETTING parameter declarations. */
#undef pTable_dymax
#undef pTable_dymin
#undef pTable_dxmax
#undef pTable_dxmin
#undef pTable_ysum
#undef pTable_ymax
#undef pTable_ymin
#undef pTable_xsum
#undef pTable_xmax
#undef pTable_xmin
#undef pTable_y
#undef pTable_x
#undef pTable
#undef lambda3
#undef lambda2
#undef lambda1
#undef p_in
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[2]) fprintf(stderr, "Warning: No neutron could reach Component[2] Source\n");
    if (mcAbsorbProp[2]) fprintf(stderr, "Warning: %g events were removed in Component[2] Source=Source_gen()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[2]);
    if (!mcNCounter[3]) fprintf(stderr, "Warning: No neutron could reach Component[3] AlWindow1\n");
    if (mcAbsorbProp[3]) fprintf(stderr, "Warning: %g events were removed in Component[3] AlWindow1=Al_window()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[3]);
  /* User FINALLY code for component 'PinkCarter'. */
  SIG_MESSAGE("PinkCarter (Finally)");
#define mccompcurname  PinkCarter
#define mccompcurtype  Guide_gravity
#define mccompcurindex 4
#define GVars mccPinkCarter_GVars
#define pTable mccPinkCarter_pTable
{   /* Declarations of PinkCarter=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccPinkCarter_w1;
MCNUM h1 = mccPinkCarter_h1;
MCNUM w2 = mccPinkCarter_w2;
MCNUM h2 = mccPinkCarter_h2;
MCNUM l = mccPinkCarter_l;
MCNUM R0 = mccPinkCarter_R0;
MCNUM Qc = mccPinkCarter_Qc;
MCNUM alpha = mccPinkCarter_alpha;
MCNUM m = mccPinkCarter_m;
MCNUM W = mccPinkCarter_W;
MCNUM nslit = mccPinkCarter_nslit;
MCNUM d = mccPinkCarter_d;
MCNUM mleft = mccPinkCarter_mleft;
MCNUM mright = mccPinkCarter_mright;
MCNUM mtop = mccPinkCarter_mtop;
MCNUM mbottom = mccPinkCarter_mbottom;
MCNUM nhslit = mccPinkCarter_nhslit;
MCNUM G = mccPinkCarter_G;
MCNUM aleft = mccPinkCarter_aleft;
MCNUM aright = mccPinkCarter_aright;
MCNUM atop = mccPinkCarter_atop;
MCNUM abottom = mccPinkCarter_abottom;
MCNUM wavy = mccPinkCarter_wavy;
MCNUM wavy_z = mccPinkCarter_wavy_z;
MCNUM wavy_tb = mccPinkCarter_wavy_tb;
MCNUM wavy_lr = mccPinkCarter_wavy_lr;
MCNUM chamfers = mccPinkCarter_chamfers;
MCNUM chamfers_z = mccPinkCarter_chamfers_z;
MCNUM chamfers_lr = mccPinkCarter_chamfers_lr;
MCNUM chamfers_tb = mccPinkCarter_chamfers_tb;
MCNUM nelements = mccPinkCarter_nelements;
MCNUM nu = mccPinkCarter_nu;
MCNUM phase = mccPinkCarter_phase;
char* reflect = mccPinkCarter_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 69595 "ILL_H15_D11.c"
}   /* End of PinkCarter=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[4]) fprintf(stderr, "Warning: No neutron could reach Component[4] PinkCarter\n");
    if (mcAbsorbProp[4]) fprintf(stderr, "Warning: %g events were removed in Component[4] PinkCarter=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[4]);
    if (!mcNCounter[5]) fprintf(stderr, "Warning: No neutron could reach Component[5] AlWindow2\n");
    if (mcAbsorbProp[5]) fprintf(stderr, "Warning: %g events were removed in Component[5] AlWindow2=Al_window()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[5]);
  /* User FINALLY code for component 'LeadShutter'. */
  SIG_MESSAGE("LeadShutter (Finally)");
#define mccompcurname  LeadShutter
#define mccompcurtype  Guide_gravity
#define mccompcurindex 6
#define GVars mccLeadShutter_GVars
#define pTable mccLeadShutter_pTable
{   /* Declarations of LeadShutter=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccLeadShutter_w1;
MCNUM h1 = mccLeadShutter_h1;
MCNUM w2 = mccLeadShutter_w2;
MCNUM h2 = mccLeadShutter_h2;
MCNUM l = mccLeadShutter_l;
MCNUM R0 = mccLeadShutter_R0;
MCNUM Qc = mccLeadShutter_Qc;
MCNUM alpha = mccLeadShutter_alpha;
MCNUM m = mccLeadShutter_m;
MCNUM W = mccLeadShutter_W;
MCNUM nslit = mccLeadShutter_nslit;
MCNUM d = mccLeadShutter_d;
MCNUM mleft = mccLeadShutter_mleft;
MCNUM mright = mccLeadShutter_mright;
MCNUM mtop = mccLeadShutter_mtop;
MCNUM mbottom = mccLeadShutter_mbottom;
MCNUM nhslit = mccLeadShutter_nhslit;
MCNUM G = mccLeadShutter_G;
MCNUM aleft = mccLeadShutter_aleft;
MCNUM aright = mccLeadShutter_aright;
MCNUM atop = mccLeadShutter_atop;
MCNUM abottom = mccLeadShutter_abottom;
MCNUM wavy = mccLeadShutter_wavy;
MCNUM wavy_z = mccLeadShutter_wavy_z;
MCNUM wavy_tb = mccLeadShutter_wavy_tb;
MCNUM wavy_lr = mccLeadShutter_wavy_lr;
MCNUM chamfers = mccLeadShutter_chamfers;
MCNUM chamfers_z = mccLeadShutter_chamfers_z;
MCNUM chamfers_lr = mccLeadShutter_chamfers_lr;
MCNUM chamfers_tb = mccLeadShutter_chamfers_tb;
MCNUM nelements = mccLeadShutter_nelements;
MCNUM nu = mccLeadShutter_nu;
MCNUM phase = mccLeadShutter_phase;
char* reflect = mccLeadShutter_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 69656 "ILL_H15_D11.c"
}   /* End of LeadShutter=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[6]) fprintf(stderr, "Warning: No neutron could reach Component[6] LeadShutter\n");
    if (mcAbsorbProp[6]) fprintf(stderr, "Warning: %g events were removed in Component[6] LeadShutter=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[6]);
    if (!mcNCounter[7]) fprintf(stderr, "Warning: No neutron could reach Component[7] AlWindow3\n");
    if (mcAbsorbProp[7]) fprintf(stderr, "Warning: %g events were removed in Component[7] AlWindow3=Al_window()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[7]);
    if (!mcNCounter[8]) fprintf(stderr, "Warning: No neutron could reach Component[8] CurvedGuideStart\n");
    if (mcAbsorbProp[8]) fprintf(stderr, "Warning: %g events were removed in Component[8] CurvedGuideStart=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[8]);
  /* User FINALLY code for component 'cg1'. */
  SIG_MESSAGE("cg1 (Finally)");
#define mccompcurname  cg1
#define mccompcurtype  Guide_gravity
#define mccompcurindex 9
#define GVars mcccg1_GVars
#define pTable mcccg1_pTable
{   /* Declarations of cg1=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg1_w1;
MCNUM h1 = mcccg1_h1;
MCNUM w2 = mcccg1_w2;
MCNUM h2 = mcccg1_h2;
MCNUM l = mcccg1_l;
MCNUM R0 = mcccg1_R0;
MCNUM Qc = mcccg1_Qc;
MCNUM alpha = mcccg1_alpha;
MCNUM m = mcccg1_m;
MCNUM W = mcccg1_W;
MCNUM nslit = mcccg1_nslit;
MCNUM d = mcccg1_d;
MCNUM mleft = mcccg1_mleft;
MCNUM mright = mcccg1_mright;
MCNUM mtop = mcccg1_mtop;
MCNUM mbottom = mcccg1_mbottom;
MCNUM nhslit = mcccg1_nhslit;
MCNUM G = mcccg1_G;
MCNUM aleft = mcccg1_aleft;
MCNUM aright = mcccg1_aright;
MCNUM atop = mcccg1_atop;
MCNUM abottom = mcccg1_abottom;
MCNUM wavy = mcccg1_wavy;
MCNUM wavy_z = mcccg1_wavy_z;
MCNUM wavy_tb = mcccg1_wavy_tb;
MCNUM wavy_lr = mcccg1_wavy_lr;
MCNUM chamfers = mcccg1_chamfers;
MCNUM chamfers_z = mcccg1_chamfers_z;
MCNUM chamfers_lr = mcccg1_chamfers_lr;
MCNUM chamfers_tb = mcccg1_chamfers_tb;
MCNUM nelements = mcccg1_nelements;
MCNUM nu = mcccg1_nu;
MCNUM phase = mcccg1_phase;
char* reflect = mcccg1_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 69719 "ILL_H15_D11.c"
}   /* End of cg1=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[9]) fprintf(stderr, "Warning: No neutron could reach Component[9] cg1\n");
    if (mcAbsorbProp[9]) fprintf(stderr, "Warning: %g events were removed in Component[9] cg1=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[9]);
  /* User FINALLY code for component 'cg2'. */
  SIG_MESSAGE("cg2 (Finally)");
#define mccompcurname  cg2
#define mccompcurtype  Guide_gravity
#define mccompcurindex 10
#define GVars mcccg2_GVars
#define pTable mcccg2_pTable
{   /* Declarations of cg2=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg2_w1;
MCNUM h1 = mcccg2_h1;
MCNUM w2 = mcccg2_w2;
MCNUM h2 = mcccg2_h2;
MCNUM l = mcccg2_l;
MCNUM R0 = mcccg2_R0;
MCNUM Qc = mcccg2_Qc;
MCNUM alpha = mcccg2_alpha;
MCNUM m = mcccg2_m;
MCNUM W = mcccg2_W;
MCNUM nslit = mcccg2_nslit;
MCNUM d = mcccg2_d;
MCNUM mleft = mcccg2_mleft;
MCNUM mright = mcccg2_mright;
MCNUM mtop = mcccg2_mtop;
MCNUM mbottom = mcccg2_mbottom;
MCNUM nhslit = mcccg2_nhslit;
MCNUM G = mcccg2_G;
MCNUM aleft = mcccg2_aleft;
MCNUM aright = mcccg2_aright;
MCNUM atop = mcccg2_atop;
MCNUM abottom = mcccg2_abottom;
MCNUM wavy = mcccg2_wavy;
MCNUM wavy_z = mcccg2_wavy_z;
MCNUM wavy_tb = mcccg2_wavy_tb;
MCNUM wavy_lr = mcccg2_wavy_lr;
MCNUM chamfers = mcccg2_chamfers;
MCNUM chamfers_z = mcccg2_chamfers_z;
MCNUM chamfers_lr = mcccg2_chamfers_lr;
MCNUM chamfers_tb = mcccg2_chamfers_tb;
MCNUM nelements = mcccg2_nelements;
MCNUM nu = mcccg2_nu;
MCNUM phase = mcccg2_phase;
char* reflect = mcccg2_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 69778 "ILL_H15_D11.c"
}   /* End of cg2=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[10]) fprintf(stderr, "Warning: No neutron could reach Component[10] cg2\n");
    if (mcAbsorbProp[10]) fprintf(stderr, "Warning: %g events were removed in Component[10] cg2=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[10]);
  /* User FINALLY code for component 'cg3'. */
  SIG_MESSAGE("cg3 (Finally)");
#define mccompcurname  cg3
#define mccompcurtype  Guide_gravity
#define mccompcurindex 11
#define GVars mcccg3_GVars
#define pTable mcccg3_pTable
{   /* Declarations of cg3=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg3_w1;
MCNUM h1 = mcccg3_h1;
MCNUM w2 = mcccg3_w2;
MCNUM h2 = mcccg3_h2;
MCNUM l = mcccg3_l;
MCNUM R0 = mcccg3_R0;
MCNUM Qc = mcccg3_Qc;
MCNUM alpha = mcccg3_alpha;
MCNUM m = mcccg3_m;
MCNUM W = mcccg3_W;
MCNUM nslit = mcccg3_nslit;
MCNUM d = mcccg3_d;
MCNUM mleft = mcccg3_mleft;
MCNUM mright = mcccg3_mright;
MCNUM mtop = mcccg3_mtop;
MCNUM mbottom = mcccg3_mbottom;
MCNUM nhslit = mcccg3_nhslit;
MCNUM G = mcccg3_G;
MCNUM aleft = mcccg3_aleft;
MCNUM aright = mcccg3_aright;
MCNUM atop = mcccg3_atop;
MCNUM abottom = mcccg3_abottom;
MCNUM wavy = mcccg3_wavy;
MCNUM wavy_z = mcccg3_wavy_z;
MCNUM wavy_tb = mcccg3_wavy_tb;
MCNUM wavy_lr = mcccg3_wavy_lr;
MCNUM chamfers = mcccg3_chamfers;
MCNUM chamfers_z = mcccg3_chamfers_z;
MCNUM chamfers_lr = mcccg3_chamfers_lr;
MCNUM chamfers_tb = mcccg3_chamfers_tb;
MCNUM nelements = mcccg3_nelements;
MCNUM nu = mcccg3_nu;
MCNUM phase = mcccg3_phase;
char* reflect = mcccg3_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 69837 "ILL_H15_D11.c"
}   /* End of cg3=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[11]) fprintf(stderr, "Warning: No neutron could reach Component[11] cg3\n");
    if (mcAbsorbProp[11]) fprintf(stderr, "Warning: %g events were removed in Component[11] cg3=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[11]);
  /* User FINALLY code for component 'cg4'. */
  SIG_MESSAGE("cg4 (Finally)");
#define mccompcurname  cg4
#define mccompcurtype  Guide_gravity
#define mccompcurindex 12
#define GVars mcccg4_GVars
#define pTable mcccg4_pTable
{   /* Declarations of cg4=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg4_w1;
MCNUM h1 = mcccg4_h1;
MCNUM w2 = mcccg4_w2;
MCNUM h2 = mcccg4_h2;
MCNUM l = mcccg4_l;
MCNUM R0 = mcccg4_R0;
MCNUM Qc = mcccg4_Qc;
MCNUM alpha = mcccg4_alpha;
MCNUM m = mcccg4_m;
MCNUM W = mcccg4_W;
MCNUM nslit = mcccg4_nslit;
MCNUM d = mcccg4_d;
MCNUM mleft = mcccg4_mleft;
MCNUM mright = mcccg4_mright;
MCNUM mtop = mcccg4_mtop;
MCNUM mbottom = mcccg4_mbottom;
MCNUM nhslit = mcccg4_nhslit;
MCNUM G = mcccg4_G;
MCNUM aleft = mcccg4_aleft;
MCNUM aright = mcccg4_aright;
MCNUM atop = mcccg4_atop;
MCNUM abottom = mcccg4_abottom;
MCNUM wavy = mcccg4_wavy;
MCNUM wavy_z = mcccg4_wavy_z;
MCNUM wavy_tb = mcccg4_wavy_tb;
MCNUM wavy_lr = mcccg4_wavy_lr;
MCNUM chamfers = mcccg4_chamfers;
MCNUM chamfers_z = mcccg4_chamfers_z;
MCNUM chamfers_lr = mcccg4_chamfers_lr;
MCNUM chamfers_tb = mcccg4_chamfers_tb;
MCNUM nelements = mcccg4_nelements;
MCNUM nu = mcccg4_nu;
MCNUM phase = mcccg4_phase;
char* reflect = mcccg4_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 69896 "ILL_H15_D11.c"
}   /* End of cg4=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[12]) fprintf(stderr, "Warning: No neutron could reach Component[12] cg4\n");
    if (mcAbsorbProp[12]) fprintf(stderr, "Warning: %g events were removed in Component[12] cg4=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[12]);
  /* User FINALLY code for component 'cg5'. */
  SIG_MESSAGE("cg5 (Finally)");
#define mccompcurname  cg5
#define mccompcurtype  Guide_gravity
#define mccompcurindex 13
#define GVars mcccg5_GVars
#define pTable mcccg5_pTable
{   /* Declarations of cg5=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg5_w1;
MCNUM h1 = mcccg5_h1;
MCNUM w2 = mcccg5_w2;
MCNUM h2 = mcccg5_h2;
MCNUM l = mcccg5_l;
MCNUM R0 = mcccg5_R0;
MCNUM Qc = mcccg5_Qc;
MCNUM alpha = mcccg5_alpha;
MCNUM m = mcccg5_m;
MCNUM W = mcccg5_W;
MCNUM nslit = mcccg5_nslit;
MCNUM d = mcccg5_d;
MCNUM mleft = mcccg5_mleft;
MCNUM mright = mcccg5_mright;
MCNUM mtop = mcccg5_mtop;
MCNUM mbottom = mcccg5_mbottom;
MCNUM nhslit = mcccg5_nhslit;
MCNUM G = mcccg5_G;
MCNUM aleft = mcccg5_aleft;
MCNUM aright = mcccg5_aright;
MCNUM atop = mcccg5_atop;
MCNUM abottom = mcccg5_abottom;
MCNUM wavy = mcccg5_wavy;
MCNUM wavy_z = mcccg5_wavy_z;
MCNUM wavy_tb = mcccg5_wavy_tb;
MCNUM wavy_lr = mcccg5_wavy_lr;
MCNUM chamfers = mcccg5_chamfers;
MCNUM chamfers_z = mcccg5_chamfers_z;
MCNUM chamfers_lr = mcccg5_chamfers_lr;
MCNUM chamfers_tb = mcccg5_chamfers_tb;
MCNUM nelements = mcccg5_nelements;
MCNUM nu = mcccg5_nu;
MCNUM phase = mcccg5_phase;
char* reflect = mcccg5_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 69955 "ILL_H15_D11.c"
}   /* End of cg5=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[13]) fprintf(stderr, "Warning: No neutron could reach Component[13] cg5\n");
    if (mcAbsorbProp[13]) fprintf(stderr, "Warning: %g events were removed in Component[13] cg5=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[13]);
  /* User FINALLY code for component 'cg6'. */
  SIG_MESSAGE("cg6 (Finally)");
#define mccompcurname  cg6
#define mccompcurtype  Guide_gravity
#define mccompcurindex 14
#define GVars mcccg6_GVars
#define pTable mcccg6_pTable
{   /* Declarations of cg6=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg6_w1;
MCNUM h1 = mcccg6_h1;
MCNUM w2 = mcccg6_w2;
MCNUM h2 = mcccg6_h2;
MCNUM l = mcccg6_l;
MCNUM R0 = mcccg6_R0;
MCNUM Qc = mcccg6_Qc;
MCNUM alpha = mcccg6_alpha;
MCNUM m = mcccg6_m;
MCNUM W = mcccg6_W;
MCNUM nslit = mcccg6_nslit;
MCNUM d = mcccg6_d;
MCNUM mleft = mcccg6_mleft;
MCNUM mright = mcccg6_mright;
MCNUM mtop = mcccg6_mtop;
MCNUM mbottom = mcccg6_mbottom;
MCNUM nhslit = mcccg6_nhslit;
MCNUM G = mcccg6_G;
MCNUM aleft = mcccg6_aleft;
MCNUM aright = mcccg6_aright;
MCNUM atop = mcccg6_atop;
MCNUM abottom = mcccg6_abottom;
MCNUM wavy = mcccg6_wavy;
MCNUM wavy_z = mcccg6_wavy_z;
MCNUM wavy_tb = mcccg6_wavy_tb;
MCNUM wavy_lr = mcccg6_wavy_lr;
MCNUM chamfers = mcccg6_chamfers;
MCNUM chamfers_z = mcccg6_chamfers_z;
MCNUM chamfers_lr = mcccg6_chamfers_lr;
MCNUM chamfers_tb = mcccg6_chamfers_tb;
MCNUM nelements = mcccg6_nelements;
MCNUM nu = mcccg6_nu;
MCNUM phase = mcccg6_phase;
char* reflect = mcccg6_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 70014 "ILL_H15_D11.c"
}   /* End of cg6=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[14]) fprintf(stderr, "Warning: No neutron could reach Component[14] cg6\n");
    if (mcAbsorbProp[14]) fprintf(stderr, "Warning: %g events were removed in Component[14] cg6=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[14]);
  /* User FINALLY code for component 'cg7'. */
  SIG_MESSAGE("cg7 (Finally)");
#define mccompcurname  cg7
#define mccompcurtype  Guide_gravity
#define mccompcurindex 15
#define GVars mcccg7_GVars
#define pTable mcccg7_pTable
{   /* Declarations of cg7=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg7_w1;
MCNUM h1 = mcccg7_h1;
MCNUM w2 = mcccg7_w2;
MCNUM h2 = mcccg7_h2;
MCNUM l = mcccg7_l;
MCNUM R0 = mcccg7_R0;
MCNUM Qc = mcccg7_Qc;
MCNUM alpha = mcccg7_alpha;
MCNUM m = mcccg7_m;
MCNUM W = mcccg7_W;
MCNUM nslit = mcccg7_nslit;
MCNUM d = mcccg7_d;
MCNUM mleft = mcccg7_mleft;
MCNUM mright = mcccg7_mright;
MCNUM mtop = mcccg7_mtop;
MCNUM mbottom = mcccg7_mbottom;
MCNUM nhslit = mcccg7_nhslit;
MCNUM G = mcccg7_G;
MCNUM aleft = mcccg7_aleft;
MCNUM aright = mcccg7_aright;
MCNUM atop = mcccg7_atop;
MCNUM abottom = mcccg7_abottom;
MCNUM wavy = mcccg7_wavy;
MCNUM wavy_z = mcccg7_wavy_z;
MCNUM wavy_tb = mcccg7_wavy_tb;
MCNUM wavy_lr = mcccg7_wavy_lr;
MCNUM chamfers = mcccg7_chamfers;
MCNUM chamfers_z = mcccg7_chamfers_z;
MCNUM chamfers_lr = mcccg7_chamfers_lr;
MCNUM chamfers_tb = mcccg7_chamfers_tb;
MCNUM nelements = mcccg7_nelements;
MCNUM nu = mcccg7_nu;
MCNUM phase = mcccg7_phase;
char* reflect = mcccg7_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 70073 "ILL_H15_D11.c"
}   /* End of cg7=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[15]) fprintf(stderr, "Warning: No neutron could reach Component[15] cg7\n");
    if (mcAbsorbProp[15]) fprintf(stderr, "Warning: %g events were removed in Component[15] cg7=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[15]);
  /* User FINALLY code for component 'cg8'. */
  SIG_MESSAGE("cg8 (Finally)");
#define mccompcurname  cg8
#define mccompcurtype  Guide_gravity
#define mccompcurindex 16
#define GVars mcccg8_GVars
#define pTable mcccg8_pTable
{   /* Declarations of cg8=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg8_w1;
MCNUM h1 = mcccg8_h1;
MCNUM w2 = mcccg8_w2;
MCNUM h2 = mcccg8_h2;
MCNUM l = mcccg8_l;
MCNUM R0 = mcccg8_R0;
MCNUM Qc = mcccg8_Qc;
MCNUM alpha = mcccg8_alpha;
MCNUM m = mcccg8_m;
MCNUM W = mcccg8_W;
MCNUM nslit = mcccg8_nslit;
MCNUM d = mcccg8_d;
MCNUM mleft = mcccg8_mleft;
MCNUM mright = mcccg8_mright;
MCNUM mtop = mcccg8_mtop;
MCNUM mbottom = mcccg8_mbottom;
MCNUM nhslit = mcccg8_nhslit;
MCNUM G = mcccg8_G;
MCNUM aleft = mcccg8_aleft;
MCNUM aright = mcccg8_aright;
MCNUM atop = mcccg8_atop;
MCNUM abottom = mcccg8_abottom;
MCNUM wavy = mcccg8_wavy;
MCNUM wavy_z = mcccg8_wavy_z;
MCNUM wavy_tb = mcccg8_wavy_tb;
MCNUM wavy_lr = mcccg8_wavy_lr;
MCNUM chamfers = mcccg8_chamfers;
MCNUM chamfers_z = mcccg8_chamfers_z;
MCNUM chamfers_lr = mcccg8_chamfers_lr;
MCNUM chamfers_tb = mcccg8_chamfers_tb;
MCNUM nelements = mcccg8_nelements;
MCNUM nu = mcccg8_nu;
MCNUM phase = mcccg8_phase;
char* reflect = mcccg8_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 70132 "ILL_H15_D11.c"
}   /* End of cg8=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[16]) fprintf(stderr, "Warning: No neutron could reach Component[16] cg8\n");
    if (mcAbsorbProp[16]) fprintf(stderr, "Warning: %g events were removed in Component[16] cg8=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[16]);
  /* User FINALLY code for component 'cg9'. */
  SIG_MESSAGE("cg9 (Finally)");
#define mccompcurname  cg9
#define mccompcurtype  Guide_gravity
#define mccompcurindex 17
#define GVars mcccg9_GVars
#define pTable mcccg9_pTable
{   /* Declarations of cg9=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg9_w1;
MCNUM h1 = mcccg9_h1;
MCNUM w2 = mcccg9_w2;
MCNUM h2 = mcccg9_h2;
MCNUM l = mcccg9_l;
MCNUM R0 = mcccg9_R0;
MCNUM Qc = mcccg9_Qc;
MCNUM alpha = mcccg9_alpha;
MCNUM m = mcccg9_m;
MCNUM W = mcccg9_W;
MCNUM nslit = mcccg9_nslit;
MCNUM d = mcccg9_d;
MCNUM mleft = mcccg9_mleft;
MCNUM mright = mcccg9_mright;
MCNUM mtop = mcccg9_mtop;
MCNUM mbottom = mcccg9_mbottom;
MCNUM nhslit = mcccg9_nhslit;
MCNUM G = mcccg9_G;
MCNUM aleft = mcccg9_aleft;
MCNUM aright = mcccg9_aright;
MCNUM atop = mcccg9_atop;
MCNUM abottom = mcccg9_abottom;
MCNUM wavy = mcccg9_wavy;
MCNUM wavy_z = mcccg9_wavy_z;
MCNUM wavy_tb = mcccg9_wavy_tb;
MCNUM wavy_lr = mcccg9_wavy_lr;
MCNUM chamfers = mcccg9_chamfers;
MCNUM chamfers_z = mcccg9_chamfers_z;
MCNUM chamfers_lr = mcccg9_chamfers_lr;
MCNUM chamfers_tb = mcccg9_chamfers_tb;
MCNUM nelements = mcccg9_nelements;
MCNUM nu = mcccg9_nu;
MCNUM phase = mcccg9_phase;
char* reflect = mcccg9_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 70191 "ILL_H15_D11.c"
}   /* End of cg9=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[17]) fprintf(stderr, "Warning: No neutron could reach Component[17] cg9\n");
    if (mcAbsorbProp[17]) fprintf(stderr, "Warning: %g events were removed in Component[17] cg9=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[17]);
  /* User FINALLY code for component 'cg10'. */
  SIG_MESSAGE("cg10 (Finally)");
#define mccompcurname  cg10
#define mccompcurtype  Guide_gravity
#define mccompcurindex 18
#define GVars mcccg10_GVars
#define pTable mcccg10_pTable
{   /* Declarations of cg10=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg10_w1;
MCNUM h1 = mcccg10_h1;
MCNUM w2 = mcccg10_w2;
MCNUM h2 = mcccg10_h2;
MCNUM l = mcccg10_l;
MCNUM R0 = mcccg10_R0;
MCNUM Qc = mcccg10_Qc;
MCNUM alpha = mcccg10_alpha;
MCNUM m = mcccg10_m;
MCNUM W = mcccg10_W;
MCNUM nslit = mcccg10_nslit;
MCNUM d = mcccg10_d;
MCNUM mleft = mcccg10_mleft;
MCNUM mright = mcccg10_mright;
MCNUM mtop = mcccg10_mtop;
MCNUM mbottom = mcccg10_mbottom;
MCNUM nhslit = mcccg10_nhslit;
MCNUM G = mcccg10_G;
MCNUM aleft = mcccg10_aleft;
MCNUM aright = mcccg10_aright;
MCNUM atop = mcccg10_atop;
MCNUM abottom = mcccg10_abottom;
MCNUM wavy = mcccg10_wavy;
MCNUM wavy_z = mcccg10_wavy_z;
MCNUM wavy_tb = mcccg10_wavy_tb;
MCNUM wavy_lr = mcccg10_wavy_lr;
MCNUM chamfers = mcccg10_chamfers;
MCNUM chamfers_z = mcccg10_chamfers_z;
MCNUM chamfers_lr = mcccg10_chamfers_lr;
MCNUM chamfers_tb = mcccg10_chamfers_tb;
MCNUM nelements = mcccg10_nelements;
MCNUM nu = mcccg10_nu;
MCNUM phase = mcccg10_phase;
char* reflect = mcccg10_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 70250 "ILL_H15_D11.c"
}   /* End of cg10=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[18]) fprintf(stderr, "Warning: No neutron could reach Component[18] cg10\n");
    if (mcAbsorbProp[18]) fprintf(stderr, "Warning: %g events were removed in Component[18] cg10=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[18]);
  /* User FINALLY code for component 'cg11'. */
  SIG_MESSAGE("cg11 (Finally)");
#define mccompcurname  cg11
#define mccompcurtype  Guide_gravity
#define mccompcurindex 19
#define GVars mcccg11_GVars
#define pTable mcccg11_pTable
{   /* Declarations of cg11=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg11_w1;
MCNUM h1 = mcccg11_h1;
MCNUM w2 = mcccg11_w2;
MCNUM h2 = mcccg11_h2;
MCNUM l = mcccg11_l;
MCNUM R0 = mcccg11_R0;
MCNUM Qc = mcccg11_Qc;
MCNUM alpha = mcccg11_alpha;
MCNUM m = mcccg11_m;
MCNUM W = mcccg11_W;
MCNUM nslit = mcccg11_nslit;
MCNUM d = mcccg11_d;
MCNUM mleft = mcccg11_mleft;
MCNUM mright = mcccg11_mright;
MCNUM mtop = mcccg11_mtop;
MCNUM mbottom = mcccg11_mbottom;
MCNUM nhslit = mcccg11_nhslit;
MCNUM G = mcccg11_G;
MCNUM aleft = mcccg11_aleft;
MCNUM aright = mcccg11_aright;
MCNUM atop = mcccg11_atop;
MCNUM abottom = mcccg11_abottom;
MCNUM wavy = mcccg11_wavy;
MCNUM wavy_z = mcccg11_wavy_z;
MCNUM wavy_tb = mcccg11_wavy_tb;
MCNUM wavy_lr = mcccg11_wavy_lr;
MCNUM chamfers = mcccg11_chamfers;
MCNUM chamfers_z = mcccg11_chamfers_z;
MCNUM chamfers_lr = mcccg11_chamfers_lr;
MCNUM chamfers_tb = mcccg11_chamfers_tb;
MCNUM nelements = mcccg11_nelements;
MCNUM nu = mcccg11_nu;
MCNUM phase = mcccg11_phase;
char* reflect = mcccg11_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 70309 "ILL_H15_D11.c"
}   /* End of cg11=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[19]) fprintf(stderr, "Warning: No neutron could reach Component[19] cg11\n");
    if (mcAbsorbProp[19]) fprintf(stderr, "Warning: %g events were removed in Component[19] cg11=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[19]);
  /* User FINALLY code for component 'cg12'. */
  SIG_MESSAGE("cg12 (Finally)");
#define mccompcurname  cg12
#define mccompcurtype  Guide_gravity
#define mccompcurindex 20
#define GVars mcccg12_GVars
#define pTable mcccg12_pTable
{   /* Declarations of cg12=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg12_w1;
MCNUM h1 = mcccg12_h1;
MCNUM w2 = mcccg12_w2;
MCNUM h2 = mcccg12_h2;
MCNUM l = mcccg12_l;
MCNUM R0 = mcccg12_R0;
MCNUM Qc = mcccg12_Qc;
MCNUM alpha = mcccg12_alpha;
MCNUM m = mcccg12_m;
MCNUM W = mcccg12_W;
MCNUM nslit = mcccg12_nslit;
MCNUM d = mcccg12_d;
MCNUM mleft = mcccg12_mleft;
MCNUM mright = mcccg12_mright;
MCNUM mtop = mcccg12_mtop;
MCNUM mbottom = mcccg12_mbottom;
MCNUM nhslit = mcccg12_nhslit;
MCNUM G = mcccg12_G;
MCNUM aleft = mcccg12_aleft;
MCNUM aright = mcccg12_aright;
MCNUM atop = mcccg12_atop;
MCNUM abottom = mcccg12_abottom;
MCNUM wavy = mcccg12_wavy;
MCNUM wavy_z = mcccg12_wavy_z;
MCNUM wavy_tb = mcccg12_wavy_tb;
MCNUM wavy_lr = mcccg12_wavy_lr;
MCNUM chamfers = mcccg12_chamfers;
MCNUM chamfers_z = mcccg12_chamfers_z;
MCNUM chamfers_lr = mcccg12_chamfers_lr;
MCNUM chamfers_tb = mcccg12_chamfers_tb;
MCNUM nelements = mcccg12_nelements;
MCNUM nu = mcccg12_nu;
MCNUM phase = mcccg12_phase;
char* reflect = mcccg12_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 70368 "ILL_H15_D11.c"
}   /* End of cg12=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[20]) fprintf(stderr, "Warning: No neutron could reach Component[20] cg12\n");
    if (mcAbsorbProp[20]) fprintf(stderr, "Warning: %g events were removed in Component[20] cg12=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[20]);
  /* User FINALLY code for component 'cg13'. */
  SIG_MESSAGE("cg13 (Finally)");
#define mccompcurname  cg13
#define mccompcurtype  Guide_gravity
#define mccompcurindex 21
#define GVars mcccg13_GVars
#define pTable mcccg13_pTable
{   /* Declarations of cg13=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg13_w1;
MCNUM h1 = mcccg13_h1;
MCNUM w2 = mcccg13_w2;
MCNUM h2 = mcccg13_h2;
MCNUM l = mcccg13_l;
MCNUM R0 = mcccg13_R0;
MCNUM Qc = mcccg13_Qc;
MCNUM alpha = mcccg13_alpha;
MCNUM m = mcccg13_m;
MCNUM W = mcccg13_W;
MCNUM nslit = mcccg13_nslit;
MCNUM d = mcccg13_d;
MCNUM mleft = mcccg13_mleft;
MCNUM mright = mcccg13_mright;
MCNUM mtop = mcccg13_mtop;
MCNUM mbottom = mcccg13_mbottom;
MCNUM nhslit = mcccg13_nhslit;
MCNUM G = mcccg13_G;
MCNUM aleft = mcccg13_aleft;
MCNUM aright = mcccg13_aright;
MCNUM atop = mcccg13_atop;
MCNUM abottom = mcccg13_abottom;
MCNUM wavy = mcccg13_wavy;
MCNUM wavy_z = mcccg13_wavy_z;
MCNUM wavy_tb = mcccg13_wavy_tb;
MCNUM wavy_lr = mcccg13_wavy_lr;
MCNUM chamfers = mcccg13_chamfers;
MCNUM chamfers_z = mcccg13_chamfers_z;
MCNUM chamfers_lr = mcccg13_chamfers_lr;
MCNUM chamfers_tb = mcccg13_chamfers_tb;
MCNUM nelements = mcccg13_nelements;
MCNUM nu = mcccg13_nu;
MCNUM phase = mcccg13_phase;
char* reflect = mcccg13_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 70427 "ILL_H15_D11.c"
}   /* End of cg13=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[21]) fprintf(stderr, "Warning: No neutron could reach Component[21] cg13\n");
    if (mcAbsorbProp[21]) fprintf(stderr, "Warning: %g events were removed in Component[21] cg13=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[21]);
  /* User FINALLY code for component 'cg14'. */
  SIG_MESSAGE("cg14 (Finally)");
#define mccompcurname  cg14
#define mccompcurtype  Guide_gravity
#define mccompcurindex 22
#define GVars mcccg14_GVars
#define pTable mcccg14_pTable
{   /* Declarations of cg14=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg14_w1;
MCNUM h1 = mcccg14_h1;
MCNUM w2 = mcccg14_w2;
MCNUM h2 = mcccg14_h2;
MCNUM l = mcccg14_l;
MCNUM R0 = mcccg14_R0;
MCNUM Qc = mcccg14_Qc;
MCNUM alpha = mcccg14_alpha;
MCNUM m = mcccg14_m;
MCNUM W = mcccg14_W;
MCNUM nslit = mcccg14_nslit;
MCNUM d = mcccg14_d;
MCNUM mleft = mcccg14_mleft;
MCNUM mright = mcccg14_mright;
MCNUM mtop = mcccg14_mtop;
MCNUM mbottom = mcccg14_mbottom;
MCNUM nhslit = mcccg14_nhslit;
MCNUM G = mcccg14_G;
MCNUM aleft = mcccg14_aleft;
MCNUM aright = mcccg14_aright;
MCNUM atop = mcccg14_atop;
MCNUM abottom = mcccg14_abottom;
MCNUM wavy = mcccg14_wavy;
MCNUM wavy_z = mcccg14_wavy_z;
MCNUM wavy_tb = mcccg14_wavy_tb;
MCNUM wavy_lr = mcccg14_wavy_lr;
MCNUM chamfers = mcccg14_chamfers;
MCNUM chamfers_z = mcccg14_chamfers_z;
MCNUM chamfers_lr = mcccg14_chamfers_lr;
MCNUM chamfers_tb = mcccg14_chamfers_tb;
MCNUM nelements = mcccg14_nelements;
MCNUM nu = mcccg14_nu;
MCNUM phase = mcccg14_phase;
char* reflect = mcccg14_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 70486 "ILL_H15_D11.c"
}   /* End of cg14=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[22]) fprintf(stderr, "Warning: No neutron could reach Component[22] cg14\n");
    if (mcAbsorbProp[22]) fprintf(stderr, "Warning: %g events were removed in Component[22] cg14=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[22]);
  /* User FINALLY code for component 'cg15'. */
  SIG_MESSAGE("cg15 (Finally)");
#define mccompcurname  cg15
#define mccompcurtype  Guide_gravity
#define mccompcurindex 23
#define GVars mcccg15_GVars
#define pTable mcccg15_pTable
{   /* Declarations of cg15=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg15_w1;
MCNUM h1 = mcccg15_h1;
MCNUM w2 = mcccg15_w2;
MCNUM h2 = mcccg15_h2;
MCNUM l = mcccg15_l;
MCNUM R0 = mcccg15_R0;
MCNUM Qc = mcccg15_Qc;
MCNUM alpha = mcccg15_alpha;
MCNUM m = mcccg15_m;
MCNUM W = mcccg15_W;
MCNUM nslit = mcccg15_nslit;
MCNUM d = mcccg15_d;
MCNUM mleft = mcccg15_mleft;
MCNUM mright = mcccg15_mright;
MCNUM mtop = mcccg15_mtop;
MCNUM mbottom = mcccg15_mbottom;
MCNUM nhslit = mcccg15_nhslit;
MCNUM G = mcccg15_G;
MCNUM aleft = mcccg15_aleft;
MCNUM aright = mcccg15_aright;
MCNUM atop = mcccg15_atop;
MCNUM abottom = mcccg15_abottom;
MCNUM wavy = mcccg15_wavy;
MCNUM wavy_z = mcccg15_wavy_z;
MCNUM wavy_tb = mcccg15_wavy_tb;
MCNUM wavy_lr = mcccg15_wavy_lr;
MCNUM chamfers = mcccg15_chamfers;
MCNUM chamfers_z = mcccg15_chamfers_z;
MCNUM chamfers_lr = mcccg15_chamfers_lr;
MCNUM chamfers_tb = mcccg15_chamfers_tb;
MCNUM nelements = mcccg15_nelements;
MCNUM nu = mcccg15_nu;
MCNUM phase = mcccg15_phase;
char* reflect = mcccg15_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 70545 "ILL_H15_D11.c"
}   /* End of cg15=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[23]) fprintf(stderr, "Warning: No neutron could reach Component[23] cg15\n");
    if (mcAbsorbProp[23]) fprintf(stderr, "Warning: %g events were removed in Component[23] cg15=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[23]);
  /* User FINALLY code for component 'cg16'. */
  SIG_MESSAGE("cg16 (Finally)");
#define mccompcurname  cg16
#define mccompcurtype  Guide_gravity
#define mccompcurindex 24
#define GVars mcccg16_GVars
#define pTable mcccg16_pTable
{   /* Declarations of cg16=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg16_w1;
MCNUM h1 = mcccg16_h1;
MCNUM w2 = mcccg16_w2;
MCNUM h2 = mcccg16_h2;
MCNUM l = mcccg16_l;
MCNUM R0 = mcccg16_R0;
MCNUM Qc = mcccg16_Qc;
MCNUM alpha = mcccg16_alpha;
MCNUM m = mcccg16_m;
MCNUM W = mcccg16_W;
MCNUM nslit = mcccg16_nslit;
MCNUM d = mcccg16_d;
MCNUM mleft = mcccg16_mleft;
MCNUM mright = mcccg16_mright;
MCNUM mtop = mcccg16_mtop;
MCNUM mbottom = mcccg16_mbottom;
MCNUM nhslit = mcccg16_nhslit;
MCNUM G = mcccg16_G;
MCNUM aleft = mcccg16_aleft;
MCNUM aright = mcccg16_aright;
MCNUM atop = mcccg16_atop;
MCNUM abottom = mcccg16_abottom;
MCNUM wavy = mcccg16_wavy;
MCNUM wavy_z = mcccg16_wavy_z;
MCNUM wavy_tb = mcccg16_wavy_tb;
MCNUM wavy_lr = mcccg16_wavy_lr;
MCNUM chamfers = mcccg16_chamfers;
MCNUM chamfers_z = mcccg16_chamfers_z;
MCNUM chamfers_lr = mcccg16_chamfers_lr;
MCNUM chamfers_tb = mcccg16_chamfers_tb;
MCNUM nelements = mcccg16_nelements;
MCNUM nu = mcccg16_nu;
MCNUM phase = mcccg16_phase;
char* reflect = mcccg16_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 70604 "ILL_H15_D11.c"
}   /* End of cg16=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[24]) fprintf(stderr, "Warning: No neutron could reach Component[24] cg16\n");
    if (mcAbsorbProp[24]) fprintf(stderr, "Warning: %g events were removed in Component[24] cg16=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[24]);
  /* User FINALLY code for component 'cg17'. */
  SIG_MESSAGE("cg17 (Finally)");
#define mccompcurname  cg17
#define mccompcurtype  Guide_gravity
#define mccompcurindex 25
#define GVars mcccg17_GVars
#define pTable mcccg17_pTable
{   /* Declarations of cg17=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg17_w1;
MCNUM h1 = mcccg17_h1;
MCNUM w2 = mcccg17_w2;
MCNUM h2 = mcccg17_h2;
MCNUM l = mcccg17_l;
MCNUM R0 = mcccg17_R0;
MCNUM Qc = mcccg17_Qc;
MCNUM alpha = mcccg17_alpha;
MCNUM m = mcccg17_m;
MCNUM W = mcccg17_W;
MCNUM nslit = mcccg17_nslit;
MCNUM d = mcccg17_d;
MCNUM mleft = mcccg17_mleft;
MCNUM mright = mcccg17_mright;
MCNUM mtop = mcccg17_mtop;
MCNUM mbottom = mcccg17_mbottom;
MCNUM nhslit = mcccg17_nhslit;
MCNUM G = mcccg17_G;
MCNUM aleft = mcccg17_aleft;
MCNUM aright = mcccg17_aright;
MCNUM atop = mcccg17_atop;
MCNUM abottom = mcccg17_abottom;
MCNUM wavy = mcccg17_wavy;
MCNUM wavy_z = mcccg17_wavy_z;
MCNUM wavy_tb = mcccg17_wavy_tb;
MCNUM wavy_lr = mcccg17_wavy_lr;
MCNUM chamfers = mcccg17_chamfers;
MCNUM chamfers_z = mcccg17_chamfers_z;
MCNUM chamfers_lr = mcccg17_chamfers_lr;
MCNUM chamfers_tb = mcccg17_chamfers_tb;
MCNUM nelements = mcccg17_nelements;
MCNUM nu = mcccg17_nu;
MCNUM phase = mcccg17_phase;
char* reflect = mcccg17_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 70663 "ILL_H15_D11.c"
}   /* End of cg17=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[25]) fprintf(stderr, "Warning: No neutron could reach Component[25] cg17\n");
    if (mcAbsorbProp[25]) fprintf(stderr, "Warning: %g events were removed in Component[25] cg17=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[25]);
  /* User FINALLY code for component 'cg18'. */
  SIG_MESSAGE("cg18 (Finally)");
#define mccompcurname  cg18
#define mccompcurtype  Guide_gravity
#define mccompcurindex 26
#define GVars mcccg18_GVars
#define pTable mcccg18_pTable
{   /* Declarations of cg18=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg18_w1;
MCNUM h1 = mcccg18_h1;
MCNUM w2 = mcccg18_w2;
MCNUM h2 = mcccg18_h2;
MCNUM l = mcccg18_l;
MCNUM R0 = mcccg18_R0;
MCNUM Qc = mcccg18_Qc;
MCNUM alpha = mcccg18_alpha;
MCNUM m = mcccg18_m;
MCNUM W = mcccg18_W;
MCNUM nslit = mcccg18_nslit;
MCNUM d = mcccg18_d;
MCNUM mleft = mcccg18_mleft;
MCNUM mright = mcccg18_mright;
MCNUM mtop = mcccg18_mtop;
MCNUM mbottom = mcccg18_mbottom;
MCNUM nhslit = mcccg18_nhslit;
MCNUM G = mcccg18_G;
MCNUM aleft = mcccg18_aleft;
MCNUM aright = mcccg18_aright;
MCNUM atop = mcccg18_atop;
MCNUM abottom = mcccg18_abottom;
MCNUM wavy = mcccg18_wavy;
MCNUM wavy_z = mcccg18_wavy_z;
MCNUM wavy_tb = mcccg18_wavy_tb;
MCNUM wavy_lr = mcccg18_wavy_lr;
MCNUM chamfers = mcccg18_chamfers;
MCNUM chamfers_z = mcccg18_chamfers_z;
MCNUM chamfers_lr = mcccg18_chamfers_lr;
MCNUM chamfers_tb = mcccg18_chamfers_tb;
MCNUM nelements = mcccg18_nelements;
MCNUM nu = mcccg18_nu;
MCNUM phase = mcccg18_phase;
char* reflect = mcccg18_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 70722 "ILL_H15_D11.c"
}   /* End of cg18=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[26]) fprintf(stderr, "Warning: No neutron could reach Component[26] cg18\n");
    if (mcAbsorbProp[26]) fprintf(stderr, "Warning: %g events were removed in Component[26] cg18=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[26]);
  /* User FINALLY code for component 'cg19'. */
  SIG_MESSAGE("cg19 (Finally)");
#define mccompcurname  cg19
#define mccompcurtype  Guide_gravity
#define mccompcurindex 27
#define GVars mcccg19_GVars
#define pTable mcccg19_pTable
{   /* Declarations of cg19=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg19_w1;
MCNUM h1 = mcccg19_h1;
MCNUM w2 = mcccg19_w2;
MCNUM h2 = mcccg19_h2;
MCNUM l = mcccg19_l;
MCNUM R0 = mcccg19_R0;
MCNUM Qc = mcccg19_Qc;
MCNUM alpha = mcccg19_alpha;
MCNUM m = mcccg19_m;
MCNUM W = mcccg19_W;
MCNUM nslit = mcccg19_nslit;
MCNUM d = mcccg19_d;
MCNUM mleft = mcccg19_mleft;
MCNUM mright = mcccg19_mright;
MCNUM mtop = mcccg19_mtop;
MCNUM mbottom = mcccg19_mbottom;
MCNUM nhslit = mcccg19_nhslit;
MCNUM G = mcccg19_G;
MCNUM aleft = mcccg19_aleft;
MCNUM aright = mcccg19_aright;
MCNUM atop = mcccg19_atop;
MCNUM abottom = mcccg19_abottom;
MCNUM wavy = mcccg19_wavy;
MCNUM wavy_z = mcccg19_wavy_z;
MCNUM wavy_tb = mcccg19_wavy_tb;
MCNUM wavy_lr = mcccg19_wavy_lr;
MCNUM chamfers = mcccg19_chamfers;
MCNUM chamfers_z = mcccg19_chamfers_z;
MCNUM chamfers_lr = mcccg19_chamfers_lr;
MCNUM chamfers_tb = mcccg19_chamfers_tb;
MCNUM nelements = mcccg19_nelements;
MCNUM nu = mcccg19_nu;
MCNUM phase = mcccg19_phase;
char* reflect = mcccg19_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 70781 "ILL_H15_D11.c"
}   /* End of cg19=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[27]) fprintf(stderr, "Warning: No neutron could reach Component[27] cg19\n");
    if (mcAbsorbProp[27]) fprintf(stderr, "Warning: %g events were removed in Component[27] cg19=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[27]);
  /* User FINALLY code for component 'cg20'. */
  SIG_MESSAGE("cg20 (Finally)");
#define mccompcurname  cg20
#define mccompcurtype  Guide_gravity
#define mccompcurindex 28
#define GVars mcccg20_GVars
#define pTable mcccg20_pTable
{   /* Declarations of cg20=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg20_w1;
MCNUM h1 = mcccg20_h1;
MCNUM w2 = mcccg20_w2;
MCNUM h2 = mcccg20_h2;
MCNUM l = mcccg20_l;
MCNUM R0 = mcccg20_R0;
MCNUM Qc = mcccg20_Qc;
MCNUM alpha = mcccg20_alpha;
MCNUM m = mcccg20_m;
MCNUM W = mcccg20_W;
MCNUM nslit = mcccg20_nslit;
MCNUM d = mcccg20_d;
MCNUM mleft = mcccg20_mleft;
MCNUM mright = mcccg20_mright;
MCNUM mtop = mcccg20_mtop;
MCNUM mbottom = mcccg20_mbottom;
MCNUM nhslit = mcccg20_nhslit;
MCNUM G = mcccg20_G;
MCNUM aleft = mcccg20_aleft;
MCNUM aright = mcccg20_aright;
MCNUM atop = mcccg20_atop;
MCNUM abottom = mcccg20_abottom;
MCNUM wavy = mcccg20_wavy;
MCNUM wavy_z = mcccg20_wavy_z;
MCNUM wavy_tb = mcccg20_wavy_tb;
MCNUM wavy_lr = mcccg20_wavy_lr;
MCNUM chamfers = mcccg20_chamfers;
MCNUM chamfers_z = mcccg20_chamfers_z;
MCNUM chamfers_lr = mcccg20_chamfers_lr;
MCNUM chamfers_tb = mcccg20_chamfers_tb;
MCNUM nelements = mcccg20_nelements;
MCNUM nu = mcccg20_nu;
MCNUM phase = mcccg20_phase;
char* reflect = mcccg20_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 70840 "ILL_H15_D11.c"
}   /* End of cg20=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[28]) fprintf(stderr, "Warning: No neutron could reach Component[28] cg20\n");
    if (mcAbsorbProp[28]) fprintf(stderr, "Warning: %g events were removed in Component[28] cg20=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[28]);
  /* User FINALLY code for component 'cg21'. */
  SIG_MESSAGE("cg21 (Finally)");
#define mccompcurname  cg21
#define mccompcurtype  Guide_gravity
#define mccompcurindex 29
#define GVars mcccg21_GVars
#define pTable mcccg21_pTable
{   /* Declarations of cg21=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg21_w1;
MCNUM h1 = mcccg21_h1;
MCNUM w2 = mcccg21_w2;
MCNUM h2 = mcccg21_h2;
MCNUM l = mcccg21_l;
MCNUM R0 = mcccg21_R0;
MCNUM Qc = mcccg21_Qc;
MCNUM alpha = mcccg21_alpha;
MCNUM m = mcccg21_m;
MCNUM W = mcccg21_W;
MCNUM nslit = mcccg21_nslit;
MCNUM d = mcccg21_d;
MCNUM mleft = mcccg21_mleft;
MCNUM mright = mcccg21_mright;
MCNUM mtop = mcccg21_mtop;
MCNUM mbottom = mcccg21_mbottom;
MCNUM nhslit = mcccg21_nhslit;
MCNUM G = mcccg21_G;
MCNUM aleft = mcccg21_aleft;
MCNUM aright = mcccg21_aright;
MCNUM atop = mcccg21_atop;
MCNUM abottom = mcccg21_abottom;
MCNUM wavy = mcccg21_wavy;
MCNUM wavy_z = mcccg21_wavy_z;
MCNUM wavy_tb = mcccg21_wavy_tb;
MCNUM wavy_lr = mcccg21_wavy_lr;
MCNUM chamfers = mcccg21_chamfers;
MCNUM chamfers_z = mcccg21_chamfers_z;
MCNUM chamfers_lr = mcccg21_chamfers_lr;
MCNUM chamfers_tb = mcccg21_chamfers_tb;
MCNUM nelements = mcccg21_nelements;
MCNUM nu = mcccg21_nu;
MCNUM phase = mcccg21_phase;
char* reflect = mcccg21_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 70899 "ILL_H15_D11.c"
}   /* End of cg21=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[29]) fprintf(stderr, "Warning: No neutron could reach Component[29] cg21\n");
    if (mcAbsorbProp[29]) fprintf(stderr, "Warning: %g events were removed in Component[29] cg21=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[29]);
  /* User FINALLY code for component 'cg22'. */
  SIG_MESSAGE("cg22 (Finally)");
#define mccompcurname  cg22
#define mccompcurtype  Guide_gravity
#define mccompcurindex 30
#define GVars mcccg22_GVars
#define pTable mcccg22_pTable
{   /* Declarations of cg22=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg22_w1;
MCNUM h1 = mcccg22_h1;
MCNUM w2 = mcccg22_w2;
MCNUM h2 = mcccg22_h2;
MCNUM l = mcccg22_l;
MCNUM R0 = mcccg22_R0;
MCNUM Qc = mcccg22_Qc;
MCNUM alpha = mcccg22_alpha;
MCNUM m = mcccg22_m;
MCNUM W = mcccg22_W;
MCNUM nslit = mcccg22_nslit;
MCNUM d = mcccg22_d;
MCNUM mleft = mcccg22_mleft;
MCNUM mright = mcccg22_mright;
MCNUM mtop = mcccg22_mtop;
MCNUM mbottom = mcccg22_mbottom;
MCNUM nhslit = mcccg22_nhslit;
MCNUM G = mcccg22_G;
MCNUM aleft = mcccg22_aleft;
MCNUM aright = mcccg22_aright;
MCNUM atop = mcccg22_atop;
MCNUM abottom = mcccg22_abottom;
MCNUM wavy = mcccg22_wavy;
MCNUM wavy_z = mcccg22_wavy_z;
MCNUM wavy_tb = mcccg22_wavy_tb;
MCNUM wavy_lr = mcccg22_wavy_lr;
MCNUM chamfers = mcccg22_chamfers;
MCNUM chamfers_z = mcccg22_chamfers_z;
MCNUM chamfers_lr = mcccg22_chamfers_lr;
MCNUM chamfers_tb = mcccg22_chamfers_tb;
MCNUM nelements = mcccg22_nelements;
MCNUM nu = mcccg22_nu;
MCNUM phase = mcccg22_phase;
char* reflect = mcccg22_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 70958 "ILL_H15_D11.c"
}   /* End of cg22=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[30]) fprintf(stderr, "Warning: No neutron could reach Component[30] cg22\n");
    if (mcAbsorbProp[30]) fprintf(stderr, "Warning: %g events were removed in Component[30] cg22=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[30]);
  /* User FINALLY code for component 'cg23'. */
  SIG_MESSAGE("cg23 (Finally)");
#define mccompcurname  cg23
#define mccompcurtype  Guide_gravity
#define mccompcurindex 31
#define GVars mcccg23_GVars
#define pTable mcccg23_pTable
{   /* Declarations of cg23=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg23_w1;
MCNUM h1 = mcccg23_h1;
MCNUM w2 = mcccg23_w2;
MCNUM h2 = mcccg23_h2;
MCNUM l = mcccg23_l;
MCNUM R0 = mcccg23_R0;
MCNUM Qc = mcccg23_Qc;
MCNUM alpha = mcccg23_alpha;
MCNUM m = mcccg23_m;
MCNUM W = mcccg23_W;
MCNUM nslit = mcccg23_nslit;
MCNUM d = mcccg23_d;
MCNUM mleft = mcccg23_mleft;
MCNUM mright = mcccg23_mright;
MCNUM mtop = mcccg23_mtop;
MCNUM mbottom = mcccg23_mbottom;
MCNUM nhslit = mcccg23_nhslit;
MCNUM G = mcccg23_G;
MCNUM aleft = mcccg23_aleft;
MCNUM aright = mcccg23_aright;
MCNUM atop = mcccg23_atop;
MCNUM abottom = mcccg23_abottom;
MCNUM wavy = mcccg23_wavy;
MCNUM wavy_z = mcccg23_wavy_z;
MCNUM wavy_tb = mcccg23_wavy_tb;
MCNUM wavy_lr = mcccg23_wavy_lr;
MCNUM chamfers = mcccg23_chamfers;
MCNUM chamfers_z = mcccg23_chamfers_z;
MCNUM chamfers_lr = mcccg23_chamfers_lr;
MCNUM chamfers_tb = mcccg23_chamfers_tb;
MCNUM nelements = mcccg23_nelements;
MCNUM nu = mcccg23_nu;
MCNUM phase = mcccg23_phase;
char* reflect = mcccg23_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 71017 "ILL_H15_D11.c"
}   /* End of cg23=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[31]) fprintf(stderr, "Warning: No neutron could reach Component[31] cg23\n");
    if (mcAbsorbProp[31]) fprintf(stderr, "Warning: %g events were removed in Component[31] cg23=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[31]);
  /* User FINALLY code for component 'cg24'. */
  SIG_MESSAGE("cg24 (Finally)");
#define mccompcurname  cg24
#define mccompcurtype  Guide_gravity
#define mccompcurindex 32
#define GVars mcccg24_GVars
#define pTable mcccg24_pTable
{   /* Declarations of cg24=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg24_w1;
MCNUM h1 = mcccg24_h1;
MCNUM w2 = mcccg24_w2;
MCNUM h2 = mcccg24_h2;
MCNUM l = mcccg24_l;
MCNUM R0 = mcccg24_R0;
MCNUM Qc = mcccg24_Qc;
MCNUM alpha = mcccg24_alpha;
MCNUM m = mcccg24_m;
MCNUM W = mcccg24_W;
MCNUM nslit = mcccg24_nslit;
MCNUM d = mcccg24_d;
MCNUM mleft = mcccg24_mleft;
MCNUM mright = mcccg24_mright;
MCNUM mtop = mcccg24_mtop;
MCNUM mbottom = mcccg24_mbottom;
MCNUM nhslit = mcccg24_nhslit;
MCNUM G = mcccg24_G;
MCNUM aleft = mcccg24_aleft;
MCNUM aright = mcccg24_aright;
MCNUM atop = mcccg24_atop;
MCNUM abottom = mcccg24_abottom;
MCNUM wavy = mcccg24_wavy;
MCNUM wavy_z = mcccg24_wavy_z;
MCNUM wavy_tb = mcccg24_wavy_tb;
MCNUM wavy_lr = mcccg24_wavy_lr;
MCNUM chamfers = mcccg24_chamfers;
MCNUM chamfers_z = mcccg24_chamfers_z;
MCNUM chamfers_lr = mcccg24_chamfers_lr;
MCNUM chamfers_tb = mcccg24_chamfers_tb;
MCNUM nelements = mcccg24_nelements;
MCNUM nu = mcccg24_nu;
MCNUM phase = mcccg24_phase;
char* reflect = mcccg24_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 71076 "ILL_H15_D11.c"
}   /* End of cg24=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[32]) fprintf(stderr, "Warning: No neutron could reach Component[32] cg24\n");
    if (mcAbsorbProp[32]) fprintf(stderr, "Warning: %g events were removed in Component[32] cg24=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[32]);
  /* User FINALLY code for component 'cg25'. */
  SIG_MESSAGE("cg25 (Finally)");
#define mccompcurname  cg25
#define mccompcurtype  Guide_gravity
#define mccompcurindex 33
#define GVars mcccg25_GVars
#define pTable mcccg25_pTable
{   /* Declarations of cg25=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg25_w1;
MCNUM h1 = mcccg25_h1;
MCNUM w2 = mcccg25_w2;
MCNUM h2 = mcccg25_h2;
MCNUM l = mcccg25_l;
MCNUM R0 = mcccg25_R0;
MCNUM Qc = mcccg25_Qc;
MCNUM alpha = mcccg25_alpha;
MCNUM m = mcccg25_m;
MCNUM W = mcccg25_W;
MCNUM nslit = mcccg25_nslit;
MCNUM d = mcccg25_d;
MCNUM mleft = mcccg25_mleft;
MCNUM mright = mcccg25_mright;
MCNUM mtop = mcccg25_mtop;
MCNUM mbottom = mcccg25_mbottom;
MCNUM nhslit = mcccg25_nhslit;
MCNUM G = mcccg25_G;
MCNUM aleft = mcccg25_aleft;
MCNUM aright = mcccg25_aright;
MCNUM atop = mcccg25_atop;
MCNUM abottom = mcccg25_abottom;
MCNUM wavy = mcccg25_wavy;
MCNUM wavy_z = mcccg25_wavy_z;
MCNUM wavy_tb = mcccg25_wavy_tb;
MCNUM wavy_lr = mcccg25_wavy_lr;
MCNUM chamfers = mcccg25_chamfers;
MCNUM chamfers_z = mcccg25_chamfers_z;
MCNUM chamfers_lr = mcccg25_chamfers_lr;
MCNUM chamfers_tb = mcccg25_chamfers_tb;
MCNUM nelements = mcccg25_nelements;
MCNUM nu = mcccg25_nu;
MCNUM phase = mcccg25_phase;
char* reflect = mcccg25_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 71135 "ILL_H15_D11.c"
}   /* End of cg25=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[33]) fprintf(stderr, "Warning: No neutron could reach Component[33] cg25\n");
    if (mcAbsorbProp[33]) fprintf(stderr, "Warning: %g events were removed in Component[33] cg25=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[33]);
    if (!mcNCounter[34]) fprintf(stderr, "Warning: No neutron could reach Component[34] AlWindow4\n");
    if (mcAbsorbProp[34]) fprintf(stderr, "Warning: %g events were removed in Component[34] AlWindow4=Al_window()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[34]);
  /* User FINALLY code for component 'PSD_VTE'. */
  SIG_MESSAGE("PSD_VTE (Finally)");
#define mccompcurname  PSD_VTE
#define mccompcurtype  Monitor_nD
#define mccompcurindex 35
#define user1 mccPSD_VTE_user1
#define user2 mccPSD_VTE_user2
#define user3 mccPSD_VTE_user3
#define DEFS mccPSD_VTE_DEFS
#define Vars mccPSD_VTE_Vars
#define detector mccPSD_VTE_detector
#define offdata mccPSD_VTE_offdata
{   /* Declarations of PSD_VTE=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccPSD_VTE_xwidth;
MCNUM yheight = mccPSD_VTE_yheight;
MCNUM zdepth = mccPSD_VTE_zdepth;
MCNUM xmin = mccPSD_VTE_xmin;
MCNUM xmax = mccPSD_VTE_xmax;
MCNUM ymin = mccPSD_VTE_ymin;
MCNUM ymax = mccPSD_VTE_ymax;
MCNUM zmin = mccPSD_VTE_zmin;
MCNUM zmax = mccPSD_VTE_zmax;
MCNUM bins = mccPSD_VTE_bins;
MCNUM min = mccPSD_VTE_min;
MCNUM max = mccPSD_VTE_max;
MCNUM restore_neutron = mccPSD_VTE_restore_neutron;
MCNUM radius = mccPSD_VTE_radius;
char* options = mccPSD_VTE_options;
char* filename = mccPSD_VTE_filename;
char* geometry = mccPSD_VTE_geometry;
char* username1 = mccPSD_VTE_username1;
char* username2 = mccPSD_VTE_username2;
char* username3 = mccPSD_VTE_username3;
int nowritefile = mccPSD_VTE_nowritefile;
#line 490 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  /* free pointers */
  Monitor_nD_Finally(&DEFS, &Vars);
}
#line 71186 "ILL_H15_D11.c"
}   /* End of PSD_VTE=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[35]) fprintf(stderr, "Warning: No neutron could reach Component[35] PSD_VTE\n");
    if (mcAbsorbProp[35]) fprintf(stderr, "Warning: %g events were removed in Component[35] PSD_VTE=Monitor_nD()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[35]);
    if (!mcNCounter[36]) fprintf(stderr, "Warning: No neutron could reach Component[36] AlWindow5\n");
    if (mcAbsorbProp[36]) fprintf(stderr, "Warning: %g events were removed in Component[36] AlWindow5=Al_window()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[36]);
    if (!mcNCounter[37]) fprintf(stderr, "Warning: No neutron could reach Component[37] VTEtoIN6GuideStart\n");
    if (mcAbsorbProp[37]) fprintf(stderr, "Warning: %g events were removed in Component[37] VTEtoIN6GuideStart=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[37]);
  /* User FINALLY code for component 'sg1'. */
  SIG_MESSAGE("sg1 (Finally)");
#define mccompcurname  sg1
#define mccompcurtype  Guide_gravity
#define mccompcurindex 38
#define GVars mccsg1_GVars
#define pTable mccsg1_pTable
{   /* Declarations of sg1=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg1_w1;
MCNUM h1 = mccsg1_h1;
MCNUM w2 = mccsg1_w2;
MCNUM h2 = mccsg1_h2;
MCNUM l = mccsg1_l;
MCNUM R0 = mccsg1_R0;
MCNUM Qc = mccsg1_Qc;
MCNUM alpha = mccsg1_alpha;
MCNUM m = mccsg1_m;
MCNUM W = mccsg1_W;
MCNUM nslit = mccsg1_nslit;
MCNUM d = mccsg1_d;
MCNUM mleft = mccsg1_mleft;
MCNUM mright = mccsg1_mright;
MCNUM mtop = mccsg1_mtop;
MCNUM mbottom = mccsg1_mbottom;
MCNUM nhslit = mccsg1_nhslit;
MCNUM G = mccsg1_G;
MCNUM aleft = mccsg1_aleft;
MCNUM aright = mccsg1_aright;
MCNUM atop = mccsg1_atop;
MCNUM abottom = mccsg1_abottom;
MCNUM wavy = mccsg1_wavy;
MCNUM wavy_z = mccsg1_wavy_z;
MCNUM wavy_tb = mccsg1_wavy_tb;
MCNUM wavy_lr = mccsg1_wavy_lr;
MCNUM chamfers = mccsg1_chamfers;
MCNUM chamfers_z = mccsg1_chamfers_z;
MCNUM chamfers_lr = mccsg1_chamfers_lr;
MCNUM chamfers_tb = mccsg1_chamfers_tb;
MCNUM nelements = mccsg1_nelements;
MCNUM nu = mccsg1_nu;
MCNUM phase = mccsg1_phase;
char* reflect = mccsg1_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 71254 "ILL_H15_D11.c"
}   /* End of sg1=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[38]) fprintf(stderr, "Warning: No neutron could reach Component[38] sg1\n");
    if (mcAbsorbProp[38]) fprintf(stderr, "Warning: %g events were removed in Component[38] sg1=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[38]);
  /* User FINALLY code for component 'sg2'. */
  SIG_MESSAGE("sg2 (Finally)");
#define mccompcurname  sg2
#define mccompcurtype  Guide_gravity
#define mccompcurindex 39
#define GVars mccsg2_GVars
#define pTable mccsg2_pTable
{   /* Declarations of sg2=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg2_w1;
MCNUM h1 = mccsg2_h1;
MCNUM w2 = mccsg2_w2;
MCNUM h2 = mccsg2_h2;
MCNUM l = mccsg2_l;
MCNUM R0 = mccsg2_R0;
MCNUM Qc = mccsg2_Qc;
MCNUM alpha = mccsg2_alpha;
MCNUM m = mccsg2_m;
MCNUM W = mccsg2_W;
MCNUM nslit = mccsg2_nslit;
MCNUM d = mccsg2_d;
MCNUM mleft = mccsg2_mleft;
MCNUM mright = mccsg2_mright;
MCNUM mtop = mccsg2_mtop;
MCNUM mbottom = mccsg2_mbottom;
MCNUM nhslit = mccsg2_nhslit;
MCNUM G = mccsg2_G;
MCNUM aleft = mccsg2_aleft;
MCNUM aright = mccsg2_aright;
MCNUM atop = mccsg2_atop;
MCNUM abottom = mccsg2_abottom;
MCNUM wavy = mccsg2_wavy;
MCNUM wavy_z = mccsg2_wavy_z;
MCNUM wavy_tb = mccsg2_wavy_tb;
MCNUM wavy_lr = mccsg2_wavy_lr;
MCNUM chamfers = mccsg2_chamfers;
MCNUM chamfers_z = mccsg2_chamfers_z;
MCNUM chamfers_lr = mccsg2_chamfers_lr;
MCNUM chamfers_tb = mccsg2_chamfers_tb;
MCNUM nelements = mccsg2_nelements;
MCNUM nu = mccsg2_nu;
MCNUM phase = mccsg2_phase;
char* reflect = mccsg2_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 71313 "ILL_H15_D11.c"
}   /* End of sg2=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[39]) fprintf(stderr, "Warning: No neutron could reach Component[39] sg2\n");
    if (mcAbsorbProp[39]) fprintf(stderr, "Warning: %g events were removed in Component[39] sg2=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[39]);
  /* User FINALLY code for component 'sg3'. */
  SIG_MESSAGE("sg3 (Finally)");
#define mccompcurname  sg3
#define mccompcurtype  Guide_gravity
#define mccompcurindex 40
#define GVars mccsg3_GVars
#define pTable mccsg3_pTable
{   /* Declarations of sg3=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg3_w1;
MCNUM h1 = mccsg3_h1;
MCNUM w2 = mccsg3_w2;
MCNUM h2 = mccsg3_h2;
MCNUM l = mccsg3_l;
MCNUM R0 = mccsg3_R0;
MCNUM Qc = mccsg3_Qc;
MCNUM alpha = mccsg3_alpha;
MCNUM m = mccsg3_m;
MCNUM W = mccsg3_W;
MCNUM nslit = mccsg3_nslit;
MCNUM d = mccsg3_d;
MCNUM mleft = mccsg3_mleft;
MCNUM mright = mccsg3_mright;
MCNUM mtop = mccsg3_mtop;
MCNUM mbottom = mccsg3_mbottom;
MCNUM nhslit = mccsg3_nhslit;
MCNUM G = mccsg3_G;
MCNUM aleft = mccsg3_aleft;
MCNUM aright = mccsg3_aright;
MCNUM atop = mccsg3_atop;
MCNUM abottom = mccsg3_abottom;
MCNUM wavy = mccsg3_wavy;
MCNUM wavy_z = mccsg3_wavy_z;
MCNUM wavy_tb = mccsg3_wavy_tb;
MCNUM wavy_lr = mccsg3_wavy_lr;
MCNUM chamfers = mccsg3_chamfers;
MCNUM chamfers_z = mccsg3_chamfers_z;
MCNUM chamfers_lr = mccsg3_chamfers_lr;
MCNUM chamfers_tb = mccsg3_chamfers_tb;
MCNUM nelements = mccsg3_nelements;
MCNUM nu = mccsg3_nu;
MCNUM phase = mccsg3_phase;
char* reflect = mccsg3_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 71372 "ILL_H15_D11.c"
}   /* End of sg3=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[40]) fprintf(stderr, "Warning: No neutron could reach Component[40] sg3\n");
    if (mcAbsorbProp[40]) fprintf(stderr, "Warning: %g events were removed in Component[40] sg3=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[40]);
  /* User FINALLY code for component 'sg4'. */
  SIG_MESSAGE("sg4 (Finally)");
#define mccompcurname  sg4
#define mccompcurtype  Guide_gravity
#define mccompcurindex 41
#define GVars mccsg4_GVars
#define pTable mccsg4_pTable
{   /* Declarations of sg4=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg4_w1;
MCNUM h1 = mccsg4_h1;
MCNUM w2 = mccsg4_w2;
MCNUM h2 = mccsg4_h2;
MCNUM l = mccsg4_l;
MCNUM R0 = mccsg4_R0;
MCNUM Qc = mccsg4_Qc;
MCNUM alpha = mccsg4_alpha;
MCNUM m = mccsg4_m;
MCNUM W = mccsg4_W;
MCNUM nslit = mccsg4_nslit;
MCNUM d = mccsg4_d;
MCNUM mleft = mccsg4_mleft;
MCNUM mright = mccsg4_mright;
MCNUM mtop = mccsg4_mtop;
MCNUM mbottom = mccsg4_mbottom;
MCNUM nhslit = mccsg4_nhslit;
MCNUM G = mccsg4_G;
MCNUM aleft = mccsg4_aleft;
MCNUM aright = mccsg4_aright;
MCNUM atop = mccsg4_atop;
MCNUM abottom = mccsg4_abottom;
MCNUM wavy = mccsg4_wavy;
MCNUM wavy_z = mccsg4_wavy_z;
MCNUM wavy_tb = mccsg4_wavy_tb;
MCNUM wavy_lr = mccsg4_wavy_lr;
MCNUM chamfers = mccsg4_chamfers;
MCNUM chamfers_z = mccsg4_chamfers_z;
MCNUM chamfers_lr = mccsg4_chamfers_lr;
MCNUM chamfers_tb = mccsg4_chamfers_tb;
MCNUM nelements = mccsg4_nelements;
MCNUM nu = mccsg4_nu;
MCNUM phase = mccsg4_phase;
char* reflect = mccsg4_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 71431 "ILL_H15_D11.c"
}   /* End of sg4=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[41]) fprintf(stderr, "Warning: No neutron could reach Component[41] sg4\n");
    if (mcAbsorbProp[41]) fprintf(stderr, "Warning: %g events were removed in Component[41] sg4=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[41]);
  /* User FINALLY code for component 'sg5'. */
  SIG_MESSAGE("sg5 (Finally)");
#define mccompcurname  sg5
#define mccompcurtype  Guide_gravity
#define mccompcurindex 42
#define GVars mccsg5_GVars
#define pTable mccsg5_pTable
{   /* Declarations of sg5=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg5_w1;
MCNUM h1 = mccsg5_h1;
MCNUM w2 = mccsg5_w2;
MCNUM h2 = mccsg5_h2;
MCNUM l = mccsg5_l;
MCNUM R0 = mccsg5_R0;
MCNUM Qc = mccsg5_Qc;
MCNUM alpha = mccsg5_alpha;
MCNUM m = mccsg5_m;
MCNUM W = mccsg5_W;
MCNUM nslit = mccsg5_nslit;
MCNUM d = mccsg5_d;
MCNUM mleft = mccsg5_mleft;
MCNUM mright = mccsg5_mright;
MCNUM mtop = mccsg5_mtop;
MCNUM mbottom = mccsg5_mbottom;
MCNUM nhslit = mccsg5_nhslit;
MCNUM G = mccsg5_G;
MCNUM aleft = mccsg5_aleft;
MCNUM aright = mccsg5_aright;
MCNUM atop = mccsg5_atop;
MCNUM abottom = mccsg5_abottom;
MCNUM wavy = mccsg5_wavy;
MCNUM wavy_z = mccsg5_wavy_z;
MCNUM wavy_tb = mccsg5_wavy_tb;
MCNUM wavy_lr = mccsg5_wavy_lr;
MCNUM chamfers = mccsg5_chamfers;
MCNUM chamfers_z = mccsg5_chamfers_z;
MCNUM chamfers_lr = mccsg5_chamfers_lr;
MCNUM chamfers_tb = mccsg5_chamfers_tb;
MCNUM nelements = mccsg5_nelements;
MCNUM nu = mccsg5_nu;
MCNUM phase = mccsg5_phase;
char* reflect = mccsg5_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 71490 "ILL_H15_D11.c"
}   /* End of sg5=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[42]) fprintf(stderr, "Warning: No neutron could reach Component[42] sg5\n");
    if (mcAbsorbProp[42]) fprintf(stderr, "Warning: %g events were removed in Component[42] sg5=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[42]);
  /* User FINALLY code for component 'sg6'. */
  SIG_MESSAGE("sg6 (Finally)");
#define mccompcurname  sg6
#define mccompcurtype  Guide_gravity
#define mccompcurindex 43
#define GVars mccsg6_GVars
#define pTable mccsg6_pTable
{   /* Declarations of sg6=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg6_w1;
MCNUM h1 = mccsg6_h1;
MCNUM w2 = mccsg6_w2;
MCNUM h2 = mccsg6_h2;
MCNUM l = mccsg6_l;
MCNUM R0 = mccsg6_R0;
MCNUM Qc = mccsg6_Qc;
MCNUM alpha = mccsg6_alpha;
MCNUM m = mccsg6_m;
MCNUM W = mccsg6_W;
MCNUM nslit = mccsg6_nslit;
MCNUM d = mccsg6_d;
MCNUM mleft = mccsg6_mleft;
MCNUM mright = mccsg6_mright;
MCNUM mtop = mccsg6_mtop;
MCNUM mbottom = mccsg6_mbottom;
MCNUM nhslit = mccsg6_nhslit;
MCNUM G = mccsg6_G;
MCNUM aleft = mccsg6_aleft;
MCNUM aright = mccsg6_aright;
MCNUM atop = mccsg6_atop;
MCNUM abottom = mccsg6_abottom;
MCNUM wavy = mccsg6_wavy;
MCNUM wavy_z = mccsg6_wavy_z;
MCNUM wavy_tb = mccsg6_wavy_tb;
MCNUM wavy_lr = mccsg6_wavy_lr;
MCNUM chamfers = mccsg6_chamfers;
MCNUM chamfers_z = mccsg6_chamfers_z;
MCNUM chamfers_lr = mccsg6_chamfers_lr;
MCNUM chamfers_tb = mccsg6_chamfers_tb;
MCNUM nelements = mccsg6_nelements;
MCNUM nu = mccsg6_nu;
MCNUM phase = mccsg6_phase;
char* reflect = mccsg6_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 71549 "ILL_H15_D11.c"
}   /* End of sg6=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[43]) fprintf(stderr, "Warning: No neutron could reach Component[43] sg6\n");
    if (mcAbsorbProp[43]) fprintf(stderr, "Warning: %g events were removed in Component[43] sg6=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[43]);
  /* User FINALLY code for component 'sg7'. */
  SIG_MESSAGE("sg7 (Finally)");
#define mccompcurname  sg7
#define mccompcurtype  Guide_gravity
#define mccompcurindex 44
#define GVars mccsg7_GVars
#define pTable mccsg7_pTable
{   /* Declarations of sg7=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg7_w1;
MCNUM h1 = mccsg7_h1;
MCNUM w2 = mccsg7_w2;
MCNUM h2 = mccsg7_h2;
MCNUM l = mccsg7_l;
MCNUM R0 = mccsg7_R0;
MCNUM Qc = mccsg7_Qc;
MCNUM alpha = mccsg7_alpha;
MCNUM m = mccsg7_m;
MCNUM W = mccsg7_W;
MCNUM nslit = mccsg7_nslit;
MCNUM d = mccsg7_d;
MCNUM mleft = mccsg7_mleft;
MCNUM mright = mccsg7_mright;
MCNUM mtop = mccsg7_mtop;
MCNUM mbottom = mccsg7_mbottom;
MCNUM nhslit = mccsg7_nhslit;
MCNUM G = mccsg7_G;
MCNUM aleft = mccsg7_aleft;
MCNUM aright = mccsg7_aright;
MCNUM atop = mccsg7_atop;
MCNUM abottom = mccsg7_abottom;
MCNUM wavy = mccsg7_wavy;
MCNUM wavy_z = mccsg7_wavy_z;
MCNUM wavy_tb = mccsg7_wavy_tb;
MCNUM wavy_lr = mccsg7_wavy_lr;
MCNUM chamfers = mccsg7_chamfers;
MCNUM chamfers_z = mccsg7_chamfers_z;
MCNUM chamfers_lr = mccsg7_chamfers_lr;
MCNUM chamfers_tb = mccsg7_chamfers_tb;
MCNUM nelements = mccsg7_nelements;
MCNUM nu = mccsg7_nu;
MCNUM phase = mccsg7_phase;
char* reflect = mccsg7_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 71608 "ILL_H15_D11.c"
}   /* End of sg7=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[44]) fprintf(stderr, "Warning: No neutron could reach Component[44] sg7\n");
    if (mcAbsorbProp[44]) fprintf(stderr, "Warning: %g events were removed in Component[44] sg7=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[44]);
  /* User FINALLY code for component 'sg8'. */
  SIG_MESSAGE("sg8 (Finally)");
#define mccompcurname  sg8
#define mccompcurtype  Guide_gravity
#define mccompcurindex 45
#define GVars mccsg8_GVars
#define pTable mccsg8_pTable
{   /* Declarations of sg8=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg8_w1;
MCNUM h1 = mccsg8_h1;
MCNUM w2 = mccsg8_w2;
MCNUM h2 = mccsg8_h2;
MCNUM l = mccsg8_l;
MCNUM R0 = mccsg8_R0;
MCNUM Qc = mccsg8_Qc;
MCNUM alpha = mccsg8_alpha;
MCNUM m = mccsg8_m;
MCNUM W = mccsg8_W;
MCNUM nslit = mccsg8_nslit;
MCNUM d = mccsg8_d;
MCNUM mleft = mccsg8_mleft;
MCNUM mright = mccsg8_mright;
MCNUM mtop = mccsg8_mtop;
MCNUM mbottom = mccsg8_mbottom;
MCNUM nhslit = mccsg8_nhslit;
MCNUM G = mccsg8_G;
MCNUM aleft = mccsg8_aleft;
MCNUM aright = mccsg8_aright;
MCNUM atop = mccsg8_atop;
MCNUM abottom = mccsg8_abottom;
MCNUM wavy = mccsg8_wavy;
MCNUM wavy_z = mccsg8_wavy_z;
MCNUM wavy_tb = mccsg8_wavy_tb;
MCNUM wavy_lr = mccsg8_wavy_lr;
MCNUM chamfers = mccsg8_chamfers;
MCNUM chamfers_z = mccsg8_chamfers_z;
MCNUM chamfers_lr = mccsg8_chamfers_lr;
MCNUM chamfers_tb = mccsg8_chamfers_tb;
MCNUM nelements = mccsg8_nelements;
MCNUM nu = mccsg8_nu;
MCNUM phase = mccsg8_phase;
char* reflect = mccsg8_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 71667 "ILL_H15_D11.c"
}   /* End of sg8=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[45]) fprintf(stderr, "Warning: No neutron could reach Component[45] sg8\n");
    if (mcAbsorbProp[45]) fprintf(stderr, "Warning: %g events were removed in Component[45] sg8=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[45]);
  /* User FINALLY code for component 'sg9'. */
  SIG_MESSAGE("sg9 (Finally)");
#define mccompcurname  sg9
#define mccompcurtype  Guide_gravity
#define mccompcurindex 46
#define GVars mccsg9_GVars
#define pTable mccsg9_pTable
{   /* Declarations of sg9=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg9_w1;
MCNUM h1 = mccsg9_h1;
MCNUM w2 = mccsg9_w2;
MCNUM h2 = mccsg9_h2;
MCNUM l = mccsg9_l;
MCNUM R0 = mccsg9_R0;
MCNUM Qc = mccsg9_Qc;
MCNUM alpha = mccsg9_alpha;
MCNUM m = mccsg9_m;
MCNUM W = mccsg9_W;
MCNUM nslit = mccsg9_nslit;
MCNUM d = mccsg9_d;
MCNUM mleft = mccsg9_mleft;
MCNUM mright = mccsg9_mright;
MCNUM mtop = mccsg9_mtop;
MCNUM mbottom = mccsg9_mbottom;
MCNUM nhslit = mccsg9_nhslit;
MCNUM G = mccsg9_G;
MCNUM aleft = mccsg9_aleft;
MCNUM aright = mccsg9_aright;
MCNUM atop = mccsg9_atop;
MCNUM abottom = mccsg9_abottom;
MCNUM wavy = mccsg9_wavy;
MCNUM wavy_z = mccsg9_wavy_z;
MCNUM wavy_tb = mccsg9_wavy_tb;
MCNUM wavy_lr = mccsg9_wavy_lr;
MCNUM chamfers = mccsg9_chamfers;
MCNUM chamfers_z = mccsg9_chamfers_z;
MCNUM chamfers_lr = mccsg9_chamfers_lr;
MCNUM chamfers_tb = mccsg9_chamfers_tb;
MCNUM nelements = mccsg9_nelements;
MCNUM nu = mccsg9_nu;
MCNUM phase = mccsg9_phase;
char* reflect = mccsg9_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 71726 "ILL_H15_D11.c"
}   /* End of sg9=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[46]) fprintf(stderr, "Warning: No neutron could reach Component[46] sg9\n");
    if (mcAbsorbProp[46]) fprintf(stderr, "Warning: %g events were removed in Component[46] sg9=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[46]);
  /* User FINALLY code for component 'sg10'. */
  SIG_MESSAGE("sg10 (Finally)");
#define mccompcurname  sg10
#define mccompcurtype  Guide_gravity
#define mccompcurindex 47
#define GVars mccsg10_GVars
#define pTable mccsg10_pTable
{   /* Declarations of sg10=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg10_w1;
MCNUM h1 = mccsg10_h1;
MCNUM w2 = mccsg10_w2;
MCNUM h2 = mccsg10_h2;
MCNUM l = mccsg10_l;
MCNUM R0 = mccsg10_R0;
MCNUM Qc = mccsg10_Qc;
MCNUM alpha = mccsg10_alpha;
MCNUM m = mccsg10_m;
MCNUM W = mccsg10_W;
MCNUM nslit = mccsg10_nslit;
MCNUM d = mccsg10_d;
MCNUM mleft = mccsg10_mleft;
MCNUM mright = mccsg10_mright;
MCNUM mtop = mccsg10_mtop;
MCNUM mbottom = mccsg10_mbottom;
MCNUM nhslit = mccsg10_nhslit;
MCNUM G = mccsg10_G;
MCNUM aleft = mccsg10_aleft;
MCNUM aright = mccsg10_aright;
MCNUM atop = mccsg10_atop;
MCNUM abottom = mccsg10_abottom;
MCNUM wavy = mccsg10_wavy;
MCNUM wavy_z = mccsg10_wavy_z;
MCNUM wavy_tb = mccsg10_wavy_tb;
MCNUM wavy_lr = mccsg10_wavy_lr;
MCNUM chamfers = mccsg10_chamfers;
MCNUM chamfers_z = mccsg10_chamfers_z;
MCNUM chamfers_lr = mccsg10_chamfers_lr;
MCNUM chamfers_tb = mccsg10_chamfers_tb;
MCNUM nelements = mccsg10_nelements;
MCNUM nu = mccsg10_nu;
MCNUM phase = mccsg10_phase;
char* reflect = mccsg10_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 71785 "ILL_H15_D11.c"
}   /* End of sg10=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[47]) fprintf(stderr, "Warning: No neutron could reach Component[47] sg10\n");
    if (mcAbsorbProp[47]) fprintf(stderr, "Warning: %g events were removed in Component[47] sg10=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[47]);
  /* User FINALLY code for component 'sg11'. */
  SIG_MESSAGE("sg11 (Finally)");
#define mccompcurname  sg11
#define mccompcurtype  Guide_gravity
#define mccompcurindex 48
#define GVars mccsg11_GVars
#define pTable mccsg11_pTable
{   /* Declarations of sg11=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg11_w1;
MCNUM h1 = mccsg11_h1;
MCNUM w2 = mccsg11_w2;
MCNUM h2 = mccsg11_h2;
MCNUM l = mccsg11_l;
MCNUM R0 = mccsg11_R0;
MCNUM Qc = mccsg11_Qc;
MCNUM alpha = mccsg11_alpha;
MCNUM m = mccsg11_m;
MCNUM W = mccsg11_W;
MCNUM nslit = mccsg11_nslit;
MCNUM d = mccsg11_d;
MCNUM mleft = mccsg11_mleft;
MCNUM mright = mccsg11_mright;
MCNUM mtop = mccsg11_mtop;
MCNUM mbottom = mccsg11_mbottom;
MCNUM nhslit = mccsg11_nhslit;
MCNUM G = mccsg11_G;
MCNUM aleft = mccsg11_aleft;
MCNUM aright = mccsg11_aright;
MCNUM atop = mccsg11_atop;
MCNUM abottom = mccsg11_abottom;
MCNUM wavy = mccsg11_wavy;
MCNUM wavy_z = mccsg11_wavy_z;
MCNUM wavy_tb = mccsg11_wavy_tb;
MCNUM wavy_lr = mccsg11_wavy_lr;
MCNUM chamfers = mccsg11_chamfers;
MCNUM chamfers_z = mccsg11_chamfers_z;
MCNUM chamfers_lr = mccsg11_chamfers_lr;
MCNUM chamfers_tb = mccsg11_chamfers_tb;
MCNUM nelements = mccsg11_nelements;
MCNUM nu = mccsg11_nu;
MCNUM phase = mccsg11_phase;
char* reflect = mccsg11_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 71844 "ILL_H15_D11.c"
}   /* End of sg11=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[48]) fprintf(stderr, "Warning: No neutron could reach Component[48] sg11\n");
    if (mcAbsorbProp[48]) fprintf(stderr, "Warning: %g events were removed in Component[48] sg11=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[48]);
  /* User FINALLY code for component 'sg12'. */
  SIG_MESSAGE("sg12 (Finally)");
#define mccompcurname  sg12
#define mccompcurtype  Guide_gravity
#define mccompcurindex 49
#define GVars mccsg12_GVars
#define pTable mccsg12_pTable
{   /* Declarations of sg12=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg12_w1;
MCNUM h1 = mccsg12_h1;
MCNUM w2 = mccsg12_w2;
MCNUM h2 = mccsg12_h2;
MCNUM l = mccsg12_l;
MCNUM R0 = mccsg12_R0;
MCNUM Qc = mccsg12_Qc;
MCNUM alpha = mccsg12_alpha;
MCNUM m = mccsg12_m;
MCNUM W = mccsg12_W;
MCNUM nslit = mccsg12_nslit;
MCNUM d = mccsg12_d;
MCNUM mleft = mccsg12_mleft;
MCNUM mright = mccsg12_mright;
MCNUM mtop = mccsg12_mtop;
MCNUM mbottom = mccsg12_mbottom;
MCNUM nhslit = mccsg12_nhslit;
MCNUM G = mccsg12_G;
MCNUM aleft = mccsg12_aleft;
MCNUM aright = mccsg12_aright;
MCNUM atop = mccsg12_atop;
MCNUM abottom = mccsg12_abottom;
MCNUM wavy = mccsg12_wavy;
MCNUM wavy_z = mccsg12_wavy_z;
MCNUM wavy_tb = mccsg12_wavy_tb;
MCNUM wavy_lr = mccsg12_wavy_lr;
MCNUM chamfers = mccsg12_chamfers;
MCNUM chamfers_z = mccsg12_chamfers_z;
MCNUM chamfers_lr = mccsg12_chamfers_lr;
MCNUM chamfers_tb = mccsg12_chamfers_tb;
MCNUM nelements = mccsg12_nelements;
MCNUM nu = mccsg12_nu;
MCNUM phase = mccsg12_phase;
char* reflect = mccsg12_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 71903 "ILL_H15_D11.c"
}   /* End of sg12=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[49]) fprintf(stderr, "Warning: No neutron could reach Component[49] sg12\n");
    if (mcAbsorbProp[49]) fprintf(stderr, "Warning: %g events were removed in Component[49] sg12=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[49]);
  /* User FINALLY code for component 'sg13'. */
  SIG_MESSAGE("sg13 (Finally)");
#define mccompcurname  sg13
#define mccompcurtype  Guide_gravity
#define mccompcurindex 50
#define GVars mccsg13_GVars
#define pTable mccsg13_pTable
{   /* Declarations of sg13=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg13_w1;
MCNUM h1 = mccsg13_h1;
MCNUM w2 = mccsg13_w2;
MCNUM h2 = mccsg13_h2;
MCNUM l = mccsg13_l;
MCNUM R0 = mccsg13_R0;
MCNUM Qc = mccsg13_Qc;
MCNUM alpha = mccsg13_alpha;
MCNUM m = mccsg13_m;
MCNUM W = mccsg13_W;
MCNUM nslit = mccsg13_nslit;
MCNUM d = mccsg13_d;
MCNUM mleft = mccsg13_mleft;
MCNUM mright = mccsg13_mright;
MCNUM mtop = mccsg13_mtop;
MCNUM mbottom = mccsg13_mbottom;
MCNUM nhslit = mccsg13_nhslit;
MCNUM G = mccsg13_G;
MCNUM aleft = mccsg13_aleft;
MCNUM aright = mccsg13_aright;
MCNUM atop = mccsg13_atop;
MCNUM abottom = mccsg13_abottom;
MCNUM wavy = mccsg13_wavy;
MCNUM wavy_z = mccsg13_wavy_z;
MCNUM wavy_tb = mccsg13_wavy_tb;
MCNUM wavy_lr = mccsg13_wavy_lr;
MCNUM chamfers = mccsg13_chamfers;
MCNUM chamfers_z = mccsg13_chamfers_z;
MCNUM chamfers_lr = mccsg13_chamfers_lr;
MCNUM chamfers_tb = mccsg13_chamfers_tb;
MCNUM nelements = mccsg13_nelements;
MCNUM nu = mccsg13_nu;
MCNUM phase = mccsg13_phase;
char* reflect = mccsg13_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 71962 "ILL_H15_D11.c"
}   /* End of sg13=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[50]) fprintf(stderr, "Warning: No neutron could reach Component[50] sg13\n");
    if (mcAbsorbProp[50]) fprintf(stderr, "Warning: %g events were removed in Component[50] sg13=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[50]);
  /* User FINALLY code for component 'sg14'. */
  SIG_MESSAGE("sg14 (Finally)");
#define mccompcurname  sg14
#define mccompcurtype  Guide_gravity
#define mccompcurindex 51
#define GVars mccsg14_GVars
#define pTable mccsg14_pTable
{   /* Declarations of sg14=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg14_w1;
MCNUM h1 = mccsg14_h1;
MCNUM w2 = mccsg14_w2;
MCNUM h2 = mccsg14_h2;
MCNUM l = mccsg14_l;
MCNUM R0 = mccsg14_R0;
MCNUM Qc = mccsg14_Qc;
MCNUM alpha = mccsg14_alpha;
MCNUM m = mccsg14_m;
MCNUM W = mccsg14_W;
MCNUM nslit = mccsg14_nslit;
MCNUM d = mccsg14_d;
MCNUM mleft = mccsg14_mleft;
MCNUM mright = mccsg14_mright;
MCNUM mtop = mccsg14_mtop;
MCNUM mbottom = mccsg14_mbottom;
MCNUM nhslit = mccsg14_nhslit;
MCNUM G = mccsg14_G;
MCNUM aleft = mccsg14_aleft;
MCNUM aright = mccsg14_aright;
MCNUM atop = mccsg14_atop;
MCNUM abottom = mccsg14_abottom;
MCNUM wavy = mccsg14_wavy;
MCNUM wavy_z = mccsg14_wavy_z;
MCNUM wavy_tb = mccsg14_wavy_tb;
MCNUM wavy_lr = mccsg14_wavy_lr;
MCNUM chamfers = mccsg14_chamfers;
MCNUM chamfers_z = mccsg14_chamfers_z;
MCNUM chamfers_lr = mccsg14_chamfers_lr;
MCNUM chamfers_tb = mccsg14_chamfers_tb;
MCNUM nelements = mccsg14_nelements;
MCNUM nu = mccsg14_nu;
MCNUM phase = mccsg14_phase;
char* reflect = mccsg14_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 72021 "ILL_H15_D11.c"
}   /* End of sg14=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[51]) fprintf(stderr, "Warning: No neutron could reach Component[51] sg14\n");
    if (mcAbsorbProp[51]) fprintf(stderr, "Warning: %g events were removed in Component[51] sg14=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[51]);
  /* User FINALLY code for component 'sg15'. */
  SIG_MESSAGE("sg15 (Finally)");
#define mccompcurname  sg15
#define mccompcurtype  Guide_gravity
#define mccompcurindex 52
#define GVars mccsg15_GVars
#define pTable mccsg15_pTable
{   /* Declarations of sg15=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg15_w1;
MCNUM h1 = mccsg15_h1;
MCNUM w2 = mccsg15_w2;
MCNUM h2 = mccsg15_h2;
MCNUM l = mccsg15_l;
MCNUM R0 = mccsg15_R0;
MCNUM Qc = mccsg15_Qc;
MCNUM alpha = mccsg15_alpha;
MCNUM m = mccsg15_m;
MCNUM W = mccsg15_W;
MCNUM nslit = mccsg15_nslit;
MCNUM d = mccsg15_d;
MCNUM mleft = mccsg15_mleft;
MCNUM mright = mccsg15_mright;
MCNUM mtop = mccsg15_mtop;
MCNUM mbottom = mccsg15_mbottom;
MCNUM nhslit = mccsg15_nhslit;
MCNUM G = mccsg15_G;
MCNUM aleft = mccsg15_aleft;
MCNUM aright = mccsg15_aright;
MCNUM atop = mccsg15_atop;
MCNUM abottom = mccsg15_abottom;
MCNUM wavy = mccsg15_wavy;
MCNUM wavy_z = mccsg15_wavy_z;
MCNUM wavy_tb = mccsg15_wavy_tb;
MCNUM wavy_lr = mccsg15_wavy_lr;
MCNUM chamfers = mccsg15_chamfers;
MCNUM chamfers_z = mccsg15_chamfers_z;
MCNUM chamfers_lr = mccsg15_chamfers_lr;
MCNUM chamfers_tb = mccsg15_chamfers_tb;
MCNUM nelements = mccsg15_nelements;
MCNUM nu = mccsg15_nu;
MCNUM phase = mccsg15_phase;
char* reflect = mccsg15_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 72080 "ILL_H15_D11.c"
}   /* End of sg15=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[52]) fprintf(stderr, "Warning: No neutron could reach Component[52] sg15\n");
    if (mcAbsorbProp[52]) fprintf(stderr, "Warning: %g events were removed in Component[52] sg15=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[52]);
  /* User FINALLY code for component 'sg16'. */
  SIG_MESSAGE("sg16 (Finally)");
#define mccompcurname  sg16
#define mccompcurtype  Guide_gravity
#define mccompcurindex 53
#define GVars mccsg16_GVars
#define pTable mccsg16_pTable
{   /* Declarations of sg16=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg16_w1;
MCNUM h1 = mccsg16_h1;
MCNUM w2 = mccsg16_w2;
MCNUM h2 = mccsg16_h2;
MCNUM l = mccsg16_l;
MCNUM R0 = mccsg16_R0;
MCNUM Qc = mccsg16_Qc;
MCNUM alpha = mccsg16_alpha;
MCNUM m = mccsg16_m;
MCNUM W = mccsg16_W;
MCNUM nslit = mccsg16_nslit;
MCNUM d = mccsg16_d;
MCNUM mleft = mccsg16_mleft;
MCNUM mright = mccsg16_mright;
MCNUM mtop = mccsg16_mtop;
MCNUM mbottom = mccsg16_mbottom;
MCNUM nhslit = mccsg16_nhslit;
MCNUM G = mccsg16_G;
MCNUM aleft = mccsg16_aleft;
MCNUM aright = mccsg16_aright;
MCNUM atop = mccsg16_atop;
MCNUM abottom = mccsg16_abottom;
MCNUM wavy = mccsg16_wavy;
MCNUM wavy_z = mccsg16_wavy_z;
MCNUM wavy_tb = mccsg16_wavy_tb;
MCNUM wavy_lr = mccsg16_wavy_lr;
MCNUM chamfers = mccsg16_chamfers;
MCNUM chamfers_z = mccsg16_chamfers_z;
MCNUM chamfers_lr = mccsg16_chamfers_lr;
MCNUM chamfers_tb = mccsg16_chamfers_tb;
MCNUM nelements = mccsg16_nelements;
MCNUM nu = mccsg16_nu;
MCNUM phase = mccsg16_phase;
char* reflect = mccsg16_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 72139 "ILL_H15_D11.c"
}   /* End of sg16=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[53]) fprintf(stderr, "Warning: No neutron could reach Component[53] sg16\n");
    if (mcAbsorbProp[53]) fprintf(stderr, "Warning: %g events were removed in Component[53] sg16=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[53]);
  /* User FINALLY code for component 'sg17'. */
  SIG_MESSAGE("sg17 (Finally)");
#define mccompcurname  sg17
#define mccompcurtype  Guide_gravity
#define mccompcurindex 54
#define GVars mccsg17_GVars
#define pTable mccsg17_pTable
{   /* Declarations of sg17=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg17_w1;
MCNUM h1 = mccsg17_h1;
MCNUM w2 = mccsg17_w2;
MCNUM h2 = mccsg17_h2;
MCNUM l = mccsg17_l;
MCNUM R0 = mccsg17_R0;
MCNUM Qc = mccsg17_Qc;
MCNUM alpha = mccsg17_alpha;
MCNUM m = mccsg17_m;
MCNUM W = mccsg17_W;
MCNUM nslit = mccsg17_nslit;
MCNUM d = mccsg17_d;
MCNUM mleft = mccsg17_mleft;
MCNUM mright = mccsg17_mright;
MCNUM mtop = mccsg17_mtop;
MCNUM mbottom = mccsg17_mbottom;
MCNUM nhslit = mccsg17_nhslit;
MCNUM G = mccsg17_G;
MCNUM aleft = mccsg17_aleft;
MCNUM aright = mccsg17_aright;
MCNUM atop = mccsg17_atop;
MCNUM abottom = mccsg17_abottom;
MCNUM wavy = mccsg17_wavy;
MCNUM wavy_z = mccsg17_wavy_z;
MCNUM wavy_tb = mccsg17_wavy_tb;
MCNUM wavy_lr = mccsg17_wavy_lr;
MCNUM chamfers = mccsg17_chamfers;
MCNUM chamfers_z = mccsg17_chamfers_z;
MCNUM chamfers_lr = mccsg17_chamfers_lr;
MCNUM chamfers_tb = mccsg17_chamfers_tb;
MCNUM nelements = mccsg17_nelements;
MCNUM nu = mccsg17_nu;
MCNUM phase = mccsg17_phase;
char* reflect = mccsg17_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 72198 "ILL_H15_D11.c"
}   /* End of sg17=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[54]) fprintf(stderr, "Warning: No neutron could reach Component[54] sg17\n");
    if (mcAbsorbProp[54]) fprintf(stderr, "Warning: %g events were removed in Component[54] sg17=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[54]);
  /* User FINALLY code for component 'sg18'. */
  SIG_MESSAGE("sg18 (Finally)");
#define mccompcurname  sg18
#define mccompcurtype  Guide_gravity
#define mccompcurindex 55
#define GVars mccsg18_GVars
#define pTable mccsg18_pTable
{   /* Declarations of sg18=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg18_w1;
MCNUM h1 = mccsg18_h1;
MCNUM w2 = mccsg18_w2;
MCNUM h2 = mccsg18_h2;
MCNUM l = mccsg18_l;
MCNUM R0 = mccsg18_R0;
MCNUM Qc = mccsg18_Qc;
MCNUM alpha = mccsg18_alpha;
MCNUM m = mccsg18_m;
MCNUM W = mccsg18_W;
MCNUM nslit = mccsg18_nslit;
MCNUM d = mccsg18_d;
MCNUM mleft = mccsg18_mleft;
MCNUM mright = mccsg18_mright;
MCNUM mtop = mccsg18_mtop;
MCNUM mbottom = mccsg18_mbottom;
MCNUM nhslit = mccsg18_nhslit;
MCNUM G = mccsg18_G;
MCNUM aleft = mccsg18_aleft;
MCNUM aright = mccsg18_aright;
MCNUM atop = mccsg18_atop;
MCNUM abottom = mccsg18_abottom;
MCNUM wavy = mccsg18_wavy;
MCNUM wavy_z = mccsg18_wavy_z;
MCNUM wavy_tb = mccsg18_wavy_tb;
MCNUM wavy_lr = mccsg18_wavy_lr;
MCNUM chamfers = mccsg18_chamfers;
MCNUM chamfers_z = mccsg18_chamfers_z;
MCNUM chamfers_lr = mccsg18_chamfers_lr;
MCNUM chamfers_tb = mccsg18_chamfers_tb;
MCNUM nelements = mccsg18_nelements;
MCNUM nu = mccsg18_nu;
MCNUM phase = mccsg18_phase;
char* reflect = mccsg18_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 72257 "ILL_H15_D11.c"
}   /* End of sg18=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[55]) fprintf(stderr, "Warning: No neutron could reach Component[55] sg18\n");
    if (mcAbsorbProp[55]) fprintf(stderr, "Warning: %g events were removed in Component[55] sg18=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[55]);
  /* User FINALLY code for component 'sg19'. */
  SIG_MESSAGE("sg19 (Finally)");
#define mccompcurname  sg19
#define mccompcurtype  Guide_gravity
#define mccompcurindex 56
#define GVars mccsg19_GVars
#define pTable mccsg19_pTable
{   /* Declarations of sg19=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg19_w1;
MCNUM h1 = mccsg19_h1;
MCNUM w2 = mccsg19_w2;
MCNUM h2 = mccsg19_h2;
MCNUM l = mccsg19_l;
MCNUM R0 = mccsg19_R0;
MCNUM Qc = mccsg19_Qc;
MCNUM alpha = mccsg19_alpha;
MCNUM m = mccsg19_m;
MCNUM W = mccsg19_W;
MCNUM nslit = mccsg19_nslit;
MCNUM d = mccsg19_d;
MCNUM mleft = mccsg19_mleft;
MCNUM mright = mccsg19_mright;
MCNUM mtop = mccsg19_mtop;
MCNUM mbottom = mccsg19_mbottom;
MCNUM nhslit = mccsg19_nhslit;
MCNUM G = mccsg19_G;
MCNUM aleft = mccsg19_aleft;
MCNUM aright = mccsg19_aright;
MCNUM atop = mccsg19_atop;
MCNUM abottom = mccsg19_abottom;
MCNUM wavy = mccsg19_wavy;
MCNUM wavy_z = mccsg19_wavy_z;
MCNUM wavy_tb = mccsg19_wavy_tb;
MCNUM wavy_lr = mccsg19_wavy_lr;
MCNUM chamfers = mccsg19_chamfers;
MCNUM chamfers_z = mccsg19_chamfers_z;
MCNUM chamfers_lr = mccsg19_chamfers_lr;
MCNUM chamfers_tb = mccsg19_chamfers_tb;
MCNUM nelements = mccsg19_nelements;
MCNUM nu = mccsg19_nu;
MCNUM phase = mccsg19_phase;
char* reflect = mccsg19_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 72316 "ILL_H15_D11.c"
}   /* End of sg19=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[56]) fprintf(stderr, "Warning: No neutron could reach Component[56] sg19\n");
    if (mcAbsorbProp[56]) fprintf(stderr, "Warning: %g events were removed in Component[56] sg19=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[56]);
  /* User FINALLY code for component 'sg20'. */
  SIG_MESSAGE("sg20 (Finally)");
#define mccompcurname  sg20
#define mccompcurtype  Guide_gravity
#define mccompcurindex 57
#define GVars mccsg20_GVars
#define pTable mccsg20_pTable
{   /* Declarations of sg20=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg20_w1;
MCNUM h1 = mccsg20_h1;
MCNUM w2 = mccsg20_w2;
MCNUM h2 = mccsg20_h2;
MCNUM l = mccsg20_l;
MCNUM R0 = mccsg20_R0;
MCNUM Qc = mccsg20_Qc;
MCNUM alpha = mccsg20_alpha;
MCNUM m = mccsg20_m;
MCNUM W = mccsg20_W;
MCNUM nslit = mccsg20_nslit;
MCNUM d = mccsg20_d;
MCNUM mleft = mccsg20_mleft;
MCNUM mright = mccsg20_mright;
MCNUM mtop = mccsg20_mtop;
MCNUM mbottom = mccsg20_mbottom;
MCNUM nhslit = mccsg20_nhslit;
MCNUM G = mccsg20_G;
MCNUM aleft = mccsg20_aleft;
MCNUM aright = mccsg20_aright;
MCNUM atop = mccsg20_atop;
MCNUM abottom = mccsg20_abottom;
MCNUM wavy = mccsg20_wavy;
MCNUM wavy_z = mccsg20_wavy_z;
MCNUM wavy_tb = mccsg20_wavy_tb;
MCNUM wavy_lr = mccsg20_wavy_lr;
MCNUM chamfers = mccsg20_chamfers;
MCNUM chamfers_z = mccsg20_chamfers_z;
MCNUM chamfers_lr = mccsg20_chamfers_lr;
MCNUM chamfers_tb = mccsg20_chamfers_tb;
MCNUM nelements = mccsg20_nelements;
MCNUM nu = mccsg20_nu;
MCNUM phase = mccsg20_phase;
char* reflect = mccsg20_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 72375 "ILL_H15_D11.c"
}   /* End of sg20=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[57]) fprintf(stderr, "Warning: No neutron could reach Component[57] sg20\n");
    if (mcAbsorbProp[57]) fprintf(stderr, "Warning: %g events were removed in Component[57] sg20=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[57]);
  /* User FINALLY code for component 'sg21'. */
  SIG_MESSAGE("sg21 (Finally)");
#define mccompcurname  sg21
#define mccompcurtype  Guide_gravity
#define mccompcurindex 58
#define GVars mccsg21_GVars
#define pTable mccsg21_pTable
{   /* Declarations of sg21=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg21_w1;
MCNUM h1 = mccsg21_h1;
MCNUM w2 = mccsg21_w2;
MCNUM h2 = mccsg21_h2;
MCNUM l = mccsg21_l;
MCNUM R0 = mccsg21_R0;
MCNUM Qc = mccsg21_Qc;
MCNUM alpha = mccsg21_alpha;
MCNUM m = mccsg21_m;
MCNUM W = mccsg21_W;
MCNUM nslit = mccsg21_nslit;
MCNUM d = mccsg21_d;
MCNUM mleft = mccsg21_mleft;
MCNUM mright = mccsg21_mright;
MCNUM mtop = mccsg21_mtop;
MCNUM mbottom = mccsg21_mbottom;
MCNUM nhslit = mccsg21_nhslit;
MCNUM G = mccsg21_G;
MCNUM aleft = mccsg21_aleft;
MCNUM aright = mccsg21_aright;
MCNUM atop = mccsg21_atop;
MCNUM abottom = mccsg21_abottom;
MCNUM wavy = mccsg21_wavy;
MCNUM wavy_z = mccsg21_wavy_z;
MCNUM wavy_tb = mccsg21_wavy_tb;
MCNUM wavy_lr = mccsg21_wavy_lr;
MCNUM chamfers = mccsg21_chamfers;
MCNUM chamfers_z = mccsg21_chamfers_z;
MCNUM chamfers_lr = mccsg21_chamfers_lr;
MCNUM chamfers_tb = mccsg21_chamfers_tb;
MCNUM nelements = mccsg21_nelements;
MCNUM nu = mccsg21_nu;
MCNUM phase = mccsg21_phase;
char* reflect = mccsg21_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 72434 "ILL_H15_D11.c"
}   /* End of sg21=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[58]) fprintf(stderr, "Warning: No neutron could reach Component[58] sg21\n");
    if (mcAbsorbProp[58]) fprintf(stderr, "Warning: %g events were removed in Component[58] sg21=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[58]);
  /* User FINALLY code for component 'sg22'. */
  SIG_MESSAGE("sg22 (Finally)");
#define mccompcurname  sg22
#define mccompcurtype  Guide_gravity
#define mccompcurindex 59
#define GVars mccsg22_GVars
#define pTable mccsg22_pTable
{   /* Declarations of sg22=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg22_w1;
MCNUM h1 = mccsg22_h1;
MCNUM w2 = mccsg22_w2;
MCNUM h2 = mccsg22_h2;
MCNUM l = mccsg22_l;
MCNUM R0 = mccsg22_R0;
MCNUM Qc = mccsg22_Qc;
MCNUM alpha = mccsg22_alpha;
MCNUM m = mccsg22_m;
MCNUM W = mccsg22_W;
MCNUM nslit = mccsg22_nslit;
MCNUM d = mccsg22_d;
MCNUM mleft = mccsg22_mleft;
MCNUM mright = mccsg22_mright;
MCNUM mtop = mccsg22_mtop;
MCNUM mbottom = mccsg22_mbottom;
MCNUM nhslit = mccsg22_nhslit;
MCNUM G = mccsg22_G;
MCNUM aleft = mccsg22_aleft;
MCNUM aright = mccsg22_aright;
MCNUM atop = mccsg22_atop;
MCNUM abottom = mccsg22_abottom;
MCNUM wavy = mccsg22_wavy;
MCNUM wavy_z = mccsg22_wavy_z;
MCNUM wavy_tb = mccsg22_wavy_tb;
MCNUM wavy_lr = mccsg22_wavy_lr;
MCNUM chamfers = mccsg22_chamfers;
MCNUM chamfers_z = mccsg22_chamfers_z;
MCNUM chamfers_lr = mccsg22_chamfers_lr;
MCNUM chamfers_tb = mccsg22_chamfers_tb;
MCNUM nelements = mccsg22_nelements;
MCNUM nu = mccsg22_nu;
MCNUM phase = mccsg22_phase;
char* reflect = mccsg22_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 72493 "ILL_H15_D11.c"
}   /* End of sg22=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[59]) fprintf(stderr, "Warning: No neutron could reach Component[59] sg22\n");
    if (mcAbsorbProp[59]) fprintf(stderr, "Warning: %g events were removed in Component[59] sg22=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[59]);
    if (!mcNCounter[60]) fprintf(stderr, "Warning: No neutron could reach Component[60] AlWindow6\n");
    if (mcAbsorbProp[60]) fprintf(stderr, "Warning: %g events were removed in Component[60] AlWindow6=Al_window()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[60]);
  /* User FINALLY code for component 'PSD_IN6'. */
  SIG_MESSAGE("PSD_IN6 (Finally)");
#define mccompcurname  PSD_IN6
#define mccompcurtype  Monitor_nD
#define mccompcurindex 61
#define user1 mccPSD_IN6_user1
#define user2 mccPSD_IN6_user2
#define user3 mccPSD_IN6_user3
#define DEFS mccPSD_IN6_DEFS
#define Vars mccPSD_IN6_Vars
#define detector mccPSD_IN6_detector
#define offdata mccPSD_IN6_offdata
{   /* Declarations of PSD_IN6=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccPSD_IN6_xwidth;
MCNUM yheight = mccPSD_IN6_yheight;
MCNUM zdepth = mccPSD_IN6_zdepth;
MCNUM xmin = mccPSD_IN6_xmin;
MCNUM xmax = mccPSD_IN6_xmax;
MCNUM ymin = mccPSD_IN6_ymin;
MCNUM ymax = mccPSD_IN6_ymax;
MCNUM zmin = mccPSD_IN6_zmin;
MCNUM zmax = mccPSD_IN6_zmax;
MCNUM bins = mccPSD_IN6_bins;
MCNUM min = mccPSD_IN6_min;
MCNUM max = mccPSD_IN6_max;
MCNUM restore_neutron = mccPSD_IN6_restore_neutron;
MCNUM radius = mccPSD_IN6_radius;
char* options = mccPSD_IN6_options;
char* filename = mccPSD_IN6_filename;
char* geometry = mccPSD_IN6_geometry;
char* username1 = mccPSD_IN6_username1;
char* username2 = mccPSD_IN6_username2;
char* username3 = mccPSD_IN6_username3;
int nowritefile = mccPSD_IN6_nowritefile;
#line 490 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  /* free pointers */
  Monitor_nD_Finally(&DEFS, &Vars);
}
#line 72544 "ILL_H15_D11.c"
}   /* End of PSD_IN6=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[61]) fprintf(stderr, "Warning: No neutron could reach Component[61] PSD_IN6\n");
    if (mcAbsorbProp[61]) fprintf(stderr, "Warning: %g events were removed in Component[61] PSD_IN6=Monitor_nD()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[61]);
    if (!mcNCounter[62]) fprintf(stderr, "Warning: No neutron could reach Component[62] AlWindow7\n");
    if (mcAbsorbProp[62]) fprintf(stderr, "Warning: %g events were removed in Component[62] AlWindow7=Al_window()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[62]);
    if (!mcNCounter[63]) fprintf(stderr, "Warning: No neutron could reach Component[63] IN6toD7GuideStart\n");
    if (mcAbsorbProp[63]) fprintf(stderr, "Warning: %g events were removed in Component[63] IN6toD7GuideStart=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[63]);
  /* User FINALLY code for component 'sg23'. */
  SIG_MESSAGE("sg23 (Finally)");
#define mccompcurname  sg23
#define mccompcurtype  Guide_gravity
#define mccompcurindex 64
#define GVars mccsg23_GVars
#define pTable mccsg23_pTable
{   /* Declarations of sg23=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg23_w1;
MCNUM h1 = mccsg23_h1;
MCNUM w2 = mccsg23_w2;
MCNUM h2 = mccsg23_h2;
MCNUM l = mccsg23_l;
MCNUM R0 = mccsg23_R0;
MCNUM Qc = mccsg23_Qc;
MCNUM alpha = mccsg23_alpha;
MCNUM m = mccsg23_m;
MCNUM W = mccsg23_W;
MCNUM nslit = mccsg23_nslit;
MCNUM d = mccsg23_d;
MCNUM mleft = mccsg23_mleft;
MCNUM mright = mccsg23_mright;
MCNUM mtop = mccsg23_mtop;
MCNUM mbottom = mccsg23_mbottom;
MCNUM nhslit = mccsg23_nhslit;
MCNUM G = mccsg23_G;
MCNUM aleft = mccsg23_aleft;
MCNUM aright = mccsg23_aright;
MCNUM atop = mccsg23_atop;
MCNUM abottom = mccsg23_abottom;
MCNUM wavy = mccsg23_wavy;
MCNUM wavy_z = mccsg23_wavy_z;
MCNUM wavy_tb = mccsg23_wavy_tb;
MCNUM wavy_lr = mccsg23_wavy_lr;
MCNUM chamfers = mccsg23_chamfers;
MCNUM chamfers_z = mccsg23_chamfers_z;
MCNUM chamfers_lr = mccsg23_chamfers_lr;
MCNUM chamfers_tb = mccsg23_chamfers_tb;
MCNUM nelements = mccsg23_nelements;
MCNUM nu = mccsg23_nu;
MCNUM phase = mccsg23_phase;
char* reflect = mccsg23_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 72612 "ILL_H15_D11.c"
}   /* End of sg23=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[64]) fprintf(stderr, "Warning: No neutron could reach Component[64] sg23\n");
    if (mcAbsorbProp[64]) fprintf(stderr, "Warning: %g events were removed in Component[64] sg23=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[64]);
  /* User FINALLY code for component 'sg24'. */
  SIG_MESSAGE("sg24 (Finally)");
#define mccompcurname  sg24
#define mccompcurtype  Guide_gravity
#define mccompcurindex 65
#define GVars mccsg24_GVars
#define pTable mccsg24_pTable
{   /* Declarations of sg24=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg24_w1;
MCNUM h1 = mccsg24_h1;
MCNUM w2 = mccsg24_w2;
MCNUM h2 = mccsg24_h2;
MCNUM l = mccsg24_l;
MCNUM R0 = mccsg24_R0;
MCNUM Qc = mccsg24_Qc;
MCNUM alpha = mccsg24_alpha;
MCNUM m = mccsg24_m;
MCNUM W = mccsg24_W;
MCNUM nslit = mccsg24_nslit;
MCNUM d = mccsg24_d;
MCNUM mleft = mccsg24_mleft;
MCNUM mright = mccsg24_mright;
MCNUM mtop = mccsg24_mtop;
MCNUM mbottom = mccsg24_mbottom;
MCNUM nhslit = mccsg24_nhslit;
MCNUM G = mccsg24_G;
MCNUM aleft = mccsg24_aleft;
MCNUM aright = mccsg24_aright;
MCNUM atop = mccsg24_atop;
MCNUM abottom = mccsg24_abottom;
MCNUM wavy = mccsg24_wavy;
MCNUM wavy_z = mccsg24_wavy_z;
MCNUM wavy_tb = mccsg24_wavy_tb;
MCNUM wavy_lr = mccsg24_wavy_lr;
MCNUM chamfers = mccsg24_chamfers;
MCNUM chamfers_z = mccsg24_chamfers_z;
MCNUM chamfers_lr = mccsg24_chamfers_lr;
MCNUM chamfers_tb = mccsg24_chamfers_tb;
MCNUM nelements = mccsg24_nelements;
MCNUM nu = mccsg24_nu;
MCNUM phase = mccsg24_phase;
char* reflect = mccsg24_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 72671 "ILL_H15_D11.c"
}   /* End of sg24=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[65]) fprintf(stderr, "Warning: No neutron could reach Component[65] sg24\n");
    if (mcAbsorbProp[65]) fprintf(stderr, "Warning: %g events were removed in Component[65] sg24=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[65]);
  /* User FINALLY code for component 'sg25'. */
  SIG_MESSAGE("sg25 (Finally)");
#define mccompcurname  sg25
#define mccompcurtype  Guide_gravity
#define mccompcurindex 66
#define GVars mccsg25_GVars
#define pTable mccsg25_pTable
{   /* Declarations of sg25=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg25_w1;
MCNUM h1 = mccsg25_h1;
MCNUM w2 = mccsg25_w2;
MCNUM h2 = mccsg25_h2;
MCNUM l = mccsg25_l;
MCNUM R0 = mccsg25_R0;
MCNUM Qc = mccsg25_Qc;
MCNUM alpha = mccsg25_alpha;
MCNUM m = mccsg25_m;
MCNUM W = mccsg25_W;
MCNUM nslit = mccsg25_nslit;
MCNUM d = mccsg25_d;
MCNUM mleft = mccsg25_mleft;
MCNUM mright = mccsg25_mright;
MCNUM mtop = mccsg25_mtop;
MCNUM mbottom = mccsg25_mbottom;
MCNUM nhslit = mccsg25_nhslit;
MCNUM G = mccsg25_G;
MCNUM aleft = mccsg25_aleft;
MCNUM aright = mccsg25_aright;
MCNUM atop = mccsg25_atop;
MCNUM abottom = mccsg25_abottom;
MCNUM wavy = mccsg25_wavy;
MCNUM wavy_z = mccsg25_wavy_z;
MCNUM wavy_tb = mccsg25_wavy_tb;
MCNUM wavy_lr = mccsg25_wavy_lr;
MCNUM chamfers = mccsg25_chamfers;
MCNUM chamfers_z = mccsg25_chamfers_z;
MCNUM chamfers_lr = mccsg25_chamfers_lr;
MCNUM chamfers_tb = mccsg25_chamfers_tb;
MCNUM nelements = mccsg25_nelements;
MCNUM nu = mccsg25_nu;
MCNUM phase = mccsg25_phase;
char* reflect = mccsg25_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 72730 "ILL_H15_D11.c"
}   /* End of sg25=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[66]) fprintf(stderr, "Warning: No neutron could reach Component[66] sg25\n");
    if (mcAbsorbProp[66]) fprintf(stderr, "Warning: %g events were removed in Component[66] sg25=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[66]);
  /* User FINALLY code for component 'sg26'. */
  SIG_MESSAGE("sg26 (Finally)");
#define mccompcurname  sg26
#define mccompcurtype  Guide_gravity
#define mccompcurindex 67
#define GVars mccsg26_GVars
#define pTable mccsg26_pTable
{   /* Declarations of sg26=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg26_w1;
MCNUM h1 = mccsg26_h1;
MCNUM w2 = mccsg26_w2;
MCNUM h2 = mccsg26_h2;
MCNUM l = mccsg26_l;
MCNUM R0 = mccsg26_R0;
MCNUM Qc = mccsg26_Qc;
MCNUM alpha = mccsg26_alpha;
MCNUM m = mccsg26_m;
MCNUM W = mccsg26_W;
MCNUM nslit = mccsg26_nslit;
MCNUM d = mccsg26_d;
MCNUM mleft = mccsg26_mleft;
MCNUM mright = mccsg26_mright;
MCNUM mtop = mccsg26_mtop;
MCNUM mbottom = mccsg26_mbottom;
MCNUM nhslit = mccsg26_nhslit;
MCNUM G = mccsg26_G;
MCNUM aleft = mccsg26_aleft;
MCNUM aright = mccsg26_aright;
MCNUM atop = mccsg26_atop;
MCNUM abottom = mccsg26_abottom;
MCNUM wavy = mccsg26_wavy;
MCNUM wavy_z = mccsg26_wavy_z;
MCNUM wavy_tb = mccsg26_wavy_tb;
MCNUM wavy_lr = mccsg26_wavy_lr;
MCNUM chamfers = mccsg26_chamfers;
MCNUM chamfers_z = mccsg26_chamfers_z;
MCNUM chamfers_lr = mccsg26_chamfers_lr;
MCNUM chamfers_tb = mccsg26_chamfers_tb;
MCNUM nelements = mccsg26_nelements;
MCNUM nu = mccsg26_nu;
MCNUM phase = mccsg26_phase;
char* reflect = mccsg26_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 72789 "ILL_H15_D11.c"
}   /* End of sg26=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[67]) fprintf(stderr, "Warning: No neutron could reach Component[67] sg26\n");
    if (mcAbsorbProp[67]) fprintf(stderr, "Warning: %g events were removed in Component[67] sg26=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[67]);
  /* User FINALLY code for component 'sg27'. */
  SIG_MESSAGE("sg27 (Finally)");
#define mccompcurname  sg27
#define mccompcurtype  Guide_gravity
#define mccompcurindex 68
#define GVars mccsg27_GVars
#define pTable mccsg27_pTable
{   /* Declarations of sg27=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg27_w1;
MCNUM h1 = mccsg27_h1;
MCNUM w2 = mccsg27_w2;
MCNUM h2 = mccsg27_h2;
MCNUM l = mccsg27_l;
MCNUM R0 = mccsg27_R0;
MCNUM Qc = mccsg27_Qc;
MCNUM alpha = mccsg27_alpha;
MCNUM m = mccsg27_m;
MCNUM W = mccsg27_W;
MCNUM nslit = mccsg27_nslit;
MCNUM d = mccsg27_d;
MCNUM mleft = mccsg27_mleft;
MCNUM mright = mccsg27_mright;
MCNUM mtop = mccsg27_mtop;
MCNUM mbottom = mccsg27_mbottom;
MCNUM nhslit = mccsg27_nhslit;
MCNUM G = mccsg27_G;
MCNUM aleft = mccsg27_aleft;
MCNUM aright = mccsg27_aright;
MCNUM atop = mccsg27_atop;
MCNUM abottom = mccsg27_abottom;
MCNUM wavy = mccsg27_wavy;
MCNUM wavy_z = mccsg27_wavy_z;
MCNUM wavy_tb = mccsg27_wavy_tb;
MCNUM wavy_lr = mccsg27_wavy_lr;
MCNUM chamfers = mccsg27_chamfers;
MCNUM chamfers_z = mccsg27_chamfers_z;
MCNUM chamfers_lr = mccsg27_chamfers_lr;
MCNUM chamfers_tb = mccsg27_chamfers_tb;
MCNUM nelements = mccsg27_nelements;
MCNUM nu = mccsg27_nu;
MCNUM phase = mccsg27_phase;
char* reflect = mccsg27_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 72848 "ILL_H15_D11.c"
}   /* End of sg27=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[68]) fprintf(stderr, "Warning: No neutron could reach Component[68] sg27\n");
    if (mcAbsorbProp[68]) fprintf(stderr, "Warning: %g events were removed in Component[68] sg27=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[68]);
    if (!mcNCounter[69]) fprintf(stderr, "Warning: No neutron could reach Component[69] AlWindow8\n");
    if (mcAbsorbProp[69]) fprintf(stderr, "Warning: %g events were removed in Component[69] AlWindow8=Al_window()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[69]);
  /* User FINALLY code for component 'PSD_D7'. */
  SIG_MESSAGE("PSD_D7 (Finally)");
#define mccompcurname  PSD_D7
#define mccompcurtype  Monitor_nD
#define mccompcurindex 70
#define user1 mccPSD_D7_user1
#define user2 mccPSD_D7_user2
#define user3 mccPSD_D7_user3
#define DEFS mccPSD_D7_DEFS
#define Vars mccPSD_D7_Vars
#define detector mccPSD_D7_detector
#define offdata mccPSD_D7_offdata
{   /* Declarations of PSD_D7=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccPSD_D7_xwidth;
MCNUM yheight = mccPSD_D7_yheight;
MCNUM zdepth = mccPSD_D7_zdepth;
MCNUM xmin = mccPSD_D7_xmin;
MCNUM xmax = mccPSD_D7_xmax;
MCNUM ymin = mccPSD_D7_ymin;
MCNUM ymax = mccPSD_D7_ymax;
MCNUM zmin = mccPSD_D7_zmin;
MCNUM zmax = mccPSD_D7_zmax;
MCNUM bins = mccPSD_D7_bins;
MCNUM min = mccPSD_D7_min;
MCNUM max = mccPSD_D7_max;
MCNUM restore_neutron = mccPSD_D7_restore_neutron;
MCNUM radius = mccPSD_D7_radius;
char* options = mccPSD_D7_options;
char* filename = mccPSD_D7_filename;
char* geometry = mccPSD_D7_geometry;
char* username1 = mccPSD_D7_username1;
char* username2 = mccPSD_D7_username2;
char* username3 = mccPSD_D7_username3;
int nowritefile = mccPSD_D7_nowritefile;
#line 490 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  /* free pointers */
  Monitor_nD_Finally(&DEFS, &Vars);
}
#line 72899 "ILL_H15_D11.c"
}   /* End of PSD_D7=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[70]) fprintf(stderr, "Warning: No neutron could reach Component[70] PSD_D7\n");
    if (mcAbsorbProp[70]) fprintf(stderr, "Warning: %g events were removed in Component[70] PSD_D7=Monitor_nD()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[70]);
    if (!mcNCounter[71]) fprintf(stderr, "Warning: No neutron could reach Component[71] AlWindow9\n");
    if (mcAbsorbProp[71]) fprintf(stderr, "Warning: %g events were removed in Component[71] AlWindow9=Al_window()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[71]);
    if (!mcNCounter[72]) fprintf(stderr, "Warning: No neutron could reach Component[72] D7toD11GuideStart\n");
    if (mcAbsorbProp[72]) fprintf(stderr, "Warning: %g events were removed in Component[72] D7toD11GuideStart=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[72]);
  /* User FINALLY code for component 'sg28'. */
  SIG_MESSAGE("sg28 (Finally)");
#define mccompcurname  sg28
#define mccompcurtype  Guide_gravity
#define mccompcurindex 73
#define GVars mccsg28_GVars
#define pTable mccsg28_pTable
{   /* Declarations of sg28=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg28_w1;
MCNUM h1 = mccsg28_h1;
MCNUM w2 = mccsg28_w2;
MCNUM h2 = mccsg28_h2;
MCNUM l = mccsg28_l;
MCNUM R0 = mccsg28_R0;
MCNUM Qc = mccsg28_Qc;
MCNUM alpha = mccsg28_alpha;
MCNUM m = mccsg28_m;
MCNUM W = mccsg28_W;
MCNUM nslit = mccsg28_nslit;
MCNUM d = mccsg28_d;
MCNUM mleft = mccsg28_mleft;
MCNUM mright = mccsg28_mright;
MCNUM mtop = mccsg28_mtop;
MCNUM mbottom = mccsg28_mbottom;
MCNUM nhslit = mccsg28_nhslit;
MCNUM G = mccsg28_G;
MCNUM aleft = mccsg28_aleft;
MCNUM aright = mccsg28_aright;
MCNUM atop = mccsg28_atop;
MCNUM abottom = mccsg28_abottom;
MCNUM wavy = mccsg28_wavy;
MCNUM wavy_z = mccsg28_wavy_z;
MCNUM wavy_tb = mccsg28_wavy_tb;
MCNUM wavy_lr = mccsg28_wavy_lr;
MCNUM chamfers = mccsg28_chamfers;
MCNUM chamfers_z = mccsg28_chamfers_z;
MCNUM chamfers_lr = mccsg28_chamfers_lr;
MCNUM chamfers_tb = mccsg28_chamfers_tb;
MCNUM nelements = mccsg28_nelements;
MCNUM nu = mccsg28_nu;
MCNUM phase = mccsg28_phase;
char* reflect = mccsg28_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 72967 "ILL_H15_D11.c"
}   /* End of sg28=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[73]) fprintf(stderr, "Warning: No neutron could reach Component[73] sg28\n");
    if (mcAbsorbProp[73]) fprintf(stderr, "Warning: %g events were removed in Component[73] sg28=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[73]);
  /* User FINALLY code for component 'sg29'. */
  SIG_MESSAGE("sg29 (Finally)");
#define mccompcurname  sg29
#define mccompcurtype  Guide_gravity
#define mccompcurindex 74
#define GVars mccsg29_GVars
#define pTable mccsg29_pTable
{   /* Declarations of sg29=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg29_w1;
MCNUM h1 = mccsg29_h1;
MCNUM w2 = mccsg29_w2;
MCNUM h2 = mccsg29_h2;
MCNUM l = mccsg29_l;
MCNUM R0 = mccsg29_R0;
MCNUM Qc = mccsg29_Qc;
MCNUM alpha = mccsg29_alpha;
MCNUM m = mccsg29_m;
MCNUM W = mccsg29_W;
MCNUM nslit = mccsg29_nslit;
MCNUM d = mccsg29_d;
MCNUM mleft = mccsg29_mleft;
MCNUM mright = mccsg29_mright;
MCNUM mtop = mccsg29_mtop;
MCNUM mbottom = mccsg29_mbottom;
MCNUM nhslit = mccsg29_nhslit;
MCNUM G = mccsg29_G;
MCNUM aleft = mccsg29_aleft;
MCNUM aright = mccsg29_aright;
MCNUM atop = mccsg29_atop;
MCNUM abottom = mccsg29_abottom;
MCNUM wavy = mccsg29_wavy;
MCNUM wavy_z = mccsg29_wavy_z;
MCNUM wavy_tb = mccsg29_wavy_tb;
MCNUM wavy_lr = mccsg29_wavy_lr;
MCNUM chamfers = mccsg29_chamfers;
MCNUM chamfers_z = mccsg29_chamfers_z;
MCNUM chamfers_lr = mccsg29_chamfers_lr;
MCNUM chamfers_tb = mccsg29_chamfers_tb;
MCNUM nelements = mccsg29_nelements;
MCNUM nu = mccsg29_nu;
MCNUM phase = mccsg29_phase;
char* reflect = mccsg29_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 73026 "ILL_H15_D11.c"
}   /* End of sg29=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[74]) fprintf(stderr, "Warning: No neutron could reach Component[74] sg29\n");
    if (mcAbsorbProp[74]) fprintf(stderr, "Warning: %g events were removed in Component[74] sg29=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[74]);
    if (!mcNCounter[75]) fprintf(stderr, "Warning: No neutron could reach Component[75] AlWindow10\n");
    if (mcAbsorbProp[75]) fprintf(stderr, "Warning: %g events were removed in Component[75] AlWindow10=Al_window()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[75]);
  /* User FINALLY code for component 'Mon_D11_In'. */
  SIG_MESSAGE("Mon_D11_In (Finally)");
#define mccompcurname  Mon_D11_In
#define mccompcurtype  Monitor_nD
#define mccompcurindex 76
#define user1 mccMon_D11_In_user1
#define user2 mccMon_D11_In_user2
#define user3 mccMon_D11_In_user3
#define DEFS mccMon_D11_In_DEFS
#define Vars mccMon_D11_In_Vars
#define detector mccMon_D11_In_detector
#define offdata mccMon_D11_In_offdata
{   /* Declarations of Mon_D11_In=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccMon_D11_In_xwidth;
MCNUM yheight = mccMon_D11_In_yheight;
MCNUM zdepth = mccMon_D11_In_zdepth;
MCNUM xmin = mccMon_D11_In_xmin;
MCNUM xmax = mccMon_D11_In_xmax;
MCNUM ymin = mccMon_D11_In_ymin;
MCNUM ymax = mccMon_D11_In_ymax;
MCNUM zmin = mccMon_D11_In_zmin;
MCNUM zmax = mccMon_D11_In_zmax;
MCNUM bins = mccMon_D11_In_bins;
MCNUM min = mccMon_D11_In_min;
MCNUM max = mccMon_D11_In_max;
MCNUM restore_neutron = mccMon_D11_In_restore_neutron;
MCNUM radius = mccMon_D11_In_radius;
char* options = mccMon_D11_In_options;
char* filename = mccMon_D11_In_filename;
char* geometry = mccMon_D11_In_geometry;
char* username1 = mccMon_D11_In_username1;
char* username2 = mccMon_D11_In_username2;
char* username3 = mccMon_D11_In_username3;
int nowritefile = mccMon_D11_In_nowritefile;
#line 490 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  /* free pointers */
  Monitor_nD_Finally(&DEFS, &Vars);
}
#line 73077 "ILL_H15_D11.c"
}   /* End of Mon_D11_In=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[76]) fprintf(stderr, "Warning: No neutron could reach Component[76] Mon_D11_In\n");
    if (mcAbsorbProp[76]) fprintf(stderr, "Warning: %g events were removed in Component[76] Mon_D11_In=Monitor_nD()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[76]);
    if (!mcNCounter[77]) fprintf(stderr, "Warning: No neutron could reach Component[77] Dolores\n");
    if (mcAbsorbProp[77]) fprintf(stderr, "Warning: %g events were removed in Component[77] Dolores=V_selector()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[77]);
    if (!mcNCounter[78]) fprintf(stderr, "Warning: No neutron could reach Component[78] AlWindow11\n");
    if (mcAbsorbProp[78]) fprintf(stderr, "Warning: %g events were removed in Component[78] AlWindow11=Al_window()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[78]);
  /* User FINALLY code for component 'sg30'. */
  SIG_MESSAGE("sg30 (Finally)");
#define mccompcurname  sg30
#define mccompcurtype  Guide_gravity
#define mccompcurindex 79
#define GVars mccsg30_GVars
#define pTable mccsg30_pTable
{   /* Declarations of sg30=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg30_w1;
MCNUM h1 = mccsg30_h1;
MCNUM w2 = mccsg30_w2;
MCNUM h2 = mccsg30_h2;
MCNUM l = mccsg30_l;
MCNUM R0 = mccsg30_R0;
MCNUM Qc = mccsg30_Qc;
MCNUM alpha = mccsg30_alpha;
MCNUM m = mccsg30_m;
MCNUM W = mccsg30_W;
MCNUM nslit = mccsg30_nslit;
MCNUM d = mccsg30_d;
MCNUM mleft = mccsg30_mleft;
MCNUM mright = mccsg30_mright;
MCNUM mtop = mccsg30_mtop;
MCNUM mbottom = mccsg30_mbottom;
MCNUM nhslit = mccsg30_nhslit;
MCNUM G = mccsg30_G;
MCNUM aleft = mccsg30_aleft;
MCNUM aright = mccsg30_aright;
MCNUM atop = mccsg30_atop;
MCNUM abottom = mccsg30_abottom;
MCNUM wavy = mccsg30_wavy;
MCNUM wavy_z = mccsg30_wavy_z;
MCNUM wavy_tb = mccsg30_wavy_tb;
MCNUM wavy_lr = mccsg30_wavy_lr;
MCNUM chamfers = mccsg30_chamfers;
MCNUM chamfers_z = mccsg30_chamfers_z;
MCNUM chamfers_lr = mccsg30_chamfers_lr;
MCNUM chamfers_tb = mccsg30_chamfers_tb;
MCNUM nelements = mccsg30_nelements;
MCNUM nu = mccsg30_nu;
MCNUM phase = mccsg30_phase;
char* reflect = mccsg30_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 73145 "ILL_H15_D11.c"
}   /* End of sg30=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[79]) fprintf(stderr, "Warning: No neutron could reach Component[79] sg30\n");
    if (mcAbsorbProp[79]) fprintf(stderr, "Warning: %g events were removed in Component[79] sg30=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[79]);
    if (!mcNCounter[80]) fprintf(stderr, "Warning: No neutron could reach Component[80] AlWindow12\n");
    if (mcAbsorbProp[80]) fprintf(stderr, "Warning: %g events were removed in Component[80] AlWindow12=Al_window()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[80]);
  /* User FINALLY code for component 'Mon_D11_Out'. */
  SIG_MESSAGE("Mon_D11_Out (Finally)");
#define mccompcurname  Mon_D11_Out
#define mccompcurtype  Monitor_nD
#define mccompcurindex 81
#define user1 mccMon_D11_Out_user1
#define user2 mccMon_D11_Out_user2
#define user3 mccMon_D11_Out_user3
#define DEFS mccMon_D11_Out_DEFS
#define Vars mccMon_D11_Out_Vars
#define detector mccMon_D11_Out_detector
#define offdata mccMon_D11_Out_offdata
{   /* Declarations of Mon_D11_Out=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccMon_D11_Out_xwidth;
MCNUM yheight = mccMon_D11_Out_yheight;
MCNUM zdepth = mccMon_D11_Out_zdepth;
MCNUM xmin = mccMon_D11_Out_xmin;
MCNUM xmax = mccMon_D11_Out_xmax;
MCNUM ymin = mccMon_D11_Out_ymin;
MCNUM ymax = mccMon_D11_Out_ymax;
MCNUM zmin = mccMon_D11_Out_zmin;
MCNUM zmax = mccMon_D11_Out_zmax;
MCNUM bins = mccMon_D11_Out_bins;
MCNUM min = mccMon_D11_Out_min;
MCNUM max = mccMon_D11_Out_max;
MCNUM restore_neutron = mccMon_D11_Out_restore_neutron;
MCNUM radius = mccMon_D11_Out_radius;
char* options = mccMon_D11_Out_options;
char* filename = mccMon_D11_Out_filename;
char* geometry = mccMon_D11_Out_geometry;
char* username1 = mccMon_D11_Out_username1;
char* username2 = mccMon_D11_Out_username2;
char* username3 = mccMon_D11_Out_username3;
int nowritefile = mccMon_D11_Out_nowritefile;
#line 490 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  /* free pointers */
  Monitor_nD_Finally(&DEFS, &Vars);
}
#line 73196 "ILL_H15_D11.c"
}   /* End of Mon_D11_Out=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[81]) fprintf(stderr, "Warning: No neutron could reach Component[81] Mon_D11_Out\n");
    if (mcAbsorbProp[81]) fprintf(stderr, "Warning: %g events were removed in Component[81] Mon_D11_Out=Monitor_nD()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[81]);
    if (!mcNCounter[82]) fprintf(stderr, "Warning: No neutron could reach Component[82] AlWindow13\n");
    if (mcAbsorbProp[82]) fprintf(stderr, "Warning: %g events were removed in Component[82] AlWindow13=Al_window()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[82]);
    if (!mcNCounter[83]) fprintf(stderr, "Warning: No neutron could reach Component[83] MovableGuideStart\n");
    if (mcAbsorbProp[83]) fprintf(stderr, "Warning: %g events were removed in Component[83] MovableGuideStart=Arm()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[83]);
  /* User FINALLY code for component 'mg0'. */
  SIG_MESSAGE("mg0 (Finally)");
#define mccompcurname  mg0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 84
#define GVars mccmg0_GVars
#define pTable mccmg0_pTable
{   /* Declarations of mg0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg0_w1;
MCNUM h1 = mccmg0_h1;
MCNUM w2 = mccmg0_w2;
MCNUM h2 = mccmg0_h2;
MCNUM l = mccmg0_l;
MCNUM R0 = mccmg0_R0;
MCNUM Qc = mccmg0_Qc;
MCNUM alpha = mccmg0_alpha;
MCNUM m = mccmg0_m;
MCNUM W = mccmg0_W;
MCNUM nslit = mccmg0_nslit;
MCNUM d = mccmg0_d;
MCNUM mleft = mccmg0_mleft;
MCNUM mright = mccmg0_mright;
MCNUM mtop = mccmg0_mtop;
MCNUM mbottom = mccmg0_mbottom;
MCNUM nhslit = mccmg0_nhslit;
MCNUM G = mccmg0_G;
MCNUM aleft = mccmg0_aleft;
MCNUM aright = mccmg0_aright;
MCNUM atop = mccmg0_atop;
MCNUM abottom = mccmg0_abottom;
MCNUM wavy = mccmg0_wavy;
MCNUM wavy_z = mccmg0_wavy_z;
MCNUM wavy_tb = mccmg0_wavy_tb;
MCNUM wavy_lr = mccmg0_wavy_lr;
MCNUM chamfers = mccmg0_chamfers;
MCNUM chamfers_z = mccmg0_chamfers_z;
MCNUM chamfers_lr = mccmg0_chamfers_lr;
MCNUM chamfers_tb = mccmg0_chamfers_tb;
MCNUM nelements = mccmg0_nelements;
MCNUM nu = mccmg0_nu;
MCNUM phase = mccmg0_phase;
char* reflect = mccmg0_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 73264 "ILL_H15_D11.c"
}   /* End of mg0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[84]) fprintf(stderr, "Warning: No neutron could reach Component[84] mg0\n");
    if (mcAbsorbProp[84]) fprintf(stderr, "Warning: %g events were removed in Component[84] mg0=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[84]);
  /* User FINALLY code for component 'mg1'. */
  SIG_MESSAGE("mg1 (Finally)");
#define mccompcurname  mg1
#define mccompcurtype  Guide_gravity
#define mccompcurindex 85
#define GVars mccmg1_GVars
#define pTable mccmg1_pTable
{   /* Declarations of mg1=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg1_w1;
MCNUM h1 = mccmg1_h1;
MCNUM w2 = mccmg1_w2;
MCNUM h2 = mccmg1_h2;
MCNUM l = mccmg1_l;
MCNUM R0 = mccmg1_R0;
MCNUM Qc = mccmg1_Qc;
MCNUM alpha = mccmg1_alpha;
MCNUM m = mccmg1_m;
MCNUM W = mccmg1_W;
MCNUM nslit = mccmg1_nslit;
MCNUM d = mccmg1_d;
MCNUM mleft = mccmg1_mleft;
MCNUM mright = mccmg1_mright;
MCNUM mtop = mccmg1_mtop;
MCNUM mbottom = mccmg1_mbottom;
MCNUM nhslit = mccmg1_nhslit;
MCNUM G = mccmg1_G;
MCNUM aleft = mccmg1_aleft;
MCNUM aright = mccmg1_aright;
MCNUM atop = mccmg1_atop;
MCNUM abottom = mccmg1_abottom;
MCNUM wavy = mccmg1_wavy;
MCNUM wavy_z = mccmg1_wavy_z;
MCNUM wavy_tb = mccmg1_wavy_tb;
MCNUM wavy_lr = mccmg1_wavy_lr;
MCNUM chamfers = mccmg1_chamfers;
MCNUM chamfers_z = mccmg1_chamfers_z;
MCNUM chamfers_lr = mccmg1_chamfers_lr;
MCNUM chamfers_tb = mccmg1_chamfers_tb;
MCNUM nelements = mccmg1_nelements;
MCNUM nu = mccmg1_nu;
MCNUM phase = mccmg1_phase;
char* reflect = mccmg1_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 73323 "ILL_H15_D11.c"
}   /* End of mg1=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[85]) fprintf(stderr, "Warning: No neutron could reach Component[85] mg1\n");
    if (mcAbsorbProp[85]) fprintf(stderr, "Warning: %g events were removed in Component[85] mg1=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[85]);
  /* User FINALLY code for component 'mg2'. */
  SIG_MESSAGE("mg2 (Finally)");
#define mccompcurname  mg2
#define mccompcurtype  Guide_gravity
#define mccompcurindex 86
#define GVars mccmg2_GVars
#define pTable mccmg2_pTable
{   /* Declarations of mg2=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg2_w1;
MCNUM h1 = mccmg2_h1;
MCNUM w2 = mccmg2_w2;
MCNUM h2 = mccmg2_h2;
MCNUM l = mccmg2_l;
MCNUM R0 = mccmg2_R0;
MCNUM Qc = mccmg2_Qc;
MCNUM alpha = mccmg2_alpha;
MCNUM m = mccmg2_m;
MCNUM W = mccmg2_W;
MCNUM nslit = mccmg2_nslit;
MCNUM d = mccmg2_d;
MCNUM mleft = mccmg2_mleft;
MCNUM mright = mccmg2_mright;
MCNUM mtop = mccmg2_mtop;
MCNUM mbottom = mccmg2_mbottom;
MCNUM nhslit = mccmg2_nhslit;
MCNUM G = mccmg2_G;
MCNUM aleft = mccmg2_aleft;
MCNUM aright = mccmg2_aright;
MCNUM atop = mccmg2_atop;
MCNUM abottom = mccmg2_abottom;
MCNUM wavy = mccmg2_wavy;
MCNUM wavy_z = mccmg2_wavy_z;
MCNUM wavy_tb = mccmg2_wavy_tb;
MCNUM wavy_lr = mccmg2_wavy_lr;
MCNUM chamfers = mccmg2_chamfers;
MCNUM chamfers_z = mccmg2_chamfers_z;
MCNUM chamfers_lr = mccmg2_chamfers_lr;
MCNUM chamfers_tb = mccmg2_chamfers_tb;
MCNUM nelements = mccmg2_nelements;
MCNUM nu = mccmg2_nu;
MCNUM phase = mccmg2_phase;
char* reflect = mccmg2_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 73382 "ILL_H15_D11.c"
}   /* End of mg2=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[86]) fprintf(stderr, "Warning: No neutron could reach Component[86] mg2\n");
    if (mcAbsorbProp[86]) fprintf(stderr, "Warning: %g events were removed in Component[86] mg2=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[86]);
  /* User FINALLY code for component 'mg3'. */
  SIG_MESSAGE("mg3 (Finally)");
#define mccompcurname  mg3
#define mccompcurtype  Guide_gravity
#define mccompcurindex 87
#define GVars mccmg3_GVars
#define pTable mccmg3_pTable
{   /* Declarations of mg3=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg3_w1;
MCNUM h1 = mccmg3_h1;
MCNUM w2 = mccmg3_w2;
MCNUM h2 = mccmg3_h2;
MCNUM l = mccmg3_l;
MCNUM R0 = mccmg3_R0;
MCNUM Qc = mccmg3_Qc;
MCNUM alpha = mccmg3_alpha;
MCNUM m = mccmg3_m;
MCNUM W = mccmg3_W;
MCNUM nslit = mccmg3_nslit;
MCNUM d = mccmg3_d;
MCNUM mleft = mccmg3_mleft;
MCNUM mright = mccmg3_mright;
MCNUM mtop = mccmg3_mtop;
MCNUM mbottom = mccmg3_mbottom;
MCNUM nhslit = mccmg3_nhslit;
MCNUM G = mccmg3_G;
MCNUM aleft = mccmg3_aleft;
MCNUM aright = mccmg3_aright;
MCNUM atop = mccmg3_atop;
MCNUM abottom = mccmg3_abottom;
MCNUM wavy = mccmg3_wavy;
MCNUM wavy_z = mccmg3_wavy_z;
MCNUM wavy_tb = mccmg3_wavy_tb;
MCNUM wavy_lr = mccmg3_wavy_lr;
MCNUM chamfers = mccmg3_chamfers;
MCNUM chamfers_z = mccmg3_chamfers_z;
MCNUM chamfers_lr = mccmg3_chamfers_lr;
MCNUM chamfers_tb = mccmg3_chamfers_tb;
MCNUM nelements = mccmg3_nelements;
MCNUM nu = mccmg3_nu;
MCNUM phase = mccmg3_phase;
char* reflect = mccmg3_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 73441 "ILL_H15_D11.c"
}   /* End of mg3=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[87]) fprintf(stderr, "Warning: No neutron could reach Component[87] mg3\n");
    if (mcAbsorbProp[87]) fprintf(stderr, "Warning: %g events were removed in Component[87] mg3=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[87]);
  /* User FINALLY code for component 'mg4'. */
  SIG_MESSAGE("mg4 (Finally)");
#define mccompcurname  mg4
#define mccompcurtype  Guide_gravity
#define mccompcurindex 88
#define GVars mccmg4_GVars
#define pTable mccmg4_pTable
{   /* Declarations of mg4=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg4_w1;
MCNUM h1 = mccmg4_h1;
MCNUM w2 = mccmg4_w2;
MCNUM h2 = mccmg4_h2;
MCNUM l = mccmg4_l;
MCNUM R0 = mccmg4_R0;
MCNUM Qc = mccmg4_Qc;
MCNUM alpha = mccmg4_alpha;
MCNUM m = mccmg4_m;
MCNUM W = mccmg4_W;
MCNUM nslit = mccmg4_nslit;
MCNUM d = mccmg4_d;
MCNUM mleft = mccmg4_mleft;
MCNUM mright = mccmg4_mright;
MCNUM mtop = mccmg4_mtop;
MCNUM mbottom = mccmg4_mbottom;
MCNUM nhslit = mccmg4_nhslit;
MCNUM G = mccmg4_G;
MCNUM aleft = mccmg4_aleft;
MCNUM aright = mccmg4_aright;
MCNUM atop = mccmg4_atop;
MCNUM abottom = mccmg4_abottom;
MCNUM wavy = mccmg4_wavy;
MCNUM wavy_z = mccmg4_wavy_z;
MCNUM wavy_tb = mccmg4_wavy_tb;
MCNUM wavy_lr = mccmg4_wavy_lr;
MCNUM chamfers = mccmg4_chamfers;
MCNUM chamfers_z = mccmg4_chamfers_z;
MCNUM chamfers_lr = mccmg4_chamfers_lr;
MCNUM chamfers_tb = mccmg4_chamfers_tb;
MCNUM nelements = mccmg4_nelements;
MCNUM nu = mccmg4_nu;
MCNUM phase = mccmg4_phase;
char* reflect = mccmg4_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 73500 "ILL_H15_D11.c"
}   /* End of mg4=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[88]) fprintf(stderr, "Warning: No neutron could reach Component[88] mg4\n");
    if (mcAbsorbProp[88]) fprintf(stderr, "Warning: %g events were removed in Component[88] mg4=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[88]);
  /* User FINALLY code for component 'mg5'. */
  SIG_MESSAGE("mg5 (Finally)");
#define mccompcurname  mg5
#define mccompcurtype  Guide_gravity
#define mccompcurindex 89
#define GVars mccmg5_GVars
#define pTable mccmg5_pTable
{   /* Declarations of mg5=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg5_w1;
MCNUM h1 = mccmg5_h1;
MCNUM w2 = mccmg5_w2;
MCNUM h2 = mccmg5_h2;
MCNUM l = mccmg5_l;
MCNUM R0 = mccmg5_R0;
MCNUM Qc = mccmg5_Qc;
MCNUM alpha = mccmg5_alpha;
MCNUM m = mccmg5_m;
MCNUM W = mccmg5_W;
MCNUM nslit = mccmg5_nslit;
MCNUM d = mccmg5_d;
MCNUM mleft = mccmg5_mleft;
MCNUM mright = mccmg5_mright;
MCNUM mtop = mccmg5_mtop;
MCNUM mbottom = mccmg5_mbottom;
MCNUM nhslit = mccmg5_nhslit;
MCNUM G = mccmg5_G;
MCNUM aleft = mccmg5_aleft;
MCNUM aright = mccmg5_aright;
MCNUM atop = mccmg5_atop;
MCNUM abottom = mccmg5_abottom;
MCNUM wavy = mccmg5_wavy;
MCNUM wavy_z = mccmg5_wavy_z;
MCNUM wavy_tb = mccmg5_wavy_tb;
MCNUM wavy_lr = mccmg5_wavy_lr;
MCNUM chamfers = mccmg5_chamfers;
MCNUM chamfers_z = mccmg5_chamfers_z;
MCNUM chamfers_lr = mccmg5_chamfers_lr;
MCNUM chamfers_tb = mccmg5_chamfers_tb;
MCNUM nelements = mccmg5_nelements;
MCNUM nu = mccmg5_nu;
MCNUM phase = mccmg5_phase;
char* reflect = mccmg5_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 73559 "ILL_H15_D11.c"
}   /* End of mg5=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[89]) fprintf(stderr, "Warning: No neutron could reach Component[89] mg5\n");
    if (mcAbsorbProp[89]) fprintf(stderr, "Warning: %g events were removed in Component[89] mg5=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[89]);
  /* User FINALLY code for component 'mg6'. */
  SIG_MESSAGE("mg6 (Finally)");
#define mccompcurname  mg6
#define mccompcurtype  Guide_gravity
#define mccompcurindex 90
#define GVars mccmg6_GVars
#define pTable mccmg6_pTable
{   /* Declarations of mg6=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg6_w1;
MCNUM h1 = mccmg6_h1;
MCNUM w2 = mccmg6_w2;
MCNUM h2 = mccmg6_h2;
MCNUM l = mccmg6_l;
MCNUM R0 = mccmg6_R0;
MCNUM Qc = mccmg6_Qc;
MCNUM alpha = mccmg6_alpha;
MCNUM m = mccmg6_m;
MCNUM W = mccmg6_W;
MCNUM nslit = mccmg6_nslit;
MCNUM d = mccmg6_d;
MCNUM mleft = mccmg6_mleft;
MCNUM mright = mccmg6_mright;
MCNUM mtop = mccmg6_mtop;
MCNUM mbottom = mccmg6_mbottom;
MCNUM nhslit = mccmg6_nhslit;
MCNUM G = mccmg6_G;
MCNUM aleft = mccmg6_aleft;
MCNUM aright = mccmg6_aright;
MCNUM atop = mccmg6_atop;
MCNUM abottom = mccmg6_abottom;
MCNUM wavy = mccmg6_wavy;
MCNUM wavy_z = mccmg6_wavy_z;
MCNUM wavy_tb = mccmg6_wavy_tb;
MCNUM wavy_lr = mccmg6_wavy_lr;
MCNUM chamfers = mccmg6_chamfers;
MCNUM chamfers_z = mccmg6_chamfers_z;
MCNUM chamfers_lr = mccmg6_chamfers_lr;
MCNUM chamfers_tb = mccmg6_chamfers_tb;
MCNUM nelements = mccmg6_nelements;
MCNUM nu = mccmg6_nu;
MCNUM phase = mccmg6_phase;
char* reflect = mccmg6_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 73618 "ILL_H15_D11.c"
}   /* End of mg6=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[90]) fprintf(stderr, "Warning: No neutron could reach Component[90] mg6\n");
    if (mcAbsorbProp[90]) fprintf(stderr, "Warning: %g events were removed in Component[90] mg6=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[90]);
  /* User FINALLY code for component 'mg7'. */
  SIG_MESSAGE("mg7 (Finally)");
#define mccompcurname  mg7
#define mccompcurtype  Guide_gravity
#define mccompcurindex 91
#define GVars mccmg7_GVars
#define pTable mccmg7_pTable
{   /* Declarations of mg7=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg7_w1;
MCNUM h1 = mccmg7_h1;
MCNUM w2 = mccmg7_w2;
MCNUM h2 = mccmg7_h2;
MCNUM l = mccmg7_l;
MCNUM R0 = mccmg7_R0;
MCNUM Qc = mccmg7_Qc;
MCNUM alpha = mccmg7_alpha;
MCNUM m = mccmg7_m;
MCNUM W = mccmg7_W;
MCNUM nslit = mccmg7_nslit;
MCNUM d = mccmg7_d;
MCNUM mleft = mccmg7_mleft;
MCNUM mright = mccmg7_mright;
MCNUM mtop = mccmg7_mtop;
MCNUM mbottom = mccmg7_mbottom;
MCNUM nhslit = mccmg7_nhslit;
MCNUM G = mccmg7_G;
MCNUM aleft = mccmg7_aleft;
MCNUM aright = mccmg7_aright;
MCNUM atop = mccmg7_atop;
MCNUM abottom = mccmg7_abottom;
MCNUM wavy = mccmg7_wavy;
MCNUM wavy_z = mccmg7_wavy_z;
MCNUM wavy_tb = mccmg7_wavy_tb;
MCNUM wavy_lr = mccmg7_wavy_lr;
MCNUM chamfers = mccmg7_chamfers;
MCNUM chamfers_z = mccmg7_chamfers_z;
MCNUM chamfers_lr = mccmg7_chamfers_lr;
MCNUM chamfers_tb = mccmg7_chamfers_tb;
MCNUM nelements = mccmg7_nelements;
MCNUM nu = mccmg7_nu;
MCNUM phase = mccmg7_phase;
char* reflect = mccmg7_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 73677 "ILL_H15_D11.c"
}   /* End of mg7=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[91]) fprintf(stderr, "Warning: No neutron could reach Component[91] mg7\n");
    if (mcAbsorbProp[91]) fprintf(stderr, "Warning: %g events were removed in Component[91] mg7=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[91]);
  /* User FINALLY code for component 'mg8'. */
  SIG_MESSAGE("mg8 (Finally)");
#define mccompcurname  mg8
#define mccompcurtype  Guide_gravity
#define mccompcurindex 92
#define GVars mccmg8_GVars
#define pTable mccmg8_pTable
{   /* Declarations of mg8=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg8_w1;
MCNUM h1 = mccmg8_h1;
MCNUM w2 = mccmg8_w2;
MCNUM h2 = mccmg8_h2;
MCNUM l = mccmg8_l;
MCNUM R0 = mccmg8_R0;
MCNUM Qc = mccmg8_Qc;
MCNUM alpha = mccmg8_alpha;
MCNUM m = mccmg8_m;
MCNUM W = mccmg8_W;
MCNUM nslit = mccmg8_nslit;
MCNUM d = mccmg8_d;
MCNUM mleft = mccmg8_mleft;
MCNUM mright = mccmg8_mright;
MCNUM mtop = mccmg8_mtop;
MCNUM mbottom = mccmg8_mbottom;
MCNUM nhslit = mccmg8_nhslit;
MCNUM G = mccmg8_G;
MCNUM aleft = mccmg8_aleft;
MCNUM aright = mccmg8_aright;
MCNUM atop = mccmg8_atop;
MCNUM abottom = mccmg8_abottom;
MCNUM wavy = mccmg8_wavy;
MCNUM wavy_z = mccmg8_wavy_z;
MCNUM wavy_tb = mccmg8_wavy_tb;
MCNUM wavy_lr = mccmg8_wavy_lr;
MCNUM chamfers = mccmg8_chamfers;
MCNUM chamfers_z = mccmg8_chamfers_z;
MCNUM chamfers_lr = mccmg8_chamfers_lr;
MCNUM chamfers_tb = mccmg8_chamfers_tb;
MCNUM nelements = mccmg8_nelements;
MCNUM nu = mccmg8_nu;
MCNUM phase = mccmg8_phase;
char* reflect = mccmg8_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 73736 "ILL_H15_D11.c"
}   /* End of mg8=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[92]) fprintf(stderr, "Warning: No neutron could reach Component[92] mg8\n");
    if (mcAbsorbProp[92]) fprintf(stderr, "Warning: %g events were removed in Component[92] mg8=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[92]);
  /* User FINALLY code for component 'mg9'. */
  SIG_MESSAGE("mg9 (Finally)");
#define mccompcurname  mg9
#define mccompcurtype  Guide_gravity
#define mccompcurindex 93
#define GVars mccmg9_GVars
#define pTable mccmg9_pTable
{   /* Declarations of mg9=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg9_w1;
MCNUM h1 = mccmg9_h1;
MCNUM w2 = mccmg9_w2;
MCNUM h2 = mccmg9_h2;
MCNUM l = mccmg9_l;
MCNUM R0 = mccmg9_R0;
MCNUM Qc = mccmg9_Qc;
MCNUM alpha = mccmg9_alpha;
MCNUM m = mccmg9_m;
MCNUM W = mccmg9_W;
MCNUM nslit = mccmg9_nslit;
MCNUM d = mccmg9_d;
MCNUM mleft = mccmg9_mleft;
MCNUM mright = mccmg9_mright;
MCNUM mtop = mccmg9_mtop;
MCNUM mbottom = mccmg9_mbottom;
MCNUM nhslit = mccmg9_nhslit;
MCNUM G = mccmg9_G;
MCNUM aleft = mccmg9_aleft;
MCNUM aright = mccmg9_aright;
MCNUM atop = mccmg9_atop;
MCNUM abottom = mccmg9_abottom;
MCNUM wavy = mccmg9_wavy;
MCNUM wavy_z = mccmg9_wavy_z;
MCNUM wavy_tb = mccmg9_wavy_tb;
MCNUM wavy_lr = mccmg9_wavy_lr;
MCNUM chamfers = mccmg9_chamfers;
MCNUM chamfers_z = mccmg9_chamfers_z;
MCNUM chamfers_lr = mccmg9_chamfers_lr;
MCNUM chamfers_tb = mccmg9_chamfers_tb;
MCNUM nelements = mccmg9_nelements;
MCNUM nu = mccmg9_nu;
MCNUM phase = mccmg9_phase;
char* reflect = mccmg9_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 73795 "ILL_H15_D11.c"
}   /* End of mg9=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[93]) fprintf(stderr, "Warning: No neutron could reach Component[93] mg9\n");
    if (mcAbsorbProp[93]) fprintf(stderr, "Warning: %g events were removed in Component[93] mg9=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[93]);
  /* User FINALLY code for component 'mg10'. */
  SIG_MESSAGE("mg10 (Finally)");
#define mccompcurname  mg10
#define mccompcurtype  Guide_gravity
#define mccompcurindex 94
#define GVars mccmg10_GVars
#define pTable mccmg10_pTable
{   /* Declarations of mg10=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg10_w1;
MCNUM h1 = mccmg10_h1;
MCNUM w2 = mccmg10_w2;
MCNUM h2 = mccmg10_h2;
MCNUM l = mccmg10_l;
MCNUM R0 = mccmg10_R0;
MCNUM Qc = mccmg10_Qc;
MCNUM alpha = mccmg10_alpha;
MCNUM m = mccmg10_m;
MCNUM W = mccmg10_W;
MCNUM nslit = mccmg10_nslit;
MCNUM d = mccmg10_d;
MCNUM mleft = mccmg10_mleft;
MCNUM mright = mccmg10_mright;
MCNUM mtop = mccmg10_mtop;
MCNUM mbottom = mccmg10_mbottom;
MCNUM nhslit = mccmg10_nhslit;
MCNUM G = mccmg10_G;
MCNUM aleft = mccmg10_aleft;
MCNUM aright = mccmg10_aright;
MCNUM atop = mccmg10_atop;
MCNUM abottom = mccmg10_abottom;
MCNUM wavy = mccmg10_wavy;
MCNUM wavy_z = mccmg10_wavy_z;
MCNUM wavy_tb = mccmg10_wavy_tb;
MCNUM wavy_lr = mccmg10_wavy_lr;
MCNUM chamfers = mccmg10_chamfers;
MCNUM chamfers_z = mccmg10_chamfers_z;
MCNUM chamfers_lr = mccmg10_chamfers_lr;
MCNUM chamfers_tb = mccmg10_chamfers_tb;
MCNUM nelements = mccmg10_nelements;
MCNUM nu = mccmg10_nu;
MCNUM phase = mccmg10_phase;
char* reflect = mccmg10_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 73854 "ILL_H15_D11.c"
}   /* End of mg10=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[94]) fprintf(stderr, "Warning: No neutron could reach Component[94] mg10\n");
    if (mcAbsorbProp[94]) fprintf(stderr, "Warning: %g events were removed in Component[94] mg10=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[94]);
  /* User FINALLY code for component 'mg11'. */
  SIG_MESSAGE("mg11 (Finally)");
#define mccompcurname  mg11
#define mccompcurtype  Guide_gravity
#define mccompcurindex 95
#define GVars mccmg11_GVars
#define pTable mccmg11_pTable
{   /* Declarations of mg11=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg11_w1;
MCNUM h1 = mccmg11_h1;
MCNUM w2 = mccmg11_w2;
MCNUM h2 = mccmg11_h2;
MCNUM l = mccmg11_l;
MCNUM R0 = mccmg11_R0;
MCNUM Qc = mccmg11_Qc;
MCNUM alpha = mccmg11_alpha;
MCNUM m = mccmg11_m;
MCNUM W = mccmg11_W;
MCNUM nslit = mccmg11_nslit;
MCNUM d = mccmg11_d;
MCNUM mleft = mccmg11_mleft;
MCNUM mright = mccmg11_mright;
MCNUM mtop = mccmg11_mtop;
MCNUM mbottom = mccmg11_mbottom;
MCNUM nhslit = mccmg11_nhslit;
MCNUM G = mccmg11_G;
MCNUM aleft = mccmg11_aleft;
MCNUM aright = mccmg11_aright;
MCNUM atop = mccmg11_atop;
MCNUM abottom = mccmg11_abottom;
MCNUM wavy = mccmg11_wavy;
MCNUM wavy_z = mccmg11_wavy_z;
MCNUM wavy_tb = mccmg11_wavy_tb;
MCNUM wavy_lr = mccmg11_wavy_lr;
MCNUM chamfers = mccmg11_chamfers;
MCNUM chamfers_z = mccmg11_chamfers_z;
MCNUM chamfers_lr = mccmg11_chamfers_lr;
MCNUM chamfers_tb = mccmg11_chamfers_tb;
MCNUM nelements = mccmg11_nelements;
MCNUM nu = mccmg11_nu;
MCNUM phase = mccmg11_phase;
char* reflect = mccmg11_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 73913 "ILL_H15_D11.c"
}   /* End of mg11=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[95]) fprintf(stderr, "Warning: No neutron could reach Component[95] mg11\n");
    if (mcAbsorbProp[95]) fprintf(stderr, "Warning: %g events were removed in Component[95] mg11=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[95]);
  /* User FINALLY code for component 'mg12'. */
  SIG_MESSAGE("mg12 (Finally)");
#define mccompcurname  mg12
#define mccompcurtype  Guide_gravity
#define mccompcurindex 96
#define GVars mccmg12_GVars
#define pTable mccmg12_pTable
{   /* Declarations of mg12=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg12_w1;
MCNUM h1 = mccmg12_h1;
MCNUM w2 = mccmg12_w2;
MCNUM h2 = mccmg12_h2;
MCNUM l = mccmg12_l;
MCNUM R0 = mccmg12_R0;
MCNUM Qc = mccmg12_Qc;
MCNUM alpha = mccmg12_alpha;
MCNUM m = mccmg12_m;
MCNUM W = mccmg12_W;
MCNUM nslit = mccmg12_nslit;
MCNUM d = mccmg12_d;
MCNUM mleft = mccmg12_mleft;
MCNUM mright = mccmg12_mright;
MCNUM mtop = mccmg12_mtop;
MCNUM mbottom = mccmg12_mbottom;
MCNUM nhslit = mccmg12_nhslit;
MCNUM G = mccmg12_G;
MCNUM aleft = mccmg12_aleft;
MCNUM aright = mccmg12_aright;
MCNUM atop = mccmg12_atop;
MCNUM abottom = mccmg12_abottom;
MCNUM wavy = mccmg12_wavy;
MCNUM wavy_z = mccmg12_wavy_z;
MCNUM wavy_tb = mccmg12_wavy_tb;
MCNUM wavy_lr = mccmg12_wavy_lr;
MCNUM chamfers = mccmg12_chamfers;
MCNUM chamfers_z = mccmg12_chamfers_z;
MCNUM chamfers_lr = mccmg12_chamfers_lr;
MCNUM chamfers_tb = mccmg12_chamfers_tb;
MCNUM nelements = mccmg12_nelements;
MCNUM nu = mccmg12_nu;
MCNUM phase = mccmg12_phase;
char* reflect = mccmg12_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 73972 "ILL_H15_D11.c"
}   /* End of mg12=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[96]) fprintf(stderr, "Warning: No neutron could reach Component[96] mg12\n");
    if (mcAbsorbProp[96]) fprintf(stderr, "Warning: %g events were removed in Component[96] mg12=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[96]);
  /* User FINALLY code for component 'mg13'. */
  SIG_MESSAGE("mg13 (Finally)");
#define mccompcurname  mg13
#define mccompcurtype  Guide_gravity
#define mccompcurindex 97
#define GVars mccmg13_GVars
#define pTable mccmg13_pTable
{   /* Declarations of mg13=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg13_w1;
MCNUM h1 = mccmg13_h1;
MCNUM w2 = mccmg13_w2;
MCNUM h2 = mccmg13_h2;
MCNUM l = mccmg13_l;
MCNUM R0 = mccmg13_R0;
MCNUM Qc = mccmg13_Qc;
MCNUM alpha = mccmg13_alpha;
MCNUM m = mccmg13_m;
MCNUM W = mccmg13_W;
MCNUM nslit = mccmg13_nslit;
MCNUM d = mccmg13_d;
MCNUM mleft = mccmg13_mleft;
MCNUM mright = mccmg13_mright;
MCNUM mtop = mccmg13_mtop;
MCNUM mbottom = mccmg13_mbottom;
MCNUM nhslit = mccmg13_nhslit;
MCNUM G = mccmg13_G;
MCNUM aleft = mccmg13_aleft;
MCNUM aright = mccmg13_aright;
MCNUM atop = mccmg13_atop;
MCNUM abottom = mccmg13_abottom;
MCNUM wavy = mccmg13_wavy;
MCNUM wavy_z = mccmg13_wavy_z;
MCNUM wavy_tb = mccmg13_wavy_tb;
MCNUM wavy_lr = mccmg13_wavy_lr;
MCNUM chamfers = mccmg13_chamfers;
MCNUM chamfers_z = mccmg13_chamfers_z;
MCNUM chamfers_lr = mccmg13_chamfers_lr;
MCNUM chamfers_tb = mccmg13_chamfers_tb;
MCNUM nelements = mccmg13_nelements;
MCNUM nu = mccmg13_nu;
MCNUM phase = mccmg13_phase;
char* reflect = mccmg13_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 74031 "ILL_H15_D11.c"
}   /* End of mg13=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[97]) fprintf(stderr, "Warning: No neutron could reach Component[97] mg13\n");
    if (mcAbsorbProp[97]) fprintf(stderr, "Warning: %g events were removed in Component[97] mg13=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[97]);
  /* User FINALLY code for component 'mg14'. */
  SIG_MESSAGE("mg14 (Finally)");
#define mccompcurname  mg14
#define mccompcurtype  Guide_gravity
#define mccompcurindex 98
#define GVars mccmg14_GVars
#define pTable mccmg14_pTable
{   /* Declarations of mg14=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg14_w1;
MCNUM h1 = mccmg14_h1;
MCNUM w2 = mccmg14_w2;
MCNUM h2 = mccmg14_h2;
MCNUM l = mccmg14_l;
MCNUM R0 = mccmg14_R0;
MCNUM Qc = mccmg14_Qc;
MCNUM alpha = mccmg14_alpha;
MCNUM m = mccmg14_m;
MCNUM W = mccmg14_W;
MCNUM nslit = mccmg14_nslit;
MCNUM d = mccmg14_d;
MCNUM mleft = mccmg14_mleft;
MCNUM mright = mccmg14_mright;
MCNUM mtop = mccmg14_mtop;
MCNUM mbottom = mccmg14_mbottom;
MCNUM nhslit = mccmg14_nhslit;
MCNUM G = mccmg14_G;
MCNUM aleft = mccmg14_aleft;
MCNUM aright = mccmg14_aright;
MCNUM atop = mccmg14_atop;
MCNUM abottom = mccmg14_abottom;
MCNUM wavy = mccmg14_wavy;
MCNUM wavy_z = mccmg14_wavy_z;
MCNUM wavy_tb = mccmg14_wavy_tb;
MCNUM wavy_lr = mccmg14_wavy_lr;
MCNUM chamfers = mccmg14_chamfers;
MCNUM chamfers_z = mccmg14_chamfers_z;
MCNUM chamfers_lr = mccmg14_chamfers_lr;
MCNUM chamfers_tb = mccmg14_chamfers_tb;
MCNUM nelements = mccmg14_nelements;
MCNUM nu = mccmg14_nu;
MCNUM phase = mccmg14_phase;
char* reflect = mccmg14_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 74090 "ILL_H15_D11.c"
}   /* End of mg14=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[98]) fprintf(stderr, "Warning: No neutron could reach Component[98] mg14\n");
    if (mcAbsorbProp[98]) fprintf(stderr, "Warning: %g events were removed in Component[98] mg14=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[98]);
  /* User FINALLY code for component 'mg15'. */
  SIG_MESSAGE("mg15 (Finally)");
#define mccompcurname  mg15
#define mccompcurtype  Guide_gravity
#define mccompcurindex 99
#define GVars mccmg15_GVars
#define pTable mccmg15_pTable
{   /* Declarations of mg15=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg15_w1;
MCNUM h1 = mccmg15_h1;
MCNUM w2 = mccmg15_w2;
MCNUM h2 = mccmg15_h2;
MCNUM l = mccmg15_l;
MCNUM R0 = mccmg15_R0;
MCNUM Qc = mccmg15_Qc;
MCNUM alpha = mccmg15_alpha;
MCNUM m = mccmg15_m;
MCNUM W = mccmg15_W;
MCNUM nslit = mccmg15_nslit;
MCNUM d = mccmg15_d;
MCNUM mleft = mccmg15_mleft;
MCNUM mright = mccmg15_mright;
MCNUM mtop = mccmg15_mtop;
MCNUM mbottom = mccmg15_mbottom;
MCNUM nhslit = mccmg15_nhslit;
MCNUM G = mccmg15_G;
MCNUM aleft = mccmg15_aleft;
MCNUM aright = mccmg15_aright;
MCNUM atop = mccmg15_atop;
MCNUM abottom = mccmg15_abottom;
MCNUM wavy = mccmg15_wavy;
MCNUM wavy_z = mccmg15_wavy_z;
MCNUM wavy_tb = mccmg15_wavy_tb;
MCNUM wavy_lr = mccmg15_wavy_lr;
MCNUM chamfers = mccmg15_chamfers;
MCNUM chamfers_z = mccmg15_chamfers_z;
MCNUM chamfers_lr = mccmg15_chamfers_lr;
MCNUM chamfers_tb = mccmg15_chamfers_tb;
MCNUM nelements = mccmg15_nelements;
MCNUM nu = mccmg15_nu;
MCNUM phase = mccmg15_phase;
char* reflect = mccmg15_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 74149 "ILL_H15_D11.c"
}   /* End of mg15=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[99]) fprintf(stderr, "Warning: No neutron could reach Component[99] mg15\n");
    if (mcAbsorbProp[99]) fprintf(stderr, "Warning: %g events were removed in Component[99] mg15=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[99]);
  /* User FINALLY code for component 'mg16'. */
  SIG_MESSAGE("mg16 (Finally)");
#define mccompcurname  mg16
#define mccompcurtype  Guide_gravity
#define mccompcurindex 100
#define GVars mccmg16_GVars
#define pTable mccmg16_pTable
{   /* Declarations of mg16=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg16_w1;
MCNUM h1 = mccmg16_h1;
MCNUM w2 = mccmg16_w2;
MCNUM h2 = mccmg16_h2;
MCNUM l = mccmg16_l;
MCNUM R0 = mccmg16_R0;
MCNUM Qc = mccmg16_Qc;
MCNUM alpha = mccmg16_alpha;
MCNUM m = mccmg16_m;
MCNUM W = mccmg16_W;
MCNUM nslit = mccmg16_nslit;
MCNUM d = mccmg16_d;
MCNUM mleft = mccmg16_mleft;
MCNUM mright = mccmg16_mright;
MCNUM mtop = mccmg16_mtop;
MCNUM mbottom = mccmg16_mbottom;
MCNUM nhslit = mccmg16_nhslit;
MCNUM G = mccmg16_G;
MCNUM aleft = mccmg16_aleft;
MCNUM aright = mccmg16_aright;
MCNUM atop = mccmg16_atop;
MCNUM abottom = mccmg16_abottom;
MCNUM wavy = mccmg16_wavy;
MCNUM wavy_z = mccmg16_wavy_z;
MCNUM wavy_tb = mccmg16_wavy_tb;
MCNUM wavy_lr = mccmg16_wavy_lr;
MCNUM chamfers = mccmg16_chamfers;
MCNUM chamfers_z = mccmg16_chamfers_z;
MCNUM chamfers_lr = mccmg16_chamfers_lr;
MCNUM chamfers_tb = mccmg16_chamfers_tb;
MCNUM nelements = mccmg16_nelements;
MCNUM nu = mccmg16_nu;
MCNUM phase = mccmg16_phase;
char* reflect = mccmg16_reflect;
#line 562 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{
if (GVars.warnings > 100) {
  fprintf(stderr,"%s: warning: neutron has entered guide, but can not exit !\n", GVars.compcurname);
  fprintf(stderr,"%s: warning: This message has been repeated %g times\n", GVars.compcurname, GVars.warnings);
}
}
#line 74208 "ILL_H15_D11.c"
}   /* End of mg16=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[100]) fprintf(stderr, "Warning: No neutron could reach Component[100] mg16\n");
    if (mcAbsorbProp[100]) fprintf(stderr, "Warning: %g events were removed in Component[100] mg16=Guide_gravity()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[100]);
  /* User FINALLY code for component 'SampleF'. */
  SIG_MESSAGE("SampleF (Finally)");
#define mccompcurname  SampleF
#define mccompcurtype  Monitor_nD
#define mccompcurindex 101
#define user1 mccSampleF_user1
#define user2 mccSampleF_user2
#define user3 mccSampleF_user3
#define DEFS mccSampleF_DEFS
#define Vars mccSampleF_Vars
#define detector mccSampleF_detector
#define offdata mccSampleF_offdata
{   /* Declarations of SampleF=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccSampleF_xwidth;
MCNUM yheight = mccSampleF_yheight;
MCNUM zdepth = mccSampleF_zdepth;
MCNUM xmin = mccSampleF_xmin;
MCNUM xmax = mccSampleF_xmax;
MCNUM ymin = mccSampleF_ymin;
MCNUM ymax = mccSampleF_ymax;
MCNUM zmin = mccSampleF_zmin;
MCNUM zmax = mccSampleF_zmax;
MCNUM bins = mccSampleF_bins;
MCNUM min = mccSampleF_min;
MCNUM max = mccSampleF_max;
MCNUM restore_neutron = mccSampleF_restore_neutron;
MCNUM radius = mccSampleF_radius;
char* options = mccSampleF_options;
char* filename = mccSampleF_filename;
char* geometry = mccSampleF_geometry;
char* username1 = mccSampleF_username1;
char* username2 = mccSampleF_username2;
char* username3 = mccSampleF_username3;
int nowritefile = mccSampleF_nowritefile;
#line 490 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  /* free pointers */
  Monitor_nD_Finally(&DEFS, &Vars);
}
#line 74257 "ILL_H15_D11.c"
}   /* End of SampleF=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[101]) fprintf(stderr, "Warning: No neutron could reach Component[101] SampleF\n");
    if (mcAbsorbProp[101]) fprintf(stderr, "Warning: %g events were removed in Component[101] SampleF=Monitor_nD()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[101]);
  /* User FINALLY code for component 'SampleC'. */
  SIG_MESSAGE("SampleC (Finally)");
#define mccompcurname  SampleC
#define mccompcurtype  Monitor_nD
#define mccompcurindex 102
#define user1 mccSampleC_user1
#define user2 mccSampleC_user2
#define user3 mccSampleC_user3
#define DEFS mccSampleC_DEFS
#define Vars mccSampleC_Vars
#define detector mccSampleC_detector
#define offdata mccSampleC_offdata
{   /* Declarations of SampleC=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccSampleC_xwidth;
MCNUM yheight = mccSampleC_yheight;
MCNUM zdepth = mccSampleC_zdepth;
MCNUM xmin = mccSampleC_xmin;
MCNUM xmax = mccSampleC_xmax;
MCNUM ymin = mccSampleC_ymin;
MCNUM ymax = mccSampleC_ymax;
MCNUM zmin = mccSampleC_zmin;
MCNUM zmax = mccSampleC_zmax;
MCNUM bins = mccSampleC_bins;
MCNUM min = mccSampleC_min;
MCNUM max = mccSampleC_max;
MCNUM restore_neutron = mccSampleC_restore_neutron;
MCNUM radius = mccSampleC_radius;
char* options = mccSampleC_options;
char* filename = mccSampleC_filename;
char* geometry = mccSampleC_geometry;
char* username1 = mccSampleC_username1;
char* username2 = mccSampleC_username2;
char* username3 = mccSampleC_username3;
int nowritefile = mccSampleC_nowritefile;
#line 490 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  /* free pointers */
  Monitor_nD_Finally(&DEFS, &Vars);
}
#line 74311 "ILL_H15_D11.c"
}   /* End of SampleC=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

    if (!mcNCounter[102]) fprintf(stderr, "Warning: No neutron could reach Component[102] SampleC\n");
    if (mcAbsorbProp[102]) fprintf(stderr, "Warning: %g events were removed in Component[102] SampleC=Monitor_nD()\n"
"         (negative time, miss next components, rounding errors, Nan, Inf).\n", mcAbsorbProp[102]);
  mcsiminfo_close(); 
} /* end finally */
#define magnify mcdis_magnify
#define line mcdis_line
#define dashed_line mcdis_dashed_line
#define multiline mcdis_multiline
#define rectangle mcdis_rectangle
#define box mcdis_box
#define circle mcdis_circle
#define cylinder mcdis_cylinder
#define sphere mcdis_sphere
void mcdisplay(void) {
  printf("MCDISPLAY: start\n");
  /* Components MCDISPLAY code. */

  /* MCDISPLAY code for component 'PG'. */
  SIG_MESSAGE("PG (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PG");
#define mccompcurname  PG
#define mccompcurtype  Progress_bar
#define mccompcurindex 1
#define IntermediateCnts mccPG_IntermediateCnts
#define StartTime mccPG_StartTime
#define EndTime mccPG_EndTime
#define CurrentTime mccPG_CurrentTime
{   /* Declarations of PG=Progress_bar() SETTING parameters. */
char* profile = mccPG_profile;
MCNUM percent = mccPG_percent;
MCNUM flag_save = mccPG_flag_save;
MCNUM minutes = mccPG_minutes;
#line 147 "/usr/share/mcstas/2.6rc1/misc/Progress_bar.comp"
{
  
}
#line 74360 "ILL_H15_D11.c"
}   /* End of PG=Progress_bar() SETTING parameter declarations. */
#undef CurrentTime
#undef EndTime
#undef StartTime
#undef IntermediateCnts
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Source'. */
  SIG_MESSAGE("Source (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Source");
#define mccompcurname  Source
#define mccompcurtype  Source_gen
#define mccompcurindex 2
#define p_in mccSource_p_in
#define lambda1 mccSource_lambda1
#define lambda2 mccSource_lambda2
#define lambda3 mccSource_lambda3
#define pTable mccSource_pTable
#define pTable_x mccSource_pTable_x
#define pTable_y mccSource_pTable_y
#define pTable_xmin mccSource_pTable_xmin
#define pTable_xmax mccSource_pTable_xmax
#define pTable_xsum mccSource_pTable_xsum
#define pTable_ymin mccSource_pTable_ymin
#define pTable_ymax mccSource_pTable_ymax
#define pTable_ysum mccSource_pTable_ysum
#define pTable_dxmin mccSource_pTable_dxmin
#define pTable_dxmax mccSource_pTable_dxmax
#define pTable_dymin mccSource_pTable_dymin
#define pTable_dymax mccSource_pTable_dymax
{   /* Declarations of Source=Source_gen() SETTING parameters. */
char* flux_file = mccSource_flux_file;
char* xdiv_file = mccSource_xdiv_file;
char* ydiv_file = mccSource_ydiv_file;
MCNUM radius = mccSource_radius;
MCNUM dist = mccSource_dist;
MCNUM focus_xw = mccSource_focus_xw;
MCNUM focus_yh = mccSource_focus_yh;
MCNUM focus_aw = mccSource_focus_aw;
MCNUM focus_ah = mccSource_focus_ah;
MCNUM E0 = mccSource_E0;
MCNUM dE = mccSource_dE;
MCNUM lambda0 = mccSource_lambda0;
MCNUM dlambda = mccSource_dlambda;
MCNUM I1 = mccSource_I1;
MCNUM yheight = mccSource_yheight;
MCNUM xwidth = mccSource_xwidth;
MCNUM verbose = mccSource_verbose;
MCNUM T1 = mccSource_T1;
MCNUM flux_file_perAA = mccSource_flux_file_perAA;
MCNUM flux_file_log = mccSource_flux_file_log;
MCNUM Lmin = mccSource_Lmin;
MCNUM Lmax = mccSource_Lmax;
MCNUM Emin = mccSource_Emin;
MCNUM Emax = mccSource_Emax;
MCNUM T2 = mccSource_T2;
MCNUM I2 = mccSource_I2;
MCNUM T3 = mccSource_T3;
MCNUM I3 = mccSource_I3;
MCNUM zdepth = mccSource_zdepth;
int target_index = mccSource_target_index;
#line 578 "/usr/share/mcstas/2.6rc1/sources/Source_gen.comp"
{
  double xmin;
  double xmax;
  double ymin;
  double ymax;

  if (radius)
  {
    
    circle("xy",0,0,0,radius);
    if (zdepth) {
      circle("xy",0,0,-zdepth/2,radius);
      circle("xy",0,0, zdepth/2,radius);
    }
  }
  else
  {
    xmin = -xwidth/2; xmax = xwidth/2;
    ymin = -yheight/2; ymax = yheight/2;

    
    multiline(5, (double)xmin, (double)ymin, 0.0,
             (double)xmax, (double)ymin, 0.0,
             (double)xmax, (double)ymax, 0.0,
             (double)xmin, (double)ymax, 0.0,
             (double)xmin, (double)ymin, 0.0);
    if (zdepth) {
      multiline(5, (double)xmin, (double)ymin, -zdepth/2,
             (double)xmax, (double)ymin, -zdepth/2,
             (double)xmax, (double)ymax, -zdepth/2,
             (double)xmin, (double)ymax, -zdepth/2,
             (double)xmin, (double)ymin, -zdepth/2);
      multiline(5, (double)xmin, (double)ymin, zdepth/2,
             (double)xmax, (double)ymin, zdepth/2,
             (double)xmax, (double)ymax, zdepth/2,
             (double)xmin, (double)ymax, zdepth/2,
             (double)xmin, (double)ymin, zdepth/2);
    }
  }
  if (dist) {
    if (focus_aw) focus_xw=dist*tan(focus_aw*DEG2RAD);
    if (focus_ah) focus_yh=dist*tan(focus_ah*DEG2RAD);
    dashed_line(0,0,0, -focus_xw/2,-focus_yh/2,dist, 4);
    dashed_line(0,0,0,  focus_xw/2,-focus_yh/2,dist, 4);
    dashed_line(0,0,0,  focus_xw/2, focus_yh/2,dist, 4);
    dashed_line(0,0,0, -focus_xw/2, focus_yh/2,dist, 4);
  }
}
#line 74473 "ILL_H15_D11.c"
}   /* End of Source=Source_gen() SETTING parameter declarations. */
#undef pTable_dymax
#undef pTable_dymin
#undef pTable_dxmax
#undef pTable_dxmin
#undef pTable_ysum
#undef pTable_ymax
#undef pTable_ymin
#undef pTable_xsum
#undef pTable_xmax
#undef pTable_xmin
#undef pTable_y
#undef pTable_x
#undef pTable
#undef lambda3
#undef lambda2
#undef lambda1
#undef p_in
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'AlWindow1'. */
  SIG_MESSAGE("AlWindow1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "AlWindow1");
#define mccompcurname  AlWindow1
#define mccompcurtype  Al_window
#define mccompcurindex 3
{   /* Declarations of AlWindow1=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow1_thickness;
#line 95 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 74512 "ILL_H15_D11.c"
}   /* End of AlWindow1=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PinkCarter'. */
  SIG_MESSAGE("PinkCarter (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PinkCarter");
#define mccompcurname  PinkCarter
#define mccompcurtype  Guide_gravity
#define mccompcurindex 4
#define GVars mccPinkCarter_GVars
#define pTable mccPinkCarter_pTable
{   /* Declarations of PinkCarter=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccPinkCarter_w1;
MCNUM h1 = mccPinkCarter_h1;
MCNUM w2 = mccPinkCarter_w2;
MCNUM h2 = mccPinkCarter_h2;
MCNUM l = mccPinkCarter_l;
MCNUM R0 = mccPinkCarter_R0;
MCNUM Qc = mccPinkCarter_Qc;
MCNUM alpha = mccPinkCarter_alpha;
MCNUM m = mccPinkCarter_m;
MCNUM W = mccPinkCarter_W;
MCNUM nslit = mccPinkCarter_nslit;
MCNUM d = mccPinkCarter_d;
MCNUM mleft = mccPinkCarter_mleft;
MCNUM mright = mccPinkCarter_mright;
MCNUM mtop = mccPinkCarter_mtop;
MCNUM mbottom = mccPinkCarter_mbottom;
MCNUM nhslit = mccPinkCarter_nhslit;
MCNUM G = mccPinkCarter_G;
MCNUM aleft = mccPinkCarter_aleft;
MCNUM aright = mccPinkCarter_aright;
MCNUM atop = mccPinkCarter_atop;
MCNUM abottom = mccPinkCarter_abottom;
MCNUM wavy = mccPinkCarter_wavy;
MCNUM wavy_z = mccPinkCarter_wavy_z;
MCNUM wavy_tb = mccPinkCarter_wavy_tb;
MCNUM wavy_lr = mccPinkCarter_wavy_lr;
MCNUM chamfers = mccPinkCarter_chamfers;
MCNUM chamfers_z = mccPinkCarter_chamfers_z;
MCNUM chamfers_lr = mccPinkCarter_chamfers_lr;
MCNUM chamfers_tb = mccPinkCarter_chamfers_tb;
MCNUM nelements = mccPinkCarter_nelements;
MCNUM nu = mccPinkCarter_nu;
MCNUM phase = mccPinkCarter_phase;
char* reflect = mccPinkCarter_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 74624 "ILL_H15_D11.c"
}   /* End of PinkCarter=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'AlWindow2'. */
  SIG_MESSAGE("AlWindow2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "AlWindow2");
#define mccompcurname  AlWindow2
#define mccompcurtype  Al_window
#define mccompcurindex 5
{   /* Declarations of AlWindow2=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow2_thickness;
#line 95 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 74648 "ILL_H15_D11.c"
}   /* End of AlWindow2=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'LeadShutter'. */
  SIG_MESSAGE("LeadShutter (McDisplay)");
  printf("MCDISPLAY: component %s\n", "LeadShutter");
#define mccompcurname  LeadShutter
#define mccompcurtype  Guide_gravity
#define mccompcurindex 6
#define GVars mccLeadShutter_GVars
#define pTable mccLeadShutter_pTable
{   /* Declarations of LeadShutter=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccLeadShutter_w1;
MCNUM h1 = mccLeadShutter_h1;
MCNUM w2 = mccLeadShutter_w2;
MCNUM h2 = mccLeadShutter_h2;
MCNUM l = mccLeadShutter_l;
MCNUM R0 = mccLeadShutter_R0;
MCNUM Qc = mccLeadShutter_Qc;
MCNUM alpha = mccLeadShutter_alpha;
MCNUM m = mccLeadShutter_m;
MCNUM W = mccLeadShutter_W;
MCNUM nslit = mccLeadShutter_nslit;
MCNUM d = mccLeadShutter_d;
MCNUM mleft = mccLeadShutter_mleft;
MCNUM mright = mccLeadShutter_mright;
MCNUM mtop = mccLeadShutter_mtop;
MCNUM mbottom = mccLeadShutter_mbottom;
MCNUM nhslit = mccLeadShutter_nhslit;
MCNUM G = mccLeadShutter_G;
MCNUM aleft = mccLeadShutter_aleft;
MCNUM aright = mccLeadShutter_aright;
MCNUM atop = mccLeadShutter_atop;
MCNUM abottom = mccLeadShutter_abottom;
MCNUM wavy = mccLeadShutter_wavy;
MCNUM wavy_z = mccLeadShutter_wavy_z;
MCNUM wavy_tb = mccLeadShutter_wavy_tb;
MCNUM wavy_lr = mccLeadShutter_wavy_lr;
MCNUM chamfers = mccLeadShutter_chamfers;
MCNUM chamfers_z = mccLeadShutter_chamfers_z;
MCNUM chamfers_lr = mccLeadShutter_chamfers_lr;
MCNUM chamfers_tb = mccLeadShutter_chamfers_tb;
MCNUM nelements = mccLeadShutter_nelements;
MCNUM nu = mccLeadShutter_nu;
MCNUM phase = mccLeadShutter_phase;
char* reflect = mccLeadShutter_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 74760 "ILL_H15_D11.c"
}   /* End of LeadShutter=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'AlWindow3'. */
  SIG_MESSAGE("AlWindow3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "AlWindow3");
#define mccompcurname  AlWindow3
#define mccompcurtype  Al_window
#define mccompcurindex 7
{   /* Declarations of AlWindow3=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow3_thickness;
#line 95 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 74784 "ILL_H15_D11.c"
}   /* End of AlWindow3=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'CurvedGuideStart'. */
  SIG_MESSAGE("CurvedGuideStart (McDisplay)");
  printf("MCDISPLAY: component %s\n", "CurvedGuideStart");
#define mccompcurname  CurvedGuideStart
#define mccompcurtype  Arm
#define mccompcurindex 8
#line 40 "/usr/share/mcstas/2.6rc1/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 74804 "ILL_H15_D11.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg1'. */
  SIG_MESSAGE("cg1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg1");
#define mccompcurname  cg1
#define mccompcurtype  Guide_gravity
#define mccompcurindex 9
#define GVars mcccg1_GVars
#define pTable mcccg1_pTable
{   /* Declarations of cg1=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg1_w1;
MCNUM h1 = mcccg1_h1;
MCNUM w2 = mcccg1_w2;
MCNUM h2 = mcccg1_h2;
MCNUM l = mcccg1_l;
MCNUM R0 = mcccg1_R0;
MCNUM Qc = mcccg1_Qc;
MCNUM alpha = mcccg1_alpha;
MCNUM m = mcccg1_m;
MCNUM W = mcccg1_W;
MCNUM nslit = mcccg1_nslit;
MCNUM d = mcccg1_d;
MCNUM mleft = mcccg1_mleft;
MCNUM mright = mcccg1_mright;
MCNUM mtop = mcccg1_mtop;
MCNUM mbottom = mcccg1_mbottom;
MCNUM nhslit = mcccg1_nhslit;
MCNUM G = mcccg1_G;
MCNUM aleft = mcccg1_aleft;
MCNUM aright = mcccg1_aright;
MCNUM atop = mcccg1_atop;
MCNUM abottom = mcccg1_abottom;
MCNUM wavy = mcccg1_wavy;
MCNUM wavy_z = mcccg1_wavy_z;
MCNUM wavy_tb = mcccg1_wavy_tb;
MCNUM wavy_lr = mcccg1_wavy_lr;
MCNUM chamfers = mcccg1_chamfers;
MCNUM chamfers_z = mcccg1_chamfers_z;
MCNUM chamfers_lr = mcccg1_chamfers_lr;
MCNUM chamfers_tb = mcccg1_chamfers_tb;
MCNUM nelements = mcccg1_nelements;
MCNUM nu = mcccg1_nu;
MCNUM phase = mcccg1_phase;
char* reflect = mcccg1_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 74915 "ILL_H15_D11.c"
}   /* End of cg1=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg2'. */
  SIG_MESSAGE("cg2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg2");
#define mccompcurname  cg2
#define mccompcurtype  Guide_gravity
#define mccompcurindex 10
#define GVars mcccg2_GVars
#define pTable mcccg2_pTable
{   /* Declarations of cg2=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg2_w1;
MCNUM h1 = mcccg2_h1;
MCNUM w2 = mcccg2_w2;
MCNUM h2 = mcccg2_h2;
MCNUM l = mcccg2_l;
MCNUM R0 = mcccg2_R0;
MCNUM Qc = mcccg2_Qc;
MCNUM alpha = mcccg2_alpha;
MCNUM m = mcccg2_m;
MCNUM W = mcccg2_W;
MCNUM nslit = mcccg2_nslit;
MCNUM d = mcccg2_d;
MCNUM mleft = mcccg2_mleft;
MCNUM mright = mcccg2_mright;
MCNUM mtop = mcccg2_mtop;
MCNUM mbottom = mcccg2_mbottom;
MCNUM nhslit = mcccg2_nhslit;
MCNUM G = mcccg2_G;
MCNUM aleft = mcccg2_aleft;
MCNUM aright = mcccg2_aright;
MCNUM atop = mcccg2_atop;
MCNUM abottom = mcccg2_abottom;
MCNUM wavy = mcccg2_wavy;
MCNUM wavy_z = mcccg2_wavy_z;
MCNUM wavy_tb = mcccg2_wavy_tb;
MCNUM wavy_lr = mcccg2_wavy_lr;
MCNUM chamfers = mcccg2_chamfers;
MCNUM chamfers_z = mcccg2_chamfers_z;
MCNUM chamfers_lr = mcccg2_chamfers_lr;
MCNUM chamfers_tb = mcccg2_chamfers_tb;
MCNUM nelements = mcccg2_nelements;
MCNUM nu = mcccg2_nu;
MCNUM phase = mcccg2_phase;
char* reflect = mcccg2_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 75029 "ILL_H15_D11.c"
}   /* End of cg2=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg3'. */
  SIG_MESSAGE("cg3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg3");
#define mccompcurname  cg3
#define mccompcurtype  Guide_gravity
#define mccompcurindex 11
#define GVars mcccg3_GVars
#define pTable mcccg3_pTable
{   /* Declarations of cg3=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg3_w1;
MCNUM h1 = mcccg3_h1;
MCNUM w2 = mcccg3_w2;
MCNUM h2 = mcccg3_h2;
MCNUM l = mcccg3_l;
MCNUM R0 = mcccg3_R0;
MCNUM Qc = mcccg3_Qc;
MCNUM alpha = mcccg3_alpha;
MCNUM m = mcccg3_m;
MCNUM W = mcccg3_W;
MCNUM nslit = mcccg3_nslit;
MCNUM d = mcccg3_d;
MCNUM mleft = mcccg3_mleft;
MCNUM mright = mcccg3_mright;
MCNUM mtop = mcccg3_mtop;
MCNUM mbottom = mcccg3_mbottom;
MCNUM nhslit = mcccg3_nhslit;
MCNUM G = mcccg3_G;
MCNUM aleft = mcccg3_aleft;
MCNUM aright = mcccg3_aright;
MCNUM atop = mcccg3_atop;
MCNUM abottom = mcccg3_abottom;
MCNUM wavy = mcccg3_wavy;
MCNUM wavy_z = mcccg3_wavy_z;
MCNUM wavy_tb = mcccg3_wavy_tb;
MCNUM wavy_lr = mcccg3_wavy_lr;
MCNUM chamfers = mcccg3_chamfers;
MCNUM chamfers_z = mcccg3_chamfers_z;
MCNUM chamfers_lr = mcccg3_chamfers_lr;
MCNUM chamfers_tb = mcccg3_chamfers_tb;
MCNUM nelements = mcccg3_nelements;
MCNUM nu = mcccg3_nu;
MCNUM phase = mcccg3_phase;
char* reflect = mcccg3_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 75143 "ILL_H15_D11.c"
}   /* End of cg3=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg4'. */
  SIG_MESSAGE("cg4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg4");
#define mccompcurname  cg4
#define mccompcurtype  Guide_gravity
#define mccompcurindex 12
#define GVars mcccg4_GVars
#define pTable mcccg4_pTable
{   /* Declarations of cg4=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg4_w1;
MCNUM h1 = mcccg4_h1;
MCNUM w2 = mcccg4_w2;
MCNUM h2 = mcccg4_h2;
MCNUM l = mcccg4_l;
MCNUM R0 = mcccg4_R0;
MCNUM Qc = mcccg4_Qc;
MCNUM alpha = mcccg4_alpha;
MCNUM m = mcccg4_m;
MCNUM W = mcccg4_W;
MCNUM nslit = mcccg4_nslit;
MCNUM d = mcccg4_d;
MCNUM mleft = mcccg4_mleft;
MCNUM mright = mcccg4_mright;
MCNUM mtop = mcccg4_mtop;
MCNUM mbottom = mcccg4_mbottom;
MCNUM nhslit = mcccg4_nhslit;
MCNUM G = mcccg4_G;
MCNUM aleft = mcccg4_aleft;
MCNUM aright = mcccg4_aright;
MCNUM atop = mcccg4_atop;
MCNUM abottom = mcccg4_abottom;
MCNUM wavy = mcccg4_wavy;
MCNUM wavy_z = mcccg4_wavy_z;
MCNUM wavy_tb = mcccg4_wavy_tb;
MCNUM wavy_lr = mcccg4_wavy_lr;
MCNUM chamfers = mcccg4_chamfers;
MCNUM chamfers_z = mcccg4_chamfers_z;
MCNUM chamfers_lr = mcccg4_chamfers_lr;
MCNUM chamfers_tb = mcccg4_chamfers_tb;
MCNUM nelements = mcccg4_nelements;
MCNUM nu = mcccg4_nu;
MCNUM phase = mcccg4_phase;
char* reflect = mcccg4_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 75257 "ILL_H15_D11.c"
}   /* End of cg4=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg5'. */
  SIG_MESSAGE("cg5 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg5");
#define mccompcurname  cg5
#define mccompcurtype  Guide_gravity
#define mccompcurindex 13
#define GVars mcccg5_GVars
#define pTable mcccg5_pTable
{   /* Declarations of cg5=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg5_w1;
MCNUM h1 = mcccg5_h1;
MCNUM w2 = mcccg5_w2;
MCNUM h2 = mcccg5_h2;
MCNUM l = mcccg5_l;
MCNUM R0 = mcccg5_R0;
MCNUM Qc = mcccg5_Qc;
MCNUM alpha = mcccg5_alpha;
MCNUM m = mcccg5_m;
MCNUM W = mcccg5_W;
MCNUM nslit = mcccg5_nslit;
MCNUM d = mcccg5_d;
MCNUM mleft = mcccg5_mleft;
MCNUM mright = mcccg5_mright;
MCNUM mtop = mcccg5_mtop;
MCNUM mbottom = mcccg5_mbottom;
MCNUM nhslit = mcccg5_nhslit;
MCNUM G = mcccg5_G;
MCNUM aleft = mcccg5_aleft;
MCNUM aright = mcccg5_aright;
MCNUM atop = mcccg5_atop;
MCNUM abottom = mcccg5_abottom;
MCNUM wavy = mcccg5_wavy;
MCNUM wavy_z = mcccg5_wavy_z;
MCNUM wavy_tb = mcccg5_wavy_tb;
MCNUM wavy_lr = mcccg5_wavy_lr;
MCNUM chamfers = mcccg5_chamfers;
MCNUM chamfers_z = mcccg5_chamfers_z;
MCNUM chamfers_lr = mcccg5_chamfers_lr;
MCNUM chamfers_tb = mcccg5_chamfers_tb;
MCNUM nelements = mcccg5_nelements;
MCNUM nu = mcccg5_nu;
MCNUM phase = mcccg5_phase;
char* reflect = mcccg5_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 75371 "ILL_H15_D11.c"
}   /* End of cg5=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg6'. */
  SIG_MESSAGE("cg6 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg6");
#define mccompcurname  cg6
#define mccompcurtype  Guide_gravity
#define mccompcurindex 14
#define GVars mcccg6_GVars
#define pTable mcccg6_pTable
{   /* Declarations of cg6=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg6_w1;
MCNUM h1 = mcccg6_h1;
MCNUM w2 = mcccg6_w2;
MCNUM h2 = mcccg6_h2;
MCNUM l = mcccg6_l;
MCNUM R0 = mcccg6_R0;
MCNUM Qc = mcccg6_Qc;
MCNUM alpha = mcccg6_alpha;
MCNUM m = mcccg6_m;
MCNUM W = mcccg6_W;
MCNUM nslit = mcccg6_nslit;
MCNUM d = mcccg6_d;
MCNUM mleft = mcccg6_mleft;
MCNUM mright = mcccg6_mright;
MCNUM mtop = mcccg6_mtop;
MCNUM mbottom = mcccg6_mbottom;
MCNUM nhslit = mcccg6_nhslit;
MCNUM G = mcccg6_G;
MCNUM aleft = mcccg6_aleft;
MCNUM aright = mcccg6_aright;
MCNUM atop = mcccg6_atop;
MCNUM abottom = mcccg6_abottom;
MCNUM wavy = mcccg6_wavy;
MCNUM wavy_z = mcccg6_wavy_z;
MCNUM wavy_tb = mcccg6_wavy_tb;
MCNUM wavy_lr = mcccg6_wavy_lr;
MCNUM chamfers = mcccg6_chamfers;
MCNUM chamfers_z = mcccg6_chamfers_z;
MCNUM chamfers_lr = mcccg6_chamfers_lr;
MCNUM chamfers_tb = mcccg6_chamfers_tb;
MCNUM nelements = mcccg6_nelements;
MCNUM nu = mcccg6_nu;
MCNUM phase = mcccg6_phase;
char* reflect = mcccg6_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 75485 "ILL_H15_D11.c"
}   /* End of cg6=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg7'. */
  SIG_MESSAGE("cg7 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg7");
#define mccompcurname  cg7
#define mccompcurtype  Guide_gravity
#define mccompcurindex 15
#define GVars mcccg7_GVars
#define pTable mcccg7_pTable
{   /* Declarations of cg7=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg7_w1;
MCNUM h1 = mcccg7_h1;
MCNUM w2 = mcccg7_w2;
MCNUM h2 = mcccg7_h2;
MCNUM l = mcccg7_l;
MCNUM R0 = mcccg7_R0;
MCNUM Qc = mcccg7_Qc;
MCNUM alpha = mcccg7_alpha;
MCNUM m = mcccg7_m;
MCNUM W = mcccg7_W;
MCNUM nslit = mcccg7_nslit;
MCNUM d = mcccg7_d;
MCNUM mleft = mcccg7_mleft;
MCNUM mright = mcccg7_mright;
MCNUM mtop = mcccg7_mtop;
MCNUM mbottom = mcccg7_mbottom;
MCNUM nhslit = mcccg7_nhslit;
MCNUM G = mcccg7_G;
MCNUM aleft = mcccg7_aleft;
MCNUM aright = mcccg7_aright;
MCNUM atop = mcccg7_atop;
MCNUM abottom = mcccg7_abottom;
MCNUM wavy = mcccg7_wavy;
MCNUM wavy_z = mcccg7_wavy_z;
MCNUM wavy_tb = mcccg7_wavy_tb;
MCNUM wavy_lr = mcccg7_wavy_lr;
MCNUM chamfers = mcccg7_chamfers;
MCNUM chamfers_z = mcccg7_chamfers_z;
MCNUM chamfers_lr = mcccg7_chamfers_lr;
MCNUM chamfers_tb = mcccg7_chamfers_tb;
MCNUM nelements = mcccg7_nelements;
MCNUM nu = mcccg7_nu;
MCNUM phase = mcccg7_phase;
char* reflect = mcccg7_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 75599 "ILL_H15_D11.c"
}   /* End of cg7=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg8'. */
  SIG_MESSAGE("cg8 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg8");
#define mccompcurname  cg8
#define mccompcurtype  Guide_gravity
#define mccompcurindex 16
#define GVars mcccg8_GVars
#define pTable mcccg8_pTable
{   /* Declarations of cg8=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg8_w1;
MCNUM h1 = mcccg8_h1;
MCNUM w2 = mcccg8_w2;
MCNUM h2 = mcccg8_h2;
MCNUM l = mcccg8_l;
MCNUM R0 = mcccg8_R0;
MCNUM Qc = mcccg8_Qc;
MCNUM alpha = mcccg8_alpha;
MCNUM m = mcccg8_m;
MCNUM W = mcccg8_W;
MCNUM nslit = mcccg8_nslit;
MCNUM d = mcccg8_d;
MCNUM mleft = mcccg8_mleft;
MCNUM mright = mcccg8_mright;
MCNUM mtop = mcccg8_mtop;
MCNUM mbottom = mcccg8_mbottom;
MCNUM nhslit = mcccg8_nhslit;
MCNUM G = mcccg8_G;
MCNUM aleft = mcccg8_aleft;
MCNUM aright = mcccg8_aright;
MCNUM atop = mcccg8_atop;
MCNUM abottom = mcccg8_abottom;
MCNUM wavy = mcccg8_wavy;
MCNUM wavy_z = mcccg8_wavy_z;
MCNUM wavy_tb = mcccg8_wavy_tb;
MCNUM wavy_lr = mcccg8_wavy_lr;
MCNUM chamfers = mcccg8_chamfers;
MCNUM chamfers_z = mcccg8_chamfers_z;
MCNUM chamfers_lr = mcccg8_chamfers_lr;
MCNUM chamfers_tb = mcccg8_chamfers_tb;
MCNUM nelements = mcccg8_nelements;
MCNUM nu = mcccg8_nu;
MCNUM phase = mcccg8_phase;
char* reflect = mcccg8_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 75713 "ILL_H15_D11.c"
}   /* End of cg8=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg9'. */
  SIG_MESSAGE("cg9 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg9");
#define mccompcurname  cg9
#define mccompcurtype  Guide_gravity
#define mccompcurindex 17
#define GVars mcccg9_GVars
#define pTable mcccg9_pTable
{   /* Declarations of cg9=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg9_w1;
MCNUM h1 = mcccg9_h1;
MCNUM w2 = mcccg9_w2;
MCNUM h2 = mcccg9_h2;
MCNUM l = mcccg9_l;
MCNUM R0 = mcccg9_R0;
MCNUM Qc = mcccg9_Qc;
MCNUM alpha = mcccg9_alpha;
MCNUM m = mcccg9_m;
MCNUM W = mcccg9_W;
MCNUM nslit = mcccg9_nslit;
MCNUM d = mcccg9_d;
MCNUM mleft = mcccg9_mleft;
MCNUM mright = mcccg9_mright;
MCNUM mtop = mcccg9_mtop;
MCNUM mbottom = mcccg9_mbottom;
MCNUM nhslit = mcccg9_nhslit;
MCNUM G = mcccg9_G;
MCNUM aleft = mcccg9_aleft;
MCNUM aright = mcccg9_aright;
MCNUM atop = mcccg9_atop;
MCNUM abottom = mcccg9_abottom;
MCNUM wavy = mcccg9_wavy;
MCNUM wavy_z = mcccg9_wavy_z;
MCNUM wavy_tb = mcccg9_wavy_tb;
MCNUM wavy_lr = mcccg9_wavy_lr;
MCNUM chamfers = mcccg9_chamfers;
MCNUM chamfers_z = mcccg9_chamfers_z;
MCNUM chamfers_lr = mcccg9_chamfers_lr;
MCNUM chamfers_tb = mcccg9_chamfers_tb;
MCNUM nelements = mcccg9_nelements;
MCNUM nu = mcccg9_nu;
MCNUM phase = mcccg9_phase;
char* reflect = mcccg9_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 75827 "ILL_H15_D11.c"
}   /* End of cg9=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg10'. */
  SIG_MESSAGE("cg10 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg10");
#define mccompcurname  cg10
#define mccompcurtype  Guide_gravity
#define mccompcurindex 18
#define GVars mcccg10_GVars
#define pTable mcccg10_pTable
{   /* Declarations of cg10=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg10_w1;
MCNUM h1 = mcccg10_h1;
MCNUM w2 = mcccg10_w2;
MCNUM h2 = mcccg10_h2;
MCNUM l = mcccg10_l;
MCNUM R0 = mcccg10_R0;
MCNUM Qc = mcccg10_Qc;
MCNUM alpha = mcccg10_alpha;
MCNUM m = mcccg10_m;
MCNUM W = mcccg10_W;
MCNUM nslit = mcccg10_nslit;
MCNUM d = mcccg10_d;
MCNUM mleft = mcccg10_mleft;
MCNUM mright = mcccg10_mright;
MCNUM mtop = mcccg10_mtop;
MCNUM mbottom = mcccg10_mbottom;
MCNUM nhslit = mcccg10_nhslit;
MCNUM G = mcccg10_G;
MCNUM aleft = mcccg10_aleft;
MCNUM aright = mcccg10_aright;
MCNUM atop = mcccg10_atop;
MCNUM abottom = mcccg10_abottom;
MCNUM wavy = mcccg10_wavy;
MCNUM wavy_z = mcccg10_wavy_z;
MCNUM wavy_tb = mcccg10_wavy_tb;
MCNUM wavy_lr = mcccg10_wavy_lr;
MCNUM chamfers = mcccg10_chamfers;
MCNUM chamfers_z = mcccg10_chamfers_z;
MCNUM chamfers_lr = mcccg10_chamfers_lr;
MCNUM chamfers_tb = mcccg10_chamfers_tb;
MCNUM nelements = mcccg10_nelements;
MCNUM nu = mcccg10_nu;
MCNUM phase = mcccg10_phase;
char* reflect = mcccg10_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 75941 "ILL_H15_D11.c"
}   /* End of cg10=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg11'. */
  SIG_MESSAGE("cg11 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg11");
#define mccompcurname  cg11
#define mccompcurtype  Guide_gravity
#define mccompcurindex 19
#define GVars mcccg11_GVars
#define pTable mcccg11_pTable
{   /* Declarations of cg11=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg11_w1;
MCNUM h1 = mcccg11_h1;
MCNUM w2 = mcccg11_w2;
MCNUM h2 = mcccg11_h2;
MCNUM l = mcccg11_l;
MCNUM R0 = mcccg11_R0;
MCNUM Qc = mcccg11_Qc;
MCNUM alpha = mcccg11_alpha;
MCNUM m = mcccg11_m;
MCNUM W = mcccg11_W;
MCNUM nslit = mcccg11_nslit;
MCNUM d = mcccg11_d;
MCNUM mleft = mcccg11_mleft;
MCNUM mright = mcccg11_mright;
MCNUM mtop = mcccg11_mtop;
MCNUM mbottom = mcccg11_mbottom;
MCNUM nhslit = mcccg11_nhslit;
MCNUM G = mcccg11_G;
MCNUM aleft = mcccg11_aleft;
MCNUM aright = mcccg11_aright;
MCNUM atop = mcccg11_atop;
MCNUM abottom = mcccg11_abottom;
MCNUM wavy = mcccg11_wavy;
MCNUM wavy_z = mcccg11_wavy_z;
MCNUM wavy_tb = mcccg11_wavy_tb;
MCNUM wavy_lr = mcccg11_wavy_lr;
MCNUM chamfers = mcccg11_chamfers;
MCNUM chamfers_z = mcccg11_chamfers_z;
MCNUM chamfers_lr = mcccg11_chamfers_lr;
MCNUM chamfers_tb = mcccg11_chamfers_tb;
MCNUM nelements = mcccg11_nelements;
MCNUM nu = mcccg11_nu;
MCNUM phase = mcccg11_phase;
char* reflect = mcccg11_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 76055 "ILL_H15_D11.c"
}   /* End of cg11=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg12'. */
  SIG_MESSAGE("cg12 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg12");
#define mccompcurname  cg12
#define mccompcurtype  Guide_gravity
#define mccompcurindex 20
#define GVars mcccg12_GVars
#define pTable mcccg12_pTable
{   /* Declarations of cg12=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg12_w1;
MCNUM h1 = mcccg12_h1;
MCNUM w2 = mcccg12_w2;
MCNUM h2 = mcccg12_h2;
MCNUM l = mcccg12_l;
MCNUM R0 = mcccg12_R0;
MCNUM Qc = mcccg12_Qc;
MCNUM alpha = mcccg12_alpha;
MCNUM m = mcccg12_m;
MCNUM W = mcccg12_W;
MCNUM nslit = mcccg12_nslit;
MCNUM d = mcccg12_d;
MCNUM mleft = mcccg12_mleft;
MCNUM mright = mcccg12_mright;
MCNUM mtop = mcccg12_mtop;
MCNUM mbottom = mcccg12_mbottom;
MCNUM nhslit = mcccg12_nhslit;
MCNUM G = mcccg12_G;
MCNUM aleft = mcccg12_aleft;
MCNUM aright = mcccg12_aright;
MCNUM atop = mcccg12_atop;
MCNUM abottom = mcccg12_abottom;
MCNUM wavy = mcccg12_wavy;
MCNUM wavy_z = mcccg12_wavy_z;
MCNUM wavy_tb = mcccg12_wavy_tb;
MCNUM wavy_lr = mcccg12_wavy_lr;
MCNUM chamfers = mcccg12_chamfers;
MCNUM chamfers_z = mcccg12_chamfers_z;
MCNUM chamfers_lr = mcccg12_chamfers_lr;
MCNUM chamfers_tb = mcccg12_chamfers_tb;
MCNUM nelements = mcccg12_nelements;
MCNUM nu = mcccg12_nu;
MCNUM phase = mcccg12_phase;
char* reflect = mcccg12_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 76169 "ILL_H15_D11.c"
}   /* End of cg12=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg13'. */
  SIG_MESSAGE("cg13 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg13");
#define mccompcurname  cg13
#define mccompcurtype  Guide_gravity
#define mccompcurindex 21
#define GVars mcccg13_GVars
#define pTable mcccg13_pTable
{   /* Declarations of cg13=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg13_w1;
MCNUM h1 = mcccg13_h1;
MCNUM w2 = mcccg13_w2;
MCNUM h2 = mcccg13_h2;
MCNUM l = mcccg13_l;
MCNUM R0 = mcccg13_R0;
MCNUM Qc = mcccg13_Qc;
MCNUM alpha = mcccg13_alpha;
MCNUM m = mcccg13_m;
MCNUM W = mcccg13_W;
MCNUM nslit = mcccg13_nslit;
MCNUM d = mcccg13_d;
MCNUM mleft = mcccg13_mleft;
MCNUM mright = mcccg13_mright;
MCNUM mtop = mcccg13_mtop;
MCNUM mbottom = mcccg13_mbottom;
MCNUM nhslit = mcccg13_nhslit;
MCNUM G = mcccg13_G;
MCNUM aleft = mcccg13_aleft;
MCNUM aright = mcccg13_aright;
MCNUM atop = mcccg13_atop;
MCNUM abottom = mcccg13_abottom;
MCNUM wavy = mcccg13_wavy;
MCNUM wavy_z = mcccg13_wavy_z;
MCNUM wavy_tb = mcccg13_wavy_tb;
MCNUM wavy_lr = mcccg13_wavy_lr;
MCNUM chamfers = mcccg13_chamfers;
MCNUM chamfers_z = mcccg13_chamfers_z;
MCNUM chamfers_lr = mcccg13_chamfers_lr;
MCNUM chamfers_tb = mcccg13_chamfers_tb;
MCNUM nelements = mcccg13_nelements;
MCNUM nu = mcccg13_nu;
MCNUM phase = mcccg13_phase;
char* reflect = mcccg13_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 76283 "ILL_H15_D11.c"
}   /* End of cg13=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg14'. */
  SIG_MESSAGE("cg14 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg14");
#define mccompcurname  cg14
#define mccompcurtype  Guide_gravity
#define mccompcurindex 22
#define GVars mcccg14_GVars
#define pTable mcccg14_pTable
{   /* Declarations of cg14=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg14_w1;
MCNUM h1 = mcccg14_h1;
MCNUM w2 = mcccg14_w2;
MCNUM h2 = mcccg14_h2;
MCNUM l = mcccg14_l;
MCNUM R0 = mcccg14_R0;
MCNUM Qc = mcccg14_Qc;
MCNUM alpha = mcccg14_alpha;
MCNUM m = mcccg14_m;
MCNUM W = mcccg14_W;
MCNUM nslit = mcccg14_nslit;
MCNUM d = mcccg14_d;
MCNUM mleft = mcccg14_mleft;
MCNUM mright = mcccg14_mright;
MCNUM mtop = mcccg14_mtop;
MCNUM mbottom = mcccg14_mbottom;
MCNUM nhslit = mcccg14_nhslit;
MCNUM G = mcccg14_G;
MCNUM aleft = mcccg14_aleft;
MCNUM aright = mcccg14_aright;
MCNUM atop = mcccg14_atop;
MCNUM abottom = mcccg14_abottom;
MCNUM wavy = mcccg14_wavy;
MCNUM wavy_z = mcccg14_wavy_z;
MCNUM wavy_tb = mcccg14_wavy_tb;
MCNUM wavy_lr = mcccg14_wavy_lr;
MCNUM chamfers = mcccg14_chamfers;
MCNUM chamfers_z = mcccg14_chamfers_z;
MCNUM chamfers_lr = mcccg14_chamfers_lr;
MCNUM chamfers_tb = mcccg14_chamfers_tb;
MCNUM nelements = mcccg14_nelements;
MCNUM nu = mcccg14_nu;
MCNUM phase = mcccg14_phase;
char* reflect = mcccg14_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 76397 "ILL_H15_D11.c"
}   /* End of cg14=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg15'. */
  SIG_MESSAGE("cg15 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg15");
#define mccompcurname  cg15
#define mccompcurtype  Guide_gravity
#define mccompcurindex 23
#define GVars mcccg15_GVars
#define pTable mcccg15_pTable
{   /* Declarations of cg15=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg15_w1;
MCNUM h1 = mcccg15_h1;
MCNUM w2 = mcccg15_w2;
MCNUM h2 = mcccg15_h2;
MCNUM l = mcccg15_l;
MCNUM R0 = mcccg15_R0;
MCNUM Qc = mcccg15_Qc;
MCNUM alpha = mcccg15_alpha;
MCNUM m = mcccg15_m;
MCNUM W = mcccg15_W;
MCNUM nslit = mcccg15_nslit;
MCNUM d = mcccg15_d;
MCNUM mleft = mcccg15_mleft;
MCNUM mright = mcccg15_mright;
MCNUM mtop = mcccg15_mtop;
MCNUM mbottom = mcccg15_mbottom;
MCNUM nhslit = mcccg15_nhslit;
MCNUM G = mcccg15_G;
MCNUM aleft = mcccg15_aleft;
MCNUM aright = mcccg15_aright;
MCNUM atop = mcccg15_atop;
MCNUM abottom = mcccg15_abottom;
MCNUM wavy = mcccg15_wavy;
MCNUM wavy_z = mcccg15_wavy_z;
MCNUM wavy_tb = mcccg15_wavy_tb;
MCNUM wavy_lr = mcccg15_wavy_lr;
MCNUM chamfers = mcccg15_chamfers;
MCNUM chamfers_z = mcccg15_chamfers_z;
MCNUM chamfers_lr = mcccg15_chamfers_lr;
MCNUM chamfers_tb = mcccg15_chamfers_tb;
MCNUM nelements = mcccg15_nelements;
MCNUM nu = mcccg15_nu;
MCNUM phase = mcccg15_phase;
char* reflect = mcccg15_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 76511 "ILL_H15_D11.c"
}   /* End of cg15=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg16'. */
  SIG_MESSAGE("cg16 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg16");
#define mccompcurname  cg16
#define mccompcurtype  Guide_gravity
#define mccompcurindex 24
#define GVars mcccg16_GVars
#define pTable mcccg16_pTable
{   /* Declarations of cg16=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg16_w1;
MCNUM h1 = mcccg16_h1;
MCNUM w2 = mcccg16_w2;
MCNUM h2 = mcccg16_h2;
MCNUM l = mcccg16_l;
MCNUM R0 = mcccg16_R0;
MCNUM Qc = mcccg16_Qc;
MCNUM alpha = mcccg16_alpha;
MCNUM m = mcccg16_m;
MCNUM W = mcccg16_W;
MCNUM nslit = mcccg16_nslit;
MCNUM d = mcccg16_d;
MCNUM mleft = mcccg16_mleft;
MCNUM mright = mcccg16_mright;
MCNUM mtop = mcccg16_mtop;
MCNUM mbottom = mcccg16_mbottom;
MCNUM nhslit = mcccg16_nhslit;
MCNUM G = mcccg16_G;
MCNUM aleft = mcccg16_aleft;
MCNUM aright = mcccg16_aright;
MCNUM atop = mcccg16_atop;
MCNUM abottom = mcccg16_abottom;
MCNUM wavy = mcccg16_wavy;
MCNUM wavy_z = mcccg16_wavy_z;
MCNUM wavy_tb = mcccg16_wavy_tb;
MCNUM wavy_lr = mcccg16_wavy_lr;
MCNUM chamfers = mcccg16_chamfers;
MCNUM chamfers_z = mcccg16_chamfers_z;
MCNUM chamfers_lr = mcccg16_chamfers_lr;
MCNUM chamfers_tb = mcccg16_chamfers_tb;
MCNUM nelements = mcccg16_nelements;
MCNUM nu = mcccg16_nu;
MCNUM phase = mcccg16_phase;
char* reflect = mcccg16_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 76625 "ILL_H15_D11.c"
}   /* End of cg16=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg17'. */
  SIG_MESSAGE("cg17 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg17");
#define mccompcurname  cg17
#define mccompcurtype  Guide_gravity
#define mccompcurindex 25
#define GVars mcccg17_GVars
#define pTable mcccg17_pTable
{   /* Declarations of cg17=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg17_w1;
MCNUM h1 = mcccg17_h1;
MCNUM w2 = mcccg17_w2;
MCNUM h2 = mcccg17_h2;
MCNUM l = mcccg17_l;
MCNUM R0 = mcccg17_R0;
MCNUM Qc = mcccg17_Qc;
MCNUM alpha = mcccg17_alpha;
MCNUM m = mcccg17_m;
MCNUM W = mcccg17_W;
MCNUM nslit = mcccg17_nslit;
MCNUM d = mcccg17_d;
MCNUM mleft = mcccg17_mleft;
MCNUM mright = mcccg17_mright;
MCNUM mtop = mcccg17_mtop;
MCNUM mbottom = mcccg17_mbottom;
MCNUM nhslit = mcccg17_nhslit;
MCNUM G = mcccg17_G;
MCNUM aleft = mcccg17_aleft;
MCNUM aright = mcccg17_aright;
MCNUM atop = mcccg17_atop;
MCNUM abottom = mcccg17_abottom;
MCNUM wavy = mcccg17_wavy;
MCNUM wavy_z = mcccg17_wavy_z;
MCNUM wavy_tb = mcccg17_wavy_tb;
MCNUM wavy_lr = mcccg17_wavy_lr;
MCNUM chamfers = mcccg17_chamfers;
MCNUM chamfers_z = mcccg17_chamfers_z;
MCNUM chamfers_lr = mcccg17_chamfers_lr;
MCNUM chamfers_tb = mcccg17_chamfers_tb;
MCNUM nelements = mcccg17_nelements;
MCNUM nu = mcccg17_nu;
MCNUM phase = mcccg17_phase;
char* reflect = mcccg17_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 76739 "ILL_H15_D11.c"
}   /* End of cg17=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg18'. */
  SIG_MESSAGE("cg18 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg18");
#define mccompcurname  cg18
#define mccompcurtype  Guide_gravity
#define mccompcurindex 26
#define GVars mcccg18_GVars
#define pTable mcccg18_pTable
{   /* Declarations of cg18=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg18_w1;
MCNUM h1 = mcccg18_h1;
MCNUM w2 = mcccg18_w2;
MCNUM h2 = mcccg18_h2;
MCNUM l = mcccg18_l;
MCNUM R0 = mcccg18_R0;
MCNUM Qc = mcccg18_Qc;
MCNUM alpha = mcccg18_alpha;
MCNUM m = mcccg18_m;
MCNUM W = mcccg18_W;
MCNUM nslit = mcccg18_nslit;
MCNUM d = mcccg18_d;
MCNUM mleft = mcccg18_mleft;
MCNUM mright = mcccg18_mright;
MCNUM mtop = mcccg18_mtop;
MCNUM mbottom = mcccg18_mbottom;
MCNUM nhslit = mcccg18_nhslit;
MCNUM G = mcccg18_G;
MCNUM aleft = mcccg18_aleft;
MCNUM aright = mcccg18_aright;
MCNUM atop = mcccg18_atop;
MCNUM abottom = mcccg18_abottom;
MCNUM wavy = mcccg18_wavy;
MCNUM wavy_z = mcccg18_wavy_z;
MCNUM wavy_tb = mcccg18_wavy_tb;
MCNUM wavy_lr = mcccg18_wavy_lr;
MCNUM chamfers = mcccg18_chamfers;
MCNUM chamfers_z = mcccg18_chamfers_z;
MCNUM chamfers_lr = mcccg18_chamfers_lr;
MCNUM chamfers_tb = mcccg18_chamfers_tb;
MCNUM nelements = mcccg18_nelements;
MCNUM nu = mcccg18_nu;
MCNUM phase = mcccg18_phase;
char* reflect = mcccg18_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 76853 "ILL_H15_D11.c"
}   /* End of cg18=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg19'. */
  SIG_MESSAGE("cg19 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg19");
#define mccompcurname  cg19
#define mccompcurtype  Guide_gravity
#define mccompcurindex 27
#define GVars mcccg19_GVars
#define pTable mcccg19_pTable
{   /* Declarations of cg19=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg19_w1;
MCNUM h1 = mcccg19_h1;
MCNUM w2 = mcccg19_w2;
MCNUM h2 = mcccg19_h2;
MCNUM l = mcccg19_l;
MCNUM R0 = mcccg19_R0;
MCNUM Qc = mcccg19_Qc;
MCNUM alpha = mcccg19_alpha;
MCNUM m = mcccg19_m;
MCNUM W = mcccg19_W;
MCNUM nslit = mcccg19_nslit;
MCNUM d = mcccg19_d;
MCNUM mleft = mcccg19_mleft;
MCNUM mright = mcccg19_mright;
MCNUM mtop = mcccg19_mtop;
MCNUM mbottom = mcccg19_mbottom;
MCNUM nhslit = mcccg19_nhslit;
MCNUM G = mcccg19_G;
MCNUM aleft = mcccg19_aleft;
MCNUM aright = mcccg19_aright;
MCNUM atop = mcccg19_atop;
MCNUM abottom = mcccg19_abottom;
MCNUM wavy = mcccg19_wavy;
MCNUM wavy_z = mcccg19_wavy_z;
MCNUM wavy_tb = mcccg19_wavy_tb;
MCNUM wavy_lr = mcccg19_wavy_lr;
MCNUM chamfers = mcccg19_chamfers;
MCNUM chamfers_z = mcccg19_chamfers_z;
MCNUM chamfers_lr = mcccg19_chamfers_lr;
MCNUM chamfers_tb = mcccg19_chamfers_tb;
MCNUM nelements = mcccg19_nelements;
MCNUM nu = mcccg19_nu;
MCNUM phase = mcccg19_phase;
char* reflect = mcccg19_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 76967 "ILL_H15_D11.c"
}   /* End of cg19=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg20'. */
  SIG_MESSAGE("cg20 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg20");
#define mccompcurname  cg20
#define mccompcurtype  Guide_gravity
#define mccompcurindex 28
#define GVars mcccg20_GVars
#define pTable mcccg20_pTable
{   /* Declarations of cg20=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg20_w1;
MCNUM h1 = mcccg20_h1;
MCNUM w2 = mcccg20_w2;
MCNUM h2 = mcccg20_h2;
MCNUM l = mcccg20_l;
MCNUM R0 = mcccg20_R0;
MCNUM Qc = mcccg20_Qc;
MCNUM alpha = mcccg20_alpha;
MCNUM m = mcccg20_m;
MCNUM W = mcccg20_W;
MCNUM nslit = mcccg20_nslit;
MCNUM d = mcccg20_d;
MCNUM mleft = mcccg20_mleft;
MCNUM mright = mcccg20_mright;
MCNUM mtop = mcccg20_mtop;
MCNUM mbottom = mcccg20_mbottom;
MCNUM nhslit = mcccg20_nhslit;
MCNUM G = mcccg20_G;
MCNUM aleft = mcccg20_aleft;
MCNUM aright = mcccg20_aright;
MCNUM atop = mcccg20_atop;
MCNUM abottom = mcccg20_abottom;
MCNUM wavy = mcccg20_wavy;
MCNUM wavy_z = mcccg20_wavy_z;
MCNUM wavy_tb = mcccg20_wavy_tb;
MCNUM wavy_lr = mcccg20_wavy_lr;
MCNUM chamfers = mcccg20_chamfers;
MCNUM chamfers_z = mcccg20_chamfers_z;
MCNUM chamfers_lr = mcccg20_chamfers_lr;
MCNUM chamfers_tb = mcccg20_chamfers_tb;
MCNUM nelements = mcccg20_nelements;
MCNUM nu = mcccg20_nu;
MCNUM phase = mcccg20_phase;
char* reflect = mcccg20_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 77081 "ILL_H15_D11.c"
}   /* End of cg20=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg21'. */
  SIG_MESSAGE("cg21 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg21");
#define mccompcurname  cg21
#define mccompcurtype  Guide_gravity
#define mccompcurindex 29
#define GVars mcccg21_GVars
#define pTable mcccg21_pTable
{   /* Declarations of cg21=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg21_w1;
MCNUM h1 = mcccg21_h1;
MCNUM w2 = mcccg21_w2;
MCNUM h2 = mcccg21_h2;
MCNUM l = mcccg21_l;
MCNUM R0 = mcccg21_R0;
MCNUM Qc = mcccg21_Qc;
MCNUM alpha = mcccg21_alpha;
MCNUM m = mcccg21_m;
MCNUM W = mcccg21_W;
MCNUM nslit = mcccg21_nslit;
MCNUM d = mcccg21_d;
MCNUM mleft = mcccg21_mleft;
MCNUM mright = mcccg21_mright;
MCNUM mtop = mcccg21_mtop;
MCNUM mbottom = mcccg21_mbottom;
MCNUM nhslit = mcccg21_nhslit;
MCNUM G = mcccg21_G;
MCNUM aleft = mcccg21_aleft;
MCNUM aright = mcccg21_aright;
MCNUM atop = mcccg21_atop;
MCNUM abottom = mcccg21_abottom;
MCNUM wavy = mcccg21_wavy;
MCNUM wavy_z = mcccg21_wavy_z;
MCNUM wavy_tb = mcccg21_wavy_tb;
MCNUM wavy_lr = mcccg21_wavy_lr;
MCNUM chamfers = mcccg21_chamfers;
MCNUM chamfers_z = mcccg21_chamfers_z;
MCNUM chamfers_lr = mcccg21_chamfers_lr;
MCNUM chamfers_tb = mcccg21_chamfers_tb;
MCNUM nelements = mcccg21_nelements;
MCNUM nu = mcccg21_nu;
MCNUM phase = mcccg21_phase;
char* reflect = mcccg21_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 77195 "ILL_H15_D11.c"
}   /* End of cg21=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg22'. */
  SIG_MESSAGE("cg22 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg22");
#define mccompcurname  cg22
#define mccompcurtype  Guide_gravity
#define mccompcurindex 30
#define GVars mcccg22_GVars
#define pTable mcccg22_pTable
{   /* Declarations of cg22=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg22_w1;
MCNUM h1 = mcccg22_h1;
MCNUM w2 = mcccg22_w2;
MCNUM h2 = mcccg22_h2;
MCNUM l = mcccg22_l;
MCNUM R0 = mcccg22_R0;
MCNUM Qc = mcccg22_Qc;
MCNUM alpha = mcccg22_alpha;
MCNUM m = mcccg22_m;
MCNUM W = mcccg22_W;
MCNUM nslit = mcccg22_nslit;
MCNUM d = mcccg22_d;
MCNUM mleft = mcccg22_mleft;
MCNUM mright = mcccg22_mright;
MCNUM mtop = mcccg22_mtop;
MCNUM mbottom = mcccg22_mbottom;
MCNUM nhslit = mcccg22_nhslit;
MCNUM G = mcccg22_G;
MCNUM aleft = mcccg22_aleft;
MCNUM aright = mcccg22_aright;
MCNUM atop = mcccg22_atop;
MCNUM abottom = mcccg22_abottom;
MCNUM wavy = mcccg22_wavy;
MCNUM wavy_z = mcccg22_wavy_z;
MCNUM wavy_tb = mcccg22_wavy_tb;
MCNUM wavy_lr = mcccg22_wavy_lr;
MCNUM chamfers = mcccg22_chamfers;
MCNUM chamfers_z = mcccg22_chamfers_z;
MCNUM chamfers_lr = mcccg22_chamfers_lr;
MCNUM chamfers_tb = mcccg22_chamfers_tb;
MCNUM nelements = mcccg22_nelements;
MCNUM nu = mcccg22_nu;
MCNUM phase = mcccg22_phase;
char* reflect = mcccg22_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 77309 "ILL_H15_D11.c"
}   /* End of cg22=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg23'. */
  SIG_MESSAGE("cg23 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg23");
#define mccompcurname  cg23
#define mccompcurtype  Guide_gravity
#define mccompcurindex 31
#define GVars mcccg23_GVars
#define pTable mcccg23_pTable
{   /* Declarations of cg23=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg23_w1;
MCNUM h1 = mcccg23_h1;
MCNUM w2 = mcccg23_w2;
MCNUM h2 = mcccg23_h2;
MCNUM l = mcccg23_l;
MCNUM R0 = mcccg23_R0;
MCNUM Qc = mcccg23_Qc;
MCNUM alpha = mcccg23_alpha;
MCNUM m = mcccg23_m;
MCNUM W = mcccg23_W;
MCNUM nslit = mcccg23_nslit;
MCNUM d = mcccg23_d;
MCNUM mleft = mcccg23_mleft;
MCNUM mright = mcccg23_mright;
MCNUM mtop = mcccg23_mtop;
MCNUM mbottom = mcccg23_mbottom;
MCNUM nhslit = mcccg23_nhslit;
MCNUM G = mcccg23_G;
MCNUM aleft = mcccg23_aleft;
MCNUM aright = mcccg23_aright;
MCNUM atop = mcccg23_atop;
MCNUM abottom = mcccg23_abottom;
MCNUM wavy = mcccg23_wavy;
MCNUM wavy_z = mcccg23_wavy_z;
MCNUM wavy_tb = mcccg23_wavy_tb;
MCNUM wavy_lr = mcccg23_wavy_lr;
MCNUM chamfers = mcccg23_chamfers;
MCNUM chamfers_z = mcccg23_chamfers_z;
MCNUM chamfers_lr = mcccg23_chamfers_lr;
MCNUM chamfers_tb = mcccg23_chamfers_tb;
MCNUM nelements = mcccg23_nelements;
MCNUM nu = mcccg23_nu;
MCNUM phase = mcccg23_phase;
char* reflect = mcccg23_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 77423 "ILL_H15_D11.c"
}   /* End of cg23=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg24'. */
  SIG_MESSAGE("cg24 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg24");
#define mccompcurname  cg24
#define mccompcurtype  Guide_gravity
#define mccompcurindex 32
#define GVars mcccg24_GVars
#define pTable mcccg24_pTable
{   /* Declarations of cg24=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg24_w1;
MCNUM h1 = mcccg24_h1;
MCNUM w2 = mcccg24_w2;
MCNUM h2 = mcccg24_h2;
MCNUM l = mcccg24_l;
MCNUM R0 = mcccg24_R0;
MCNUM Qc = mcccg24_Qc;
MCNUM alpha = mcccg24_alpha;
MCNUM m = mcccg24_m;
MCNUM W = mcccg24_W;
MCNUM nslit = mcccg24_nslit;
MCNUM d = mcccg24_d;
MCNUM mleft = mcccg24_mleft;
MCNUM mright = mcccg24_mright;
MCNUM mtop = mcccg24_mtop;
MCNUM mbottom = mcccg24_mbottom;
MCNUM nhslit = mcccg24_nhslit;
MCNUM G = mcccg24_G;
MCNUM aleft = mcccg24_aleft;
MCNUM aright = mcccg24_aright;
MCNUM atop = mcccg24_atop;
MCNUM abottom = mcccg24_abottom;
MCNUM wavy = mcccg24_wavy;
MCNUM wavy_z = mcccg24_wavy_z;
MCNUM wavy_tb = mcccg24_wavy_tb;
MCNUM wavy_lr = mcccg24_wavy_lr;
MCNUM chamfers = mcccg24_chamfers;
MCNUM chamfers_z = mcccg24_chamfers_z;
MCNUM chamfers_lr = mcccg24_chamfers_lr;
MCNUM chamfers_tb = mcccg24_chamfers_tb;
MCNUM nelements = mcccg24_nelements;
MCNUM nu = mcccg24_nu;
MCNUM phase = mcccg24_phase;
char* reflect = mcccg24_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 77537 "ILL_H15_D11.c"
}   /* End of cg24=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'cg25'. */
  SIG_MESSAGE("cg25 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "cg25");
#define mccompcurname  cg25
#define mccompcurtype  Guide_gravity
#define mccompcurindex 33
#define GVars mcccg25_GVars
#define pTable mcccg25_pTable
{   /* Declarations of cg25=Guide_gravity() SETTING parameters. */
MCNUM w1 = mcccg25_w1;
MCNUM h1 = mcccg25_h1;
MCNUM w2 = mcccg25_w2;
MCNUM h2 = mcccg25_h2;
MCNUM l = mcccg25_l;
MCNUM R0 = mcccg25_R0;
MCNUM Qc = mcccg25_Qc;
MCNUM alpha = mcccg25_alpha;
MCNUM m = mcccg25_m;
MCNUM W = mcccg25_W;
MCNUM nslit = mcccg25_nslit;
MCNUM d = mcccg25_d;
MCNUM mleft = mcccg25_mleft;
MCNUM mright = mcccg25_mright;
MCNUM mtop = mcccg25_mtop;
MCNUM mbottom = mcccg25_mbottom;
MCNUM nhslit = mcccg25_nhslit;
MCNUM G = mcccg25_G;
MCNUM aleft = mcccg25_aleft;
MCNUM aright = mcccg25_aright;
MCNUM atop = mcccg25_atop;
MCNUM abottom = mcccg25_abottom;
MCNUM wavy = mcccg25_wavy;
MCNUM wavy_z = mcccg25_wavy_z;
MCNUM wavy_tb = mcccg25_wavy_tb;
MCNUM wavy_lr = mcccg25_wavy_lr;
MCNUM chamfers = mcccg25_chamfers;
MCNUM chamfers_z = mcccg25_chamfers_z;
MCNUM chamfers_lr = mcccg25_chamfers_lr;
MCNUM chamfers_tb = mcccg25_chamfers_tb;
MCNUM nelements = mcccg25_nelements;
MCNUM nu = mcccg25_nu;
MCNUM phase = mcccg25_phase;
char* reflect = mcccg25_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 77651 "ILL_H15_D11.c"
}   /* End of cg25=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'AlWindow4'. */
  SIG_MESSAGE("AlWindow4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "AlWindow4");
#define mccompcurname  AlWindow4
#define mccompcurtype  Al_window
#define mccompcurindex 34
{   /* Declarations of AlWindow4=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow4_thickness;
#line 95 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77675 "ILL_H15_D11.c"
}   /* End of AlWindow4=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PSD_VTE'. */
  SIG_MESSAGE("PSD_VTE (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PSD_VTE");
#define mccompcurname  PSD_VTE
#define mccompcurtype  Monitor_nD
#define mccompcurindex 35
#define user1 mccPSD_VTE_user1
#define user2 mccPSD_VTE_user2
#define user3 mccPSD_VTE_user3
#define DEFS mccPSD_VTE_DEFS
#define Vars mccPSD_VTE_Vars
#define detector mccPSD_VTE_detector
#define offdata mccPSD_VTE_offdata
{   /* Declarations of PSD_VTE=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccPSD_VTE_xwidth;
MCNUM yheight = mccPSD_VTE_yheight;
MCNUM zdepth = mccPSD_VTE_zdepth;
MCNUM xmin = mccPSD_VTE_xmin;
MCNUM xmax = mccPSD_VTE_xmax;
MCNUM ymin = mccPSD_VTE_ymin;
MCNUM ymax = mccPSD_VTE_ymax;
MCNUM zmin = mccPSD_VTE_zmin;
MCNUM zmax = mccPSD_VTE_zmax;
MCNUM bins = mccPSD_VTE_bins;
MCNUM min = mccPSD_VTE_min;
MCNUM max = mccPSD_VTE_max;
MCNUM restore_neutron = mccPSD_VTE_restore_neutron;
MCNUM radius = mccPSD_VTE_radius;
char* options = mccPSD_VTE_options;
char* filename = mccPSD_VTE_filename;
char* geometry = mccPSD_VTE_geometry;
char* username1 = mccPSD_VTE_username1;
char* username2 = mccPSD_VTE_username2;
char* username3 = mccPSD_VTE_username3;
int nowritefile = mccPSD_VTE_nowritefile;
#line 496 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    off_display(offdata);
  } else {
    Monitor_nD_McDisplay(&DEFS, &Vars);
  }
}
#line 77725 "ILL_H15_D11.c"
}   /* End of PSD_VTE=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'AlWindow5'. */
  SIG_MESSAGE("AlWindow5 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "AlWindow5");
#define mccompcurname  AlWindow5
#define mccompcurtype  Al_window
#define mccompcurindex 36
{   /* Declarations of AlWindow5=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow5_thickness;
#line 95 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77754 "ILL_H15_D11.c"
}   /* End of AlWindow5=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'VTEtoIN6GuideStart'. */
  SIG_MESSAGE("VTEtoIN6GuideStart (McDisplay)");
  printf("MCDISPLAY: component %s\n", "VTEtoIN6GuideStart");
#define mccompcurname  VTEtoIN6GuideStart
#define mccompcurtype  Arm
#define mccompcurindex 37
#line 40 "/usr/share/mcstas/2.6rc1/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 77774 "ILL_H15_D11.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg1'. */
  SIG_MESSAGE("sg1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg1");
#define mccompcurname  sg1
#define mccompcurtype  Guide_gravity
#define mccompcurindex 38
#define GVars mccsg1_GVars
#define pTable mccsg1_pTable
{   /* Declarations of sg1=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg1_w1;
MCNUM h1 = mccsg1_h1;
MCNUM w2 = mccsg1_w2;
MCNUM h2 = mccsg1_h2;
MCNUM l = mccsg1_l;
MCNUM R0 = mccsg1_R0;
MCNUM Qc = mccsg1_Qc;
MCNUM alpha = mccsg1_alpha;
MCNUM m = mccsg1_m;
MCNUM W = mccsg1_W;
MCNUM nslit = mccsg1_nslit;
MCNUM d = mccsg1_d;
MCNUM mleft = mccsg1_mleft;
MCNUM mright = mccsg1_mright;
MCNUM mtop = mccsg1_mtop;
MCNUM mbottom = mccsg1_mbottom;
MCNUM nhslit = mccsg1_nhslit;
MCNUM G = mccsg1_G;
MCNUM aleft = mccsg1_aleft;
MCNUM aright = mccsg1_aright;
MCNUM atop = mccsg1_atop;
MCNUM abottom = mccsg1_abottom;
MCNUM wavy = mccsg1_wavy;
MCNUM wavy_z = mccsg1_wavy_z;
MCNUM wavy_tb = mccsg1_wavy_tb;
MCNUM wavy_lr = mccsg1_wavy_lr;
MCNUM chamfers = mccsg1_chamfers;
MCNUM chamfers_z = mccsg1_chamfers_z;
MCNUM chamfers_lr = mccsg1_chamfers_lr;
MCNUM chamfers_tb = mccsg1_chamfers_tb;
MCNUM nelements = mccsg1_nelements;
MCNUM nu = mccsg1_nu;
MCNUM phase = mccsg1_phase;
char* reflect = mccsg1_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 77885 "ILL_H15_D11.c"
}   /* End of sg1=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg2'. */
  SIG_MESSAGE("sg2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg2");
#define mccompcurname  sg2
#define mccompcurtype  Guide_gravity
#define mccompcurindex 39
#define GVars mccsg2_GVars
#define pTable mccsg2_pTable
{   /* Declarations of sg2=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg2_w1;
MCNUM h1 = mccsg2_h1;
MCNUM w2 = mccsg2_w2;
MCNUM h2 = mccsg2_h2;
MCNUM l = mccsg2_l;
MCNUM R0 = mccsg2_R0;
MCNUM Qc = mccsg2_Qc;
MCNUM alpha = mccsg2_alpha;
MCNUM m = mccsg2_m;
MCNUM W = mccsg2_W;
MCNUM nslit = mccsg2_nslit;
MCNUM d = mccsg2_d;
MCNUM mleft = mccsg2_mleft;
MCNUM mright = mccsg2_mright;
MCNUM mtop = mccsg2_mtop;
MCNUM mbottom = mccsg2_mbottom;
MCNUM nhslit = mccsg2_nhslit;
MCNUM G = mccsg2_G;
MCNUM aleft = mccsg2_aleft;
MCNUM aright = mccsg2_aright;
MCNUM atop = mccsg2_atop;
MCNUM abottom = mccsg2_abottom;
MCNUM wavy = mccsg2_wavy;
MCNUM wavy_z = mccsg2_wavy_z;
MCNUM wavy_tb = mccsg2_wavy_tb;
MCNUM wavy_lr = mccsg2_wavy_lr;
MCNUM chamfers = mccsg2_chamfers;
MCNUM chamfers_z = mccsg2_chamfers_z;
MCNUM chamfers_lr = mccsg2_chamfers_lr;
MCNUM chamfers_tb = mccsg2_chamfers_tb;
MCNUM nelements = mccsg2_nelements;
MCNUM nu = mccsg2_nu;
MCNUM phase = mccsg2_phase;
char* reflect = mccsg2_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 77999 "ILL_H15_D11.c"
}   /* End of sg2=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg3'. */
  SIG_MESSAGE("sg3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg3");
#define mccompcurname  sg3
#define mccompcurtype  Guide_gravity
#define mccompcurindex 40
#define GVars mccsg3_GVars
#define pTable mccsg3_pTable
{   /* Declarations of sg3=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg3_w1;
MCNUM h1 = mccsg3_h1;
MCNUM w2 = mccsg3_w2;
MCNUM h2 = mccsg3_h2;
MCNUM l = mccsg3_l;
MCNUM R0 = mccsg3_R0;
MCNUM Qc = mccsg3_Qc;
MCNUM alpha = mccsg3_alpha;
MCNUM m = mccsg3_m;
MCNUM W = mccsg3_W;
MCNUM nslit = mccsg3_nslit;
MCNUM d = mccsg3_d;
MCNUM mleft = mccsg3_mleft;
MCNUM mright = mccsg3_mright;
MCNUM mtop = mccsg3_mtop;
MCNUM mbottom = mccsg3_mbottom;
MCNUM nhslit = mccsg3_nhslit;
MCNUM G = mccsg3_G;
MCNUM aleft = mccsg3_aleft;
MCNUM aright = mccsg3_aright;
MCNUM atop = mccsg3_atop;
MCNUM abottom = mccsg3_abottom;
MCNUM wavy = mccsg3_wavy;
MCNUM wavy_z = mccsg3_wavy_z;
MCNUM wavy_tb = mccsg3_wavy_tb;
MCNUM wavy_lr = mccsg3_wavy_lr;
MCNUM chamfers = mccsg3_chamfers;
MCNUM chamfers_z = mccsg3_chamfers_z;
MCNUM chamfers_lr = mccsg3_chamfers_lr;
MCNUM chamfers_tb = mccsg3_chamfers_tb;
MCNUM nelements = mccsg3_nelements;
MCNUM nu = mccsg3_nu;
MCNUM phase = mccsg3_phase;
char* reflect = mccsg3_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 78113 "ILL_H15_D11.c"
}   /* End of sg3=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg4'. */
  SIG_MESSAGE("sg4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg4");
#define mccompcurname  sg4
#define mccompcurtype  Guide_gravity
#define mccompcurindex 41
#define GVars mccsg4_GVars
#define pTable mccsg4_pTable
{   /* Declarations of sg4=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg4_w1;
MCNUM h1 = mccsg4_h1;
MCNUM w2 = mccsg4_w2;
MCNUM h2 = mccsg4_h2;
MCNUM l = mccsg4_l;
MCNUM R0 = mccsg4_R0;
MCNUM Qc = mccsg4_Qc;
MCNUM alpha = mccsg4_alpha;
MCNUM m = mccsg4_m;
MCNUM W = mccsg4_W;
MCNUM nslit = mccsg4_nslit;
MCNUM d = mccsg4_d;
MCNUM mleft = mccsg4_mleft;
MCNUM mright = mccsg4_mright;
MCNUM mtop = mccsg4_mtop;
MCNUM mbottom = mccsg4_mbottom;
MCNUM nhslit = mccsg4_nhslit;
MCNUM G = mccsg4_G;
MCNUM aleft = mccsg4_aleft;
MCNUM aright = mccsg4_aright;
MCNUM atop = mccsg4_atop;
MCNUM abottom = mccsg4_abottom;
MCNUM wavy = mccsg4_wavy;
MCNUM wavy_z = mccsg4_wavy_z;
MCNUM wavy_tb = mccsg4_wavy_tb;
MCNUM wavy_lr = mccsg4_wavy_lr;
MCNUM chamfers = mccsg4_chamfers;
MCNUM chamfers_z = mccsg4_chamfers_z;
MCNUM chamfers_lr = mccsg4_chamfers_lr;
MCNUM chamfers_tb = mccsg4_chamfers_tb;
MCNUM nelements = mccsg4_nelements;
MCNUM nu = mccsg4_nu;
MCNUM phase = mccsg4_phase;
char* reflect = mccsg4_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 78227 "ILL_H15_D11.c"
}   /* End of sg4=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg5'. */
  SIG_MESSAGE("sg5 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg5");
#define mccompcurname  sg5
#define mccompcurtype  Guide_gravity
#define mccompcurindex 42
#define GVars mccsg5_GVars
#define pTable mccsg5_pTable
{   /* Declarations of sg5=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg5_w1;
MCNUM h1 = mccsg5_h1;
MCNUM w2 = mccsg5_w2;
MCNUM h2 = mccsg5_h2;
MCNUM l = mccsg5_l;
MCNUM R0 = mccsg5_R0;
MCNUM Qc = mccsg5_Qc;
MCNUM alpha = mccsg5_alpha;
MCNUM m = mccsg5_m;
MCNUM W = mccsg5_W;
MCNUM nslit = mccsg5_nslit;
MCNUM d = mccsg5_d;
MCNUM mleft = mccsg5_mleft;
MCNUM mright = mccsg5_mright;
MCNUM mtop = mccsg5_mtop;
MCNUM mbottom = mccsg5_mbottom;
MCNUM nhslit = mccsg5_nhslit;
MCNUM G = mccsg5_G;
MCNUM aleft = mccsg5_aleft;
MCNUM aright = mccsg5_aright;
MCNUM atop = mccsg5_atop;
MCNUM abottom = mccsg5_abottom;
MCNUM wavy = mccsg5_wavy;
MCNUM wavy_z = mccsg5_wavy_z;
MCNUM wavy_tb = mccsg5_wavy_tb;
MCNUM wavy_lr = mccsg5_wavy_lr;
MCNUM chamfers = mccsg5_chamfers;
MCNUM chamfers_z = mccsg5_chamfers_z;
MCNUM chamfers_lr = mccsg5_chamfers_lr;
MCNUM chamfers_tb = mccsg5_chamfers_tb;
MCNUM nelements = mccsg5_nelements;
MCNUM nu = mccsg5_nu;
MCNUM phase = mccsg5_phase;
char* reflect = mccsg5_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 78341 "ILL_H15_D11.c"
}   /* End of sg5=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg6'. */
  SIG_MESSAGE("sg6 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg6");
#define mccompcurname  sg6
#define mccompcurtype  Guide_gravity
#define mccompcurindex 43
#define GVars mccsg6_GVars
#define pTable mccsg6_pTable
{   /* Declarations of sg6=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg6_w1;
MCNUM h1 = mccsg6_h1;
MCNUM w2 = mccsg6_w2;
MCNUM h2 = mccsg6_h2;
MCNUM l = mccsg6_l;
MCNUM R0 = mccsg6_R0;
MCNUM Qc = mccsg6_Qc;
MCNUM alpha = mccsg6_alpha;
MCNUM m = mccsg6_m;
MCNUM W = mccsg6_W;
MCNUM nslit = mccsg6_nslit;
MCNUM d = mccsg6_d;
MCNUM mleft = mccsg6_mleft;
MCNUM mright = mccsg6_mright;
MCNUM mtop = mccsg6_mtop;
MCNUM mbottom = mccsg6_mbottom;
MCNUM nhslit = mccsg6_nhslit;
MCNUM G = mccsg6_G;
MCNUM aleft = mccsg6_aleft;
MCNUM aright = mccsg6_aright;
MCNUM atop = mccsg6_atop;
MCNUM abottom = mccsg6_abottom;
MCNUM wavy = mccsg6_wavy;
MCNUM wavy_z = mccsg6_wavy_z;
MCNUM wavy_tb = mccsg6_wavy_tb;
MCNUM wavy_lr = mccsg6_wavy_lr;
MCNUM chamfers = mccsg6_chamfers;
MCNUM chamfers_z = mccsg6_chamfers_z;
MCNUM chamfers_lr = mccsg6_chamfers_lr;
MCNUM chamfers_tb = mccsg6_chamfers_tb;
MCNUM nelements = mccsg6_nelements;
MCNUM nu = mccsg6_nu;
MCNUM phase = mccsg6_phase;
char* reflect = mccsg6_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 78455 "ILL_H15_D11.c"
}   /* End of sg6=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg7'. */
  SIG_MESSAGE("sg7 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg7");
#define mccompcurname  sg7
#define mccompcurtype  Guide_gravity
#define mccompcurindex 44
#define GVars mccsg7_GVars
#define pTable mccsg7_pTable
{   /* Declarations of sg7=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg7_w1;
MCNUM h1 = mccsg7_h1;
MCNUM w2 = mccsg7_w2;
MCNUM h2 = mccsg7_h2;
MCNUM l = mccsg7_l;
MCNUM R0 = mccsg7_R0;
MCNUM Qc = mccsg7_Qc;
MCNUM alpha = mccsg7_alpha;
MCNUM m = mccsg7_m;
MCNUM W = mccsg7_W;
MCNUM nslit = mccsg7_nslit;
MCNUM d = mccsg7_d;
MCNUM mleft = mccsg7_mleft;
MCNUM mright = mccsg7_mright;
MCNUM mtop = mccsg7_mtop;
MCNUM mbottom = mccsg7_mbottom;
MCNUM nhslit = mccsg7_nhslit;
MCNUM G = mccsg7_G;
MCNUM aleft = mccsg7_aleft;
MCNUM aright = mccsg7_aright;
MCNUM atop = mccsg7_atop;
MCNUM abottom = mccsg7_abottom;
MCNUM wavy = mccsg7_wavy;
MCNUM wavy_z = mccsg7_wavy_z;
MCNUM wavy_tb = mccsg7_wavy_tb;
MCNUM wavy_lr = mccsg7_wavy_lr;
MCNUM chamfers = mccsg7_chamfers;
MCNUM chamfers_z = mccsg7_chamfers_z;
MCNUM chamfers_lr = mccsg7_chamfers_lr;
MCNUM chamfers_tb = mccsg7_chamfers_tb;
MCNUM nelements = mccsg7_nelements;
MCNUM nu = mccsg7_nu;
MCNUM phase = mccsg7_phase;
char* reflect = mccsg7_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 78569 "ILL_H15_D11.c"
}   /* End of sg7=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg8'. */
  SIG_MESSAGE("sg8 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg8");
#define mccompcurname  sg8
#define mccompcurtype  Guide_gravity
#define mccompcurindex 45
#define GVars mccsg8_GVars
#define pTable mccsg8_pTable
{   /* Declarations of sg8=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg8_w1;
MCNUM h1 = mccsg8_h1;
MCNUM w2 = mccsg8_w2;
MCNUM h2 = mccsg8_h2;
MCNUM l = mccsg8_l;
MCNUM R0 = mccsg8_R0;
MCNUM Qc = mccsg8_Qc;
MCNUM alpha = mccsg8_alpha;
MCNUM m = mccsg8_m;
MCNUM W = mccsg8_W;
MCNUM nslit = mccsg8_nslit;
MCNUM d = mccsg8_d;
MCNUM mleft = mccsg8_mleft;
MCNUM mright = mccsg8_mright;
MCNUM mtop = mccsg8_mtop;
MCNUM mbottom = mccsg8_mbottom;
MCNUM nhslit = mccsg8_nhslit;
MCNUM G = mccsg8_G;
MCNUM aleft = mccsg8_aleft;
MCNUM aright = mccsg8_aright;
MCNUM atop = mccsg8_atop;
MCNUM abottom = mccsg8_abottom;
MCNUM wavy = mccsg8_wavy;
MCNUM wavy_z = mccsg8_wavy_z;
MCNUM wavy_tb = mccsg8_wavy_tb;
MCNUM wavy_lr = mccsg8_wavy_lr;
MCNUM chamfers = mccsg8_chamfers;
MCNUM chamfers_z = mccsg8_chamfers_z;
MCNUM chamfers_lr = mccsg8_chamfers_lr;
MCNUM chamfers_tb = mccsg8_chamfers_tb;
MCNUM nelements = mccsg8_nelements;
MCNUM nu = mccsg8_nu;
MCNUM phase = mccsg8_phase;
char* reflect = mccsg8_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 78683 "ILL_H15_D11.c"
}   /* End of sg8=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg9'. */
  SIG_MESSAGE("sg9 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg9");
#define mccompcurname  sg9
#define mccompcurtype  Guide_gravity
#define mccompcurindex 46
#define GVars mccsg9_GVars
#define pTable mccsg9_pTable
{   /* Declarations of sg9=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg9_w1;
MCNUM h1 = mccsg9_h1;
MCNUM w2 = mccsg9_w2;
MCNUM h2 = mccsg9_h2;
MCNUM l = mccsg9_l;
MCNUM R0 = mccsg9_R0;
MCNUM Qc = mccsg9_Qc;
MCNUM alpha = mccsg9_alpha;
MCNUM m = mccsg9_m;
MCNUM W = mccsg9_W;
MCNUM nslit = mccsg9_nslit;
MCNUM d = mccsg9_d;
MCNUM mleft = mccsg9_mleft;
MCNUM mright = mccsg9_mright;
MCNUM mtop = mccsg9_mtop;
MCNUM mbottom = mccsg9_mbottom;
MCNUM nhslit = mccsg9_nhslit;
MCNUM G = mccsg9_G;
MCNUM aleft = mccsg9_aleft;
MCNUM aright = mccsg9_aright;
MCNUM atop = mccsg9_atop;
MCNUM abottom = mccsg9_abottom;
MCNUM wavy = mccsg9_wavy;
MCNUM wavy_z = mccsg9_wavy_z;
MCNUM wavy_tb = mccsg9_wavy_tb;
MCNUM wavy_lr = mccsg9_wavy_lr;
MCNUM chamfers = mccsg9_chamfers;
MCNUM chamfers_z = mccsg9_chamfers_z;
MCNUM chamfers_lr = mccsg9_chamfers_lr;
MCNUM chamfers_tb = mccsg9_chamfers_tb;
MCNUM nelements = mccsg9_nelements;
MCNUM nu = mccsg9_nu;
MCNUM phase = mccsg9_phase;
char* reflect = mccsg9_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 78797 "ILL_H15_D11.c"
}   /* End of sg9=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg10'. */
  SIG_MESSAGE("sg10 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg10");
#define mccompcurname  sg10
#define mccompcurtype  Guide_gravity
#define mccompcurindex 47
#define GVars mccsg10_GVars
#define pTable mccsg10_pTable
{   /* Declarations of sg10=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg10_w1;
MCNUM h1 = mccsg10_h1;
MCNUM w2 = mccsg10_w2;
MCNUM h2 = mccsg10_h2;
MCNUM l = mccsg10_l;
MCNUM R0 = mccsg10_R0;
MCNUM Qc = mccsg10_Qc;
MCNUM alpha = mccsg10_alpha;
MCNUM m = mccsg10_m;
MCNUM W = mccsg10_W;
MCNUM nslit = mccsg10_nslit;
MCNUM d = mccsg10_d;
MCNUM mleft = mccsg10_mleft;
MCNUM mright = mccsg10_mright;
MCNUM mtop = mccsg10_mtop;
MCNUM mbottom = mccsg10_mbottom;
MCNUM nhslit = mccsg10_nhslit;
MCNUM G = mccsg10_G;
MCNUM aleft = mccsg10_aleft;
MCNUM aright = mccsg10_aright;
MCNUM atop = mccsg10_atop;
MCNUM abottom = mccsg10_abottom;
MCNUM wavy = mccsg10_wavy;
MCNUM wavy_z = mccsg10_wavy_z;
MCNUM wavy_tb = mccsg10_wavy_tb;
MCNUM wavy_lr = mccsg10_wavy_lr;
MCNUM chamfers = mccsg10_chamfers;
MCNUM chamfers_z = mccsg10_chamfers_z;
MCNUM chamfers_lr = mccsg10_chamfers_lr;
MCNUM chamfers_tb = mccsg10_chamfers_tb;
MCNUM nelements = mccsg10_nelements;
MCNUM nu = mccsg10_nu;
MCNUM phase = mccsg10_phase;
char* reflect = mccsg10_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 78911 "ILL_H15_D11.c"
}   /* End of sg10=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg11'. */
  SIG_MESSAGE("sg11 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg11");
#define mccompcurname  sg11
#define mccompcurtype  Guide_gravity
#define mccompcurindex 48
#define GVars mccsg11_GVars
#define pTable mccsg11_pTable
{   /* Declarations of sg11=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg11_w1;
MCNUM h1 = mccsg11_h1;
MCNUM w2 = mccsg11_w2;
MCNUM h2 = mccsg11_h2;
MCNUM l = mccsg11_l;
MCNUM R0 = mccsg11_R0;
MCNUM Qc = mccsg11_Qc;
MCNUM alpha = mccsg11_alpha;
MCNUM m = mccsg11_m;
MCNUM W = mccsg11_W;
MCNUM nslit = mccsg11_nslit;
MCNUM d = mccsg11_d;
MCNUM mleft = mccsg11_mleft;
MCNUM mright = mccsg11_mright;
MCNUM mtop = mccsg11_mtop;
MCNUM mbottom = mccsg11_mbottom;
MCNUM nhslit = mccsg11_nhslit;
MCNUM G = mccsg11_G;
MCNUM aleft = mccsg11_aleft;
MCNUM aright = mccsg11_aright;
MCNUM atop = mccsg11_atop;
MCNUM abottom = mccsg11_abottom;
MCNUM wavy = mccsg11_wavy;
MCNUM wavy_z = mccsg11_wavy_z;
MCNUM wavy_tb = mccsg11_wavy_tb;
MCNUM wavy_lr = mccsg11_wavy_lr;
MCNUM chamfers = mccsg11_chamfers;
MCNUM chamfers_z = mccsg11_chamfers_z;
MCNUM chamfers_lr = mccsg11_chamfers_lr;
MCNUM chamfers_tb = mccsg11_chamfers_tb;
MCNUM nelements = mccsg11_nelements;
MCNUM nu = mccsg11_nu;
MCNUM phase = mccsg11_phase;
char* reflect = mccsg11_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 79025 "ILL_H15_D11.c"
}   /* End of sg11=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg12'. */
  SIG_MESSAGE("sg12 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg12");
#define mccompcurname  sg12
#define mccompcurtype  Guide_gravity
#define mccompcurindex 49
#define GVars mccsg12_GVars
#define pTable mccsg12_pTable
{   /* Declarations of sg12=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg12_w1;
MCNUM h1 = mccsg12_h1;
MCNUM w2 = mccsg12_w2;
MCNUM h2 = mccsg12_h2;
MCNUM l = mccsg12_l;
MCNUM R0 = mccsg12_R0;
MCNUM Qc = mccsg12_Qc;
MCNUM alpha = mccsg12_alpha;
MCNUM m = mccsg12_m;
MCNUM W = mccsg12_W;
MCNUM nslit = mccsg12_nslit;
MCNUM d = mccsg12_d;
MCNUM mleft = mccsg12_mleft;
MCNUM mright = mccsg12_mright;
MCNUM mtop = mccsg12_mtop;
MCNUM mbottom = mccsg12_mbottom;
MCNUM nhslit = mccsg12_nhslit;
MCNUM G = mccsg12_G;
MCNUM aleft = mccsg12_aleft;
MCNUM aright = mccsg12_aright;
MCNUM atop = mccsg12_atop;
MCNUM abottom = mccsg12_abottom;
MCNUM wavy = mccsg12_wavy;
MCNUM wavy_z = mccsg12_wavy_z;
MCNUM wavy_tb = mccsg12_wavy_tb;
MCNUM wavy_lr = mccsg12_wavy_lr;
MCNUM chamfers = mccsg12_chamfers;
MCNUM chamfers_z = mccsg12_chamfers_z;
MCNUM chamfers_lr = mccsg12_chamfers_lr;
MCNUM chamfers_tb = mccsg12_chamfers_tb;
MCNUM nelements = mccsg12_nelements;
MCNUM nu = mccsg12_nu;
MCNUM phase = mccsg12_phase;
char* reflect = mccsg12_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 79139 "ILL_H15_D11.c"
}   /* End of sg12=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg13'. */
  SIG_MESSAGE("sg13 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg13");
#define mccompcurname  sg13
#define mccompcurtype  Guide_gravity
#define mccompcurindex 50
#define GVars mccsg13_GVars
#define pTable mccsg13_pTable
{   /* Declarations of sg13=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg13_w1;
MCNUM h1 = mccsg13_h1;
MCNUM w2 = mccsg13_w2;
MCNUM h2 = mccsg13_h2;
MCNUM l = mccsg13_l;
MCNUM R0 = mccsg13_R0;
MCNUM Qc = mccsg13_Qc;
MCNUM alpha = mccsg13_alpha;
MCNUM m = mccsg13_m;
MCNUM W = mccsg13_W;
MCNUM nslit = mccsg13_nslit;
MCNUM d = mccsg13_d;
MCNUM mleft = mccsg13_mleft;
MCNUM mright = mccsg13_mright;
MCNUM mtop = mccsg13_mtop;
MCNUM mbottom = mccsg13_mbottom;
MCNUM nhslit = mccsg13_nhslit;
MCNUM G = mccsg13_G;
MCNUM aleft = mccsg13_aleft;
MCNUM aright = mccsg13_aright;
MCNUM atop = mccsg13_atop;
MCNUM abottom = mccsg13_abottom;
MCNUM wavy = mccsg13_wavy;
MCNUM wavy_z = mccsg13_wavy_z;
MCNUM wavy_tb = mccsg13_wavy_tb;
MCNUM wavy_lr = mccsg13_wavy_lr;
MCNUM chamfers = mccsg13_chamfers;
MCNUM chamfers_z = mccsg13_chamfers_z;
MCNUM chamfers_lr = mccsg13_chamfers_lr;
MCNUM chamfers_tb = mccsg13_chamfers_tb;
MCNUM nelements = mccsg13_nelements;
MCNUM nu = mccsg13_nu;
MCNUM phase = mccsg13_phase;
char* reflect = mccsg13_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 79253 "ILL_H15_D11.c"
}   /* End of sg13=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg14'. */
  SIG_MESSAGE("sg14 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg14");
#define mccompcurname  sg14
#define mccompcurtype  Guide_gravity
#define mccompcurindex 51
#define GVars mccsg14_GVars
#define pTable mccsg14_pTable
{   /* Declarations of sg14=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg14_w1;
MCNUM h1 = mccsg14_h1;
MCNUM w2 = mccsg14_w2;
MCNUM h2 = mccsg14_h2;
MCNUM l = mccsg14_l;
MCNUM R0 = mccsg14_R0;
MCNUM Qc = mccsg14_Qc;
MCNUM alpha = mccsg14_alpha;
MCNUM m = mccsg14_m;
MCNUM W = mccsg14_W;
MCNUM nslit = mccsg14_nslit;
MCNUM d = mccsg14_d;
MCNUM mleft = mccsg14_mleft;
MCNUM mright = mccsg14_mright;
MCNUM mtop = mccsg14_mtop;
MCNUM mbottom = mccsg14_mbottom;
MCNUM nhslit = mccsg14_nhslit;
MCNUM G = mccsg14_G;
MCNUM aleft = mccsg14_aleft;
MCNUM aright = mccsg14_aright;
MCNUM atop = mccsg14_atop;
MCNUM abottom = mccsg14_abottom;
MCNUM wavy = mccsg14_wavy;
MCNUM wavy_z = mccsg14_wavy_z;
MCNUM wavy_tb = mccsg14_wavy_tb;
MCNUM wavy_lr = mccsg14_wavy_lr;
MCNUM chamfers = mccsg14_chamfers;
MCNUM chamfers_z = mccsg14_chamfers_z;
MCNUM chamfers_lr = mccsg14_chamfers_lr;
MCNUM chamfers_tb = mccsg14_chamfers_tb;
MCNUM nelements = mccsg14_nelements;
MCNUM nu = mccsg14_nu;
MCNUM phase = mccsg14_phase;
char* reflect = mccsg14_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 79367 "ILL_H15_D11.c"
}   /* End of sg14=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg15'. */
  SIG_MESSAGE("sg15 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg15");
#define mccompcurname  sg15
#define mccompcurtype  Guide_gravity
#define mccompcurindex 52
#define GVars mccsg15_GVars
#define pTable mccsg15_pTable
{   /* Declarations of sg15=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg15_w1;
MCNUM h1 = mccsg15_h1;
MCNUM w2 = mccsg15_w2;
MCNUM h2 = mccsg15_h2;
MCNUM l = mccsg15_l;
MCNUM R0 = mccsg15_R0;
MCNUM Qc = mccsg15_Qc;
MCNUM alpha = mccsg15_alpha;
MCNUM m = mccsg15_m;
MCNUM W = mccsg15_W;
MCNUM nslit = mccsg15_nslit;
MCNUM d = mccsg15_d;
MCNUM mleft = mccsg15_mleft;
MCNUM mright = mccsg15_mright;
MCNUM mtop = mccsg15_mtop;
MCNUM mbottom = mccsg15_mbottom;
MCNUM nhslit = mccsg15_nhslit;
MCNUM G = mccsg15_G;
MCNUM aleft = mccsg15_aleft;
MCNUM aright = mccsg15_aright;
MCNUM atop = mccsg15_atop;
MCNUM abottom = mccsg15_abottom;
MCNUM wavy = mccsg15_wavy;
MCNUM wavy_z = mccsg15_wavy_z;
MCNUM wavy_tb = mccsg15_wavy_tb;
MCNUM wavy_lr = mccsg15_wavy_lr;
MCNUM chamfers = mccsg15_chamfers;
MCNUM chamfers_z = mccsg15_chamfers_z;
MCNUM chamfers_lr = mccsg15_chamfers_lr;
MCNUM chamfers_tb = mccsg15_chamfers_tb;
MCNUM nelements = mccsg15_nelements;
MCNUM nu = mccsg15_nu;
MCNUM phase = mccsg15_phase;
char* reflect = mccsg15_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 79481 "ILL_H15_D11.c"
}   /* End of sg15=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg16'. */
  SIG_MESSAGE("sg16 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg16");
#define mccompcurname  sg16
#define mccompcurtype  Guide_gravity
#define mccompcurindex 53
#define GVars mccsg16_GVars
#define pTable mccsg16_pTable
{   /* Declarations of sg16=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg16_w1;
MCNUM h1 = mccsg16_h1;
MCNUM w2 = mccsg16_w2;
MCNUM h2 = mccsg16_h2;
MCNUM l = mccsg16_l;
MCNUM R0 = mccsg16_R0;
MCNUM Qc = mccsg16_Qc;
MCNUM alpha = mccsg16_alpha;
MCNUM m = mccsg16_m;
MCNUM W = mccsg16_W;
MCNUM nslit = mccsg16_nslit;
MCNUM d = mccsg16_d;
MCNUM mleft = mccsg16_mleft;
MCNUM mright = mccsg16_mright;
MCNUM mtop = mccsg16_mtop;
MCNUM mbottom = mccsg16_mbottom;
MCNUM nhslit = mccsg16_nhslit;
MCNUM G = mccsg16_G;
MCNUM aleft = mccsg16_aleft;
MCNUM aright = mccsg16_aright;
MCNUM atop = mccsg16_atop;
MCNUM abottom = mccsg16_abottom;
MCNUM wavy = mccsg16_wavy;
MCNUM wavy_z = mccsg16_wavy_z;
MCNUM wavy_tb = mccsg16_wavy_tb;
MCNUM wavy_lr = mccsg16_wavy_lr;
MCNUM chamfers = mccsg16_chamfers;
MCNUM chamfers_z = mccsg16_chamfers_z;
MCNUM chamfers_lr = mccsg16_chamfers_lr;
MCNUM chamfers_tb = mccsg16_chamfers_tb;
MCNUM nelements = mccsg16_nelements;
MCNUM nu = mccsg16_nu;
MCNUM phase = mccsg16_phase;
char* reflect = mccsg16_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 79595 "ILL_H15_D11.c"
}   /* End of sg16=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg17'. */
  SIG_MESSAGE("sg17 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg17");
#define mccompcurname  sg17
#define mccompcurtype  Guide_gravity
#define mccompcurindex 54
#define GVars mccsg17_GVars
#define pTable mccsg17_pTable
{   /* Declarations of sg17=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg17_w1;
MCNUM h1 = mccsg17_h1;
MCNUM w2 = mccsg17_w2;
MCNUM h2 = mccsg17_h2;
MCNUM l = mccsg17_l;
MCNUM R0 = mccsg17_R0;
MCNUM Qc = mccsg17_Qc;
MCNUM alpha = mccsg17_alpha;
MCNUM m = mccsg17_m;
MCNUM W = mccsg17_W;
MCNUM nslit = mccsg17_nslit;
MCNUM d = mccsg17_d;
MCNUM mleft = mccsg17_mleft;
MCNUM mright = mccsg17_mright;
MCNUM mtop = mccsg17_mtop;
MCNUM mbottom = mccsg17_mbottom;
MCNUM nhslit = mccsg17_nhslit;
MCNUM G = mccsg17_G;
MCNUM aleft = mccsg17_aleft;
MCNUM aright = mccsg17_aright;
MCNUM atop = mccsg17_atop;
MCNUM abottom = mccsg17_abottom;
MCNUM wavy = mccsg17_wavy;
MCNUM wavy_z = mccsg17_wavy_z;
MCNUM wavy_tb = mccsg17_wavy_tb;
MCNUM wavy_lr = mccsg17_wavy_lr;
MCNUM chamfers = mccsg17_chamfers;
MCNUM chamfers_z = mccsg17_chamfers_z;
MCNUM chamfers_lr = mccsg17_chamfers_lr;
MCNUM chamfers_tb = mccsg17_chamfers_tb;
MCNUM nelements = mccsg17_nelements;
MCNUM nu = mccsg17_nu;
MCNUM phase = mccsg17_phase;
char* reflect = mccsg17_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 79709 "ILL_H15_D11.c"
}   /* End of sg17=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg18'. */
  SIG_MESSAGE("sg18 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg18");
#define mccompcurname  sg18
#define mccompcurtype  Guide_gravity
#define mccompcurindex 55
#define GVars mccsg18_GVars
#define pTable mccsg18_pTable
{   /* Declarations of sg18=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg18_w1;
MCNUM h1 = mccsg18_h1;
MCNUM w2 = mccsg18_w2;
MCNUM h2 = mccsg18_h2;
MCNUM l = mccsg18_l;
MCNUM R0 = mccsg18_R0;
MCNUM Qc = mccsg18_Qc;
MCNUM alpha = mccsg18_alpha;
MCNUM m = mccsg18_m;
MCNUM W = mccsg18_W;
MCNUM nslit = mccsg18_nslit;
MCNUM d = mccsg18_d;
MCNUM mleft = mccsg18_mleft;
MCNUM mright = mccsg18_mright;
MCNUM mtop = mccsg18_mtop;
MCNUM mbottom = mccsg18_mbottom;
MCNUM nhslit = mccsg18_nhslit;
MCNUM G = mccsg18_G;
MCNUM aleft = mccsg18_aleft;
MCNUM aright = mccsg18_aright;
MCNUM atop = mccsg18_atop;
MCNUM abottom = mccsg18_abottom;
MCNUM wavy = mccsg18_wavy;
MCNUM wavy_z = mccsg18_wavy_z;
MCNUM wavy_tb = mccsg18_wavy_tb;
MCNUM wavy_lr = mccsg18_wavy_lr;
MCNUM chamfers = mccsg18_chamfers;
MCNUM chamfers_z = mccsg18_chamfers_z;
MCNUM chamfers_lr = mccsg18_chamfers_lr;
MCNUM chamfers_tb = mccsg18_chamfers_tb;
MCNUM nelements = mccsg18_nelements;
MCNUM nu = mccsg18_nu;
MCNUM phase = mccsg18_phase;
char* reflect = mccsg18_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 79823 "ILL_H15_D11.c"
}   /* End of sg18=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg19'. */
  SIG_MESSAGE("sg19 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg19");
#define mccompcurname  sg19
#define mccompcurtype  Guide_gravity
#define mccompcurindex 56
#define GVars mccsg19_GVars
#define pTable mccsg19_pTable
{   /* Declarations of sg19=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg19_w1;
MCNUM h1 = mccsg19_h1;
MCNUM w2 = mccsg19_w2;
MCNUM h2 = mccsg19_h2;
MCNUM l = mccsg19_l;
MCNUM R0 = mccsg19_R0;
MCNUM Qc = mccsg19_Qc;
MCNUM alpha = mccsg19_alpha;
MCNUM m = mccsg19_m;
MCNUM W = mccsg19_W;
MCNUM nslit = mccsg19_nslit;
MCNUM d = mccsg19_d;
MCNUM mleft = mccsg19_mleft;
MCNUM mright = mccsg19_mright;
MCNUM mtop = mccsg19_mtop;
MCNUM mbottom = mccsg19_mbottom;
MCNUM nhslit = mccsg19_nhslit;
MCNUM G = mccsg19_G;
MCNUM aleft = mccsg19_aleft;
MCNUM aright = mccsg19_aright;
MCNUM atop = mccsg19_atop;
MCNUM abottom = mccsg19_abottom;
MCNUM wavy = mccsg19_wavy;
MCNUM wavy_z = mccsg19_wavy_z;
MCNUM wavy_tb = mccsg19_wavy_tb;
MCNUM wavy_lr = mccsg19_wavy_lr;
MCNUM chamfers = mccsg19_chamfers;
MCNUM chamfers_z = mccsg19_chamfers_z;
MCNUM chamfers_lr = mccsg19_chamfers_lr;
MCNUM chamfers_tb = mccsg19_chamfers_tb;
MCNUM nelements = mccsg19_nelements;
MCNUM nu = mccsg19_nu;
MCNUM phase = mccsg19_phase;
char* reflect = mccsg19_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 79937 "ILL_H15_D11.c"
}   /* End of sg19=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg20'. */
  SIG_MESSAGE("sg20 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg20");
#define mccompcurname  sg20
#define mccompcurtype  Guide_gravity
#define mccompcurindex 57
#define GVars mccsg20_GVars
#define pTable mccsg20_pTable
{   /* Declarations of sg20=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg20_w1;
MCNUM h1 = mccsg20_h1;
MCNUM w2 = mccsg20_w2;
MCNUM h2 = mccsg20_h2;
MCNUM l = mccsg20_l;
MCNUM R0 = mccsg20_R0;
MCNUM Qc = mccsg20_Qc;
MCNUM alpha = mccsg20_alpha;
MCNUM m = mccsg20_m;
MCNUM W = mccsg20_W;
MCNUM nslit = mccsg20_nslit;
MCNUM d = mccsg20_d;
MCNUM mleft = mccsg20_mleft;
MCNUM mright = mccsg20_mright;
MCNUM mtop = mccsg20_mtop;
MCNUM mbottom = mccsg20_mbottom;
MCNUM nhslit = mccsg20_nhslit;
MCNUM G = mccsg20_G;
MCNUM aleft = mccsg20_aleft;
MCNUM aright = mccsg20_aright;
MCNUM atop = mccsg20_atop;
MCNUM abottom = mccsg20_abottom;
MCNUM wavy = mccsg20_wavy;
MCNUM wavy_z = mccsg20_wavy_z;
MCNUM wavy_tb = mccsg20_wavy_tb;
MCNUM wavy_lr = mccsg20_wavy_lr;
MCNUM chamfers = mccsg20_chamfers;
MCNUM chamfers_z = mccsg20_chamfers_z;
MCNUM chamfers_lr = mccsg20_chamfers_lr;
MCNUM chamfers_tb = mccsg20_chamfers_tb;
MCNUM nelements = mccsg20_nelements;
MCNUM nu = mccsg20_nu;
MCNUM phase = mccsg20_phase;
char* reflect = mccsg20_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 80051 "ILL_H15_D11.c"
}   /* End of sg20=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg21'. */
  SIG_MESSAGE("sg21 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg21");
#define mccompcurname  sg21
#define mccompcurtype  Guide_gravity
#define mccompcurindex 58
#define GVars mccsg21_GVars
#define pTable mccsg21_pTable
{   /* Declarations of sg21=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg21_w1;
MCNUM h1 = mccsg21_h1;
MCNUM w2 = mccsg21_w2;
MCNUM h2 = mccsg21_h2;
MCNUM l = mccsg21_l;
MCNUM R0 = mccsg21_R0;
MCNUM Qc = mccsg21_Qc;
MCNUM alpha = mccsg21_alpha;
MCNUM m = mccsg21_m;
MCNUM W = mccsg21_W;
MCNUM nslit = mccsg21_nslit;
MCNUM d = mccsg21_d;
MCNUM mleft = mccsg21_mleft;
MCNUM mright = mccsg21_mright;
MCNUM mtop = mccsg21_mtop;
MCNUM mbottom = mccsg21_mbottom;
MCNUM nhslit = mccsg21_nhslit;
MCNUM G = mccsg21_G;
MCNUM aleft = mccsg21_aleft;
MCNUM aright = mccsg21_aright;
MCNUM atop = mccsg21_atop;
MCNUM abottom = mccsg21_abottom;
MCNUM wavy = mccsg21_wavy;
MCNUM wavy_z = mccsg21_wavy_z;
MCNUM wavy_tb = mccsg21_wavy_tb;
MCNUM wavy_lr = mccsg21_wavy_lr;
MCNUM chamfers = mccsg21_chamfers;
MCNUM chamfers_z = mccsg21_chamfers_z;
MCNUM chamfers_lr = mccsg21_chamfers_lr;
MCNUM chamfers_tb = mccsg21_chamfers_tb;
MCNUM nelements = mccsg21_nelements;
MCNUM nu = mccsg21_nu;
MCNUM phase = mccsg21_phase;
char* reflect = mccsg21_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 80165 "ILL_H15_D11.c"
}   /* End of sg21=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg22'. */
  SIG_MESSAGE("sg22 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg22");
#define mccompcurname  sg22
#define mccompcurtype  Guide_gravity
#define mccompcurindex 59
#define GVars mccsg22_GVars
#define pTable mccsg22_pTable
{   /* Declarations of sg22=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg22_w1;
MCNUM h1 = mccsg22_h1;
MCNUM w2 = mccsg22_w2;
MCNUM h2 = mccsg22_h2;
MCNUM l = mccsg22_l;
MCNUM R0 = mccsg22_R0;
MCNUM Qc = mccsg22_Qc;
MCNUM alpha = mccsg22_alpha;
MCNUM m = mccsg22_m;
MCNUM W = mccsg22_W;
MCNUM nslit = mccsg22_nslit;
MCNUM d = mccsg22_d;
MCNUM mleft = mccsg22_mleft;
MCNUM mright = mccsg22_mright;
MCNUM mtop = mccsg22_mtop;
MCNUM mbottom = mccsg22_mbottom;
MCNUM nhslit = mccsg22_nhslit;
MCNUM G = mccsg22_G;
MCNUM aleft = mccsg22_aleft;
MCNUM aright = mccsg22_aright;
MCNUM atop = mccsg22_atop;
MCNUM abottom = mccsg22_abottom;
MCNUM wavy = mccsg22_wavy;
MCNUM wavy_z = mccsg22_wavy_z;
MCNUM wavy_tb = mccsg22_wavy_tb;
MCNUM wavy_lr = mccsg22_wavy_lr;
MCNUM chamfers = mccsg22_chamfers;
MCNUM chamfers_z = mccsg22_chamfers_z;
MCNUM chamfers_lr = mccsg22_chamfers_lr;
MCNUM chamfers_tb = mccsg22_chamfers_tb;
MCNUM nelements = mccsg22_nelements;
MCNUM nu = mccsg22_nu;
MCNUM phase = mccsg22_phase;
char* reflect = mccsg22_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 80279 "ILL_H15_D11.c"
}   /* End of sg22=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'AlWindow6'. */
  SIG_MESSAGE("AlWindow6 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "AlWindow6");
#define mccompcurname  AlWindow6
#define mccompcurtype  Al_window
#define mccompcurindex 60
{   /* Declarations of AlWindow6=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow6_thickness;
#line 95 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 80303 "ILL_H15_D11.c"
}   /* End of AlWindow6=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PSD_IN6'. */
  SIG_MESSAGE("PSD_IN6 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PSD_IN6");
#define mccompcurname  PSD_IN6
#define mccompcurtype  Monitor_nD
#define mccompcurindex 61
#define user1 mccPSD_IN6_user1
#define user2 mccPSD_IN6_user2
#define user3 mccPSD_IN6_user3
#define DEFS mccPSD_IN6_DEFS
#define Vars mccPSD_IN6_Vars
#define detector mccPSD_IN6_detector
#define offdata mccPSD_IN6_offdata
{   /* Declarations of PSD_IN6=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccPSD_IN6_xwidth;
MCNUM yheight = mccPSD_IN6_yheight;
MCNUM zdepth = mccPSD_IN6_zdepth;
MCNUM xmin = mccPSD_IN6_xmin;
MCNUM xmax = mccPSD_IN6_xmax;
MCNUM ymin = mccPSD_IN6_ymin;
MCNUM ymax = mccPSD_IN6_ymax;
MCNUM zmin = mccPSD_IN6_zmin;
MCNUM zmax = mccPSD_IN6_zmax;
MCNUM bins = mccPSD_IN6_bins;
MCNUM min = mccPSD_IN6_min;
MCNUM max = mccPSD_IN6_max;
MCNUM restore_neutron = mccPSD_IN6_restore_neutron;
MCNUM radius = mccPSD_IN6_radius;
char* options = mccPSD_IN6_options;
char* filename = mccPSD_IN6_filename;
char* geometry = mccPSD_IN6_geometry;
char* username1 = mccPSD_IN6_username1;
char* username2 = mccPSD_IN6_username2;
char* username3 = mccPSD_IN6_username3;
int nowritefile = mccPSD_IN6_nowritefile;
#line 496 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    off_display(offdata);
  } else {
    Monitor_nD_McDisplay(&DEFS, &Vars);
  }
}
#line 80353 "ILL_H15_D11.c"
}   /* End of PSD_IN6=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'AlWindow7'. */
  SIG_MESSAGE("AlWindow7 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "AlWindow7");
#define mccompcurname  AlWindow7
#define mccompcurtype  Al_window
#define mccompcurindex 62
{   /* Declarations of AlWindow7=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow7_thickness;
#line 95 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 80382 "ILL_H15_D11.c"
}   /* End of AlWindow7=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'IN6toD7GuideStart'. */
  SIG_MESSAGE("IN6toD7GuideStart (McDisplay)");
  printf("MCDISPLAY: component %s\n", "IN6toD7GuideStart");
#define mccompcurname  IN6toD7GuideStart
#define mccompcurtype  Arm
#define mccompcurindex 63
#line 40 "/usr/share/mcstas/2.6rc1/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 80402 "ILL_H15_D11.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg23'. */
  SIG_MESSAGE("sg23 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg23");
#define mccompcurname  sg23
#define mccompcurtype  Guide_gravity
#define mccompcurindex 64
#define GVars mccsg23_GVars
#define pTable mccsg23_pTable
{   /* Declarations of sg23=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg23_w1;
MCNUM h1 = mccsg23_h1;
MCNUM w2 = mccsg23_w2;
MCNUM h2 = mccsg23_h2;
MCNUM l = mccsg23_l;
MCNUM R0 = mccsg23_R0;
MCNUM Qc = mccsg23_Qc;
MCNUM alpha = mccsg23_alpha;
MCNUM m = mccsg23_m;
MCNUM W = mccsg23_W;
MCNUM nslit = mccsg23_nslit;
MCNUM d = mccsg23_d;
MCNUM mleft = mccsg23_mleft;
MCNUM mright = mccsg23_mright;
MCNUM mtop = mccsg23_mtop;
MCNUM mbottom = mccsg23_mbottom;
MCNUM nhslit = mccsg23_nhslit;
MCNUM G = mccsg23_G;
MCNUM aleft = mccsg23_aleft;
MCNUM aright = mccsg23_aright;
MCNUM atop = mccsg23_atop;
MCNUM abottom = mccsg23_abottom;
MCNUM wavy = mccsg23_wavy;
MCNUM wavy_z = mccsg23_wavy_z;
MCNUM wavy_tb = mccsg23_wavy_tb;
MCNUM wavy_lr = mccsg23_wavy_lr;
MCNUM chamfers = mccsg23_chamfers;
MCNUM chamfers_z = mccsg23_chamfers_z;
MCNUM chamfers_lr = mccsg23_chamfers_lr;
MCNUM chamfers_tb = mccsg23_chamfers_tb;
MCNUM nelements = mccsg23_nelements;
MCNUM nu = mccsg23_nu;
MCNUM phase = mccsg23_phase;
char* reflect = mccsg23_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 80513 "ILL_H15_D11.c"
}   /* End of sg23=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg24'. */
  SIG_MESSAGE("sg24 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg24");
#define mccompcurname  sg24
#define mccompcurtype  Guide_gravity
#define mccompcurindex 65
#define GVars mccsg24_GVars
#define pTable mccsg24_pTable
{   /* Declarations of sg24=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg24_w1;
MCNUM h1 = mccsg24_h1;
MCNUM w2 = mccsg24_w2;
MCNUM h2 = mccsg24_h2;
MCNUM l = mccsg24_l;
MCNUM R0 = mccsg24_R0;
MCNUM Qc = mccsg24_Qc;
MCNUM alpha = mccsg24_alpha;
MCNUM m = mccsg24_m;
MCNUM W = mccsg24_W;
MCNUM nslit = mccsg24_nslit;
MCNUM d = mccsg24_d;
MCNUM mleft = mccsg24_mleft;
MCNUM mright = mccsg24_mright;
MCNUM mtop = mccsg24_mtop;
MCNUM mbottom = mccsg24_mbottom;
MCNUM nhslit = mccsg24_nhslit;
MCNUM G = mccsg24_G;
MCNUM aleft = mccsg24_aleft;
MCNUM aright = mccsg24_aright;
MCNUM atop = mccsg24_atop;
MCNUM abottom = mccsg24_abottom;
MCNUM wavy = mccsg24_wavy;
MCNUM wavy_z = mccsg24_wavy_z;
MCNUM wavy_tb = mccsg24_wavy_tb;
MCNUM wavy_lr = mccsg24_wavy_lr;
MCNUM chamfers = mccsg24_chamfers;
MCNUM chamfers_z = mccsg24_chamfers_z;
MCNUM chamfers_lr = mccsg24_chamfers_lr;
MCNUM chamfers_tb = mccsg24_chamfers_tb;
MCNUM nelements = mccsg24_nelements;
MCNUM nu = mccsg24_nu;
MCNUM phase = mccsg24_phase;
char* reflect = mccsg24_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 80627 "ILL_H15_D11.c"
}   /* End of sg24=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg25'. */
  SIG_MESSAGE("sg25 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg25");
#define mccompcurname  sg25
#define mccompcurtype  Guide_gravity
#define mccompcurindex 66
#define GVars mccsg25_GVars
#define pTable mccsg25_pTable
{   /* Declarations of sg25=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg25_w1;
MCNUM h1 = mccsg25_h1;
MCNUM w2 = mccsg25_w2;
MCNUM h2 = mccsg25_h2;
MCNUM l = mccsg25_l;
MCNUM R0 = mccsg25_R0;
MCNUM Qc = mccsg25_Qc;
MCNUM alpha = mccsg25_alpha;
MCNUM m = mccsg25_m;
MCNUM W = mccsg25_W;
MCNUM nslit = mccsg25_nslit;
MCNUM d = mccsg25_d;
MCNUM mleft = mccsg25_mleft;
MCNUM mright = mccsg25_mright;
MCNUM mtop = mccsg25_mtop;
MCNUM mbottom = mccsg25_mbottom;
MCNUM nhslit = mccsg25_nhslit;
MCNUM G = mccsg25_G;
MCNUM aleft = mccsg25_aleft;
MCNUM aright = mccsg25_aright;
MCNUM atop = mccsg25_atop;
MCNUM abottom = mccsg25_abottom;
MCNUM wavy = mccsg25_wavy;
MCNUM wavy_z = mccsg25_wavy_z;
MCNUM wavy_tb = mccsg25_wavy_tb;
MCNUM wavy_lr = mccsg25_wavy_lr;
MCNUM chamfers = mccsg25_chamfers;
MCNUM chamfers_z = mccsg25_chamfers_z;
MCNUM chamfers_lr = mccsg25_chamfers_lr;
MCNUM chamfers_tb = mccsg25_chamfers_tb;
MCNUM nelements = mccsg25_nelements;
MCNUM nu = mccsg25_nu;
MCNUM phase = mccsg25_phase;
char* reflect = mccsg25_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 80741 "ILL_H15_D11.c"
}   /* End of sg25=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg26'. */
  SIG_MESSAGE("sg26 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg26");
#define mccompcurname  sg26
#define mccompcurtype  Guide_gravity
#define mccompcurindex 67
#define GVars mccsg26_GVars
#define pTable mccsg26_pTable
{   /* Declarations of sg26=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg26_w1;
MCNUM h1 = mccsg26_h1;
MCNUM w2 = mccsg26_w2;
MCNUM h2 = mccsg26_h2;
MCNUM l = mccsg26_l;
MCNUM R0 = mccsg26_R0;
MCNUM Qc = mccsg26_Qc;
MCNUM alpha = mccsg26_alpha;
MCNUM m = mccsg26_m;
MCNUM W = mccsg26_W;
MCNUM nslit = mccsg26_nslit;
MCNUM d = mccsg26_d;
MCNUM mleft = mccsg26_mleft;
MCNUM mright = mccsg26_mright;
MCNUM mtop = mccsg26_mtop;
MCNUM mbottom = mccsg26_mbottom;
MCNUM nhslit = mccsg26_nhslit;
MCNUM G = mccsg26_G;
MCNUM aleft = mccsg26_aleft;
MCNUM aright = mccsg26_aright;
MCNUM atop = mccsg26_atop;
MCNUM abottom = mccsg26_abottom;
MCNUM wavy = mccsg26_wavy;
MCNUM wavy_z = mccsg26_wavy_z;
MCNUM wavy_tb = mccsg26_wavy_tb;
MCNUM wavy_lr = mccsg26_wavy_lr;
MCNUM chamfers = mccsg26_chamfers;
MCNUM chamfers_z = mccsg26_chamfers_z;
MCNUM chamfers_lr = mccsg26_chamfers_lr;
MCNUM chamfers_tb = mccsg26_chamfers_tb;
MCNUM nelements = mccsg26_nelements;
MCNUM nu = mccsg26_nu;
MCNUM phase = mccsg26_phase;
char* reflect = mccsg26_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 80855 "ILL_H15_D11.c"
}   /* End of sg26=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg27'. */
  SIG_MESSAGE("sg27 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg27");
#define mccompcurname  sg27
#define mccompcurtype  Guide_gravity
#define mccompcurindex 68
#define GVars mccsg27_GVars
#define pTable mccsg27_pTable
{   /* Declarations of sg27=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg27_w1;
MCNUM h1 = mccsg27_h1;
MCNUM w2 = mccsg27_w2;
MCNUM h2 = mccsg27_h2;
MCNUM l = mccsg27_l;
MCNUM R0 = mccsg27_R0;
MCNUM Qc = mccsg27_Qc;
MCNUM alpha = mccsg27_alpha;
MCNUM m = mccsg27_m;
MCNUM W = mccsg27_W;
MCNUM nslit = mccsg27_nslit;
MCNUM d = mccsg27_d;
MCNUM mleft = mccsg27_mleft;
MCNUM mright = mccsg27_mright;
MCNUM mtop = mccsg27_mtop;
MCNUM mbottom = mccsg27_mbottom;
MCNUM nhslit = mccsg27_nhslit;
MCNUM G = mccsg27_G;
MCNUM aleft = mccsg27_aleft;
MCNUM aright = mccsg27_aright;
MCNUM atop = mccsg27_atop;
MCNUM abottom = mccsg27_abottom;
MCNUM wavy = mccsg27_wavy;
MCNUM wavy_z = mccsg27_wavy_z;
MCNUM wavy_tb = mccsg27_wavy_tb;
MCNUM wavy_lr = mccsg27_wavy_lr;
MCNUM chamfers = mccsg27_chamfers;
MCNUM chamfers_z = mccsg27_chamfers_z;
MCNUM chamfers_lr = mccsg27_chamfers_lr;
MCNUM chamfers_tb = mccsg27_chamfers_tb;
MCNUM nelements = mccsg27_nelements;
MCNUM nu = mccsg27_nu;
MCNUM phase = mccsg27_phase;
char* reflect = mccsg27_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 80969 "ILL_H15_D11.c"
}   /* End of sg27=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'AlWindow8'. */
  SIG_MESSAGE("AlWindow8 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "AlWindow8");
#define mccompcurname  AlWindow8
#define mccompcurtype  Al_window
#define mccompcurindex 69
{   /* Declarations of AlWindow8=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow8_thickness;
#line 95 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 80993 "ILL_H15_D11.c"
}   /* End of AlWindow8=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'PSD_D7'. */
  SIG_MESSAGE("PSD_D7 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "PSD_D7");
#define mccompcurname  PSD_D7
#define mccompcurtype  Monitor_nD
#define mccompcurindex 70
#define user1 mccPSD_D7_user1
#define user2 mccPSD_D7_user2
#define user3 mccPSD_D7_user3
#define DEFS mccPSD_D7_DEFS
#define Vars mccPSD_D7_Vars
#define detector mccPSD_D7_detector
#define offdata mccPSD_D7_offdata
{   /* Declarations of PSD_D7=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccPSD_D7_xwidth;
MCNUM yheight = mccPSD_D7_yheight;
MCNUM zdepth = mccPSD_D7_zdepth;
MCNUM xmin = mccPSD_D7_xmin;
MCNUM xmax = mccPSD_D7_xmax;
MCNUM ymin = mccPSD_D7_ymin;
MCNUM ymax = mccPSD_D7_ymax;
MCNUM zmin = mccPSD_D7_zmin;
MCNUM zmax = mccPSD_D7_zmax;
MCNUM bins = mccPSD_D7_bins;
MCNUM min = mccPSD_D7_min;
MCNUM max = mccPSD_D7_max;
MCNUM restore_neutron = mccPSD_D7_restore_neutron;
MCNUM radius = mccPSD_D7_radius;
char* options = mccPSD_D7_options;
char* filename = mccPSD_D7_filename;
char* geometry = mccPSD_D7_geometry;
char* username1 = mccPSD_D7_username1;
char* username2 = mccPSD_D7_username2;
char* username3 = mccPSD_D7_username3;
int nowritefile = mccPSD_D7_nowritefile;
#line 496 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    off_display(offdata);
  } else {
    Monitor_nD_McDisplay(&DEFS, &Vars);
  }
}
#line 81043 "ILL_H15_D11.c"
}   /* End of PSD_D7=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'AlWindow9'. */
  SIG_MESSAGE("AlWindow9 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "AlWindow9");
#define mccompcurname  AlWindow9
#define mccompcurtype  Al_window
#define mccompcurindex 71
{   /* Declarations of AlWindow9=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow9_thickness;
#line 95 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 81072 "ILL_H15_D11.c"
}   /* End of AlWindow9=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'D7toD11GuideStart'. */
  SIG_MESSAGE("D7toD11GuideStart (McDisplay)");
  printf("MCDISPLAY: component %s\n", "D7toD11GuideStart");
#define mccompcurname  D7toD11GuideStart
#define mccompcurtype  Arm
#define mccompcurindex 72
#line 40 "/usr/share/mcstas/2.6rc1/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 81092 "ILL_H15_D11.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg28'. */
  SIG_MESSAGE("sg28 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg28");
#define mccompcurname  sg28
#define mccompcurtype  Guide_gravity
#define mccompcurindex 73
#define GVars mccsg28_GVars
#define pTable mccsg28_pTable
{   /* Declarations of sg28=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg28_w1;
MCNUM h1 = mccsg28_h1;
MCNUM w2 = mccsg28_w2;
MCNUM h2 = mccsg28_h2;
MCNUM l = mccsg28_l;
MCNUM R0 = mccsg28_R0;
MCNUM Qc = mccsg28_Qc;
MCNUM alpha = mccsg28_alpha;
MCNUM m = mccsg28_m;
MCNUM W = mccsg28_W;
MCNUM nslit = mccsg28_nslit;
MCNUM d = mccsg28_d;
MCNUM mleft = mccsg28_mleft;
MCNUM mright = mccsg28_mright;
MCNUM mtop = mccsg28_mtop;
MCNUM mbottom = mccsg28_mbottom;
MCNUM nhslit = mccsg28_nhslit;
MCNUM G = mccsg28_G;
MCNUM aleft = mccsg28_aleft;
MCNUM aright = mccsg28_aright;
MCNUM atop = mccsg28_atop;
MCNUM abottom = mccsg28_abottom;
MCNUM wavy = mccsg28_wavy;
MCNUM wavy_z = mccsg28_wavy_z;
MCNUM wavy_tb = mccsg28_wavy_tb;
MCNUM wavy_lr = mccsg28_wavy_lr;
MCNUM chamfers = mccsg28_chamfers;
MCNUM chamfers_z = mccsg28_chamfers_z;
MCNUM chamfers_lr = mccsg28_chamfers_lr;
MCNUM chamfers_tb = mccsg28_chamfers_tb;
MCNUM nelements = mccsg28_nelements;
MCNUM nu = mccsg28_nu;
MCNUM phase = mccsg28_phase;
char* reflect = mccsg28_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 81203 "ILL_H15_D11.c"
}   /* End of sg28=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg29'. */
  SIG_MESSAGE("sg29 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg29");
#define mccompcurname  sg29
#define mccompcurtype  Guide_gravity
#define mccompcurindex 74
#define GVars mccsg29_GVars
#define pTable mccsg29_pTable
{   /* Declarations of sg29=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg29_w1;
MCNUM h1 = mccsg29_h1;
MCNUM w2 = mccsg29_w2;
MCNUM h2 = mccsg29_h2;
MCNUM l = mccsg29_l;
MCNUM R0 = mccsg29_R0;
MCNUM Qc = mccsg29_Qc;
MCNUM alpha = mccsg29_alpha;
MCNUM m = mccsg29_m;
MCNUM W = mccsg29_W;
MCNUM nslit = mccsg29_nslit;
MCNUM d = mccsg29_d;
MCNUM mleft = mccsg29_mleft;
MCNUM mright = mccsg29_mright;
MCNUM mtop = mccsg29_mtop;
MCNUM mbottom = mccsg29_mbottom;
MCNUM nhslit = mccsg29_nhslit;
MCNUM G = mccsg29_G;
MCNUM aleft = mccsg29_aleft;
MCNUM aright = mccsg29_aright;
MCNUM atop = mccsg29_atop;
MCNUM abottom = mccsg29_abottom;
MCNUM wavy = mccsg29_wavy;
MCNUM wavy_z = mccsg29_wavy_z;
MCNUM wavy_tb = mccsg29_wavy_tb;
MCNUM wavy_lr = mccsg29_wavy_lr;
MCNUM chamfers = mccsg29_chamfers;
MCNUM chamfers_z = mccsg29_chamfers_z;
MCNUM chamfers_lr = mccsg29_chamfers_lr;
MCNUM chamfers_tb = mccsg29_chamfers_tb;
MCNUM nelements = mccsg29_nelements;
MCNUM nu = mccsg29_nu;
MCNUM phase = mccsg29_phase;
char* reflect = mccsg29_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 81317 "ILL_H15_D11.c"
}   /* End of sg29=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'AlWindow10'. */
  SIG_MESSAGE("AlWindow10 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "AlWindow10");
#define mccompcurname  AlWindow10
#define mccompcurtype  Al_window
#define mccompcurindex 75
{   /* Declarations of AlWindow10=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow10_thickness;
#line 95 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 81341 "ILL_H15_D11.c"
}   /* End of AlWindow10=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Mon_D11_In'. */
  SIG_MESSAGE("Mon_D11_In (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Mon_D11_In");
#define mccompcurname  Mon_D11_In
#define mccompcurtype  Monitor_nD
#define mccompcurindex 76
#define user1 mccMon_D11_In_user1
#define user2 mccMon_D11_In_user2
#define user3 mccMon_D11_In_user3
#define DEFS mccMon_D11_In_DEFS
#define Vars mccMon_D11_In_Vars
#define detector mccMon_D11_In_detector
#define offdata mccMon_D11_In_offdata
{   /* Declarations of Mon_D11_In=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccMon_D11_In_xwidth;
MCNUM yheight = mccMon_D11_In_yheight;
MCNUM zdepth = mccMon_D11_In_zdepth;
MCNUM xmin = mccMon_D11_In_xmin;
MCNUM xmax = mccMon_D11_In_xmax;
MCNUM ymin = mccMon_D11_In_ymin;
MCNUM ymax = mccMon_D11_In_ymax;
MCNUM zmin = mccMon_D11_In_zmin;
MCNUM zmax = mccMon_D11_In_zmax;
MCNUM bins = mccMon_D11_In_bins;
MCNUM min = mccMon_D11_In_min;
MCNUM max = mccMon_D11_In_max;
MCNUM restore_neutron = mccMon_D11_In_restore_neutron;
MCNUM radius = mccMon_D11_In_radius;
char* options = mccMon_D11_In_options;
char* filename = mccMon_D11_In_filename;
char* geometry = mccMon_D11_In_geometry;
char* username1 = mccMon_D11_In_username1;
char* username2 = mccMon_D11_In_username2;
char* username3 = mccMon_D11_In_username3;
int nowritefile = mccMon_D11_In_nowritefile;
#line 496 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    off_display(offdata);
  } else {
    Monitor_nD_McDisplay(&DEFS, &Vars);
  }
}
#line 81391 "ILL_H15_D11.c"
}   /* End of Mon_D11_In=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Dolores'. */
  SIG_MESSAGE("Dolores (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Dolores");
#define mccompcurname  Dolores
#define mccompcurtype  V_selector
#define mccompcurindex 77
#define omega mccDolores_omega
#define alpha_rad mccDolores_alpha_rad
#define dt0 mccDolores_dt0
#define dt1 mccDolores_dt1
#define r_i mccDolores_r_i
#define r_f mccDolores_r_f
#define r_mean mccDolores_r_mean
#define theta_i mccDolores_theta_i
#define theta_f mccDolores_theta_f
#define A mccDolores_A
#define d_s_alpha mccDolores_d_s_alpha
{   /* Declarations of Dolores=V_selector() SETTING parameters. */
MCNUM xwidth = mccDolores_xwidth;
MCNUM yheight = mccDolores_yheight;
MCNUM zdepth = mccDolores_zdepth;
MCNUM radius = mccDolores_radius;
MCNUM alpha = mccDolores_alpha;
MCNUM length = mccDolores_length;
MCNUM d = mccDolores_d;
MCNUM nu = mccDolores_nu;
MCNUM nslit = mccDolores_nslit;
#line 104 "/usr/share/mcstas/2.6rc1/optics/V_selector.comp"
{
  double r = radius + yheight;
  double x0 = -xwidth/2.0;
  double x1 =  xwidth/2.0;
  double y0 = -yheight/2.0;
  double y1 =  yheight/2.0;
  double z0 = -zdepth/2.0;
  double z1 = -length/2.0;
  double z2 =  length/2.0;
  double z3 =  zdepth/2.0;
  double a;
  double xw, yh;

  
  xw = xwidth/2.0;
  yh = yheight/2.0;
  /* Draw apertures */
  for(a = z0;;)
  {
    multiline(3, x0-xw, (double)y1, a,
              (double)x0, (double)y1, a,
              (double)x0, y1+yh, a);
    multiline(3, x1+xw, (double)y1, a,
              (double)x1, (double)y1, a,
              (double)x1, y1+yh, a);
    multiline(3, x0-xw, (double)y0, a,
              (double)x0, (double)y0, a,
              (double)x0, y0-yh, a);
    multiline(3, x1+xw, (double)y0, a,
              (double)x1, (double)y0, a,
              (double)x1, y0-yh, a);
    if(a == z3)
      break;
    else
      a = z3;
  }

  /* Draw cylinder. */
  circle("xy", 0, -radius, z1, r);
  circle("xy", 0, -radius, z2, r);
  line(0, -radius, z1, 0, -radius, z2);
  for(a = 0; a < 2*PI; a += PI/8)
  {
    multiline(4,
              0.0, -radius, z1,
              r*cos(a), r*sin(a) - radius, z1,
              r*cos(a + DEG2RAD*alpha), r*sin(a + DEG2RAD*alpha) - radius, z2,
              0.0, -radius, z2);
  }
}
#line 81482 "ILL_H15_D11.c"
}   /* End of Dolores=V_selector() SETTING parameter declarations. */
#undef d_s_alpha
#undef A
#undef theta_f
#undef theta_i
#undef r_mean
#undef r_f
#undef r_i
#undef dt1
#undef dt0
#undef alpha_rad
#undef omega
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'AlWindow11'. */
  SIG_MESSAGE("AlWindow11 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "AlWindow11");
#define mccompcurname  AlWindow11
#define mccompcurtype  Al_window
#define mccompcurindex 78
{   /* Declarations of AlWindow11=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow11_thickness;
#line 95 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 81515 "ILL_H15_D11.c"
}   /* End of AlWindow11=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'sg30'. */
  SIG_MESSAGE("sg30 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "sg30");
#define mccompcurname  sg30
#define mccompcurtype  Guide_gravity
#define mccompcurindex 79
#define GVars mccsg30_GVars
#define pTable mccsg30_pTable
{   /* Declarations of sg30=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccsg30_w1;
MCNUM h1 = mccsg30_h1;
MCNUM w2 = mccsg30_w2;
MCNUM h2 = mccsg30_h2;
MCNUM l = mccsg30_l;
MCNUM R0 = mccsg30_R0;
MCNUM Qc = mccsg30_Qc;
MCNUM alpha = mccsg30_alpha;
MCNUM m = mccsg30_m;
MCNUM W = mccsg30_W;
MCNUM nslit = mccsg30_nslit;
MCNUM d = mccsg30_d;
MCNUM mleft = mccsg30_mleft;
MCNUM mright = mccsg30_mright;
MCNUM mtop = mccsg30_mtop;
MCNUM mbottom = mccsg30_mbottom;
MCNUM nhslit = mccsg30_nhslit;
MCNUM G = mccsg30_G;
MCNUM aleft = mccsg30_aleft;
MCNUM aright = mccsg30_aright;
MCNUM atop = mccsg30_atop;
MCNUM abottom = mccsg30_abottom;
MCNUM wavy = mccsg30_wavy;
MCNUM wavy_z = mccsg30_wavy_z;
MCNUM wavy_tb = mccsg30_wavy_tb;
MCNUM wavy_lr = mccsg30_wavy_lr;
MCNUM chamfers = mccsg30_chamfers;
MCNUM chamfers_z = mccsg30_chamfers_z;
MCNUM chamfers_lr = mccsg30_chamfers_lr;
MCNUM chamfers_tb = mccsg30_chamfers_tb;
MCNUM nelements = mccsg30_nelements;
MCNUM nu = mccsg30_nu;
MCNUM phase = mccsg30_phase;
char* reflect = mccsg30_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 81627 "ILL_H15_D11.c"
}   /* End of sg30=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'AlWindow12'. */
  SIG_MESSAGE("AlWindow12 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "AlWindow12");
#define mccompcurname  AlWindow12
#define mccompcurtype  Al_window
#define mccompcurindex 80
{   /* Declarations of AlWindow12=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow12_thickness;
#line 95 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 81651 "ILL_H15_D11.c"
}   /* End of AlWindow12=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'Mon_D11_Out'. */
  SIG_MESSAGE("Mon_D11_Out (McDisplay)");
  printf("MCDISPLAY: component %s\n", "Mon_D11_Out");
#define mccompcurname  Mon_D11_Out
#define mccompcurtype  Monitor_nD
#define mccompcurindex 81
#define user1 mccMon_D11_Out_user1
#define user2 mccMon_D11_Out_user2
#define user3 mccMon_D11_Out_user3
#define DEFS mccMon_D11_Out_DEFS
#define Vars mccMon_D11_Out_Vars
#define detector mccMon_D11_Out_detector
#define offdata mccMon_D11_Out_offdata
{   /* Declarations of Mon_D11_Out=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccMon_D11_Out_xwidth;
MCNUM yheight = mccMon_D11_Out_yheight;
MCNUM zdepth = mccMon_D11_Out_zdepth;
MCNUM xmin = mccMon_D11_Out_xmin;
MCNUM xmax = mccMon_D11_Out_xmax;
MCNUM ymin = mccMon_D11_Out_ymin;
MCNUM ymax = mccMon_D11_Out_ymax;
MCNUM zmin = mccMon_D11_Out_zmin;
MCNUM zmax = mccMon_D11_Out_zmax;
MCNUM bins = mccMon_D11_Out_bins;
MCNUM min = mccMon_D11_Out_min;
MCNUM max = mccMon_D11_Out_max;
MCNUM restore_neutron = mccMon_D11_Out_restore_neutron;
MCNUM radius = mccMon_D11_Out_radius;
char* options = mccMon_D11_Out_options;
char* filename = mccMon_D11_Out_filename;
char* geometry = mccMon_D11_Out_geometry;
char* username1 = mccMon_D11_Out_username1;
char* username2 = mccMon_D11_Out_username2;
char* username3 = mccMon_D11_Out_username3;
int nowritefile = mccMon_D11_Out_nowritefile;
#line 496 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    off_display(offdata);
  } else {
    Monitor_nD_McDisplay(&DEFS, &Vars);
  }
}
#line 81701 "ILL_H15_D11.c"
}   /* End of Mon_D11_Out=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'AlWindow13'. */
  SIG_MESSAGE("AlWindow13 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "AlWindow13");
#define mccompcurname  AlWindow13
#define mccompcurtype  Al_window
#define mccompcurindex 82
{   /* Declarations of AlWindow13=Al_window() SETTING parameters. */
MCNUM thickness = mccAlWindow13_thickness;
#line 95 "/usr/share/mcstas/2.6rc1/contrib/Al_window.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 81730 "ILL_H15_D11.c"
}   /* End of AlWindow13=Al_window() SETTING parameter declarations. */
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'MovableGuideStart'. */
  SIG_MESSAGE("MovableGuideStart (McDisplay)");
  printf("MCDISPLAY: component %s\n", "MovableGuideStart");
#define mccompcurname  MovableGuideStart
#define mccompcurtype  Arm
#define mccompcurindex 83
#line 40 "/usr/share/mcstas/2.6rc1/optics/Arm.comp"
{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
}
#line 81750 "ILL_H15_D11.c"
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'mg0'. */
  SIG_MESSAGE("mg0 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "mg0");
#define mccompcurname  mg0
#define mccompcurtype  Guide_gravity
#define mccompcurindex 84
#define GVars mccmg0_GVars
#define pTable mccmg0_pTable
{   /* Declarations of mg0=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg0_w1;
MCNUM h1 = mccmg0_h1;
MCNUM w2 = mccmg0_w2;
MCNUM h2 = mccmg0_h2;
MCNUM l = mccmg0_l;
MCNUM R0 = mccmg0_R0;
MCNUM Qc = mccmg0_Qc;
MCNUM alpha = mccmg0_alpha;
MCNUM m = mccmg0_m;
MCNUM W = mccmg0_W;
MCNUM nslit = mccmg0_nslit;
MCNUM d = mccmg0_d;
MCNUM mleft = mccmg0_mleft;
MCNUM mright = mccmg0_mright;
MCNUM mtop = mccmg0_mtop;
MCNUM mbottom = mccmg0_mbottom;
MCNUM nhslit = mccmg0_nhslit;
MCNUM G = mccmg0_G;
MCNUM aleft = mccmg0_aleft;
MCNUM aright = mccmg0_aright;
MCNUM atop = mccmg0_atop;
MCNUM abottom = mccmg0_abottom;
MCNUM wavy = mccmg0_wavy;
MCNUM wavy_z = mccmg0_wavy_z;
MCNUM wavy_tb = mccmg0_wavy_tb;
MCNUM wavy_lr = mccmg0_wavy_lr;
MCNUM chamfers = mccmg0_chamfers;
MCNUM chamfers_z = mccmg0_chamfers_z;
MCNUM chamfers_lr = mccmg0_chamfers_lr;
MCNUM chamfers_tb = mccmg0_chamfers_tb;
MCNUM nelements = mccmg0_nelements;
MCNUM nu = mccmg0_nu;
MCNUM phase = mccmg0_phase;
char* reflect = mccmg0_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 81861 "ILL_H15_D11.c"
}   /* End of mg0=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'mg1'. */
  SIG_MESSAGE("mg1 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "mg1");
#define mccompcurname  mg1
#define mccompcurtype  Guide_gravity
#define mccompcurindex 85
#define GVars mccmg1_GVars
#define pTable mccmg1_pTable
{   /* Declarations of mg1=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg1_w1;
MCNUM h1 = mccmg1_h1;
MCNUM w2 = mccmg1_w2;
MCNUM h2 = mccmg1_h2;
MCNUM l = mccmg1_l;
MCNUM R0 = mccmg1_R0;
MCNUM Qc = mccmg1_Qc;
MCNUM alpha = mccmg1_alpha;
MCNUM m = mccmg1_m;
MCNUM W = mccmg1_W;
MCNUM nslit = mccmg1_nslit;
MCNUM d = mccmg1_d;
MCNUM mleft = mccmg1_mleft;
MCNUM mright = mccmg1_mright;
MCNUM mtop = mccmg1_mtop;
MCNUM mbottom = mccmg1_mbottom;
MCNUM nhslit = mccmg1_nhslit;
MCNUM G = mccmg1_G;
MCNUM aleft = mccmg1_aleft;
MCNUM aright = mccmg1_aright;
MCNUM atop = mccmg1_atop;
MCNUM abottom = mccmg1_abottom;
MCNUM wavy = mccmg1_wavy;
MCNUM wavy_z = mccmg1_wavy_z;
MCNUM wavy_tb = mccmg1_wavy_tb;
MCNUM wavy_lr = mccmg1_wavy_lr;
MCNUM chamfers = mccmg1_chamfers;
MCNUM chamfers_z = mccmg1_chamfers_z;
MCNUM chamfers_lr = mccmg1_chamfers_lr;
MCNUM chamfers_tb = mccmg1_chamfers_tb;
MCNUM nelements = mccmg1_nelements;
MCNUM nu = mccmg1_nu;
MCNUM phase = mccmg1_phase;
char* reflect = mccmg1_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 81975 "ILL_H15_D11.c"
}   /* End of mg1=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'mg2'. */
  SIG_MESSAGE("mg2 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "mg2");
#define mccompcurname  mg2
#define mccompcurtype  Guide_gravity
#define mccompcurindex 86
#define GVars mccmg2_GVars
#define pTable mccmg2_pTable
{   /* Declarations of mg2=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg2_w1;
MCNUM h1 = mccmg2_h1;
MCNUM w2 = mccmg2_w2;
MCNUM h2 = mccmg2_h2;
MCNUM l = mccmg2_l;
MCNUM R0 = mccmg2_R0;
MCNUM Qc = mccmg2_Qc;
MCNUM alpha = mccmg2_alpha;
MCNUM m = mccmg2_m;
MCNUM W = mccmg2_W;
MCNUM nslit = mccmg2_nslit;
MCNUM d = mccmg2_d;
MCNUM mleft = mccmg2_mleft;
MCNUM mright = mccmg2_mright;
MCNUM mtop = mccmg2_mtop;
MCNUM mbottom = mccmg2_mbottom;
MCNUM nhslit = mccmg2_nhslit;
MCNUM G = mccmg2_G;
MCNUM aleft = mccmg2_aleft;
MCNUM aright = mccmg2_aright;
MCNUM atop = mccmg2_atop;
MCNUM abottom = mccmg2_abottom;
MCNUM wavy = mccmg2_wavy;
MCNUM wavy_z = mccmg2_wavy_z;
MCNUM wavy_tb = mccmg2_wavy_tb;
MCNUM wavy_lr = mccmg2_wavy_lr;
MCNUM chamfers = mccmg2_chamfers;
MCNUM chamfers_z = mccmg2_chamfers_z;
MCNUM chamfers_lr = mccmg2_chamfers_lr;
MCNUM chamfers_tb = mccmg2_chamfers_tb;
MCNUM nelements = mccmg2_nelements;
MCNUM nu = mccmg2_nu;
MCNUM phase = mccmg2_phase;
char* reflect = mccmg2_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82089 "ILL_H15_D11.c"
}   /* End of mg2=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'mg3'. */
  SIG_MESSAGE("mg3 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "mg3");
#define mccompcurname  mg3
#define mccompcurtype  Guide_gravity
#define mccompcurindex 87
#define GVars mccmg3_GVars
#define pTable mccmg3_pTable
{   /* Declarations of mg3=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg3_w1;
MCNUM h1 = mccmg3_h1;
MCNUM w2 = mccmg3_w2;
MCNUM h2 = mccmg3_h2;
MCNUM l = mccmg3_l;
MCNUM R0 = mccmg3_R0;
MCNUM Qc = mccmg3_Qc;
MCNUM alpha = mccmg3_alpha;
MCNUM m = mccmg3_m;
MCNUM W = mccmg3_W;
MCNUM nslit = mccmg3_nslit;
MCNUM d = mccmg3_d;
MCNUM mleft = mccmg3_mleft;
MCNUM mright = mccmg3_mright;
MCNUM mtop = mccmg3_mtop;
MCNUM mbottom = mccmg3_mbottom;
MCNUM nhslit = mccmg3_nhslit;
MCNUM G = mccmg3_G;
MCNUM aleft = mccmg3_aleft;
MCNUM aright = mccmg3_aright;
MCNUM atop = mccmg3_atop;
MCNUM abottom = mccmg3_abottom;
MCNUM wavy = mccmg3_wavy;
MCNUM wavy_z = mccmg3_wavy_z;
MCNUM wavy_tb = mccmg3_wavy_tb;
MCNUM wavy_lr = mccmg3_wavy_lr;
MCNUM chamfers = mccmg3_chamfers;
MCNUM chamfers_z = mccmg3_chamfers_z;
MCNUM chamfers_lr = mccmg3_chamfers_lr;
MCNUM chamfers_tb = mccmg3_chamfers_tb;
MCNUM nelements = mccmg3_nelements;
MCNUM nu = mccmg3_nu;
MCNUM phase = mccmg3_phase;
char* reflect = mccmg3_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82203 "ILL_H15_D11.c"
}   /* End of mg3=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'mg4'. */
  SIG_MESSAGE("mg4 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "mg4");
#define mccompcurname  mg4
#define mccompcurtype  Guide_gravity
#define mccompcurindex 88
#define GVars mccmg4_GVars
#define pTable mccmg4_pTable
{   /* Declarations of mg4=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg4_w1;
MCNUM h1 = mccmg4_h1;
MCNUM w2 = mccmg4_w2;
MCNUM h2 = mccmg4_h2;
MCNUM l = mccmg4_l;
MCNUM R0 = mccmg4_R0;
MCNUM Qc = mccmg4_Qc;
MCNUM alpha = mccmg4_alpha;
MCNUM m = mccmg4_m;
MCNUM W = mccmg4_W;
MCNUM nslit = mccmg4_nslit;
MCNUM d = mccmg4_d;
MCNUM mleft = mccmg4_mleft;
MCNUM mright = mccmg4_mright;
MCNUM mtop = mccmg4_mtop;
MCNUM mbottom = mccmg4_mbottom;
MCNUM nhslit = mccmg4_nhslit;
MCNUM G = mccmg4_G;
MCNUM aleft = mccmg4_aleft;
MCNUM aright = mccmg4_aright;
MCNUM atop = mccmg4_atop;
MCNUM abottom = mccmg4_abottom;
MCNUM wavy = mccmg4_wavy;
MCNUM wavy_z = mccmg4_wavy_z;
MCNUM wavy_tb = mccmg4_wavy_tb;
MCNUM wavy_lr = mccmg4_wavy_lr;
MCNUM chamfers = mccmg4_chamfers;
MCNUM chamfers_z = mccmg4_chamfers_z;
MCNUM chamfers_lr = mccmg4_chamfers_lr;
MCNUM chamfers_tb = mccmg4_chamfers_tb;
MCNUM nelements = mccmg4_nelements;
MCNUM nu = mccmg4_nu;
MCNUM phase = mccmg4_phase;
char* reflect = mccmg4_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82317 "ILL_H15_D11.c"
}   /* End of mg4=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'mg5'. */
  SIG_MESSAGE("mg5 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "mg5");
#define mccompcurname  mg5
#define mccompcurtype  Guide_gravity
#define mccompcurindex 89
#define GVars mccmg5_GVars
#define pTable mccmg5_pTable
{   /* Declarations of mg5=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg5_w1;
MCNUM h1 = mccmg5_h1;
MCNUM w2 = mccmg5_w2;
MCNUM h2 = mccmg5_h2;
MCNUM l = mccmg5_l;
MCNUM R0 = mccmg5_R0;
MCNUM Qc = mccmg5_Qc;
MCNUM alpha = mccmg5_alpha;
MCNUM m = mccmg5_m;
MCNUM W = mccmg5_W;
MCNUM nslit = mccmg5_nslit;
MCNUM d = mccmg5_d;
MCNUM mleft = mccmg5_mleft;
MCNUM mright = mccmg5_mright;
MCNUM mtop = mccmg5_mtop;
MCNUM mbottom = mccmg5_mbottom;
MCNUM nhslit = mccmg5_nhslit;
MCNUM G = mccmg5_G;
MCNUM aleft = mccmg5_aleft;
MCNUM aright = mccmg5_aright;
MCNUM atop = mccmg5_atop;
MCNUM abottom = mccmg5_abottom;
MCNUM wavy = mccmg5_wavy;
MCNUM wavy_z = mccmg5_wavy_z;
MCNUM wavy_tb = mccmg5_wavy_tb;
MCNUM wavy_lr = mccmg5_wavy_lr;
MCNUM chamfers = mccmg5_chamfers;
MCNUM chamfers_z = mccmg5_chamfers_z;
MCNUM chamfers_lr = mccmg5_chamfers_lr;
MCNUM chamfers_tb = mccmg5_chamfers_tb;
MCNUM nelements = mccmg5_nelements;
MCNUM nu = mccmg5_nu;
MCNUM phase = mccmg5_phase;
char* reflect = mccmg5_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82431 "ILL_H15_D11.c"
}   /* End of mg5=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'mg6'. */
  SIG_MESSAGE("mg6 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "mg6");
#define mccompcurname  mg6
#define mccompcurtype  Guide_gravity
#define mccompcurindex 90
#define GVars mccmg6_GVars
#define pTable mccmg6_pTable
{   /* Declarations of mg6=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg6_w1;
MCNUM h1 = mccmg6_h1;
MCNUM w2 = mccmg6_w2;
MCNUM h2 = mccmg6_h2;
MCNUM l = mccmg6_l;
MCNUM R0 = mccmg6_R0;
MCNUM Qc = mccmg6_Qc;
MCNUM alpha = mccmg6_alpha;
MCNUM m = mccmg6_m;
MCNUM W = mccmg6_W;
MCNUM nslit = mccmg6_nslit;
MCNUM d = mccmg6_d;
MCNUM mleft = mccmg6_mleft;
MCNUM mright = mccmg6_mright;
MCNUM mtop = mccmg6_mtop;
MCNUM mbottom = mccmg6_mbottom;
MCNUM nhslit = mccmg6_nhslit;
MCNUM G = mccmg6_G;
MCNUM aleft = mccmg6_aleft;
MCNUM aright = mccmg6_aright;
MCNUM atop = mccmg6_atop;
MCNUM abottom = mccmg6_abottom;
MCNUM wavy = mccmg6_wavy;
MCNUM wavy_z = mccmg6_wavy_z;
MCNUM wavy_tb = mccmg6_wavy_tb;
MCNUM wavy_lr = mccmg6_wavy_lr;
MCNUM chamfers = mccmg6_chamfers;
MCNUM chamfers_z = mccmg6_chamfers_z;
MCNUM chamfers_lr = mccmg6_chamfers_lr;
MCNUM chamfers_tb = mccmg6_chamfers_tb;
MCNUM nelements = mccmg6_nelements;
MCNUM nu = mccmg6_nu;
MCNUM phase = mccmg6_phase;
char* reflect = mccmg6_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82545 "ILL_H15_D11.c"
}   /* End of mg6=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'mg7'. */
  SIG_MESSAGE("mg7 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "mg7");
#define mccompcurname  mg7
#define mccompcurtype  Guide_gravity
#define mccompcurindex 91
#define GVars mccmg7_GVars
#define pTable mccmg7_pTable
{   /* Declarations of mg7=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg7_w1;
MCNUM h1 = mccmg7_h1;
MCNUM w2 = mccmg7_w2;
MCNUM h2 = mccmg7_h2;
MCNUM l = mccmg7_l;
MCNUM R0 = mccmg7_R0;
MCNUM Qc = mccmg7_Qc;
MCNUM alpha = mccmg7_alpha;
MCNUM m = mccmg7_m;
MCNUM W = mccmg7_W;
MCNUM nslit = mccmg7_nslit;
MCNUM d = mccmg7_d;
MCNUM mleft = mccmg7_mleft;
MCNUM mright = mccmg7_mright;
MCNUM mtop = mccmg7_mtop;
MCNUM mbottom = mccmg7_mbottom;
MCNUM nhslit = mccmg7_nhslit;
MCNUM G = mccmg7_G;
MCNUM aleft = mccmg7_aleft;
MCNUM aright = mccmg7_aright;
MCNUM atop = mccmg7_atop;
MCNUM abottom = mccmg7_abottom;
MCNUM wavy = mccmg7_wavy;
MCNUM wavy_z = mccmg7_wavy_z;
MCNUM wavy_tb = mccmg7_wavy_tb;
MCNUM wavy_lr = mccmg7_wavy_lr;
MCNUM chamfers = mccmg7_chamfers;
MCNUM chamfers_z = mccmg7_chamfers_z;
MCNUM chamfers_lr = mccmg7_chamfers_lr;
MCNUM chamfers_tb = mccmg7_chamfers_tb;
MCNUM nelements = mccmg7_nelements;
MCNUM nu = mccmg7_nu;
MCNUM phase = mccmg7_phase;
char* reflect = mccmg7_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82659 "ILL_H15_D11.c"
}   /* End of mg7=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'mg8'. */
  SIG_MESSAGE("mg8 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "mg8");
#define mccompcurname  mg8
#define mccompcurtype  Guide_gravity
#define mccompcurindex 92
#define GVars mccmg8_GVars
#define pTable mccmg8_pTable
{   /* Declarations of mg8=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg8_w1;
MCNUM h1 = mccmg8_h1;
MCNUM w2 = mccmg8_w2;
MCNUM h2 = mccmg8_h2;
MCNUM l = mccmg8_l;
MCNUM R0 = mccmg8_R0;
MCNUM Qc = mccmg8_Qc;
MCNUM alpha = mccmg8_alpha;
MCNUM m = mccmg8_m;
MCNUM W = mccmg8_W;
MCNUM nslit = mccmg8_nslit;
MCNUM d = mccmg8_d;
MCNUM mleft = mccmg8_mleft;
MCNUM mright = mccmg8_mright;
MCNUM mtop = mccmg8_mtop;
MCNUM mbottom = mccmg8_mbottom;
MCNUM nhslit = mccmg8_nhslit;
MCNUM G = mccmg8_G;
MCNUM aleft = mccmg8_aleft;
MCNUM aright = mccmg8_aright;
MCNUM atop = mccmg8_atop;
MCNUM abottom = mccmg8_abottom;
MCNUM wavy = mccmg8_wavy;
MCNUM wavy_z = mccmg8_wavy_z;
MCNUM wavy_tb = mccmg8_wavy_tb;
MCNUM wavy_lr = mccmg8_wavy_lr;
MCNUM chamfers = mccmg8_chamfers;
MCNUM chamfers_z = mccmg8_chamfers_z;
MCNUM chamfers_lr = mccmg8_chamfers_lr;
MCNUM chamfers_tb = mccmg8_chamfers_tb;
MCNUM nelements = mccmg8_nelements;
MCNUM nu = mccmg8_nu;
MCNUM phase = mccmg8_phase;
char* reflect = mccmg8_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82773 "ILL_H15_D11.c"
}   /* End of mg8=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'mg9'. */
  SIG_MESSAGE("mg9 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "mg9");
#define mccompcurname  mg9
#define mccompcurtype  Guide_gravity
#define mccompcurindex 93
#define GVars mccmg9_GVars
#define pTable mccmg9_pTable
{   /* Declarations of mg9=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg9_w1;
MCNUM h1 = mccmg9_h1;
MCNUM w2 = mccmg9_w2;
MCNUM h2 = mccmg9_h2;
MCNUM l = mccmg9_l;
MCNUM R0 = mccmg9_R0;
MCNUM Qc = mccmg9_Qc;
MCNUM alpha = mccmg9_alpha;
MCNUM m = mccmg9_m;
MCNUM W = mccmg9_W;
MCNUM nslit = mccmg9_nslit;
MCNUM d = mccmg9_d;
MCNUM mleft = mccmg9_mleft;
MCNUM mright = mccmg9_mright;
MCNUM mtop = mccmg9_mtop;
MCNUM mbottom = mccmg9_mbottom;
MCNUM nhslit = mccmg9_nhslit;
MCNUM G = mccmg9_G;
MCNUM aleft = mccmg9_aleft;
MCNUM aright = mccmg9_aright;
MCNUM atop = mccmg9_atop;
MCNUM abottom = mccmg9_abottom;
MCNUM wavy = mccmg9_wavy;
MCNUM wavy_z = mccmg9_wavy_z;
MCNUM wavy_tb = mccmg9_wavy_tb;
MCNUM wavy_lr = mccmg9_wavy_lr;
MCNUM chamfers = mccmg9_chamfers;
MCNUM chamfers_z = mccmg9_chamfers_z;
MCNUM chamfers_lr = mccmg9_chamfers_lr;
MCNUM chamfers_tb = mccmg9_chamfers_tb;
MCNUM nelements = mccmg9_nelements;
MCNUM nu = mccmg9_nu;
MCNUM phase = mccmg9_phase;
char* reflect = mccmg9_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 82887 "ILL_H15_D11.c"
}   /* End of mg9=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'mg10'. */
  SIG_MESSAGE("mg10 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "mg10");
#define mccompcurname  mg10
#define mccompcurtype  Guide_gravity
#define mccompcurindex 94
#define GVars mccmg10_GVars
#define pTable mccmg10_pTable
{   /* Declarations of mg10=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg10_w1;
MCNUM h1 = mccmg10_h1;
MCNUM w2 = mccmg10_w2;
MCNUM h2 = mccmg10_h2;
MCNUM l = mccmg10_l;
MCNUM R0 = mccmg10_R0;
MCNUM Qc = mccmg10_Qc;
MCNUM alpha = mccmg10_alpha;
MCNUM m = mccmg10_m;
MCNUM W = mccmg10_W;
MCNUM nslit = mccmg10_nslit;
MCNUM d = mccmg10_d;
MCNUM mleft = mccmg10_mleft;
MCNUM mright = mccmg10_mright;
MCNUM mtop = mccmg10_mtop;
MCNUM mbottom = mccmg10_mbottom;
MCNUM nhslit = mccmg10_nhslit;
MCNUM G = mccmg10_G;
MCNUM aleft = mccmg10_aleft;
MCNUM aright = mccmg10_aright;
MCNUM atop = mccmg10_atop;
MCNUM abottom = mccmg10_abottom;
MCNUM wavy = mccmg10_wavy;
MCNUM wavy_z = mccmg10_wavy_z;
MCNUM wavy_tb = mccmg10_wavy_tb;
MCNUM wavy_lr = mccmg10_wavy_lr;
MCNUM chamfers = mccmg10_chamfers;
MCNUM chamfers_z = mccmg10_chamfers_z;
MCNUM chamfers_lr = mccmg10_chamfers_lr;
MCNUM chamfers_tb = mccmg10_chamfers_tb;
MCNUM nelements = mccmg10_nelements;
MCNUM nu = mccmg10_nu;
MCNUM phase = mccmg10_phase;
char* reflect = mccmg10_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83001 "ILL_H15_D11.c"
}   /* End of mg10=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'mg11'. */
  SIG_MESSAGE("mg11 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "mg11");
#define mccompcurname  mg11
#define mccompcurtype  Guide_gravity
#define mccompcurindex 95
#define GVars mccmg11_GVars
#define pTable mccmg11_pTable
{   /* Declarations of mg11=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg11_w1;
MCNUM h1 = mccmg11_h1;
MCNUM w2 = mccmg11_w2;
MCNUM h2 = mccmg11_h2;
MCNUM l = mccmg11_l;
MCNUM R0 = mccmg11_R0;
MCNUM Qc = mccmg11_Qc;
MCNUM alpha = mccmg11_alpha;
MCNUM m = mccmg11_m;
MCNUM W = mccmg11_W;
MCNUM nslit = mccmg11_nslit;
MCNUM d = mccmg11_d;
MCNUM mleft = mccmg11_mleft;
MCNUM mright = mccmg11_mright;
MCNUM mtop = mccmg11_mtop;
MCNUM mbottom = mccmg11_mbottom;
MCNUM nhslit = mccmg11_nhslit;
MCNUM G = mccmg11_G;
MCNUM aleft = mccmg11_aleft;
MCNUM aright = mccmg11_aright;
MCNUM atop = mccmg11_atop;
MCNUM abottom = mccmg11_abottom;
MCNUM wavy = mccmg11_wavy;
MCNUM wavy_z = mccmg11_wavy_z;
MCNUM wavy_tb = mccmg11_wavy_tb;
MCNUM wavy_lr = mccmg11_wavy_lr;
MCNUM chamfers = mccmg11_chamfers;
MCNUM chamfers_z = mccmg11_chamfers_z;
MCNUM chamfers_lr = mccmg11_chamfers_lr;
MCNUM chamfers_tb = mccmg11_chamfers_tb;
MCNUM nelements = mccmg11_nelements;
MCNUM nu = mccmg11_nu;
MCNUM phase = mccmg11_phase;
char* reflect = mccmg11_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83115 "ILL_H15_D11.c"
}   /* End of mg11=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'mg12'. */
  SIG_MESSAGE("mg12 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "mg12");
#define mccompcurname  mg12
#define mccompcurtype  Guide_gravity
#define mccompcurindex 96
#define GVars mccmg12_GVars
#define pTable mccmg12_pTable
{   /* Declarations of mg12=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg12_w1;
MCNUM h1 = mccmg12_h1;
MCNUM w2 = mccmg12_w2;
MCNUM h2 = mccmg12_h2;
MCNUM l = mccmg12_l;
MCNUM R0 = mccmg12_R0;
MCNUM Qc = mccmg12_Qc;
MCNUM alpha = mccmg12_alpha;
MCNUM m = mccmg12_m;
MCNUM W = mccmg12_W;
MCNUM nslit = mccmg12_nslit;
MCNUM d = mccmg12_d;
MCNUM mleft = mccmg12_mleft;
MCNUM mright = mccmg12_mright;
MCNUM mtop = mccmg12_mtop;
MCNUM mbottom = mccmg12_mbottom;
MCNUM nhslit = mccmg12_nhslit;
MCNUM G = mccmg12_G;
MCNUM aleft = mccmg12_aleft;
MCNUM aright = mccmg12_aright;
MCNUM atop = mccmg12_atop;
MCNUM abottom = mccmg12_abottom;
MCNUM wavy = mccmg12_wavy;
MCNUM wavy_z = mccmg12_wavy_z;
MCNUM wavy_tb = mccmg12_wavy_tb;
MCNUM wavy_lr = mccmg12_wavy_lr;
MCNUM chamfers = mccmg12_chamfers;
MCNUM chamfers_z = mccmg12_chamfers_z;
MCNUM chamfers_lr = mccmg12_chamfers_lr;
MCNUM chamfers_tb = mccmg12_chamfers_tb;
MCNUM nelements = mccmg12_nelements;
MCNUM nu = mccmg12_nu;
MCNUM phase = mccmg12_phase;
char* reflect = mccmg12_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83229 "ILL_H15_D11.c"
}   /* End of mg12=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'mg13'. */
  SIG_MESSAGE("mg13 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "mg13");
#define mccompcurname  mg13
#define mccompcurtype  Guide_gravity
#define mccompcurindex 97
#define GVars mccmg13_GVars
#define pTable mccmg13_pTable
{   /* Declarations of mg13=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg13_w1;
MCNUM h1 = mccmg13_h1;
MCNUM w2 = mccmg13_w2;
MCNUM h2 = mccmg13_h2;
MCNUM l = mccmg13_l;
MCNUM R0 = mccmg13_R0;
MCNUM Qc = mccmg13_Qc;
MCNUM alpha = mccmg13_alpha;
MCNUM m = mccmg13_m;
MCNUM W = mccmg13_W;
MCNUM nslit = mccmg13_nslit;
MCNUM d = mccmg13_d;
MCNUM mleft = mccmg13_mleft;
MCNUM mright = mccmg13_mright;
MCNUM mtop = mccmg13_mtop;
MCNUM mbottom = mccmg13_mbottom;
MCNUM nhslit = mccmg13_nhslit;
MCNUM G = mccmg13_G;
MCNUM aleft = mccmg13_aleft;
MCNUM aright = mccmg13_aright;
MCNUM atop = mccmg13_atop;
MCNUM abottom = mccmg13_abottom;
MCNUM wavy = mccmg13_wavy;
MCNUM wavy_z = mccmg13_wavy_z;
MCNUM wavy_tb = mccmg13_wavy_tb;
MCNUM wavy_lr = mccmg13_wavy_lr;
MCNUM chamfers = mccmg13_chamfers;
MCNUM chamfers_z = mccmg13_chamfers_z;
MCNUM chamfers_lr = mccmg13_chamfers_lr;
MCNUM chamfers_tb = mccmg13_chamfers_tb;
MCNUM nelements = mccmg13_nelements;
MCNUM nu = mccmg13_nu;
MCNUM phase = mccmg13_phase;
char* reflect = mccmg13_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83343 "ILL_H15_D11.c"
}   /* End of mg13=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'mg14'. */
  SIG_MESSAGE("mg14 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "mg14");
#define mccompcurname  mg14
#define mccompcurtype  Guide_gravity
#define mccompcurindex 98
#define GVars mccmg14_GVars
#define pTable mccmg14_pTable
{   /* Declarations of mg14=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg14_w1;
MCNUM h1 = mccmg14_h1;
MCNUM w2 = mccmg14_w2;
MCNUM h2 = mccmg14_h2;
MCNUM l = mccmg14_l;
MCNUM R0 = mccmg14_R0;
MCNUM Qc = mccmg14_Qc;
MCNUM alpha = mccmg14_alpha;
MCNUM m = mccmg14_m;
MCNUM W = mccmg14_W;
MCNUM nslit = mccmg14_nslit;
MCNUM d = mccmg14_d;
MCNUM mleft = mccmg14_mleft;
MCNUM mright = mccmg14_mright;
MCNUM mtop = mccmg14_mtop;
MCNUM mbottom = mccmg14_mbottom;
MCNUM nhslit = mccmg14_nhslit;
MCNUM G = mccmg14_G;
MCNUM aleft = mccmg14_aleft;
MCNUM aright = mccmg14_aright;
MCNUM atop = mccmg14_atop;
MCNUM abottom = mccmg14_abottom;
MCNUM wavy = mccmg14_wavy;
MCNUM wavy_z = mccmg14_wavy_z;
MCNUM wavy_tb = mccmg14_wavy_tb;
MCNUM wavy_lr = mccmg14_wavy_lr;
MCNUM chamfers = mccmg14_chamfers;
MCNUM chamfers_z = mccmg14_chamfers_z;
MCNUM chamfers_lr = mccmg14_chamfers_lr;
MCNUM chamfers_tb = mccmg14_chamfers_tb;
MCNUM nelements = mccmg14_nelements;
MCNUM nu = mccmg14_nu;
MCNUM phase = mccmg14_phase;
char* reflect = mccmg14_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83457 "ILL_H15_D11.c"
}   /* End of mg14=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'mg15'. */
  SIG_MESSAGE("mg15 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "mg15");
#define mccompcurname  mg15
#define mccompcurtype  Guide_gravity
#define mccompcurindex 99
#define GVars mccmg15_GVars
#define pTable mccmg15_pTable
{   /* Declarations of mg15=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg15_w1;
MCNUM h1 = mccmg15_h1;
MCNUM w2 = mccmg15_w2;
MCNUM h2 = mccmg15_h2;
MCNUM l = mccmg15_l;
MCNUM R0 = mccmg15_R0;
MCNUM Qc = mccmg15_Qc;
MCNUM alpha = mccmg15_alpha;
MCNUM m = mccmg15_m;
MCNUM W = mccmg15_W;
MCNUM nslit = mccmg15_nslit;
MCNUM d = mccmg15_d;
MCNUM mleft = mccmg15_mleft;
MCNUM mright = mccmg15_mright;
MCNUM mtop = mccmg15_mtop;
MCNUM mbottom = mccmg15_mbottom;
MCNUM nhslit = mccmg15_nhslit;
MCNUM G = mccmg15_G;
MCNUM aleft = mccmg15_aleft;
MCNUM aright = mccmg15_aright;
MCNUM atop = mccmg15_atop;
MCNUM abottom = mccmg15_abottom;
MCNUM wavy = mccmg15_wavy;
MCNUM wavy_z = mccmg15_wavy_z;
MCNUM wavy_tb = mccmg15_wavy_tb;
MCNUM wavy_lr = mccmg15_wavy_lr;
MCNUM chamfers = mccmg15_chamfers;
MCNUM chamfers_z = mccmg15_chamfers_z;
MCNUM chamfers_lr = mccmg15_chamfers_lr;
MCNUM chamfers_tb = mccmg15_chamfers_tb;
MCNUM nelements = mccmg15_nelements;
MCNUM nu = mccmg15_nu;
MCNUM phase = mccmg15_phase;
char* reflect = mccmg15_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83571 "ILL_H15_D11.c"
}   /* End of mg15=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'mg16'. */
  SIG_MESSAGE("mg16 (McDisplay)");
  printf("MCDISPLAY: component %s\n", "mg16");
#define mccompcurname  mg16
#define mccompcurtype  Guide_gravity
#define mccompcurindex 100
#define GVars mccmg16_GVars
#define pTable mccmg16_pTable
{   /* Declarations of mg16=Guide_gravity() SETTING parameters. */
MCNUM w1 = mccmg16_w1;
MCNUM h1 = mccmg16_h1;
MCNUM w2 = mccmg16_w2;
MCNUM h2 = mccmg16_h2;
MCNUM l = mccmg16_l;
MCNUM R0 = mccmg16_R0;
MCNUM Qc = mccmg16_Qc;
MCNUM alpha = mccmg16_alpha;
MCNUM m = mccmg16_m;
MCNUM W = mccmg16_W;
MCNUM nslit = mccmg16_nslit;
MCNUM d = mccmg16_d;
MCNUM mleft = mccmg16_mleft;
MCNUM mright = mccmg16_mright;
MCNUM mtop = mccmg16_mtop;
MCNUM mbottom = mccmg16_mbottom;
MCNUM nhslit = mccmg16_nhslit;
MCNUM G = mccmg16_G;
MCNUM aleft = mccmg16_aleft;
MCNUM aright = mccmg16_aright;
MCNUM atop = mccmg16_atop;
MCNUM abottom = mccmg16_abottom;
MCNUM wavy = mccmg16_wavy;
MCNUM wavy_z = mccmg16_wavy_z;
MCNUM wavy_tb = mccmg16_wavy_tb;
MCNUM wavy_lr = mccmg16_wavy_lr;
MCNUM chamfers = mccmg16_chamfers;
MCNUM chamfers_z = mccmg16_chamfers_z;
MCNUM chamfers_lr = mccmg16_chamfers_lr;
MCNUM chamfers_tb = mccmg16_chamfers_tb;
MCNUM nelements = mccmg16_nelements;
MCNUM nu = mccmg16_nu;
MCNUM phase = mccmg16_phase;
char* reflect = mccmg16_reflect;
#line 571 "/usr/share/mcstas/2.6rc1/optics/Guide_gravity.comp"
{

  if (l > 0 && nelements > 0) {
    int i,j,n;
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double nel = (nelements > 11 ? 11 : nelements);

    
    for (n=0; n<nel; n++)
    {
      double z0, z1;
      z0 =     n*(l/nel);
      z1 = (n+1)*(l/nel);

      for(j = 0; j < nhslit; j++)
      {
        y1 = j*(GVars.h1c+d)         - h1/2.0;
        y2 = j*(GVars.h2c+d)         - h2/2.0;
        y3 = (j+1)*(GVars.h1c+d) - d - h1/2.0;
        y4 = (j+1)*(GVars.h2c+d) - d - h2/2.0;
        for(i = 0; i < nslit; i++)
        {
          x1 = i*(GVars.w1c+d)         - w1/2.0;
          x2 = i*(GVars.w2c+d)         - w2/2.0;
          x3 = (i+1)*(GVars.w1c+d) - d - w1/2.0;
          x4 = (i+1)*(GVars.w2c+d) - d - w2/2.0;
          multiline(5,
                    x1, y1, z0,
                    x2, y2, z1,
                    x2, y4, z1,
                    x1, y3, z0,
                    x1, y1, z0);
          multiline(5,
                    x3, y1, z0,
                    x4, y2, z1,
                    x4, y4, z1,
                    x3, y3, z0,
                    x3, y1, z0);
        }
        line(-w1/2.0, y1, z0, w1/2.0, y1, z0);
        line(-w2/2.0, y2, z1, w2/2.0, y2, z1);
      }
    }

    if (nu || phase) {
      double radius = sqrt(w1*w1+l*l);
      /* cylinder top/center/bottom  */
      circle("xz", 0,-h1/2,l/2,radius);
      circle("xz", 0,0    ,l/2,radius);
      circle("xz", 0, h1/2,l/2,radius);
    }
  }
  else {
    /* A bit ugly; hard-coded dimensions. */
    
    line(0,0,0,0.2,0,0);
    line(0,0,0,0,0.2,0);
    line(0,0,0,0,0,0.2);
  }

}
#line 83685 "ILL_H15_D11.c"
}   /* End of mg16=Guide_gravity() SETTING parameter declarations. */
#undef pTable
#undef GVars
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'SampleF'. */
  SIG_MESSAGE("SampleF (McDisplay)");
  printf("MCDISPLAY: component %s\n", "SampleF");
#define mccompcurname  SampleF
#define mccompcurtype  Monitor_nD
#define mccompcurindex 101
#define user1 mccSampleF_user1
#define user2 mccSampleF_user2
#define user3 mccSampleF_user3
#define DEFS mccSampleF_DEFS
#define Vars mccSampleF_Vars
#define detector mccSampleF_detector
#define offdata mccSampleF_offdata
{   /* Declarations of SampleF=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccSampleF_xwidth;
MCNUM yheight = mccSampleF_yheight;
MCNUM zdepth = mccSampleF_zdepth;
MCNUM xmin = mccSampleF_xmin;
MCNUM xmax = mccSampleF_xmax;
MCNUM ymin = mccSampleF_ymin;
MCNUM ymax = mccSampleF_ymax;
MCNUM zmin = mccSampleF_zmin;
MCNUM zmax = mccSampleF_zmax;
MCNUM bins = mccSampleF_bins;
MCNUM min = mccSampleF_min;
MCNUM max = mccSampleF_max;
MCNUM restore_neutron = mccSampleF_restore_neutron;
MCNUM radius = mccSampleF_radius;
char* options = mccSampleF_options;
char* filename = mccSampleF_filename;
char* geometry = mccSampleF_geometry;
char* username1 = mccSampleF_username1;
char* username2 = mccSampleF_username2;
char* username3 = mccSampleF_username3;
int nowritefile = mccSampleF_nowritefile;
#line 496 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    off_display(offdata);
  } else {
    Monitor_nD_McDisplay(&DEFS, &Vars);
  }
}
#line 83737 "ILL_H15_D11.c"
}   /* End of SampleF=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  /* MCDISPLAY code for component 'SampleC'. */
  SIG_MESSAGE("SampleC (McDisplay)");
  printf("MCDISPLAY: component %s\n", "SampleC");
#define mccompcurname  SampleC
#define mccompcurtype  Monitor_nD
#define mccompcurindex 102
#define user1 mccSampleC_user1
#define user2 mccSampleC_user2
#define user3 mccSampleC_user3
#define DEFS mccSampleC_DEFS
#define Vars mccSampleC_Vars
#define detector mccSampleC_detector
#define offdata mccSampleC_offdata
{   /* Declarations of SampleC=Monitor_nD() SETTING parameters. */
MCNUM xwidth = mccSampleC_xwidth;
MCNUM yheight = mccSampleC_yheight;
MCNUM zdepth = mccSampleC_zdepth;
MCNUM xmin = mccSampleC_xmin;
MCNUM xmax = mccSampleC_xmax;
MCNUM ymin = mccSampleC_ymin;
MCNUM ymax = mccSampleC_ymax;
MCNUM zmin = mccSampleC_zmin;
MCNUM zmax = mccSampleC_zmax;
MCNUM bins = mccSampleC_bins;
MCNUM min = mccSampleC_min;
MCNUM max = mccSampleC_max;
MCNUM restore_neutron = mccSampleC_restore_neutron;
MCNUM radius = mccSampleC_radius;
char* options = mccSampleC_options;
char* filename = mccSampleC_filename;
char* geometry = mccSampleC_geometry;
char* username1 = mccSampleC_username1;
char* username2 = mccSampleC_username2;
char* username3 = mccSampleC_username3;
int nowritefile = mccSampleC_nowritefile;
#line 496 "/usr/share/mcstas/2.6rc1/monitors/Monitor_nD.comp"
{
  if (geometry && strlen(geometry) && strcmp(geometry,"0") && strcmp(geometry, "NULL"))
  {
    off_display(offdata);
  } else {
    Monitor_nD_McDisplay(&DEFS, &Vars);
  }
}
#line 83794 "ILL_H15_D11.c"
}   /* End of SampleC=Monitor_nD() SETTING parameter declarations. */
#undef offdata
#undef detector
#undef Vars
#undef DEFS
#undef user3
#undef user2
#undef user1
#undef mccompcurname
#undef mccompcurtype
#undef mccompcurindex

  printf("MCDISPLAY: end\n");
} /* end display */
#undef magnify
#undef line
#undef dashed_line
#undef multiline
#undef rectangle
#undef box
#undef circle
#undef cylinder
#undef sphere
/* end of generated C code ILL_H15_D11.c */
